#include "brutus.h"

#include "SDL.h"
#include "SDL_mixer.h"

#include <direct.h>
#include <stdnoreturn.h>
#include <signal.h>
#if defined (__MINGW32__)
#include <dirent.h>
#else
#include "../ext/dirent/dirent.h"
#endif

#include <math.h>
#include <stdio.h>
#include <time.h>

typedef uint32_t color_t;
typedef struct smacker_t *smacker;
typedef void (map_callback)(int x, int y, int grid_offset);
typedef void (*back_sidebar_draw_function)(void);
typedef back_sidebar_draw_function slide_finished_function;
typedef void (*front_sidebar_draw_function)(int x_offset);

#define SETTINGS_MAX_ENTRIES 17

#define INTPTR(d) (*(int*)(d))
#define MSG_SIZE 1000
#define BUILD_MENU_BUTTONS_COUNT 12
#define MAX_ITEMS_PER_BUILD_MENU 11
#define MAX_ITEMS_PER_SUBMENU 6
#define NO_COLUMN -1
#define SIDEBAR_COLLAPSED_WIDTH 42
#define SIDEBAR_EXPANDED_WIDTH 162
#define SIDEBAR_MAIN_SECTION_HEIGHT 450
#define SIDEBAR_FILLER_Y_OFFSET (SIDEBAR_MAIN_SECTION_HEIGHT + TOP_MENU_HEIGHT)
#define MINIMAP_WIDTH 146
#define MINIMAP_HEIGHT 111
#define CHANNEL_FILENAME_MAX 32
#define MAX_INVASION_WARNINGS 101
#define MAX_PLAYER_NAME 24
#define MAX_SCENARIO_NAME 65
#define MAX_BRIEF_DESCRIPTION 32
#define MAX_BRIEFING 2500
#define MAX_REQUESTS 40
#define MAX_EDITOR_CUSTOM_MESSAGES 45
#define MAX_EARTHQUAKE_POINTS 8
#define MAX_EARTHQUAKES 10
#define MAX_EARTHQUAKE_BRANCHES 4
#define MAX_INVASION_POINTS 8
#define MAX_INVASIONS 40
#define ENEMY_TYPE_MAX_COUNT 20
#define MAX_PRICE_CHANGES 40
#define MAX_DEMAND_CHANGES 40
#define MAX_CUSTOM_MESSAGE_TITLE 30
#define MAX_CUSTOM_MESSAGE_TEXT 1000
#define MAX_CUSTOM_MESSAGE_VIDEO_TEXT 24
#define MAX_HERD_POINTS 8
#define MAX_FISH_POINTS 8
#define OFFSET(x,y) (x + GRID_SIZE * y)
#define COLOR_BLACK 0x000000
#define COLOR_RED 0xff0000
#define COLOR_WHITE 0xffffff
#define COLOR_SG2_TRANSPARENT 0xf700ff
#define COLOR_TOOLTIP 0x424242
#define COLOR_SIDEBAR 0xbdb592
#define COLOR_FONT_RED COLOR_RED
#define COLOR_FONT_BLUE 0x0055ff
#define COLOR_FONT_YELLOW 0xe7e75a
#define COLOR_FONT_ORANGE 0xff5a08
#define COLOR_FONT_ORANGE_LIGHT 0xffa500
#define COLOR_FONT_LIGHT_GRAY 0xb3b3b3
#define COLOR_INSET_LIGHT 0xffffff
#define COLOR_INSET_DARK 0x848484
#define COLOR_MASK_NONE 0xffffff
#define COLOR_MASK_RED 0xff0818
#define COLOR_MASK_GREEN 0x18ff18
#define COLOR_MASK_BLUE 0x663377ff
#define COLOR_MASK_LEGION_HIGHLIGHT 0x66ff3300
#define COLOR_MINIMAP_VIEWPORT 0xe7e75a
#define COLOR_MINIMAP_DARK 0x424242
#define COLOR_MINIMAP_LIGHT 0xc6c6c6
#define COLOR_MINIMAP_SOLDIER 0xf70000
#define COLOR_MINIMAP_SELECTED_SOLDIER 0xffffff
#define COLOR_MINIMAP_ENEMY_CENTRAL 0x7b0000
#define COLOR_MINIMAP_ENEMY_NORTHERN 0x1800ff
#define COLOR_MINIMAP_ENEMY_DESERT 0x08007b
#define COLOR_MINIMAP_WOLF COLOR_BLACK
#define COLOR_MOUSE_DARK_GRAY 0x3f3f3f
#define COLOR_MOUSE_MEDIUM_GRAY 0x737373
#define COLOR_MOUSE_LIGHT_GRAY 0xb3b3b3
#define ALPHA_OPAQUE 0xff000000
#define ALPHA_FONT_SEMI_TRANSPARENT 0x99000000
#define ALPHA_MASK_SEMI_TRANSPARENT 0x48000000
#define ALPHA_TRANSPARENT 0x00000000
#define BLOCK_SIZE 16
#define TOP_MENU_HEIGHT 24
#define MAX_FORMATION_FIGURES 16
#define ROUT_MORALE_THRESHOLD 20
#define MAX_LEGIONS 6
#define WOLF_PACK_SIZE 8
#define MAX_WOLF_ROAM_DISTANCE 16
#define WOLF_PACK_ROAM_DELAY 12
#define SHEEP_HERD_SIZE 10
#define MAX_SHEEP_ROAM_DISTANCE 8
#define SHEEP_HERD_ROAM_DELAY 24
#define ZEBRA_HERD_SIZE 12
#define MAX_ZEBRA_ROAM_DISTANCE 20
#define ZEBRA_HERD_ROAM_DELAY 6
#define MAX_ENEMY_FORMATIONS 100
#define MAX_FIGURES 1000
#define MAX_RANGED_TARGETERS_PER_UNIT 4
#define MAX_MELEE_TARGETERS_PER_UNIT 4
#define MAX_MELEE_COMBATANTS_PER_UNIT 4
#define PREFECT_TARGET_ACQUISITION_RANGE 15
#define MAX_EMPIRE_OBJECTS 200
#define SPEED_CHANGE_IMMEDIATE 0
#define MAX_NUM_FILES 128
#define FILE_NAME_MAX 64
#define DIR_PATH_MAX 255
#define CONFIG_STRING_VALUE_MAX 32
#define MAX_PLAYER_NAME_LENGTH 24
#define RESOURCE_TYPES_MAX 16
#define FOOD_TYPES_MAX 7
#define COIN_IMAGE_ID 1202
#define EMPTY_WAREHOUSE_IMG_ID 3337
#define EMPTY_CART_IMG_ID 4650
#define MAX_GODS 5
#define VIEW_X_MAX 165
#define VIEW_Y_MAX 325
#define TILE_WIDTH_PIXELS 60
#define TILE_HEIGHT_PIXELS 30
#define HALF_TILE_WIDTH_PIXELS 30
#define HALF_TILE_HEIGHT_PIXELS 15
#define MAX_WARNINGS 5
#define MAX_BUILDINGS 2000
#define MAX_HOUSE_TYPES 20
#define MAX_PROGRESS_WORKSHOP 400
#define MAX_PROGRESS_RAW 200
#define INFINITE 10000
#define UNITS_PER_LOAD 100
#define ONE_LOAD 100
#define CHIEF_ADVISOR_HEIGHT 23
#define X_OFFSET 232
#define MAX_ITEMS_PER_LIST 20
#define GROUP 5
#define PROCEED_GROUP 43
#define PROCEED_TEXT 5
#define MENU_X_OFFSET_OVERLAY_MENU 170
#define SUBMENU_X_OFFSET 348
#define MENU_Y_OFFSET_OVERLAY_MENU 72
#define MENU_CLICK_MARGIN 20
#define MAX_BUTTONS_OVERLAY_MENU 8
#define MAX_MESSAGES_IN_WINDOW 10
#define MAX_HISTORY 200
#define MAX_EDITOR_FILES 9
#define MAX_BUTTONS_MAIN_MENU 5
#define NUM_INTRO_VIDEOS 3
#define DISPLAY_TIME_MILLIS 1000
#define NUM_BOTTOM_BUTTONS_HOTKEY_EDITOR_WINDOW 2
#define HOTKEY_HEADER -1
#define TR_NONE -1
#define GROUP_BUILDINGS 28
#define NUM_VISIBLE_OPTIONS 14
#define NUM_BOTTOM_BUTTONS_HOTKEY_CONFIG_WINDOW 3
#define HOTKEY_X_OFFSET_1 270
#define HOTKEY_X_OFFSET_2 420
#define HOTKEY_BTN_WIDTH 150
#define HOTKEY_BTN_HEIGHT 22
#define NUM_FILES_IN_VIEW 12
#define MAX_FILE_WINDOW_TEXT_WIDTH (18 * BLOCK_SIZE)
#define MAX_WIDTH 2032
#define MAX_HEIGHT 1136
#define MAX_WIDGETS 13
#define NUM_VISIBLE_ITEMS 16
#define NUM_BOTTOM_BUTTONS_WINDOW_CONFIG 4
#define ITEM_Y_OFFSET 60
#define ITEM_HEIGHT 24
#define CHECKBOX_CHECK_SIZE 20
#define CHECKBOX_HEIGHT 20
#define CHECKBOX_WIDTH 560
#define CHECKBOX_TEXT_WIDTH CHECKBOX_WIDTH - CHECKBOX_CHECK_SIZE - 15
#define NUMERICAL_RANGE_X 20
#define NUMERICAL_SLIDER_X 50
#define NUMERICAL_SLIDER_PADDING 2
#define NUMERICAL_DOT_SIZE 20
#define MAX_SCENARIOS 15
#define MENU_X_OFFSET_BUILD_MENU 258
#define MENU_Y_OFFSET_BUILD_MENU 110
#define MENU_ITEM_WIDTH 176
#define MENU_CLICK_MARGIN 20
#define TRADE_ADVISOR_HEIGHT 27
#define RATINGS_ADVISOR_HEIGHT 27
#define POPULATION_ADVISOR_HEIGHT 27
#define MILITARY_ADVISOR_HEIGHT 26
#define IMPERIAL_ADVISOR_HEIGHT 27
#define MAX_REQUESTS_SHOWN 5
#define HEALTH_ADVISOR_HEIGHT 18
#define FINANCIAL_ADVISOR_HEIGHT 26
#define ENTERTAINMENT_ADVISOR_HEIGHT 23
#define PEOPLE_OFFSET 330
#define COVERAGE_OFFSET 470
#define COVERAGE_WIDTH 130
#define EDUCATION_ADVISOR_HEIGHT 16
#define MAX_TILES_BUILDING_PREVIEW 25
#define SLIDE_SPEED 7
#define SLIDE_ACCELERATION_MILLIS 65
#define SIDEBAR_DECELERATION_OFFSET 125
#define EXTRA_INFO_LINE_SPACE 16
#define EXTRA_INFO_HEIGHT_GAME_SPEED 64
#define EXTRA_INFO_HEIGHT_UNEMPLOYMENT 48
#define EXTRA_INFO_HEIGHT_RATINGS 176
#define EXTRA_INFO_VERTICAL_PADDING 8
#define MINIMAP_Y_OFFSET 59
#define MAX_CITY_SOUNDS_CHANNELS 70
#define MAX_DEVICE_CHANNELS 151
#define AUDIO_RATE 22050
#define AUDIO_FORMAT AUDIO_S16
#define AUDIO_CHANNELS 2
#define AUDIO_BUFFERS 1024
#define MAX_ENEMY_TYPES_PER_ARMY 3
#define MAX_BOOKMARKS 4
#define MAX_TILES_TERRAIN 8
#define MAX_PATH 500
#define MAX_QUEUE_ROUTING GRID_SIZE * GRID_SIZE
#define GUARD 50000
#define UNTIL_STOP 0
#define UNTIL_CONTINUE 1
#define FORBIDDEN_TERRAIN_MEADOW (TERRAIN_AQUEDUCT | TERRAIN_ELEVATION | TERRAIN_ACCESS_RAMP | TERRAIN_RUBBLE | TERRAIN_ROAD | TERRAIN_BUILDING | TERRAIN_GARDEN)
#define FORBIDDEN_TERRAIN_RUBBLE (TERRAIN_AQUEDUCT | TERRAIN_ELEVATION | TERRAIN_ACCESS_RAMP | TERRAIN_ROAD | TERRAIN_BUILDING | TERRAIN_GARDEN)
#define MAX_QUEUE 1000
#define DOUBLE_CLICK_TIME 300
#define MOUSE_BORDER 5
#define TOUCH_BORDER 100
#define SCROLL_DRAG_MIN_DELTA 4
#define SCROLL_KEY_PRESSED 1
#define SCROLL_KEY_MAX_VALUE 30000.0f
#define PRESSED_EFFECT_MILLIS 100
#define PRESSED_REPEAT_INITIAL_MILLIS 300
#define PRESSED_REPEAT_MILLIS 50
#define FOOTPRINT_WIDTH 58
#define FOOTPRINT_HEIGHT 30
#define COMPONENT(c, shift) ((c >> shift) & 0xff)
#define MIX_RB(src, dst, alpha) ((((src & 0xff00ff) * alpha + (dst & 0xff00ff) * (256 - alpha)) >> 8) & 0xff00ff)
#define MIX_G(src, dst, alpha) ((((src & 0x00ff00) * alpha + (dst & 0x00ff00) * (256 - alpha)) >> 8) & 0x00ff00)
#define TOP_MENU_BASE_X_OFFSET 10
#define MENU_BASE_TEXT_Y_OFFSET 6
#define TOP_MENU_ITEM_HEIGHT 20
#define MAX_LINKS 50
#define HEADER_SIZE_BMP 26
#define TILE_X_SIZE 60
#define TILE_Y_SIZE 30
#define IMAGE_HEIGHT_CHUNK TILE_Y_SIZE
#define BMP_BITS_PER_PIXEL 24
#define BMP_BYTES_PER_PIXEL (BMP_BITS_PER_PIXEL / 8)
#define SCROLL_BUTTON_HEIGHT 26
#define SCROLL_BUTTON_WIDTH 39
#define SCROLL_DOT_SIZE 25
#define TOTAL_BUTTON_HEIGHT (2 * SCROLL_BUTTON_HEIGHT + SCROLL_DOT_SIZE)
#define ELLIPSIS_LENGTH 4
#define NUMBER_BUFFER_LENGTH 100
#define MAX_WINDOW_QUEUE 3
#define MAX_HOUSE_LEVELS 20
#define MAX_ANIM_TIMERS 51
#define COMPRESS_BUFFER_SIZE 600000
#define UNCOMPRESSED 0x80000000
#define INF_SIZE 62
#define MAX_TICKS_PER_FRAME 20
#define MAX_DIR 4
#define MAX_UNDO_BUILDINGS 50
#define PREFECT_LEASH_RANGE 20
#define MAP_FLAG_IMG_ID 2916
#define MAX_TRADERS 100
#define MAX_COVERAGE 96
#define MAX_PATH_LENGTH 500
#define MAX_ROUTES 600
#define MENU_X_OFFSET 170
#define MENU_Y_OFFSET 110
#define MENU_ITEM_HEIGHT 24
#define MENU_ITEM_WIDTH_EDITOR 160
#define MENU_CLICK_MARGIN 20
#define MAX_ITEMS_PER_MENU 16
#define MAX_TILES_OFFSETS 4
#define TERRAIN_NOT_DISPLACEABLE TERRAIN_ROCK | TERRAIN_WATER | TERRAIN_BUILDING | TERRAIN_ELEVATION | TERRAIN_ACCESS_RAMP
#define MAX_EMPIRE_WIDTH 2032
#define MAX_EMPIRE_HEIGHT 1136
#define MINIMAP_Y_OFFSET_EDITOR 30
#define MAX_ALLOWED_BUILDINGS 78
#define INVASION_TYPE_MAX_COUNT 5
#define MAX_DEMAND_ROUTES 20
#define DEMAND_ROUTE_MAX_NAME_LENGTH 50
#define FRAME_TIME 16.67
#define HEADER_SIZE_SMACKER 104
#define MAX_TRACKS 7
#define MAX_PALETTE 256
#define FLAG_Y_INTERLACE 0x02
#define FLAG_Y_DOUBLE 0x04
#define AUDIO_MASK_RATE 0xFFFFFF
#define AUDIO_FLAG_STEREO 0x10000000
#define AUDIO_FLAG_16BIT 0x20000000
#define AUDIO_FLAG_HAS_TRACK 0x40000000
#define AUDIO_FLAG_COMPRESSED 0x80000000
#define BLOCK_MONO 0
#define BLOCK_FULL 1
#define BLOCK_SOLID 3
#define MAX_RANDOM 100
#define MAX_TEXT_ENTRIES 1000
#define MAX_TEXT_DATA 200000
#define MIN_TEXT_SIZE (28 + MAX_TEXT_ENTRIES * 8)
#define MAX_TEXT_SIZE (MIN_TEXT_SIZE + MAX_TEXT_DATA)
#define MAX_MESSAGE_ENTRIES 400
#define MAX_MESSAGE_DATA 460000
#define MIN_MESSAGE_SIZE 32024
#define MAX_MESSAGE_SIZE (MIN_MESSAGE_SIZE + MAX_MESSAGE_DATA)
#define BUFFER_SIZE 400000
#define FILE_TEXT_ENG "c3.eng"
#define FILE_MM_ENG "c3_mm.eng"
#define FILE_EDITOR_TEXT_ENG "c3_map.eng"
#define FILE_EDITOR_MM_ENG "c3_map_mm.eng"
#define HEADER_SIZE_EMPIRE 20680
#define ENTRY_SIZE 64
#define MAIN_ENTRIES 10000
#define ENEMY_ENTRIES 801
#define MAIN_INDEX_SIZE 660680
#define ENEMY_INDEX_OFFSET HEADER_SIZE_EMPIRE
#define ENEMY_INDEX_SIZE ENTRY_SIZE * ENEMY_ENTRIES
#define ENEMY_FILES_COUNT 11
#define MAIN_DATA_SIZE 30000000
#define EMPIRE_IMAGE_DATA_SIZE 8000000 // 2000*1000*4
#define ENEMY_DATA_SIZE 2400000
#define SCRATCH_DATA_SIZE 12100000
#define NAME_SIZE 32
#define MAX_LINE 100
#define MAX_MAPPINGS HOTKEY_MAX_ITEMS * 2
#define F_OK 0
#define access _access
#define TIE 10
#define CURSE_LOADS 16
#define MARS_INVASION_SMALL 16
#define MARS_INVASION_LARGE 32
#define MAX_TEXT 100
#define TIMEOUT_MS 15000
#define MAX_MESSAGES 1000
#define MAX_MESSAGE_QUEUE 20
#define MAX_MESSAGE_CATEGORIES 20
#define LABOR_CATEGORIES_COUNT 9
#define MAX_STORAGES 200
#define MAX_GRANARIES 100
#define MAX_SMALL 500
#define MAX_LARGE 2000
#define MAX_BURNING 500
#define MIN_Y_POSITION 32
#define MARGIN_POSITION 16
#define SOUND_FILENAME_MAX 32

// start enums
enum {
    CURSOR_SCALE_1 = 0,
    CURSOR_SCALE_1_5 = 1,
    CURSOR_SCALE_2 = 2,
};
enum {
    BUILDING_NONE = 0,
    BUILDING_HOUSE_VACANT_LOT = 1,
    BUILDING_HOUSE_SMALL_TENT = 2,
    BUILDING_HOUSE_LARGE_TENT = 3,
    BUILDING_HOUSE_SMALL_SHACK = 4,
    BUILDING_HOUSE_LARGE_SHACK = 5,
    BUILDING_HOUSE_SMALL_HOVEL = 6,
    BUILDING_HOUSE_LARGE_HOVEL = 7,
    BUILDING_HOUSE_SMALL_CASA = 8,
    BUILDING_HOUSE_LARGE_CASA = 9,
    BUILDING_HOUSE_SMALL_INSULA = 10,
    BUILDING_HOUSE_MEDIUM_INSULA = 11,
    BUILDING_HOUSE_LARGE_INSULA = 12,
    BUILDING_HOUSE_GRAND_INSULA = 13,
    BUILDING_HOUSE_SMALL_VILLA = 14,
    BUILDING_HOUSE_MEDIUM_VILLA = 15,
    BUILDING_HOUSE_LARGE_VILLA = 16,
    BUILDING_HOUSE_GRAND_VILLA = 17,
    BUILDING_HOUSE_SMALL_PALACE = 18,
    BUILDING_HOUSE_MEDIUM_PALACE = 19,
    BUILDING_HOUSE_LARGE_PALACE = 20,
    BUILDING_HOUSE_LUXURY_PALACE = 21,
    BUILDING_CLEAR_LAND = 22,
    BUILDING_ROAD = 23,
    BUILDING_RESERVOIR = 24,
    BUILDING_AQUEDUCT = 25,
    BUILDING_FOUNTAIN = 26,
    BUILDING_WELL = 27,
    BUILDING_DOCTOR = 28,
    BUILDING_BATHHOUSE = 29,
    BUILDING_BARBER = 30,
    BUILDING_HOSPITAL = 31,
    BUILDING_SMALL_TEMPLE_CERES = 32,
    BUILDING_SMALL_TEMPLE_NEPTUNE = 33,
    BUILDING_SMALL_TEMPLE_MERCURY = 34,
    BUILDING_SMALL_TEMPLE_MARS = 35,
    BUILDING_SMALL_TEMPLE_VENUS = 36,
    BUILDING_LARGE_TEMPLE_CERES = 37,
    BUILDING_LARGE_TEMPLE_NEPTUNE = 38,
    BUILDING_LARGE_TEMPLE_MERCURY = 39,
    BUILDING_LARGE_TEMPLE_MARS = 40,
    BUILDING_LARGE_TEMPLE_VENUS = 41,
    BUILDING_ORACLE = 42,
    BUILDING_SCHOOL = 43,
    BUILDING_LIBRARY = 44,
    BUILDING_ACADEMY = 45,
    BUILDING_MISSION_POST = 46,
    BUILDING_THEATER = 47,
    BUILDING_ACTOR_COLONY = 48,
    BUILDING_AMPHITHEATER = 49,
    BUILDING_GLADIATOR_SCHOOL = 50,
    BUILDING_LION_HOUSE = 51,
    BUILDING_COLOSSEUM = 52,
    BUILDING_CHARIOT_MAKER = 53,
    BUILDING_HIPPODROME = 54,
    BUILDING_GARDENS = 55,
    BUILDING_PLAZA = 56,
    BUILDING_SMALL_STATUE = 57,
    BUILDING_MEDIUM_STATUE = 58,
    BUILDING_LARGE_STATUE = 59,
    BUILDING_GOVERNORS_HOUSE = 60,
    BUILDING_GOVERNORS_VILLA = 61,
    BUILDING_GOVERNORS_PALACE = 62,
    BUILDING_FORUM = 63,
    BUILDING_SENATE = 64,
    BUILDING_TRIUMPHAL_ARCH = 65,
    BUILDING_ENGINEERS_POST = 66,
    BUILDING_LOW_BRIDGE = 67,
    BUILDING_SHIP_BRIDGE = 68,
    BUILDING_SHIPYARD = 69,
    BUILDING_WHARF = 70,
    BUILDING_DOCK = 71,
    BUILDING_PREFECTURE = 72,
    BUILDING_WALL = 73,
    BUILDING_TOWER = 74,
    BUILDING_GATEHOUSE = 75,
    BUILDING_FORT_LEGIONARIES = 76,
    BUILDING_FORT_JAVELIN = 77,
    BUILDING_FORT_MOUNTED = 78,
    BUILDING_BARRACKS = 79,
    BUILDING_MILITARY_ACADEMY = 80,
    BUILDING_WHEAT_FARM = 81,
    BUILDING_VEGETABLE_FARM = 82,
    BUILDING_FRUIT_FARM = 83,
    BUILDING_PIG_FARM = 84,
    BUILDING_OLIVE_FARM = 85,
    BUILDING_VINES_FARM = 86,
    BUILDING_CLAY_PIT = 87,
    BUILDING_TIMBER_YARD = 88,
    BUILDING_MARBLE_QUARRY = 89,
    BUILDING_IRON_MINE = 90,
    BUILDING_OIL_WORKSHOP = 91,
    BUILDING_WINE_WORKSHOP = 92,
    BUILDING_POTTERY_WORKSHOP = 93,
    BUILDING_FURNITURE_WORKSHOP = 94,
    BUILDING_WEAPONS_WORKSHOP = 95,
    BUILDING_MARKET = 96,
    BUILDING_GRANARY = 97,
    BUILDING_WAREHOUSE = 98,
    BUILDING_WAREHOUSE_SPACE = 99,
    BUILDING_NATIVE_HUT = 100,
    BUILDING_NATIVE_MEETING = 101,
    BUILDING_NATIVE_CROPS = 102,
    BUILDING_FORT_GROUND = 103,
    BUILDING_BURNING_RUIN = 104,
    // helper constants
    BUILDING_TYPE_MAX = 105
};
enum {
    HOUSE_SMALL_TENT = 0,
    HOUSE_LARGE_TENT = 1,
    HOUSE_SMALL_SHACK = 2,
    HOUSE_LARGE_SHACK = 3,
    HOUSE_SMALL_HOVEL = 4,
    HOUSE_LARGE_HOVEL = 5,
    HOUSE_SMALL_CASA = 6,
    HOUSE_LARGE_CASA = 7,
    HOUSE_SMALL_INSULA = 8,
    HOUSE_MEDIUM_INSULA = 9,
    HOUSE_LARGE_INSULA = 10,
    HOUSE_GRAND_INSULA = 11,
    HOUSE_SMALL_VILLA = 12,
    HOUSE_MEDIUM_VILLA = 13,
    HOUSE_LARGE_VILLA = 14,
    HOUSE_GRAND_VILLA = 15,
    HOUSE_SMALL_PALACE = 16,
    HOUSE_MEDIUM_PALACE = 17,
    HOUSE_LARGE_PALACE = 18,
    HOUSE_LUXURY_PALACE = 19,
};
enum {
    BUILDING_STATE_UNUSED = 0,
    BUILDING_STATE_IN_USE = 1,
    BUILDING_STATE_UNDO = 2,
    BUILDING_STATE_CREATED = 3,
    BUILDING_STATE_RUBBLE = 4,
    BUILDING_STATE_DELETED_BY_GAME = 5, // used for earthquakes, fires, house mergers
    BUILDING_STATE_DELETED_BY_PLAYER = 6
};
enum {
    BUILDING_STORAGE_STATE_ACCEPTING = 0,
    BUILDING_STORAGE_STATE_NOT_ACCEPTING = 1,
    BUILDING_STORAGE_STATE_GETTING = 2
};
enum {
    ADVISOR_NONE = 0,
    ADVISOR_LABOR = 1,
    ADVISOR_MILITARY = 2,
    ADVISOR_IMPERIAL = 3,
    ADVISOR_RATINGS = 4,
    ADVISOR_TRADE = 5,
    ADVISOR_POPULATION = 6,
    ADVISOR_HEALTH = 7,
    ADVISOR_EDUCATION = 8,
    ADVISOR_ENTERTAINMENT = 9,
    ADVISOR_RELIGION = 10,
    ADVISOR_FINANCIAL = 11,
    ADVISOR_CHIEF = 12
};
enum {
    LOW_MOOD_CAUSE_NONE = 0,
    LOW_MOOD_CAUSE_NO_FOOD = 1,
    LOW_MOOD_CAUSE_NO_JOBS = 2,
    LOW_MOOD_CAUSE_HIGH_TAXES = 3,
    LOW_MOOD_CAUSE_LOW_WAGES = 4,
    LOW_MOOD_CAUSE_MANY_TENTS = 5,
};
enum {
    NO_IMMIGRATION_LOW_WAGES = 0,
    NO_IMMIGRATION_NO_JOBS = 1,
    NO_IMMIGRATION_NO_FOOD = 2,
    NO_IMMIGRATION_HIGH_TAXES = 3,
    NO_IMMIGRATION_MANY_TENTS = 4,
    NO_IMMIGRATION_LOW_MOOD = 5
};
enum {
    FESTIVAL_NONE = 0,
    FESTIVAL_SMALL = 1,
    FESTIVAL_LARGE = 2,
    FESTIVAL_GRAND = 3
};
enum {
    GOD_CERES = 0,
    GOD_NEPTUNE = 1,
    GOD_MERCURY = 2,
    GOD_MARS = 3,
    GOD_VENUS = 4
};
enum {
    TRADE_STATUS_NONE = 0,
    TRADE_STATUS_IMPORT = 1,
    TRADE_STATUS_EXPORT = 2
};
enum {
    GIFT_MODEST = 0,
    GIFT_GENEROUS = 1,
    GIFT_LAVISH = 2
};
enum {
    MESSAGE_CAT_RIOT = 0,
    MESSAGE_CAT_FIRE = 1,
    MESSAGE_CAT_COLLAPSE = 2,
    MESSAGE_CAT_RIOT_COLLAPSE = 3,
    MESSAGE_CAT_BLOCKED_DOCK = 4,
    MESSAGE_CAT_WORKERS_NEEDED = 8,
    MESSAGE_CAT_NO_WORKING_DOCK = 10,
    MESSAGE_CAT_FISHING_BLOCKED = 11,
};
enum {
    MESSAGE_ADVISOR_NONE = 0,
    MESSAGE_ADVISOR_LABOR = 1,
    MESSAGE_ADVISOR_TRADE = 2,
    MESSAGE_ADVISOR_POPULATION = 3,
    MESSAGE_ADVISOR_IMPERIAL = 4,
    MESSAGE_ADVISOR_MILITARY = 5,
    MESSAGE_ADVISOR_HEALTH = 6,
    MESSAGE_ADVISOR_RELIGION = 7,
};
enum {
    MESSAGE_POPULATION_500 = 2,
    MESSAGE_POPULATION_1000 = 3,
    MESSAGE_POPULATION_2000 = 4,
    MESSAGE_POPULATION_3000 = 5,
    MESSAGE_POPULATION_5000 = 6,
    MESSAGE_POPULATION_10000 = 7,
    MESSAGE_POPULATION_15000 = 8,
    MESSAGE_POPULATION_20000 = 9,
    MESSAGE_POPULATION_25000 = 10,
    MESSAGE_RIOT = 11,
    MESSAGE_FIRE = 12,
    MESSAGE_COLLAPSED_BUILDING = 13,
    MESSAGE_DESTROYED_BUILDING = 14,
    MESSAGE_NAVIGATION_IMPOSSIBLE = 15,
    MESSAGE_CITY_IN_DEBT = 16,
    MESSAGE_CITY_IN_DEBT_AGAIN = 17,
    MESSAGE_CITY_STILL_IN_DEBT = 18,
    MESSAGE_CAESAR_WRATH = 19,
    MESSAGE_CAESAR_ARMY_CONTINUE = 20,
    MESSAGE_CAESAR_ARMY_RETREAT = 21,
    MESSAGE_LOCAL_UPRISING = 22,
    MESSAGE_BARBARIAN_ATTACK = 23,
    MESSAGE_CAESAR_ARMY_ATTACK = 24,
    MESSAGE_DISTANT_BATTLE = 25,
    MESSAGE_ENEMIES_CLOSING = 26,
    MESSAGE_ENEMIES_AT_THE_DOOR = 27,
    MESSAGE_CAESAR_REQUESTS_GOODS = 28,
    MESSAGE_CAESAR_REQUESTS_MONEY = 29,
    MESSAGE_CAESAR_REQUESTS_ARMY = 30,
    MESSAGE_REQUEST_REMINDER = 31,
    MESSAGE_REQUEST_RECEIVED = 32,
    MESSAGE_REQUEST_REFUSED = 33,
    MESSAGE_REQUEST_REFUSED_OVERDUE = 34,
    MESSAGE_REQUEST_RECEIVED_LATE = 35,
    MESSAGE_UNEMPLOYMENT = 36,
    MESSAGE_WORKERS_NEEDED = 37,
    MESSAGE_SMALL_FESTIVAL = 38,
    MESSAGE_LARGE_FESTIVAL = 39,
    MESSAGE_GRAND_FESTIVAL = 40,
    MESSAGE_WRATH_OF_CERES = 41,
    MESSAGE_WRATH_OF_NEPTUNE_NO_SEA_TRADE = 42,
    MESSAGE_WRATH_OF_MERCURY = 43,
    MESSAGE_WRATH_OF_MARS_NO_MILITARY = 44,
    MESSAGE_WRATH_OF_VENUS = 45,
    MESSAGE_PEOPLE_DISGRUNTLED = 46,
    MESSAGE_PEOPLE_UNHAPPY = 47,
    MESSAGE_PEOPLE_ANGRY = 48,
    MESSAGE_NOT_ENOUGH_FOOD = 49,
    MESSAGE_FOOD_NOT_DELIVERED = 50,
    MESSAGE_THEFT = 52,
    MESSAGE_GODS_UNHAPPY = 55,
    MESSAGE_EARTHQUAKE = 62,
    MESSAGE_GLADIATOR_REVOLT = 63,
    MESSAGE_LAND_TRADE_DISRUPTED_SANDSTORMS = 65,
    MESSAGE_SEA_TRADE_DISRUPTED = 66,
    MESSAGE_LAND_TRADE_DISRUPTED_LANDSLIDES = 67,
    MESSAGE_ROME_RAISES_WAGES = 68,
    MESSAGE_ROME_LOWERS_WAGES = 69,
    MESSAGE_CONTAMINATED_WATER = 70,
    MESSAGE_IRON_MINE_COLLAPED = 71,
    MESSAGE_CLAY_PIT_FLOODED = 72,
    MESSAGE_GLADIATOR_REVOLT_FINISHED = 73,
    MESSAGE_INCREASED_TRADING = 74,
    MESSAGE_DECREASED_TRADING = 75,
    MESSAGE_TRADE_STOPPED = 76,
    MESSAGE_PRICE_INCREASED = 78,
    MESSAGE_PRICE_DECREASED = 79,
    MESSAGE_EMPIRE_HAS_EXPANDED = 77,
    MESSAGE_ROAD_TO_ROME_BLOCKED = 80,
    MESSAGE_WRATH_OF_NEPTUNE = 81,
    MESSAGE_WRATH_OF_MARS = 82,
    MESSAGE_DISTANT_BATTLE_LOST_NO_TROOPS = 84,
    MESSAGE_DISTANT_BATTLE_LOST_TOO_LATE = 85,
    MESSAGE_DISTANT_BATTLE_LOST_TOO_WEAK = 86,
    MESSAGE_DISTANT_BATTLE_WON = 87,
    MESSAGE_TROOPS_RETURN_FAILED = 88,
    MESSAGE_TROOPS_RETURN_VICTORIOUS = 89,
    MESSAGE_DISTANT_BATTLE_CITY_RETAKEN = 90,
    MESSAGE_CERES_IS_UPSET = 91,
    MESSAGE_NEPTUNE_IS_UPSET = 92,
    MESSAGE_MERCURY_IS_UPSET = 93,
    MESSAGE_MARS_IS_UPSET = 94,
    MESSAGE_VENUS_IS_UPSET = 95,
    MESSAGE_BLESSING_FROM_CERES = 96,
    MESSAGE_BLESSING_FROM_NEPTUNE = 97,
    MESSAGE_BLESSING_FROM_MERCURY = 98,
    MESSAGE_BLESSING_FROM_MARS = 99,
    MESSAGE_BLESSING_FROM_VENUS = 100,
    MESSAGE_GODS_WRATHFUL = 101,
    MESSAGE_HEALTH_ILLNESS = 102,
    MESSAGE_HEALTH_DISEASE = 103,
    MESSAGE_HEALTH_PESTILENCE = 104,
    MESSAGE_SPIRIT_OF_MARS = 105,
    MESSAGE_CAESAR_RESPECT_1 = 106,
    MESSAGE_CAESAR_RESPECT_2 = 107,
    MESSAGE_CAESAR_RESPECT_3 = 108,
    MESSAGE_WORKING_HIPPODROME = 109,
    MESSAGE_WORKING_COLOSSEUM = 110,
    MESSAGE_EMIGRATION = 111,
    MESSAGE_FIRED = 112,
    MESSAGE_ENEMY_ARMY_ATTACK = 114,
    MESSAGE_REQUEST_CAN_COMPLY = 115,
    MESSAGE_ROAD_TO_ROME_OBSTRUCTED = 116,
    MESSAGE_NO_WORKING_DOCK = 117,
    MESSAGE_FISHING_BOAT_BLOCKED = 118,
    MESSAGE_LOCAL_UPRISING_MARS = 121,
    MESSAGE_DISTANT_BATTLE_WON_TRIUMPHAL_ARCH_DISABLED = 122,
    MESSAGE_EDITOR_1 = 123,
    MESSAGE_EDITOR_2 = 124,
    MESSAGE_EDITOR_3 = 125,
    MESSAGE_EDITOR_4 = 126,
    MESSAGE_EDITOR_5 = 127,
    MESSAGE_EDITOR_6 = 128,
    MESSAGE_EDITOR_7 = 129,
    MESSAGE_EDITOR_8 = 130,
    MESSAGE_EDITOR_9 = 131,
    MESSAGE_EDITOR_10 = 132,
    MESSAGE_EDITOR_11 = 133,
    MESSAGE_EDITOR_12 = 134,
    MESSAGE_EDITOR_13 = 135,
    MESSAGE_EDITOR_14 = 136,
    MESSAGE_EDITOR_15 = 137,
    MESSAGE_EDITOR_16 = 138,
    MESSAGE_EDITOR_17 = 139,
    MESSAGE_EDITOR_18 = 140,
    MESSAGE_EDITOR_19 = 141,
    MESSAGE_EDITOR_20 = 142,
    MESSAGE_EDITOR_21 = 143,
    MESSAGE_EDITOR_22 = 144,
    MESSAGE_EDITOR_23 = 145,
    MESSAGE_EDITOR_24 = 146,
    MESSAGE_EDITOR_25 = 147,
    MESSAGE_EDITOR_26 = 148,
    MESSAGE_EDITOR_27 = 149,
    MESSAGE_EDITOR_28 = 150,
    MESSAGE_EDITOR_29 = 151,
    MESSAGE_EDITOR_30 = 152,
    MESSAGE_EDITOR_31 = 153,
    MESSAGE_EDITOR_32 = 154,
    MESSAGE_EDITOR_33 = 155,
    MESSAGE_EDITOR_34 = 156,
    MESSAGE_EDITOR_35 = 157,
    MESSAGE_EDITOR_36 = 158,
    MESSAGE_EDITOR_37 = 159,
    MESSAGE_EDITOR_38 = 160,
    MESSAGE_EDITOR_39 = 161,
    MESSAGE_EDITOR_40 = 162,
    MESSAGE_EDITOR_41 = 163,
    MESSAGE_EDITOR_42 = 164,
    MESSAGE_EDITOR_43 = 165,
    MESSAGE_EDITOR_44 = 166,
    MESSAGE_EDITOR_45 = 167,
};
enum {
    SELECTED_RATING_NONE = 0,
    SELECTED_RATING_CULTURE = 1,
    SELECTED_RATING_PROSPERITY = 2,
    SELECTED_RATING_PEACE = 3,
    SELECTED_RATING_FAVOR = 4
};
enum {
    VICTORY_STATE_LOST = -1,
    VICTORY_STATE_NONE = 0,
    VICTORY_STATE_WON = 1
};
enum {
    WARNING_ORIENTATION = 1,
    WARNING_CLEAR_LAND_NEEDED = 2,
    WARNING_OUT_OF_MONEY = 3,
    WARNING_ONE_BUILDING_OF_TYPE = 4,
    WARNING_ROAD_ACCESS_NEEDED = 11,
    WARNING_NOT_AVAILABLE = 13,
    WARNING_NOT_AVAILABLE_YET = 14,
    WARNING_MARBLE_NEEDED_LARGE_TEMPLE = 15,
    WARNING_MARBLE_NEEDED_ORACLE = 16,
    WARNING_WORKERS_NEEDED = 17,
    WARNING_MORE_FOOD_NEEDED = 18,
    WARNING_BUILD_MARKET = 19,
    WARNING_MEADOW_NEEDED = 20,
    WARNING_WATER_NEEDED = 21,
    WARNING_ROCK_NEEDED = 22,
    WARNING_TREE_NEEDED = 23,
    WARNING_SHORE_NEEDED = 25,
    WARNING_IRON_NEEDED = 26,
    WARNING_VINES_NEEDED = 27,
    WARNING_OLIVES_NEEDED = 28,
    WARNING_CLAY_NEEDED = 29,
    WARNING_TIMBER_NEEDED = 30,
    WARNING_OPEN_TRADE_TO_IMPORT = 31,
    WARNING_TRADE_IMPORT_RESOURCE = 32,
    WARNING_BUILD_IRON_MINE = 33,
    WARNING_BUILD_VINES_FARM = 34,
    WARNING_BUILD_OLIVE_FARM = 35,
    WARNING_BUILD_CLAY_PIT = 36,
    WARNING_BUILD_TIMBER_YARD = 37,
    WARNING_WATER_PIPE_ACCESS_NEEDED = 38,
    WARNING_PLACE_RESERVOIR_NEXT_TO_WATER = 39,
    WARNING_CONNECT_TO_RESERVOIR = 40,
    WARNING_SENTRIES_NEED_WALL = 41,
    WARNING_BUILD_BARRACKS = 42,
    WARNING_WEAPONS_NEEDED = 43,
    WARNING_BUILD_ACTOR_COLONY = 44,
    WARNING_BUILD_GLADIATOR_SCHOOL = 45,
    WARNING_BUILD_LION_HOUSE = 46,
    WARNING_BUILD_CHARIOT_MAKER = 47,
    WARNING_WALL_NEEDED = 49,
    WARNING_ENEMY_NEARBY = 50,
    WARNING_LEGION_MORALE_TOO_LOW = 51,
    WARNING_MAX_LEGIONS_REACHED = 52,
    WARNING_PEOPLE_ON_BRIDGE = 55,
    WARNING_DOCK_OPEN_WATER_NEEDED = 56,
    WARNING_EDITOR_NEED_MAP_EDGE = 58,
    WARNING_EDITOR_NEED_OPEN_WATER = 59,
    WARNING_EDITOR_CANNOT_PLACE = 60,
    WARNING_HOUSE_TOO_FAR_FROM_ROAD = 62,
    WARNING_CITY_BOXED_IN = 63,
    WARNING_CITY_BOXED_IN_PEOPLE_WILL_PERISH = 64,
    WARNING_DATA_LIMIT_REACHED = 65
};
enum {
    RESOURCE_NONE = 0,
    RESOURCE_WHEAT = 1,
    RESOURCE_VEGETABLES = 2,
    RESOURCE_FRUIT = 3,
    RESOURCE_MEAT = 4,
    RESOURCE_OLIVES = 5,
    RESOURCE_VINES = 6,
    RESOURCE_CLAY = 7,
    RESOURCE_TIMBER = 8,
    RESOURCE_MARBLE = 9,
    RESOURCE_IRON = 10,
    RESOURCE_OIL = 11,
    RESOURCE_WINE = 12,
    RESOURCE_POTTERY = 13,
    RESOURCE_FURNITURE = 14,
    RESOURCE_WEAPONS = 15,
    RESOURCE_DENARII = 16,
    RESOURCE_TROOPS = 17,
};
enum {
    INVENTORY_WHEAT = 0,
    INVENTORY_VEGETABLES = 1,
    INVENTORY_FRUIT = 2,
    INVENTORY_MEAT = 3,
    INVENTORY_OIL = 4,
    INVENTORY_WINE = 5,
    INVENTORY_POTTERY = 6,
    INVENTORY_FURNITURE = 7,
    // helper constants
    INVENTORY_MAX = 8
};
enum {
    WORKSHOP_NONE = 0,
    WORKSHOP_OLIVES_TO_OIL = 1,
    WORKSHOP_VINES_TO_WINE = 2,
    WORKSHOP_CLAY_TO_POTTERY = 3,
    WORKSHOP_TIMBER_TO_FURNITURE = 4,
    WORKSHOP_IRON_TO_WEAPONS = 5,
};
enum {
    RESOURCE_IMAGE_STORAGE = 0,
    RESOURCE_IMAGE_CART = 1,
    RESOURCE_IMAGE_FOOD_CART = 2,
    RESOURCE_IMAGE_ICON = 3
};
enum {
    SETTINGS_FULLSCREEN,
    SETTINGS_WINDOW_WIDTH,
    SETTINGS_WINDOW_HEIGHT,
    SETTINGS_SOUND_EFFECTS_ENABLED,
    SETTINGS_SOUND_EFFECTS_VOLUME,
    SETTINGS_MUSIC_ENABLED,
    SETTINGS_MUSIC_VOLUME,
    SETTINGS_SPEECH_ENABLED,
    SETTINGS_SPEECH_VOLUME,
    SETTINGS_CITY_SOUNDS_ENABLED,
    SETTINGS_CITY_SOUNDS_VOLUME,
    SETTINGS_GAME_SPEED,
    SETTINGS_SCROLL_SPEED,
    SETTINGS_MONTHLY_AUTOSAVE_ENABLED,
    SETTINGS_WARNINGS_ENABLED,
    SETTINGS_VICTORY_VIDEO,
    SETTINGS_LAST_ADVISOR,
};
enum {
    CONFIG_SCREEN_DISPLAY_SCALE,
    CONFIG_SCREEN_CURSOR_SCALE,
    CONFIG_UI_SIDEBAR_INFO,
    CONFIG_UI_SHOW_INTRO_VIDEO,
    CONFIG_UI_DISABLE_MOUSE_EDGE_SCROLLING,
    CONFIG_UI_DISABLE_RIGHT_CLICK_MAP_DRAG,
    CONFIG_UI_VISUAL_FEEDBACK_ON_DELETE,
    CONFIG_UI_HIGHLIGHT_LEGIONS,
    CONFIG_MAX_ENTRIES
};
enum {
    CONFIG_STRING_PLAYER_NAME,
    CONFIG_STRING_MAX_ENTRIES
};
enum {
    HOTKEY_ARROW_UP,
    HOTKEY_ARROW_DOWN,
    HOTKEY_ARROW_LEFT,
    HOTKEY_ARROW_RIGHT,
    HOTKEY_TOGGLE_FULLSCREEN,
    HOTKEY_RESET_WINDOW,
    HOTKEY_SAVE_SCREENSHOT,
    HOTKEY_SAVE_CITY_SCREENSHOT,
    HOTKEY_LOAD_FILE,
    HOTKEY_SAVE_FILE,
    HOTKEY_DECREASE_GAME_SPEED,
    HOTKEY_INCREASE_GAME_SPEED,
    HOTKEY_TOGGLE_PAUSE,
    HOTKEY_ROTATE_MAP_LEFT,
    HOTKEY_ROTATE_MAP_RIGHT,
    HOTKEY_REPLAY_MAP,
    HOTKEY_CYCLE_LEGION,
    HOTKEY_RETURN_LEGIONS_TO_FORT,
    HOTKEY_SHOW_LAST_ADVISOR,
    HOTKEY_SHOW_EMPIRE_MAP,
    HOTKEY_SHOW_MESSAGES,
    HOTKEY_GO_TO_PROBLEM,
    HOTKEY_BUILD_CLONE,
    HOTKEY_CYCLE_BUILDINGS,
    HOTKEY_CYCLE_BUILDINGS_REVERSE,
    HOTKEY_UNDO,
    HOTKEY_BUILD_VACANT_HOUSE,
    HOTKEY_BUILD_CLEAR_LAND,
    HOTKEY_BUILD_ROAD,
    HOTKEY_BUILD_RESERVOIR,
    HOTKEY_BUILD_AQUEDUCT,
    HOTKEY_BUILD_FOUNTAIN,
    HOTKEY_BUILD_WELL,
    HOTKEY_BUILD_DOCTOR,
    HOTKEY_BUILD_BATHHOUSE,
    HOTKEY_BUILD_BARBER,
    HOTKEY_BUILD_HOSPITAL,
    HOTKEY_BUILD_SMALL_TEMPLE_CERES,
    HOTKEY_BUILD_SMALL_TEMPLE_NEPTUNE,
    HOTKEY_BUILD_SMALL_TEMPLE_MERCURY,
    HOTKEY_BUILD_SMALL_TEMPLE_MARS,
    HOTKEY_BUILD_SMALL_TEMPLE_VENUS,
    HOTKEY_BUILD_LARGE_TEMPLE_CERES,
    HOTKEY_BUILD_LARGE_TEMPLE_NEPTUNE,
    HOTKEY_BUILD_LARGE_TEMPLE_MERCURY,
    HOTKEY_BUILD_LARGE_TEMPLE_MARS,
    HOTKEY_BUILD_LARGE_TEMPLE_VENUS,
    HOTKEY_BUILD_ORACLE,
    HOTKEY_BUILD_SCHOOL,
    HOTKEY_BUILD_LIBRARY,
    HOTKEY_BUILD_ACADEMY,
    HOTKEY_BUILD_MISSION_POST,
    HOTKEY_BUILD_THEATER,
    HOTKEY_BUILD_ACTOR_COLONY,
    HOTKEY_BUILD_AMPHITHEATER,
    HOTKEY_BUILD_GLADIATOR_SCHOOL,
    HOTKEY_BUILD_LION_HOUSE,
    HOTKEY_BUILD_COLOSSEUM,
    HOTKEY_BUILD_CHARIOT_MAKER,
    HOTKEY_BUILD_HIPPODROME,
    HOTKEY_BUILD_GARDENS,
    HOTKEY_BUILD_PLAZA,
    HOTKEY_BUILD_SMALL_STATUE,
    HOTKEY_BUILD_MEDIUM_STATUE,
    HOTKEY_BUILD_LARGE_STATUE,
    HOTKEY_BUILD_GOVERNORS_HOUSE,
    HOTKEY_BUILD_GOVERNORS_VILLA,
    HOTKEY_BUILD_GOVERNORS_PALACE,
    HOTKEY_BUILD_FORUM,
    HOTKEY_BUILD_SENATE,
    HOTKEY_BUILD_TRIUMPHAL_ARCH,
    HOTKEY_BUILD_ENGINEERS_POST,
    HOTKEY_BUILD_LOW_BRIDGE,
    HOTKEY_BUILD_SHIP_BRIDGE,
    HOTKEY_BUILD_SHIPYARD,
    HOTKEY_BUILD_WHARF,
    HOTKEY_BUILD_DOCK,
    HOTKEY_BUILD_PREFECTURE,
    HOTKEY_BUILD_WALL,
    HOTKEY_BUILD_TOWER,
    HOTKEY_BUILD_GATEHOUSE,
    HOTKEY_BUILD_FORT_LEGIONARIES,
    HOTKEY_BUILD_FORT_JAVELIN,
    HOTKEY_BUILD_FORT_MOUNTED,
    HOTKEY_BUILD_BARRACKS,
    HOTKEY_BUILD_MILITARY_ACADEMY,
    HOTKEY_BUILD_WHEAT_FARM,
    HOTKEY_BUILD_VEGETABLE_FARM,
    HOTKEY_BUILD_FRUIT_FARM,
    HOTKEY_BUILD_PIG_FARM,
    HOTKEY_BUILD_OLIVE_FARM,
    HOTKEY_BUILD_VINES_FARM,
    HOTKEY_BUILD_CLAY_PIT,
    HOTKEY_BUILD_TIMBER_YARD,
    HOTKEY_BUILD_MARBLE_QUARRY,
    HOTKEY_BUILD_IRON_MINE,
    HOTKEY_BUILD_OIL_WORKSHOP,
    HOTKEY_BUILD_WINE_WORKSHOP,
    HOTKEY_BUILD_POTTERY_WORKSHOP,
    HOTKEY_BUILD_FURNITURE_WORKSHOP,
    HOTKEY_BUILD_WEAPONS_WORKSHOP,
    HOTKEY_BUILD_MARKET,
    HOTKEY_BUILD_GRANARY,
    HOTKEY_BUILD_WAREHOUSE,
    HOTKEY_SHOW_OVERLAY_WATER,
    HOTKEY_SHOW_OVERLAY_FIRE,
    HOTKEY_SHOW_OVERLAY_DAMAGE,
    HOTKEY_SHOW_OVERLAY_CRIME,
    HOTKEY_SHOW_OVERLAY_PROBLEMS,
    HOTKEY_GO_TO_BOOKMARK_1,
    HOTKEY_GO_TO_BOOKMARK_2,
    HOTKEY_GO_TO_BOOKMARK_3,
    HOTKEY_GO_TO_BOOKMARK_4,
    HOTKEY_SET_BOOKMARK_1,
    HOTKEY_SET_BOOKMARK_2,
    HOTKEY_SET_BOOKMARK_3,
    HOTKEY_SET_BOOKMARK_4,
    HOTKEY_EDITOR_TOGGLE_BATTLE_INFO,
    HOTKEY_CHEAT_MONEY,
    HOTKEY_CHEAT_INVASION,
    HOTKEY_CHEAT_VICTORY,
    HOTKEY_MAX_ITEMS
};
enum {
    GROUP_TERRAIN_BLACK = 1,
    GROUP_TERRAIN_TREE = 2,
    GROUP_TERRAIN_UGLY_GRASS = 3,
    GROUP_TERRAIN_SHRUB = 4,
    GROUP_TERRAIN_WATER = 5,
    GROUP_TERRAIN_EARTHQUAKE = 6,
    GROUP_TERRAIN_GRASS_2 = 7,
    GROUP_TERRAIN_ELEVATION_ROCK = 8,
    GROUP_TERRAIN_ELEVATION = 9,
    GROUP_TERRAIN_GRASS_1 = 10,
    GROUP_TOP_MENU = 11,
    GROUP_SIDE_PANEL = 12,
    GROUP_SIDEBAR_ADVISORS_EMPIRE = 13,
    GROUP_MAIN_MENU_BACKGROUND = 14,
    GROUP_PANEL_BUTTON = 15,
    GROUP_FONT = 16,
    GROUP_BUILDING_TOWER = 17,
    GROUP_BUILDING_AQUEDUCT = 19,
    GROUP_TERRAIN_OVERLAY = 20,
    GROUP_TERRAIN_FLAT_TILE = 21,
    GROUP_BUILDING_MARKET = 22,
    GROUP_BUILDING_WELL = 23,
    GROUP_BUILDING_WALL = 24,
    GROUP_BUILDING_RESERVOIR = 25,
    // 26-35: houses
    GROUP_BUILDING_HOUSE_TENT = 26,
    GROUP_BUILDING_HOUSE_SHACK = 27,
    GROUP_BUILDING_HOUSE_HOVEL = 28,
    GROUP_BUILDING_HOUSE_CASA = 29,
    GROUP_BUILDING_HOUSE_INSULA_1 = 30,
    GROUP_BUILDING_HOUSE_INSULA_2 = 31,
    GROUP_BUILDING_HOUSE_VILLA_1 = 32,
    GROUP_BUILDING_HOUSE_VILLA_2 = 33,
    GROUP_BUILDING_HOUSE_PALACE_1 = 34,
    GROUP_BUILDING_HOUSE_PALACE_2 = 35,
    GROUP_BUILDING_HOUSE_VACANT_LOT = 36,
    GROUP_BUILDING_FARM_HOUSE = 37,
    GROUP_BUILDING_MARBLE_QUARRY = 38,
    GROUP_BUILDING_IRON_MINE = 39,
    GROUP_BUILDING_CLAY_PIT = 40,
    GROUP_BUILDING_SCHOOL = 41,
    GROUP_BUILDING_LIBRARY = 42,
    GROUP_BUILDING_ACADEMY = 43,
    GROUP_BUILDING_WINE_WORKSHOP = 44,
    GROUP_BUILDING_AMPHITHEATER = 45,
    GROUP_BUILDING_THEATER = 46,
    GROUP_EMPIRE_MAP = 47,
    GROUP_BUILDING_COLOSSEUM = 48,
    GROUP_BUILDING_GLADIATOR_SCHOOL = 49,
    GROUP_BUILDING_LION_HOUSE = 50,
    GROUP_BUILDING_ACTOR_COLONY = 51,
    GROUP_BUILDING_CHARIOT_MAKER = 52,
    GROUP_BUILDING_FOUNTAIN_4 = 53,
    GROUP_BUILDING_FOUNTAIN_1 = 54,
    GROUP_BUILDING_FOUNTAIN_2 = 55,
    GROUP_BUILDING_FOUNTAIN_3 = 56,
    GROUP_FIGURE_LABOR_SEEKER = 57,
    GROUP_TERRAIN_PLAZA = 58,
    GROUP_TERRAIN_GARDEN = 59,
    GROUP_BUILDING_WORKSHOP_RAW_MATERIAL = 60,
    GROUP_BUILDING_STATUE = 61,
    GROUP_BUILDING_SENATE = 62,
    GROUP_BUILDING_FORUM = 63,
    GROUP_BUILDING_PREFECTURE = 64,
    GROUP_BUILDING_TIMBER_YARD = 65,
    GROUP_BUILDING_FORT = 66,
    GROUP_BUILDING_BARBER = 67,
    GROUP_BUILDING_DOCTOR = 68,
    GROUP_BUILDING_BATHHOUSE_WATER = 69,
    GROUP_BUILDING_HOSPITAL = 70,
    GROUP_BUILDING_TEMPLE_CERES = 71,
    GROUP_BUILDING_TEMPLE_NEPTUNE = 72,
    GROUP_BUILDING_TEMPLE_MERCURY = 73,
    GROUP_BUILDING_TEMPLE_MARS = 74,
    GROUP_BUILDING_TEMPLE_VENUS = 75,
    GROUP_BUILDING_ORACLE = 76,
    GROUP_BUILDING_SHIPYARD = 77,
    GROUP_BUILDING_DOCK_1 = 78,
    GROUP_BUILDING_WHARF = 79,
    GROUP_BUILDING_ENGINEERS_POST = 81,
    GROUP_BUILDING_WAREHOUSE = 82,
    GROUP_BUILDING_GOVERNORS_HOUSE = 85,
    GROUP_BUILDING_GOVERNORS_VILLA = 86,
    GROUP_BUILDING_GOVERNORS_PALACE = 87,
    GROUP_FIGURE_BATHHOUSE_WORKER = 88,
    GROUP_SIDEBAR_BRIEFING_ROTATE_BUTTONS = 89,
    GROUP_ARROW_MESSAGE_PROBLEMS = 90,
    GROUP_FIGURE_PRIEST = 91,
    GROUP_SIDEBAR_BUTTONS = 92,
    GROUP_LABOR_PRIORITY_LOCK = 94,
    GROUP_PANEL_WINDOWS = 95,
    GROUP_OK_CANCEL_SCROLL_BUTTONS = 96,
    GROUP_FIGURE_ACTOR = 98,
    GROUP_BUILDING_GRANARY = 99,
    GROUP_BUILDING_FARM_CROPS = 100,
    GROUP_FIGURE_LION_TAMER = 101,
    GROUP_FIGURE_EXPLOSION = 102,
    GROUP_OVERLAY_COLUMN = 103,
    GROUP_FIGURE_TAX_COLLECTOR = 104,
    GROUP_FIGURE_SCHOOL_CHILD = 105,
    GROUP_FIGURE_MARKET_LADY = 106,
    GROUP_FIGURE_CARTPUSHER = 107,
    GROUP_FIGURE_MIGRANT = 108,
    GROUP_FIGURE_LION_TAMER_WHIP = 109,
    GROUP_FIGURE_ENGINEER = 110,
    GROUP_FIGURE_GLADIATOR = 111,
    GROUP_TERRAIN_ROAD = 112,
    GROUP_TERRAIN_RUBBLE = 114,
    GROUP_FIGURE_CRIMINAL = 115,
    GROUP_FIGURE_BARBER = 116,
    GROUP_FIGURE_PREFECT = 117,
    GROUP_FIGURE_HOMELESS = 118,
    GROUP_TERRAIN_RUBBLE_TENT = 119,
    GROUP_TERRAIN_RUBBLE_GENERAL = 120,
    GROUP_FIGURE_PREFECT_WITH_BUCKET = 121,
    GROUP_BUILDING_OIL_WORKSHOP = 122,
    GROUP_BUILDING_WEAPONS_WORKSHOP = 123,
    GROUP_BUILDING_FURNITURE_WORKSHOP = 124,
    GROUP_BUILDING_POTTERY_WORKSHOP = 125,
    GROUP_FIGURE_FORT_FLAGS = 126,
    GROUP_FIGURE_FORT_STANDARD_ICONS = 127,
    GROUP_ADVISOR_ICONS = 128,
    GROUP_FIGURE_TRADE_CARAVAN = 130,
    GROUP_FIGURE_MIGRANT_CART = 131,
    GROUP_DIALOG_BACKGROUND = 132,
    GROUP_SUNKEN_TEXTBOX_BACKGROUND = 133,
    GROUP_CONTEXT_ICONS = 134,
    GROUP_TERRAIN_DESIRABILITY = 135,
    GROUP_ADVISOR_BACKGROUND = 136,
    GROUP_EDITOR_SIDEBAR_BUTTONS = 137,
    GROUP_TERRAIN_MEADOW = 138,
    GROUP_FIGURE_MAP_FLAG_ICONS = 140,
    GROUP_MINIMAP_EMPTY_LAND = 141,
    GROUP_MINIMAP_WATER = 142,
    GROUP_MINIMAP_TREE = 143,
    GROUP_MINIMAP_ROCK = 145,
    GROUP_MINIMAP_MEADOW = 146,
    GROUP_MINIMAP_ROAD = 147,
    GROUP_MINIMAP_HOUSE = 148,
    GROUP_MINIMAP_BUILDING = 149,
    GROUP_MINIMAP_WALL = 150,
    GROUP_MINIMAP_AQUEDUCT = 151,
    GROUP_MINIMAP_BLACK = 152,
    GROUP_FIGURE_FLOTSAM_0 = 153,
    GROUP_FIGURE_FLOTSAM_1 = 154,
    GROUP_FIGURE_FLOTSAM_2 = 155,
    GROUP_FIGURE_FLOTSAM_3 = 156,
    GROUP_POPULATION_GRAPH_BAR = 157,
    GROUP_BULLET = 158,
    GROUP_MESSAGE_IMAGES = 159,
    GROUP_WIN_GAME_BACKGROUND = 160,
    GROUP_CONFIG = 161,
    GROUP_LOGO = 162,
    GROUP_FIGURE_LION = 163,
    GROUP_BUILDING_BRIDGE = 164,
    GROUP_FIGURE_SHIP = 165,
    GROUP_BUILDING_BARRACKS = 166,
    GROUP_BUILDING_DOCK_2 = 168,
    GROUP_BUILDING_DOCK_3 = 169,
    GROUP_BUILDING_DOCK_4 = 170,
    GROUP_BUILDING_DOCK_DOCKERS = 171,
    GROUP_EMPIRE_PANELS = 172,
    GROUP_EMPIRE_CITY = 174,
    GROUP_EMPIRE_CITY_TRADE = 175,
    GROUP_EMPIRE_CITY_DISTANT_ROMAN = 176,
    GROUP_EMPIRE_TRADE_ROUTE_TYPE = 179,
    GROUP_BUILDING_NATIVE = 183,
    GROUP_BUILDING_MISSION_POST = 184,
    GROUP_BUILDING_BATHHOUSE_NO_WATER = 185,
    GROUP_RATINGS_COLUMN = 189,
    GROUP_BIG_PEOPLE = 190,
    GROUP_BUILDING_THEATER_SHOW = 191,
    GROUP_BUILDING_AMPHITHEATER_SHOW = 192,
    GROUP_BUILDING_COLOSSEUM_SHOW = 193,
    GROUP_FIGURE_TOWER_SENTRY = 194,
    GROUP_RATINGS_BACKGROUND = 195,
    GROUP_BUILDING_AQUEDUCT_NO_WATER = 196,
    GROUP_FORT_FORMATIONS = 197,
    GROUP_FIGURE_MISSILE = 198,
    GROUP_MESSAGE_ADVISOR_BUTTONS = 199,
    GROUP_FIGURE_BALLISTA = 200,
    GROUP_BUILDING_MILITARY_ACADEMY = 201,
    GROUP_BUILDING_FORT_JAVELIN = 202,
    GROUP_BUILDING_FORT_LEGIONARY = 204,
    GROUP_BUILDING_TRIUMPHAL_ARCH = 205,
    GROUP_FIGURE_SEAGULLS = 206,
    GROUP_TERRAIN_WATER_SHORE = 207,
    GROUP_BORDERED_BUTTON = 208,
    GROUP_FIGURE_DELIVERY_BOY = 209,
    GROUP_BUILDING_MARKET_FANCY = 210,
    GROUP_BUILDING_BATHHOUSE_FANCY_WATER = 211,
    GROUP_BUILDING_BATHHOUSE_FANCY_NO_WATER = 212,
    GROUP_BUILDING_HIPPODROME_1 = 213,
    GROUP_BUILDING_HIPPODROME_2 = 214,
    GROUP_FIGURE_CHARIOTEER = 215,
    GROUP_TERRAIN_ACCESS_RAMP = 216,
    GROUP_FIGURE_HIPPODROME_HORSE_1 = 217,
    GROUP_FIGURE_HIPPODROME_HORSE_2 = 218,
    GROUP_FIGURE_HIPPODROME_CART_1 = 219,
    GROUP_FIGURE_HIPPODROME_CART_2 = 220,
    GROUP_BUILDING_SENATE_FANCY = 221,
    GROUP_FORT_ICONS = 222,
    GROUP_EMPIRE_FOREIGN_CITY = 223,
    GROUP_GOD_BOLT = 225,
    GROUP_FIGURE_SHIPWRECK = 226,
    GROUP_PLAGUE_SKULL = 227,
    GROUP_FIGURE_DOCTOR_SURGEON = 228,
    GROUP_FIGURE_PATRICIAN = 229,
    GROUP_FIGURE_MISSIONARY = 230,
    GROUP_FIGURE_TEACHER_LIBRARIAN = 231,
    GROUP_FIGURE_FORT_MOUNTED = 232,
    GROUP_FIGURE_SHEEP = 233,
    GROUP_FIGURE_WOLF = 234,
    GROUP_FIGURE_ZEBRA = 235,
    GROUP_FIGURE_CAESAR_LEGIONARY = 236,
    GROUP_FIGURE_CARTPUSHER_CART_MULTIPLE_FOOD = 237,
    GROUP_BUILDING_TRADE_CENTER_FLAG = 238,
    GROUP_TERRAIN_ROCK = 239,
    GROUP_TERRAIN_ENTRY_EXIT_FLAGS = 240,
    GROUP_FIGURE_FORT_STANDARD_POLE = 241,
    GROUP_FIGURE_FLOTSAM_SHEEP = 242,
    GROUP_TRADE_AMOUNT = 243,
    GROUP_SELECT_MISSION_BACKGROUND = 244,
    GROUP_SELECT_MISSION = 245,
    GROUP_CCK_BACKGROUND = 246,
    GROUP_SCENARIO_IMAGE = 247,
    GROUP_BUILDING_GATEHOUSE = 248,
    GROUP_FIGURE_CARTPUSHER_CART_MULTIPLE_RESOURCE = 250,
    GROUP_LOADING_SCREEN = 251,
    GROUP_INTERMEZZO_BACKGROUND = 252,
    GROUP_PANEL_WINDOWS_DESERT = 253,
    GROUP_SELECT_MISSION_BUTTON = 254,
};
enum {
    IMAGE_TYPE_WITH_TRANSPARENCY = 0,
    IMAGE_TYPE_ISOMETRIC = 30
};
enum {
    TYPE_MANUAL = 0,
    TYPE_ABOUT = 1,
    TYPE_MESSAGE = 2,
    TYPE_MISSION = 3
};
enum {
    MESSAGE_TYPE_GENERAL = 0,
    MESSAGE_TYPE_DISASTER = 1,
    MESSAGE_TYPE_IMPERIAL = 2,
    MESSAGE_TYPE_EMIGRATION = 3,
    MESSAGE_TYPE_TRADE_CHANGE = 5,
    MESSAGE_TYPE_PRICE_CHANGE = 6,
    MESSAGE_TYPE_INVASION = 7
};
enum {
    SMACKER_Y_SCALE_NONE = 0,
    SMACKER_Y_SCALE_INTERLACE = 1,
    SMACKER_Y_SCALE_DOUBLE = 2
};
enum {
    SMACKER_FRAME_ERROR = 0,
    SMACKER_FRAME_OK = 1,
    SMACKER_FRAME_DONE = 2
};
enum {
    SPEED_DIRECTION_NEGATIVE = -1,
    SPEED_DIRECTION_STOPPED = 0,
    SPEED_DIRECTION_POSITIVE = 1
};
enum {
    GROUP_EDITOR_SCENARIO_IMAGE = 22,
    GROUP_EDITOR_BUILDING_CROPS = 23,
    GROUP_EDITOR_EMPIRE_MAP = 47,
    GROUP_EDITOR_SIDE_PANEL = 80,
    GROUP_EDITOR_EMPIRE_PANELS = 172,
    GROUP_EDITOR_BUILDING_NATIVE = 183,
    GROUP_EDITOR_EMPIRE_FOREIGN_CITY = 223,
    GROUP_EDITOR_TRADE_AMOUNT = 243,
};
enum {
    EMPIRE_OBJECT_ORNAMENT = 0,
    EMPIRE_OBJECT_CITY = 1,
    EMPIRE_OBJECT_BATTLE_ICON = 3,
    EMPIRE_OBJECT_LAND_TRADE_ROUTE = 4,
    EMPIRE_OBJECT_SEA_TRADE_ROUTE = 5,
    EMPIRE_OBJECT_ROMAN_ARMY = 6,
    EMPIRE_OBJECT_ENEMY_ARMY = 7,
};
enum {
    EMPIRE_CITY_DISTANT_ROMAN = 0,
    EMPIRE_CITY_OURS = 1,
    EMPIRE_CITY_TRADE = 2,
    EMPIRE_CITY_FUTURE_TRADE = 3,
    EMPIRE_CITY_DISTANT_FOREIGN = 4,
    EMPIRE_CITY_VULNERABLE_ROMAN = 5,
    EMPIRE_CITY_FUTURE_ROMAN = 6,
};
enum {
    FIGURE_NONE = 0,
    FIGURE_IMMIGRANT = 1,
    FIGURE_EMIGRANT = 2,
    FIGURE_HOMELESS = 3,
    FIGURE_PATRICIAN = 4,
    FIGURE_CART_PUSHER = 5,
    FIGURE_LABOR_SEEKER = 6,
    FIGURE_BARBER = 7,
    FIGURE_BATHHOUSE_WORKER = 8,
    FIGURE_DOCTOR = 9,
    FIGURE_SURGEON = 10,
    FIGURE_PRIEST = 11,
    FIGURE_SCHOOL_CHILD = 12,
    FIGURE_TEACHER = 13,
    FIGURE_LIBRARIAN = 14,
    FIGURE_MISSIONARY = 15,
    FIGURE_ACTOR = 16,
    FIGURE_GLADIATOR = 17,
    FIGURE_LION_TAMER = 18,
    FIGURE_CHARIOTEER = 19,
    FIGURE_HIPPODROME_HORSES = 20,
    FIGURE_TAX_COLLECTOR = 21,
    FIGURE_ENGINEER = 22,
    FIGURE_FISHING_BOAT = 23,
    FIGURE_FISH_GULLS = 24,
    FIGURE_SHIPWRECK = 25,
    FIGURE_DOCKER = 26,
    FIGURE_FLOTSAM = 27,
    FIGURE_BALLISTA = 28,
    FIGURE_BOLT = 29,
    FIGURE_TOWER_SENTRY = 30,
    FIGURE_JAVELIN = 31,
    FIGURE_PREFECT = 32,
    FIGURE_FORT_STANDARD = 33,
    FIGURE_FORT_JAVELIN = 34,
    FIGURE_FORT_MOUNTED = 35,
    FIGURE_FORT_LEGIONARY = 36,
    FIGURE_MARKET_BUYER = 37,
    FIGURE_MARKET_TRADER = 38,
    FIGURE_DELIVERY_BOY = 39,
    FIGURE_WAREHOUSEMAN = 40,
    FIGURE_PROTESTER = 41,
    FIGURE_CRIMINAL = 42,
    FIGURE_RIOTER = 43,
    FIGURE_TRADE_CARAVAN = 44,
    FIGURE_TRADE_CARAVAN_DONKEY = 45,
    FIGURE_TRADE_SHIP = 46,
    FIGURE_INDIGENOUS_NATIVE = 47,
    FIGURE_NATIVE_TRADER = 48,
    FIGURE_WOLF = 49,
    FIGURE_SHEEP = 50,
    FIGURE_ZEBRA = 51,
    FIGURE_ENEMY_GLADIATOR = 52,
    FIGURE_ENEMY_BARBARIAN_SWORDSMAN = 53,
    FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN = 54,
    FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT = 55,
    FIGURE_ENEMY_BRITON_SWORDSMAN = 56,
    FIGURE_ENEMY_BRITON_CHARIOT = 57,
    FIGURE_ENEMY_CELT_SWORDSMAN = 58,
    FIGURE_ENEMY_CELT_CHARIOT = 59,
    FIGURE_ENEMY_PICT_SWORDSMAN = 60,
    FIGURE_ENEMY_PICT_CHARIOT = 61,
    FIGURE_ENEMY_EGYPTIAN_SWORDSMAN = 62,
    FIGURE_ENEMY_EGYPTIAN_CAMEL = 63,
    FIGURE_ENEMY_ETRUSCAN_SWORDSMAN = 64,
    FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER = 65,
    FIGURE_ENEMY_SAMNITE_SWORDSMAN = 66,
    FIGURE_ENEMY_SAMNITE_SPEAR_THROWER = 67,
    FIGURE_ENEMY_GAUL_SWORDSMAN = 68,
    FIGURE_ENEMY_GAUL_AXEMAN = 69,
    FIGURE_ENEMY_HELVETIUS_SWORDSMAN = 70,
    FIGURE_ENEMY_HELVETIUS_AXEMAN = 71,
    FIGURE_ENEMY_HUN_SWORDSMAN = 72,
    FIGURE_ENEMY_HUN_MOUNTED_ARCHER = 73,
    FIGURE_ENEMY_GOTH_SWORDSMAN = 74,
    FIGURE_ENEMY_GOTH_MOUNTED_ARCHER = 75,
    FIGURE_ENEMY_VISIGOTH_SWORDSMAN = 76,
    FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER = 77,
    FIGURE_ENEMY_GREEK_SWORDSMAN = 78,
    FIGURE_ENEMY_GREEK_SPEAR_THROWER = 79,
    FIGURE_ENEMY_MACEDONIAN_SWORDSMAN = 80,
    FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER = 81,
    FIGURE_ENEMY_NUMIDIAN_SWORDSMAN = 82,
    FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER = 83,
    FIGURE_ENEMY_PERGAMUM_SWORDSMAN = 84,
    FIGURE_ENEMY_PERGAMUM_ARCHER = 85,
    FIGURE_ENEMY_IBERIAN_SWORDSMAN = 86,
    FIGURE_ENEMY_IBERIAN_SPEAR_THROWER = 87,
    FIGURE_ENEMY_JUDEAN_SWORDSMAN = 88,
    FIGURE_ENEMY_JUDEAN_SPEAR_THROWER = 89,
    FIGURE_ENEMY_SELEUCID_SWORDSMAN = 90,
    FIGURE_ENEMY_SELEUCID_SPEAR_THROWER = 91,
    FIGURE_ENEMY_CAESAR_JAVELIN = 92,
    FIGURE_ENEMY_CAESAR_MOUNTED = 93,
    FIGURE_ENEMY_CAESAR_LEGIONARY = 94,
    FIGURE_ARROW = 95,
    FIGURE_MAP_FLAG = 96,
    FIGURE_EXPLOSION = 97,
    FIGURE_TYPE_MAX = 98,
};
enum {
    ENEMY_TYPE_BARBARIAN = 0,
    ENEMY_TYPE_CARTHAGINIAN = 1,
    ENEMY_TYPE_BRITON = 2,
    ENEMY_TYPE_CELT = 3,
    ENEMY_TYPE_PICT = 4,
    ENEMY_TYPE_EGYPTIAN = 5,
    ENEMY_TYPE_ETRUSCAN = 6,
    ENEMY_TYPE_SAMNITE = 7,
    ENEMY_TYPE_GAUL = 8,
    ENEMY_TYPE_HELVETIUS = 9,
    ENEMY_TYPE_HUN = 10,
    ENEMY_TYPE_GOTH = 11,
    ENEMY_TYPE_VISIGOTH = 12,
    ENEMY_TYPE_GREEK = 13,
    ENEMY_TYPE_MACEDONIAN = 14,
    ENEMY_TYPE_NUMIDIAN = 15,
    ENEMY_TYPE_PERGAMUM = 16,
    ENEMY_TYPE_IBERIAN = 17,
    ENEMY_TYPE_JUDEAN = 18,
    ENEMY_TYPE_SELEUCID = 19,
    ENEMY_TYPE_CAESAR = 20
};
enum {
    ENEMY_IMG_TYPE_BARBARIAN = 0,
    ENEMY_IMG_TYPE_CARTHAGINIAN = 1,
    ENEMY_IMG_TYPE_CELT = 2,
    ENEMY_IMG_TYPE_EGYPTIAN = 3,
    ENEMY_IMG_TYPE_ETRUSCAN = 4,
    ENEMY_IMG_TYPE_GAUL = 5,
    ENEMY_IMG_TYPE_GOTH = 6,
    ENEMY_IMG_TYPE_GREEK = 7,
    ENEMY_IMG_TYPE_NORTH_AFRICAN = 8,
    ENEMY_IMG_TYPE_PERSIAN = 9,
    ENEMY_IMG_TYPE_PHOENICIAN = 10,
    ENEMY_IMG_TYPE_CAESAR = 11
};
enum {
    FIGURE_ACTION_IMMIGRANT_CREATED = 1,
    FIGURE_ACTION_IMMIGRANT_ARRIVING = 2,
    FIGURE_ACTION_IMMIGRANT_ENTERING_HOUSE = 3,
    FIGURE_ACTION_EMIGRANT_CREATED = 4,
    FIGURE_ACTION_EMIGRANT_EXITING_HOUSE = 5,
    FIGURE_ACTION_EMIGRANT_LEAVING = 6,
    FIGURE_ACTION_HOMELESS_CREATED = 7,
    FIGURE_ACTION_HOMELESS_GOING_TO_HOUSE = 8,
    FIGURE_ACTION_HOMELESS_ENTERING_HOUSE = 9,
    FIGURE_ACTION_HOMELESS_LEAVING = 10,
    FIGURE_ACTION_CARTPUSHER_INITIAL = 11,
    FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_WAREHOUSE = 12,
    FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_GRANARY = 13,
    FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_WORKSHOP = 14,
    FIGURE_ACTION_CARTPUSHER_AT_WAREHOUSE = 15,
    FIGURE_ACTION_CARTPUSHER_AT_GRANARY = 16,
    FIGURE_ACTION_CARTPUSHER_AT_WORKSHOP = 17,
    FIGURE_ACTION_CARTPUSHER_RETURNING = 18,
    FIGURE_ACTION_ROAMING = 19,
    FIGURE_ACTION_ROAMER_RETURNING = 20,
    FIGURE_ACTION_ENTERTAINER_AT_SCHOOL_CREATED = 21,
    FIGURE_ACTION_ENTERTAINER_EXITING_SCHOOL = 22,
    FIGURE_ACTION_ENTERTAINER_GOING_TO_VENUE = 23,
    FIGURE_ACTION_ENTERTAINER_ROAMING = 24,
    FIGURE_ACTION_ENTERTAINER_RETURNING = 25,
    FIGURE_ACTION_TAX_COLLECTOR_CREATED = 26,
    FIGURE_ACTION_TAX_COLLECTOR_ENTERING_EXITING = 27,
    FIGURE_ACTION_TAX_COLLECTOR_ROAMING = 28,
    FIGURE_ACTION_TAX_COLLECTOR_RETURNING = 29,
    FIGURE_ACTION_ENGINEER_CREATED = 30,
    FIGURE_ACTION_ENGINEER_ENTERING_EXITING = 31,
    FIGURE_ACTION_ENGINEER_ROAMING = 32,
    FIGURE_ACTION_ENGINEER_RETURNING = 33,
    FIGURE_ACTION_DOCKER_IDLING = 34,
    FIGURE_ACTION_DOCKER_IMPORT_QUEUE = 35,
    FIGURE_ACTION_DOCKER_EXPORT_QUEUE = 36,
    FIGURE_ACTION_DOCKER_IMPORT_GOING_TO_WAREHOUSE = 37,
    FIGURE_ACTION_DOCKER_EXPORT_GOING_TO_WAREHOUSE = 38,
    FIGURE_ACTION_DOCKER_EXPORT_RETURNING = 39,
    FIGURE_ACTION_DOCKER_IMPORT_RETURNING = 40,
    FIGURE_ACTION_DOCKER_IMPORT_AT_WAREHOUSE = 41,
    FIGURE_ACTION_DOCKER_EXPORT_AT_WAREHOUSE = 42,
    FIGURE_ACTION_PREFECT_CREATED = 43,
    FIGURE_ACTION_PREFECT_ENTERING_EXITING = 44,
    FIGURE_ACTION_PREFECT_ROAMING = 45,
    FIGURE_ACTION_PREFECT_RETURNING = 46,
    FIGURE_ACTION_PREFECT_GOING_TO_FIRE = 47,
    FIGURE_ACTION_PREFECT_AT_FIRE = 48,
    FIGURE_ACTION_SOLDIER_AT_REST = 49,
    FIGURE_ACTION_SOLDIER_GOING_TO_FORT = 50,
    FIGURE_ACTION_SOLDIER_RETURNING_TO_BARRACKS = 51,
    FIGURE_ACTION_SOLDIER_GOING_TO_STANDARD = 52,
    FIGURE_ACTION_SOLDIER_AT_STANDARD = 53,
    FIGURE_ACTION_SOLDIER_GOING_TO_MILITARY_ACADEMY = 54,
    FIGURE_ACTION_SOLDIER_MOPPING_UP = 55,
    FIGURE_ACTION_SOLDIER_GOING_TO_DISTANT_BATTLE = 56,
    FIGURE_ACTION_SOLDIER_RETURNING_FROM_DISTANT_BATTLE = 57,
    FIGURE_ACTION_TOWER_SENTRY_AT_REST = 58,
    FIGURE_ACTION_TOWER_SENTRY_PATROLLING = 59,
    FIGURE_ACTION_TOWER_SENTRY_RETURNING = 60,
    FIGURE_ACTION_TOWER_SENTRY_GOING_TO_TOWER = 61,
    FIGURE_ACTION_MARKET_BUYER_GOING_TO_STORAGE = 62,
    FIGURE_ACTION_MARKET_BUYER_RETURNING = 63,
    FIGURE_ACTION_WAREHOUSEMAN_CREATED = 64,
    FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE = 65,
    FIGURE_ACTION_WAREHOUSEMAN_AT_DELIVERY_BUILDING = 66,
    FIGURE_ACTION_WAREHOUSEMAN_RETURNING_EMPTY = 67,
    FIGURE_ACTION_WAREHOUSEMAN_GETTING_FOOD = 68,
    FIGURE_ACTION_WAREHOUSEMAN_AT_GRANARY = 69,
    FIGURE_ACTION_WAREHOUSEMAN_RETURNING_WITH_FOOD = 70,
    FIGURE_ACTION_WAREHOUSEMAN_GETTING_RESOURCE = 71,
    FIGURE_ACTION_WAREHOUSEMAN_AT_WAREHOUSE = 72,
    FIGURE_ACTION_WAREHOUSEMAN_RETURNING_WITH_RESOURCE = 73,
    FIGURE_ACTION_TRADE_CARAVAN_CREATED = 74,
    FIGURE_ACTION_TRADE_CARAVAN_ARRIVING = 75,
    FIGURE_ACTION_TRADE_CARAVAN_TRADING = 76,
    FIGURE_ACTION_TRADE_CARAVAN_LEAVING = 77,
    FIGURE_ACTION_TRADE_SHIP_CREATED = 78,
    FIGURE_ACTION_TRADE_SHIP_GOING_TO_DOCK = 79,
    FIGURE_ACTION_TRADE_SHIP_MOORED = 80,
    FIGURE_ACTION_TRADE_SHIP_GOING_TO_DOCK_QUEUE = 81,
    FIGURE_ACTION_TRADE_SHIP_ANCHORED = 82,
    FIGURE_ACTION_TRADE_SHIP_LEAVING = 83,
    FIGURE_ACTION_RIOTER_CREATED = 84,
    FIGURE_ACTION_RIOTER_MOVING = 85,
    FIGURE_ACTION_ENEMY_SPAWNING = 86,
    FIGURE_ACTION_ENEMY_REGROUPING = 87,
    FIGURE_ACTION_ENEMY_ADVANCING = 88,
    FIGURE_ACTION_ENEMY_ENGAGED = 89,
    FIGURE_ACTION_NATIVE_GOING_TO_MEETING_CENTER = 90,
    FIGURE_ACTION_NATIVE_RETURNING_FROM_MEETING = 91,
    FIGURE_ACTION_NATIVE_CREATED = 92,
    FIGURE_ACTION_NATIVE_ATTACKING = 93,
    FIGURE_ACTION_NATIVE_TRADER_GOING_TO_WAREHOUSE = 94,
    FIGURE_ACTION_NATIVE_TRADER_RETURNING = 95,
    FIGURE_ACTION_NATIVE_TRADER_CREATED = 96,
    FIGURE_ACTION_NATIVE_TRADER_AT_WAREHOUSE = 97,
    FIGURE_ACTION_BALLISTA_READY = 98,
    FIGURE_ACTION_FISHING_BOAT_CREATED = 99,
    FIGURE_ACTION_FISHING_BOAT_GOING_TO_FISH = 100,
    FIGURE_ACTION_FISHING_BOAT_FISHING = 101,
    FIGURE_ACTION_FISHING_BOAT_GOING_TO_WHARF = 102,
    FIGURE_ACTION_FISHING_BOAT_AT_WHARF = 103,
    FIGURE_ACTION_FISHING_BOAT_RETURNING_WITH_FISH = 104,
    FIGURE_ACTION_HERD_ANIMAL_AT_REST = 105,
    FIGURE_ACTION_HERD_ANIMAL_MOVING = 106,
    FIGURE_ACTION_HIPPODROME_HORSE_CREATED = 107,
    FIGURE_ACTION_HIPPODROME_HORSE_RACING = 108,
    FIGURE_ACTION_HIPPODROME_HORSE_DONE = 109,
    FIGURE_ACTION_FLOTSAM_CREATED = 110,
    FIGURE_ACTION_FLOTSAM_FLOATING = 111,
    FIGURE_ACTION_FLOTSAM_OFF_MAP = 112,
};
enum {
    TERRAIN_USAGE_ANY = 0,
    TERRAIN_USAGE_ROADS = 1,
    TERRAIN_USAGE_ENEMY = 2,
    TERRAIN_USAGE_PREFER_ROADS = 3,
    TERRAIN_USAGE_WALLS = 4,
    TERRAIN_USAGE_ANIMAL = 5,
};
enum {
    FORMATION_ATTACK_FOOD_CHAIN = 0,
    FORMATION_ATTACK_GOLD_STORES = 1,
    FORMATION_ATTACK_BEST_BUILDINGS = 2,
    FORMATION_ATTACK_TROOPS = 3,
    FORMATION_ATTACK_RANDOM = 4
};
enum {
    FORMATION_TORTOISE = 0,
    FORMATION_DOUBLE_LINE_1 = 1,
    FORMATION_DOUBLE_LINE_2 = 2,
    FORMATION_SINGLE_LINE_1 = 3,
    FORMATION_SINGLE_LINE_2 = 4,
    FORMATION_MOP_UP = 5,
    FORMATION_AT_REST = 6,
    FORMATION_ENEMY_MOB = 7,
    FORMATION_ENEMY_WIDE_COLUMN = 8,
    FORMATION_MAX = 9
};
enum {
    DIR_0_TOP = 0,
    DIR_1_TOP_RIGHT = 1,
    DIR_2_RIGHT = 2,
    DIR_3_BOTTOM_RIGHT = 3,
    DIR_4_BOTTOM = 4,
    DIR_5_BOTTOM_LEFT = 5,
    DIR_6_LEFT = 6,
    DIR_7_TOP_LEFT = 7,
    DIR_8_NONE = 8,
    DIR_FIGURE_AT_DESTINATION = 8,
    DIR_FIGURE_REROUTE = 9,
    DIR_FIGURE_LOST = 10,
    DIR_FIGURE_ATTACK = 11,
};
enum {
    SOUND_MUSIC = 1,
    SOUND_SPEECH = 2,
    SOUND_EFFECTS = 3,
    SOUND_CITY = 4,
};
enum {
    TRADE_SHIP_NONE = 0,
    TRADE_SHIP_BUYING = 1,
    TRADE_SHIP_SELLING = 2,
};
enum {
    MAP_FLAG_ENTRY = 1,
    MAP_FLAG_EXIT = 2,
    MAP_FLAG_EARTHQUAKE_MIN = 3,
    MAP_FLAG_EARTHQUAKE_MAX = 12,
    MAP_FLAG_INVASION_MIN = 13,
    MAP_FLAG_INVASION_MAX = 20,
    MAP_FLAG_RIVER_ENTRY = 21,
    MAP_FLAG_RIVER_EXIT = 22,
    MAP_FLAG_FISHING_MIN = 23,
    MAP_FLAG_FISHING_MAX = 30,
    MAP_FLAG_HERD_MIN = 31,
    MAP_FLAG_HERD_MAX = 38,
    MAP_FLAG_MIN = 1,
    MAP_FLAG_MAX = 39,
};
enum {
    OVERLAY_NONE = 0,
    OVERLAY_WATER = 2,
    OVERLAY_RELIGION = 4,
    OVERLAY_FIRE = 8,
    OVERLAY_DAMAGE = 9,
    OVERLAY_CRIME = 10,
    OVERLAY_ENTERTAINMENT = 11,
    OVERLAY_THEATER = 12,
    OVERLAY_AMPHITHEATER = 13,
    OVERLAY_COLOSSEUM = 14,
    OVERLAY_HIPPODROME = 15,
    OVERLAY_EDUCATION = 16,
    OVERLAY_SCHOOL = 17,
    OVERLAY_LIBRARY = 18,
    OVERLAY_ACADEMY = 19,
    OVERLAY_BARBER = 20,
    OVERLAY_BATHHOUSE = 21,
    OVERLAY_CLINIC = 22,
    OVERLAY_HOSPITAL = 23,
    OVERLAY_TAX_INCOME = 24,
    OVERLAY_FOOD_STOCKS = 25,
    OVERLAY_DESIRABILITY = 26,
    OVERLAY_WORKERS_UNUSED = 27,
    OVERLAY_NATIVE = 28,
    OVERLAY_PROBLEMS = 29
};
enum {
    CLIP_NONE,
    CLIP_LEFT,
    CLIP_RIGHT,
    CLIP_TOP,
    CLIP_BOTTOM,
    CLIP_BOTH,
    CLIP_INVISIBLE
};
enum {
    FONT_NORMAL_PLAIN,
    FONT_NORMAL_BLACK,
    FONT_NORMAL_WHITE,
    FONT_NORMAL_RED,
    FONT_LARGE_PLAIN,
    FONT_LARGE_BLACK,
    FONT_LARGE_BROWN,
    FONT_SMALL_PLAIN,
    FONT_NORMAL_GREEN,
    FONT_NORMAL_BROWN,
    FONT_TYPES_MAX
};
enum {
    WINDOW_LOGO,
    WINDOW_MAIN_MENU,
    WINDOW_CONFIG,
    WINDOW_HOTKEY_CONFIG,
    WINDOW_HOTKEY_EDITOR,
    WINDOW_CCK_SELECTION,
    WINDOW_FILE_DIALOG,
    WINDOW_POPUP_DIALOG,
    WINDOW_PLAIN_MESSAGE_DIALOG,
    WINDOW_INTRO_VIDEO,
    // mission start/end
    WINDOW_INTERMEZZO,
    WINDOW_MISSION_SELECTION,
    WINDOW_MISSION_BRIEFING,
    WINDOW_VICTORY_DIALOG,
    WINDOW_VICTORY_VIDEO,
    WINDOW_MISSION_END,
    // city
    WINDOW_CITY,
    WINDOW_CITY_MILITARY,
    WINDOW_TOP_MENU,
    WINDOW_OVERLAY_MENU,
    WINDOW_MILITARY_MENU,
    WINDOW_BUILD_MENU,
    WINDOW_SLIDING_SIDEBAR,
    WINDOW_MESSAGE_DIALOG,
    WINDOW_MESSAGE_LIST,
    WINDOW_BUILDING_INFO,
    // advisors and dialogs
    WINDOW_ADVISORS,
    WINDOW_LABOR_PRIORITY,
    WINDOW_SET_SALARY,
    WINDOW_DONATE_TO_CITY,
    WINDOW_GIFT_TO_EMPEROR,
    WINDOW_TRADE_PRICES,
    WINDOW_RESOURCE_SETTINGS,
    WINDOW_HOLD_FESTIVAL,
    // empire and dialog
    WINDOW_EMPIRE,
    WINDOW_TRADE_OPENED,
    // options dialogs
    WINDOW_DISPLAY_OPTIONS,
    WINDOW_SOUND_OPTIONS,
    WINDOW_SPEED_OPTIONS,
    // utility windows
    WINDOW_SELECT_LIST,
    WINDOW_NUMERIC_INPUT,
    // editor
    WINDOW_EDITOR_MAP,
    WINDOW_EDITOR_TOP_MENU,
    WINDOW_EDITOR_BUILD_MENU,
    WINDOW_EDITOR_EMPIRE,
    WINDOW_EDITOR_ATTRIBUTES,
    WINDOW_EDITOR_BRIEFING,
    WINDOW_EDITOR_STARTING_CONDITIONS,
    WINDOW_EDITOR_START_YEAR,
    WINDOW_EDITOR_WIN_CRITERIA,
    WINDOW_EDITOR_ALLOWED_BUILDINGS,
    WINDOW_EDITOR_SPECIAL_EVENTS,
    WINDOW_EDITOR_REQUESTS,
    WINDOW_EDITOR_EDIT_REQUEST,
    WINDOW_EDITOR_CUSTOM_MESSAGES,
    WINDOW_EDITOR_EDIT_CUSTOM_MESSAGE,
    WINDOW_EDITOR_EARTHQUAKES,
    WINDOW_EDITOR_EDIT_EARTHQUAKE,
    WINDOW_EDITOR_INVASIONS,
    WINDOW_EDITOR_EDIT_INVASION,
    WINDOW_EDITOR_PRICE_CHANGES,
    WINDOW_EDITOR_EDIT_PRICE_CHANGE,
    WINDOW_EDITOR_DEMAND_CHANGES,
    WINDOW_EDITOR_EDIT_DEMAND_CHANGE,
};
enum {
    CURSOR_ARROW = 0,
    CURSOR_SHOVEL = 1,
    CURSOR_SWORD = 2,
    CURSOR_MAX,
};
enum {
    KEY_TYPE_NONE = 0,
    KEY_TYPE_A,
    KEY_TYPE_B,
    KEY_TYPE_C,
    KEY_TYPE_D,
    KEY_TYPE_E,
    KEY_TYPE_F,
    KEY_TYPE_G,
    KEY_TYPE_H,
    KEY_TYPE_I,
    KEY_TYPE_J,
    KEY_TYPE_K,
    KEY_TYPE_L,
    KEY_TYPE_M,
    KEY_TYPE_N,
    KEY_TYPE_O,
    KEY_TYPE_P,
    KEY_TYPE_Q,
    KEY_TYPE_R,
    KEY_TYPE_S,
    KEY_TYPE_T,
    KEY_TYPE_U,
    KEY_TYPE_V,
    KEY_TYPE_W,
    KEY_TYPE_X,
    KEY_TYPE_Y,
    KEY_TYPE_Z,
    KEY_TYPE_1,
    KEY_TYPE_2,
    KEY_TYPE_3,
    KEY_TYPE_4,
    KEY_TYPE_5,
    KEY_TYPE_6,
    KEY_TYPE_7,
    KEY_TYPE_8,
    KEY_TYPE_9,
    KEY_TYPE_0,
    KEY_TYPE_MINUS,
    KEY_TYPE_EQUALS,
    KEY_TYPE_ENTER,
    KEY_TYPE_ESCAPE,
    KEY_TYPE_BACKSPACE,
    KEY_TYPE_TAB,
    KEY_TYPE_CAPSLOCK,
    KEY_TYPE_SPACE,
    KEY_TYPE_LEFTBRACKET,
    KEY_TYPE_RIGHTBRACKET,
    KEY_TYPE_BACKSLASH,
    KEY_TYPE_SEMICOLON,
    KEY_TYPE_APOSTROPHE,
    KEY_TYPE_GRAVE,
    KEY_TYPE_COMMA,
    KEY_TYPE_PERIOD,
    KEY_TYPE_SLASH,
    KEY_TYPE_F1,
    KEY_TYPE_F2,
    KEY_TYPE_F3,
    KEY_TYPE_F4,
    KEY_TYPE_F5,
    KEY_TYPE_F6,
    KEY_TYPE_F7,
    KEY_TYPE_F8,
    KEY_TYPE_F9,
    KEY_TYPE_F10,
    KEY_TYPE_F11,
    KEY_TYPE_F12,
    KEY_TYPE_INSERT,
    KEY_TYPE_DELETE,
    KEY_TYPE_HOME,
    KEY_TYPE_END,
    KEY_TYPE_PAGEUP,
    KEY_TYPE_PAGEDOWN,
    // arrow keys
    KEY_TYPE_RIGHT,
    KEY_TYPE_LEFT,
    KEY_TYPE_DOWN,
    KEY_TYPE_UP,
    // keypad keys
    KEY_TYPE_KP_1,
    KEY_TYPE_KP_2,
    KEY_TYPE_KP_3,
    KEY_TYPE_KP_4,
    KEY_TYPE_KP_5,
    KEY_TYPE_KP_6,
    KEY_TYPE_KP_7,
    KEY_TYPE_KP_8,
    KEY_TYPE_KP_9,
    KEY_TYPE_KP_0,
    KEY_TYPE_KP_PERIOD,
    KEY_TYPE_KP_PLUS,
    KEY_TYPE_KP_MINUS,
    KEY_TYPE_KP_MULTIPLY,
    KEY_TYPE_KP_DIVIDE,
    // the key next to left shift on ISO (Non-US) keyboards, usually \ or <
    KEY_TYPE_NON_US,
    KEY_TYPE_MAX_ITEMS
};
enum {
    KEY_MOD_NONE = 0,
    KEY_MOD_SHIFT = 1,
    KEY_MOD_CTRL = 2,
    KEY_MOD_ALT = 4,
    KEY_MOD_GUI = 8,
};
enum {
    SCROLL_NONE = 0,
    SCROLL_UP = -1,
    SCROLL_DOWN = 1
};
enum {
    SCROLL_TYPE_CITY = 0,
    SCROLL_TYPE_EMPIRE = 1,
    SCROLL_TYPE_MAX = 2
};
enum {
    GRID_SIZE = 162
};
enum {
    TERRAIN_SHRUB = 1,
    TERRAIN_ROCK = 2,
    TERRAIN_WATER = 4,
    TERRAIN_BUILDING = 8,
    TERRAIN_TREE = 16,
    TERRAIN_GARDEN = 32,
    TERRAIN_ROAD = 64,
    TERRAIN_RESERVOIR_RANGE = 128,
    TERRAIN_AQUEDUCT = 256,
    TERRAIN_ELEVATION = 512,
    TERRAIN_ACCESS_RAMP = 1024,
    TERRAIN_MEADOW = 2048,
    TERRAIN_RUBBLE = 4096,
    TERRAIN_FOUNTAIN_RANGE = 8192,
    TERRAIN_WALL = 16384,
    TERRAIN_GATEHOUSE = 32768,
    // combined
    TERRAIN_WALL_OR_GATEHOUSE = TERRAIN_WALL | TERRAIN_GATEHOUSE,
    TERRAIN_NOT_CLEAR = TERRAIN_SHRUB | TERRAIN_ROCK | TERRAIN_WATER | TERRAIN_BUILDING | TERRAIN_TREE | TERRAIN_GARDEN | TERRAIN_ROAD | TERRAIN_AQUEDUCT | TERRAIN_ELEVATION | TERRAIN_ACCESS_RAMP | TERRAIN_RUBBLE | TERRAIN_WALL | TERRAIN_GATEHOUSE,
    TERRAIN_CLEARABLE = TERRAIN_SHRUB | TERRAIN_BUILDING | TERRAIN_TREE | TERRAIN_GARDEN | TERRAIN_ROAD | TERRAIN_AQUEDUCT | TERRAIN_RUBBLE | TERRAIN_WALL | TERRAIN_GATEHOUSE,
    TERRAIN_IMPASSABLE = TERRAIN_SHRUB | TERRAIN_ROCK | TERRAIN_WATER | TERRAIN_BUILDING | TERRAIN_TREE | TERRAIN_ELEVATION | TERRAIN_WALL | TERRAIN_GATEHOUSE,
    TERRAIN_ALL = 65535
};
enum {
    ROUTED_BUILDING_ROAD = 0,
    ROUTED_BUILDING_WALL = 1,
    ROUTED_BUILDING_AQUEDUCT = 2,
    ROUTED_BUILDING_AQUEDUCT_WITHOUT_GRAPHIC = 4,
};
enum {
    CITIZEN_0_ROAD = 0,
    CITIZEN_2_PASSABLE_TERRAIN = 2,
    CITIZEN_4_CLEAR_TERRAIN = 4,
    CITIZEN_N1_BLOCKED = -1,
    CITIZEN_N3_AQUEDUCT = -3,
    CITIZEN_N4_RESERVOIR_CONNECTOR = -4,

    NONCITIZEN_0_PASSABLE = 0,
    NONCITIZEN_1_BUILDING = 1,
    NONCITIZEN_2_CLEARABLE = 2,
    NONCITIZEN_3_WALL = 3,
    NONCITIZEN_4_GATEHOUSE = 4,
    NONCITIZEN_5_FORT = 5,
    NONCITIZEN_N1_BLOCKED = -1,

    WATER_0_PASSABLE = 0,
    WATER_N1_BLOCKED = -1,
    WATER_N2_MAP_EDGE = -2,
    WATER_N3_LOW_BRIDGE = -3,

    WALL_0_PASSABLE = 0,
    WALL_N1_BLOCKED = -1,
};
enum {
    EDGE_X0Y0 = 0,
    EDGE_X1Y0 = 1,
    EDGE_X2Y0 = 2,
    EDGE_X0Y1 = 8,
    EDGE_X1Y1 = 9,
    EDGE_X2Y1 = 10,
    EDGE_X0Y2 = 16,
    EDGE_X1Y2 = 17,
    EDGE_X2Y2 = 18
};
enum {
    CLIMATE_NORTHERN = 0,
    CLIMATE_CENTRAL = 1,
    CLIMATE_DESERT = 2,
};
enum {
    EVENT_DISABLED = 0,
    EVENT_NOT_STARTED = 1,
    EVENT_IN_PROGRESS = 2,
    EVENT_FINISHED = 3
};
enum {
    INVASION_TYPE_LOCAL_UPRISING = 1,
    INVASION_TYPE_ENEMY_ARMY = 2,
    INVASION_TYPE_CAESAR = 3,
    INVASION_TYPE_DISTANT_BATTLE = 4,
};
enum {
    REQUEST_STATE_NORMAL = 0,
    REQUEST_STATE_OVERDUE = 1,
    REQUEST_STATE_DISPATCHED = 2,
    REQUEST_STATE_DISPATCHED_LATE = 3,
    REQUEST_STATE_IGNORED = 4,
    REQUEST_STATE_RECEIVED = 5
};
enum {
    SOUND_CHANNEL_SPEECH = 0,
    // user interface effects
    SOUND_CHANNEL_EFFECTS_MIN = 1,
    SOUND_CHANNEL_EFFECTS_MAX = 44,
    // city sounds (from buildings)
    SOUND_CHANNEL_CITY_MIN = 45,
    SOUND_CHANNEL_CITY_MAX = 150,
    SOUND_CHANNEL_MAX = SOUND_CHANNEL_CITY_MAX + 1
};
enum {
    SOUND_DIRECTION_LEFT = 0,
    SOUND_DIRECTION_CENTER = 2,
    SOUND_DIRECTION_RIGHT = 4
};
enum {
    SOUND_EFFECT_PANEL = 1,
    SOUND_EFFECT_SIDEBAR = 2,
    SOUND_EFFECT_ICON = 3,
    SOUND_EFFECT_BUILD = 4,
    SOUND_EFFECT_EXPLOSION = 5,
    SOUND_EFFECT_FANFARE = 6,
    SOUND_EFFECT_FANFARE_URGENT = 7,
    // battle effects
    SOUND_EFFECT_ARROW = 8,
    SOUND_EFFECT_ARROW_HIT = 9,
    SOUND_EFFECT_AXE = 10,
    SOUND_EFFECT_BALLISTA_SHOOT = 11,
    SOUND_EFFECT_BALLISTA_HIT_GROUND = 12,
    SOUND_EFFECT_BALLISTA_HIT_PERSON = 13,
    SOUND_EFFECT_CLUB = 14,
    SOUND_EFFECT_CAMEL = 15,
    SOUND_EFFECT_ELEPHANT = 16,
    SOUND_EFFECT_ELEPHANT_HIT = 17,
    SOUND_EFFECT_ELEPHANT_DIE = 18,
    SOUND_EFFECT_HORSE = 19,
    SOUND_EFFECT_HORSE2 = 20,
    SOUND_EFFECT_HORSE_MOVING = 21,
    SOUND_EFFECT_JAVELIN = 22,
    SOUND_EFFECT_LION_ATTACK = 23,
    SOUND_EFFECT_LION_DIE = 24,
    SOUND_EFFECT_HORN3 = 25,
    SOUND_EFFECT_SWORD = 26,
    SOUND_EFFECT_SWORD_SWING = 27,
    SOUND_EFFECT_LIGHT_SWORD = 28,
    SOUND_EFFECT_SPEAR = 29,
    SOUND_EFFECT_WOLF_ATTACK = 30,
    SOUND_EFFECT_WOLF_ATTACK_2 = 31,
    SOUND_EFFECT_WOLF_DIE = 32,
    SOUND_EFFECT_SOLDIER_DIE = 33, // 4x
    SOUND_EFFECT_CITIZEN_DIE = 37, // 4x
    SOUND_EFFECT_SHEEP_DIE = 41,
    SOUND_EFFECT_ZEBRA_DIE = 42,
    SOUND_EFFECT_WOLF_HOWL = 43,
    SOUND_EFFECT_FIRE_SPLASH = 44,
    SOUND_EFFECT_FORMATION_SHIELD = 45
};
enum {
    MENU_VACANT_HOUSE = 0,
    MENU_CLEAR_LAND = 1,
    MENU_ROAD = 2,
    MENU_WATER = 3,
    MENU_HEALTH = 4,
    MENU_TEMPLES = 5,
    MENU_EDUCATION = 6,
    MENU_ENTERTAINMENT = 7,
    MENU_ADMINISTRATION = 8,
    MENU_ENGINEERING = 9,
    MENU_SECURITY = 10,
    MENU_INDUSTRY = 11,
};
enum {
    FILE_DIALOG_SAVE = 0,
    FILE_DIALOG_LOAD = 1,
    FILE_DIALOG_DELETE = 2
};
enum {
    FILE_TYPE_SAVED_GAME = 0,
    FILE_TYPE_SCENARIO = 1
};
enum {
    MESSAGE_NONE = 0,
    MESSAGE_MISSING_PATCH = 1,
};
enum {
    MESSAGE_DIALOG_ABOUT = 0,
    MESSAGE_DIALOG_HELP = 10,
    MESSAGE_DIALOG_TOP_FUNDS = 15,
    MESSAGE_DIALOG_TOP_POPULATION = 16,
    MESSAGE_DIALOG_TOP_DATE = 17,
    MESSAGE_DIALOG_OVERLAYS = 18,
    MESSAGE_DIALOG_ADVISOR_LABOR = 20,
    MESSAGE_DIALOG_ADVISOR_MILITARY = 21,
    MESSAGE_DIALOG_ADVISOR_IMPERIAL = 22,
    MESSAGE_DIALOG_ADVISOR_RATINGS = 23,
    MESSAGE_DIALOG_ADVISOR_TRADE = 24,
    MESSAGE_DIALOG_ADVISOR_POPULATION = 25,
    MESSAGE_DIALOG_ADVISOR_HEALTH = 26,
    MESSAGE_DIALOG_ADVISOR_EDUCATION = 27,
    MESSAGE_DIALOG_ADVISOR_ENTERTAINMENT = 28,
    MESSAGE_DIALOG_ADVISOR_RELIGION = 29,
    MESSAGE_DIALOG_ADVISOR_FINANCIAL = 30,
    MESSAGE_DIALOG_ADVISOR_CHIEF = 31,
    MESSAGE_DIALOG_EMPIRE_MAP = 32,
    MESSAGE_DIALOG_MESSAGES = 34,
    MESSAGE_DIALOG_INDUSTRY = 46,
    MESSAGE_DIALOG_THEFT = 251,
    MESSAGE_DIALOG_EDITOR_ABOUT = 331,
    MESSAGE_DIALOG_EDITOR_HELP = 332,
};
enum {
    POPUP_DIALOG_NONE = -1,
    POPUP_DIALOG_QUIT = 0,
    POPUP_DIALOG_OPEN_TRADE = 2,
    POPUP_DIALOG_SEND_GOODS = 4,
    POPUP_DIALOG_NOT_ENOUGH_GOODS = 6,
    POPUP_DIALOG_NO_LEGIONS_AVAILABLE = 8,
    POPUP_DIALOG_NO_LEGIONS_SELECTED = 10,
    POPUP_DIALOG_SEND_TROOPS = 12,
    POPUP_DIALOG_DELETE_FORT = 14,
    POPUP_DIALOG_DELETE_BRIDGE = 18,
    POPUP_DIALOG_EDITOR_QUIT_WITHOUT_SAVING = 20,
};
enum {
    SLIDE_DIRECTION_IN = 0,
    SLIDE_DIRECTION_OUT = 1
};
enum {
    USER_EVENT_QUIT,
    USER_EVENT_RESIZE,
    USER_EVENT_FULLSCREEN,
    USER_EVENT_WINDOWED,
    USER_EVENT_CENTER_WINDOW,
};
enum {
    IB_NORMAL = 4,
    IB_SCROLL = 6,
    IB_BUILD = 2
};
enum {
    STATUS_NOT_ENOUGH_RESOURCES = -1,
    STATUS_CONFIRM_SEND_LEGIONS = -2,
    STATUS_NO_LEGIONS_SELECTED = -3,
    STATUS_NO_LEGIONS_AVAILABLE = -4,
};
enum {
    MODE_TEXT,
    MODE_GROUP,
};
enum {
    INTERMEZZO_MISSION_BRIEFING = 0,
    INTERMEZZO_FIRED = 1,
    INTERMEZZO_WON = 2,
};
enum {
    TYPE_NONE,
    TYPE_SPACE,
    TYPE_HEADER,
    TYPE_INPUT_BOX,
    TYPE_CHECKBOX,
    TYPE_NUMERICAL_DESC,
    TYPE_NUMERICAL_RANGE
};
enum {
    RANGE_DISPLAY_SCALE,
    RANGE_CURSOR_SCALE
};
enum {
    INFO_NONE = 0,
    INFO_FUNDS = 1,
    INFO_POPULATION = 2,
    INFO_DATE = 3
};
enum {
    FIGURE_COLOR_NONE = 0,
    FIGURE_COLOR_SOLDIER = 1,
    FIGURE_COLOR_SELECTED_SOLDIER = 2,
    FIGURE_COLOR_ENEMY = 3,
    FIGURE_COLOR_WOLF = 4
};
enum {
    REFRESH_NOT_NEEDED = 0,
    REFRESH_FULL = 1,
    REFRESH_CAMERA_MOVED = 2
};
enum {
    COLUMN_TYPE_RISK,
    COLUMN_TYPE_ACCESS
};
enum {
    SIDEBAR_EXTRA_DISPLAY_NONE = 0,
    SIDEBAR_EXTRA_DISPLAY_GAME_SPEED = 1,
    SIDEBAR_EXTRA_DISPLAY_UNEMPLOYMENT = 2,
    SIDEBAR_EXTRA_DISPLAY_RATINGS = 4,
    SIDEBAR_EXTRA_DISPLAY_ALL = 7
};
enum {
    SOUND_CHANNEL_CITY_VACANT_LOT = 46, // house_slum1 and house_slum2
    SOUND_CHANNEL_CITY_HOUSE_SLUM = 48,
    SOUND_CHANNEL_CITY_HOUSE_POOR = 50,
    SOUND_CHANNEL_CITY_HOUSE_MEDIUM = 54,
    SOUND_CHANNEL_CITY_HOUSE_GOOD = 58,
    SOUND_CHANNEL_CITY_HOUSE_POSH = 62,
    SOUND_CHANNEL_CITY_EMPTY_LAND = 66,
    SOUND_CHANNEL_CITY_RESERVOIR = 67,
    SOUND_CHANNEL_CITY_AQUEDUCT = 68,
    SOUND_CHANNEL_CITY_FOUNTAIN = 69,
    SOUND_CHANNEL_CITY_WELL = 70,
    SOUND_CHANNEL_CITY_BARBER = 71,
    SOUND_CHANNEL_CITY_BATHHOUSE = 72,
    SOUND_CHANNEL_CITY_CLINIC = 73,
    SOUND_CHANNEL_CITY_HOSPITAL = 74,
    SOUND_CHANNEL_CITY_TEMPLE_CERES = 75,
    SOUND_CHANNEL_CITY_TEMPLE_NEPTUNE = 76,
    SOUND_CHANNEL_CITY_TEMPLE_MERCURY = 78,
    SOUND_CHANNEL_CITY_TEMPLE_MARS = 79,
    SOUND_CHANNEL_CITY_TEMPLE_VENUS = 81,
    SOUND_CHANNEL_CITY_ORACLE = 82,
    SOUND_CHANNEL_CITY_SCHOOL = 83,
    SOUND_CHANNEL_CITY_ACADEMY = 84,
    SOUND_CHANNEL_CITY_LIBRARY = 85,
    SOUND_CHANNEL_CITY_THEATER = 86,
    SOUND_CHANNEL_CITY_AMPHITHEATER = 87,
    SOUND_CHANNEL_CITY_COLOSSEUM = 88,
    SOUND_CHANNEL_CITY_HIPPODROME = 89,
    SOUND_CHANNEL_CITY_GLADIATOR_SCHOOL = 90,
    SOUND_CHANNEL_CITY_LION_PIT = 91,
    SOUND_CHANNEL_CITY_ACTOR_COLONY = 92,
    SOUND_CHANNEL_CITY_CHARIOT_MAKER = 93,
    SOUND_CHANNEL_CITY_FORUM = 94,
    SOUND_CHANNEL_CITY_SENATE = 95,
    SOUND_CHANNEL_CITY_PALACE = 96,
    SOUND_CHANNEL_CITY_STATUE = 97,
    SOUND_CHANNEL_CITY_GARDEN = 98,
    SOUND_CHANNEL_CITY_SHIPYARD = 102,
    SOUND_CHANNEL_CITY_DOCK = 105,
    SOUND_CHANNEL_CITY_WHARF = 108,
    SOUND_CHANNEL_CITY_TOWER = 111,
    SOUND_CHANNEL_CITY_FORT = 115,
    SOUND_CHANNEL_CITY_BARRACKS = 119,
    SOUND_CHANNEL_CITY_MILITARY_ACADEMY = 120,
    SOUND_CHANNEL_CITY_WHEAT_FARM = 121,
    SOUND_CHANNEL_CITY_VEGETABLE_FARM = 123,
    SOUND_CHANNEL_CITY_FRUIT_FARM = 124,
    SOUND_CHANNEL_CITY_OLIVE_FARM = 125,
    SOUND_CHANNEL_CITY_VINE_FARM = 126,
    SOUND_CHANNEL_CITY_PIG_FARM = 127,
    SOUND_CHANNEL_CITY_CLAY_PIT = 128,
    SOUND_CHANNEL_CITY_QUARRY = 129,
    SOUND_CHANNEL_CITY_IRON_MINE = 130,
    SOUND_CHANNEL_CITY_TIMBER_YARD = 131,
    SOUND_CHANNEL_CITY_WINE_WORKSHOP = 132,
    SOUND_CHANNEL_CITY_OIL_WORKSHOP = 133,
    SOUND_CHANNEL_CITY_WEAPONS_WORKSHOP = 134,
    SOUND_CHANNEL_CITY_FURNITURE_WORKSHOP = 136,
    SOUND_CHANNEL_CITY_POTTERY_WORKSHOP = 138,
    SOUND_CHANNEL_CITY_MARKET = 140,
    SOUND_CHANNEL_CITY_GRANARY = 144,
    SOUND_CHANNEL_CITY_WAREHOUSE = 147,
    SOUND_CHANNEL_CITY_BURNING_RUIN = 150,
};
enum {
    TRACK_NONE = 0,
    TRACK_CITY_1 = 1,
    TRACK_CITY_2 = 2,
    TRACK_CITY_3 = 3,
    TRACK_CITY_4 = 4,
    TRACK_CITY_5 = 5,
    TRACK_COMBAT_SHORT = 6,
    TRACK_COMBAT_LONG = 7,
    TRACK_INTRO = 8,
    TRACK_MAX = 9
};
enum {
    EVENT_ROME_RAISES_WAGES = 1,
    EVENT_ROME_LOWERS_WAGES = 2,
    EVENT_LAND_TRADE_DISRUPTED = 3,
    EVENT_LAND_SEA_DISRUPTED = 4,
    EVENT_CONTAMINATED_WATER = 5
};
enum {
    BIT_SIZE1 = 0x00,
    BIT_SIZE2 = 0x01,
    BIT_SIZE3 = 0x02,
    BIT_SIZE4 = 0x04,
    BIT_SIZE5 = 0x08,
    BIT_SIZES = 0x0f,
    BIT_NO_SIZES = 0xf0,
    BIT_CONSTRUCTION = 0x10,
    BIT_NO_CONSTRUCTION = 0xef,
    BIT_ALTERNATE_TERRAIN = 0x20,
    BIT_DELETED = 0x40,
    BIT_NO_DELETED = 0xbf,
    BIT_PLAZA_OR_EARTHQUAKE = 0x80,
    BIT_NO_PLAZA = 0x7f,
    BIT_NO_CONSTRUCTION_AND_DELETED = 0xaf,
    EDGE_MASK_X = 0x7,
    EDGE_MASK_Y = 0x38,
    EDGE_MASK_XY = 0x3f,
    EDGE_LEFTMOST_TILE = 0x40,
    EDGE_NO_LEFTMOST_TILE = 0xbf,
    EDGE_NATIVE_LAND = 0x80,
    EDGE_NO_NATIVE_LAND = 0x7f,
};
enum {
    CONTEXT_WATER,
    CONTEXT_WALL,
    CONTEXT_WALL_GATEHOUSE,
    CONTEXT_ELEVATION,
    CONTEXT_EARTHQUAKE,
    CONTEXT_DIRT_ROAD,
    CONTEXT_PAVED_ROAD,
    CONTEXT_AQUEDUCT,
    CONTEXT_MAX_ITEMS
};
enum {
    SYSTEM_NONE = 0,
    SYSTEM_UP = 1,
    SYSTEM_DOWN = 2,
    SYSTEM_DOUBLE_CLICK = 4
};
enum {
    KEY_STATE_UNPRESSED = 0,
    KEY_STATE_PRESSED = 1,
    KEY_STATE_HELD = 2,
    KEY_STATE_AXIS = 3
};
enum {
    FULL_CITY_SCREENSHOT = 0,
    DISPLAY_SCREENSHOT = 1
};
enum {
    DRAW_TYPE_SET,
    DRAW_TYPE_AND,
    DRAW_TYPE_NONE,
    DRAW_TYPE_BLEND,
    DRAW_TYPE_BLEND_ALPHA
};
enum {
    EVOLVE = 1,
    NONE = 0,
    DEVOLVE = -1
};
enum {
    HORSE_CREATED = 0,
    HORSE_RACING = 1,
    HORSE_FINISHED = 2
};
enum {
    DESTROYABLE_BUILDING,
    DESTROYABLE_AQUEDUCT_GARDEN,
    DESTROYABLE_WALL,
    DESTROYABLE_GATEHOUSE,
    DESTROYABLE_NONE
};
enum {
    EMPIRE_WIDTH = 2000,
    EMPIRE_HEIGHT = 1000,
    EMPIRE_HEADER_SIZE = 1280,
    EMPIRE_DATA_SIZE = 12800
};
enum {
    MENU_NONE = -1,
    MENU_SHRUB = 0,
    MENU_ELEVATION = 1,
    MENU_ROCK = 2,
    MENU_BRUSH_SIZE = 3,
    MENU_EARTHQUAKE_POINTS = 4,
    MENU_INVASION_POINTS = 5,
    MENU_PEOPLE_POINTS = 6,
    MENU_RIVER_POINTS = 7,
    MENU_NATIVE_BUILDINGS = 8,
    MENU_ANIMAL_POINTS = 9,
};
enum {
    TOOL_GRASS = 0,
    TOOL_SMALL_SHRUB = 1,
    TOOL_MEDIUM_SHRUB = 2,
    TOOL_LARGE_SHRUB = 3,
    TOOL_LARGEST_SHRUB = 4,
    TOOL_WATER = 5,
    TOOL_RAISE_LAND = 6,
    TOOL_LOWER_LAND = 7,
    TOOL_ACCESS_RAMP = 8,
    TOOL_TREES = 9,
    TOOL_SMALL_ROCK = 10,
    TOOL_MEDIUM_ROCK = 11,
    TOOL_LARGE_ROCK = 12,
    TOOL_MEADOW = 13,
    TOOL_ROAD = 14,
    TOOL_EARTHQUAKE_POINT = 15,
    TOOL_INVASION_POINT = 16,
    TOOL_ENTRY_POINT = 17,
    TOOL_EXIT_POINT = 18,
    TOOL_RIVER_ENTRY_POINT = 19,
    TOOL_RIVER_EXIT_POINT = 20,
    TOOL_NATIVE_CENTER = 21,
    TOOL_NATIVE_HUT = 22,
    TOOL_NATIVE_FIELD = 23,
    TOOL_HOUSE_VACANT_LOT = 24,
    TOOL_FISHING_POINT = 25,
    TOOL_HERD_POINT = 26
};
enum {
    RATING_CULTURE,
    RATING_PROSPERITY,
    RATING_PEACE,
    RATING_FAVOR
};
enum {
    CUSTOM_MESSAGE_ATTRIBUTES = 0,
    CUSTOM_MESSAGE_TITLE = 1,
    CUSTOM_MESSAGE_TEXT = 2,
};
enum {
    LABOR_CATEGORY_INDUSTRY_COMMERCE = 0,
    LABOR_CATEGORY_FOOD_PRODUCTION = 1,
    LABOR_CATEGORY_ENGINEERING = 2,
    LABOR_CATEGORY_WATER = 3,
    LABOR_CATEGORY_PREFECTURES = 4,
    LABOR_CATEGORY_MILITARY = 5,
    LABOR_CATEGORY_ENTERTAINMENT = 6,
    LABOR_CATEGORY_HEALTH_EDUCATION = 7,
    LABOR_CATEGORY_GOVERNANCE_RELIGION = 8
};
enum {
    BUILDING_INFO_NONE = 0,
    BUILDING_INFO_TERRAIN = 1,
    BUILDING_INFO_BUILDING = 2,
    BUILDING_INFO_LEGION = 4
};
enum {
    TERRAIN_INFO_NONE = 0,
    TERRAIN_INFO_TREE = 1,
    TERRAIN_INFO_ROCK = 2,
    TERRAIN_INFO_WATER = 3,
    TERRAIN_INFO_SHRUB = 4,
    TERRAIN_INFO_EARTHQUAKE = 5,
    TERRAIN_INFO_ROAD = 6,
    TERRAIN_INFO_AQUEDUCT = 7,
    TERRAIN_INFO_RUBBLE = 8,
    TERRAIN_INFO_WALL = 9,
    TERRAIN_INFO_EMPTY = 10,
    TERRAIN_INFO_BRIDGE = 11,
    TERRAIN_INFO_GARDEN = 12,
    TERRAIN_INFO_PLAZA = 13,
    TERRAIN_INFO_ENTRY_FLAG = 14,
    TERRAIN_INFO_EXIT_FLAG = 15
};
enum {
    WELL_NECESSARY = 0,
    WELL_UNNECESSARY_FOUNTAIN = 1,
    WELL_UNNECESSARY_NO_HOUSES = 2
};
enum {
    GOD_STATE_NONE = 0,
    GOD_STATE_VERY_ANGRY = 1,
    GOD_STATE_ANGRY = 2
};
enum {
    WAREHOUSE_ROOM = 0,
    WAREHOUSE_FULL = 1,
    WAREHOUSE_SOME_ROOM = 2
};
enum {
    WAREHOUSE_TASK_NONE = -1,
    WAREHOUSE_TASK_GETTING = 0,
    WAREHOUSE_TASK_DELIVERING = 1
};
enum {
    GRANARY_TASK_NONE = -1,
    GRANARY_TASK_GETTING = 0
};
// end enums

// start chars
static char settings_file_strings[][25] = {
    "fullscreen", // 0
    "window_width", // 1
    "window_height", // 2
    "sound_effects_enabled", // 3
    "sound_effects_volume", // 4
    "music_enabled", // 5
    "music_volume", // 6
    "speech_enabled", // 7
    "speech_volume", // 8
    "city_sounds_enabled", // 9
    "city_sounds_volume", // 10
    "game_speed", // 11
    "scroll_speed", // 12
    "monthly_autosave_enabled", // 13
    "warnings_enabled", // 14
    "victory_video_switch", // 15
    "last_advisor", // 16
};
static char CONFIGS_FILE_PATH[DIR_PATH_MAX]; // the path to "brutus.configs" within the Brutus directory
static char HOTKEY_CONFIGS_FILE_PATH[DIR_PATH_MAX]; // the path to "brutus.hconfigs" within the Brutus directory
static char MAPS_DIR_PATH[DIR_PATH_MAX]; // the path to the /maps folder in the Brutus directory
static char SETTINGS_FILE_PATH[DIR_PATH_MAX]; // the path to "brutus.settings" within the Brutus directory
char SAVES_DIR_PATH[DIR_PATH_MAX]; // the path to the /saves folder in the Brutus directory
static char log_buffer[MSG_SIZE];
static char *key_display_names[KEY_TYPE_MAX_ITEMS] = {
    "", "A", "B", "C", "D", "E", "F", "G", "H", "I",
    "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S",
    "T", "U", "V", "W", "X", "Y", "Z", "1", "2", "3",
    "4", "5", "6", "7", "8", "9", "0", "-", "=", "Enter",
    "Esc", "Backspace", "Tab", "Space", "Left bracket", "Right bracket", "Backslash", ";", "'", "Backtick",
    ",", ".", "/", "F1", "F2", "F3", "F4", "F5", "F6", "F7",
    "F8", "F9", "F10", "F11", "F12", "Insert", "Delete", "Home", "End", "PageUp",
    "PageDown", "Right", "Left", "Down", "Up",
    "Keypad 1", "Keypad 2", "Keypad 3", "Keypad 4", "Keypad 5",
    "Keypad 6", "Keypad 7", "Keypad 8", "Keypad 9", "Keypad 0",
    "Keypad .", "Keypad +", "Keypad -", "Keypad *", "Keypad /", "NonUS"
};
static char *hotkey_strings[] = {
    "Brutus hotkey configuration", // 0
    "Hotkey", // 1
    "Alternative", // 2
    "Reset defaults", // 3
    "Cancel", // 4
    "OK", // 5
};
static char *hotkey_widget_strings[] = {
    "Arrow keys", // 0
    "Up", // 1
    "Down", // 2
    "Left", // 3
    "Right", // 4
    "Global hotkeys", // 5
    "Toggle fullscreen", // 6
    "Reset window", // 7
    "Save screenshot", // 8
    "Save full city screenshot", // 9
    "Load file", // 10
    "Save file", // 11
    "City hotkeys", // 12
    "Decrease game speed", // 13
    "Increase game speed", // 14
    "Toggle pause", // 15
    "Rotate map left", // 16
    "Rotate map right", // 17
    "Replay map", // 18
    "Cycle through legions", // 19
    "Return legions to fort", // 20
    "Show last advisor", // 21
    "Show empire map", // 22
    "Show messages", // 23
    "Go to problem", // 24
    "Overlays", // 25
    "Show water overlay", // 26
    "Show fire overlay", // 27
    "Damage overlay", // 28
    "Crime overlay", // 29
    "Problems overlay", // 30
    "City map bookmarks", // 31
    "Go to bookmark 1", // 32
    "Go to bookmark 2", // 33
    "Go to bookmark 3", // 34
    "Go to bookmark 4", // 35
    "Set bookmark 1", // 36
    "Set bookmark 2", // 37
    "Set bookmark 3", // 38
    "Set bookmark 4", // 39
    "Editor", // 40
    "Toggle battle info", // 41
    "Cheats", // 42
    "Cheat: money", // 43
    "Cheat: invasion", // 44
    "Cheat: victory", // 45
    "Construction hotkeys", // 46
    "Clone building under cursor", // 47
    "Cycle through buildings", // 48
    "Cycle back through buildings", // 49
    "Undo last building", // 50
    "Housing", // 51
};
static char *hotkey_editor_bottom_button_strings[] = {
    "Press new hotkey", // 0
    "Cancel", // 1
    "OK", // 2
};
static char SOUND_FILE_LOSE[] = "wavs/lose_game.wav";
static char SOUND_FILE_WIN[] = "wavs/actors_great1.wav";
static char *intro_videos[NUM_INTRO_VIDEOS] = { "smk/logo.smk", "smk/intro.smk", "smk/credits.smk" };
static char EDITOR_FILES[MAX_EDITOR_FILES][32] = {
    "c3_map.eng",
    "c3_map_mm.eng",
    "c3map.sg2",
    "c3map.555",
    "c3map_north.sg2",
    "c3map_north.555",
    "c3map_south.sg2",
    "c3map_south.555",
    "map_panels.555"
};
static char *config_bottom_button_strings[] = {
    "Configure hotkeys", // 0
    "Reset defaults", // 1
    "Cancel", // 2
    "OK", // 3
};
static char *config_widget_strings[] = {
    "Player name:",
    "Display scale:",
    "Cursor scale:",
    "User interface changes",
    "Extra information in the control panel",
    "Play intro videos",
    "Disable map scrolling on window edge",
    "Disable right click to drag the map",
    "Improve visual feedback when clearing land",
    "Highlight legion on cursor hover",
};
static char *too_many_files_string = "Too many files. Showing 128.";
static char *submenu_strings[] = {
    "Menu: Small Temples",  // 0
    "Menu: Large Temples",  // 1
    "Menu: Forts", // 2
    "Menu: Farms",  // 3
    "Menu: Raw Materials",  // 4
    "Menu: Workshops"  // 5
};
static   char tracks[][32] = {
    "",
    "wavs/ROME1.WAV",
    "wavs/ROME2.WAV",
    "wavs/ROME3.WAV",
    "wavs/ROME4.WAV",
    "wavs/ROME5.WAV",
    "wavs/Combat_Short.wav",
    "wavs/Combat_Long.wav",
    "wavs/setup.wav"
};
static   char mp3_tracks[][32] = {
    "",
    "mp3/ROME1.mp3",
    "mp3/ROME2.mp3",
    "mp3/ROME3.mp3",
    "mp3/ROME4.mp3",
    "mp3/ROME5.mp3",
    "mp3/Combat_Short.mp3",
    "mp3/Combat_Long.mp3",
    "mp3/setup.mp3"
};
static char *key_names[KEY_TYPE_MAX_ITEMS] = {
    "", "A", "B", "C", "D", "E", "F", "G", "H", "I",
    "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S",
    "T", "U", "V", "W", "X", "Y", "Z", "1", "2", "3",
    "4", "5", "6", "7", "8", "9", "0", "-", "=", "Enter",
    "Esc", "Backspace", "Tab", "Space", "[", "]", "\\", ";", "'", "`",
    ",", ".", "/", "F1", "F2", "F3", "F4", "F5", "F6", "F7",
    "F8", "F9", "F10", "F11", "F12", "Insert", "Delete", "Home", "End", "PageUp",
    "PageDown", "Right", "Left", "Down", "Up",
    "Kp1", "Kp2", "Kp3", "Kp4", "Kp5", "Kp6", "Kp7", "Kp8", "Kp9", "Kp0",
    "Kp.", "Kp+", "Kp-", "Kp*", "Kp/", "NonUS"
};
static char tmp_line_text[200];
static char filename_formats[][32] = {
    "full city %Y-%m-%d %H.%M.%S.bmp",
    "city %Y-%m-%d %H.%M.%S.bmp",
};
static char tmp_line_rich_text[200];
static char editor_top_menu_clear_earthquakes_string[] = "Clear earthquakes";
static char CHAR_TO_FONT_IMAGE_DEFAULT[] = {
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01,
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3F, 0x40, 0x00, 0x00, 0x41, 0x00, 0x4A, 0x43, 0x44, 0x42, 0x46, 0x4E, 0x45, 0x4F, 0x4D,
    0x3E, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x48, 0x49, 0x00, 0x47, 0x00, 0x4B,
    0x00, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29,
    0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00, 0x50,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6E, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00,
    0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x72, 0x70, 0x71, 0x71, 0x69, 0x00, 0x6D, 0x65, 0x74, 0x6A, 0x73, 0x73, 0x77, 0x75, 0x76, 0x76,
    0x00, 0x6C, 0x7A, 0x78, 0x79, 0x79, 0x7B, 0x00, 0x00, 0x7E, 0x7C, 0x7D, 0x6B, 0x33, 0x00, 0x68,
    0x53, 0x52, 0x54, 0x51, 0x51, 0x00, 0x67, 0x65, 0x57, 0x56, 0x58, 0x55, 0x5B, 0x5A, 0x5C, 0x59,
    0x00, 0x66, 0x5F, 0x5E, 0x60, 0x60, 0x5D, 0x00, 0x00, 0x63, 0x62, 0x64, 0x61, 0x19, 0x00, 0x19,
};

static char sound_channel_filenames[SOUND_CHANNEL_MAX][CHANNEL_FILENAME_MAX] = {
    "", // speech channel
    "wavs/panel1.wav",
    "wavs/panel3.wav",
    "wavs/icon1.wav",
    "wavs/build1.wav",
    "wavs/explod1.wav",
    "wavs/fanfare.wav",
    "wavs/fanfare2.wav",
    "wavs/arrow.wav",
    "wavs/arrow_hit.wav",
    "wavs/axe.wav",
    "wavs/ballista.wav",
    "wavs/ballista_hit_ground.wav",
    "wavs/ballista_hit_person.wav",
    "wavs/club.wav",
    "wavs/camel1.wav",
    "wavs/elephant.wav",
    "wavs/elephant_hit.wav",
    "wavs/elephant_die.wav",
    "wavs/horse.wav",
    "wavs/horse2.wav",
    "wavs/horse_mov.wav",
    "wavs/javelin.wav",
    "wavs/lion_attack.wav",
    "wavs/lion_die.wav",
    "wavs/horn3.wav",
    "wavs/sword.wav",
    "wavs/sword_swing.wav",
    "wavs/sword_light.wav",
    "wavs/spear_attack.wav",
    "wavs/wolf_attack.wav",
    "wavs/wolf_attack2.wav",
    "wavs/wolf_die.wav",
    "wavs/die1.wav",
    "wavs/die2.wav",
    "wavs/die4.wav",
    "wavs/die10.wav",
    "wavs/die3.wav",
    "wavs/die5.wav",
    "wavs/die8.wav",
    "wavs/die9.wav",
    "wavs/sheep_die.wav",
    "wavs/zebra_die.wav",
    "wavs/wolf_howl.wav",
    "wavs/fire_splash.wav",
    "wavs/formation_shield.wav",
    // city sounds
    "wavs/house_slum1.wav",
    "wavs/house_slum2.wav",
    "wavs/house_slum3.wav",
    "wavs/house_slum4.wav",
    "wavs/house_poor1.wav",
    "wavs/house_poor2.wav",
    "wavs/house_poor3.wav",
    "wavs/house_poor4.wav",
    "wavs/house_mid1.wav",
    "wavs/house_mid2.wav",
    "wavs/house_mid3.wav",
    "wavs/house_mid4.wav",
    "wavs/house_good1.wav",
    "wavs/house_good2.wav",
    "wavs/house_good3.wav",
    "wavs/house_good4.wav",
    "wavs/house_posh1.wav",
    "wavs/house_posh2.wav",
    "wavs/house_posh3.wav",
    "wavs/house_posh4.wav",
    "wavs/empty_land1.wav",
    "wavs/resevoir.wav",
    "wavs/aquaduct.wav", // same as river.wav
    "wavs/fountain.wav",
    "wavs/well.wav",
    "wavs/barber.wav",
    "wavs/baths.wav",
    "wavs/clinic.wav",
    "wavs/hospital.wav",
    "wavs/temp_farm.wav",
    "wavs/temp_ship.wav",
    "wavs/temple_ship.wav",
    "wavs/temp_comm.wav",
    "wavs/temp_war.wav",
    "wavs/temple_war.wav",
    "wavs/temp_love.wav",
    "wavs/oracle.wav",
    "wavs/school.wav",
    "wavs/academy.wav",
    "wavs/library.wav",
    "wavs/theatre.wav",
    "wavs/ampitheatre.wav",
    "wavs/colloseum.wav",
    "wavs/hippodrome.wav",
    "wavs/glad_pit.wav",
    "wavs/lion_pit.wav",
    "wavs/art_pit.wav",
    "wavs/char_pit.wav",
    "wavs/forum.wav",
    "wavs/senate.wav",
    "wavs/palace.wav",
    "wavs/statue.wav",
    "wavs/gardens1.wav", // same as emptyland1.wav
    "wavs/gardens2.wav", // same as emptyland2.wav
    "wavs/gardens3.wav", // same as emptyland3.wav
    "wavs/gardens4.wav", // same as emptyland4.wav
    "wavs/shipyard.wav",
    "wavs/shipyard1.wav",
    "wavs/shipyard2.wav",
    "wavs/dock.wav",
    "wavs/dock1.wav",
    "wavs/dock2.wav",
    "wavs/wharf.wav",
    "wavs/wharf1.wav",
    "wavs/wharf2.wav",
    "wavs/tower1.wav",
    "wavs/tower2.wav",
    "wavs/tower3.wav",
    "wavs/tower4.wav",
    "wavs/fort1.wav",
    "wavs/fort2.wav",
    "wavs/fort3.wav",
    "wavs/fort4.wav",
    "wavs/mil_acad.wav",
    "wavs/barracks.wav",
    "wavs/wheat.wav",
    "wavs/wheat_farm.wav",
    "wavs/veg_farm.wav",
    "wavs/figs_farm.wav",
    "wavs/olives_farm.wav",
    "wavs/vines_farm.wav",
    "wavs/meat_farm.wav",
    "wavs/clay_pit.wav",
    "wavs/quarry.wav",
    "wavs/mine.wav",
    "wavs/lumber_mill.wav",
    "wavs/wine_workshop.wav",
    "wavs/oil_workshop.wav",
    "wavs/weap_workshop.wav",
    "wavs/weapons_workshop.wav",
    "wavs/furn_workshop.wav",
    "wavs/furniture_workshop.wav",
    "wavs/pott_workshop.wav",
    "wavs/pottery_workshop.wav",
    "wavs/market1.wav",
    "wavs/market2.wav",
    "wavs/market3.wav",
    "wavs/market4.wav",
    "wavs/granary.wav",
    "wavs/granary1.wav",
    "wavs/granary2.wav",
    "wavs/warehouse.wav",
    "wavs/warehouse1.wav",
    "wavs/warehouse2.wav",
    "wavs/burning_ruin.wav",
};
static char *editor_sidebar_menu_label_strings[] = {
    "Grass",
    "Small shrub",
    "Medium shrub",
    "Large shrub",
    "Largest shrub",
    "Water",
    "Raise land",
    "Lower land",
    "Access ramp",
    "Trees",
    "Small rock",
    "Medium rock",
    "Large rock",
    "Meadow",
    "Road",
    "Earthquake",
    "Invasion point",
    "Entry point",
    "Exit point",
    "River IN",
    "River OUT",
    "Native hut",
    "Native center",
    "Native field",
    "Vacant lot",
    "Fishing waters",
    "Herd point",
};
static char editor_menu_types_strings[][MAX_ITEMS_PER_MENU][19] = {
    {"Small shrub", "Medium shrub", "Large shrub", "Largest shrub"},
    {"Raise land", "Lower land", "Access ramp"},
    {"Small rock", "Medium rock", "Large rock"},
    {"Tiny brush", "Small brush", "Medium brush", "Big brush", "Biggest brush"},
    {"Earthquake point 1", "Earthquake point 2", "Earthquake point 3", "Earthquake point 4", "Earthquake point 5", "Earthquake point 6", "Earthquake point 7", "Earthquake point 8"},
    {"Invasion point 1", "Invasion point 2", "Invasion point 3", "Invasion point 4", "Invasion point 5", "Invasion point 6", "Invasion point 7", "Invasion point 8"},
    {"Entry point", "Exit point"},
    {"River entry", "River exit"},
    {"Native hut", "Native center", "Native field", "Vacant lot"},
    {"Fishing point 1", "Fishing point 2", "Fishing point 3", "Fishing point 4", "Fishing point 5", "Fishing point 6", "Fishing point 7", "Fishing point 8",
    "Herd point 1", "Herd point 2", "Herd point 3", "Herd point 4", "Herd point 5", "Herd point 6", "Herd point 7", "Herd point 8"},
};
static char *attribute_window_strings[] = {
    "Scenario briefing", // 0
    "Requests scheduled", // 1
    "No requests", // 2
    "Messages scheduled", // 3
    "No messages", // 4
    "Earthquakes scheduled", // 5
    "No earthquakes", // 6
    "Invasions scheduled", // 7
    "No invasions", // 8
    "Price changes sch.", // 9
    "No price changes", // 10
    "Demand changes sch.", // 11
    "No demand changes", // 12
};
static char *climate_types_strings[] = {
    "Northern provinces", // 0
    "Central provinces", // 1
    "Desert provinces", // 2
};
static char *common_editor_strings[] = {
    "Year offset:", // 0
    "Month:", // 1
    "Jan year 0 invalid", // 2
    "Amount:", // 3
    "Resource:", // 4
    "Hint: 'atL' for new line, 'atP' for new paragraph (replace 'at' with the symbol - will be hidden)", // 5
};
static char *custom_messages_strings[] = {
    "Messages to player", // 0
    "Attributes", // 1
    "Title", // 2
    "Text", // 3
};
static char *earthquakes_strings[] = {
    "Earthquakes", // 0
    "Free earthquake slot", // 1
    "Earthquake point 1", // 2
    "Earthquake point 2", // 3
    "Earthquake point 3", // 4
    "Earthquake point 4", // 5
    "Earthquake point 5", // 6
    "Earthquake point 6", // 7
    "Earthquake point 7", // 8
    "Earthquake point 8", // 9
};
static char *invasions_enemy_type_strings[] = {
    "Barbarians", // 0
    "Carthaginians", // 1
    "Britons", // 2
    "Celts", // 3
    "Picts", // 4
    "Egyptians", // 5
    "Etruscans", // 6
    "Samnites", // 7
    "Gauls", // 8
    "Helvetii", // 9
    "Huns", // 10
    "Goths", // 11
    "Visigoths", // 12
    "Graeci", // 13
    "Macedonians", // 14
    "Numidians", // 15
    "Pergamum", // 16
    "Iberians", // 17
    "Judaeans", // 18
    "Seleucids", // 19
};
static char *invasions_enemy_army_type_strings[] = {
    "No invaders", // 0
    "Local raiders", // 1
    "Enemy army", // 2
    "Caesar's legions", // 3
    "Distant battle", // 4
};
static char briefing[MAX_BRIEFING];
static char editor_custom_message_video_file[MAX_CUSTOM_MESSAGE_VIDEO_TEXT];
static char editor_custom_message_title[MAX_CUSTOM_MESSAGE_TEXT];
static char editor_custom_message_text[MAX_CUSTOM_MESSAGE_TEXT];
static char *earthquake_point_names[MAX_EARTHQUAKE_POINTS];
static char *invasion_type_names[INVASION_TYPE_MAX_COUNT];
static char *enemy_type_names[ENEMY_TYPE_MAX_COUNT];
static char route_display_names[MAX_DEMAND_ROUTES][DEMAND_ROUTE_MAX_NAME_LENGTH] = { {"None available"} };
static char *demand_routes_route_names[MAX_DEMAND_ROUTES];
static char brief_description[MAX_BRIEF_DESCRIPTION];
static char MAIN_GRAPHICS_SG2[][NAME_SIZE] = {
    "c3_north.sg2",
    "c3.sg2",
    "c3_south.sg2"
};
static char MAIN_GRAPHICS_555[][NAME_SIZE] = {
    "c3_north.555",
    "c3.555",
    "c3_south.555"
};
static char EDITOR_GRAPHICS_SG2[][NAME_SIZE] = {
    "c3map_north.sg2",
    "c3map.sg2",
    "c3map_south.sg2"
};
static char EDITOR_GRAPHICS_555[][NAME_SIZE] = {
    "c3map_north.555",
    "c3map.555",
    "c3map_south.555"
};
static char EMPIRE_555[NAME_SIZE] = "The_empire.555";
static char ENEMY_GRAPHICS_SG2[ENEMY_FILES_COUNT][NAME_SIZE] = {
    "carthage.sg2", // used for barbarians
    "carthage.sg2",
    "celts.sg2",
    "egyptians.sg2",
    "Etruscan.sg2",
    "Gaul.sg2",
    "goths.sg2",
    "Greek.sg2",
    "North African.sg2",
    "Persians.sg2",
    "Phoenician.sg2",
};
static char ENEMY_GRAPHICS_555[ENEMY_FILES_COUNT][NAME_SIZE] = {
   "carthage.555", // used for barbarians
   "carthage.555",
   "celts.555",
   "egyptians.555",
   "Etruscan.555",
   "Gaul.555",
   "goths.555",
   "Greek.555",
   "North African.555",
   "Persians.555",
   "Phoenician.555",
};
// Keep this in the same order as the actions in hotkey_config.h
static char *ini_keys_hotkey_config[] = {
    "arrow_up",
    "arrow_down",
    "arrow_left",
    "arrow_right",
    "toggle_fullscreen",
    "reset_window",
    "save_screenshot",
    "save_city_screenshot",
    "load_file",
    "save_file",
    "decrease_game_speed",
    "increase_game_speed",
    "toggle_pause",
    "rotate_map_left",
    "rotate_map_right",
    "replay_map",
    "cycle_legion",
    "return_legions_to_fort",
    "show_last_advisor",
    "show_empire_map",
    "show_messages",
    "go_to_problem",
    "show_overlay_water",
    "show_overlay_fire",
    "show_overlay_damage",
    "show_overlay_crime",
    "show_overlay_problems",
    "go_to_bookmark_1",
    "go_to_bookmark_2",
    "go_to_bookmark_3",
    "go_to_bookmark_4",
    "set_bookmark_1",
    "set_bookmark_2",
    "set_bookmark_3",
    "set_bookmark_4",
    "editor_toggle_battle_info",
    "cheat money",
    "cheat invasion",
    "cheat victory",
    "clone_building",
    "cycle_buildings",
    "cycle_buildings_reverse",
    "undo",
    "build_vacant_house",
    "build_clear_land",
    "build_road",
    "build_reservoir",
    "build_aqueduct",
    "build_fountain",
    "build_well",
    "build_doctor",
    "build_bathhouse",
    "build_barber",
    "build_hospital",
    "build_small_temple_ceres",
    "build_small_temple_neptune",
    "build_small_temple_mercury",
    "build_small_temple_mars",
    "build_small_temple_venus",
    "build_large_temple_ceres",
    "build_large_temple_neptune",
    "build_large_temple_mercury",
    "build_large_temple_mars",
    "build_large_temple_venus",
    "build_oracle",
    "build_school",
    "build_library",
    "build_academy",
    "build_mission_post",
    "build_theater",
    "build_actor_colony",
    "build_amphitheater",
    "build_gladiator_school",
    "build_lion_house",
    "build_colosseum",
    "build_chariot_maker",
    "build_hippodrome",
    "build_gardens",
    "build_plaza",
    "build_small_statue",
    "build_medium_statue",
    "build_large_statue",
    "build_governor's house",
    "build_governor's villa",
    "build_governor's palace",
    "build_forum",
    "build_senate",
    "build_triumphal_arch",
    "build_engineers_post",
    "build_low_bridge",
    "build_ship_bridge",
    "build_shipyard",
    "build_wharf",
    "build_dock",
    "build_prefecture",
    "build_wall",
    "build_tower",
    "build_gatehouse",
    "build_fort_legionaries",
    "build_fort_javelin",
    "build_fort_mounted",
    "build_barracks",
    "build_military_academy",
    "build_wheat_farm",
    "build_vegetable_farm",
    "build_fruit_farm",
    "build_pig_farm",
    "build_olive_farm",
    "build_vines_farm",
    "build_clay_pit",
    "build_timber_yard",
    "build_marble_quarry",
    "build_iron_mine",
    "build_oil_workshop",
    "build_wine_workshop",
    "build_pottery_workshop",
    "build_furniture_workshop",
    "build_weapons_workshop",
    "build_market",
    "build_granary",
    "build_warehouse",
};
// Keep this in the same order as the config_keys in config.h
static char *ini_keys_config[] = {
    "screen_display_scale",
    "screen_cursor_scale",
    "ui_sidebar_info",
    "ui_show_intro_video",
    "ui_disable_mouse_edge_scrolling",
    "ui_disable_map_drag",
    "ui_visual_feedback_on_delete",
    "ui_highlight_legions",
};
static char *ini_string_keys[] = {
    "player_name",
};
static char string_values[CONFIG_STRING_MAX_ENTRIES][CONFIG_STRING_VALUE_MAX];
static char default_string_values[CONFIG_STRING_MAX_ENTRIES][CONFIG_STRING_VALUE_MAX];
static char *resource_strings[] = {
"No resource", // RESOURCE_NONE
"Wheat", // RESOURCE_WHEAT
"Vegetables", // RESOURCE_VEGETABLES
"Fruit", // RESOURCE_FRUIT
"Meat", // RESOURCE_MEAT
"Olives", // RESOURCE_OLIVES
"Vines", // RESOURCE_VINES
"Clay", // RESOURCE_CLAY
"Timber", // RESOURCE_TIMBER
"Marble", // RESOURCE_MARBLE
"Iron", // RESOURCE_IRON
"Oil", // RESOURCE_OIL
"Wine", // RESOURCE_WINE
"Pottery", // RESOURCE_POTTERY
"Furniture", // RESOURCE_FURNITURE
"Weapons", // RESOURCE_WEAPONS
"Denarii" // RESOURCE_DENARII
};
static char *figure_desc_strings[] = {
    "Nobody", // 0
    "Immigrant", // 1
    "Emigrant", // 2
    "Homeless", // 3
    "Patrician", // 4
    "Cart pusher", // 5
    "Citizen", // 6
    "Barber", // 7
    "Baths worker", // 8
    "Doctor", // 9
    "Surgeon", // 10
    "Priest", // 11
    "School child", // 12
    "Teacher", // 13
    "Librarian", // 14
    "Missionary", // 15
    "Actor", // 16
    "Gladiator", // 17
    "Lion tamer", // 18
    "Charioteer", // 19
    "Hippodrome horse", // 20
    "Tax collector", // 21
    "Engineer", // 22
    "Fishing boat", // 23
    "Seagulls", // 24
    "Shipwreck", // 25
    "Docker", // 26
    "Flotsam", // 27
    "Ballista", // 28
    "Bolt", // 29
    "Sentry", // 30
    "Javelin", // 31
    "Prefect", // 32
    "Standard bearer", // 33
    "Javelin thrower", // 34
    "Mounted auxiliary", // 35
    "Legionary", // 36
    "Market buyer", // 37
    "Market trader", // 38
    "Delivery boy", // 39
    "Warehouseman", // 40
    "Protestor", // 41
    "Criminal", // 42
    "Rioter", // 43
    "Caravan of merchants from", // 44
    "Caravan of merchants from", // 45
    "Trade ship from", // 46
    "Indigenous native", // 47
    "Native trader", // 48
    "Wolf", // 49
    "Sheep", // 50
    "Zebra", // 51
    "Enemy", // 52
    "Arrow", // 53
    "Map flag", // 54
    "Explosion", // 55
};
static char *enemy_desc_strings[] = {
    "A barbarian warrior", // 0
    "A Carthaginian soldier", // 1
    "A Briton", // 2
    "Celtic warrior", // 3
    "Pictish warrior", // 4
    "An Egyptian soldier", // 5
    "An Etruscan soldier", // 6
    "A Samnite soldier", // 7
    "Gaulish warrior", // 8
    "A warrior of the Helvetii", // 9
    "A Hun warrior", // 10
    "A Goth warrior", // 11
    "A Visigoth warrior", // 12
    "A Greek soldier", // 13
    "A Macedonian soldier", // 14
    "A Numidian warrior", // 15
    "A soldier from Pergamum", // 16
    "An Iberian warrior", // 17
    "A Judaean warrior", // 18
    "A Seleucid soldier", // 19
    "Imperial soldier", // 20
};
static char FIGURE_SOUNDS[32][20][SOUND_FILENAME_MAX] = {
    { // 0
        "vigils_starv1.wav", "vigils_nojob1.wav", "vigils_needjob1.wav", "vigils_nofun1.wav",
        "vigils_relig1.wav", "vigils_great1.wav", "vigils_great2.wav", "vigils_exact1.wav",
        "vigils_exact2.wav", "vigils_exact3.wav", "vigils_exact4.wav", "vigils_exact5.wav",
        "vigils_exact6.wav", "vigils_exact7.wav", "vigils_exact8.wav", "vigils_exact9.wav",
        "vigils_exact10.wav", "vigils_free1.wav", "vigils_free2.wav", "vigils_free3.wav"
    },
    { // 1
        "wallguard_starv1.wav", "wallguard_nojob1.wav", "wallguard_needjob1.wav", "wallguard_nofun1.wav",
        "wallguard_relig1.wav", "wallguard_great1.wav", "wallguard_great2.wav", "wallguard_exact1.wav",
        "wallguard_exact2.wav", "wallguard_exact3.wav", "wallguard_exact4.wav", "wallguard_exact5.wav",
        "wallguard_exact6.wav", "wallguard_exact7.wav", "wallguard_exact8.wav", "wallguard_exact9.wav",
        "wallguard_exact0.wav", "wallguard_free1.wav", "wallguard_free2.wav", "wallguard_free3.wav"
    },
    { // 2
        "engine_starv1.wav", "engine_nojob1.wav", "engine_needjob1.wav", "engine_nofun1.wav",
        "engine_relig1.wav", "engine_great1.wav", "engine_great2.wav", "engine_exact1.wav",
        "engine_exact2.wav", "engine_exact3.wav", "engine_exact4.wav", "engine_exact5.wav",
        "engine_exact6.wav", "engine_exact7.wav", "engine_exact8.wav", "engine_exact9.wav",
        "engine_exact0.wav", "engine_free1.wav", "engine_free2.wav", "engine_free3.wav"
    },
    { // 3
        "taxman_starv1.wav", "taxman_nojob1.wav", "taxman_needjob1.wav", "taxman_nofun1.wav",
        "taxman_relig1.wav", "taxman_great1.wav", "taxman_great2.wav", "taxman_exact1.wav",
        "taxman_exact2.wav", "taxman_exact3.wav", "taxman_exact4.wav", "taxman_exact5.wav",
        "taxman_exact6.wav", "taxman_exact7.wav", "taxman_exact8.wav", "taxman_exact9.wav",
        "taxman_exact0.wav", "taxman_free1.wav", "taxman_free2.wav", "taxman_free3.wav"
    },
    { // 4
        "market_starv1.wav", "market_nojob1.wav", "market_needjob1.wav", "market_nofun1.wav",
        "market_relig1.wav", "market_great1.wav", "market_great2.wav", "market_exact2.wav",
        "market_exact1.wav", "market_exact3.wav", "market_exact4.wav", "market_exact5.wav",
        "market_exact6.wav", "market_exact7.wav", "market_exact8.wav", "market_exact9.wav",
        "market_exact0.wav", "market_free1.wav", "market_free2.wav", "market_free3.wav"
    },
    { // 5
        "crtpsh_starv1.wav", "crtpsh_nojob1.wav", "crtpsh_needjob1.wav", "crtpsh_nofun1.wav",
        "crtpsh_relig1.wav", "crtpsh_great1.wav", "crtpsh_great2.wav", "crtpsh_exact1.wav",
        "crtpsh_exact2.wav", "crtpsh_exact3.wav", "crtpsh_exact4.wav", "crtpsh_exact5.wav",
        "crtpsh_exact6.wav", "crtpsh_exact7.wav", "crtpsh_exact8.wav", "crtpsh_exact9.wav",
        "crtpsh_exact0.wav", "crtpsh_free1.wav", "crtpsh_free2.wav", "crtpsh_free3.wav"
    },
    { // 6
        "donkey_starv1.wav", "donkey_nojob1.wav", "donkey_needjob1.wav", "donkey_nofun1.wav",
        "donkey_relig1.wav", "donkey_great1.wav", "donkey_great2.wav", "donkey_exact1.wav",
        "donkey_exact2.wav", "donkey_exact3.wav", "donkey_exact4.wav", "donkey_exact5.wav",
        "donkey_exact6.wav", "donkey_exact7.wav", "donkey_exact8.wav", "donkey_exact9.wav",
        "donkey_exact0.wav", "donkey_free1.wav", "donkey_free2.wav", "donkey_free3.wav"
    },
    { // 7
        "boats_starv1.wav", "boats_nojob1.wav", "boats_needjob1.wav", "boats_nofun1.wav",
        "boats_relig1.wav", "boats_great1.wav", "boats_great2.wav", "boats_exact2.wav",
        "boats_exact1.wav", "boats_exact3.wav", "boats_exact4.wav", "boats_exact5.wav",
        "boats_exact6.wav", "boats_exact7.wav", "boats_exact8.wav", "boats_exact9.wav",
        "boats_exact0.wav", "boats_free1.wav", "boats_free2.wav", "boats_free3.wav"
    },
    { // 8
        "priest_starv1.wav", "priest_nojob1.wav", "priest_needjob1.wav", "priest_nofun1.wav",
        "priest_relig1.wav", "priest_great1.wav", "priest_great2.wav", "priest_exact1.wav",
        "priest_exact2.wav", "priest_exact3.wav", "priest_exact4.wav", "priest_exact5.wav",
        "priest_exact6.wav", "priest_exact7.wav", "priest_exact8.wav", "priest_exact9.wav",
        "priest_exact0.wav", "priest_free1.wav", "priest_free2.wav", "priest_free3.wav"
    },
    { // 9
        "teach_starv1.wav", "teach_nojob1.wav", "teach_needjob1.wav", "teach_nofun1.wav",
        "teach_relig1.wav", "teach_great1.wav", "teach_great2.wav", "teach_exact1.wav",
        "teach_exact2.wav", "teach_exact3.wav", "teach_exact4.wav", "teach_exact5.wav",
        "teach_exact6.wav", "teach_exact7.wav", "teach_exact8.wav", "teach_exact9.wav",
        "teach_exact0.wav", "teach_free1.wav", "teach_free2.wav", "teach_free3.wav"
    },
    { // 10
        "pupils_starv1.wav", "pupils_nojob1.wav", "pupils_needjob1.wav", "pupils_nofun1.wav",
        "pupils_relig1.wav", "pupils_great1.wav", "pupils_great2.wav", "pupils_exact1.wav",
        "pupils_exact2.wav", "pupils_exact3.wav", "pupils_exact4.wav", "pupils_exact5.wav",
        "pupils_exact6.wav", "pupils_exact7.wav", "pupils_exact8.wav", "pupils_exact9.wav",
        "pupils_exact0.wav", "pupils_free1.wav", "pupils_free2.wav", "pupils_free3.wav"
    },
    { // 11
        "bather_starv1.wav", "bather_nojob1.wav", "bather_needjob1.wav", "bather_nofun1.wav",
        "bather_relig1.wav", "bather_great1.wav", "bather_great2.wav", "bather_exact1.wav",
        "bather_exact2.wav", "bather_exact3.wav", "bather_exact4.wav", "bather_exact5.wav",
        "bather_exact6.wav", "bather_exact7.wav", "bather_exact8.wav", "bather_exact9.wav",
        "bather_exact0.wav", "bather_free1.wav", "bather_free2.wav", "bather_free3.wav"
    },
    { // 12
        "doctor_starv1.wav", "doctor_nojob1.wav", "doctor_needjob1.wav", "doctor_nofun1.wav",
        "doctor_relig1.wav", "doctor_great1.wav", "doctor_great2.wav", "doctor_exact1.wav",
        "doctor_exact2.wav", "doctor_exact3.wav", "doctor_exact4.wav", "doctor_exact5.wav",
        "doctor_exact6.wav", "doctor_exact7.wav", "doctor_exact8.wav", "doctor_exact9.wav",
        "doctor_exact0.wav", "doctor_free1.wav", "doctor_free2.wav", "doctor_free3.wav"
    },
    { // 13
        "barber_starv1.wav", "barber_nojob1.wav", "barber_needjob1.wav", "barber_nofun1.wav",
        "barber_relig1.wav", "barber_great1.wav", "barber_great2.wav", "barber_exact1.wav",
        "barber_exact2.wav", "barber_exact3.wav", "barber_exact4.wav", "barber_exact5.wav",
        "barber_exact6.wav", "barber_exact7.wav", "barber_exact8.wav", "barber_exact9.wav",
        "barber_exact0.wav", "barber_free1.wav", "barber_free2.wav", "barber_free3.wav"
    },
    { // 14
        "actors_starv1.wav", "actors_nojob1.wav", "actors_needjob1.wav", "actors_nofun1.wav",
        "actors_relig1.wav", "actors_great1.wav", "actors_great2.wav", "actors_exact1.wav",
        "actors_exact2.wav", "actors_exact3.wav", "actors_exact4.wav", "actors_exact5.wav",
        "actors_exact6.wav", "actors_exact7.wav", "actors_exact8.wav", "actors_exact9.wav",
        "actors_exact0.wav", "actors_free1.wav", "actors_free2.wav", "actors_free3.wav"
    },
    { // 15
        "gladtr_starv1.wav", "gladtr_nojob1.wav", "gladtr_needjob1.wav", "gladtr_nofun1.wav",
        "gladtr_relig1.wav", "gladtr_great1.wav", "gladtr_great2.wav", "gladtr_exact1.wav",
        "gladtr_exact2.wav", "gladtr_exact3.wav", "gladtr_exact4.wav", "gladtr_exact5.wav",
        "gladtr_exact6.wav", "gladtr_exact7.wav", "gladtr_exact8.wav", "gladtr_exact9.wav",
        "gladtr_exact0.wav", "gladtr_free1.wav", "gladtr_free2.wav", "gladtr_free3.wav"
    },
    { // 16
        "liontr_starv1.wav", "liontr_nojob1.wav", "liontr_needjob1.wav", "liontr_nofun1.wav",
        "liontr_relig1.wav", "liontr_great1.wav", "liontr_great2.wav", "liontr_exact1.wav",
        "liontr_exact2.wav", "liontr_exact3.wav", "liontr_exact4.wav", "liontr_exact5.wav",
        "liontr_exact6.wav", "liontr_exact7.wav", "liontr_exact8.wav", "liontr_exact9.wav",
        "liontr_exact0.wav", "liontr_free1.wav", "liontr_free2.wav", "liontr_free3.wav"
    },
    { // 17
        "charot_starv1.wav", "charot_nojob1.wav", "charot_needjob1.wav", "charot_nofun1.wav",
        "charot_relig1.wav", "charot_great1.wav", "charot_great2.wav", "charot_exact1.wav",
        "charot_exact2.wav", "charot_exact3.wav", "charot_exact4.wav", "charot_exact5.wav",
        "charot_exact6.wav", "charot_exact7.wav", "charot_exact8.wav", "charot_exact9.wav",
        "charot_exact0.wav", "charot_free1.wav", "charot_free2.wav", "charot_free3.wav"
    },
    { // 18
        "patric_starv1.wav", "patric_nojob1.wav", "patric_needjob1.wav", "patric_nofun1.wav",
        "patric_relig1.wav", "patric_great1.wav", "patric_great2.wav", "patric_exact1.wav",
        "patric_exact2.wav", "patric_exact3.wav", "patric_exact4.wav", "patric_exact5.wav",
        "patric_exact6.wav", "patric_exact7.wav", "patric_exact8.wav", "patric_exact9.wav",
        "patric_exact0.wav", "patric_free1.wav", "patric_free2.wav", "patric_free3.wav"
    },
    { // 19
        "pleb_starv1.wav", "pleb_nojob1.wav", "pleb_needjob1.wav", "pleb_nofun1.wav",
        "pleb_relig1.wav", "pleb_great1.wav", "pleb_great2.wav", "pleb_exact1.wav",
        "pleb_exact2.wav", "pleb_exact3.wav", "pleb_exact4.wav", "pleb_exact5.wav",
        "pleb_exact6.wav", "pleb_exact7.wav", "pleb_exact8.wav", "pleb_exact9.wav",
        "pleb_exact0.wav", "pleb_free1.wav", "pleb_free2.wav", "pleb_free3.wav"
    },
    { // 20
        "rioter_starv1.wav", "rioter_nojob1.wav", "rioter_needjob1.wav", "rioter_nofun1.wav",
        "rioter_relig1.wav", "rioter_great1.wav", "rioter_great2.wav", "rioter_exact1.wav",
        "rioter_exact2.wav", "rioter_exact3.wav", "rioter_exact4.wav", "rioter_exact5.wav",
        "rioter_exact6.wav", "rioter_exact7.wav", "rioter_exact8.wav", "rioter_exact9.wav",
        "rioter_exact0.wav", "rioter_free1.wav", "rioter_free2.wav", "rioter_free3.wav"
    },
    { // 21
        "homeless_starv1.wav", "homeless_nojob1.wav", "homeless_needjob1.wav", "homeless_nofun1.wav",
        "homeless_relig1.wav", "homeless_great1.wav", "homeless_great2.wav", "homeless_exact1.wav",
        "homeless_exact2.wav", "homeless_exact3.wav", "homeless_exact4.wav", "homeless_exact5.wav",
        "homeless_exact6.wav", "homeless_exact7.wav", "homeless_exact8.wav", "homeless_exact9.wav",
        "homeless_exact0.wav", "homeless_free1.wav", "homeless_free2.wav", "homeless_free3.wav"
    },
    { // 22
        "unemploy_starv1.wav", "unemploy_nojob1.wav", "unemploy_needjob1.wav", "unemploy_nofun1.wav",
        "unemploy_relig1.wav", "unemploy_great1.wav", "unemploy_great2.wav", "unemploy_exact1.wav",
        "unemploy_exact2.wav", "unemploy_exact3.wav", "unemploy_exact4.wav", "unemploy_exact5.wav",
        "unemploy_exact6.wav", "unemploy_exact7.wav", "unemploy_exact8.wav", "unemploy_exact9.wav",
        "unemploy_exact0.wav", "unemploy_free1.wav", "unemploy_free2.wav", "unemploy_free3.wav"
    },
    { // 23
        "emigrate_starv1.wav", "emigrate_nojob1.wav", "emigrate_needjob1.wav", "emigrate_nofun1.wav",
        "emigrate_relig1.wav", "emigrate_great1.wav", "emigrate_great2.wav", "emigrate_exact1.wav",
        "emigrate_exact2.wav", "emigrate_exact3.wav", "emigrate_exact4.wav", "emigrate_exact5.wav",
        "emigrate_exact6.wav", "emigrate_exact7.wav", "emigrate_exact8.wav", "emigrate_exact9.wav",
        "emigrate_exact0.wav", "emigrate_free1.wav", "emigrate_free2.wav", "emigrate_free3.wav"
    },
    { // 24
        "immigrant_starv1.wav", "immigrant_nojob1.wav", "immigrant_needjob1.wav", "immigrant_nofun1.wav",
        "immigrant_relig1.wav", "immigrant_great1.wav", "immigrant_great2.wav", "immigrant_exact1.wav",
        "immigrant_exact2.wav", "immigrant_exact3.wav", "immigrant_exact4.wav", "immigrant_exact5.wav",
        "immigrant_exact6.wav", "immigrant_exact7.wav", "immigrant_exact8.wav", "immigrant_exact9.wav",
        "immigrant_exact0.wav", "immigrant_free1.wav", "immigrant_free2.wav", "immigrant_free3.wav"
    },
    { // 25
        "enemy_starv1.wav", "enemy_nojob1.wav", "enemy_needjob1.wav", "enemy_nofun1.wav",
        "enemy_relig1.wav", "enemy_great1.wav", "enemy_great2.wav", "enemy_exact1.wav",
        "enemy_exact2.wav", "enemy_exact3.wav", "enemy_exact4.wav", "enemy_exact5.wav",
        "enemy_exact6.wav", "enemy_exact7.wav", "enemy_exact8.wav", "enemy_exact9.wav",
        "enemy_exact0.wav", "enemy_free1.wav", "enemy_free2.wav", "enemy_free3.wav"
    },
    { // 26
        "local_starv1.wav", "local_nojob1.wav", "local_needjob1.wav", "local_nofun1.wav",
        "local_relig1.wav", "local_great1.wav", "local_great2.wav", "local_exact1.wav",
        "local_exact2.wav", "local_exact3.wav", "local_exact4.wav", "local_exact5.wav",
        "local_exact6.wav", "local_exact7.wav", "local_exact8.wav", "local_exact9.wav",
        "local_exact0.wav", "local_free1.wav", "local_free2.wav", "local_free3.wav"
    },
    { // 27
        "libary_starv1.wav", "libary_nojob1.wav", "libary_needjob1.wav", "libary_nofun1.wav",
        "libary_relig1.wav", "libary_great1.wav", "libary_great2.wav", "libary_exact1.wav",
        "libary_exact2.wav", "libary_exact3.wav", "libary_exact4.wav", "libary_exact5.wav",
        "libary_exact6.wav", "libary_exact7.wav", "libary_exact8.wav", "libary_exact9.wav",
        "libary_exact0.wav", "libary_free1.wav", "libary_free2.wav", "libary_free3.wav"
    },
    { // 28
        "srgeon_starv1.wav", "srgeon_nojob1.wav", "srgeon_needjob1.wav", "srgeon_nofun1.wav",
        "srgeon_relig1.wav", "srgeon_great1.wav", "srgeon_great2.wav", "srgeon_exact1.wav",
        "srgeon_exact2.wav", "srgeon_exact3.wav", "srgeon_exact4.wav", "srgeon_exact5.wav",
        "srgeon_exact6.wav", "srgeon_exact7.wav", "srgeon_exact8.wav", "srgeon_exact9.wav",
        "srgeon_exact0.wav", "srgeon_free1.wav", "srgeon_free2.wav", "srgeon_free3.wav"
    },
    { // 29
        "docker_starv1.wav", "docker_nojob1.wav", "docker_needjob1.wav", "docker_nofun1.wav",
        "docker_relig1.wav", "docker_great1.wav", "docker_great2.wav", "docker_exact1.wav",
        "docker_exact2.wav", "docker_exact3.wav", "docker_exact4.wav", "docker_exact5.wav",
        "docker_exact6.wav", "docker_exact7.wav", "docker_exact8.wav", "docker_exact9.wav",
        "docker_exact0.wav", "docker_free1.wav", "docker_free2.wav", "docker_free3.wav"
    },
    { // 30
        "missionary_starv1.wav", "missionary_nojob1.wav", "missionary_needjob1.wav", "missionary_nofun1.wav",
        "missionary_relig1.wav", "missionary_great1.wav", "missionary_great2.wav", "missionary_exact1.wav",
        "missionary_exact2.wav", "missionary_exact3.wav", "missionary_exact4.wav", "missionary_exact5.wav",
        "missionary_exact6.wav", "missionary_exact7.wav", "missionary_exact8.wav", "missionary_exact9.wav",
        "missionary_exact0.wav", "missionary_free1.wav", "missionary_free2.wav", "missionary_free3.wav"
    },
    { // 31
        "granboy_starv1.wav", "granboy_nojob1.wav", "granboy_needjob1.wav", "granboy_nofun1.wav",
        "granboy_relig1.wav", "granboy_great1.wav", "granboy_great2.wav", "granboy_exact1.wav",
        "granboy_exact2.wav", "granboy_exact3.wav", "granboy_exact4.wav", "granboy_exact5.wav",
        "granboy_exact6.wav", "granboy_exact7.wav", "granboy_exact8.wav", "granboy_exact9.wav",
        "granboy_exact0.wav", "granboy_free1.wav", "granboy_free2.wav", "granboy_free3.wav"
    }
};
static char *all_buildings_strings[] = {
"None", // 0
"Vacant Lot", // 1
"Small Tent", // 2
"Large Tent", // 3
"Small Shack", // 4
"Large Shack", // 5
"Small Hovel", // 6
"Large Hovel", // 7
"Small Casa", // 8
"Large Casa", // 9
"Small Insula", // 10
"Medium Insula", // 11
"Large Insula", // 12
"Grand Insula", // 13
"Small Villa", // 14
"Medium Villa", // 15
"Large Villa", // 16
"Grand Villa", // 17
"Small Palace", // 18
"Medium Palace", // 19
"Large Palace", // 20
"Luxury Palace", // 21
"Clear Land", // 22
"Road", // 23
"Reservoir", // 24
"Aqueduct", // 25
"Fountain", // 26
"Well", // 27
"Doctor", // 28
"Bathhouse", // 29
"Barber", // 30
"Hospital", // 31
"Small Temple: Ceres", // 32
"Small Temple: Neptune", // 33
"Small Temple: Mercury", // 34
"Small Temple: Mars", // 35
"Small Temple: Venus", // 36
"Large Temple: Ceres", // 37
"Large Temple: Neptune", // 38
"Large Temple: Mercury", // 39
"Large Temple: Mars", // 40
"Large Temple: Venus", // 41
"Oracle", // 42
"School", // 43
"Library", // 44
"Academy", // 45
"Mission Post", // 46
"Theater", // 47
"Actor Colony", // 48
"Amphitheater", // 49
"Gladiator School", // 50
"Lion House", // 51
"Colosseum", // 52
"Chariot Maker", // 53
"Hippodrome", // 54
"Gardens", // 55
"Plaza", // 56
"Small Statue", // 57
"Medium Statue", // 58
"Large Statue", // 59
"Governors House", // 60
"Governors Villa", // 61
"Governors Palace", // 62
"Forum", // 63
"Senate", // 64
"Triumphal Arch", // 65
"Engineers Post", // 66
"Low Bridge", // 67
"Ship Bridge", // 68
"Shipyard", // 69
"Wharf", // 70
"Dock", // 71
"Prefecture", // 72
"Wall", // 73
"Tower", // 74
"Gatehouse", // 75
"Fort: Legionaries", // 76
"Fort: Javelin", // 77
"Fort: Mounted", // 78
"Barracks", // 79
"Military Academy", // 80
"Wheat Farm", // 81
"Vegetable Farm", // 82
"Fruit Farm", // 83
"Pig Farm", // 84
"Olive Farm", // 85
"Vines Farm", // 86
"Clay Pit", // 87
"Timber Yard", // 88
"Marble Quarry", // 89
"Iron Mine", // 90
"Oil Workshop", // 91
"Wine Workshop", // 92
"Pottery Workshop", // 93
"Furniture Workshop", // 94
"Weapons Workshop", // 95
"Market", // 96
"Granary", // 97
"Warehouse", // 98
"Warehouse Space", // 99
"Native Hut", // 100
"Native Meeting", // 101
"Native Crops", // 102
"Fort Ground", // 103
"Burning Ruin", // 104
};
// end chars

// start structs
struct mouse_button_t {
    int is_down; /**< mouse button is down */
    int went_down; /**< mouse button went down during this cycle */
    int went_up; /**< mouse button went up during this cycle */
    int double_click; /**< mouse double clicked during this cycle */
    int system_change;
};

struct mouse_t {
    int x; /**< Global position X */
    int y; /**< Global position Y */
    int scrolled; /**< Scroll state (up/down/none) */
    struct mouse_button_t left; /**< Left mouse button */
    struct mouse_button_t right; /**< Right mouse button */
    int is_inside_window; /**< Whether the mouse is in the window */
};
static struct mouse_t mouse_data;
static struct mouse_t dialog;

struct hotkeys_t {
    // fixed keys with multiple functions
    int enter_pressed;
    int escape_pressed;
    // keys with specific function
    int load_file;
    int save_file;
    int decrease_game_speed;
    int increase_game_speed;
    int toggle_pause;
    int rotate_map_left;
    int rotate_map_right;
    int replay_map;
    int cycle_legion;
    int return_legions_to_fort;
    int show_last_advisor;
    int show_empire_map;
    int show_messages;
    int go_to_problem;
    int clone_building;
    int cycle_buildings;
    int cycle_buildings_reverse;
    int undo;
    int building;
    int show_overlay;
    int go_to_bookmark;
    int set_bookmark;
    int toggle_editor_battle_info;
    int cheat_money;
    int cheat_invasion;
    int cheat_victory;
};

struct formation_t {
    int id;
    uint8_t in_use;
    uint8_t layout;
    uint8_t figure_type;
    uint8_t num_figures;
    uint8_t max_figures;
    uint16_t figures[MAX_FORMATION_FIGURES];
    uint8_t has_military_training;
    uint8_t is_at_rest;
    uint8_t deployed_duration_months;
    uint8_t direction;
    uint8_t morale;
    uint8_t max_morale;
    uint8_t routed;
    int16_t wait_ticks_movement;
    uint16_t standard_x;
    uint16_t standard_y;
    uint16_t prev_standard_x;
    uint16_t prev_standard_y;
    uint16_t legion_standard__figure_id;
    uint16_t building_id;
    uint8_t empire_service;
    uint8_t in_distant_battle;
    uint8_t cursed_by_mars;
    uint8_t recent_fight;
    uint8_t missile_attack_timeout;
    uint16_t destination_x;
    uint16_t destination_y;
    uint16_t wolf_spawn_delay;
    uint8_t attack_priority;
};
static struct formation_t enemy_formations[MAX_ENEMY_FORMATIONS];
static struct formation_t herd_formations[MAX_HERD_POINTS];
static struct formation_t legion_formations[MAX_LEGIONS];

struct map_point_t {
    int x;
    int y;
};
static struct map_point_t bookmarks[MAX_BOOKMARKS];
static   struct map_point_t CLOUD_DIRECTION[] = {
    {0, -6}, {-2, -5}, {-4, -4}, {-5, -2}, {-6, 0}, {-5, -2}, {-4, -4}, {-2, -5},
    {0, -6}, {-2, -5}, {-4, -4}, {-5, -2}, {-6, 0}, {-5, -2}, {-4, -4}, {-2, -5}
};
static   struct map_point_t HORSE_DESTINATION_1[] = {
    {2, 1}, {3, 1}, {4, 1}, {5, 1}, {6, 1}, {7, 1}, {8, 1}, {9, 1}, {10, 1}, {11, 1}, {12, 2},
    {12, 3}, {11, 3}, {10, 3}, {9, 3}, {8, 3}, {7, 3}, {6, 3}, {5, 3}, {4, 3}, {3, 3}, {2, 2}
};
static   struct map_point_t HORSE_DESTINATION_2[] = {
    {12, 3}, {11, 3}, {10, 3}, {9, 3}, {8, 3}, {7, 3}, {6, 3}, {5, 3}, {4, 3}, {3, 3}, {2, 2},
    {2, 1}, {3, 1}, {4, 1}, {5, 1}, {6, 1}, {7, 1}, {8, 1}, {9, 1}, {10, 1}, {11, 1}, {12, 2}
};

struct map_tile_t {
    int x;
    int y;
    int grid_offset;
};
static struct map_tile_t current_tile;

struct building_t {
    int id;
    unsigned char state;
    unsigned char size;
    unsigned char house_is_merged;
    unsigned char house_size;
    unsigned char x;
    unsigned char y;
    short grid_offset;
    short type;
    union {
        short house_level;
        short warehouse_resource_id;
        short workshop_type;
        short orientation;
        short fort_figure_type;
        short native_meeting_center_id;
    } subtype;
    unsigned char road_network_id;
    unsigned short created_sequence;
    short houses_covered;
    short percentage_houses_covered;
    short house_population;
    short house_population_room;
    short house_highest_population;
    unsigned char road_access_x;
    unsigned char road_access_y;
    short figure_id;
    short figure_id2; // labor seeker or market buyer
    short immigrant_figure_id;
    short figure_id4; // tower ballista or burning ruin prefect
    unsigned char figure_spawn_delay;
    unsigned char figure_roam_direction;
    unsigned char has_water_access;
    short prev_part_building_id;
    short next_part_building_id;
    short loads_stored;
    unsigned char has_well_access;
    short num_workers;
    int8_t labor_category;
    unsigned char output_resource_id;
    unsigned char has_road_access;
    unsigned char house_criminal_active;
    short damage_risk;
    short fire_risk;
    short fire_duration;
    unsigned char fire_proof; // cannot catch fire or collapse
    unsigned char house_figure_generation_delay;
    unsigned char house_tax_coverage;
    short formation_id;
    union {
        struct {
            short queued_docker_id;
            unsigned char num_ships;
            signed char orientation;
            short docker_ids[3];
            short trade_ship_id;
        } dock;
        struct {
            short inventory[8];
            short pottery_demand;
            short furniture_demand;
            short oil_demand;
            short wine_demand;
            unsigned char fetch_inventory_id;
        } market;
        struct {
            short resource_stored[16];
        } granary;
        struct {
            short progress;
            unsigned char blessing_days_left;
            unsigned char curse_days_left;
            unsigned char has_raw_materials;
            unsigned char has_fish;
            unsigned char orientation;
            short fishing_boat_id;
        } industry;
        struct {
            unsigned char num_shows;
            unsigned char days1;
            unsigned char days2;
            unsigned char play;
        } entertainment;
        struct {
            short inventory[8];
            unsigned char theater;
            unsigned char amphitheater_actor;
            unsigned char amphitheater_gladiator;
            unsigned char colosseum_gladiator;
            unsigned char colosseum_lion;
            unsigned char hippodrome;
            unsigned char school;
            unsigned char library;
            unsigned char academy;
            unsigned char barber;
            unsigned char clinic;
            unsigned char bathhouse;
            unsigned char hospital;
            unsigned char temple_ceres;
            unsigned char temple_neptune;
            unsigned char temple_mercury;
            unsigned char temple_mars;
            unsigned char temple_venus;
            unsigned char no_space_to_expand;
            unsigned char num_foods;
            unsigned char entertainment;
            unsigned char education;
            unsigned char health;
            unsigned char num_gods;
            unsigned char devolve_delay;
            unsigned char evolve_text_id;
        } house;
    } data;
    int tax_income_or_storage;
    unsigned char house_days_without_food;
    unsigned char ruin_has_plague;
    signed char desirability;
    unsigned char is_deleted;
    unsigned char storage_id;
    union {
        signed char house_happiness;
        signed char native_anger;
    } sentiment;
    unsigned char show_on_problem_overlay;
};
static struct building_t all_buildings[MAX_BUILDINGS];

struct building_properties_t {
    uint8_t size;
    uint8_t fire_proof;
    uint8_t image_group;
    uint8_t image_offset;
    uint16_t cost;
    int8_t desirability_value;
    uint8_t desirability_step;
    int8_t desirability_step_size;
    uint8_t desirability_range;
    uint8_t n_laborers;
    int8_t labor_category;
    uint8_t sound_channel;
};
struct building_properties_t building_properties[BUILDING_TYPE_MAX] = {
    // size | fireprf | img_grp | img_off | cost | des_value | des_step | des_step_siz | des_range | n_lbrs | lbr_cat | snd_ch
    {  0,     0,        0,        0,        0,     0,          0,         0,             0,          0,      -1,        0}, // BUILDING_NONE
    {  1,     0,        0,        0,        10,    0,          0,         0,             0,          0,      -1,        1}, // BUILDING_HOUSE_VACANT_LOT
    {  1,     0,        0,        0,        0,    -3,          1,         1,             3,          0,      -1,        2}, // BUILDING_HOUSE_SMALL_TENT
    {  1,     0,        0,        0,        0,    -3,          1,         1,             3,          0,      -1,        2}, // BUILDING_HOUSE_LARGE_TENT
    {  1,     0,        0,        0,        0,    -2,          1,         1,             2,          0,      -1,        2}, // BUILDING_HOUSE_SMALL_SHACK
    {  1,     0,        0,        0,        0,    -2,          1,         1,             2,          0,      -1,        2}, // BUILDING_HOUSE_LARGE_SHACK
    {  1,     0,        0,        0,        0,    -2,          1,         1,             2,          0,      -1,        2}, // BUILDING_HOUSE_SMALL_HOVEL
    {  1,     0,        0,        0,        0,    -2,          1,         1,             2,          0,      -1,        2}, // BUILDING_HOUSE_LARGE_HOVEL
    {  1,     0,        0,        0,        0,    -1,          1,         1,             1,          0,      -1,        3}, // BUILDING_HOUSE_SMALL_CASA
    {  1,     0,        0,        0,        0,    -1,          1,         1,             1,          0,      -1,        3}, // BUILDING_HOUSE_LARGE_CASA
    {  1,     0,        0,        0,        0,     0,          1,         1,             1,          0,      -1,        3}, // BUILDING_HOUSE_SMALL_INSULA
    {  1,     0,        0,        0,        0,     0,          1,         1,             1,          0,      -1,        3}, // BUILDING_HOUSE_MEDIUM_INSULA
    {  2,     0,        0,        0,        0,     0,          0,         0,             0,          0,      -1,        4}, // BUILDING_HOUSE_LARGE_INSULA
    {  2,     0,        0,        0,        0,     0,          0,         0,             0,          0,      -1,        4}, // BUILDING_HOUSE_GRAND_INSULA
    {  2,     0,        0,        0,        0,     1,          2,        -1,             2,          0,      -1,        4}, // BUILDING_HOUSE_SMALL_VILLA
    {  2,     0,        0,        0,        0,     1,          2,        -1,             2,          0,      -1,        4}, // BUILDING_HOUSE_MEDIUM_VILLA
    {  3,     0,        0,        0,        0,     2,          2,        -2,             2,          0,      -1,        5}, // BUILDING_HOUSE_LARGE_VILLA
    {  3,     0,        0,        0,        0,     2,          2,        -2,             2,          0,      -1,        5}, // BUILDING_HOUSE_GRAND_VILLA
    {  3,     0,        0,        0,        0,     3,          2,        -1,             6,          0,      -1,        5}, // BUILDING_HOUSE_SMALL_PALACE
    {  3,     0,        0,        0,        0,     3,          2,        -1,             6,          0,      -1,        5}, // BUILDING_HOUSE_MEDIUM_PALACE
    {  4,     0,        0,        0,        0,     4,          2,        -1,             6,          0,      -1,        6}, // BUILDING_HOUSE_LARGE_PALACE
    {  4,     0,        0,        0,        0,     4,          2,        -1,             6,          0,      -1,        6}, // BUILDING_HOUSE_LUXURY_PALACE
    {  0,     0,        0,        0,        2,     0,          0,         0,             0,          0,      -1,        0}, // BUILDING_CLEAR_LAND
    {  1,     0,        112,      0,        4,     0,          0,         0,             0,          0,      -1,        0}, // BUILDING_ROAD
    {  3,     1,        25,       0,        80,   -6,          1,         2,             3,          0,      -1,        8}, // BUILDING_RESERVOIR
    {  1,     0,        19,       0,        8,    -2,          1,         1,             2,          0,      -1,        9}, // BUILDING_AQUEDUCT
    {  1,     1,        54,       0,        15,    0,          0,         0,             0,          4,       3,        10}, // BUILDING_FOUNTAIN
    {  1,     1,        23,       0,        5,     0,          0,         0,             0,          0,      -1,        11}, // BUILDING_WELL
    {  1,     0,        68,       0,        30,    0,          0,         0,             0,          5,       7,        14}, // BUILDING_DOCTOR
    {  2,     0,        185,      0,        50,    4,          1,        -1,             4,          10,      7,        13}, // BUILDING_BATHHOUSE
    {  1,     0,        67,       0,        25,    2,          1,        -1,             2,          2,       7,        12}, // BUILDING_BARBER
    {  3,     0,        70,       0,        300,  -1,          2,         1,             2,          30,      7,        15}, // BUILDING_HOSPITAL
    {  2,     0,        71,       0,        50,    4,          2,        -1,             6,          2,       8,        16}, // BUILDING_SMALL_TEMPLE_CERES
    {  2,     0,        72,       0,        50,    4,          2,        -1,             6,          2,       8,        17}, // BUILDING_SMALL_TEMPLE_NEPTUNE
    {  2,     0,        73,       0,        50,    4,          2,        -1,             6,          2,       8,        18}, // BUILDING_SMALL_TEMPLE_MERCURY
    {  2,     0,        74,       0,        50,    4,          2,        -1,             6,          2,       8,        19}, // BUILDING_SMALL_TEMPLE_MARS
    {  2,     0,        75,       0,        50,    4,          2,        -1,             6,          2,       8,        20}, // BUILDING_SMALL_TEMPLE_VENUS
    {  3,     0,        71,       1,        150,   8,          2,        -1,             8,          5,       8,        16}, // BUILDING_LARGE_TEMPLE_CERES
    {  3,     0,        72,       1,        150,   8,          2,        -1,             8,          5,       8,        17}, // BUILDING_LARGE_TEMPLE_NEPTUNE
    {  3,     0,        73,       1,        150,   8,          2,        -1,             8,          5,       8,        18}, // BUILDING_LARGE_TEMPLE_MERCURY
    {  3,     0,        74,       1,        150,   8,          2,        -1,             8,          5,       8,        19}, // BUILDING_LARGE_TEMPLE_MARS
    {  3,     0,        75,       1,        150,   8,          2,        -1,             8,          5,       8,        20}, // BUILDING_LARGE_TEMPLE_VENUS
    {  2,     0,        76,       0,        200,   8,          2,        -1,             6,          0,       8,        21}, // BUILDING_ORACLE
    {  2,     0,        41,       0,        50,   -2,          1,         1,             2,          10,      7,        22}, // BUILDING_SCHOOL
    {  2,     0,        42,       0,        75,    4,          1,        -1,             4,          20,      7,        24}, // BUILDING_LIBRARY
    {  3,     0,        43,       0,        100,   4,          1,         1,             4,          30,      7,        23}, // BUILDING_ACADEMY
    {  2,     1,        184,      0,        100,  -3,          1,         1,             2,          20,      7,        0}, // BUILDING_MISSION_POST
    {  2,     0,        46,       0,        50,    2,          1,        -1,             2,          8,       6,        25}, // BUILDING_THEATER
    {  3,     0,        51,       0,        50,    2,          1,        -1,             2,          5,       6,        31}, // BUILDING_ACTOR_COLONY
    {  3,     0,        45,       0,        100,   4,          1,        -1,             4,          12,      6,        26}, // BUILDING_AMPHITHEATER
    {  3,     0,        49,       0,        75,   -3,          1,         1,             3,          8,       6,        29}, // BUILDING_GLADIATOR_SCHOOL
    {  3,     0,        50,       0,        75,   -3,          1,         1,             3,          8,       6,        30}, // BUILDING_LION_HOUSE
    {  5,     0,        48,       0,        500,  -3,          1,         1,             3,          25,      6,        27}, // BUILDING_COLOSSEUM
    {  3,     0,        52,       0,        75,   -3,          1,         1,             3,          8,       6,        32}, // BUILDING_CHARIOT_MAKER
    {  5,     0,        213,      0,        2500, -3,          1,         1,             3,          150,     6,        28}, // BUILDING_HIPPODROME
    {  1,     1,        59,       0,        12,    3,          1,        -1,             3,          0,      -1,        37}, // BUILDING_GARDENS
    {  1,     1,        58,       0,        15,    4,          1,        -2,             2,          0,      -1,        0}, // BUILDING_PLAZA
    {  1,     1,        61,       0,        12,    3,          1,        -1,             3,          0,      -1,        36}, // BUILDING_SMALL_STATUE
    {  2,     1,        61,       1,        60,    10,         1,        -2,             4,          0,      -1,        36}, // BUILDING_MEDIUM_STATUE
    {  3,     1,        61,       2,        150,   14,         2,        -2,             5,          0,      -1,        36}, // BUILDING_LARGE_STATUE
    {  3,     0,        85,       0,        150,   12,         2,        -2,             3,          0,      -1,        35}, // BUILDING_GOVERNORS_HOUSE
    {  4,     0,        86,       0,        400,   20,         2,        -3,             4,          0,      -1,        35}, // BUILDING_GOVERNORS_VILLA
    {  5,     0,        87,       0,        700,   28,         2,        -4,             5,          0,      -1,        35}, // BUILDING_GOVERNORS_PALACE
    {  2,     0,        63,       0,        75,    3,          2,        -1,             2,          6,       8,        33}, // BUILDING_FORUM
    {  5,     0,        62,       0,        400,   14,         2,        -1,             8,          30,      8,        34}, // BUILDING_SENATE
    {  3,     1,        205,      0,        0,     18,         2,         3,             5,          0,      -1,        0}, // BUILDING_TRIUMPHAL_ARCH
    {  1,     1,        81,       0,        30,    0,          1,         1,             1,          5,       2,        0}, // BUILDING_ENGINEERS_POST
    {  1,     1,        0,        0,        40,    0,          0,         0,             0,          0,      -1,        0}, // BUILDING_LOW_BRIDGE
    {  1,     1,        0,        0,        100,   0,          0,         0,             0,          0,      -1,        0}, // BUILDING_SHIP_BRIDGE
    {  2,     0,        77,       0,        100,  -8,          2,         2,             3,          10,      0,        38}, // BUILDING_SHIPYARD
    {  2,     0,        79,       0,        60,   -8,          2,         2,             3,          6,       0,        40}, // BUILDING_WHARF
    {  3,     0,        78,       0,        100,  -8,          2,         2,             3,          12,      0,        39}, // BUILDING_DOCK
    {  1,     0,        64,       0,        30,   -2,          1,         1,             2,          6,       4,        0}, // BUILDING_PREFECTURE
    {  1,     0,        24,       26,       12,    0,          0,         0,             0,          0,      -1,        0}, // BUILDING_WALL
    {  2,     1,        17,       0,        150,  -8,          1,         2,             3,          6,       5,        41}, // BUILDING_TOWER
    {  2,     1,        17,       1,        100,  -4,          1,         1,             3,          0,       5,        0}, // BUILDING_GATEHOUSE
    {  3,     1,        66,       0,        1000, -20,         2,         2,             8,          0,      -1,        0}, // BUILDING_FORT_LEGIONARIES
    {  3,     1,        66,       0,        1000, -20,         2,         2,             8,          0,      -1,        0}, // BUILDING_FORT_JAVELIN
    {  3,     1,        66,       0,        1000, -20,         2,         2,             8,          0,      -1,        0}, // BUILDING_FORT_MOUNTED
    {  3,     0,        166,      0,        150,  -6,          1,         1,             3,          10,      5,        44}, // BUILDING_BARRACKS
    {  3,     0,        201,      0,        1000, -3,          1,         1,             3,          20,      5,        43}, // BUILDING_MILITARY_ACADEMY
    {  3,     0,        37,       0,        40,   -2,          1,         1,             2,          10,      1,        45}, // BUILDING_WHEAT_FARM
    {  3,     0,        37,       0,        40,   -2,          1,         1,             2,          10,      1,        46}, // BUILDING_VEGETABLE_FARM
    {  3,     0,        37,       0,        40,   -2,          1,         1,             2,          10,      1,        47}, // BUILDING_FRUIT_FARM
    {  3,     0,        37,       0,        40,   -2,          1,         1,             2,          10,      1,        50}, // BUILDING_PIG_FARM
    {  3,     0,        37,       0,        40,   -2,          1,         1,             2,          10,      0,        48}, // BUILDING_OLIVE_FARM
    {  3,     0,        37,       0,        40,   -2,          1,         1,             2,          10,      0,        49}, // BUILDING_VINES_FARM
    {  2,     0,        40,       0,        40,   -3,          1,         1,             3,          10,      0,        51}, // BUILDING_CLAY_PIT
    {  2,     0,        65,       0,        40,   -4,          1,         1,             3,          10,      0,        54}, // BUILDING_TIMBER_YARD
    {  2,     0,        38,       0,        50,   -6,          1,         1,             4,          10,      0,        52}, // BUILDING_MARBLE_QUARRY
    {  2,     0,        39,       0,        50,   -6,          1,         1,             4,          10,      0,        53}, // BUILDING_IRON_MINE
    {  2,     0,        122,      0,        50,   -4,          1,         1,             2,          10,      0,        56}, // BUILDING_OIL_WORKSHOP
    {  2,     0,        44,       0,        45,   -1,          1,         1,             1,          10,      0,        55}, // BUILDING_WINE_WORKSHOP
    {  2,     0,        125,      0,        40,   -4,          1,         1,             2,          10,      0,        59}, // BUILDING_POTTERY_WORKSHOP
    {  2,     0,        124,      0,        40,   -4,          1,         1,             2,          10,      0,        58}, // BUILDING_FURNITURE_WORKSHOP
    {  2,     0,        123,      0,        50,   -4,          1,         1,             2,          10,      0,        57}, // BUILDING_WEAPONS_WORKSHOP
    {  2,     0,        22,       0,        40,   -2,          1,         1,             6,          5,       0,        60}, // BUILDING_MARKET
    {  3,     0,        99,       0,        100,  -4,          1,         2,             2,          6,       1,        61}, // BUILDING_GRANARY
    {  1,     1,        82,       0,        70,   -5,          2,         2,             3,          6,       0,        62}, // BUILDING_WAREHOUSE
    {  1,     1,        82,       0,        0,     0,          0,         0,             0,          0,      -1,        0}, // BUILDING_WAREHOUSE_SPACE
    {  1,     1,        183,      0,        50,    0,          0,         0,             0,          0,      -1,        0}, // BUILDING_NATIVE_HUT
    {  2,     1,        183,      2,        50,    0,          0,         0,             0,          0,      -1,        0}, // BUILDING_NATIVE_MEETING
    {  1,     1,        100,      0,        0,     0,          0,         0,             0,          0,      -1,        0}, // BUILDING_NATIVE_CROPS
    {  4,     1,        66,       1,        0,     0,          0,         0,             0,          0,      -1,        0}, // BUILDING_FORT_GROUND
    {  1,     1,        0,        0,        0,    -1,          1,         1,             2,          0,      -1,        63}, // BUILDING_BURNING_RUIN
};

struct house_properties_t {
    int8_t devolve_desirability; /**< Desirability at which the house devolves */
    int8_t evolve_desirability; /**< Desirability at which the house evolves */
    uint8_t entertainment; /**< Entertainment points required */
    uint8_t water; /**< Water required: 1 = well, 2 = fountain */
    uint8_t religion; /**< Number of gods required */
    uint8_t education; /**< Education required: 1 = school or library, 2 = school and library, 3 = school, library and academy */
    uint8_t barber; /**< Barber required (boolean) */
    uint8_t bathhouse; /**< Bathhouse required (boolean) */
    uint8_t health; /**< Health required: 1 = doctor or hospital, 2 = doctor and hospital */
    uint8_t food_types; /**< Number of food types required */
    uint8_t pottery; /**< Pottery required */
    uint8_t oil; /**< Oil required */
    uint8_t furniture; /**< Furniture required */
    uint8_t wine; /**< Wine types required: 1 = any wine, 2 = two types of wine */
    uint16_t prosperity; /**< Prosperity contribution */
    uint8_t max_people; /**< Maximum people per tile (medium insula and lower) or per house (large insula and up) */
    uint8_t tax_multiplier; /**< Tax rate multiplier */
};
struct house_properties_t house_properties[MAX_HOUSE_TYPES] = {
    // dev_des | ev_des | ent | water | relg | edu | barb | bath | health | food | pott | oil | furn | wine | prosp | max_ppl | tax_mult
    { -99,      -10,      0,    0,      0,     0,    0,     0,       0,     0,     0,    0,     0,     0,     5,      5,        1},
    { -12,      -5,       0,    1,      0,     0,    0,     0,       0,     0,     0,    0,     0,     0,     10,     7,        1},
    { -7,        0,       0,    1,      0,     0,    0,     0,       0,     1,     0,    0,     0,     0,     15,     9,        1},
    { -2,        4,       0,    1,      1,     0,    0,     0,       0,     1,     0,    0,     0,     0,     20,     11,       1},
    {  2,        8,       0,    2,      1,     0,    0,     0,       0,     1,     0,    0,     0,     0,     25,     13,       2},
    {  6,        12,      10,   2,      1,     0,    0,     0,       0,     1,     0,    0,     0,     0,     30,     15,       2},
    { 10,        16,      10,   2,      1,     1,    0,     0,       0,     1,     0,    0,     0,     0,     35,     17,       2},
    { 14,        20,      10,   2,      1,     1,    0,     1,       0,     1,     1,    0,     0,     0,     45,     19,       2},
    { 18,        25,      25,   2,      1,     1,    0,     1,       0,     1,     1,    0,     0,     0,     50,     19,       3},
    { 22,        32,      25,   2,      1,     1,    0,     1,       1,     1,     1,    0,     1,     0,     58,     20,       3},
    { 29,        40,      25,   2,      1,     2,    1,     1,       1,     1,     1,    1,     1,     0,     65,     84,       3},
    { 37,        48,      35,   2,      1,     2,    1,     1,       1,     2,     1,    1,     1,     0,     80,     84,       4},
    { 45,        53,      35,   2,      2,     2,    1,     1,       1,     2,     1,    1,     1,     1,     150,    40,       9},
    { 50,        58,      40,   2,      2,     2,    1,     1,       2,     2,     1,    1,     1,     1,     180,    42,       10},
    { 55,        63,      45,   2,      2,     3,    1,     1,       2,     2,     1,    1,     1,     1,     400,    90,       11},
    { 60,        68,      50,   2,      3,     3,    1,     1,       2,     3,     1,    1,     1,     1,     600,    100,      11},
    { 65,        74,      55,   2,      3,     3,    1,     1,       2,     3,     1,    1,     1,     2,     700,    106,      12},
    { 70,        80,      60,   2,      4,     3,    1,     1,       2,     3,     1,    1,     1,     2,     900,    112,      12},
    { 76,        90,      70,   2,      4,     3,    1,     1,       2,     3,     1,    1,     1,     2,     1500,   190,      15},
    { 85,        100,     80,   2,      4,     3,    1,     1,       2,     3,     1,    1,     1,     2,     1750,   200,      16},
};

struct building_storage_t {
    int empty_all;
    int resource_state[RESOURCE_TYPES_MAX];
};

struct emperor_gift_t {
    int id;
    int cost;
};

struct god_status_t {
    int8_t happiness;
    int8_t target_happiness;
    int8_t wrath_bolts;
    int8_t blessing_done;
    int8_t small_curse_done;
    int32_t months_since_festival;
};

struct finance_overview_t {
    struct {
        int taxes;
        int exports;
        int donated;
        int total;
    } income;
    struct {
        int imports;
        int wages;
        int construction;
        int interest;
        int salary;
        int sundries;
        int tribute;
        int total;
    } expenses;
    int net_in_out;
    int balance;
};

struct house_demands_t {
    struct {
        int well;
        int fountain;
        int entertainment;
        int more_entertainment;
        int education;
        int more_education;
        int religion;
        int second_religion;
        int third_religion;
        int barber;
        int bathhouse;
        int clinic;
        int hospital;
        int food;
        int second_wine;
    } missing;
    struct {
        int school;
        int library;
        int barber;
        int bathhouse;
        int clinic;
        int religion;
    } requiring;
    int health;
    int religion;
    int education;
    int entertainment;
};

struct labor_category_data_t {
    int workers_needed;
    int workers_allocated;
    int buildings;
    int priority;
    int total_houses_covered;
};

struct city_message_t {
    int sequence;
    int message_type;
    int year;
    int month;
    int param1;
    int param2;
    int is_read;
};

struct pixel_view_coordinates_t {
    int x;
    int y;
};

struct city_data_t {
    struct {
        int16_t senate_placed;
        uint8_t senate_x;
        uint8_t senate_y;
        int16_t senate_grid_offset;
        int32_t senate_building_id;
        int32_t hippodrome_placed;
        int8_t barracks_x;
        int8_t barracks_y;
        int16_t barracks_grid_offset;
        int32_t barracks_building_id;
        int32_t barracks_placed;
        int32_t trade_center_building_id;
        int8_t triumphal_arches_available;
        int16_t working_wharfs;
        int32_t shipyard_boats_requested;
        int16_t working_docks;
        int16_t working_dock_ids[10];
        int32_t mission_post_operational;
        struct map_point_t main_native_meeting;
    } building;
    struct {
        int16_t animals;
        int32_t enemies;
        int32_t imperial_soldiers;
        int32_t rioters;
        int32_t soldiers;
    } figure;
    struct house_demands_t houses;
    struct {
        struct emperor_gift_t gifts[3];
        int32_t months_since_gift;
        int32_t gift_overdose_penalty;

        int32_t debt_state;
        int32_t months_in_debt;

        int32_t player_rank;
        int32_t salary_rank;
        int32_t salary_amount;
        int32_t donate_amount;
        int32_t personal_savings;
        struct {
            int32_t count;
            int32_t size;
            int32_t soldiers_killed;
            int32_t warnings_given;
            int32_t days_until_invasion;
            int32_t duration_day_countdown;
            int32_t retreat_message_shown;
            int16_t from_editor;
        } invasion;
    } emperor;
    struct {
        uint8_t total_legions;
        int32_t legionary_legions;
        int32_t native_attack_duration;
    } military;
    struct {
        uint8_t city;
        int8_t city_foreign_months_left;
        int8_t total_count;
        int8_t won_count;
        uint8_t enemy_strength;
        uint8_t roman_strength;
        int8_t months_until_battle;
        int8_t roman_months_to_travel_forth;
        int8_t roman_months_to_travel_back;
        int8_t enemy_months_traveled;
        int8_t roman_months_traveled;
    } distant_battle;
    struct {
        int32_t treasury;
        int32_t tax_percentage;
        int32_t estimated_tax_income;
        int32_t estimated_wages;
        struct finance_overview_t last_year;
        struct finance_overview_t this_year;
        int32_t interest_so_far;
        int32_t salary_so_far;
        int32_t wages_so_far;
        int16_t stolen_this_year;
        int16_t stolen_last_year;
        int32_t cheated_money;
        int32_t tribute_not_paid_last_year;
        int32_t tribute_not_paid_total_years;
        int32_t wage_rate_paid_this_year;
        int32_t wage_rate_paid_last_year;
    } finance;
    struct {
        int32_t taxed_plebs;
        int32_t taxed_patricians;
        int32_t untaxed_plebs;
        int32_t untaxed_patricians;
        int32_t percentage_taxed_plebs;
        int32_t percentage_taxed_patricians;
        int32_t percentage_taxed_people;
        struct {
            int32_t collected_plebs;
            int32_t collected_patricians;
            int32_t uncollected_plebs;
            int32_t uncollected_patricians;
        } yearly;
        struct {
            int32_t collected_plebs;
            int32_t collected_patricians;
            int32_t uncollected_plebs;
            int32_t uncollected_patricians;
        } monthly;
    } taxes;
    struct {
        uint32_t population;
        int32_t population_last_year;
        int32_t school_age;
        int32_t academy_age;
        int32_t working_age;
        struct {
            int32_t values[2400];
            int32_t next_index;
            int32_t count;
        } monthly;
        int16_t at_age[100];
        int32_t at_level[20];

        int32_t yearly_update_requested;
        int32_t yearly_births;
        int32_t yearly_deaths;
        int32_t lost_removal;
        int32_t lost_homeless;
        int32_t lost_troop_request;
        int32_t last_change;
        int32_t total_all_years;
        int32_t total_years;
        int32_t average_per_year;
        uint32_t highest_ever;
        int32_t total_capacity;
        int32_t room_in_houses;
        int32_t people_in_tents;
        int32_t people_in_tents_shacks;
        int32_t people_in_large_insula_and_above;
        int32_t people_in_villas_palaces;
        int32_t percentage_plebs;
        int32_t last_used_house_add;
        int32_t last_used_house_remove;
        int32_t graph_order;
    } population;
    struct {
        int32_t wages;
        int32_t wages_rome;
        int32_t workers_available;
        int32_t workers_employed;
        int32_t workers_unemployed;
        int32_t workers_needed;
        int32_t unemployment_percentage;
        int32_t unemployment_percentage_for_senate;
        struct labor_category_data_t categories[10];
    } labor;
    struct {
        int32_t immigration_duration;
        int32_t emigration_duration;
        int32_t immigration_amount_per_batch;
        int32_t emigration_amount_per_batch;
        int32_t immigration_queue_size;
        int32_t emigration_queue_size;
        int32_t immigrated_today;
        int32_t emigrated_today;
        int32_t refused_immigrants_today;
        int32_t no_immigration_cause;
        int32_t percentage;
        int32_t newcomers;
        int32_t emigration_message_shown;
    } migration;
    struct {
        int32_t value;
        int32_t previous_value;
        int32_t message_delay;
        int32_t low_mood_cause;
        int32_t protesters;
        int32_t criminals; // muggers+rioters
    } sentiment;
    struct {
        int32_t num_hospital_workers;
        int32_t target_value;
        int32_t value;
    } health;
    struct {
        uint32_t culture;
        uint32_t prosperity;
        uint32_t peace;
        uint32_t favor;
        struct {
            int32_t library;
        } culture_points;
        int32_t prosperity_treasury_last_year;
        uint32_t prosperity_max;
        int32_t peace_destroyed_buildings;
        int32_t peace_years_of_peace;
        int32_t peace_num_criminals;
        int32_t peace_num_rioters;
        int32_t peace_riot_cause;
        int32_t favor_salary_penalty;
        int32_t favor_ignored_request_penalty;
        uint32_t favor_last_year;
        int32_t favor_change; // 0 = dropping, 1 = stalling, 2 = rising

        int32_t selected;
        int32_t culture_explanation;
        int32_t prosperity_explanation;
        int32_t peace_explanation;
        int32_t favor_explanation;
    } ratings;
    struct {
        int32_t average_entertainment;
        int32_t average_religion;
        int32_t average_education;
        int32_t average_health;
        int32_t religion_coverage;
    } culture;
    struct {
        struct god_status_t gods[5];
        int32_t least_happy_god;
        int32_t angry_message_delay;
        int32_t venus_curse_active;
        int32_t neptune_double_trade_active;
        int32_t neptune_sank_ships;
        int32_t mars_spirit_power;
    } religion;
    struct {
        int32_t theater_shows;
        int32_t theater_no_shows_weighted;
        int32_t amphitheater_shows;
        int32_t amphitheater_no_shows_weighted;
        int32_t colosseum_shows;
        int32_t colosseum_no_shows_weighted;
        int32_t hippodrome_shows;
        int32_t hippodrome_no_shows_weighted;
        int32_t venue_needing_shows;
        int32_t hippodrome_has_race;
        int32_t hippodrome_message_shown;
        int32_t colosseum_message_shown;
    } entertainment;
    struct {
        int8_t god;
        int8_t size;
        int32_t cost;
        int32_t months_to_go;
        int32_t months_since_festival;
        int32_t first_festival_effect_months;
        int32_t second_festival_effect_months;
    } festival;
    struct {
        int16_t space_in_warehouses[RESOURCE_TYPES_MAX];
        uint16_t stored_in_warehouses[RESOURCE_TYPES_MAX];
        int32_t space_in_workshops[6];
        int32_t stored_in_workshops[6];
        int16_t trade_status[RESOURCE_TYPES_MAX];
        int16_t export_over[RESOURCE_TYPES_MAX];
        int32_t stockpiled[RESOURCE_TYPES_MAX];
        int16_t mothballed[RESOURCE_TYPES_MAX];
        int32_t wine_types_available;
        int32_t food_types_available;
        int32_t food_types_eaten;
        int32_t granary_food_stored[FOOD_TYPES_MAX];
        int32_t granary_total_stored;
        int32_t food_supply_months;
        int32_t food_needed_per_month;
        int32_t food_consumed_last_month;
        int32_t food_produced_last_month;
        int32_t food_produced_this_month;
        struct {
            int operating;
            int not_operating;
            int not_operating_with_food;
            int understaffed;
        } granaries;
        int16_t last_used_warehouse;
    } resource;
    struct {
        uint8_t hit_elephant;
        uint8_t die_citizen;
        uint8_t die_soldier;
    } sound;
    struct {
        int16_t num_land_routes;
        int16_t num_sea_routes;
        int16_t land_trade_problem_duration;
        int16_t sea_trade_problem_duration;
        int32_t caravan_import_resource;
        int32_t caravan_backup_import_resource;
        int32_t docker_import_resource;
        int32_t docker_export_resource;
    } trade;
    struct {
        struct {
            int32_t id;
            int32_t size;
        } largest_road_networks[10];
    } map;
    struct {
        int32_t has_won;
        int32_t continue_months_left;
        int32_t continue_months_chosen;
        int32_t fired_message_shown;
        int32_t victory_message_shown;
    } mission;
};
static struct city_data_t city_data;

struct resource_list_t {
    int size;
    int items[RESOURCE_TYPES_MAX];
};

struct resource_img_ids_t {
    int icon_img_id;
    int editor_icon_img_id;
    int warehouse_space_img_id;
    int cart_img_id;
    int farm_field_img_id;
    int empire_icon_img_id;
    int editor_empire_icon_img_id;
};
struct resource_img_ids_t resource_images[RESOURCE_TYPES_MAX] = {
{0, 0, 0, 0, -1, 0, 0}, // RESOURCE_NONE
{1187, 1190, 3338, 8, 0, 7983, 3233}, // RESOURCE_WHEAT
{1188, 1191, 3342, 16, 5, 7984, 3234}, // RESOURCE_VEGETABLES
{1189, 1192, 3346, 24, 10, 7985, 3235}, // RESOURCE_FRUIT
{1192, 1195, 3358, 48, 25, 7988, 3238}, // RESOURCE_MEAT
{1190, 1193, 3350, 32, 15, 7986, 3236}, // RESOURCE_OLIVES
{1191, 1194, 3354, 40, 20, 7987, 3237}, // RESOURCE_VINES
{1197, 1200, 3378, 88, -1, 7993, 3243}, // RESOURCE_CLAY
{1196, 1199, 3366, 80, -1, 7992, 3242}, // RESOURCE_TIMBER
{1198, 1201, 3382, 96, -1, 7994, 3244}, // RESOURCE_MARBLE
{1195, 1198, 3370, 72, -1, 7991, 3241}, // RESOURCE_IRON
{1194, 1197, 3366, 64, -1, 7990, 3240}, // RESOURCE_OIL
{1193, 1196, 3362, 56, -1, 7989, 3239}, // RESOURCE_WINE
{1201, 1204, 3394, 120, -1, 7997, 3247}, // RESOURCE_POTTERY
{1200, 1203, 3390, 112, -1, 7996, 3246}, // RESOURCE_FURNITURE
{1199, 1202, 3386, 104, -1, 7995, 3245}, // RESOURCE_WEAPONS
};

struct trade_price_t {
    uint16_t buy;
    uint16_t sell;
};
struct trade_price_t DEFAULT_PRICES[RESOURCE_TYPES_MAX] = {
    {0, 0}, // RESOURCE_NONE
    {28, 22}, // RESOURCE_WHEAT
    {38, 30}, // RESOURCE_VEGETABLES
    {38, 30}, // RESOURCE_FRUIT
    {44, 36}, // RESOURCE_MEAT
    {42, 34}, // RESOURCE_OLIVES
    {44, 36}, // RESOURCE_VINES
    {40, 30}, // RESOURCE_CLAY
    {50, 35}, // RESOURCE_TIMBER
    {200, 140}, // RESOURCE_MARBLE
    {60, 40}, // RESOURCE_IRON
    {180, 140}, // RESOURCE_OIL
    {215, 160}, // RESOURCE_WINE
    {180, 140}, // RESOURCE_POTTERY
    {200, 150}, // RESOURCE_FURNITURE
    {250, 180}, // RESOURCE_WEAPONS
};
static struct trade_price_t trade_prices[RESOURCE_TYPES_MAX];

struct buffer_t {
    uint8_t *data; /**< Read-only: data */
    int size; /**< Read-only: size of the data */
    int index; /**< Read-only: bytes read/written so far */
    int overflow; /**< Read-only: indicates attempt to read/write beyond end of buffer */
};

struct dir_listing {
    char files[MAX_NUM_FILES][FILE_NAME_MAX]; /**< Filenames in UTF-8 encoding */
    int num_files; /**< Number of files in the list */
    int file_overflow;
};
static struct dir_listing listing;

struct image_t {
    int width;
    int height;
    int num_animation_sprites;
    int sprite_offset_x;
    int sprite_offset_y;
    int animation_can_reverse;
    int animation_speed_id;
    struct {
        int type;
        int is_fully_compressed;
        int is_external;
        int has_compressed_part;
        int bitmap_id;
        int offset;
        int data_length;
        int uncompressed_length;
    } draw;
};

struct lang_message_image {
    int id; /**< ID of the image */
    int x; /**< X offset */
    int y; /**< Y offset */
};

struct lang_message_string {
    char *text; /**< Text */
    int x; /**< X offset */
    int y; /**< Y offset */
};

struct lang_message_t {
    int type;
    int message_type;
    int x;
    int y;
    int width_blocks;
    int height_blocks;
    int urgent;
    struct lang_message_image image;
    struct lang_message_string title;
    struct lang_message_string subtitle;
    struct lang_message_string video;
    struct lang_message_string content;
};

struct speed_type_t {
    double speed_difference;
    double desired_speed;
    double current_speed;
    double adjusted_current_speed;
    double cumulative_delta;
    double fine_position;
    int adjust_for_time;
    uint32_t start_time;
    uint32_t total_time;
    uint32_t last_speed_check;
};

struct empire_object_t {
    int32_t id;
    uint8_t type;
    int16_t x;
    int16_t y;
    int16_t image_id;
    struct {
        int16_t x;
        int16_t y;
        int16_t image_id;
    } expanded;
    int16_t width;
    int16_t height;
    uint8_t animation_index;
    uint8_t in_use;
    uint8_t city_type;
    uint8_t city_name_id;
    uint8_t trade_route_id;
    uint8_t trade_route_open;
    uint32_t trade_route_cost;
    int16_t trader_entry_delay;
    uint8_t is_sea_trade;
    int16_t trader_figure_ids[3];
    uint8_t resource_buy_limit[RESOURCE_TYPES_MAX];
    uint8_t resource_sell_limit[RESOURCE_TYPES_MAX];
    uint8_t resource_bought[RESOURCE_TYPES_MAX];
    uint8_t resource_sold[RESOURCE_TYPES_MAX];
    uint8_t invasion_path_id;
    uint8_t invasion_years;
    uint8_t distant_battle_travel_months;
};
static struct empire_object_t empire_objects[MAX_EMPIRE_OBJECTS];
static struct empire_object_t *selected_empire_object_editor;

struct figure_t {
    int id;
    uint8_t in_use;
    uint8_t is_targetable;
    uint8_t is_corpse;
    uint8_t type;
    uint8_t action_state;
    uint8_t is_fleeing;
    uint8_t formation_id;
    uint8_t index_in_formation;
    uint8_t damage;
    uint8_t is_military_trained;
    uint8_t mounted_charge_ticks;
    uint8_t mounted_charge_ticks_max;
    uint16_t target_figure_id;
    uint16_t melee_targeter_ids[MAX_MELEE_TARGETERS_PER_UNIT];
    uint16_t melee_combatant_ids[MAX_MELEE_COMBATANTS_PER_UNIT];
    uint8_t num_melee_combatants;
    uint16_t ranged_targeter_ids[MAX_RANGED_TARGETERS_PER_UNIT];
    uint8_t prefect_recent_guard_duty;
    int8_t attack_direction;
    uint8_t engaged_in_combat;
    int8_t source_x;
    int8_t source_y;
    uint16_t routing_path_id;
    uint16_t routing_path_current_tile;
    uint16_t routing_path_length;
    uint8_t terrain_usage;
    uint8_t speed_multiplier;
    int8_t previous_tile_direction;
    int8_t previous_tile_x;
    int8_t previous_tile_y;
    int8_t direction;
    uint8_t progress_on_tile;
    int16_t x;
    int16_t y;
    uint16_t grid_offset;
    int8_t destination_x;
    int8_t destination_y;
    uint16_t destination_grid_offset; // only used for soldiers
    uint8_t destination_building_id;
    uint8_t figure_is_halted;
    uint8_t use_cross_country;
    uint8_t cc_direction; // 1 = x, 2 = y
    uint16_t cross_country_x; // position = 15 * x + offset on tile
    uint16_t cross_country_y; // position = 15 * y + offset on tile
    int16_t cc_delta_x;
    int16_t cc_delta_y;
    int16_t cc_delta_xy;
    uint16_t cc_destination_x;
    uint16_t cc_destination_y;
    uint8_t missile_offset;
    uint16_t roam_length;
    uint8_t roam_choose_destination;
    uint8_t roam_random_counter;
    int8_t roam_turn_direction;
    int8_t roam_ticks_until_next_turn;
    uint8_t in_building_wait_ticks;
    uint8_t height_adjusted_ticks;
    uint8_t current_height;
    uint8_t target_height;
    uint16_t next_figure_id_on_same_tile;
    uint16_t image_id;
    uint8_t image_offset;
    uint8_t attack_image_offset;
    uint8_t is_shooting;
    uint16_t cart_image_id;
    int8_t x_offset_cart;
    int8_t y_offset_cart;
    uint8_t enemy_image_group;
    int16_t wait_ticks;
    uint8_t wait_ticks_missile;
    uint16_t name_id;
    uint8_t is_invisible;
    uint16_t building_id; // for missiles: building_id contains the figure that shot it
    uint16_t immigrant_building_id;
    uint8_t migrant_num_people;
    uint8_t min_max_seen;
    uint8_t phrase_sequence_exact;
    int8_t phrase_id;
    uint8_t phrase_sequence_city;
    uint8_t empire_city_id;
    uint8_t resource_id;
    uint8_t collecting_item_id; // NOT a resource ID for cartpushers! IS a resource ID for warehousemen
    uint8_t trader_id;
    uint16_t leading_figure_id;
    uint8_t trader_amount_bought;
    uint8_t loads_sold_or_carrying;
    uint8_t trade_ship_failed_dock_attempts;
    uint8_t flotsam_visible;
};
static struct figure_t figures[MAX_FIGURES];

struct figure_properties_t {
    uint8_t is_unarmed_civilian_unit;
    uint8_t is_friendly_armed_unit; // excl. player legions
    uint8_t is_player_legion_unit;
    uint8_t is_criminal_unit;
    uint8_t is_empire_trader;
    uint8_t is_native_unit;
    uint8_t is_herd_animal;
    uint8_t is_enemy_unit; // excl. Caesar legions
    uint8_t is_caesar_legion_unit;
    uint8_t melee_attack_value;
    uint8_t melee_defense_value;
    uint8_t missile_attack_value;
    uint8_t missile_defense_value;
    uint8_t missile_delay;
    uint8_t missile_type;
    uint8_t max_range;
    uint8_t max_damage;
    uint16_t max_roam_length;
    uint8_t is_boat; // 1 for boat, 2 for flotsam
    uint8_t big_img_id;
    int8_t sound_category;
};
static struct figure_properties_t figure_properties[FIGURE_TYPE_MAX] = {
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  0,   0,   0, 8,  -1},  // FIGURE_NONE = 0,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  0,   0, 13,  24},  // FIGURE_IMMIGRANT = 1,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  0,   0, 13,  23},  // FIGURE_EMIGRANT = 2,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  0,   0, 9,   21},  // FIGURE_HOMELESS = 3,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  10,  128, 0, 58,  18},  // FIGURE_PATRICIAN = 4,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  0,   0, 4,   5},  // FIGURE_CART_PUSHER = 5,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  384, 0, 13,  19},  // FIGURE_LABOR_SEEKER = 6,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  384, 0, 2,   13},  // FIGURE_BARBER = 7,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  384, 0, 3,   11},  // FIGURE_BATHHOUSE_WORKER = 8,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  384, 0, 6,   12},  // FIGURE_DOCTOR = 9,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  384, 0, 6,   12},  // FIGURE_SURGEON = 10,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  384, 0, 14,  8},  // FIGURE_PRIEST = 11,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  10,  96,  0, 5,   10},  // FIGURE_SCHOOL_CHILD = 12,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  384, 0, 52,  9},  // FIGURE_TEACHER = 13,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  384, 0, 52,  9},  // FIGURE_LIBRARIAN = 14,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20, 192,  0, 53,  30},  // FIGURE_MISSIONARY = 15,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  2, 512,   0, 1,   14},  // FIGURE_ACTOR = 16,
{0, 1, 0, 0, 0, 0, 0, 0, 0, 9,  2, 0,   0, 0,   0,              0,  100, 512, 0, 33,  15},  // FIGURE_GLADIATOR = 17,
{0, 1, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0,   0, 0,   0,              0,  100, 512, 0, 10,  16},  // FIGURE_LION_TAMER = 18,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20, 512,  0, 11,  17},  // FIGURE_CHARIOTEER = 19,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  0, 0,     0, 8,  -1},  // FIGURE_HIPPODROME_HORSES = 20,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20, 512,  0, 16,  3},  // FIGURE_TAX_COLLECTOR = 21,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20, 640,  0, 7,   2},  // FIGURE_ENGINEER = 22,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  0, 0,     1, 60, -1},  // FIGURE_FISHING_BOAT = 23,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  0, 0,     0, 8,  -1},  // FIGURE_FISH_GULLS = 24,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  0, 0,     1, 62, -1},  // FIGURE_SHIPWRECK = 25,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20, 0,    0, 17,  5},  // FIGURE_DOCKER = 26,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  0, 0,     2, 8,  -1},  // FIGURE_FLOTSAM = 27,
{0, 1, 0, 0, 0, 0, 0, 0, 0, 0,  0, 8,   0, 200, FIGURE_BOLT,    15, 0, 0,     0, 8,  -1},  // FIGURE_BALLISTA = 28,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 200, 0, 0,   0,              0,  0, 0,     0, 8,  -1},  // FIGURE_BOLT = 29,
{0, 1, 0, 0, 0, 0, 0, 0, 0, 6,  0, 6,   0, 50,  FIGURE_JAVELIN, 12, 50, 0,    0, 50,  1},  // FIGURE_TOWER_SENTRY = 30,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 15,  0, 0,   0,              0,  0, 0,     0, 8,  -1},  // FIGURE_JAVELIN = 31,
{0, 1, 0, 0, 0, 0, 0, 0, 0, 5,  0, 0,   0, 0,   0,              0,  50, 640,  0, 18,  0},  // FIGURE_PREFECT = 32,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  0, 0,     0, 8,  -1},  // FIGURE_FORT_STANDARD = 33,
{0, 0, 1, 0, 0, 0, 0, 0, 0, 4,  0, 4,   0, 100, FIGURE_JAVELIN, 10, 70, 0,    0, 42,  1},  // FIGURE_FORT_JAVELIN = 34,
{0, 0, 1, 0, 0, 0, 0, 0, 0, 6,  0, 0,   0, 0,   0,              0,  110, 0,   0, 26,  1},  // FIGURE_FORT_MOUNTED = 35,
{0, 0, 1, 0, 0, 0, 0, 0, 0, 10, 3, 0,   6, 0,   0,              0,  150, 0,   0, 41,  1},  // FIGURE_FORT_LEGIONARY = 36,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20, 800,  0, 12,  4},  // FIGURE_MARKET_BUYER = 37,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20, 384,  0, 12,  4},  // FIGURE_MARKET_TRADER = 38,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20, 0,    0, 38,  31},  // FIGURE_DELIVERY_BOY = 39,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20, 0,    0, 4,   5},  // FIGURE_WAREHOUSEMAN = 40,
{0, 0, 0, 1, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  30, 0,    0, 15,  20},  // FIGURE_PROTESTER = 41,
{0, 0, 0, 1, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  30, 0,    0, 15,  20},  // FIGURE_CRIMINAL = 42,
{0, 0, 0, 1, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  30, 480,  0, 15,  20},  // FIGURE_RIOTER = 43,
{0, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  10, 0,    0, 25,  6},  // FIGURE_TRADE_CARAVAN = 44,
{0, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  10, 0,    0, 25,  6},  // FIGURE_TRADE_CARAVAN_DONKEY = 45,
{0, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  0, 0,     1, 8,   7},  // FIGURE_TRADE_SHIP = 46,
{0, 0, 0, 0, 0, 1, 0, 0, 0, 6,  0, 0,   0, 0,   0,              0,  40, 800,  0, 21, -1},  // FIGURE_INDIGENOUS_NATIVE = 47,
{0, 0, 0, 0, 0, 1, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  40, 0,    0, 63, -1},  // FIGURE_NATIVE_TRADER = 48,
{0, 0, 0, 0, 0, 0, 1, 0, 0, 8,  0, 0,   0, 0,   0,              0,  80, 0,    0, 55, -1},  // FIGURE_WOLF = 49,
{0, 0, 0, 0, 0, 0, 1, 0, 0, 0,  0, 0,   0, 0,   0,              0,  10, 0,    0, 54, -1},  // FIGURE_SHEEP = 50,
{0, 0, 0, 0, 0, 0, 1, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20, 0,    0, 56, -1},  // FIGURE_ZEBRA = 51,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 9,  2, 0,   0, 0,   0,              0,  100, 0,   0, 33,  25},  // FIGURE_ENEMY_GLADIATOR = 52,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  1, 0,   0, 0,   0,              0,  90, 0,    0, 21,  25},  // FIGURE_ENEMY_BARBARIAN_SWORDSMAN = 53,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 12, 2, 0,   2, 0,   0,              0,  120, 0,   0, 22,  25},  // FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN = 54,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 20, 5, 0,   8, 70,  FIGURE_ARROW,   15, 200, 0,   0, 30,  25},  // FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT = 55,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 10, 1, 0,   2, 0,   0,              0,  110, 0,   0, 24,  25},  // FIGURE_ENEMY_BRITON_SWORDSMAN = 56,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 12, 4, 0,   4, 0,   0,              0,  120, 0,   0, 23,  25},  // FIGURE_ENEMY_BRITON_CHARIOT = 57,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 10, 1, 0,   2, 0,   0,              0,  110, 0,   0, 24,  25},  // FIGURE_ENEMY_CELT_SWORDSMAN = 58,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 12, 4, 0,   4, 0,   0,              0,  120, 0,   0, 23,  25},  // FIGURE_ENEMY_CELT_CHARIOT = 59,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 10, 1, 0,   2, 0,   0,              0,  110, 0,   0, 24,  25},  // FIGURE_ENEMY_PICT_SWORDSMAN = 60,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 12, 4, 0,   4, 0,   0,              0,  120, 0,   0, 23,  25},  // FIGURE_ENEMY_PICT_CHARIOT = 61,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  0, 0,   0, 0,   0,              0,  90, 0,    0, 29,  25},  // FIGURE_ENEMY_EGYPTIAN_SWORDSMAN = 62,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  1, 0,   0, 70,  FIGURE_ARROW,   15, 120, 0,   0, 28,  25},  // FIGURE_ENEMY_EGYPTIAN_CAMEL = 63,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 12, 2, 0,   2, 0,   0,              0,  120, 0,   0, 31,  25},  // FIGURE_ENEMY_ETRUSCAN_SWORDSMAN = 64,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 5,  0, 0,   0, 70,  FIGURE_JAVELIN, 10, 70, 0,    0, 32,  25},  // FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER = 65,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 12, 2, 0,   2, 0,   0,              0,  120, 0,   0, 31,  25},  // FIGURE_ENEMY_SAMNITE_SWORDSMAN = 66,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 5,  0, 0,   0, 70,  FIGURE_JAVELIN, 10, 70, 0,    0, 32,  25},  // FIGURE_ENEMY_SAMNITE_SPEAR_THROWER = 67,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 10, 1, 0,   2, 0,   0,              0,  110, 0,   0, 40,  25},  // FIGURE_ENEMY_GAUL_SWORDSMAN = 68,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 15, 2, 0,   3, 0,   0,              0,  120, 0,   0, 39,  25},  // FIGURE_ENEMY_GAUL_AXEMAN = 69,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 10, 1, 0,   2, 0,   0,              0,  110, 0,   0, 40,  25},  // FIGURE_ENEMY_HELVETIUS_SWORDSMAN = 70,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 15, 2, 0,   3, 0,   0,              0,  120, 0,   0, 39,  25},  // FIGURE_ENEMY_HELVETIUS_AXEMAN = 71,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  1, 0,   0, 0,   0,              0,  90, 0,    0, 35,  25},  // FIGURE_ENEMY_HUN_SWORDSMAN = 72,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 6,  1, 0,   0, 70,  FIGURE_ARROW,   15, 100, 0,   0, 34,  25},  // FIGURE_ENEMY_HUN_MOUNTED_ARCHER = 73,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  1, 0,   0, 0,   0,              0,  90, 0,    0, 35,  25},  // FIGURE_ENEMY_GOTH_SWORDSMAN = 74,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 6,  1, 0,   0, 70,  FIGURE_ARROW,   15, 100, 0,   0, 34,  25},  // FIGURE_ENEMY_GOTH_MOUNTED_ARCHER = 75,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  1, 0,   0, 0,   0,              0,  90, 0,    0, 35,  25},  // FIGURE_ENEMY_VISIGOTH_SWORDSMAN = 76,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 6,  1, 0,   0, 70,  FIGURE_ARROW,   15, 100, 0,   0, 34,  25},  // FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER = 77,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 12, 2, 0,   2, 0,   0,              0,  120, 0,   0, 37,  25},  // FIGURE_ENEMY_GREEK_SWORDSMAN = 78,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 5,  0, 0,   0, 70,  FIGURE_JAVELIN, 10, 70, 0,    0, 36,  25},  // FIGURE_ENEMY_GREEK_SPEAR_THROWER = 79,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 12, 2, 0,   2, 0,   0,              0,  120, 0,   0, 37,  25},  // FIGURE_ENEMY_MACEDONIAN_SWORDSMAN = 80,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 5,  0, 0,   0, 70,  FIGURE_JAVELIN, 10, 70, 0,    0, 36,  25},  // FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER = 81,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  1, 0,   0, 0,   0,              0,  90, 0,    0, 20,  25},  // FIGURE_ENEMY_NUMIDIAN_SWORDSMAN = 82,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 5,  0, 0,   0, 100, FIGURE_JAVELIN, 10, 70, 0,    0, 20,  25},  // FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER = 83,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  0, 0,   0, 0,   0,              0,  90, 0,    0, 45,  25},  // FIGURE_ENEMY_PERGAMUM_SWORDSMAN = 84,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 5,  0, 0,   0, 70,  FIGURE_ARROW,   15, 70, 0,    0, 44,  25},  // FIGURE_ENEMY_PERGAMUM_ARCHER = 85,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  0, 0,   0, 0,   0,              0,  90, 0,    0, 47,  25},  // FIGURE_ENEMY_IBERIAN_SWORDSMAN = 86,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 5,  0, 0,   0, 70,  FIGURE_JAVELIN, 10, 70, 0,    0, 46,  25},  // FIGURE_ENEMY_IBERIAN_SPEAR_THROWER = 87,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  0, 0,   0, 0,   0,              0,  90, 0,    0, 47,  25},  // FIGURE_ENEMY_JUDEAN_SWORDSMAN = 88,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 5,  0, 0,   0, 70,  FIGURE_JAVELIN, 10, 70, 0,    0, 46,  25},  // FIGURE_ENEMY_JUDEAN_SPEAR_THROWER = 89,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  0, 0,   0, 0,   0,              0,  90, 0,    0, 47,  25},  // FIGURE_ENEMY_SELEUCID_SWORDSMAN = 90,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 5,  0, 0,   0, 70,  FIGURE_JAVELIN, 10, 70, 0,    0, 46,  25},  // FIGURE_ENEMY_SELEUCID_SPEAR_THROWER = 91,
{0, 0, 0, 0, 0, 0, 0, 0, 1, 4,  0, 0,   0, 100, FIGURE_JAVELIN, 10, 90, 0,    0, 43,  25},  // FIGURE_ENEMY_CAESAR_JAVELIN = 92,
{0, 0, 0, 0, 0, 0, 0, 0, 1, 8,  0, 0,   0, 0,   0,              0,  100, 0,   0, 27,  25},  // FIGURE_ENEMY_CAESAR_MOUNTED = 93,
{0, 0, 0, 0, 0, 0, 0, 0, 1, 10, 3, 0,   6, 0,   0,              0,  150, 0,   0, 48,  25},  // FIGURE_ENEMY_CAESAR_LEGIONARY = 94,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 5,   0, 0,   0,              0,  0, 0,     0, 8,  -1},  // FIGURE_ARROW = 95,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  0, 0,     0, 8,  -1},  // FIGURE_MAP_FLAG = 96,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  0, 0,     0, 8,  -1},  // FIGURE_EXPLOSION = 97,
};

struct set_sound_t {
    int enabled;
    int volume;
};

struct clip_info_t {
    int clip_x;
    int clip_y;
    int clipped_pixels_left;
    int clipped_pixels_right;
    int clipped_pixels_top;
    int clipped_pixels_bottom;
    int visible_pixels_x;
    int visible_pixels_y;
    int is_visible;
};
static struct clip_info_t clip;

struct arrow_button_t {
    short x_offset;
    short y_offset;
    short image_id;
    short size;
    void (*left_click_handler)(int param1, int param2);
    int parameter1;
    int parameter2;
    // state
    int pressed;
    int repeats;
};

struct font_definition_t {
    int font;
    int image_offset;
    int space_width;
    int letter_spacing;
    int line_height;
    int (*image_y_offset)(uint8_t c, int image_height, int line_height);
};

struct generic_button_t {
    short x;
    short y;
    short width;
    short height;
    void (*left_click_handler)(int param1, int param2);
    void (*right_click_handler)(int param1, int param2);
    int parameter1;
    int parameter2;
};

struct image_button_t {
    short x_offset;
    short y_offset;
    short width;
    short height;
    short button_type;
    short image_collection;
    short image_offset;
    void (*left_click_handler)(int param1, int param2);
    void (*right_click_handler)(int param1, int param2);
    int parameter1;
    int parameter2;
    char enabled;
    // state
    char pressed;
    char focused;
    uint32_t pressed_since;
};

struct menu_item_t {
    short text_group;
    short text_number;
    void (*left_click_handler)(int param);
    int parameter;
    int hidden;
};

struct menu_bar_item_t {
    short text_group;
    struct menu_item_t *items;
    int num_items;
    short x_start;
    short x_end;
    int calculated_width_blocks;
    int calculated_height_blocks;
};

struct scrollbar_type_t {
    int x;
    int y;
    int height;
    void (*on_scroll_callback)(void);
    int dot_padding;
    int always_visible;
    int max_scroll_position;
    int scroll_position;
    int is_dragging_scroll;
    int scroll_position_drag;
};
static struct scrollbar_type_t *current;

struct window_type_t {
    int id;
    void (*draw_background)(void);
    void (*draw_foreground)(void);
    void (*handle_input)(struct mouse_t *m, struct hotkeys_t *h);
};

struct hotkey_mapping_t {
    int key;
    int modifiers;
    int action;
};

struct cursor_t {
    int hotspot_x;
    int hotspot_y;
    int width;
    int height;
    char *data;
};

struct grid_u8_t {
    uint8_t items[GRID_SIZE * GRID_SIZE];
};
static struct grid_u8_t aqueduct; // The aqueduct grid is used in two ways: 1) to mark water/no water 2) to store image IDs for the aqueduct (0-15). This leads to some strange results.
static struct grid_u8_t aqueduct_backup;
static struct grid_u8_t damage_grid;
static struct grid_u8_t bitfields_backup;
static struct grid_u8_t bitfields_grid;
static struct grid_u8_t edge_backup;
static struct grid_u8_t edge_grid;
static struct grid_u8_t network;
static struct grid_u8_t random;
static struct grid_u8_t rubble_type_grid;
static struct grid_u8_t sprite;
static struct grid_u8_t sprite_backup;
static struct grid_u8_t terrain_elevation;
static struct grid_u8_t water_drag;

struct grid_i8_t {
    int8_t items[GRID_SIZE * GRID_SIZE];
};
static struct grid_i8_t desirability_grid;
static struct grid_i8_t terrain_land_citizen;
static struct grid_i8_t terrain_land_noncitizen;
static struct grid_i8_t terrain_water;
static struct grid_i8_t terrain_walls;

struct grid_u16_t {
    uint16_t items[GRID_SIZE * GRID_SIZE];
};
static struct grid_u16_t buildings_grid;
static struct grid_u16_t images;
static struct grid_u16_t images_backup;
static struct grid_u16_t map_figures;
static struct grid_u16_t terrain_grid;
static struct grid_u16_t terrain_grid_backup;

struct grid_i16_t {
    int16_t items[GRID_SIZE * GRID_SIZE];
};
static struct grid_i16_t routing_distance;

struct terrain_image_t {
    int is_valid;
    int group_offset;
    int item_offset;
    int aqueduct_offset;
};

struct map_data_t {
    int width;
    int height;
    int start_offset;
    int border_size;
};
static struct map_data_t map_data;

struct win_criteria_t {
    uint8_t enabled;
    uint32_t goal;
};

struct time_limit_criteria_t {
    uint8_t enabled;
    uint16_t years;
};

struct request_t {
    uint16_t year;
    uint16_t amount;
    uint16_t years_deadline;
    uint16_t months_to_comply;
    uint8_t month;
    uint8_t resource;
    uint8_t favor;
    uint8_t state;
    uint8_t visible;
    uint8_t can_comply_dialog_shown;
};

struct editor_custom_messages_t {
    char title[MAX_CUSTOM_MESSAGE_TITLE];
    char text[MAX_CUSTOM_MESSAGE_TEXT];
    char video_file[MAX_CUSTOM_MESSAGE_VIDEO_TEXT];
    uint8_t month;
    uint8_t urgent;
    uint8_t enabled;
    uint16_t year;
};

struct earthquake_t {
    uint8_t state;
    uint8_t severity;
    uint8_t month;
    uint16_t year;
    uint16_t duration;
    uint16_t max_duration;
    uint8_t delay;
    uint8_t max_delay;
    uint8_t point;
    struct map_point_t branch_coordinates[MAX_EARTHQUAKE_BRANCHES];
};

struct invasion_t {
    uint16_t year_offset;
    uint16_t amount;
    uint8_t month;
    uint8_t type;
    uint8_t enemy_type;
    uint8_t from;
    uint8_t target_type;
};

struct price_change_t {
    uint16_t year;
    uint8_t month;
    uint8_t resource;
    uint8_t is_rise;
    uint8_t amount;
};

struct demand_change_t {
    uint16_t year;
    uint8_t month;
    uint8_t resource;
    uint8_t trade_city_id;
    uint8_t is_rise;
};

struct scenario_t {
    struct {
        uint16_t width;
        uint16_t height;
        uint16_t grid_start;
        uint16_t grid_border_size;
    } map;
    struct {
        uint16_t expansion_year;
        uint8_t id;
        uint8_t is_expanded;
        uint8_t distant_battle_roman_travel_months;
        uint8_t distant_battle_enemy_travel_months;
    } empire;
    char scenario_name[MAX_SCENARIO_NAME];
    char brief_description[MAX_BRIEF_DESCRIPTION];
    uint8_t brief_description_image_id;
    char briefing[MAX_BRIEFING];
    uint8_t climate;
    uint8_t player_rank;
    int16_t start_year;
    uint8_t initial_favor;
    uint32_t initial_funds;
    uint32_t rescue_loan;
    uint32_t initial_personal_savings;
    uint8_t rome_supplies_wheat;
    uint8_t flotsam_enabled;
    struct win_criteria_t population_win_criteria;
    struct win_criteria_t culture_win_criteria;
    struct win_criteria_t prosperity_win_criteria;
    struct win_criteria_t peace_win_criteria;
    struct win_criteria_t favor_win_criteria;
    struct time_limit_criteria_t time_limit_win_criteria;
    struct time_limit_criteria_t survival_time_win_criteria;
    struct {
        uint8_t state;
        uint8_t month;
        uint16_t year;
    } gladiator_revolt;
    struct {
        uint8_t sea_trade_problem;
        uint8_t land_trade_problem;
        uint8_t raise_wages;
        uint8_t lower_wages;
        uint8_t contaminated_water;
    } random_events;
    uint8_t allowed_buildings[BUILDING_TYPE_MAX];
    struct request_t requests[MAX_REQUESTS];
    struct editor_custom_messages_t editor_custom_messages[MAX_EDITOR_CUSTOM_MESSAGES];
    struct earthquake_t earthquakes[MAX_EARTHQUAKES];
    struct invasion_t invasions[MAX_INVASIONS];
    uint8_t invasion_upcoming;
    struct price_change_t price_changes[MAX_PRICE_CHANGES];
    struct demand_change_t demand_changes[MAX_DEMAND_CHANGES];
    struct map_point_t earthquake_points[MAX_EARTHQUAKE_POINTS];
    struct map_point_t invasion_points[MAX_INVASION_POINTS];
    struct map_point_t entry_point;
    struct map_point_t exit_point;
    struct map_point_t river_entry_point;
    struct map_point_t river_exit_point;
    struct map_point_t herd_points[MAX_HERD_POINTS];
    struct map_point_t fishing_points[MAX_FISH_POINTS];
    struct {
        uint32_t hut;
        uint32_t meeting;
        uint32_t crops;
        uint32_t vacant_lots;
    } native_images;
    uint8_t is_saved;
};
static struct scenario_t scenario;

struct scenario_settings_t {
    char player_name[MAX_PLAYER_NAME];
};
static struct scenario_settings_t scenario_settings;

struct advisor_window_type_t {
    int (*draw_background)(void);
    void (*draw_foreground)(void);
    int (*handle_mouse)(struct mouse_t *m);
};
static struct advisor_window_type_t *current_advisor_window = 0;

struct submenu_t {
    int building_id;
    char *submenu_string;
    int submenu_items[MAX_ITEMS_PER_SUBMENU];
};

struct build_menu_t {
    int is_enabled;
    struct submenu_t menu_items[MAX_ITEMS_PER_BUILD_MENU];
};
static struct build_menu_t build_menus[BUILD_MENU_BUTTONS_COUNT];

struct city_overlay_t {
    int type;
    int column_type;
    int (*show_building)(struct building_t *b);
    int (*show_figure)(struct figure_t *f);
    int (*get_column_height)(struct building_t *b);
    void (*draw_custom_footprint)(int x, int y, int grid_offset);
    void (*draw_custom_top)(int x, int y, int grid_offset);
};
static struct city_overlay_t *overlay = 0;

struct pixel_coordinate_t {
    int x;
    int y;
};

struct input_box_t {
    int x;
    int y;
    int width_blocks;
    int height_blocks;
    int font;
    int allow_punctuation;
    char *text;
    int text_length;
};
static struct input_box_t scenario_description_input = {
    90, 16, 20, 2, FONT_NORMAL_WHITE, 1,
    brief_description, MAX_BRIEF_DESCRIPTION
};
static struct input_box_t scenario_briefing_input = {
    -260, -150, 55, 2, FONT_NORMAL_WHITE, 1,
    briefing, MAX_BRIEFING
};
static struct input_box_t editor_custom_message_input_video_file = { 36, 154, 10, 2, FONT_NORMAL_WHITE, 1, editor_custom_message_video_file, MAX_CUSTOM_MESSAGE_TITLE };
static struct input_box_t editor_custom_message_input_title = { -68, 64, 17, 2, FONT_NORMAL_WHITE, 1, editor_custom_message_title, MAX_CUSTOM_MESSAGE_TITLE };
static struct input_box_t editor_custom_message_input_text = { -68, 64, 46, 2, FONT_NORMAL_WHITE, 1, editor_custom_message_text, MAX_CUSTOM_MESSAGE_TEXT };

struct {
    int active;
    int quit;
} data = { 1, 0 };

struct {
    SDL_Cursor *cursors[CURSOR_MAX];
    SDL_Surface *surfaces[CURSOR_MAX];
    int current_shape;
    int current_scale;
} cursor_data;

struct {
    int x;
    int y;
    int enabled;
} cursor_mouse_data;

struct {
    SDL_Window *window;
    SDL_Renderer *renderer;
    SDL_Texture *texture;
    SDL_Texture *cursors[CURSOR_MAX];
} SDL;

struct {
    int x;
    int y;
    int centered;
} window_pos = { 0, 0, 1 };

struct {
    int WIDTH;
    int HEIGHT;
} MINIMUM = { 640, 480 };

static struct {
    int position;
    struct speed_type_t slide_speed;
    int direction;
    back_sidebar_draw_function back_sidebar_draw;
    front_sidebar_draw_function front_sidebar_draw;
    slide_finished_function finished_callback;
} widget_slide_data;

struct objective_t {
    int value;
    int target;
};

static struct {
    int x_offset;
    int y_offset;
    int width;
    int height;
    int is_collapsed;
    int info_to_display;
    int game_speed;
    int unemployment_percentage;
    int unemployment_amount;
    struct objective_t culture;
    struct objective_t prosperity;
    struct objective_t peace;
    struct objective_t favor;
    struct objective_t population;
} extra_widget_data;

static struct {
    int absolute_x;
    int absolute_y;
    int width_tiles;
    int height_tiles;
    int x_offset;
    int y_offset;
    int width;
    int height;
    color_t enemy_color;
    color_t *cache;
    struct {
        int x;
        int y;
        int grid_offset;
    } mouse;
    int refresh_requested;
    int camera_x;
    int camera_y;
} minimap_data;

static int draw_cursor_input_box;

static struct {
    struct map_tile_t current_tile;
    struct map_tile_t selected_tile;
    int new_start_grid_offset;
    int capture_input;
} widget_city_data;

static struct {
    uint32_t last_water_animation_time;
    int advance_water_animation;
    int image_id_water_first;
    int image_id_water_last;
    int selected_figure_id;
    int highlighted_formation;
    struct pixel_coordinate_t *selected_figure_coord;
} draw_context;

static struct {
    int offset_funds;
    int offset_population;
    int offset_date;

    int open_sub_menu;
    int focus_menu_id;
    int focus_sub_menu_id;
} top_menu_data;

static struct {
    int population;
    int treasury;
    int month;
} drawn;

static struct {
    int absolute_x;
    int absolute_y;
    int width_tiles;
    int height_tiles;
    int x_offset;
    int y_offset;
} scenario_minimap_data;

struct tile_color_t {
    color_t left;
    color_t right;
};

struct tile_color_set_t {
    struct tile_color_t water[4];
    struct tile_color_t tree[4];
    struct tile_color_t rock[4];
    struct tile_color_t meadow[4];
    struct tile_color_t grass[8];
    struct tile_color_t road;
};

// Since the minimap tiles are only 25 color sets per climate, we just hardcode them.
// This "hack" is necessary to avoid reloading the climate graphics when selecting
// a scenario with another climate in the CCK selection screen, which is expensive.
static   struct tile_color_set_t MINIMAP_COLOR_SETS[3] = {
    // central
    {
        .water = {{0x394a7b, 0x31427b}, {0x394a7b, 0x314273}, {0x313973, 0x314273}, {0x31427b, 0x394a7b}},
        .tree = {{0x6b8431, 0x102108}, {0x103908, 0x737b29}, {0x103108, 0x526b21}, {0x737b31, 0x084a10}},
        .rock = {{0x948484, 0x635a4a}, {0xa59c94, 0xb5ada5}, {0xb5ada5, 0x8c8484}, {0x635a4a, 0xa59c94}},
        .meadow = {{0xd6bd63, 0x9c8c39}, {0x948c39, 0xd6bd63}, {0xd6bd63, 0x9c9439}, {0x848431, 0xada54a}},
        .grass = {
            {0x6b8c31, 0x6b7b29}, {0x738431, 0x6b7b29}, {0x6b7329, 0x7b8c39}, {0x527b29, 0x6b7321},
            {0x6b8431, 0x737b31}, {0x6b7b31, 0x737b29}, {0x636b18, 0x526b21}, {0x737b31, 0x737b29}
        },
        .road = {0x736b63, 0x4a3121}
    },
    // northern
    {
        .water = {{0x394a7b, 0x31427b}, {0x394a7b, 0x314273}, {0x313973, 0x314273}, {0x31427b, 0x394a7b}},
        .tree = {{0x527b31, 0x082108}, {0x083908, 0x5a7329}, {0x082908, 0x316b21}, {0x527b29, 0x084a21}},
        .rock = {{0x8c8484, 0x5a5252}, {0x9c9c94, 0xa5a5a5}, {0xa5a5a5, 0x848484}, {0x5a5252, 0x9c9c94}},
        .meadow = {{0x427318, 0x8c9442}, {0xb5ad4a, 0x738c39}, {0x8c8c39, 0x6b7b29}, {0x527331, 0x5a8442}},
        .grass = {
            {0x4a8431, 0x4a7329}, {0x527b29, 0x4a7329}, {0x526b29, 0x5a8439}, {0x397321, 0x4a6b21},
            {0x527b31, 0x5a7331}, {0x4a7329, 0x5a7329}, {0x4a6b18, 0x316b21}, {0x527b29, 0x527329}
        },
        .road = {0x736b63, 0x4a3121}
    },
    // desert
    {
        .water = {{0x4a84c6, 0x4a7bc6}, {0x4a84c6, 0x4a7bc6}, {0x4a84c6, 0x5284c6}, {0x4a7bbd, 0x4a7bc6}},
        .tree = {{0xa59c7b, 0x6b7b18}, {0x214210, 0xada573}, {0x526b21, 0xcec6a5}, {0xa59c7b, 0x316321}},
        .rock = {{0xa59494, 0x736352}, {0xa59c94, 0xb5ada5}, {0xb5ada5, 0x8c847b}, {0x736352, 0xbdada5}},
        .meadow = {{0x739c31, 0x9cbd52}, {0x7bb529, 0x63ad21}, {0x9cbd52, 0x8c944a}, {0x7ba539, 0x739c31}},
        .grass = {
            {0xbdbd9c, 0xb5b594}, {0xc6bda5, 0xbdbda5}, {0xbdbd9c, 0xc6c6ad}, {0xd6cead, 0xc6bd9c},
            {0xa59c7b, 0xbdb594}, {0xcecead, 0xb5ad94}, {0xc6c6a5, 0xdedebd}, {0xcecead, 0xd6d6b5}
        },
        .road = {0x6b5a52, 0x4a4239}
    }
};

static struct {
    struct {
        int text_id;
        int scroll_position;
    } history[200];
    int num_history;
    int text_id;
    void (*background_callback)(void);
    int show_video;
    int x;
    int y;
    int x_text;
    int y_text;
    int text_height_blocks;
    int text_width_blocks;
    int focus_button_id;
} message_dialog_data;

static struct {
    int year;
    int month;
    int param1;
    int param2;
    int message_advisor;
    int use_popup;
} player_message;

static struct {
    int width_blocks;
    int height_blocks;
    int x_text;
    int y_text;
    int text_width_blocks;
    int text_height_blocks;
    int focus_button_id;
} message_list_data;

static struct {
    int x;
    int y;
    int max_digits;
    int max_value;
    void (*callback)(int);

    int num_digits;
    int value;
    int focus_button_id;
} numeric_input_data;

static struct {
    int selected_menu;
    int selected_submenu;
    int num_submenu_items;
    uint32_t submenu_focus_time;
    int menu_focus_button_id;
    int submenu_focus_button_id;
    int keep_submenu_open;
} overlay_menu_data;

static struct {
    char *title;
    char *message;
    char *extra;
} plain_message_dialog_data;

static struct {
    int type;
    int custom_text_group;
    int custom_text_id;
    int ok_clicked;
    void (*close_func)(void);
    int has_buttons;
} popup_dialog_data;

static struct {
    int resource;
    int focus_button_id;
} resource_settings_data;

static struct {
    int x;
    int y;
    int mode;
    int group;
    char **items;
    int num_items;
    void (*callback)(int);
    int focus_button_id;
} select_list_data;

static struct {
    int focus_button_id;
    int from_editor;
} sound_options_data;

static struct {
    int focus_button_id;
    int from_editor;
    int original_game_speed;
    int original_scroll_speed;
} speed_options_data;

static struct {
    int width;
    int height;
    void (*callback)(void);
} victory_video_data;

static struct {
    int action;
    int index;
    int key;
    int modifiers;
    void (*callback)(int, int, int, int);
    int focus_button;
} hotkey_editor_window_data;

static struct {
    int type;
    void (*callback)(void);
    uint32_t start_time;
} intermezzo_data;

static struct {
    int category;
    int max_items;
    int focus_id_button_set_priority;
    int focus_id_button_remove_priority;
} labor_priority_data;

struct file_type_data_t {
    char extension[4];
    char last_loaded_file[FILE_NAME_MAX];
};

static struct {
    uint32_t message_not_exist_start_time;
    int type;
    int dialog_type;
    int focus_button_id;
    int double_click;
    struct dir_listing *file_list;
    struct file_type_data_t *file_data;
    char typed_name[FILE_NAME_MAX];
    char previously_seen_typed_name[FILE_NAME_MAX];
    char selected_file[FILE_NAME_MAX];
} file_dialog_data;

static struct input_box_t file_name_input = { 144, 80, 20, 2, FONT_NORMAL_WHITE, 0, file_dialog_data.typed_name, FILE_NAME_MAX };

static struct file_type_data_t saved_game_data = { "sav", {0} };
static struct file_type_data_t file_type_scenario_data = { "map", {0} };

struct hotkey_widget_t {
    int action;
};

static struct {
    int focus_button;
    int bottom_focus_button;
    struct hotkey_mapping_t mappings[HOTKEY_MAX_ITEMS][2];
} hotkey_config_window_data;

static struct {
    int focus_button_id;
    void (*close_callback)(void);
} display_options_data;

static struct {
    int focus_button_id;
    int focus_arrow_button_id;
} donate_to_city_data;

static struct {
    struct empire_object_t *selected_object;
    int selected_button;
    int x_min, x_max, y_min, y_max;
    int x_draw_offset, y_draw_offset;
    int focus_button_id;
    int focus_resource;
} empire_window_data;

static struct hotkey_widget_t hotkey_widgets[] = {
    {HOTKEY_HEADER},
    {HOTKEY_ARROW_UP},
    {HOTKEY_ARROW_DOWN},
    {HOTKEY_ARROW_LEFT},
    {HOTKEY_ARROW_RIGHT},
    {HOTKEY_HEADER},
    {HOTKEY_TOGGLE_FULLSCREEN},
    {HOTKEY_RESET_WINDOW},
    {HOTKEY_SAVE_SCREENSHOT},
    {HOTKEY_SAVE_CITY_SCREENSHOT},
    {HOTKEY_LOAD_FILE},
    {HOTKEY_SAVE_FILE},
    {HOTKEY_HEADER},
    {HOTKEY_DECREASE_GAME_SPEED},
    {HOTKEY_INCREASE_GAME_SPEED},
    {HOTKEY_TOGGLE_PAUSE},
    {HOTKEY_ROTATE_MAP_LEFT},
    {HOTKEY_ROTATE_MAP_RIGHT},
    {HOTKEY_REPLAY_MAP},
    {HOTKEY_CYCLE_LEGION},
    {HOTKEY_RETURN_LEGIONS_TO_FORT},
    {HOTKEY_SHOW_LAST_ADVISOR},
    {HOTKEY_SHOW_EMPIRE_MAP},
    {HOTKEY_SHOW_MESSAGES},
    {HOTKEY_GO_TO_PROBLEM},
    {HOTKEY_HEADER},
    {HOTKEY_SHOW_OVERLAY_WATER},
    {HOTKEY_SHOW_OVERLAY_FIRE},
    {HOTKEY_SHOW_OVERLAY_DAMAGE},
    {HOTKEY_SHOW_OVERLAY_CRIME},
    {HOTKEY_SHOW_OVERLAY_PROBLEMS},
    {HOTKEY_HEADER},
    {HOTKEY_GO_TO_BOOKMARK_1},
    {HOTKEY_GO_TO_BOOKMARK_2},
    {HOTKEY_GO_TO_BOOKMARK_3},
    {HOTKEY_GO_TO_BOOKMARK_4},
    {HOTKEY_SET_BOOKMARK_1},
    {HOTKEY_SET_BOOKMARK_2},
    {HOTKEY_SET_BOOKMARK_3},
    {HOTKEY_SET_BOOKMARK_4},
    {HOTKEY_HEADER},
    {HOTKEY_EDITOR_TOGGLE_BATTLE_INFO},
    {HOTKEY_HEADER},
    {HOTKEY_CHEAT_MONEY},
    {HOTKEY_CHEAT_INVASION},
    {HOTKEY_CHEAT_VICTORY},
    {HOTKEY_HEADER},
    {HOTKEY_BUILD_CLONE},
    {HOTKEY_CYCLE_BUILDINGS},
    {HOTKEY_CYCLE_BUILDINGS_REVERSE},
    {HOTKEY_UNDO},
    {HOTKEY_BUILD_VACANT_HOUSE},
    {HOTKEY_BUILD_CLEAR_LAND},
    {HOTKEY_BUILD_ROAD},
    {HOTKEY_BUILD_RESERVOIR},
    {HOTKEY_BUILD_AQUEDUCT},
    {HOTKEY_BUILD_FOUNTAIN},
    {HOTKEY_BUILD_WELL},
    {HOTKEY_BUILD_BARBER},
    {HOTKEY_BUILD_BATHHOUSE},
    {HOTKEY_BUILD_DOCTOR},
    {HOTKEY_BUILD_HOSPITAL},
    {HOTKEY_BUILD_SMALL_TEMPLE_CERES},
    {HOTKEY_BUILD_SMALL_TEMPLE_NEPTUNE},
    {HOTKEY_BUILD_SMALL_TEMPLE_MERCURY},
    {HOTKEY_BUILD_SMALL_TEMPLE_MARS},
    {HOTKEY_BUILD_SMALL_TEMPLE_VENUS},
    {HOTKEY_BUILD_LARGE_TEMPLE_CERES},
    {HOTKEY_BUILD_LARGE_TEMPLE_NEPTUNE},
    {HOTKEY_BUILD_LARGE_TEMPLE_MERCURY},
    {HOTKEY_BUILD_LARGE_TEMPLE_MARS},
    {HOTKEY_BUILD_LARGE_TEMPLE_VENUS},
    {HOTKEY_BUILD_ORACLE},
    {HOTKEY_BUILD_SCHOOL},
    {HOTKEY_BUILD_ACADEMY},
    {HOTKEY_BUILD_LIBRARY},
    {HOTKEY_BUILD_MISSION_POST},
    {HOTKEY_BUILD_THEATER},
    {HOTKEY_BUILD_AMPHITHEATER},
    {HOTKEY_BUILD_COLOSSEUM},
    {HOTKEY_BUILD_HIPPODROME},
    {HOTKEY_BUILD_GLADIATOR_SCHOOL},
    {HOTKEY_BUILD_LION_HOUSE},
    {HOTKEY_BUILD_ACTOR_COLONY},
    {HOTKEY_BUILD_CHARIOT_MAKER},
    {HOTKEY_BUILD_FORUM},
    {HOTKEY_BUILD_SENATE},
    {HOTKEY_BUILD_GOVERNORS_HOUSE},
    {HOTKEY_BUILD_GOVERNORS_VILLA},
    {HOTKEY_BUILD_GOVERNORS_PALACE},
    {HOTKEY_BUILD_SMALL_STATUE},
    {HOTKEY_BUILD_MEDIUM_STATUE},
    {HOTKEY_BUILD_LARGE_STATUE},
    {HOTKEY_BUILD_TRIUMPHAL_ARCH},
    {HOTKEY_BUILD_GARDENS},
    {HOTKEY_BUILD_PLAZA},
    {HOTKEY_BUILD_ENGINEERS_POST},
    {HOTKEY_BUILD_LOW_BRIDGE},
    {HOTKEY_BUILD_SHIP_BRIDGE},
    {HOTKEY_BUILD_SHIPYARD},
    {HOTKEY_BUILD_DOCK},
    {HOTKEY_BUILD_WHARF},
    {HOTKEY_BUILD_WALL},
    {HOTKEY_BUILD_TOWER},
    {HOTKEY_BUILD_GATEHOUSE},
    {HOTKEY_BUILD_PREFECTURE},
    {HOTKEY_BUILD_FORT_LEGIONARIES},
    {HOTKEY_BUILD_FORT_JAVELIN},
    {HOTKEY_BUILD_FORT_MOUNTED},
    {HOTKEY_BUILD_MILITARY_ACADEMY},
    {HOTKEY_BUILD_BARRACKS},
    {HOTKEY_BUILD_WHEAT_FARM},
    {HOTKEY_BUILD_VEGETABLE_FARM},
    {HOTKEY_BUILD_FRUIT_FARM},
    {HOTKEY_BUILD_OLIVE_FARM},
    {HOTKEY_BUILD_VINES_FARM},
    {HOTKEY_BUILD_PIG_FARM},
    {HOTKEY_BUILD_CLAY_PIT},
    {HOTKEY_BUILD_MARBLE_QUARRY},
    {HOTKEY_BUILD_IRON_MINE},
    {HOTKEY_BUILD_TIMBER_YARD},
    {HOTKEY_BUILD_WINE_WORKSHOP},
    {HOTKEY_BUILD_OIL_WORKSHOP},
    {HOTKEY_BUILD_WEAPONS_WORKSHOP},
    {HOTKEY_BUILD_FURNITURE_WORKSHOP},
    {HOTKEY_BUILD_POTTERY_WORKSHOP},
    {HOTKEY_BUILD_MARKET},
    {HOTKEY_BUILD_GRANARY},
    {HOTKEY_BUILD_WAREHOUSE},
};

struct numerical_range_widget_t {
    int width_blocks;
    int min;
    int max;
    int step;
    int *value;
};

struct config_widget_t {
    int type;
    int subtype;
    char *(*get_display_text)(void);
    int enabled;
};

static struct numerical_range_widget_t scale_ranges[] = {
    {30, 50, 500, 5, 0},
    {30, 100, 200, 50, 0}
};

static struct {
    struct config_widget_t *widgets[MAX_WIDGETS];
    int num_widgets;
    int focus_button;
    int bottom_focus_button;
    struct {
        int original_value;
        int new_value;
        int (*change_action)(int key);
    } config_values[CONFIG_MAX_ENTRIES];
    struct {
        char original_value[CONFIG_STRING_VALUE_MAX];
        char new_value[CONFIG_STRING_VALUE_MAX];
        int (*change_action)(int key);
    } config_string_values[CONFIG_STRING_MAX_ENTRIES];
    int active_numerical_range;
} window_config_data;

static struct input_box_t player_name_input = { 125, 50, 20, 2, FONT_NORMAL_WHITE, 0, window_config_data.config_string_values[CONFIG_STRING_PLAYER_NAME].new_value, MAX_PLAYER_NAME_LENGTH };

static struct {
    int selected_menu;
    int selected_submenu;
    int num_items_to_draw;
    int y_offset;
    int focus_button_id;
} build_menu_data = { MENU_NONE, MENU_NONE, 0, 0, 0 };

static struct {
    int focus_button_id;
    int focus_toggle_button;
    int selected_item;
    int show_minimap;
    char selected_scenario_filename[FILE_NAME_MAX];
    char selected_scenario_display[FILE_NAME_MAX];
    struct dir_listing *scenarios;
} cck_selection_data;

struct sound_channel_t {
    char *filename;
    Mix_Chunk *chunk;
};

static struct {
    int initialized;
    Mix_Music *music;
    struct sound_channel_t channels[MAX_DEVICE_CHANNELS];
} data_channels;

static struct {
    SDL_AudioFormat dst_format;
    SDL_AudioStream *stream;
} custom_music;

struct city_channel_t {
    int in_use;
    int available;
    int total_views;
    int views_threshold;
    int direction_views[5];
    int channel;
    int times_played;
    uint32_t last_played_time;
    uint32_t delay_millis;
    int should_play;
};
static struct city_channel_t channels[MAX_CITY_SOUNDS_CHANNELS];

static struct {
    int current_track;
    int next_check;
} sound_data = { TRACK_NONE, 0 };

static struct {
    int pct_type[MAX_ENEMY_TYPES_PER_ARMY];
    int figure_types[MAX_ENEMY_TYPES_PER_ARMY];
    int formation_layout;
    int enemy_img_group;
} ENEMY_PROPERTIES[] = {
    {{100, 0, 0}, {FIGURE_ENEMY_BARBARIAN_SWORDSMAN, 0, 0}, FORMATION_ENEMY_MOB, ENEMY_IMG_TYPE_BARBARIAN}, // barbarian
    {{90, 10, 0}, {FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN, FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT, 0}, FORMATION_ENEMY_WIDE_COLUMN, ENEMY_IMG_TYPE_CARTHAGINIAN}, // carthaginian
    {{80, 20, 0}, {FIGURE_ENEMY_BRITON_SWORDSMAN, FIGURE_ENEMY_BRITON_CHARIOT, 0}, FORMATION_ENEMY_MOB, ENEMY_IMG_TYPE_CELT}, // briton
    {{80, 20, 0}, {FIGURE_ENEMY_CELT_SWORDSMAN, FIGURE_ENEMY_CELT_CHARIOT, 0}, FORMATION_ENEMY_MOB, ENEMY_IMG_TYPE_CELT}, // celt
    {{80, 20, 0}, {FIGURE_ENEMY_PICT_SWORDSMAN, FIGURE_ENEMY_PICT_CHARIOT, 0}, FORMATION_ENEMY_MOB, ENEMY_IMG_TYPE_CELT}, // pict
    {{80, 20, 0}, {FIGURE_ENEMY_EGYPTIAN_SWORDSMAN, FIGURE_ENEMY_EGYPTIAN_CAMEL, 0}, FORMATION_ENEMY_WIDE_COLUMN, ENEMY_IMG_TYPE_EGYPTIAN}, // egyptian
    {{50, 50, 0}, {FIGURE_ENEMY_ETRUSCAN_SWORDSMAN, FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER, 0}, FORMATION_DOUBLE_LINE_1, ENEMY_IMG_TYPE_ETRUSCAN}, // etruscan
    {{50, 50, 0}, {FIGURE_ENEMY_SAMNITE_SWORDSMAN, FIGURE_ENEMY_SAMNITE_SPEAR_THROWER, 0}, FORMATION_DOUBLE_LINE_1, ENEMY_IMG_TYPE_ETRUSCAN}, // samnite
    {{50, 50, 0}, {FIGURE_ENEMY_GAUL_SWORDSMAN, FIGURE_ENEMY_GAUL_AXEMAN, 0}, FORMATION_ENEMY_MOB, ENEMY_IMG_TYPE_GAUL}, // gaul
    {{50, 50, 0}, {FIGURE_ENEMY_HELVETIUS_SWORDSMAN, FIGURE_ENEMY_HELVETIUS_AXEMAN, 0}, FORMATION_ENEMY_MOB, ENEMY_IMG_TYPE_GAUL}, // helvetius
    {{50, 50, 0}, {FIGURE_ENEMY_HUN_SWORDSMAN, FIGURE_ENEMY_HUN_MOUNTED_ARCHER, 0}, FORMATION_ENEMY_MOB, ENEMY_IMG_TYPE_GOTH}, // hun
    {{50, 50, 0}, {FIGURE_ENEMY_GOTH_SWORDSMAN, FIGURE_ENEMY_GOTH_MOUNTED_ARCHER, 0}, FORMATION_ENEMY_MOB, ENEMY_IMG_TYPE_GOTH}, // goth
    {{50, 50, 0}, {FIGURE_ENEMY_VISIGOTH_SWORDSMAN, FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER, 0}, FORMATION_ENEMY_MOB, ENEMY_IMG_TYPE_GOTH}, // visigoth
    {{80, 20, 0}, {FIGURE_ENEMY_GREEK_SWORDSMAN, FIGURE_ENEMY_GREEK_SPEAR_THROWER, 0}, FORMATION_DOUBLE_LINE_1, ENEMY_IMG_TYPE_GREEK}, // greek
    {{80, 20, 0}, {FIGURE_ENEMY_MACEDONIAN_SWORDSMAN, FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER, 0}, FORMATION_DOUBLE_LINE_1, ENEMY_IMG_TYPE_GREEK}, // macedonian
    {{40, 60, 0}, {FIGURE_ENEMY_NUMIDIAN_SWORDSMAN, FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER, 0}, FORMATION_ENEMY_MOB, ENEMY_IMG_TYPE_NORTH_AFRICAN}, // numidian
    {{30, 70, 0}, {FIGURE_ENEMY_PERGAMUM_SWORDSMAN, FIGURE_ENEMY_PERGAMUM_ARCHER, 0}, FORMATION_TORTOISE, ENEMY_IMG_TYPE_PERSIAN}, // pergamum
    {{50, 50, 0}, {FIGURE_ENEMY_IBERIAN_SWORDSMAN, FIGURE_ENEMY_IBERIAN_SPEAR_THROWER, 0}, FORMATION_DOUBLE_LINE_1, ENEMY_IMG_TYPE_PHOENICIAN}, // iberian
    {{50, 50, 0}, {FIGURE_ENEMY_JUDEAN_SWORDSMAN, FIGURE_ENEMY_JUDEAN_SPEAR_THROWER, 0}, FORMATION_DOUBLE_LINE_1, ENEMY_IMG_TYPE_PHOENICIAN}, // judean
    {{50, 50, 0}, {FIGURE_ENEMY_SELEUCID_SWORDSMAN, FIGURE_ENEMY_SELEUCID_SPEAR_THROWER, 0}, FORMATION_DOUBLE_LINE_1, ENEMY_IMG_TYPE_PHOENICIAN}, // seleucid
    {{100, 0, 0}, {FIGURE_ENEMY_CAESAR_LEGIONARY, 0, 0}, FORMATION_TORTOISE, ENEMY_IMG_TYPE_CAESAR} // caesar
};

static struct {
    int width;
    int height;
} MAP_SIZES[] = {
    {40, 40},
    {60, 60},
    {80, 80},
    {100, 100},
    {120, 120},
    {160, 160}
};

static struct {
    int items[MAX_QUEUE];
    int head;
    int tail;
} water_supply_queue;

static struct {
    int total_routes_calculated;
    int enemy_routes_calculated;
} stats = { 0, 0 };

static struct {
    int head;
    int tail;
    int items[MAX_QUEUE_ROUTING];
} routing_queue;

static struct {
    int items[MAX_QUEUE];
    int head;
    int tail;
} road_network_queue;

struct terrain_image_context {
    unsigned char tiles[MAX_TILES_TERRAIN];
    unsigned char offset_for_orientation[4];
    unsigned char aqueduct_offset;
    unsigned char max_item_offset;
    unsigned char current_item_offset;
};

// 0 = no match
// 1 = match
// 2 = don't care
static struct terrain_image_context terrain_images_water[48] = {
    {{1, 2, 1, 2, 1, 2, 1, 2}, {79, 79, 79, 79}, 0, 1, 0},
    {{1, 2, 1, 2, 1, 2, 0, 2}, {47, 46, 45, 44}, 0, 1, 0},
    {{0, 2, 1, 2, 1, 2, 1, 2}, {44, 47, 46, 45}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 2, 1, 2}, {45, 44, 47, 46}, 0, 1, 0},
    {{1, 2, 1, 2, 0, 2, 1, 2}, {46, 45, 44, 47}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 2, 0, 2}, {40, 42, 40, 42}, 0, 2, 0},
    {{0, 2, 1, 2, 0, 2, 1, 2}, {42, 40, 42, 40}, 0, 2, 0},
    {{1, 2, 1, 2, 0, 0, 0, 2}, {32, 28, 24, 36}, 0, 4, 0},
    {{0, 2, 1, 2, 1, 2, 0, 0}, {36, 32, 28, 24}, 0, 4, 0},
    {{0, 0, 0, 2, 1, 2, 1, 2}, {24, 36, 32, 28}, 0, 4, 0},
    {{1, 2, 0, 0, 0, 2, 1, 2}, {28, 24, 36, 32}, 0, 4, 0},
    {{1, 2, 1, 2, 0, 1, 0, 2}, {77, 76, 75, 78}, 0, 1, 0},
    {{0, 2, 1, 2, 1, 2, 0, 1}, {78, 77, 76, 75}, 0, 1, 0},
    {{0, 1, 0, 2, 1, 2, 1, 2}, {75, 78, 77, 76}, 0, 1, 0},
    {{1, 2, 0, 1, 0, 2, 1, 2}, {76, 75, 78, 77}, 0, 1, 0},
    {{1, 2, 0, 0, 0, 0, 0, 2}, {16, 12, 8, 20}, 0, 4, 0},
    {{0, 2, 1, 2, 0, 0, 0, 0}, {20, 16, 12, 8}, 0, 4, 0},
    {{0, 0, 0, 2, 1, 2, 0, 0}, {8, 20, 16, 12}, 0, 4, 0},
    {{0, 0, 0, 0, 0, 2, 1, 2}, {12, 8, 20, 16}, 0, 4, 0},
    {{1, 2, 0, 1, 0, 0, 0, 2}, {69, 66, 63, 72}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 1, 0, 0}, {72, 69, 66, 63}, 0, 1, 0},
    {{0, 0, 0, 2, 1, 2, 0, 1}, {63, 72, 69, 66}, 0, 1, 0},
    {{0, 1, 0, 0, 0, 2, 1, 2}, {66, 63, 72, 69}, 0, 1, 0},
    {{1, 2, 0, 0, 0, 1, 0, 2}, {70, 67, 64, 73}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 0, 0, 1}, {73, 70, 67, 64}, 0, 1, 0},
    {{0, 1, 0, 2, 1, 2, 0, 0}, {64, 73, 70, 67}, 0, 1, 0},
    {{0, 0, 0, 1, 0, 2, 1, 2}, {67, 64, 73, 70}, 0, 1, 0},
    {{1, 2, 0, 1, 0, 1, 0, 2}, {71, 68, 65, 74}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 1, 0, 1}, {74, 71, 68, 65}, 0, 1, 0},
    {{0, 1, 0, 2, 1, 2, 0, 1}, {65, 74, 71, 68}, 0, 1, 0},
    {{0, 1, 0, 1, 0, 2, 1, 2}, {68, 65, 74, 71}, 0, 1, 0},
    {{0, 1, 0, 1, 0, 1, 0, 1}, {62, 62, 62, 62}, 0, 1, 0},
    {{0, 1, 0, 1, 0, 1, 0, 0}, {60, 59, 58, 61}, 0, 1, 0},
    {{0, 0, 0, 1, 0, 1, 0, 1}, {61, 60, 59, 58}, 0, 1, 0},
    {{0, 1, 0, 0, 0, 1, 0, 1}, {58, 61, 60, 59}, 0, 1, 0},
    {{0, 1, 0, 1, 0, 0, 0, 1}, {59, 58, 61, 60}, 0, 1, 0},
    {{0, 1, 0, 0, 0, 1, 0, 0}, {48, 49, 48, 49}, 0, 1, 0},
    {{0, 0, 0, 1, 0, 0, 0, 1}, {49, 48, 49, 48}, 0, 1, 0},
    {{0, 1, 0, 1, 0, 0, 0, 0}, {56, 55, 54, 57}, 0, 1, 0},
    {{0, 0, 0, 1, 0, 1, 0, 0}, {57, 56, 55, 54}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 1, 0, 1}, {54, 57, 56, 55}, 0, 1, 0},
    {{0, 1, 0, 0, 0, 0, 0, 1}, {55, 54, 57, 56}, 0, 1, 0},
    {{0, 1, 0, 0, 0, 0, 0, 0}, {52, 51, 50, 53}, 0, 1, 0},
    {{0, 0, 0, 1, 0, 0, 0, 0}, {53, 52, 51, 50}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 1, 0, 0}, {50, 53, 52, 51}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 0, 0, 1}, {51, 50, 53, 52}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0}, 0, 6, 0},
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0}, 0, 0, 0},
};

static struct terrain_image_context terrain_images_wall[48] = {
    {{1, 2, 1, 2, 1, 2, 1, 2}, {26, 26, 26, 26}, 0, 1, 0},
    {{1, 2, 1, 2, 1, 2, 0, 2}, {15, 10, 5, 16}, 0, 1, 0},
    {{0, 2, 1, 2, 1, 2, 1, 2}, {16, 15, 10, 5}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 2, 1, 2}, {5, 16, 15, 10}, 0, 1, 0},
    {{1, 2, 1, 2, 0, 2, 1, 2}, {10, 5, 16, 15}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 2, 0, 2}, {1, 4, 1, 4}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 2, 1, 2}, {4, 1, 4, 1}, 0, 1, 0},
    {{1, 2, 1, 2, 0, 0, 0, 2}, {10, 7, 5, 12}, 0, 1, 0},
    {{0, 2, 1, 2, 1, 2, 0, 0}, {12, 10, 7, 5}, 0, 1, 0},
    {{0, 0, 0, 2, 1, 2, 1, 2}, {5, 12, 10, 7}, 0, 1, 0},
    {{1, 2, 0, 0, 0, 2, 1, 2}, {7, 5, 12, 10}, 0, 1, 0},
    {{1, 2, 1, 2, 0, 1, 0, 2}, {10, 22, 5, 12}, 0, 1, 0},
    {{0, 2, 1, 2, 1, 2, 0, 1}, {12, 10, 22, 5}, 0, 1, 0},
    {{0, 1, 0, 2, 1, 2, 1, 2}, {5, 12, 10, 22}, 0, 1, 0},
    {{1, 2, 0, 1, 0, 2, 1, 2}, {22, 5, 12, 10}, 0, 1, 0},
    {{1, 2, 0, 0, 0, 0, 0, 2}, {3, 2, 1, 4}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 0, 0, 0}, {4, 3, 2, 1}, 0, 1, 0},
    {{0, 0, 0, 2, 1, 2, 0, 0}, {1, 4, 3, 2}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 2, 1, 2}, {2, 1, 4, 3}, 0, 1, 0},
    {{1, 2, 0, 1, 0, 0, 0, 2}, {22, 24, 1, 4}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 1, 0, 0}, {4, 22, 24, 1}, 0, 1, 0},
    {{0, 0, 0, 2, 1, 2, 0, 1}, {1, 4, 22, 24}, 0, 1, 0},
    {{0, 1, 0, 0, 0, 2, 1, 2}, {24, 1, 4, 22}, 0, 1, 0},
    {{1, 2, 0, 0, 0, 1, 0, 2}, {25, 22, 1, 4}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 0, 0, 1}, {4, 25, 22, 1}, 0, 1, 0},
    {{0, 1, 0, 2, 1, 2, 0, 0}, {1, 4, 25, 22}, 0, 1, 0},
    {{0, 0, 0, 1, 0, 2, 1, 2}, {22, 1, 4, 25}, 0, 1, 0},
    {{1, 2, 0, 1, 0, 1, 0, 2}, {22, 22, 1, 4}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 1, 0, 1}, {4, 22, 22, 1}, 0, 1, 0},
    {{0, 1, 0, 2, 1, 2, 0, 1}, {1, 4, 22, 22}, 0, 1, 0},
    {{0, 1, 0, 1, 0, 2, 1, 2}, {22, 1, 4, 22}, 0, 1, 0},
    {{0, 1, 0, 1, 0, 1, 0, 1}, {22, 22, 22, 22}, 0, 1, 0},
    {{0, 1, 0, 1, 0, 1, 0, 0}, {22, 22, 23, 22}, 0, 1, 0},
    {{0, 0, 0, 1, 0, 1, 0, 1}, {22, 22, 22, 23}, 0, 1, 0},
    {{0, 1, 0, 0, 0, 1, 0, 1}, {23, 22, 22, 22}, 0, 1, 0},
    {{0, 1, 0, 1, 0, 0, 0, 1}, {22, 23, 22, 22}, 0, 1, 0},
    {{0, 1, 0, 0, 0, 1, 0, 0}, {17, 18, 17, 18}, 0, 1, 0},
    {{0, 0, 0, 1, 0, 0, 0, 1}, {18, 17, 18, 17}, 0, 1, 0},
    {{0, 1, 0, 1, 0, 0, 0, 0}, {22, 21, 19, 22}, 0, 1, 0},
    {{0, 0, 0, 1, 0, 1, 0, 0}, {22, 22, 21, 19}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 1, 0, 1}, {19, 22, 22, 21}, 0, 1, 0},
    {{0, 1, 0, 0, 0, 0, 0, 1}, {21, 19, 22, 22}, 0, 1, 0},
    {{0, 1, 0, 0, 0, 0, 0, 0}, {21, 20, 19, 22}, 0, 1, 0},
    {{0, 0, 0, 1, 0, 0, 0, 0}, {22, 21, 20, 19}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 1, 0, 0}, {19, 22, 21, 20}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 0, 0, 1}, {20, 19, 22, 21}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0}, 0, 0, 0},
};

static struct terrain_image_context terrain_images_wall_gatehouse[10] = {
    {{1, 2, 0, 2, 0, 2, 0, 2}, {16, 15, 10, 5}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 2, 0, 2}, {5, 16, 15, 10}, 0, 1, 0},
    {{0, 2, 0, 2, 1, 2, 0, 2}, {10, 5, 16, 15}, 0, 1, 0},
    {{0, 2, 0, 2, 0, 2, 1, 2}, {15, 10, 5, 16}, 0, 1, 0},
    {{1, 2, 1, 2, 0, 2, 0, 2}, {27, 12, 28, 22}, 0, 1, 0},
    {{0, 2, 1, 2, 1, 2, 0, 2}, {22, 27, 12, 28}, 0, 1, 0},
    {{0, 2, 0, 2, 1, 2, 1, 2}, {28, 22, 27, 12}, 0, 1, 0},
    {{1, 2, 0, 2, 0, 2, 1, 2}, {12, 28, 22, 27}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 2, 0, 2}, {31, 32, 31, 32}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 2, 1, 2}, {32, 31, 32, 31}, 0, 1, 0},
};

static struct terrain_image_context terrain_images_elevation[14] = {
    {{1, 1, 1, 1, 1, 1, 1, 1}, {44, 44, 44, 44}, 2, 1, 0},
    {{1, 1, 1, 1, 1, 0, 1, 1}, {30, 18, 28, 22}, 4, 2, 0},
    {{1, 1, 1, 1, 1, 1, 1, 0}, {22, 30, 18, 28}, 4, 2, 0},
    {{1, 0, 1, 1, 1, 1, 1, 1}, {28, 22, 30, 18}, 4, 2, 0},
    {{1, 1, 1, 0, 1, 1, 1, 1}, {18, 28, 22, 30}, 4, 2, 0},
    {{1, 1, 1, 2, 2, 2, 1, 1}, {0, 8, 12, 4}, 4, 4, 0},
    {{1, 1, 1, 1, 1, 2, 2, 2}, {4, 0, 8, 12}, 4, 4, 0},
    {{2, 2, 1, 1, 1, 1, 1, 2}, {12, 4, 0, 8}, 4, 4, 0},
    {{1, 2, 2, 2, 1, 1, 1, 1}, {8, 12, 4, 0}, 4, 4, 0},
    {{1, 1, 1, 2, 2, 2, 2, 2}, {24, 16, 26, 20}, 4, 2, 0},
    {{2, 2, 1, 1, 1, 2, 2, 2}, {20, 24, 16, 26}, 4, 2, 0},
    {{2, 2, 2, 2, 1, 1, 1, 2}, {26, 20, 24, 16}, 4, 2, 0},
    {{1, 2, 2, 2, 2, 2, 1, 1}, {16, 26, 20, 24}, 4, 2, 0},
    {{2, 2, 2, 2, 2, 2, 2, 2}, {32, 32, 32, 32}, 4, 4, 0},
};

static struct terrain_image_context terrain_images_earthquake[17] = {
    {{1, 2, 1, 2, 1, 2, 1, 2}, {29, 29, 29, 29}, 0, 1, 0},
    {{1, 2, 1, 2, 1, 2, 0, 2}, {25, 28, 27, 26}, 0, 1, 0},
    {{0, 2, 1, 2, 1, 2, 1, 2}, {26, 25, 28, 27}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 2, 1, 2}, {27, 26, 25, 28}, 0, 1, 0},
    {{1, 2, 1, 2, 0, 2, 1, 2}, {28, 27, 26, 25}, 0, 1, 0},
    {{1, 2, 1, 2, 0, 2, 0, 2}, {8, 14, 12, 10}, 0, 2, 0},
    {{0, 2, 1, 2, 1, 2, 0, 2}, {10, 8, 14, 12}, 0, 2, 0},
    {{0, 2, 0, 2, 1, 2, 1, 2}, {12, 10, 8, 14}, 0, 2, 0},
    {{1, 2, 0, 2, 0, 2, 1, 2}, {14, 12, 10, 8}, 0, 2, 0},
    {{1, 2, 0, 2, 1, 2, 0, 2}, {0, 4, 0, 4}, 0, 4, 0},
    {{0, 2, 1, 2, 0, 2, 1, 2}, {4, 0, 4, 0}, 0, 4, 0},
    {{1, 2, 0, 2, 0, 2, 0, 2}, {16, 22, 18, 20}, 0, 2, 0},
    {{0, 2, 1, 2, 0, 2, 0, 2}, {20, 16, 22, 18}, 0, 2, 0},
    {{0, 2, 0, 2, 1, 2, 0, 2}, {18, 20, 16, 22}, 0, 2, 0},
    {{0, 2, 0, 2, 0, 2, 1, 2}, {22, 18, 20, 16}, 0, 2, 0},
    {{0, 2, 0, 2, 0, 2, 0, 2}, {24, 24, 24, 24}, 0, 1, 0},
    {{2, 2, 2, 2, 2, 2, 2, 2}, {24, 24, 24, 24}, 0, 1, 0},
};

static struct terrain_image_context terrain_images_dirt_road[17] = {
    {{1, 2, 1, 2, 1, 2, 1, 2}, {17, 17, 17, 17}, 0, 1, 0},
    {{1, 2, 1, 2, 1, 2, 0, 2}, {13, 16, 15, 14}, 0, 1, 0},
    {{0, 2, 1, 2, 1, 2, 1, 2}, {14, 13, 16, 15}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 2, 1, 2}, {15, 14, 13, 16}, 0, 1, 0},
    {{1, 2, 1, 2, 0, 2, 1, 2}, {16, 15, 14, 13}, 0, 1, 0},
    {{1, 2, 1, 2, 0, 2, 0, 2}, {4, 7, 6, 5}, 0, 1, 0},
    {{0, 2, 1, 2, 1, 2, 0, 2}, {5, 4, 7, 6}, 0, 1, 0},
    {{0, 2, 0, 2, 1, 2, 1, 2}, {6, 5, 4, 7}, 0, 1, 0},
    {{1, 2, 0, 2, 0, 2, 1, 2}, {7, 6, 5, 4}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 2, 0, 2}, {0, 1, 0, 1}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 2, 1, 2}, {1, 0, 1, 0}, 0, 1, 0},
    {{1, 2, 0, 2, 0, 2, 0, 2}, {8, 11, 10, 9}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 2, 0, 2}, {9, 8, 11, 10}, 0, 1, 0},
    {{0, 2, 0, 2, 1, 2, 0, 2}, {10, 9, 8, 11}, 0, 1, 0},
    {{0, 2, 0, 2, 0, 2, 1, 2}, {11, 10, 9, 8}, 0, 1, 0},
    {{0, 2, 0, 2, 0, 2, 0, 2}, {12, 12, 12, 12}, 0, 1, 0},
    {{2, 2, 2, 2, 2, 2, 2, 2}, {12, 12, 12, 12}, 0, 1, 0},
};

static struct terrain_image_context terrain_images_paved_road[48] = {
    {{1, 0, 1, 0, 1, 0, 1, 0}, {17, 17, 17, 17}, 0, 1, 0},
    {{1, 0, 1, 0, 1, 2, 0, 2}, {13, 16, 15, 14}, 0, 1, 0},
    {{1, 1, 1, 1, 1, 2, 0, 2}, {18, 21, 20, 19}, 0, 1, 0},
    {{1, 0, 1, 1, 1, 2, 0, 2}, {26, 33, 32, 31}, 0, 1, 0},
    {{1, 1, 1, 0, 1, 2, 0, 2}, {30, 29, 28, 27}, 0, 1, 0},
    {{0, 2, 1, 0, 1, 0, 1, 2}, {14, 13, 16, 15}, 0, 1, 0},
    {{0, 2, 1, 1, 1, 1, 1, 2}, {19, 18, 21, 20}, 0, 1, 0},
    {{0, 2, 1, 0, 1, 1, 1, 2}, {31, 26, 33, 32}, 0, 1, 0},
    {{0, 2, 1, 1, 1, 0, 1, 2}, {27, 30, 29, 28}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 0, 1, 0}, {15, 14, 13, 16}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 1, 1, 1}, {20, 19, 18, 21}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 0, 1, 1}, {32, 31, 26, 33}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 1, 1, 0}, {28, 27, 30, 29}, 0, 1, 0},
    {{1, 0, 1, 2, 0, 2, 1, 0}, {16, 15, 14, 13}, 0, 1, 0},
    {{1, 1, 1, 2, 0, 2, 1, 1}, {21, 20, 19, 18}, 0, 1, 0},
    {{1, 1, 1, 2, 0, 2, 1, 0}, {33, 32, 31, 26}, 0, 1, 0},
    {{1, 0, 1, 2, 0, 2, 1, 1}, {29, 28, 27, 30}, 0, 1, 0},
    {{1, 1, 1, 2, 0, 0, 0, 2}, {22, 25, 24, 23}, 0, 1, 0},
    {{0, 2, 1, 1, 1, 2, 0, 0}, {23, 22, 25, 24}, 0, 1, 0},
    {{0, 0, 0, 2, 1, 1, 1, 2}, {24, 23, 22, 25}, 0, 1, 0},
    {{1, 2, 0, 0, 0, 2, 1, 1}, {25, 24, 23, 22}, 0, 1, 0},
    {{1, 0, 1, 0, 1, 1, 1, 1}, {34, 37, 36, 35}, 0, 1, 0},
    {{1, 1, 1, 0, 1, 0, 1, 1}, {35, 34, 37, 36}, 0, 1, 0},
    {{1, 1, 1, 1, 1, 0, 1, 0}, {36, 35, 34, 37}, 0, 1, 0},
    {{1, 0, 1, 1, 1, 1, 1, 0}, {37, 36, 35, 34}, 0, 1, 0},
    {{1, 0, 1, 0, 1, 0, 1, 1}, {38, 41, 40, 39}, 0, 1, 0},
    {{1, 1, 1, 0, 1, 0, 1, 0}, {39, 38, 41, 40}, 0, 1, 0},
    {{1, 0, 1, 1, 1, 0, 1, 0}, {40, 39, 38, 41}, 0, 1, 0},
    {{1, 0, 1, 0, 1, 1, 1, 0}, {41, 40, 39, 38}, 0, 1, 0},
    {{1, 1, 1, 1, 1, 0, 1, 1}, {42, 45, 44, 43}, 0, 1, 0},
    {{1, 1, 1, 1, 1, 1, 1, 0}, {43, 42, 45, 44}, 0, 1, 0},
    {{1, 0, 1, 1, 1, 1, 1, 1}, {44, 43, 42, 45}, 0, 1, 0},
    {{1, 1, 1, 0, 1, 1, 1, 1}, {45, 44, 43, 42}, 0, 1, 0},
    {{1, 1, 1, 0, 1, 1, 1, 0}, {46, 47, 46, 47}, 0, 1, 0},
    {{1, 0, 1, 1, 1, 0, 1, 1}, {47, 46, 47, 46}, 0, 1, 0},
    {{1, 2, 1, 2, 0, 2, 0, 2}, {4, 7, 6, 5}, 0, 1, 0},
    {{0, 2, 1, 2, 1, 2, 0, 2}, {5, 4, 7, 6}, 0, 1, 0},
    {{0, 2, 0, 2, 1, 2, 1, 2}, {6, 5, 4, 7}, 0, 1, 0},
    {{1, 2, 0, 2, 0, 2, 1, 2}, {7, 6, 5, 4}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 2, 0, 2}, {0, 1, 0, 1}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 2, 1, 2}, {1, 0, 1, 0}, 0, 1, 0},
    {{1, 2, 0, 2, 0, 2, 0, 2}, {8, 11, 10, 9}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 2, 0, 2}, {9, 8, 11, 10}, 0, 1, 0},
    {{0, 2, 0, 2, 1, 2, 0, 2}, {10, 9, 8, 11}, 0, 1, 0},
    {{0, 2, 0, 2, 0, 2, 1, 2}, {11, 10, 9, 8}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 0, 0, 0}, {12, 12, 12, 12}, 0, 1, 0},
    {{1, 1, 1, 1, 1, 1, 1, 1}, {48, 48, 48, 48}, 0, 1, 0},
    {{2, 2, 2, 2, 2, 2, 2, 2}, {12, 12, 12, 12}, 0, 1, 0},
};

static struct terrain_image_context terrain_images_aqueduct[16] = {
    {{1, 2, 1, 2, 0, 2, 0, 2}, {4, 7, 6, 5}, 7, 1, 0},
    {{0, 2, 1, 2, 1, 2, 0, 2}, {5, 4, 7, 6}, 8, 1, 0},
    {{0, 2, 0, 2, 1, 2, 1, 2}, {6, 5, 4, 7}, 9, 1, 0},
    {{1, 2, 0, 2, 0, 2, 1, 2}, {7, 6, 5, 4}, 10, 1, 0},
    {{1, 2, 0, 2, 1, 2, 0, 2}, {2, 3, 2, 3}, 5, 1, 0},
    {{0, 2, 1, 2, 0, 2, 1, 2}, {3, 2, 3, 2}, 6, 1, 0},
    {{1, 2, 0, 2, 0, 2, 0, 2}, {2, 3, 2, 3}, 1, 1, 0},
    {{0, 2, 1, 2, 0, 2, 0, 2}, {3, 2, 3, 2}, 2, 1, 0},
    {{0, 2, 0, 2, 1, 2, 0, 2}, {2, 3, 2, 3}, 3, 1, 0},
    {{0, 2, 0, 2, 0, 2, 1, 2}, {3, 2, 3, 2}, 4, 1, 0},
    {{1, 2, 1, 2, 1, 2, 0, 2}, {10, 13, 12, 11}, 11, 1, 0},
    {{0, 2, 1, 2, 1, 2, 1, 2}, {11, 10, 13, 12}, 12, 1, 0},
    {{1, 2, 0, 2, 1, 2, 1, 2}, {12, 11, 10, 13}, 13, 1, 0},
    {{1, 2, 1, 2, 0, 2, 1, 2}, {13, 12, 11, 10}, 14, 1, 0},
    {{1, 2, 1, 2, 1, 2, 1, 2}, {14, 14, 14, 14}, 15, 1, 0},
    {{2, 2, 2, 2, 2, 2, 2, 2}, {2, 2, 2, 2}, 0, 1, 0},
};

static struct {
    struct terrain_image_context *context;
    int size;
} context_pointers[] = {
    {terrain_images_water, 48},
    {terrain_images_wall, 48},
    {terrain_images_wall_gatehouse, 10},
    {terrain_images_elevation, 14},
    {terrain_images_earthquake, 17},
    {terrain_images_dirt_road, 17},
    {terrain_images_paved_road, 48},
    {terrain_images_aqueduct, 16}
};

static struct {
    int end_grid_offset;
    int length;
    int direction;
    int direction_grid_delta;
} bridge;

struct ring_tile_t {
    int x;
    int y;
    int grid_offset;
};

static struct {
    struct ring_tile_t tiles[1080];
    int index[6][7];
} desirability_data;

struct key_t {
    int state;
    int value;
    uint32_t last_change;
};

static struct {
    int is_scrolling;
    int constant_input;
    struct {
        struct key_t up;
        struct key_t down;
        struct key_t left;
        struct key_t right;
    } arrow_key;
    struct {
        int active;
        int has_started;
        struct pixel_view_coordinates_t delta;
    } drag;
    struct {
        struct speed_type_t x;
        struct speed_type_t y;
        float modifier_x;
        float modifier_y;
    } speed;
    int x_align_direction;
    int y_align_direction;
    uint32_t last_time;
    struct {
        int active;
        int x;
        int y;
        int width;
        int height;
    } limits;
} scroll_data;

struct modifier_name_t {
    int modifier;
    char *name;
};
static struct modifier_name_t modifier_names[] = {
    {KEY_MOD_CTRL, "Ctrl"},
    {KEY_MOD_ALT, "Alt"},
    {KEY_MOD_GUI, "Gui"},
    {KEY_MOD_SHIFT, "Shift"},
    {KEY_MOD_NONE, 0}
};

static struct cursor_t ARROW[] = {
    {
        0, 0, 13, 21,
        "#            "
        "##           "
        "#'#          "
        "#''#         "
        "#'''#        "
        "#''''#       "
        "#'''''#      "
        "#''''''#     "
        "#'''''''#    "
        "#''''''''#   "
        "#'''''''''#  "
        "#''''''''''# "
        "#''''''######"
        "#'''#''#     "
        "#''# #''#    "
        "#'#  #''#    "
        "##    #''#   "
        "#     #''#   "
        "       #''#  "
        "       #''#  "
        "        ##   "
    },
    {
        0, 0, 18, 30,
        "#                 "
        "##                "
        "#&#               "
        "#'&#              "
        "#''&#             "
        "#'''&#            "
        "#''''&#           "
        "#'''''&#          "
        "#''''''&#         "
        "#'''''''&#        "
        "#''''''''&#       "
        "#'''''''''&#      "
        "#''''''''''&#     "
        "#'''''''''''&#    "
        "#''''''''''''&#   "
        "#'''''''''''''&#  "
        "#''''''''''''''&# "
        "#'''''''''''''''$#"
        "#'''''''&#########"
        "#''''$%''$        "
        "#'''$##&'&#       "
        "#''$#  $''%#      "
        "#&#    #&''#      "
        "##      #''%#     "
        "#       #%''#     "
        "         #''&#    "
        "         #%''$    "
        "          #&'&#   "
        "           $'&#   "
        "           ###    "
    },
    {
        0, 0, 24, 40,
        "#                       "
        "##                      "
        "#&#                     "
        "#'&#                    "
        "#''&#                   "
        "#'''&#                  "
        "#''''&#                 "
        "#'''''&#                "
        "#''''''&#               "
        "#'''''''&#              "
        "#''''''''&#             "
        "#'''''''''&#            "
        "#''''''''''&#           "
        "#'''''''''''&#          "
        "#''''''''''''&#         "
        "#'''''''''''''&#        "
        "#''''''''''''''&#       "
        "#'''''''''''''''&#      "
        "#''''''''''''''''&#     "
        "#'''''''''''''''''&#    "
        "#''''''''''''''''''&#   "
        "#'''''''''''''''''''&#  "
        "#''''''''''''''''''''&# "
        "#'''''''''''''''''''''&#"
        "#''''''''''&############"
        "#''''''&&'''$           "
        "#'''''&##'''&#          "
        "#''''&# #%'''%#         "
        "#''''#   #''''#         "
        "#'''#    #%'''%#        "
        "#''#      #&'''#        "
        "#'$#       $'''&#       "
        "#$#        #&'''$       "
        "##          #'''&#      "
        "#           #%'''%#     "
        "             #''''#     "
        "             #%'''%#    "
        "              #&'''#    "
        "               $'&$#    "
        "               ###      "
    }
};

static struct cursor_t SWORD[] = {
    {
        0, 0, 22, 22,
        "#####                 "
        "#'''##                "
        "#''''##               "
        "#'''''##              "
        "##'''''##             "
        " ##'''''##            "
        "  ##'''''##           "
        "   ##'''''##          "
        "    ##'''''##         "
        "     ##'''''##        "
        "      ##'''''##       "
        "       ##'''''##      "
        "        ##'''''#####  "
        "         ##'''''#''#  "
        "          ##'''#'''#  "
        "           ##'#'''##  "
        "            ##'''###  "
        "            #'''##'###"
        "            #''##''''#"
        "            ######'''#"
        "                 #''##"
        "                 #### "
    },
    {
        0, 0, 34, 34,
        "######                            "
        "#%&&&##                           "
        "#&'''&##                          "
        "#&''''&##                         "
        "#&'''''&##                        "
        "##&'''''&##                       "
        " ##&'''''&##                      "
        "  ##&'''''&##                     "
        "   ##&'''''&##                    "
        "    ##&'''''&##                   "
        "     ##&'''''&##                  "
        "      ##&'''''&##                 "
        "       ##&'''''&##                "
        "        ##&'''''&##               "
        "         ##&'''''&##              "
        "          ##&'''''&##             "
        "           ##&'''''&##            "
        "            ##&'''''&##           "
        "             ##&'''''&##          "
        "              ##&'''''&########   "
        "               ##&''''''&##&&$#   "
        "                ##&''''&##&''$#   "
        "                 ##&''&##&''&##   "
        "                  ##%&##&''&###   "
        "                   #&##&''&####   "
        "                   ###&''&#####   "
        "                   ##&''&###%$### "
        "                   #&''&###%'%$$##"
        "                   #&'&###%'''''$#"
        "                   #$$####$%''''$#"
        "                   ########$'''&##"
        "                          #$''&#  "
        "                          ##$$##  "
        "                           ####   "
    },
    {
        0, 0, 46, 44,
        "########                                      "
        "#%%%%%%##                                     "
        "#%'''''&##                                    "
        "#%''''''&##                                   "
        "#%'''''''%##                                  "
        "#%''''''''%##                                 "
        "#%'''''''''%##                                "
        "##%'''''''''%##                               "
        " ##%'''''''''%##                              "
        "  ##%'''''''''%##                             "
        "   ##%'''''''''%##                            "
        "    ##%'''''''''%##                           "
        "     ##%'''''''''%##                          "
        "      ##%'''''''''%##                         "
        "       ##%'''''''''%##                        "
        "        ##%'''''''''%##                       "
        "         ##%'''''''''%##                      "
        "          ##%'''''''''%##                     "
        "           ##%'''''''''%##                    "
        "            ##%'''''''''%##                   "
        "             ##%'''''''''%##                  "
        "              ##%'''''''''%##                 "
        "               ##%'''''''''%##                "
        "                ##%'''''''''%##               "
        "                 ##%'''''''''%##              "
        "                  ##%'''''''''%##########     "
        "                   ##%'''''''''%$$##$$$##     "
        "                    ##%''''''''''%#%'''$#     "
        "                     ##%''''''''%#%''''$#     "
        "                      ##%''''''%#%'''''$#     "
        "                       ##%''''%#%'''''%##     "
        "                        ##%''%#%'''''%###     "
        "                         #$'%#%'''''%####     "
        "                         #$%#%'''''%#####     "
        "                         ###%'''''%###%$#     "
        "                         ##%'''''%###%'$####  "
        "                         #$'''''%###%''%$$$## "
        "                         #$''''%###%'''''''$##"
        "                         #$'''%###%''''''''$##"
        "                         ##$$$####$$%'''''''$#"
        "                         ###########$''''$####"
        "                                   #$'''$&#   "
        "                                    #$''$#    "
        "                                     #####    "
    }
};

static struct cursor_t SHOVEL[] = {
    {
        1, 26, 28, 28,
        "                       ##   "
        "                      ####  "
        "                     ##'### "
        "                     #'''###"
        "                     ##'''##"
        "                    ####'## "
        "                   ##'####  "
        "                  ##'##     "
        "                 ##'##      "
        "                ##'##       "
        "               ##'##        "
        "              ##'##         "
        "             ##'##          "
        "       #    ##'##           "
        "      #### ##'##            "
        "     #''####'##             "
        "    #''''##'##              "
        "   #''''##'##               "
        "  #''''#'#####              "
        " #''''#'''#'##              "
        " #'''#'''#'''##             "
        "#'''''''#''''#              "
        "#''''''#''''#               "
        "#''''''''''#                "
        "#'''''''''#                 "
        "#''''''''#                  "
        " #'''''##                   "
        "  #####                     "
    },
    {
        2, 39, 44, 41,
        "                                   ####     "
        "                                 #######    "
        "                                ##%&#####   "
        "                               ##&''$#####  "
        "                               #$'''''$#### "
        "                               #$''''''$####"
        "                               ##&''''''%## "
        "                              ####&''''$##  "
        "                             ##$''##&&&$#   "
        "                            ##$'''$#####    "
        "                           ##$'''$##        "
        "                          ##$'''$##         "
        "                         ##$'''$##          "
        "                        ##$'''$##           "
        "                       ##$'''$##            "
        "                      ##$'''$##             "
        "                     ##$'''$##              "
        "                    ##$'''$##               "
        "         ###       ##$'''$##                "
        "        ##$##     ##$'''$##                 "
        "       ##%'%##   ##$'''$##                  "
        "      ##%'''%## ##$'''$##                   "
        "     ##%'''''%##%''''$##                    "
        "    ##%''''''%#$''''$##                     "
        "   ##%''''''%#$''''$##                      "
        "  ##%''''''%#$#%''$##                       "
        "  #$''''''%#%'%#$###                        "
        "  #&'''''%#%'''$#%%##                       "
        " ##'''''%#%'''%#%''%##                      "
        " #$''''%#%'''%#%''''%##                     "
        " #&''''%%'''%#%''''''$#                     "
        " #&''''''''%#%''''''%##                     "
        "##''''''''%#%''''''%##                      "
        "#$''''''''%%''''''%##                       "
        "#$'''''''''''''''%##                        "
        "#$''''''''''''''%##                         "
        "#$'''''''''''''%##                          "
        "##'''''''''''&$##                           "
        " #%''''''''&$###                            "
        " ##%&''&%$###                               "
        "  #########                                 "
    },
    {
        3, 52, 58, 55,
        "                                               ##         "
        "                                             ######       "
        "                                            ###&#####     "
        "                                           ##$''&#####    "
        "                                          ##$''''&#####   "
        "                                         ##$'''''''$####  "
        "                                         ##$''''''''$#### "
        "                                         ##$'''''''''$####"
        "                                         ##$''''''''''$###"
        "                                         ###%'''''''''$## "
        "                                        ##%%#%''''''&##   "
        "                                       ##&''%#%''''&##    "
        "                                      ##&''''%#$$$$##     "
        "                                     ##&''''%#######      "
        "                                    ##&''''&###           "
        "                                   ##&''''&##             "
        "                                  ##&''''&##              "
        "                                 ##&''''&##               "
        "                                ##&''''&##                "
        "                               ##&''''&##                 "
        "                              ##&''''&##                  "
        "                             ##&''''&##                   "
        "                            ##&''''&##                    "
        "                           ##&''''&##                     "
        "             ##           ##&''''&##                      "
        "            ####         ##&''''&##                       "
        "           ##%%##       ##&''''&##                        "
        "          ##%''%##     ##&''''&##                         "
        "         ##%''''%##   ##&''''&##                          "
        "        ##%''''''%## ##%''''&##                           "
        "       ##%''''''''%##%'''''&##                            "
        "      ##%'''''''''%#$'''''&##                             "
        "     ##%'''''''''%#%'''''&##                              "
        "    ##%'''''''''%##%''''%##                               "
        "   ##%'''''''''%#%%#%''$##                                "
        "   #$'''''''''%#%''%#%%###                                "
        "   #&''''''''%#%''''%##%%##                               "
        "  ##''''''''%#%'''''%#%''%##                              "
        "  #%'''''''%#%'''''%#%''''%##                             "
        "  #&''''''%#%'''''%#%''''''%##                            "
        "  #''''''&#%'''''%#%''''''''%##                           "
        " #$'''''''&'''''%#%'''''''''%##                           "
        " #%''''''''''''%#%'''''''''%##                            "
        " #&'''''''''''%#%'''''''''%##                             "
        " #&''''''''''&#%'''''''''%##                              "
        " #''''''''''''&'''''''''%##                               "
        " #'''''''''''''''''''''%##                                "
        "##''''''''''''''''''''%##                                 "
        " #'''''''''''''''''''%##                                  "
        " #&'''''''''''''''''%##                                   "
        " #&'''''''''''''''&$##                                    "
        " #$'''''''''''''&$###                                     "
        "  #%'''''''''&%###                                        "
        "   #$%&&&&%$####                                          "
        "    #########                                             "
    }
};

struct hotkey_definition_t {
    int *action;
    int value;
    int key;
    int modifiers;
    int repeatable;
};

struct arrow_definition_t {
    void (*action)(int is_down);
    int key;
};

struct global_hotkeys_t {
    int toggle_fullscreen;
    int reset_window;
    int save_screenshot;
    int save_city_screenshot;
};

static struct {
    struct global_hotkeys_t global_hotkey_state;
    struct hotkeys_t hotkey_state;
    struct hotkey_definition_t *definitions;
    int num_definitions;
    struct arrow_definition_t *arrows;
    int num_arrows;
} hotkey_data;

static struct {
    int capture;
    int accepted;
    int capture_numeric;
    void (*capture_numeric_callback)(int);
    char *text;
    int cursor_position;
    int length;
    int max_length;
    int allow_punctuation;
    int viewport_start;
    int viewport_end;
    int viewport_cursor_position;
    int box_width;
    int font;
} keyboard_data;

static struct {
    int capture;
    int seen;
    int position;
    int cursor_position;
    int width;
    int x_offset;
    int y_offset;
    int text_offset_start;
    int text_offset_end;
} input_cursor;

static struct {
    char string[ELLIPSIS_LENGTH];
    int width[FONT_TYPES_MAX];
} ellipsis = { {'.', '.', '.', 0}, {0} };

static struct {
    int is_playing;
    int is_ended;
    smacker s;
    struct {
        int width;
        int height;
        int y_scale;
        int micros_per_frame;
        uint32_t start_render_millis;
        int current_frame;
    } video;
    struct {
        int has_audio;
        int bitdepth;
        int channels;
        int rate;
    } audio;
    int restart_music;
} data_video;

static struct {
    struct window_type_t window_queue[MAX_WINDOW_QUEUE];
    int queue_index;
    struct window_type_t *current_window;
    int refresh_immediate;
    int refresh_on_draw;
    int underlying_windows_redrawing;
} window_data;

static struct {
    int width;
    int height;
    int scanline_size;
    uint8_t *pixels;
} bmp_chunk;

static struct {
    struct font_definition_t *normal_font;
    struct font_definition_t *link_font;
    int line_height;
    int paragraph_indent;
    int x_text;
    int y_text;
    int text_width_blocks;
    int text_height_blocks;
    int text_height_lines;
    int num_lines;
    int max_scroll_position;
    int num_links;
} rich_text_data;

static struct {
    int width;
    int height;
    struct {
        int x;
        int y;
    } dialog_offset;
} screen_data;

static struct {
    int message_id;
    int x_min;
    int y_min;
    int x_max;
    int y_max;
} links[MAX_LINKS];

static struct {
    char *font_mapping;
    struct font_definition_t *font_definitions;
} font_data;

static struct {
    color_t *pixels;
    int width;
    int height;
} canvas;

static struct {
    int x_start;
    int x_end;
    int y_start;
    int y_end;
} clip_rectangle = { 0, 800, 0, 600 };

static struct {
    int x;
    int y;
} translation;

static struct {
    int group;
    int offset;
    int num_types;
} HOUSE_IMAGE[20] = {
    {GROUP_BUILDING_HOUSE_TENT, 0, 2}, {GROUP_BUILDING_HOUSE_TENT, 2, 2},
    {GROUP_BUILDING_HOUSE_SHACK, 0, 2}, {GROUP_BUILDING_HOUSE_SHACK, 2, 2},
    {GROUP_BUILDING_HOUSE_HOVEL, 0, 2}, {GROUP_BUILDING_HOUSE_HOVEL, 2, 2},
    {GROUP_BUILDING_HOUSE_CASA, 0, 2}, {GROUP_BUILDING_HOUSE_CASA, 2, 2},
    {GROUP_BUILDING_HOUSE_INSULA_1, 0, 2}, {GROUP_BUILDING_HOUSE_INSULA_1, 2, 2},
    {GROUP_BUILDING_HOUSE_INSULA_2, 0, 2}, {GROUP_BUILDING_HOUSE_INSULA_2, 2, 2},
    {GROUP_BUILDING_HOUSE_VILLA_1, 0, 2}, {GROUP_BUILDING_HOUSE_VILLA_1, 2, 2},
    {GROUP_BUILDING_HOUSE_VILLA_2, 0, 1}, {GROUP_BUILDING_HOUSE_VILLA_2, 1, 1},
    {GROUP_BUILDING_HOUSE_PALACE_1, 0, 1}, {GROUP_BUILDING_HOUSE_PALACE_1, 1, 1},
    {GROUP_BUILDING_HOUSE_PALACE_2, 0, 1}, {GROUP_BUILDING_HOUSE_PALACE_2, 1, 1},
};

static struct {
    int tick; // 50 ticks in a day
    int day; // 16 days in a month
    int month; // 12 months in a year
    int year;
    int total_days;
} time_data;

static struct {
    int available;
    int ready;
    int timeout_ticks;
    int building_cost;
    int num_buildings;
    int type;
    struct building_t buildings[MAX_UNDO_BUILDINGS];
} undo_data;

static struct {
    int last_check_was_valid;
    uint32_t last_update;
} speed_data;

static struct {
    int paused;
    int current_overlay;
    int previous_overlay;
} state_data = { 0, OVERLAY_NONE, OVERLAY_NONE };

static struct {
    int x;
    int y;
    int offset;
} EXPAND_DIRECTION_DELTA[MAX_DIR] = { {0, 0, 0}, {-1, -1, -GRID_SIZE - 1}, {-1, 0, -1}, {0, -1, -GRID_SIZE} };

static struct {
    int x;
    int y;
    int inventory[INVENTORY_MAX];
    int population;
} merge_data;

static struct map_point_t SEAGULL_OFFSETS[] = {
    {0, 0}, {0, -2}, {-2, 0}, {1, 2}, {2, 0}, {-3, 1}, {4, -3}, {-2, 4}, {0, 0}
};

static struct {
    uint32_t last_update;
    int should_update;
} timers[MAX_ANIM_TIMERS];

struct file_piece_t {
    struct buffer_t buf;
};

struct scenario_state_t {
    struct buffer_t *graphic_ids;
    struct buffer_t *edge;
    struct buffer_t *terrain;
    struct buffer_t *bitfields;
    struct buffer_t *random;
    struct buffer_t *random_iv;
    struct buffer_t *camera;
    struct buffer_t *scenario;
    struct buffer_t *empire_objects;
};

static struct {
    int num_pieces;
    struct file_piece_t pieces[11];
    struct scenario_state_t state;
} scenario_data = { 0 };

struct savegame_state_t {
    struct buffer_t *image_grid;
    struct buffer_t *edge_grid;
    struct buffer_t *building_grid;
    struct buffer_t *terrain_grid;
    struct buffer_t *aqueduct_grid;
    struct buffer_t *figure_grid;
    struct buffer_t *bitfields_grid;
    struct buffer_t *sprite_grid;
    struct buffer_t *random_grid;
    struct buffer_t *desirability_grid;
    struct buffer_t *building_damage_grid;
    struct buffer_t *aqueduct_backup_grid;
    struct buffer_t *sprite_backup_grid;
    struct buffer_t *figures;
    struct buffer_t *route_figures;
    struct buffer_t *route_paths;
    struct buffer_t *legion_formations;
    struct buffer_t *herd_formations;
    struct buffer_t *enemy_formations;
    struct buffer_t *city_data;
    struct buffer_t *player_name;
    struct buffer_t *buildings;
    struct buffer_t *city_view_orientation;
    struct buffer_t *game_time;
    struct buffer_t *building_extra_highest_id_ever;
    struct buffer_t *random_iv;
    struct buffer_t *city_view_camera;
    struct buffer_t *building_count_culture1;
    struct buffer_t *city_graph_order;
    struct buffer_t *empire;
    struct buffer_t *empire_objects;
    struct buffer_t *building_count_industry;
    struct buffer_t *trade_prices;
    struct buffer_t *figure_names;
    struct buffer_t *culture_coverage;
    struct buffer_t *scenario;
    struct buffer_t *messages;
    struct buffer_t *message_extra;
    struct buffer_t *population_messages;
    struct buffer_t *message_counts;
    struct buffer_t *message_delays;
    struct buffer_t *building_list_burning_totals;
    struct buffer_t *city_sounds;
    struct buffer_t *building_extra_highest_id;
    struct buffer_t *figure_traders;
    struct buffer_t *building_list_burning;
    struct buffer_t *building_list_small;
    struct buffer_t *building_list_large;
    struct buffer_t *building_count_military;
    struct buffer_t *building_storages;
    struct buffer_t *building_count_culture2;
    struct buffer_t *building_count_support;
    struct buffer_t *building_barracks_tower_sentry;
    struct buffer_t *building_extra_sequence;
    struct buffer_t *routing_counters;
    struct buffer_t *building_count_culture3;
    struct buffer_t *building_extra_corrupt_houses;
    struct buffer_t *bookmarks;
};

static struct {
    int num_pieces;
    struct file_piece_t pieces[100];
    struct savegame_state_t state;
} savegame_data = { 0 };

struct trader {
    int32_t bought_amount;
    uint8_t bought_resources[RESOURCE_TYPES_MAX];
    int32_t sold_amount;
    uint8_t sold_resources[RESOURCE_TYPES_MAX];
};

static struct {
    struct trader traders[MAX_TRADERS];
    int next_index;
} figure_trader_data;

static struct {
    int figure_ids[MAX_ROUTES];
    uint8_t direction_paths[MAX_ROUTES][MAX_PATH_LENGTH];
} figure_route_data;

static struct {
    int32_t citizen_male;
    int32_t patrician;
    int32_t citizen_female;
    int32_t tax_collector;
    int32_t engineer;
    int32_t prefect;
    int32_t javelin_thrower;
    int32_t cavalry;
    int32_t legionary;
    int32_t actor;
    int32_t gladiator;
    int32_t lion_tamer;
    int32_t charioteer;
    int32_t barbarian;
    int32_t enemy_greek;
    int32_t enemy_egyptian;
    int32_t enemy_arabian;
    int32_t trader;
    int32_t ship;
} name_data;

static struct {
    int initial_scroll_x;
    int initial_scroll_y;
    int scroll_x;
    int scroll_y;
    struct empire_object_t *selected_object;
    int viewport_width;
    int viewport_height;
} empire_data;

static struct {
    int active;
    int type;
    int id;
    int brush_size;
    int build_in_progress;
    int start_elevation;
    struct map_tile_t start_tile;
} tool_data = { 0, TOOL_GRASS, 0, 2, 0, 0, {0} };

static struct {
    uint32_t last_water_animation_time;
    int advance_water_animation;
    int image_id_water_first;
    int image_id_water_last;
} draw_context_water;

struct bitstream_t {
    uint8_t *data;
    int length;
    int index;
    int bit_index;
};

struct huffnode8_t {
    struct huffnode8_t *b[2];
    int is_leaf;
    uint8_t value;
};

struct hufftree8_t {
    struct huffnode8_t nodes[512];
    int size;
};

struct huffnode16_t {
    struct huffnode16_t *b[2];
    int is_leaf;
    uint16_t value;
};

struct hufftree16_t {
    struct huffnode16_t *root;
    struct hufftree8_t *low;
    struct hufftree8_t *high;
    uint16_t escape_codes[3];
    struct huffnode16_t *escape_nodes[3];
};

struct frame_data_t {
    uint32_t palette[MAX_PALETTE];
    uint8_t *video;
    uint8_t *audio[MAX_TRACKS];
    int audio_len[MAX_TRACKS];
};

struct smacker_t {
    FILE *fp;
    int32_t width;
    int32_t height;
    int32_t frames;
    int32_t us_per_frame;
    int32_t flags;
    int32_t trees_size;
    int32_t audio_size[7];
    int32_t audio_rate[7];
    long frame_data_offset_in_file;
    long *frame_offsets;
    int32_t *frame_sizes;
    uint8_t *frame_types;
    struct hufftree16_t *mmap_tree;
    struct hufftree16_t *mclr_tree;
    struct hufftree16_t *full_tree;
    struct hufftree16_t *type_tree;
    struct frame_data_t frame_data;
    int32_t current_frame;
};

static struct {
    uint32_t iv1;
    uint32_t iv2;
    int8_t random1_7bit;
    int16_t random1_15bit;
    int8_t random2_7bit;
    int16_t random2_15bit;
    int pool_index;
    int32_t pool[MAX_RANDOM];
} random_data;

static struct {
    struct {
        int32_t offset;
        int32_t in_use;
    } text_entries[MAX_TEXT_ENTRIES];
    char text_data[MAX_TEXT_DATA];

    struct lang_message_t message_entries[MAX_MESSAGE_ENTRIES];
    char message_data[MAX_MESSAGE_DATA];
} lang_data;

static struct {
    int current_climate;
    int is_editor;
    int fonts_enabled;
    int font_base_offset;
    uint16_t group_image_ids[300];
    char bitmaps[100][200];
    struct image_t main[MAIN_ENTRIES];
    struct image_t enemy[ENEMY_FILES_COUNT][ENEMY_ENTRIES];
    struct image_t *font;
    color_t *main_data;
    color_t *empire_data;
    color_t *enemy_data[ENEMY_FILES_COUNT];
    color_t *font_data;
    uint8_t *tmp_data;
} image_data_s = { .current_climate = -1 };

static struct {
    struct hotkey_mapping_t default_mappings[HOTKEY_MAX_ITEMS][2];
    struct hotkey_mapping_t mappings[MAX_MAPPINGS];
    int num_mappings;
} hotkey_config_data;

static struct {
    struct resource_list_t resource_list;
    struct resource_list_t food_list;
} available;

static struct {
    int theater;
    int amphitheater;
    int colosseum;
    int hippodrome;
    int hospital;
    int school;
    int academy;
    int library;
    int religion[5];
    int oracle;
} culture_coverage;

struct warning {
    int in_use;
    uint32_t time;
    char text[MAX_TEXT];
};
static struct warning warnings[MAX_WARNINGS];

static struct {
    struct city_message_t messages[MAX_MESSAGES];
    int queue[20];
    int consecutive_message_delay;
    int next_message_sequence;
    int total_messages;
    int current_message_id;
    struct {
        int pop500;
        int pop1000;
        int pop2000;
        int pop3000;
        int pop5000;
        int pop10000;
        int pop15000;
        int pop20000;
        int pop25000;
    } population_shown;
    int message_count[MAX_MESSAGE_CATEGORIES];
    int message_delay[MAX_MESSAGE_CATEGORIES];
    uint32_t last_sound_time[MESSAGE_CAT_RIOT_COLLAPSE + 1];
    int problem_count;
    int problem_index;
    uint32_t problem_last_click_time;
    int scroll_position;
} message_data;

static struct {
    int state;
    int force_win;
} victory_data;

static struct {
    int screen_width;
    int screen_height;
    int sidebar_collapsed;
    int orientation;
    struct {
        struct pixel_view_coordinates_t tile;
        struct pixel_view_coordinates_t pixel;
    } camera;
    struct {
        int x;
        int y;
        int width_pixels;
        int height_pixels;
        int width_tiles;
        int height_tiles;
    } viewport;
    struct {
        int x_pixels;
        int y_pixels;
    } selected_tile;
} view_data;

static struct {
    int category;
    int workers;
} DEFAULT_PRIORITY[LABOR_CATEGORIES_COUNT] = {
    {LABOR_CATEGORY_ENGINEERING, 3},
    {LABOR_CATEGORY_WATER, 1},
    {LABOR_CATEGORY_PREFECTURES, 3},
    {LABOR_CATEGORY_MILITARY, 2},
    {LABOR_CATEGORY_FOOD_PRODUCTION, 4},
    {LABOR_CATEGORY_INDUSTRY_COMMERCE, 2},
    {LABOR_CATEGORY_ENTERTAINMENT, 1},
    {LABOR_CATEGORY_HEALTH_EDUCATION, 1},
    {LABOR_CATEGORY_GOVERNANCE_RELIGION, 1},
};

struct building_info_context_t {
    int x_offset;
    int y_offset;
    int width_blocks;
    int height_blocks;
    int help_id;
    int can_play_sound;
    int building_id;
    int has_road_access;
    int worker_percentage;
    int has_reservoir_pipes;
    int aqueduct_has_water;
    int formation_id;
    int formation_types;
    int barracks_soldiers_requested;
    int worst_desirability_building_id;
    int warehouse_space_text;
    int type;
    int terrain_type;
    int can_go_to_advisor;
    int rubble_building_type;
    int storage_show_special_orders;
    struct {
        int sound_id;
        int phrase_id;
        int selected_index;
        int count;
        int drawn;
        int figure_ids[7];
    } figure;
};
static struct building_info_context_t b_info_context;

static struct {
    int focus_button_id;
    int orders_focus_button_id;
    int resource_focus_button_id;
    int building_id;
} distribution_data = { 0, 0, 0, 0 };

static struct {
    color_t figure_images[7][48 * 48];
    int focus_button_id;
    struct building_info_context_t *context_for_callback;
} building_figures_data;

static struct {
    int focus_button_id;
    int return_button_id;
    struct building_info_context_t *context_for_callback;
} building_military_data;

struct record {
    int active;
    int total;
};

static struct {
    struct record buildings[BUILDING_TYPE_MAX];
    struct record industry[RESOURCE_TYPES_MAX];
} count_data;

static struct {
    int building_ids[MAX_GRANARIES];
    int num_items;
    int total_storage_wheat;
    int total_storage_vegetables;
    int total_storage_fruit;
    int total_storage_meat;
} non_getting_granaries;

static struct {
    struct {
        int size;
        int items[MAX_SMALL];
    } small;
    struct {
        int size;
        int items[MAX_LARGE];
    } large;
    struct {
        int size;
        int items[MAX_BURNING];
        int total;
    } burning;
} building_list_data;

struct resource_data {
    int building_id;
    int distance;
    int num_buildings;
};

struct data_storage {
    int in_use;
    int building_id;
    struct building_storage_t storage;
};
static struct data_storage storages[MAX_STORAGES];

static struct {
    int x_start;
    int y_start;
    int x_end;
    int y_end;
    int bridge_confirmed;
    int fort_confirmed;
} confirm;

static struct {
    int type;
    int in_progress;
    struct map_tile_t start;
    struct map_tile_t end;
    int cost_preview;
    struct {
        int meadow;
        int rock;
        int tree;
        int water;
        int wall;
    } required_terrain;
    int road_orientation;
    uint32_t road_last_update;
    int draw_as_constructing;
    int start_offset_x_view;
    int start_offset_y_view;
} construction_data;

static struct {
    int highest_id_in_use;
    int highest_id_ever;
    int created_sequence;
    int incorrect_houses;
    int unfixable_houses;
} extra = { 0, 0, 0, 0, 0 };
// end structs

// start ints
static int MISSILE_LAUNCHER_OFFSETS[128] = {
    0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
static int HERD_FORMATION_LAYOUT_POSITION_X_OFFSETS[MAX_FORMATION_FIGURES] = {
    0, 2, -1, 1, 1, -1, 3, -2, 0, -4, -1, 0, 1, 4, 2, -5
};
static int HERD_FORMATION_LAYOUT_POSITION_Y_OFFSETS[MAX_FORMATION_FIGURES] = {
    0, 1, -1, 1, 0, 1, 1, -1, 2, 0, 3, 5, 4, 0, 3, 2
};
static int selected_legion_formation;
static   color_t mouse_colors[] = {
    ALPHA_TRANSPARENT,
    ALPHA_TRANSPARENT,
    ALPHA_TRANSPARENT,
    ALPHA_OPAQUE | COLOR_BLACK,
    ALPHA_OPAQUE | COLOR_MOUSE_DARK_GRAY,
    ALPHA_OPAQUE | COLOR_MOUSE_MEDIUM_GRAY,
    ALPHA_OPAQUE | COLOR_MOUSE_LIGHT_GRAY,
    ALPHA_OPAQUE | COLOR_WHITE
};
static int scale_percentage = 100;
static   int ADJACENT_OFFSETS[2][4][7] = {
    {
        {OFFSET(-1, 0), OFFSET(-1, -1), OFFSET(-1, -2), OFFSET(0, -2), OFFSET(1, -2)},
        {OFFSET(0, -1), OFFSET(1, -1), OFFSET(2, -1), OFFSET(2, 0), OFFSET(2, 1)},
        {OFFSET(1, 0), OFFSET(1, 1), OFFSET(1, 2), OFFSET(0, 2), OFFSET(-1, 2)},
        {OFFSET(0, 1), OFFSET(-1, 1), OFFSET(-2, 1), OFFSET(-2, 0), OFFSET(-2, -1)}
    },
    {
        {OFFSET(-1, 0), OFFSET(-1, -1), OFFSET(-1, -2), OFFSET(-1, -3), OFFSET(0, -3),  OFFSET(1, -3), OFFSET(2, -3)},
        {OFFSET(0, -1), OFFSET(1, -1), OFFSET(2, -1), OFFSET(3, -1), OFFSET(3, 0),  OFFSET(3, 1), OFFSET(3, 2)},
        {OFFSET(1, 0), OFFSET(1, 1), OFFSET(1, 2), OFFSET(1, 3), OFFSET(0, 3),  OFFSET(-1, 3), OFFSET(-2, 3)},
        {OFFSET(0, 1), OFFSET(-1, 1), OFFSET(-2, 1), OFFSET(-3, 1), OFFSET(-3, 0),  OFFSET(-3, -1), OFFSET(-3, -2)}
    }
};
static   int X_VIEW_OFFSETS[MAX_TILES_BUILDING_PREVIEW] = {
    0,
    -30, 30, 0,
    -60, 60, -30, 30, 0,
    -90, 90, -60, 60, -30, 30, 0,
    -120, 120, -90, 90, -60, 60, -30, 30, 0
};
static   int Y_VIEW_OFFSETS[MAX_TILES_BUILDING_PREVIEW] = {
    0,
    15, 15, 30,
    30, 30, 45, 45, 60,
    45, 45, 60, 60, 75, 75, 90,
    60, 60, 75, 75, 90, 90, 105, 105, 120
};
static   int TILE_GRID_OFFSETS[4][MAX_TILES_BUILDING_PREVIEW] = {
    {OFFSET(0,0),
    OFFSET(0,1), OFFSET(1,0), OFFSET(1,1),
    OFFSET(0,2), OFFSET(2,0), OFFSET(1,2), OFFSET(2,1), OFFSET(2,2),
    OFFSET(0,3), OFFSET(3,0), OFFSET(1,3), OFFSET(3,1), OFFSET(2,3), OFFSET(3,2), OFFSET(3,3),
    OFFSET(0,4), OFFSET(4,0), OFFSET(1,4), OFFSET(4,1), OFFSET(2,4), OFFSET(4,2),
        OFFSET(3,4), OFFSET(4,3), OFFSET(4,4)},
    {OFFSET(0,0),
    OFFSET(-1,0), OFFSET(0,1), OFFSET(-1,1),
    OFFSET(-2,0), OFFSET(0,2), OFFSET(-2,1), OFFSET(-1,2), OFFSET(-2,2),
    OFFSET(-3,0), OFFSET(0,3), OFFSET(-3,1), OFFSET(-1,3), OFFSET(-3,2), OFFSET(-2,3), OFFSET(-3,3),
    OFFSET(-4,0), OFFSET(0,4), OFFSET(-4,1), OFFSET(-1,4), OFFSET(-4,2), OFFSET(-2,4),
        OFFSET(-4,3), OFFSET(-3,4), OFFSET(-4,4)},
    {OFFSET(0,0),
    OFFSET(0,-1), OFFSET(-1,0), OFFSET(-1,-1),
    OFFSET(0,-2), OFFSET(-2,0), OFFSET(-1,-2), OFFSET(-2,-1), OFFSET(-2,-2),
    OFFSET(0,-3), OFFSET(-3,0), OFFSET(-1,-3), OFFSET(-3,-1), OFFSET(-2,-3), OFFSET(-3,-2), OFFSET(-3,-3),
    OFFSET(0,-4), OFFSET(-4,0), OFFSET(-1,-4), OFFSET(-4,-1), OFFSET(-2,-4), OFFSET(-4,-2),
        OFFSET(-3,-4), OFFSET(-4,-3), OFFSET(-4,-4)},
    {OFFSET(0,0),
    OFFSET(1,0), OFFSET(0,-1), OFFSET(1,-1),
    OFFSET(2,0), OFFSET(0,-2), OFFSET(2,-1), OFFSET(1,-2), OFFSET(2,-2),
    OFFSET(3,0), OFFSET(0,-3), OFFSET(3,-1), OFFSET(1,-3), OFFSET(3,-2), OFFSET(2,-3), OFFSET(3,-3),
    OFFSET(4,0), OFFSET(0,-4), OFFSET(4,-1), OFFSET(1,-4), OFFSET(4,-2), OFFSET(2,-4),
        OFFSET(4,-3), OFFSET(3,-4), OFFSET(4,-4)},
};
static int FORT_GROUND_GRID_OFFSETS[4] = { OFFSET(3,-1), OFFSET(4,-1), OFFSET(4,0), OFFSET(3,0) };
static int FORT_GROUND_X_VIEW_OFFSETS[4] = { 120, 90, -120, -90 };
static int FORT_GROUND_Y_VIEW_OFFSETS[4] = { 30, -75, -60, 45 };
static int HIPPODROME_X_VIEW_OFFSETS[4] = { 150, 150, -150, -150 };
static int HIPPODROME_Y_VIEW_OFFSETS[4] = { 75, -75, -75, 75 };
static color_t ENEMY_COLOR_BY_CLIMATE[] = {
    COLOR_MINIMAP_ENEMY_CENTRAL,
    COLOR_MINIMAP_ENEMY_NORTHERN,
    COLOR_MINIMAP_ENEMY_DESERT
};
static int focus_button_id_main_menu;
static int MENU_ID_TO_OVERLAY[MAX_BUTTONS_OVERLAY_MENU] = { OVERLAY_NONE, OVERLAY_WATER, 1, 3, 5, 6, 7, OVERLAY_RELIGION };
static int MENU_ID_TO_SUBMENU_ID[MAX_BUTTONS_OVERLAY_MENU] = { 0, 0, 1, 2, 3, 4, 5, 0 };
static int SUBMENU_ID_TO_OVERLAY[6][MAX_BUTTONS_OVERLAY_MENU] = {
    {0},
    {OVERLAY_FIRE, OVERLAY_DAMAGE, OVERLAY_CRIME, OVERLAY_NATIVE, OVERLAY_PROBLEMS, 0},
    {OVERLAY_ENTERTAINMENT, OVERLAY_THEATER, OVERLAY_AMPHITHEATER, OVERLAY_COLOSSEUM, OVERLAY_HIPPODROME, 0},
    {OVERLAY_EDUCATION, OVERLAY_SCHOOL, OVERLAY_LIBRARY, OVERLAY_ACADEMY, 0},
    {OVERLAY_BARBER, OVERLAY_BATHHOUSE, OVERLAY_CLINIC, OVERLAY_HOSPITAL, 0},
    {OVERLAY_TAX_INCOME, OVERLAY_FOOD_STOCKS, OVERLAY_DESIRABILITY, 0},
};
static int focus_button_id_set_salary;
static int focus_button_id_victory_dialog = 0;
static int INDEX_OPTIONS = 1;
static int INDEX_HELP = 2;
static int current_video;
static int started;
static uint32_t NOT_EXIST_MESSAGE_TIMEOUT = 500;
static int focus_button_id_gift_to_emperor;
static int focus_id_gods_button;
static int focus_id_festival_size_button;
static int focus_help_button_id;
static int current_selected_legion_index = 0;
static int focus_button_id_entertainment_advisor;
static int arrow_button_focus_financial_advisor;
static int goods_requests_to_draw;
static int selected_request_id;
static int focus_button_id_imperial_advisor;
static int focus_button_id_labor_advisor;
static int arrow_button_focus_labor_advisor;
static int focus_button_id_military_advisor;
static int focus_button_id_population_advisor;
static int focus_button_id_ratings_advisor;
static int focus_button_id_trade_advisor;
static int ADVISOR_TO_MESSAGE_TEXT[] = {
    MESSAGE_DIALOG_ABOUT,
    MESSAGE_DIALOG_ADVISOR_LABOR,
    MESSAGE_DIALOG_ADVISOR_MILITARY,
    MESSAGE_DIALOG_ADVISOR_IMPERIAL,
    MESSAGE_DIALOG_ADVISOR_RATINGS,
    MESSAGE_DIALOG_ADVISOR_TRADE,
    MESSAGE_DIALOG_ADVISOR_POPULATION,
    MESSAGE_DIALOG_ADVISOR_HEALTH,
    MESSAGE_DIALOG_ADVISOR_EDUCATION,
    MESSAGE_DIALOG_ADVISOR_ENTERTAINMENT,
    MESSAGE_DIALOG_ADVISOR_RELIGION,
    MESSAGE_DIALOG_ADVISOR_FINANCIAL,
    MESSAGE_DIALOG_ADVISOR_CHIEF
};
static int current_advisor = ADVISOR_NONE;
static int focus_button_id_advisors;
static int advisor_height;
static int Y_MENU_OFFSETS[] = {
    0, 322, 306, 274, 258, 226, 210, 178, 162, 130, 114,
    82, 66, 34, 18, -30, -46, -62, -78, -78, -94,
    -94, -110, -110,
    0, 0, 0, 0, 0, 0
};
static int BUILDING_MENU_SUBMENU_ITEM_MAPPING[BUILD_MENU_BUTTONS_COUNT][MAX_ITEMS_PER_BUILD_MENU][MAX_ITEMS_PER_SUBMENU] = {
    { // MENU_VACANT_HOUSE
        {BUILDING_HOUSE_VACANT_LOT},
    },
    { // MENU_CLEAR_LAND
        {BUILDING_CLEAR_LAND},
    },
    { // MENU_ROAD
        {BUILDING_ROAD},
    },
    { // MENU_WATER
        {BUILDING_RESERVOIR},
        {BUILDING_AQUEDUCT},
        {BUILDING_FOUNTAIN},
        {BUILDING_WELL},
    },
    { // MENU_HEALTH
        {BUILDING_DOCTOR},
        {BUILDING_BATHHOUSE},
        {BUILDING_BARBER},
        {BUILDING_HOSPITAL},
    },
    { // MENU_TEMPLES
        {BUILDING_SMALL_TEMPLE_CERES, BUILDING_SMALL_TEMPLE_NEPTUNE, BUILDING_SMALL_TEMPLE_MERCURY, BUILDING_SMALL_TEMPLE_MARS, BUILDING_SMALL_TEMPLE_VENUS},
        {BUILDING_LARGE_TEMPLE_CERES, BUILDING_LARGE_TEMPLE_NEPTUNE, BUILDING_LARGE_TEMPLE_MERCURY, BUILDING_LARGE_TEMPLE_MARS, BUILDING_LARGE_TEMPLE_VENUS},
        {BUILDING_ORACLE},
    },
    { // MENU_EDUCATION
        {BUILDING_SCHOOL},
        {BUILDING_LIBRARY},
        {BUILDING_ACADEMY},
        {BUILDING_MISSION_POST},
    },
    { // MENU_ENTERTAINMENT
        {BUILDING_THEATER},
        {BUILDING_ACTOR_COLONY},
        {BUILDING_AMPHITHEATER},
        {BUILDING_GLADIATOR_SCHOOL},
        {BUILDING_LION_HOUSE},
        {BUILDING_COLOSSEUM},
        {BUILDING_CHARIOT_MAKER},
        {BUILDING_HIPPODROME},
    },
    { // MENU_ADMINISTRATION
        {BUILDING_GARDENS},
        {BUILDING_PLAZA},
        {BUILDING_SMALL_STATUE},
        {BUILDING_MEDIUM_STATUE},
        {BUILDING_LARGE_STATUE},
        {BUILDING_GOVERNORS_HOUSE},
        {BUILDING_GOVERNORS_VILLA},
        {BUILDING_GOVERNORS_PALACE},
        {BUILDING_FORUM},
        {BUILDING_SENATE},
        {BUILDING_TRIUMPHAL_ARCH},
    },
    { // MENU_ENGINEERING
        {BUILDING_ENGINEERS_POST},
        {BUILDING_LOW_BRIDGE},
        {BUILDING_SHIP_BRIDGE},
        {BUILDING_SHIPYARD},
        {BUILDING_WHARF},
        {BUILDING_DOCK},
    },
    { // MENU_SECURITY
        {BUILDING_PREFECTURE},
        {BUILDING_WALL},
        {BUILDING_TOWER},
        {BUILDING_GATEHOUSE},
        {BUILDING_FORT_LEGIONARIES, BUILDING_FORT_JAVELIN, BUILDING_FORT_MOUNTED},
        {BUILDING_BARRACKS},
        {BUILDING_MILITARY_ACADEMY},
    },
    { // MENU_INDUSTRY
        {BUILDING_WHEAT_FARM, BUILDING_VEGETABLE_FARM, BUILDING_FRUIT_FARM, BUILDING_PIG_FARM, BUILDING_OLIVE_FARM, BUILDING_VINES_FARM},
        {BUILDING_CLAY_PIT, BUILDING_TIMBER_YARD, BUILDING_MARBLE_QUARRY, BUILDING_IRON_MINE},
        {BUILDING_OIL_WORKSHOP, BUILDING_WINE_WORKSHOP, BUILDING_POTTERY_WORKSHOP, BUILDING_FURNITURE_WORKSHOP, BUILDING_WEAPONS_WORKSHOP},
        {BUILDING_MARKET},
        {BUILDING_GRANARY},
        {BUILDING_WAREHOUSE},
    }
};
static uint32_t last_update_time;
static int LAYOUT_OFFSETS_FROM_MAP_EDGE[][2] = {
    {4, 9}, // FORMATION_TORTOISE
    {2, 5}, // FORMATION_DOUBLE_LINE_1
    {2, 5}, // FORMATION_DOUBLE_LINE_2
    {0, 0}, // FORMATION_SINGLE_LINE_1 (not used by enemies)
    {0, 0}, // FORMATION_SINGLE_LINE_2 (not used by enemies)
    {0, 0}, // FORMATION_MOP_UP (not used by enemies)
    {0, 0}, // FORMATION_AT_REST (not used by enemies)
    {4, 11}, // FORMATION_ENEMY_MOB
    {5, 12}, // FORMATION_ENEMY_WIDE_COLUMN
};
static int LAYOUT_SPACING_BETWEEN_FORMATIONS[] = {
    3, // FORMATION_TORTOISE
    5, // FORMATION_DOUBLE_LINE_1
    5, // FORMATION_DOUBLE_LINE_2
    0, // FORMATION_SINGLE_LINE_1 (not used by enemies)
    0, // FORMATION_SINGLE_LINE_2 (not used by enemies)
    0, // FORMATION_MOP_UP (not used by enemies)
    0, // FORMATION_AT_REST (not used by enemies)
    4, // FORMATION_ENEMY_MOB
    4, // FORMATION_ENEMY_WIDE_COLUMN
};
static int RANDOM_EVENT_PROBABILITY[128] = {
    0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 3, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 2, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,
    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 4, 0, 0,
    0, 0, 3, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0
};
static int route_through_building_id;
static int aqueduct_include_construction = 0;
static int direction_path[MAX_PATH];
static int ROUTE_OFFSETS[] = { -162, 1, 162, -1, -161, 163, 161, -163 };
static int ADJACENT_OFFSETS_ROUTING[] = { -GRID_SIZE, 1, GRID_SIZE, -1 };
static int DIRECTION_DELTA[] = {
    -OFFSET(0,1), OFFSET(1,-1), 1, OFFSET(1,1), OFFSET(0,1), OFFSET(-1,1), -1, -OFFSET(1,1)
};
static int ADJACENT_OFFSETS_MAP_GRID[][21] = {
    {0},
    {OFFSET(0,-1), OFFSET(1,0), OFFSET(0,1), OFFSET(-1,0), 0},
    {OFFSET(0,-1), OFFSET(1,-1), OFFSET(2,0), OFFSET(2,1), OFFSET(1,2), OFFSET(0,2), OFFSET(-1,1), OFFSET(-1,0), 0},
    {
        OFFSET(0,-1), OFFSET(1,-1), OFFSET(2,-1),
        OFFSET(3,0), OFFSET(3,1), OFFSET(3,2),
        OFFSET(2,3), OFFSET(1,3), OFFSET(0,3),
        OFFSET(-1,2), OFFSET(-1,1), OFFSET(-1,0), 0
    },
    {
        OFFSET(0,-1), OFFSET(1,-1), OFFSET(2,-1), OFFSET(3,-1),
        OFFSET(4,0), OFFSET(4,1), OFFSET(4,2), OFFSET(4,3),
        OFFSET(3,4), OFFSET(2,4), OFFSET(1,4), OFFSET(0,4),
        OFFSET(-1,3), OFFSET(-1,2), OFFSET(-1,1), OFFSET(-1,0), 0
    },
    {
        OFFSET(0,-1), OFFSET(1,-1), OFFSET(2,-1), OFFSET(3,-1), OFFSET(4,-1),
        OFFSET(5,0), OFFSET(5,1), OFFSET(5,2), OFFSET(5,3), OFFSET(5,4),
        OFFSET(4,5), OFFSET(3,5), OFFSET(2,5), OFFSET(1,5), OFFSET(0,5),
        OFFSET(-1,4), OFFSET(-1,3), OFFSET(-1,2), OFFSET(-1,1), OFFSET(-1,0), 0
    },
};
static int DIRECTION_X[] = { 0,  1,  1,  1,  0, -1, -1, -1, 0 };
static int DIRECTION_Y[] = { -1, -1,  0,  1,  1,  1,  0, -1, 0 };
static int SCROLL_STEP[SCROLL_TYPE_MAX][11] = {
    {60, 44, 30, 20, 16, 12, 10, 8, 6, 4, 2},
    {20, 15, 10,  7,  5,  4,  3, 3, 2, 2, 1}
};
static uint32_t last_click;
static int FOOTPRINT_X_START_PER_HEIGHT[] = {
    28, 26, 24, 22, 20, 18, 16, 14, 12, 10, 8, 6, 4, 2, 0,
    0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28
};
static int FOOTPRINT_OFFSET_PER_HEIGHT[] = {
    0, 2, 8, 18, 32, 50, 72, 98, 128, 162, 200, 242, 288, 338, 392, 450,
    508, 562, 612, 658, 700, 738, 772, 802, 828, 850, 868, 882, 892, 898
};
static int REPEATS[] = {
    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0,
    0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
    1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0
};
static uint32_t REPEAT_MILLIS = 30;
static unsigned int BUTTON_PRESSED_FRAMES = 3;
static int fire_spread_direction = 0;
static int HOUSE_TILE_OFFSETS[] = {
    OFFSET(0,0), OFFSET(1,0), OFFSET(0,1), OFFSET(1,1), // 2x2
    OFFSET(2,0), OFFSET(2,1), OFFSET(2,2), OFFSET(1,2), OFFSET(0,2), // 3x3
    OFFSET(3,0), OFFSET(3,1), OFFSET(3,2), OFFSET(3,3), OFFSET(2,3), OFFSET(1,3), OFFSET(0,3) // 4x4
};
static uint32_t MILLIS_PER_TICK_PER_SPEED[] = {
    702, 502, 352, 242, 162, 112, 82, 57, 37, 22, 16
};
static uint32_t MILLIS_PER_HYPER_SPEED[] = {
    702, 16, 8, 5, 3, 2
};
static int FLOTSAM_TYPE_0[] = { 0, 1, 2, 3, 4, 4, 4, 3, 2, 1, 0, 0 };
static int FLOTSAM_TYPE_12[] = { 0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 3, 2, 1, 0, 0, 1, 1, 2, 2, 1, 1, 0, 0, 0 };
static int FLOTSAM_TYPE_3[] = { 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };
static int BALLISTA_FIRING_OFFSETS[] = {
    0, 1, 2, 3, 4, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
static int CLOUD_IMAGE_OFFSETS[] = {
    0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2,
    2, 2, 2, 2, 3, 3, 3, 4, 4, 5, 6, 7
};
static int CRIMINAL_OFFSETS[] = {
    0, 0, 1, 2, 3, 4, 5, 6, 7, 7, 6, 5, 4, 3, 2, 1
};
static int CART_OFFSET_MULTIPLE_LOADS_FOOD[] = { 0, 0, 8, 16, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
static int CART_OFFSET_MULTIPLE_LOADS_NON_FOOD[] = { 0, 0, 0, 0, 0, 8, 0, 16, 24, 32, 40, 48, 56, 64, 72, 80 };
static int CART_OFFSET_8_LOADS_FOOD[] = { 0, 40, 48, 56, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
static int SHEEP_IMAGE_OFFSETS[] = {
    0,  0,  1,  1,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
    3,  3,  3,  3,  4,  4,  5,  5, -1, -1, -1, -1, -1, -1, -1, -1
};
static int TOWER_SENTRY_FIRING_OFFSETS[] = {
    0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
static int FLOTSAM_RESOURCE_IDS[] = {
    3, 1, 3, 2, 1, 3, 2, 3, 2, 1, 3, 3, 2, 3, 3, 3, 1, 2, 0, 1
};
static int FLOTSAM_WAIT_TICKS[] = {
    10, 50, 100, 130, 200, 250, 400, 430, 500, 600, 70, 750, 820, 830, 900, 980, 1010, 1030, 1200, 1300
};
static int CLOUD_TILE_OFFSETS[] = { 0, 0, 0, 1, 1, 2 };
static int CLOUD_CC_OFFSETS[] = { 0, 7, 14, 7, 14, 7 };
static int CLOUD_SPEED[] = {
    1, 2, 1, 3, 2, 1, 3, 2, 1, 1, 2, 1, 2, 1, 3, 1
};
static int FORMATION_LAYOUT_POSITION_X[FORMATION_MAX][MAX_FORMATION_FIGURES] = {
    {0, 1, 0, 1, -1, -1, 0, 1, -1, 2, 2, 2, 0, 1, -1, 2}, // FORMATION_TORTOISE
    {0, 0, -1, 1, -1, 1, -2, -2, 2, 2, -3, -3, 3, 3, -4, -4}, // FORMATION_DOUBLE_LINE_1
    {0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1}, // FORMATION_DOUBLE_LINE_2
    {0, 2, -2, 1, -1, 3, -3, 4, -4, 5, 6, -5, -6, 7, 8, -7}, // FORMATION_SINGLE_LINE_1
    {0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1}, // FORMATION_SINGLE_LINE_2
    {0, 1, 0, 1, 2, 2, 1, 0, 2, 3, 3, 3, 1, 2, 0, 3}, // FORMATION_MOP_UP
    {0, 1, 0, 1, 2, 2, 1, 0, 2, 3, 3, 3, 1, 2, 0, 3}, // FORMATION_AT_REST
    {0, -3, -1, 0, 2, 2, 3, 4, 2, 3, 0, -3, 2, -1, -3, 0}, // FORMATION_ENEMY_MOB
    {0, 2, 0, 2, -2, -2, 0, 2, -2, 4, 4, 4, 0, 2, -2, 4}, // FORMATION_ENEMY_WIDE_COLUMN
};
static int FORMATION_LAYOUT_POSITION_Y[FORMATION_MAX][MAX_FORMATION_FIGURES] = {
    {0, 0, 1, 1, 0, 1, -1, -1, -1, -1, 0, 1, 2, 2, 2, 2}, // FORMATION_TORTOISE
    {0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1}, // FORMATION_DOUBLE_LINE_1
    {0, -1, 1, 0, -1, 1, -2, -2, 2, 2, -3, -3, 3, 3, -4, -4}, // FORMATION_DOUBLE_LINE_2
    {0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1}, // FORMATION_SINGLE_LINE_1
    {0, -2, 2, -1, 1, -3, 3, -4, 4, -5, -6, 5, 6, -7, -8, 7}, // FORMATION_SINGLE_LINE_2
    {0, 0, 1, 1, 0, 1, 2, 2, 2, 0, 1, 2, 3, 3, 3, 3}, // FORMATION_MOP_UP
    {0, 0, 1, 1, 0, 1, 2, 2, 2, 0, 1, 2, 3, 3, 3, 3}, // FORMATION_AT_REST
    {0, -2, 0, 1, 0, 1, 1, 2, -2, -1, -3, 1, -1, 2, 2, -2}, // FORMATION_ENEMY_MOB
    {0, 0, 2, 2, 0, 2, -2, -2, -2, -2, 0, 2, 4, 4, 4, 4}, // FORMATION_ENEMY_WIDE_COLUMN
};
static int ENEMY_ATTACK_PRIORITY[4][30] = {
    {BUILDING_GRANARY, BUILDING_WAREHOUSE, BUILDING_MARKET,
    BUILDING_WHEAT_FARM, BUILDING_VEGETABLE_FARM, BUILDING_FRUIT_FARM, BUILDING_OLIVE_FARM, BUILDING_VINES_FARM, BUILDING_PIG_FARM, 0},
    {BUILDING_SENATE, BUILDING_FORUM, 0},
    {BUILDING_TRIUMPHAL_ARCH, BUILDING_SENATE, BUILDING_GOVERNORS_PALACE, BUILDING_GOVERNORS_VILLA, BUILDING_GOVERNORS_HOUSE,
    BUILDING_HIPPODROME, 0},
    {BUILDING_BARRACKS, BUILDING_MILITARY_ACADEMY, BUILDING_PREFECTURE, 0}
};
static int RIOTER_ATTACK_PRIORITY[100] = {
    BUILDING_GOVERNORS_PALACE, BUILDING_GOVERNORS_VILLA, BUILDING_GOVERNORS_HOUSE,
    BUILDING_SENATE, BUILDING_FORUM,
    BUILDING_HOUSE_LUXURY_PALACE, BUILDING_HOUSE_LARGE_PALACE, BUILDING_HOUSE_MEDIUM_PALACE, BUILDING_HOUSE_SMALL_PALACE,
    BUILDING_HOUSE_GRAND_VILLA, BUILDING_HOUSE_LARGE_VILLA, BUILDING_HOUSE_MEDIUM_VILLA, BUILDING_HOUSE_SMALL_VILLA,
    BUILDING_PREFECTURE,
    BUILDING_ACADEMY, BUILDING_LIBRARY,
    BUILDING_BATHHOUSE,
    BUILDING_HIPPODROME, BUILDING_COLOSSEUM, BUILDING_AMPHITHEATER, BUILDING_THEATER, BUILDING_GLADIATOR_SCHOOL, BUILDING_ACTOR_COLONY, BUILDING_CHARIOT_MAKER, BUILDING_LION_HOUSE,
    BUILDING_LARGE_TEMPLE_CERES, BUILDING_LARGE_TEMPLE_NEPTUNE, BUILDING_LARGE_TEMPLE_MERCURY, BUILDING_LARGE_TEMPLE_MARS, BUILDING_LARGE_TEMPLE_VENUS,
    BUILDING_HOSPITAL,
    BUILDING_HOUSE_GRAND_INSULA, BUILDING_HOUSE_LARGE_INSULA, BUILDING_HOUSE_MEDIUM_INSULA, BUILDING_HOUSE_SMALL_INSULA,
    BUILDING_WINE_WORKSHOP, BUILDING_OIL_WORKSHOP, BUILDING_WEAPONS_WORKSHOP, BUILDING_FURNITURE_WORKSHOP, BUILDING_POTTERY_WORKSHOP,
    BUILDING_GRANARY, BUILDING_WAREHOUSE, BUILDING_MARKET, BUILDING_DOCK,
    BUILDING_ENGINEERS_POST,
    BUILDING_HOUSE_LARGE_CASA, BUILDING_HOUSE_SMALL_CASA, BUILDING_HOUSE_LARGE_HOVEL, BUILDING_HOUSE_SMALL_HOVEL,
    BUILDING_CLAY_PIT, BUILDING_MARBLE_QUARRY, BUILDING_IRON_MINE, BUILDING_TIMBER_YARD,
    BUILDING_WHEAT_FARM, BUILDING_VEGETABLE_FARM, BUILDING_FRUIT_FARM, BUILDING_OLIVE_FARM, BUILDING_VINES_FARM, BUILDING_PIG_FARM,
    BUILDING_SMALL_TEMPLE_CERES, BUILDING_SMALL_TEMPLE_NEPTUNE, BUILDING_SMALL_TEMPLE_MERCURY, BUILDING_SMALL_TEMPLE_MARS, BUILDING_SMALL_TEMPLE_VENUS, BUILDING_ORACLE,
    BUILDING_RESERVOIR, BUILDING_FOUNTAIN, BUILDING_WELL,
    BUILDING_HOUSE_LARGE_SHACK, BUILDING_HOUSE_SMALL_SHACK, BUILDING_HOUSE_LARGE_TENT, BUILDING_HOUSE_SMALL_TENT,
    0
};
static int LAYOUT_REGROUP_DURATION[] = {
    10, // FORMATION_TORTOISE
    8, // FORMATION_DOUBLE_LINE_1
    8, // FORMATION_DOUBLE_LINE_2
    0, // FORMATION_SINGLE_LINE_1 (not used by enemies)
    0, // FORMATION_SINGLE_LINE_2 (not used by enemies)
    0, // FORMATION_MOP_UP (not used by enemies)
    0, // FORMATION_AT_REST (not used by enemies)
    5, // FORMATION_ENEMY_MOB
    9, // FORMATION_ENEMY_WIDE_COLUMN
};
static int CORPSE_IMAGE_OFFSETS[128] = {
    0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
};
static int CART_OFFSETS_X[] = { 13, 18, 12, 0, -13, -18, -13, 0 };
static int CART_OFFSETS_Y[] = { -7, -1, 7, 11, 6, -1, -7, -12 };
static int editor_active;
static int demand_routes_num_routes;
static int open_sub_menu_top_menu_editor;
static int focus_menu_id_top_menu_editor;
static int focus_sub_menu_id_top_menu_editor;
static int focus_button_id_earthquakes;
static int id_edit_earthquake;
static int focus_button_id_edit_earthquake;
static int focus_button_id_invasions;
static int id_edit_invasion;
static int focus_button_id_edit_invasion;
static int focus_button_id_price_changes;
static int id_edit_price_change;
static int focus_button_id_edit_price_change;
static int focus_button_id_demand_changes;
static int id_demand_route;
static int focus_button_id_demand_route;
static int demand_routes_route_ids[MAX_DEMAND_ROUTES];
static int focus_button_id_starting_conditions;
static int focus_button_id_start_year;
static int focus_button_id_win_criteria;
static int focus_button_id_allowed_buildings;
static int focus_button_id_special_events;
static int focus_button_id_requests;
static int id_edit_request;
static int focus_button_id_edit_request;
static int focus_button_id_attr_custom_messages;
static int focus_button_id_title_custom_messages;
static int focus_button_id_text_custom_messages;
static int custom_message_id;
static int custom_message_category;
static int focus_button_id_edit_custom_msg;
static int empire_editor_x_min;
static int empire_editor_x_max;
static int empire_editor_y_min;
static int empire_editor_y_max;
static int empire_editor_x_draw_offset;
static int empire_editor_y_draw_offset;
static int empire_editor_focus_trade_route_cost_button_id;
static int empire_editor_focus_expansion_year_button_id;
static int empire_editor_show_battle_objects;
static int focus_button_id_briefing;
static int focus_button_id_build_menu;
static int selected_submenu_build_menu = MENU_NONE;
static int num_items_build_menu;
static int focus_button_id_attributes;
static int TILE_X_VIEW_OFFSETS[MAX_TILES_OFFSETS] = { 0, -30, 30, 0 };
static int TILE_Y_VIEW_OFFSETS[MAX_TILES_OFFSETS] = { 0, 15, 15, 30 };
static int TILE_GRID_OFFSETS_EDITOR[] = { 0, GRID_SIZE, 1, GRID_SIZE + 1 };
static int ACCESS_RAMP_TILE_OFFSETS_BY_ORIENTATION[4][6] = {
    {OFFSET(0,1), OFFSET(1,1), OFFSET(0,2), OFFSET(1,2), OFFSET(0,0), OFFSET(1,0)},
    {OFFSET(0,0), OFFSET(0,1), OFFSET(-1,0), OFFSET(-1,1), OFFSET(1,0), OFFSET(1,1)},
    {OFFSET(0,0), OFFSET(1,0), OFFSET(0,-1), OFFSET(1,-1), OFFSET(0,1), OFFSET(1,1)},
    {OFFSET(1,0), OFFSET(1,1), OFFSET(2,0), OFFSET(2,1), OFFSET(0,0), OFFSET(0,1)},
};
static uint32_t current_time;
static uint8_t BIT_MASKS[] = {
    0x00,
    0x01,
    0x03,
    0x07,
    0x0f,
    0x1f,
    0x3f,
    0x7f,
    0xff,
};
static uint8_t PALETTE_MAP[64] = {
    0x00, 0x04, 0x08, 0x0C, 0x10, 0x14, 0x18, 0x1C,
    0x20, 0x24, 0x28, 0x2C, 0x30, 0x34, 0x38, 0x3C,
    0x41, 0x45, 0x49, 0x4D, 0x51, 0x55, 0x59, 0x5D,
    0x61, 0x65, 0x69, 0x6D, 0x71, 0x75, 0x79, 0x7D,
    0x82, 0x86, 0x8A, 0x8E, 0x92, 0x96, 0x9A, 0x9E,
    0xA2, 0xA6, 0xAA, 0xAE, 0xB2, 0xB6, 0xBA, 0xBE,
    0xC3, 0xC7, 0xCB, 0xCF, 0xD3, 0xD7, 0xDB, 0xDF,
    0xE3, 0xE7, 0xEB, 0xEF, 0xF3, 0xF7, 0xFB, 0xFF
};
static int CHAIN_SIZE[64] = {
     1,    2,    3,    4,    5,    6,    7,    8,
     9,   10,   11,   12,   13,   14,   15,   16,
    17,   18,   19,   20,   21,   22,   23,   24,
    25,   26,   27,   28,   29,   30,   31,   32,
    33,   34,   35,   36,   37,   38,   39,   40,
    41,   42,   43,   44,   45,   46,   47,   48,
    49,   50,   51,   52,   53,   54,   55,   56,
    57,   58,   59,  128,  256,  512, 1024, 2048
};
static int settings_values[SETTINGS_MAX_ENTRIES];
static int values[CONFIG_MAX_ENTRIES];
static int default_values[CONFIG_MAX_ENTRIES] = {
    [CONFIG_SCREEN_DISPLAY_SCALE] = 100,
    [CONFIG_SCREEN_CURSOR_SCALE] = 100
};
static int SENTIMENT_PER_TAX_RATE[26] = {
    3, 2, 2, 2, 1, 1, 1, 0, 0, -1,
    -2, -2, -3, -3, -3, -5, -5, -5, -5, -6,
    -6, -6, -6, -6, -6, -6
};
static int BIRTHS_PER_AGE_DECENNIUM[10] = {
    0, 3, 16, 9, 2, 0, 0, 0, 0, 0
};
static int DEATHS_PER_HEALTH_PER_AGE_DECENNIUM[11][10] = {
    {20, 10, 5, 10, 20, 30, 50, 85, 100, 100},
    {15, 8, 4, 8, 16, 25, 45, 70, 90, 100},
    {10, 6, 2, 6, 12, 20, 30, 55, 80, 90},
    {5, 4, 0, 4, 8, 15, 25, 40, 65, 80},
    {3, 2, 0, 2, 6, 12, 20, 30, 50, 70},
    {2, 0, 0, 0, 4, 8, 15, 25, 40, 60},
    {1, 0, 0, 0, 2, 6, 12, 20, 30, 50},
    {0, 0, 0, 0, 0, 4, 8, 15, 20, 40},
    {0, 0, 0, 0, 0, 2, 6, 10, 15, 30},
    {0, 0, 0, 0, 0, 0, 4, 5, 10, 20},
    {0, 0, 0, 0, 0, 0, 0, 2, 5, 10}
};
static int view_to_grid_offset_lookup[VIEW_X_MAX][VIEW_Y_MAX];
static int should_play_sound = 1;
static int SALARY_FOR_RANK[11] = { 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144 };
static int focus_image_button_id_building_info;
static int has_warning = 0;
static int last_items_cleared;
static int tower_sentry_request = 0;
// end ints

static FILE *log_file = 0;

noreturn static void handler(int sig)
{
    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Oops, crashed with signal %d :(", sig);
    _exit(1);
}

static int string_length(char *str)
{
    int length = 0;
    while (*str) {
        length++;
        str++;
    }
    return length;
}

static void write_log(__attribute__((unused)) void *userdata, __attribute__((unused)) int category, SDL_LogPriority priority, const char *message)
{
    if (log_file) {
        if (priority == SDL_LOG_PRIORITY_ERROR) {
            fwrite("ERROR: ", sizeof(char), 7, log_file);
        } else {
            fwrite("INFO: ", sizeof(char), 6, log_file);
        }
        fwrite(message, sizeof(char), string_length(message), log_file);
        fwrite("\n", sizeof(char), 1, log_file);
        fflush(log_file);
    }
}

static void post_event(int code)
{
    SDL_Event event;
    event.user.type = SDL_USEREVENT;
    event.user.code = code;
    SDL_PushEvent(&event);
}

static void system_resize(int width, int height)
{
    static int s_width;
    static int s_height;
    s_width = width;
    s_height = height;
    SDL_Event event;
    event.user.type = SDL_USEREVENT;
    event.user.code = USER_EVENT_RESIZE;
    event.user.data1 = &s_width;
    event.user.data2 = &s_height;
    SDL_PushEvent(&event);
}

static int string_from_int(char *dst, int value, int force_plus_sign)
{
    int total_chars = 0;
    if (value >= 0) {
        if (force_plus_sign) {
            dst[0] = '+';
            dst++;
            total_chars = 1;
        }
    } else {
        dst[0] = '-';
        dst++;
        value = -value;
        total_chars = 1;
    }
    int num_digits;
    if (value < 10) {
        num_digits = 1;
    } else if (value < 100) {
        num_digits = 2;
    } else if (value < 1000) {
        num_digits = 3;
    } else if (value < 10000) {
        num_digits = 4;
    } else if (value < 100000) {
        num_digits = 5;
    } else if (value < 1000000) {
        num_digits = 6;
    } else if (value < 10000000) {
        num_digits = 7;
    } else if (value < 100000000) {
        num_digits = 8;
    } else if (value < 1000000000) {
        num_digits = 9;
    } else {
        num_digits = 0;
    }
    total_chars += num_digits;
    dst[num_digits] = 0;
    while (--num_digits >= 0) {
        dst[num_digits] = value % 10 + '0';
        value /= 10;
    }
    return total_chars;
}

static int number_to_string(char *str, int value, char prefix, char *postfix)
{
    int offset = 0;
    if (prefix) {
        str[offset++] = prefix;
    }
    offset += string_from_int(&str[offset], value, 0);
    if (postfix) {
        while (*postfix) {
            str[offset++] = *postfix;
            postfix++;
        }
    }
    str[offset] = 0;
    return offset;
}

static int font_letter_id(struct font_definition_t *def, char *str)
{
    if (!font_data.font_mapping[(uint8_t) *str]) {
        return -1;
    }
    return font_data.font_mapping[(uint8_t) *str] + def->image_offset - 1;
}

static   struct image_t *image_letter(int letter_id)
{
    return &image_data_s.main[image_data_s.group_image_ids[GROUP_FONT] + letter_id];

}

static int get_word_width_rich_text(char *str, int *num_chars)
{
    int width = 0;
    int guard = 0;
    int word_char_seen = 0;
    *num_chars = 0;
    while (*str && ++guard < 2000) {
        if (*str == ' ') {
            if (word_char_seen) {
                break;
            }
            width += 4;
        } else if (*str > ' ') {
            // normal char
            int letter_id = font_letter_id(rich_text_data.normal_font, str);
            if (letter_id >= 0) {
                width += 1 + image_letter(letter_id)->width;
            }
            word_char_seen = 1;
        }
        str += 1;
        *num_chars += 1;
    }
    return width;
}

static   struct clip_info_t *graphics_get_clip_info(int x, int y, int width, int height)
{
    clip.clipped_pixels_left = 0;
    clip.clipped_pixels_right = 0;
    if (width <= 0
        || x + width <= clip_rectangle.x_start
        || x >= clip_rectangle.x_end) {
        clip.clip_x = CLIP_INVISIBLE;
        clip.visible_pixels_x = 0;
        return 0;
    }
    if (x < clip_rectangle.x_start) {
        // clipped on the left
        clip.clipped_pixels_left = clip_rectangle.x_start - x;
        if (x + width <= clip_rectangle.x_end) {
            clip.clip_x = CLIP_LEFT;
        } else {
            clip.clip_x = CLIP_BOTH;
            clip.clipped_pixels_right = x + width - clip_rectangle.x_end;
        }
    } else if (x + width > clip_rectangle.x_end) {
        clip.clip_x = CLIP_RIGHT;
        clip.clipped_pixels_right = x + width - clip_rectangle.x_end;
    } else {
        clip.clip_x = CLIP_NONE;
    }
    clip.visible_pixels_x = width - clip.clipped_pixels_left - clip.clipped_pixels_right;
    clip.clipped_pixels_top = 0;
    clip.clipped_pixels_bottom = 0;
    if (height <= 0
        || y + height <= clip_rectangle.y_start
        || y >= clip_rectangle.y_end) {
        clip.clip_y = CLIP_INVISIBLE;
    } else if (y < clip_rectangle.y_start) {
        // clipped on the top
        clip.clipped_pixels_top = clip_rectangle.y_start - y;
        if (y + height <= clip_rectangle.y_end) {
            clip.clip_y = CLIP_TOP;
        } else {
            clip.clip_y = CLIP_BOTH;
            clip.clipped_pixels_bottom = y + height - clip_rectangle.y_end;
        }
    } else if (y + height > clip_rectangle.y_end) {
        clip.clip_y = CLIP_BOTTOM;
        clip.clipped_pixels_bottom = y + height - clip_rectangle.y_end;
    } else {
        clip.clip_y = CLIP_NONE;
    }
    clip.visible_pixels_y = height - clip.clipped_pixels_top - clip.clipped_pixels_bottom;
    if (clip.clip_x == CLIP_INVISIBLE || clip.clip_y == CLIP_INVISIBLE) {
        clip.is_visible = 0;
    } else {
        clip.is_visible = 1;
    }
    return &clip;
}

static color_t *graphics_get_pixel(int x, int y)
{
    return &canvas.pixels[(translation.y + y) * canvas.width + (translation.x + x)];
}

static void draw_compressed_set(struct image_t *img, color_t *data, int x_offset, int y_offset, int height, color_t color)
{
    struct clip_info_t *clip = graphics_get_clip_info(x_offset, y_offset, img->width, height);
    if (!clip || !clip->is_visible) {
        return;
    }
    int unclipped = clip->clip_x == CLIP_NONE;

    for (int y = 0; y < height - clip->clipped_pixels_bottom; y++) {
        int x = 0;
        while (x < img->width) {
            color_t b = *data;
            data++;
            if (b == 255) {
                // transparent pixels to skip
                x += *data;
                data++;
            } else if (y < clip->clipped_pixels_top) {
                data += b;
                x += b;
            } else {
                data += b;
                color_t *dst = graphics_get_pixel(x_offset + x, y_offset + y);
                if (unclipped) {
                    x += b;
                    while (b) {
                        *dst = color;
                        dst++;
                        b--;
                    }
                } else {
                    while (b) {
                        if (x >= clip->clipped_pixels_left && x < img->width - clip->clipped_pixels_right) {
                            *dst = color;
                        }
                        dst++;
                        x++;
                        b--;
                    }
                }
            }
        }
    }
}

static void draw_compressed(struct image_t *img, color_t *data, int x_offset, int y_offset, int height)
{
    struct clip_info_t *clip = graphics_get_clip_info(x_offset, y_offset, img->width, height);
    if (!clip || !clip->is_visible) {
        return;
    }
    int unclipped = clip->clip_x == CLIP_NONE;

    for (int y = 0; y < height - clip->clipped_pixels_bottom; y++) {
        int x = 0;
        while (x < img->width) {
            color_t b = *data;
            data++;
            if (b == 255) {
                // transparent pixels to skip
                x += *data;
                data++;
            } else if (y < clip->clipped_pixels_top) {
                data += b;
                x += b;
            } else {
                // number of concrete pixels
                color_t *pixels = data;
                data += b;
                color_t *dst = graphics_get_pixel(x_offset + x, y_offset + y);
                if (unclipped) {
                    x += b;
                    memcpy(dst, pixels, b * sizeof(color_t));
                } else {
                    while (b) {
                        if (x >= clip->clipped_pixels_left && x < img->width - clip->clipped_pixels_right) {
                            *dst = *pixels;
                        }
                        dst++;
                        x++;
                        pixels++;
                        b--;
                    }
                }
            }
        }
    }
}

static void draw_uncompressed(struct image_t *img, color_t *data, int x_offset, int y_offset, color_t color, int type)
{
    struct clip_info_t *clip = graphics_get_clip_info(x_offset, y_offset, img->width, img->height);
    if (!clip || !clip->is_visible) {
        return;
    }
    data += img->width * clip->clipped_pixels_top;
    for (int y = clip->clipped_pixels_top; y < img->height - clip->clipped_pixels_bottom; y++) {
        data += clip->clipped_pixels_left;
        color_t *dst = graphics_get_pixel(x_offset + clip->clipped_pixels_left, y_offset + y);
        int x_max = img->width - clip->clipped_pixels_right;
        if (type == DRAW_TYPE_NONE) {
            if (img->draw.type == IMAGE_TYPE_WITH_TRANSPARENCY || img->draw.is_external) { // can be transparent
                for (int x = clip->clipped_pixels_left; x < x_max; x++, dst++) {
                    if (*data != COLOR_SG2_TRANSPARENT) {
                        *dst = *data;
                    }
                    data++;
                }
            } else {
                int num_pixels = x_max - clip->clipped_pixels_left;
                memcpy(dst, data, num_pixels * sizeof(color_t));
                data += num_pixels;
            }
        } else if (type == DRAW_TYPE_SET) {
            for (int x = clip->clipped_pixels_left; x < x_max; x++, dst++) {
                if (*data != COLOR_SG2_TRANSPARENT) {
                    *dst = color;
                }
                data++;
            }
        } else if (type == DRAW_TYPE_AND) {
            for (int x = clip->clipped_pixels_left; x < x_max; x++, dst++) {
                if (*data != COLOR_SG2_TRANSPARENT) {
                    *dst = *data & color;
                }
                data++;
            }
        } else if (type == DRAW_TYPE_BLEND) {
            for (int x = clip->clipped_pixels_left; x < x_max; x++, dst++) {
                if (*data != COLOR_SG2_TRANSPARENT) {
                    *dst &= color;
                }
                data++;
            }
        } else if (type == DRAW_TYPE_BLEND_ALPHA) {
            for (int x = clip->clipped_pixels_left; x < x_max; x++, dst++) {
                if (*data != COLOR_SG2_TRANSPARENT) {
                    color_t alpha = COMPONENT(*data, 24);
                    if (alpha == 255) {
                        *dst = color;
                    } else {
                        color_t s = color;
                        color_t d = *dst;
                        *dst = MIX_RB(s, d, alpha) | MIX_G(s, d, alpha);
                    }
                }
                data++;
            }
        }
        data += clip->clipped_pixels_right;
    }
}

static void image_draw_letter(int letter_id, int x, int y, color_t color)
{
    struct image_t *img = image_letter(letter_id);
    int image_id = image_data_s.group_image_ids[GROUP_FONT] + letter_id;
    color_t *data = &image_data_s.main_data[image_data_s.main[image_id].draw.offset];
    if (!data) {
        return;
    }

    if (img->draw.is_fully_compressed) {
        if (color) {
            draw_compressed_set(img, data, x, y, img->height, color);
        } else {
            draw_compressed(img, data, x, y, img->height);
        }
    } else {
        draw_uncompressed(img, data, x, y, color, color ? DRAW_TYPE_SET : DRAW_TYPE_NONE);
    }
}

static int text_draw(char *str, int x, int y, int font, color_t color)
{
    struct font_definition_t *def = &font_data.font_definitions[font];

    int length = string_length(str);
    if (input_cursor.capture) {
        str += input_cursor.text_offset_start;
        length = input_cursor.text_offset_end - input_cursor.text_offset_start;
    }
    int current_x = x;
    while (length > 0) {
        if (*str >= ' ') {
            int letter_id = font_letter_id(def, str);
            int width;
            if (*str == ' ' || *str == '_' || letter_id < 0) {
                width = def->space_width;
            } else {
                struct image_t *img = image_letter(letter_id);
                int height = def->image_y_offset(*str, img->height, def->line_height);
                image_draw_letter(letter_id, current_x, y - height, color);
                width = def->letter_spacing + img->width;
            }
            if (input_cursor.capture && input_cursor.position == input_cursor.cursor_position) {
                if (!input_cursor.seen) {
                    input_cursor.width = width;
                    input_cursor.x_offset = current_x - x;
                    input_cursor.seen = 1;
                }
            }
            current_x += width;
        }
        str += 1;
        length -= 1;
        input_cursor.position += 1;
    }
    if (input_cursor.capture && !input_cursor.seen) {
        input_cursor.width = 4;
        input_cursor.x_offset = current_x - x;
        input_cursor.seen = 1;
    }
    current_x += def->space_width;
    return current_x - x;
}

static int text_draw_number_colored(int value, char prefix, char *postfix, int x_offset, int y_offset, int font, color_t color)
{
    char str[NUMBER_BUFFER_LENGTH];
    number_to_string(str, value, prefix, postfix);
    return text_draw(str, x_offset, y_offset, font, color);
}

static void graphics_draw_horizontal_line(int x1, int x2, int y, color_t color)
{
    if (y < clip_rectangle.y_start || y >= clip_rectangle.y_end) {
        return;
    }
    int x_min = x1 < x2 ? x1 : x2;
    int x_max = x1 < x2 ? x2 : x1;
    x_min = x_min < clip_rectangle.x_start ? clip_rectangle.x_start : x_min;
    x_max = x_max >= clip_rectangle.x_end ? clip_rectangle.x_end - 1 : x_max;
    color_t *pixel = graphics_get_pixel(x_min, y);
    color_t *end_pixel = pixel + (x_max - x_min);
    while (pixel <= end_pixel) {
        *pixel = color;
        ++pixel;
    }
}

static void graphics_fill_rect(int x, int y, int width, int height, color_t color)
{
    for (int yy = y; yy < height + y; yy++) {
        graphics_draw_horizontal_line(x, x + width - 1, yy, color);
    }
}

static   char *string_from_ascii(char *str)
{
    char *s = str;
    while (*s) {
        if (*s & 0x80) {
            return 0;
        }
        s++;
    }
    return (char *) str;
}

static void string_copy(char *src, char *dst, int maxlength)
{
    int length = 0;
    while (length < maxlength && *src) {
        *dst = *src;
        src++;
        dst++;
        length++;
    }
    if (length == maxlength) {
        dst--;
    }
    *dst = 0;
}

static void city_warning_show_custom(char *text)
{
    if (!settings_values[SETTINGS_WARNINGS_ENABLED]) {
        return;
    }
    struct warning *w = 0;
    for (int i = 0; i < MAX_WARNINGS; i++) {
        if (!warnings[i].in_use) {
            w = &warnings[i];
            break;
        }
    }
    if (w) {
        w->in_use = 1;
        w->time = current_time;
        string_copy(text, w->text, MAX_TEXT);
    }
}

static void show_saved_notice(char *filename)
{
    char notice_text[FILE_NAME_MAX] = "Screenshot saved: ";
    int prefix_length = string_length("Screenshot saved: ");
    string_copy(string_from_ascii(filename), &notice_text[prefix_length], FILE_NAME_MAX - prefix_length);
    city_warning_show_custom(notice_text);
}

static void pixel(color_t input, uint8_t *r, uint8_t *g, uint8_t *b)
{
    color_t rr = (input & 0xff0000) >> 16;
    color_t gg = (input & 0x00ff00) >> 8;
    color_t bb = (input & 0x0000ff) >> 0;
    *r = (uint8_t) rr;
    *g = (uint8_t) gg;
    *b = (uint8_t) bb;
}

static int check_size(struct buffer_t *buf, int size)
{
    if (buf->index + size > buf->size) {
        buf->overflow = 1;
        return 0;
    }
    return 1;
}

static void buffer_write_i32(struct buffer_t *buf, int32_t value)
{
    if (check_size(buf, 4)) {
        buf->data[buf->index++] = value & 0xff;
        buf->data[buf->index++] = (value >> 8) & 0xff;
        buf->data[buf->index++] = (value >> 16) & 0xff;
        buf->data[buf->index++] = (value >> 24) & 0xff;
    }
}

static void buffer_write_i16(struct buffer_t *buf, int16_t value)
{
    if (check_size(buf, 2)) {
        buf->data[buf->index++] = value & 0xff;
        buf->data[buf->index++] = (value >> 8) & 0xff;
    }
}

static void buffer_write_i8(struct buffer_t *buf, int8_t value)
{
    if (check_size(buf, 1)) {
        buf->data[buf->index++] = value & 0xff;
    }
}

static void write_bmp_header(struct buffer_t *buf, int full_height)
{
    buffer_write_i8(buf, 'B');
    buffer_write_i8(buf, 'M');
    buffer_write_i32(buf, HEADER_SIZE_BMP + bmp_chunk.scanline_size * full_height); // file size
    buffer_write_i32(buf, 0); // reserved
    buffer_write_i32(buf, HEADER_SIZE_BMP); // data offset
    buffer_write_i32(buf, 12); // dib size
    buffer_write_i16(buf, (int16_t) bmp_chunk.width);
    buffer_write_i16(buf, (int16_t) full_height);
    buffer_write_i16(buf, 1); // planes
    buffer_write_i16(buf, BMP_BITS_PER_PIXEL);
}

static   char *generate_filename(int city_screenshot)
{
    static char filename[FILE_NAME_MAX];
    time_t curtime = time(0);
    struct tm *loctime = localtime(&curtime);
    strftime(filename, FILE_NAME_MAX, filename_formats[city_screenshot], loctime);
    return filename;
}

static void free_bmp_chunk(void)
{
    bmp_chunk.width = 0;
    bmp_chunk.height = 0;
    bmp_chunk.scanline_size = 0;
    free(bmp_chunk.pixels);
    bmp_chunk.pixels = 0;
}

static int create_bmp_chunk(int width, int height)
{
    free(bmp_chunk.pixels);
    if (!width || !height) {
        return 0;
    }
    int scanline_padding = 4 - (width * BMP_BYTES_PER_PIXEL) % 4;
    if (scanline_padding == 4) {
        scanline_padding = 0;
    }
    bmp_chunk.width = width;
    bmp_chunk.height = height;
    bmp_chunk.scanline_size = width * BMP_BYTES_PER_PIXEL + scanline_padding;
    bmp_chunk.pixels = (uint8_t *) malloc(bmp_chunk.scanline_size * height);
    if (!bmp_chunk.pixels) {
        free_bmp_chunk();
        return 0;
    }
    memset(bmp_chunk.pixels, 0, bmp_chunk.scanline_size * height);
    return 1;
}

static void buffer_init(struct buffer_t *buf, void *data, int size)
{
    buf->data = data;
    buf->size = size;
    buf->index = 0;
    buf->overflow = 0;
}

static void check_camera_boundaries(void)
{
    int x_min = (VIEW_X_MAX - map_data.width) / 2;
    int y_min = (VIEW_Y_MAX - 2 * map_data.height) / 2;
    if (view_data.camera.tile.x < x_min - 1) {
        view_data.camera.tile.x = x_min - 1;
        view_data.camera.pixel.x = 0;
    }
    if (view_data.camera.tile.x >= VIEW_X_MAX - x_min - view_data.viewport.width_tiles) {
        view_data.camera.tile.x = VIEW_X_MAX - x_min - view_data.viewport.width_tiles;
        view_data.camera.pixel.x = 0;
    }
    if (view_data.camera.tile.y < y_min - 2) {
        view_data.camera.tile.y = y_min - 1;
        view_data.camera.pixel.y = 0;
    }
    if (view_data.camera.tile.y >= ((VIEW_Y_MAX - y_min - view_data.viewport.height_tiles) & ~1)) {
        view_data.camera.tile.y = VIEW_Y_MAX - y_min - view_data.viewport.height_tiles;
        view_data.camera.pixel.y = 0;
    }
    view_data.camera.tile.y &= ~1;
}

static void city_view_set_camera_from_pixel_position(int x, int y)
{
    x = x < 0 ? 0 : x;
    y = y < 0 ? 0 : y;

    view_data.camera.tile.x = x / TILE_WIDTH_PIXELS;
    view_data.camera.tile.y = y / HALF_TILE_HEIGHT_PIXELS;
    view_data.camera.pixel.x = x % TILE_WIDTH_PIXELS;
    view_data.camera.pixel.y = y % TILE_HEIGHT_PIXELS;
    check_camera_boundaries();
}

static void graphics_set_clip_rectangle(int x, int y, int width, int height)
{
    clip_rectangle.x_start = x;
    clip_rectangle.x_end = x + width;
    clip_rectangle.y_start = y;
    clip_rectangle.y_end = y + height;
    // fix clip rectangle going over the edges of the screen
    if (translation.x + clip_rectangle.x_start < 0) {
        clip_rectangle.x_start = -translation.x;
    }
    if (translation.y + clip_rectangle.y_start < 0) {
        clip_rectangle.y_start = -translation.y;
    }
    if (translation.x + clip_rectangle.x_end > canvas.width) {
        clip_rectangle.x_end = canvas.width - translation.x;
    }
    if (translation.y + clip_rectangle.y_end > canvas.height) {
        clip_rectangle.y_end = canvas.height - translation.y;
    }
}

static void set_viewport(int x_offset, int y_offset, int width, int height)
{
    view_data.viewport.x = x_offset;
    view_data.viewport.y = y_offset;
    view_data.viewport.width_pixels = width - 2;
    view_data.viewport.height_pixels = height;
    view_data.viewport.width_tiles = width / TILE_WIDTH_PIXELS;
    view_data.viewport.height_tiles = height / HALF_TILE_HEIGHT_PIXELS;
}

static void city_warning_clear_all(void)
{
    for (int i = 0; i < MAX_WARNINGS; i++) {
        warnings[i].in_use = 0;
    }
}

static void window_invalidate(void)
{
    window_data.refresh_immediate = 1;
    window_data.refresh_on_draw = 1;
}

static void screen_set_resolution(int width, int height)
{
    screen_data.width = width;
    screen_data.height = height;
    screen_data.dialog_offset.x = (width - 640) / 2;
    screen_data.dialog_offset.y = (height - 480) / 2;

    canvas.pixels = (color_t *) malloc((size_t) width * height * sizeof(color_t));
    if (!canvas.pixels) {
        return;
    }

    memset(canvas.pixels, 0, (size_t) width * height * sizeof(color_t));
    canvas.width = width;
    canvas.height = height;

    graphics_set_clip_rectangle(0, 0, width, height);

    view_data.screen_width = width;
    view_data.screen_height = height;
    if (view_data.sidebar_collapsed) {
        set_viewport(0, TOP_MENU_HEIGHT, view_data.screen_width - 40, view_data.screen_height - TOP_MENU_HEIGHT);
    } else {
        set_viewport(0, TOP_MENU_HEIGHT, view_data.screen_width - 160, view_data.screen_height - TOP_MENU_HEIGHT);
    }
    check_camera_boundaries();
    city_warning_clear_all();
    window_invalidate();
}

static   char *build_message(char *msg, char *param_str, int param_int)
{
    int index = 0;
    index += snprintf(&log_buffer[index], MSG_SIZE - index, "%s", msg);
    if (param_str) {
        index += snprintf(&log_buffer[index], MSG_SIZE - index, "  %s", param_str);
    }
    if (param_int) {
        snprintf(&log_buffer[index], MSG_SIZE - index, "  %d", param_int);
    }
    return log_buffer;
}

static int formation_legion_at_grid_offset(int grid_offset)
{
    int figure_id = map_figures.items[grid_offset];
    while (figure_id) {
        struct figure_t *f = &figures[figure_id];
        if (figure_properties[f->type].is_player_legion_unit || f->type == FIGURE_FORT_STANDARD) {
            return f->formation_id;
        }
        figure_id = f->next_figure_id_on_same_tile;
    }
    return -1;
}

static int map_grid_is_valid_offset(int grid_offset)
{
    return grid_offset >= 0 && grid_offset < GRID_SIZE * GRID_SIZE;
}

static int map_building_at(int grid_offset)
{
    return map_grid_is_valid_offset(grid_offset) ? buildings_grid.items[grid_offset] : 0;
}

static int map_terrain_is(int grid_offset, int terrain)
{
    return map_grid_is_valid_offset(grid_offset) && terrain_grid.items[grid_offset] & terrain;
}

static int map_is_bridge(int grid_offset)
{
    return map_terrain_is(grid_offset, TERRAIN_WATER) && sprite.items[grid_offset];
}

static int map_grid_delta(int x, int y)
{
    return y * GRID_SIZE + x;
}

static int get_x_bridge_tiles(int grid_offset)
{
    int tiles = 0;
    if (map_is_bridge(grid_offset + map_grid_delta(-1, 0))) {
        tiles++;
    }
    if (map_is_bridge(grid_offset + map_grid_delta(-2, 0))) {
        tiles++;
    }
    if (map_is_bridge(grid_offset + map_grid_delta(1, 0))) {
        tiles++;
    }
    if (map_is_bridge(grid_offset + map_grid_delta(2, 0))) {
        tiles++;
    }
    return tiles;
}

static int get_y_bridge_tiles(int grid_offset)
{
    int tiles = 0;
    if (map_is_bridge(grid_offset + map_grid_delta(0, -1))) {
        tiles++;
    }
    if (map_is_bridge(grid_offset + map_grid_delta(0, -2))) {
        tiles++;
    }
    if (map_is_bridge(grid_offset + map_grid_delta(0, 1))) {
        tiles++;
    }
    if (map_is_bridge(grid_offset + map_grid_delta(0, 2))) {
        tiles++;
    }
    return tiles;
}

static void map_sprite_clear_tile(int grid_offset)
{
    sprite.items[grid_offset] = 0;
}

static void map_bridge_remove(int grid_offset, int mark_deleted)
{
    if (!map_is_bridge(grid_offset)) {
        return;
    }

    int tiles_x = get_x_bridge_tiles(grid_offset);
    int tiles_y = get_y_bridge_tiles(grid_offset);

    int offset_up = tiles_x > tiles_y ? map_grid_delta(1, 0) : map_grid_delta(0, 1);
    // find lower end of the bridge
    while (map_is_bridge(grid_offset - offset_up)) {
        grid_offset -= offset_up;
    }

    if (mark_deleted) {
        bitfields_grid.items[grid_offset] |= BIT_DELETED;
    } else {
        map_sprite_clear_tile(grid_offset);
        terrain_grid.items[grid_offset] &= ~TERRAIN_ROAD;
    }
    while (map_is_bridge(grid_offset + offset_up)) {
        grid_offset += offset_up;
        if (mark_deleted) {
            bitfields_grid.items[grid_offset] |= BIT_DELETED;
        } else {
            map_sprite_clear_tile(grid_offset);
            terrain_grid.items[grid_offset] &= ~TERRAIN_ROAD;
        }
    }
}

static struct building_t *building_main(struct building_t *b)
{
    for (int guard = 0; guard < 9; guard++) {
        if (b->prev_part_building_id <= 0) {
            return b;
        }
        b = &all_buildings[b->prev_part_building_id];
    }
    return &all_buildings[0];
}

static void map_property_clear_constructing_and_deleted(void)
{
    for (int i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        bitfields_grid.items[i] &= BIT_NO_CONSTRUCTION_AND_DELETED;
    }
}

static void map_building_tiles_mark_deleting(int grid_offset)
{
    int building_id = map_building_at(grid_offset);
    if (!building_id) {
        map_bridge_remove(grid_offset, 1);
    } else {
        grid_offset = building_main(&all_buildings[building_id])->grid_offset;
    }
    bitfields_grid.items[grid_offset] |= BIT_DELETED;
}

static int city_building_ghost_mark_deleting(struct map_tile_t *tile)
{
    if (!values[CONFIG_UI_VISUAL_FEEDBACK_ON_DELETE]) {
        return 0;
    }
    int construction_type = construction_data.type;
    if (!tile->grid_offset || construction_data.draw_as_constructing ||
        scroll_data.is_scrolling || scroll_data.drag.active || construction_type != BUILDING_CLEAR_LAND) {
        return (construction_type == BUILDING_CLEAR_LAND);
    }
    if (!construction_data.in_progress) {
        map_property_clear_constructing_and_deleted();
    }
    map_building_tiles_mark_deleting(tile->grid_offset);
    return 1;
}

static void city_view_foreach_map_tile(map_callback *callback)
{
    int odd = 0;
    int y_view = view_data.camera.tile.y - 8;
    int y_graphic = view_data.viewport.y - 9 * HALF_TILE_HEIGHT_PIXELS - view_data.camera.pixel.y;
    for (int y = 0; y < view_data.viewport.height_tiles + 21; y++) {
        if (y_view >= 0 && y_view < VIEW_Y_MAX) {
            int x_graphic = -(4 * TILE_WIDTH_PIXELS) - view_data.camera.pixel.x;
            if (odd) {
                x_graphic += view_data.viewport.x - HALF_TILE_WIDTH_PIXELS;
            } else {
                x_graphic += view_data.viewport.x;
            }
            int x_view = view_data.camera.tile.x - 4;
            for (int x = 0; x < view_data.viewport.width_tiles + 7; x++) {
                if (x_view >= 0 && x_view < VIEW_X_MAX) {
                    int grid_offset = view_to_grid_offset_lookup[x_view][y_view];
                    callback(x_graphic, y_graphic, grid_offset);
                }
                x_graphic += TILE_WIDTH_PIXELS;
                x_view++;
            }
        }
        odd = 1 - odd;
        y_graphic += HALF_TILE_HEIGHT_PIXELS;
        y_view++;
    }
}

static void building_construction_record_view_position(int view_x, int view_y, int grid_offset)
{
    if (grid_offset == construction_data.start.grid_offset) {
        construction_data.start_offset_x_view = view_x;
        construction_data.start_offset_y_view = view_y;
    }
}

static int io_read_file_part_into_buffer(char *filepath, void *buffer, int size, int offset_in_file)
{
    int bytes_read = 0;
    FILE *fp = fopen(filepath, "rb");
    if (fp) {
        int seek_result = fseek(fp, offset_in_file, SEEK_SET);
        if (seek_result == 0) {
            bytes_read = (int) fread(buffer, 1, (size_t) size, fp);
        }
        fclose(fp);
    }
    return bytes_read;
}

static uint8_t buffer_read_u8(struct buffer_t *buf)
{
    if (check_size(buf, 1)) {
        return buf->data[buf->index++];
    } else {
        return 0;
    }
}

static color_t to_32_bit(uint16_t c)
{
    return ((c & 0x7c00) << 9) | ((c & 0x7000) << 4) |
        ((c & 0x3e0) << 6) | ((c & 0x380) << 1) |
        ((c & 0x1f) << 3) | ((c & 0x1c) >> 2);
}

static uint16_t buffer_read_u16(struct buffer_t *buf)
{
    if (check_size(buf, 2)) {
        uint8_t b0 = buf->data[buf->index++];
        uint8_t b1 = buf->data[buf->index++];
        return (uint16_t) (b0 | (b1 << 8));
    } else {
        return 0;
    }
}

static int convert_compressed(struct buffer_t *buf, int buf_length, color_t *dst)
{
    int dst_length = 0;
    while (buf_length > 0) {
        int control = buffer_read_u8(buf);
        if (control == 255) {
            // next byte = transparent pixels to skip
            *dst++ = 255;
            *dst++ = buffer_read_u8(buf);
            dst_length += 2;
            buf_length -= 2;
        } else {
            // control = number of concrete pixels
            *dst++ = control;
            for (int i = 0; i < control; i++) {
                *dst++ = to_32_bit(buffer_read_u16(buf));
            }
            dst_length += control + 1;
            buf_length -= control * 2 + 1;
        }
    }
    return dst_length;
}

static int convert_uncompressed(struct buffer_t *buf, int buf_length, color_t *dst)
{
    for (int i = 0; i < buf_length; i += 2) {
        *dst = to_32_bit(buffer_read_u16(buf));
        dst++;
    }
    return buf_length / 2;
}

static void file_change_extension(char *filename, const char *new_extension)
{
    char c;
    do {
        c = *filename;
        filename++;
    } while (c != '.' && c);
    if (c == '.') {
        filename[0] = new_extension[0];
        filename[1] = new_extension[1];
        filename[2] = new_extension[2];
        filename[3] = 0;
    }
}

static color_t *image_data(int id)
{
    if (id < 0 || id >= MAIN_ENTRIES) {
        return 0;
    }
    if (!image_data_s.main[id].draw.is_external) {
        return &image_data_s.main_data[image_data_s.main[id].draw.offset];
    } else if (id == image_data_s.group_image_ids[GROUP_EMPIRE_MAP]) {
        return image_data_s.empire_data;
    } else {
        struct image_t *img = &image_data_s.main[id];
        char filename[FILE_NAME_MAX] = "555/";
        string_copy(image_data_s.bitmaps[img->draw.bitmap_id], &filename[4], FILE_NAME_MAX - 6);
        file_change_extension(filename, "555");
        int size = io_read_file_part_into_buffer(
            &filename[4], image_data_s.tmp_data,
            img->draw.data_length, img->draw.offset - 1
        );
        if (!size) {
            // try in 555 dir
            size = io_read_file_part_into_buffer(
                filename, image_data_s.tmp_data,
                img->draw.data_length, img->draw.offset - 1
            );
            if (!size) {
                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("unable to load external image", image_data_s.bitmaps[img->draw.bitmap_id], id));
                return 0;
            }
        }
        struct buffer_t buf;
        buffer_init(&buf, image_data_s.tmp_data, size);
        color_t *dst = (color_t *) &image_data_s.tmp_data[4000000];
        // NB: isometric images are never external
        if (img->draw.is_fully_compressed) {
            convert_compressed(&buf, img->draw.data_length, dst);
        } else {
            convert_uncompressed(&buf, img->draw.data_length, dst);
        }
        return dst;
    }
}

static void draw_footprint_tile(color_t *data, int x_offset, int y_offset, color_t color_mask)
{
    if (!color_mask) {
        color_mask = COLOR_MASK_NONE;
    }
    struct clip_info_t *clip = graphics_get_clip_info(x_offset, y_offset, FOOTPRINT_WIDTH, FOOTPRINT_HEIGHT);
    if (!clip || !clip->is_visible) {
        return;
    }
    // If the current tile neither clipped nor color masked, just draw it normally
    if (clip->clip_y == CLIP_NONE && clip->clip_x == CLIP_NONE && color_mask == COLOR_MASK_NONE) {
        memcpy(graphics_get_pixel(x_offset + 28, y_offset + 0), &data[0], 2 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 26, y_offset + 1), &data[2], 6 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 24, y_offset + 2), &data[8], 10 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 22, y_offset + 3), &data[18], 14 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 20, y_offset + 4), &data[32], 18 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 18, y_offset + 5), &data[50], 22 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 16, y_offset + 6), &data[72], 26 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 14, y_offset + 7), &data[98], 30 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 12, y_offset + 8), &data[128], 34 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 10, y_offset + 9), &data[162], 38 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 8, y_offset + 10), &data[200], 42 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 6, y_offset + 11), &data[242], 46 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 4, y_offset + 12), &data[288], 50 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 2, y_offset + 13), &data[338], 54 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 0, y_offset + 14), &data[392], 58 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 0, y_offset + 15), &data[450], 58 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 2, y_offset + 16), &data[508], 54 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 4, y_offset + 17), &data[562], 50 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 6, y_offset + 18), &data[612], 46 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 8, y_offset + 19), &data[658], 42 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 10, y_offset + 20), &data[700], 38 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 12, y_offset + 21), &data[738], 34 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 14, y_offset + 22), &data[772], 30 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 16, y_offset + 23), &data[802], 26 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 18, y_offset + 24), &data[828], 22 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 20, y_offset + 25), &data[850], 18 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 22, y_offset + 26), &data[868], 14 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 24, y_offset + 27), &data[882], 10 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 26, y_offset + 28), &data[892], 6 * sizeof(color_t));
        memcpy(graphics_get_pixel(x_offset + 28, y_offset + 29), &data[898], 2 * sizeof(color_t));
        return;
    }
    int clip_left = clip->clip_x == CLIP_LEFT || clip->clip_x == CLIP_BOTH;
    int clip_right = clip->clip_x == CLIP_RIGHT || clip->clip_x == CLIP_BOTH;
    color_t *src = &data[FOOTPRINT_OFFSET_PER_HEIGHT[clip->clipped_pixels_top]];
    for (int y = clip->clipped_pixels_top; y < clip->clipped_pixels_top + clip->visible_pixels_y; y++) {
        int x_start = FOOTPRINT_X_START_PER_HEIGHT[y];
        int x_max = 58 - x_start * 2;
        int x_pixel_advance = 0;
        if (clip_left) {
            if (clip->clipped_pixels_left + clip->visible_pixels_x < x_start) {
                src += x_max;
                continue;
            }
            if (clip->clipped_pixels_left > x_start) {
                int pixels_to_reduce = clip->clipped_pixels_left - x_start;
                if (pixels_to_reduce >= x_max) {
                    src += x_max;
                    continue;
                }
                src += pixels_to_reduce;
                x_max -= pixels_to_reduce;
                x_start = clip->clipped_pixels_left;
            }
        }
        if (clip_right) {
            int clip_x = 58 - clip->clipped_pixels_right;
            if (clip_x < x_start) {
                src += x_max;
                continue;
            }
            if (x_start + x_max > clip_x) {
                int temp_x_max = clip_x - x_start;
                x_pixel_advance = x_max - temp_x_max;
                x_max = temp_x_max;
            }
        }
        color_t *buffer = graphics_get_pixel(x_offset + x_start, y_offset + y);
        if (color_mask == COLOR_MASK_NONE) {
            memcpy(buffer, src, x_max * sizeof(color_t));
            src += x_max + x_pixel_advance;
        } else {
            for (int x = 0; x < x_max; x++, buffer++, src++) {
                *buffer = *src & color_mask;
            }
            src += x_pixel_advance;
        }
    }
}

static   color_t *tile_data(color_t *data, int index)
{
    return &data[900 * index];
}

static void draw_footprint_size1(int image_id, int x, int y, color_t color_mask)
{
    color_t *data = image_data(image_id);
    draw_footprint_tile(tile_data(data, 0), x, y, color_mask);
}

static void draw_footprint_size2(int image_id, int x, int y, color_t color_mask)
{
    color_t *data = image_data(image_id);
    int index = 0;
    draw_footprint_tile(tile_data(data, index++), x, y, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 30, y + 15, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 30, y + 15, color_mask);
    draw_footprint_tile(tile_data(data, index++), x, y + 30, color_mask);
}

static void draw_footprint_size3(int image_id, int x, int y, color_t color_mask)
{
    color_t *data = image_data(image_id);
    int index = 0;
    draw_footprint_tile(tile_data(data, index++), x, y, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 30, y + 15, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 30, y + 15, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 60, y + 30, color_mask);
    draw_footprint_tile(tile_data(data, index++), x, y + 30, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 60, y + 30, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 30, y + 45, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 30, y + 45, color_mask);
    draw_footprint_tile(tile_data(data, index++), x, y + 60, color_mask);
}

static void draw_footprint_size4(int image_id, int x, int y, color_t color_mask)
{
    color_t *data = image_data(image_id);
    int index = 0;
    draw_footprint_tile(tile_data(data, index++), x, y, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 30, y + 15, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 30, y + 15, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 60, y + 30, color_mask);
    draw_footprint_tile(tile_data(data, index++), x, y + 30, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 60, y + 30, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 90, y + 45, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 30, y + 45, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 30, y + 45, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 90, y + 45, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 60, y + 60, color_mask);
    draw_footprint_tile(tile_data(data, index++), x, y + 60, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 60, y + 60, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 30, y + 75, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 30, y + 75, color_mask);
    draw_footprint_tile(tile_data(data, index++), x, y + 90, color_mask);
}

static void draw_footprint_size5(int image_id, int x, int y, color_t color_mask)
{
    color_t *data = image_data(image_id);
    int index = 0;
    draw_footprint_tile(tile_data(data, index++), x, y, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 30, y + 15, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 30, y + 15, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 60, y + 30, color_mask);
    draw_footprint_tile(tile_data(data, index++), x, y + 30, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 60, y + 30, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 90, y + 45, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 30, y + 45, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 30, y + 45, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 90, y + 45, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 120, y + 60, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 60, y + 60, color_mask);
    draw_footprint_tile(tile_data(data, index++), x, y + 60, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 60, y + 60, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 120, y + 60, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 90, y + 75, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 30, y + 75, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 30, y + 75, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 90, y + 75, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 60, y + 90, color_mask);
    draw_footprint_tile(tile_data(data, index++), x, y + 90, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 60, y + 90, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 30, y + 105, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 30, y + 105, color_mask);
    draw_footprint_tile(tile_data(data, index++), x, y + 120, color_mask);
}

static struct image_t *image_get(int id)
{
    if (id >= 0 && id < MAIN_ENTRIES) {
        return &image_data_s.main[id];
    } else {
        return 0;
    }
}

static void image_draw_isometric_footprint_from_draw_tile(int image_id, int x, int y, color_t color_mask)
{
    struct image_t *img = image_get(image_id);
    if (img->draw.type != IMAGE_TYPE_ISOMETRIC) {
        return;
    }
    switch (img->width) {
        case 58:
            draw_footprint_size1(image_id, x, y, color_mask);
            break;
        case 118:
            draw_footprint_size2(image_id, x + 30, y - 15, color_mask);
            break;
        case 178:
            draw_footprint_size3(image_id, x + 60, y - 30, color_mask);
            break;
        case 238:
            draw_footprint_size4(image_id, x + 90, y - 45, color_mask);
            break;
        case 298:
            draw_footprint_size5(image_id, x + 120, y - 60, color_mask);
            break;
    }
}

static void city_view_get_viewport(int *x, int *y, int *width, int *height)
{
    *x = view_data.viewport.x;
    *y = view_data.viewport.y;
    *width = view_data.viewport.width_pixels;
    *height = view_data.viewport.height_pixels;
}

static int draw_building_as_deleted_2(struct building_t *b)
{
    b = building_main(b);
    return (b->id && (b->is_deleted || bitfields_grid.items[b->grid_offset] & BIT_DELETED));
}

static int building_is_house(int type)
{
    return type >= BUILDING_HOUSE_VACANT_LOT && type <= BUILDING_HOUSE_LUXURY_PALACE;
}

static int building_is_fort(int type)
{
    return type >= BUILDING_FORT_LEGIONARIES && type <= BUILDING_FORT_MOUNTED;
}

static void city_sounds__mark_building_view(int type, int num_workers, int direction)
{
    // mute city sounds during invasion
    if (city_data.figure.enemies || city_data.figure.imperial_soldiers) {
        return;
    }
    if (num_workers > 0
    || building_is_house(type)
    || type == BUILDING_RESERVOIR || type == BUILDING_AQUEDUCT || type == BUILDING_WELL || type == BUILDING_GARDENS
    || building_is_fort(type)) {
        int channel = building_properties[type].sound_channel;
        if (!channel) {
            return;
        }
        channels[channel].available = 1;
        ++channels[channel].total_views;
        ++channels[channel].direction_views[direction];
    }
}

static void draw_footprint_without_overlay(int x, int y, int grid_offset)
{
    building_construction_record_view_position(x, y, grid_offset);
    if (grid_offset < 0) {
        // Outside map: draw black tile
        image_draw_isometric_footprint_from_draw_tile(image_data_s.group_image_ids[GROUP_TERRAIN_BLACK], x, y, 0);
    } else if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
        // Valid grid_offset and leftmost tile -> draw
        int building_id = map_building_at(grid_offset);
        color_t color_mask = 0;
        if (building_id || map_terrain_is(grid_offset, TERRAIN_GARDEN) || map_terrain_is(grid_offset, TERRAIN_AQUEDUCT)) {
            int view_x, view_y, view_width, view_height;
            city_view_get_viewport(&view_x, &view_y, &view_width, &view_height);
            if (building_id) {
                struct building_t *b = &all_buildings[building_id];
                if (draw_building_as_deleted_2(b)) {
                    color_mask = COLOR_MASK_RED;
                }
                if (x < view_x + 100) {
                    city_sounds__mark_building_view(b->type, b->num_workers, SOUND_DIRECTION_LEFT);
                } else if (x > view_x + view_width - 100) {
                    city_sounds__mark_building_view(b->type, b->num_workers, SOUND_DIRECTION_RIGHT);
                } else {
                    city_sounds__mark_building_view(b->type, b->num_workers, SOUND_DIRECTION_CENTER);
                }
            } else if (map_terrain_is(grid_offset, TERRAIN_GARDEN)) {
                if (x < view_x + 100) {
                    city_sounds__mark_building_view(BUILDING_GARDENS, 0, SOUND_DIRECTION_LEFT);
                } else if (x > view_x + view_width - 100) {
                    city_sounds__mark_building_view(BUILDING_GARDENS, 0, SOUND_DIRECTION_RIGHT);
                } else {
                    city_sounds__mark_building_view(BUILDING_GARDENS, 0, SOUND_DIRECTION_CENTER);
                }
            } else if (map_terrain_is(grid_offset, TERRAIN_AQUEDUCT)) {
                if (x < view_x + 100) {
                    city_sounds__mark_building_view(BUILDING_AQUEDUCT, 0, SOUND_DIRECTION_LEFT);
                } else if (x > view_x + view_width - 100) {
                    city_sounds__mark_building_view(BUILDING_AQUEDUCT, 0, SOUND_DIRECTION_RIGHT);
                } else {
                    city_sounds__mark_building_view(BUILDING_AQUEDUCT, 0, SOUND_DIRECTION_CENTER);
                }
            }
        }
        int image_id = images.items[grid_offset];
        if (bitfields_grid.items[grid_offset] & BIT_CONSTRUCTION) {
            image_id = image_data_s.group_image_ids[GROUP_TERRAIN_OVERLAY];
        }
        if (draw_context.advance_water_animation &&
            image_id >= draw_context.image_id_water_first &&
            image_id <= draw_context.image_id_water_last) {
            image_id++;
            if (image_id > draw_context.image_id_water_last) {
                image_id = draw_context.image_id_water_first;
            }
            images.items[grid_offset] = image_id;
        }
        image_draw_isometric_footprint_from_draw_tile(image_id, x, y, color_mask);
    }
}

static void city_view_foreach_valid_map_tile(map_callback *callback1, map_callback *callback2, map_callback *callback3)
{
    int odd = 0;
    int y_view = view_data.camera.tile.y - 8;
    int y_graphic = view_data.viewport.y - 9 * HALF_TILE_HEIGHT_PIXELS - view_data.camera.pixel.y;
    int x_graphic, x_view;
    for (int y = 0; y < view_data.viewport.height_tiles + 21; y++) {
        if (y_view >= 0 && y_view < VIEW_Y_MAX) {
            if (callback1) {
                x_graphic = -(4 * TILE_WIDTH_PIXELS) - view_data.camera.pixel.x;
                if (odd) {
                    x_graphic += view_data.viewport.x - HALF_TILE_WIDTH_PIXELS;
                } else {
                    x_graphic += view_data.viewport.x;
                }
                x_view = view_data.camera.tile.x - 4;
                for (int x = 0; x < view_data.viewport.width_tiles + 7; x++) {
                    if (x_view >= 0 && x_view < VIEW_X_MAX) {
                        int grid_offset = view_to_grid_offset_lookup[x_view][y_view];
                        if (grid_offset >= 0) {
                            callback1(x_graphic, y_graphic, grid_offset);
                        }
                    }
                    x_graphic += TILE_WIDTH_PIXELS;
                    x_view++;
                }
            }
            if (callback2) {
                x_graphic = -(4 * TILE_WIDTH_PIXELS) - view_data.camera.pixel.x;
                if (odd) {
                    x_graphic += view_data.viewport.x - HALF_TILE_WIDTH_PIXELS;
                } else {
                    x_graphic += view_data.viewport.x;
                }
                x_view = view_data.camera.tile.x - 4;
                for (int x = 0; x < view_data.viewport.width_tiles + 7; x++) {
                    if (x_view >= 0 && x_view < VIEW_X_MAX) {
                        int grid_offset = view_to_grid_offset_lookup[x_view][y_view];
                        if (grid_offset >= 0) {
                            callback2(x_graphic, y_graphic, grid_offset);
                        }
                    }
                    x_graphic += TILE_WIDTH_PIXELS;
                    x_view++;
                }
            }
            if (callback3) {
                x_graphic = -(4 * TILE_WIDTH_PIXELS) - view_data.camera.pixel.x;
                if (odd) {
                    x_graphic += view_data.viewport.x - HALF_TILE_WIDTH_PIXELS;
                } else {
                    x_graphic += view_data.viewport.x;
                }
                x_view = view_data.camera.tile.x - 4;
                for (int x = 0; x < view_data.viewport.width_tiles + 7; x++) {
                    if (x_view >= 0 && x_view < VIEW_X_MAX) {
                        int grid_offset = view_to_grid_offset_lookup[x_view][y_view];
                        if (grid_offset >= 0) {
                            callback3(x_graphic, y_graphic, grid_offset);
                        }
                    }
                    x_graphic += TILE_WIDTH_PIXELS;
                    x_view++;
                }
            }
        }
        odd = 1 - odd;
        y_graphic += HALF_TILE_HEIGHT_PIXELS;
        y_view++;
    }
}

static int map_property_multi_tile_size(int grid_offset)
{
    switch (bitfields_grid.items[grid_offset] & BIT_SIZES) {
        case BIT_SIZE2: return 2;
        case BIT_SIZE3: return 3;
        case BIT_SIZE4: return 4;
        case BIT_SIZE5: return 5;
        default: return 1;
    }
}

static int is_multi_tile_terrain(int grid_offset)
{
    return !map_building_at(grid_offset) && map_property_multi_tile_size(grid_offset) > 1;
}

static void draw_compressed_and(struct image_t *img, color_t *data, int x_offset, int y_offset, int height, color_t color)
{
    struct clip_info_t *clip = graphics_get_clip_info(x_offset, y_offset, img->width, height);
    if (!clip || !clip->is_visible) {
        return;
    }
    int unclipped = clip->clip_x == CLIP_NONE;

    for (int y = 0; y < height - clip->clipped_pixels_bottom; y++) {
        int x = 0;
        while (x < img->width) {
            color_t b = *data;
            data++;
            if (b == 255) {
                // transparent pixels to skip
                x += *data;
                data++;
            } else if (y < clip->clipped_pixels_top) {
                data += b;
                x += b;
            } else {
                // number of concrete pixels
                color_t *pixels = data;
                data += b;
                color_t *dst = graphics_get_pixel(x_offset + x, y_offset + y);
                if (unclipped) {
                    x += b;
                    while (b) {
                        *dst = *pixels & color;
                        dst++;
                        pixels++;
                        b--;
                    }
                } else {
                    while (b) {
                        if (x >= clip->clipped_pixels_left && x < img->width - clip->clipped_pixels_right) {
                            *dst = *pixels & color;
                        }
                        dst++;
                        x++;
                        pixels++;
                        b--;
                    }
                }
            }
        }
    }
}

static void image_draw_isometric_top_from_draw_tile(int image_id, int x, int y, color_t color_mask)
{
    struct image_t *img = image_get(image_id);
    if (img->draw.type != IMAGE_TYPE_ISOMETRIC) {
        return;
    }
    if (!img->draw.has_compressed_part) {
        return;
    }
    color_t *data = &image_data(image_id)[img->draw.uncompressed_length];

    int height = img->height;
    switch (img->width) {
        case 58:
            y -= img->height - 30;
            height -= 16;
            break;
        case 118:
            y -= img->height - 45;
            height -= 31;
            break;
        case 178:
            y -= img->height - 60;
            height -= 46;
            break;
        case 238:
            y -= img->height - 75;
            height -= 61;
            break;
        case 298:
            y -= img->height - 90;
            height -= 76;
            break;
    }
    if (!color_mask) {
        draw_compressed(img, data, x, y, height);
    } else {
        draw_compressed_and(img, data, x, y, height, color_mask);
    }
}

static void image_draw_masked(int image_id, int x, int y, color_t color_mask)
{
    struct image_t *img = image_get(image_id);
    color_t *data = image_data(image_id);
    if (!data) {
        return;
    }

    if (img->draw.type == IMAGE_TYPE_ISOMETRIC) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("use image_draw_isometric_footprint for isometric!", 0, image_id));
        return;
    }

    if (img->draw.is_fully_compressed) {
        if (!color_mask) {
            draw_compressed(img, data, x, y, img->height);
        } else {
            draw_compressed_and(img, data, x, y, img->height, color_mask);
        }
    } else {
        draw_uncompressed(img, data, x, y,
                              color_mask, color_mask ? DRAW_TYPE_AND : DRAW_TYPE_NONE);
    }
}

static void draw_top_without_overlay(int x, int y, int grid_offset)
{
    if (!(edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE)) {
        return;
    }
    struct building_t *b = &all_buildings[map_building_at(grid_offset)];
    int image_id = images.items[grid_offset];
    color_t color_mask = 0;
    if (draw_building_as_deleted_2(b) || (bitfields_grid.items[grid_offset] & BIT_DELETED && !is_multi_tile_terrain(grid_offset))) {
        color_mask = COLOR_MASK_RED;
    }
    image_draw_isometric_top_from_draw_tile(image_id, x, y, color_mask);
    // specific buildings
    if (b->type == BUILDING_SENATE) {
        // rating flags
        image_id = image_data_s.group_image_ids[GROUP_BUILDING_SENATE];
        image_draw_masked(image_id + 1, x + 138, y + 44 - city_data.ratings.culture / 2, color_mask);
        image_draw_masked(image_id + 2, x + 168, y + 36 - city_data.ratings.prosperity / 2, color_mask);
        image_draw_masked(image_id + 3, x + 198, y + 27 - city_data.ratings.peace / 2, color_mask);
        image_draw_masked(image_id + 4, x + 228, y + 19 - city_data.ratings.favor / 2, color_mask);
        // unemployed
        image_id = image_data_s.group_image_ids[GROUP_FIGURE_HOMELESS];
        int unemployment_pct = city_data.labor.unemployment_percentage_for_senate;
        if (unemployment_pct > 0) {
            image_draw_masked(image_id + 108, x + 80, y, color_mask);
        }
        if (unemployment_pct > 5) {
            image_draw_masked(image_id + 104, x + 230, y - 30, color_mask);
        }
        if (unemployment_pct > 10) {
            image_draw_masked(image_id + 107, x + 100, y + 20, color_mask);
        }
        if (unemployment_pct > 15) {
            image_draw_masked(image_id + 106, x + 235, y - 10, color_mask);
        }
        if (unemployment_pct > 20) {
            image_draw_masked(image_id + 106, x + 66, y + 20, color_mask);
        }
    }
    if (b->type == BUILDING_AMPHITHEATER && b->num_workers > 0) {
        image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_AMPHITHEATER_SHOW], x + 36, y - 47, color_mask);
    }
    if (b->type == BUILDING_THEATER && b->num_workers > 0) {
        image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_THEATER_SHOW], x + 34, y - 22, color_mask);
    }
    if (b->type == BUILDING_COLOSSEUM && b->num_workers > 0) {
        image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_COLOSSEUM_SHOW], x + 70, y - 90, color_mask);
    }
    if (b->type == BUILDING_HIPPODROME && building_main(b)->num_workers > 0 && city_data.entertainment.hippodrome_has_race) {
        int subtype = b->subtype.orientation;
        int orientation = view_data.orientation;
        if ((subtype == 0 || subtype == 3) && city_data.population.population > 2000) {
            // first building part
            switch (orientation) {
                case DIR_0_TOP:
                    image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_HIPPODROME_2] + 6, x + 147, y - 72, color_mask);
                    break;
                case DIR_2_RIGHT:
                    image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_HIPPODROME_1] + 8, x + 58, y - 79, color_mask);
                    break;
                case DIR_4_BOTTOM:
                    image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_HIPPODROME_2] + 8, x + 119, y - 80, color_mask);
                    break;
                case DIR_6_LEFT:
                    image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_HIPPODROME_1] + 6, x, y - 72, color_mask);
            }
        } else if ((subtype == 1 || subtype == 4) && city_data.population.population > 100) {
            // middle building part
            switch (orientation) {
                case DIR_0_TOP:
                case DIR_4_BOTTOM:
                    image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_HIPPODROME_2] + 7, x + 122, y - 79, color_mask);
                    break;
                case DIR_2_RIGHT:
                case DIR_6_LEFT:
                    image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_HIPPODROME_1] + 7, x, y - 80, color_mask);
            }
        } else if ((subtype == 2 || subtype == 5) && city_data.population.population > 1000) {
            // last building part
            switch (orientation) {
                case DIR_0_TOP:
                    image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_HIPPODROME_2] + 8, x + 119, y - 80, color_mask);
                    break;
                case DIR_2_RIGHT:
                    image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_HIPPODROME_1] + 6, x, y - 72, color_mask);
                    break;
                case DIR_4_BOTTOM:
                    image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_HIPPODROME_2] + 6, x + 147, y - 72, color_mask);
                    break;
                case DIR_6_LEFT:
                    image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_HIPPODROME_1] + 8, x + 58, y - 79, color_mask);
                    break;
            }
        }
    }
    if (b->type == BUILDING_WINE_WORKSHOP) {
        if (b->loads_stored >= 2 || b->data.industry.has_raw_materials) {
            image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_WORKSHOP_RAW_MATERIAL], x + 45, y + 23, color_mask);
        }
    }
    if (b->type == BUILDING_OIL_WORKSHOP) {
        if (b->loads_stored >= 2 || b->data.industry.has_raw_materials) {
            image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_WORKSHOP_RAW_MATERIAL] + 1, x + 35, y + 15, color_mask);
        }
    }
    if (b->type == BUILDING_WEAPONS_WORKSHOP) {
        if (b->loads_stored >= 2 || b->data.industry.has_raw_materials) {
            image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_WORKSHOP_RAW_MATERIAL] + 3, x + 46, y + 24, color_mask);
        }
    }
    if (b->type == BUILDING_FURNITURE_WORKSHOP) {
        if (b->loads_stored >= 2 || b->data.industry.has_raw_materials) {
            image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_WORKSHOP_RAW_MATERIAL] + 2, x + 48, y + 19, color_mask);
        }
    }
    if (b->type == BUILDING_POTTERY_WORKSHOP) {
        if (b->loads_stored >= 2 || b->data.industry.has_raw_materials) {
            image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_WORKSHOP_RAW_MATERIAL] + 4, x + 47, y + 24, color_mask);
        }
    }
}

static int figure_image_normalize_direction(int direction)
{
    int normalized_direction = direction - view_data.orientation;
    if (normalized_direction < 0) {
        normalized_direction += 8;
    }
    return normalized_direction;
}

static struct image_t *image_get_enemy(struct figure_t *f)
{
    if (f->image_id < ENEMY_ENTRIES) {
        return &image_data_s.enemy[f->enemy_image_group][f->image_id];
    } else {
        return 0;
    }
}

static void adjust_pixel_offset(struct figure_t *f, int *pixel_x, int *pixel_y)
{
    // determining x/y offset on tile
    int x_offset = 0;
    int y_offset = 0;
    if (f->use_cross_country) {
        int dir = view_data.orientation;
        if (dir == DIR_0_TOP || dir == DIR_4_BOTTOM) {
            int base_pixel_x = 2 * f->cross_country_x % 15 - 2 * f->cross_country_y % 15;
            int base_pixel_y = f->cross_country_x % 15 + f->cross_country_y % 15;
            x_offset = dir == DIR_0_TOP ? base_pixel_x : -base_pixel_x;
            y_offset = dir == DIR_0_TOP ? base_pixel_y : -base_pixel_y;
        } else {
            int base_pixel_x = 2 * f->cross_country_x % 15 + 2 * f->cross_country_y % 15;
            int base_pixel_y = f->cross_country_x % 15 - f->cross_country_y % 15;
            x_offset = dir == DIR_2_RIGHT ? base_pixel_x : -base_pixel_x;
            y_offset = dir == DIR_6_LEFT ? base_pixel_y : -base_pixel_y;
        }
        y_offset -= f->missile_offset;
    } else {
        int direction = figure_image_normalize_direction(f->direction);

        if (f->progress_on_tile >= 15) {
            x_offset = 0;
        } else {
            switch (direction) {
                case DIR_0_TOP:
                case DIR_2_RIGHT:
                    x_offset = 2 * f->progress_on_tile - 28;
                    break;
                case DIR_1_TOP_RIGHT:
                    x_offset = 4 * f->progress_on_tile - 56;
                    break;
                case DIR_4_BOTTOM:
                case DIR_6_LEFT:
                    x_offset = 28 - 2 * f->progress_on_tile;
                    break;
                case DIR_5_BOTTOM_LEFT:
                    x_offset = 56 - 4 * f->progress_on_tile;
                    break;
                default:
                    x_offset = 0;
                    break;
            }
        }
        if (f->progress_on_tile >= 15) {
            y_offset = 0;
        } else {
            switch (direction) {
                case DIR_0_TOP:
                case DIR_6_LEFT:
                    y_offset = 14 - f->progress_on_tile;
                    break;
                case DIR_2_RIGHT:
                case DIR_4_BOTTOM:
                    y_offset = f->progress_on_tile - 14;
                    break;
                case DIR_3_BOTTOM_RIGHT:
                    y_offset = 2 * f->progress_on_tile - 28;
                    break;
                case DIR_7_TOP_LEFT:
                    y_offset = 28 - 2 * f->progress_on_tile;
                    break;
                default:
                    y_offset = 0;
                    break;
            }
        }
        y_offset -= f->current_height;
    }
    x_offset += 29;
    y_offset += 15;
    struct image_t *img = (figure_properties[f->type].is_native_unit || (figure_properties[f->type].is_enemy_unit && f->type != FIGURE_ENEMY_GLADIATOR)) ? image_get_enemy(f) : image_get(f->image_id);
    *pixel_x += x_offset - img->sprite_offset_x;
    *pixel_y += y_offset - img->sprite_offset_y;
}

static void image_draw(int image_id, int x, int y)
{
    struct image_t *img = image_get(image_id);
    color_t *data = image_data(image_id);
    if (!data) {
        return;
    }

    if (img->draw.is_fully_compressed) {
        draw_compressed(img, data, x, y, img->height);
    } else {
        draw_uncompressed(img, data, x, y, 0, DRAW_TYPE_NONE);
    }
}

static void image_draw_blend_alpha(int image_id, int x, int y, color_t color)
{
    struct image_t *img = image_get(image_id);
    color_t *data = image_data(image_id);
    if (!data) {
        return;
    }

    if (img->draw.type == IMAGE_TYPE_ISOMETRIC) {
        return;
    }

    if (img->draw.is_fully_compressed) {
        struct clip_info_t *clip = graphics_get_clip_info(x, y, img->width, img->height);
        if (!clip || !clip->is_visible) {
            return;
        }
        color_t alpha = COMPONENT(color, 24);
        if (!alpha) {
            return;
        }
        if (alpha == 255) {
            draw_compressed_set(img, data, x, y, img->height, color);
            return;
        }
        color_t alpha_dst = 256 - alpha;
        color_t src_rb = (color & 0xff00ff) * alpha;
        color_t src_g = (color & 0x00ff00) * alpha;
        int unclipped = clip->clip_x == CLIP_NONE;
        for (int yy = 0; yy < img->height - clip->clipped_pixels_bottom; yy++) {
            int xx = 0;
            color_t *dst = graphics_get_pixel(x, y + yy);
            while (xx < img->width) {
                color_t b = *data;
                data++;
                if (b == 255) {
                    // transparent pixels to skip
                    xx += *data;
                    dst += *data;
                    data++;
                } else if (yy < clip->clipped_pixels_top) {
                    data += b;
                    xx += b;
                    dst += b;
                } else {
                    data += b;
                    if (unclipped) {
                        xx += b;
                        while (b) {
                            color_t d = *dst;
                            *dst = (((src_rb + (d & 0xff00ff) * alpha_dst) & 0xff00ff00) |
                                    ((src_g + (d & 0x00ff00) * alpha_dst) & 0x00ff0000)) >> 8;
                            b--;
                            dst++;
                        }
                    } else {
                        while (b) {
                            if (xx >= clip->clipped_pixels_left && xx < img->width - clip->clipped_pixels_right) {
                                color_t d = *dst;
                                *dst = (((src_rb + (d & 0xff00ff) * alpha_dst) & 0xff00ff00) |
                                       ((src_g + (d & 0x00ff00) * alpha_dst) & 0x00ff0000)) >> 8;
                            }
                            dst++;
                            xx++;
                            b--;
                        }
                    }
                }
            }
        }
    } else {
        draw_uncompressed(img, data, x, y, color, DRAW_TYPE_BLEND_ALPHA);
    }
}

static void draw_figure_with_cart(struct figure_t *f, int x, int y)
{
    if (f->y_offset_cart >= 0) {
        image_draw(f->image_id, x, y);
        image_draw(f->cart_image_id, x + f->x_offset_cart, y + f->y_offset_cart);
    } else {
        image_draw(f->cart_image_id, x + f->x_offset_cart, y + f->y_offset_cart);
        image_draw(f->image_id, x, y);
    }
}

static void draw_figure_city(struct figure_t *f, int x, int y, int highlight)
{
    if (f->cart_image_id) {
        switch (f->type) {
            case FIGURE_CART_PUSHER:
            case FIGURE_WAREHOUSEMAN:
            case FIGURE_LION_TAMER:
            case FIGURE_DOCKER:
            case FIGURE_NATIVE_TRADER:
            case FIGURE_IMMIGRANT:
            case FIGURE_EMIGRANT:
                draw_figure_with_cart(f, x, y);
                break;
            case FIGURE_HIPPODROME_HORSES:
                int val = f->wait_ticks_missile;
                switch (view_data.orientation) {
                    case DIR_0_TOP:
                        x += 10;
                        if (val <= 10) {
                            y -= 2;
                        } else if (val <= 11) {
                            y -= 10;
                        } else if (val <= 12) {
                            y -= 18;
                        } else if (val <= 13) {
                            y -= 16;
                        } else if (val <= 20) {
                            y -= 14;
                        } else if (val <= 21) {
                            y -= 10;
                        } else {
                            y -= 2;
                        }
                        break;
                    case DIR_2_RIGHT:
                        x -= 10;
                        if (val <= 9) {
                            y -= 12;
                        } else if (val <= 10) {
                            y += 4;
                        } else if (val <= 11) {
                            x -= 5;
                            y += 2;
                        } else if (val <= 13) {
                            x -= 5;
                        } else if (val <= 20) {
                            y -= 2;
                        } else if (val <= 21) {
                            y -= 6;
                        } else {
                            y -= 12;
                        }
                        /* fall through */
                    case DIR_4_BOTTOM:
                        x += 20;
                        if (val <= 9) {
                            y += 4;
                        } else if (val <= 10) {
                            x += 10;
                            y += 4;
                        } else if (val <= 11) {
                            x += 10;
                            y -= 4;
                        } else if (val <= 13) {
                            y -= 6;
                        } else if (val <= 20) {
                            y -= 12;
                        } else if (val <= 21) {
                            y -= 10;
                        } else {
                            y -= 2;
                        }
                        break;
                    case DIR_6_LEFT:
                        x -= 10;
                        if (val <= 9) {
                            y -= 12;
                        } else if (val <= 10) {
                            y += 4;
                        } else if (val <= 11) {
                            y += 2;
                        } else if (val <= 13) {
                            // no change
                        } else if (val <= 20) {
                            y -= 2;
                        } else if (val <= 21) {
                            y -= 6;
                        } else {
                            y -= 12;
                        }
                        break;
                }
                draw_figure_with_cart(f, x, y);
                break;
            case FIGURE_FORT_STANDARD:
                if (!legion_formations[f->formation_id].in_distant_battle) {
                    // base
                    image_draw(f->image_id, x, y);
                    // flag
                    int flag_height = image_get(f->cart_image_id)->height;
                    image_draw(f->cart_image_id, x, y - flag_height);
                    // top icon
                    int icon_image_id = image_data_s.group_image_ids[GROUP_FIGURE_FORT_STANDARD_ICONS] + legion_formations[f->formation_id].id;
                    image_draw(icon_image_id, x, y - image_get(icon_image_id)->height - flag_height);
                }
                break;
            case FIGURE_MAP_FLAG:
                // base
                image_draw(f->image_id, x, y);
                // flag
                image_draw(f->cart_image_id, x, y - image_get(f->cart_image_id)->height);
                // flag number
                int number = 0;
                int id = f->resource_id;
                if (id >= MAP_FLAG_EARTHQUAKE_MIN && id <= MAP_FLAG_EARTHQUAKE_MAX) {
                    number = id - MAP_FLAG_EARTHQUAKE_MIN + 1;
                } else if (id >= MAP_FLAG_INVASION_MIN && id <= MAP_FLAG_INVASION_MAX) {
                    number = id - MAP_FLAG_INVASION_MIN + 1;
                } else if (id >= MAP_FLAG_FISHING_MIN && id <= MAP_FLAG_FISHING_MAX) {
                    number = id - MAP_FLAG_FISHING_MIN + 1;
                } else if (id >= MAP_FLAG_HERD_MIN && id <= MAP_FLAG_HERD_MAX) {
                    number = id - MAP_FLAG_HERD_MIN + 1;
                }
                if (number > 0) {
                    text_draw_number_colored(number, '@', " ", x + 6, y + 7, FONT_NORMAL_PLAIN, COLOR_WHITE);
                }
                break;
            default:
                image_draw(f->image_id, x, y);
                break;
        }
    } else {
        if (figure_properties[f->type].is_native_unit || figure_properties[f->type].is_enemy_unit) {
            if (f->image_id > 0 && f->image_id < 801) {
                struct image_t *img = image_get_enemy(f);
                color_t *data = 0;
                int offset = image_data_s.enemy[f->enemy_image_group][f->image_id].draw.offset;
                if (offset > 0) {
                    data = &image_data_s.enemy_data[f->enemy_image_group][offset];
                }
                if (data) {
                    draw_compressed(img, data, x, y, img->height);
                }
            }
        } else {
            image_draw(f->image_id, x, y);
            if (highlight) {
                image_draw_blend_alpha(f->image_id, x, y, COLOR_MASK_LEGION_HIGHLIGHT);
            }
        }
    }
}

static void city_draw_figure(struct figure_t *f, int x, int y, int highlight)
{
    adjust_pixel_offset(f, &x, &y);
    draw_figure_city(f, x, y, highlight);
}

static void draw_figures_without_overlay(int x, int y, int grid_offset)
{
    int figure_id = map_grid_is_valid_offset(grid_offset) ? map_figures.items[grid_offset] : 0;
    while (figure_id) {
        struct figure_t *f = &figures[figure_id];
        if (figure_id == draw_context.selected_figure_id) {
            if (!f->is_invisible || f->height_adjusted_ticks) {
                adjust_pixel_offset(f, &x, &y);
                draw_figure_city(f, x, y, 0);
                draw_context.selected_figure_coord->x = x;
                draw_context.selected_figure_coord->y = y;
            }
        } else if (!f->is_invisible) {
            if (figure_properties[f->type].is_player_legion_unit && f->formation_id == draw_context.highlighted_formation) {
                city_draw_figure(f, x, y, 1);
            } else {
                city_draw_figure(f, x, y, 0);
            }

        }
        figure_id = f->next_figure_id_on_same_tile;
    }
}

static int building_is_workshop(int type)
{
    return type >= BUILDING_OIL_WORKSHOP && type <= BUILDING_WEAPONS_WORKSHOP;
}

static int calc_percentage(int value, int total)
{
    if (total) {
        int value_times_100 = 100 * value;
        return value_times_100 / total;
    } else {
        return 0;
    }
}

static int building_animation_offset(struct building_t *b, int image_id, int grid_offset)
{
    if (b->type == BUILDING_FOUNTAIN && (b->num_workers <= 0 || !b->has_water_access)) {
        return 0;
    }
    if (b->type == BUILDING_RESERVOIR && !b->has_water_access) {
        return 0;
    }
    if (building_is_workshop(b->type)) {
        if (b->loads_stored <= 0 || b->num_workers <= 0) {
            return 0;
        }
    }
    if ((b->type == BUILDING_PREFECTURE || b->type == BUILDING_ENGINEERS_POST) && b->num_workers <= 0) {
        return 0;
    }
    if (b->type == BUILDING_MARKET && b->num_workers <= 0) {
        return 0;
    }
    if (b->type == BUILDING_WAREHOUSE && b->num_workers < building_properties[b->type].n_laborers) {
        return 0;
    }
    if (b->type == BUILDING_DOCK && b->data.dock.num_ships <= 0) {
        sprite.items[grid_offset] = 1;
        return 1;
    }
    if (b->type == BUILDING_MARBLE_QUARRY && b->num_workers <= 0) {
        sprite.items[grid_offset] = 1;
        return 1;
    } else if ((b->type == BUILDING_IRON_MINE || b->type == BUILDING_CLAY_PIT ||
        b->type == BUILDING_TIMBER_YARD) && b->num_workers <= 0) {
        return 0;
    }
    if (b->type == BUILDING_GLADIATOR_SCHOOL) {
        if (b->num_workers <= 0) {
            sprite.items[grid_offset] = 1;
            return 1;
        }
    } else if (b->type >= BUILDING_THEATER && b->type <= BUILDING_CHARIOT_MAKER &&
        b->type != BUILDING_HIPPODROME && b->num_workers <= 0) {
        return 0;
    }
    if (b->type == BUILDING_GRANARY && b->num_workers < building_properties[b->type].n_laborers) {
        return 0;
    }

    struct image_t *img = image_get(image_id);
    if (!timers[img->animation_speed_id].should_update) {
        return sprite.items[grid_offset] & 0x7f;
    }
    // advance animation
    int new_sprite = 0;
    int is_reverse = 0;
    if (b->type == BUILDING_WINE_WORKSHOP) {
        // exception for wine...
        int pct_done = calc_percentage(b->data.industry.progress, 400);
        if (pct_done <= 0) {
            new_sprite = 0;
        } else if (pct_done < 4) {
            new_sprite = 1;
        } else if (pct_done < 8) {
            new_sprite = 2;
        } else if (pct_done < 12) {
            new_sprite = 3;
        } else if (pct_done < 96) {
            if (sprite.items[grid_offset] < 4) {
                new_sprite = 4;
            } else {
                new_sprite = sprite.items[grid_offset] + 1;
                if (new_sprite > 8) {
                    new_sprite = 4;
                }
            }
        } else {
            // close to done
            if (sprite.items[grid_offset] < 9) {
                new_sprite = 9;
            } else {
                new_sprite = sprite.items[grid_offset] + 1;
                if (new_sprite > 12) {
                    new_sprite = 12;
                }
            }
        }
    } else if (img->animation_can_reverse) {
        if (sprite.items[grid_offset] & 0x80) {
            is_reverse = 1;
        }
        int current_sprite = sprite.items[grid_offset] & 0x7f;
        if (is_reverse) {
            new_sprite = current_sprite - 1;
            if (new_sprite < 1) {
                new_sprite = 1;
                is_reverse = 0;
            }
        } else {
            new_sprite = current_sprite + 1;
            if (new_sprite > img->num_animation_sprites) {
                new_sprite = img->num_animation_sprites;
                is_reverse = 1;
            }
        }
    } else {
        // Absolutely normal case
        new_sprite = sprite.items[grid_offset] + 1;
        if (new_sprite > img->num_animation_sprites) {
            new_sprite = 1;
        }
    }
    sprite.items[grid_offset] = is_reverse ? new_sprite | 0x80 : new_sprite;
    return new_sprite;
}

static void city_draw_bridge_tile(int x, int y, int bridge_sprite_id, color_t color_mask)
{
    int image_id = image_data_s.group_image_ids[GROUP_BUILDING_BRIDGE];
    switch (bridge_sprite_id) {
        case 1:
            image_draw_masked(image_id + 5, x, y - 20, color_mask);
            break;
        case 2:
            image_draw_masked(image_id, x - 1, y - 8, color_mask);
            break;
        case 3:
            image_draw_masked(image_id + 3, x, y - 8, color_mask);
            break;
        case 4:
            image_draw_masked(image_id + 2, x + 7, y - 20, color_mask);
            break;
        case 5:
            image_draw_masked(image_id + 4, x, y - 21, color_mask);
            break;
        case 6:
            image_draw_masked(image_id + 1, x + 5, y - 21, color_mask);
            break;
        case 7:
            image_draw_masked(image_id + 11, x - 3, y - 50, color_mask);
            break;
        case 8:
            image_draw_masked(image_id + 6, x - 1, y - 12, color_mask);
            break;
        case 9:
            image_draw_masked(image_id + 9, x - 30, y - 12, color_mask);
            break;
        case 10:
            image_draw_masked(image_id + 8, x - 23, y - 53, color_mask);
            break;
        case 11:
            image_draw_masked(image_id + 10, x, y - 37, color_mask);
            break;
        case 12:
            image_draw_masked(image_id + 7, x + 7, y - 38, color_mask);
            break;
            // Note: no nr 13
        case 14:
            image_draw_masked(image_id + 13, x, y - 38, color_mask);
            break;
        case 15:
            image_draw_masked(image_id + 12, x + 7, y - 38, color_mask);
            break;
    }
}

static void city_draw_bridge(int x, int y, int grid_offset)
{
    if (!map_terrain_is(grid_offset, TERRAIN_WATER)) {
        map_sprite_clear_tile(grid_offset);
        return;
    }
    if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
        return;
    }
    color_t color_mask = 0;
    if (bitfields_grid.items[grid_offset] & BIT_DELETED) {
        color_mask = COLOR_MASK_RED;
    }
    city_draw_bridge_tile(x, y, sprite.items[grid_offset], color_mask);
}

static void draw_animation_without_overlay(int x, int y, int grid_offset)
{
    int image_id = images.items[grid_offset];
    struct image_t *img = image_get(image_id);
    if (img->num_animation_sprites) {
        if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
            int building_id = map_building_at(grid_offset);
            struct building_t *b = &all_buildings[building_id];
            int color_mask = 0;
            if (draw_building_as_deleted_2(b) || bitfields_grid.items[grid_offset] & BIT_DELETED) {
                color_mask = COLOR_MASK_RED;
            }
            if (b->type == BUILDING_DOCK) {
                int num_idle = 0;
                for (int i = 0; i < 3; i++) {
                    if (b->data.dock.docker_ids[i]) {
                        struct figure_t *f = &figures[b->data.dock.docker_ids[i]];
                        if (f->action_state == FIGURE_ACTION_DOCKER_IDLING ||
                            f->action_state == FIGURE_ACTION_DOCKER_IMPORT_QUEUE) {
                            num_idle++;
                        }
                    }
                }
                if (num_idle > 0) {
                    int image_dock = images.items[grid_offset];
                    int image_dockers = image_data_s.group_image_ids[GROUP_BUILDING_DOCK_DOCKERS];
                    if (image_dock == image_data_s.group_image_ids[GROUP_BUILDING_DOCK_1]) {
                        image_dockers += 0;
                    } else if (image_dock == image_data_s.group_image_ids[GROUP_BUILDING_DOCK_2]) {
                        image_dockers += 3;
                    } else if (image_dock == image_data_s.group_image_ids[GROUP_BUILDING_DOCK_3]) {
                        image_dockers += 6;
                    } else {
                        image_dockers += 9;
                    }
                    if (num_idle == 2) {
                        image_dockers += 1;
                    } else if (num_idle == 3) {
                        image_dockers += 2;
                    }
                    struct image_t *img2 = image_get(image_dockers);
                    image_draw_masked(image_dockers, x + img2->sprite_offset_x, y + img2->sprite_offset_y, color_mask);
                }
            } else if (b->type == BUILDING_WAREHOUSE) {
                image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_WAREHOUSE] + 17, x - 4, y - 42, color_mask);
                if (b->id == city_data.building.trade_center_building_id) {
                    image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_TRADE_CENTER_FLAG], x + 19, y - 56, color_mask);
                }
            } else if (b->type == BUILDING_GRANARY) {
                image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_GRANARY] + 1,
                                  x + img->sprite_offset_x,
                                  y + 60 + img->sprite_offset_y - img->height,
                                  color_mask);
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 2400) {
                    image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_GRANARY] + 2, x + 33, y - 60, color_mask);
                }
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 1800) {
                    image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_GRANARY] + 3, x + 56, y - 50, color_mask);
                }
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 1200) {
                    image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_GRANARY] + 4, x + 91, y - 50, color_mask);
                }
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 600) {
                    image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_GRANARY] + 5, x + 117, y - 62, color_mask);
                }
            } else if (b->type == BUILDING_BURNING_RUIN && b->ruin_has_plague) {
                image_draw_masked(image_data_s.group_image_ids[GROUP_PLAGUE_SKULL], x + 18, y - 32, color_mask);
            }
            int animation_offset = building_animation_offset(b, image_id, grid_offset);
            if (b->type != BUILDING_HIPPODROME && animation_offset > 0) {
                if (animation_offset > img->num_animation_sprites) {
                    animation_offset = img->num_animation_sprites;
                }
                if (b->type == BUILDING_GRANARY) {
                    image_draw_masked(image_id + animation_offset + 5, x + 77, y - 49, color_mask);
                } else {
                    int ydiff = 0;
                    switch (map_property_multi_tile_size(grid_offset)) {
                        case 1: ydiff = 30; break;
                        case 2: ydiff = 45; break;
                        case 3: ydiff = 60; break;
                        case 4: ydiff = 75; break;
                        case 5: ydiff = 90; break;
                    }
                    image_draw_masked(image_id + animation_offset,
                                      x + img->sprite_offset_x,
                                      y + ydiff + img->sprite_offset_y - img->height,
                                      color_mask);
                }
            }
        }
    } else if (sprite.items[grid_offset]) {
        city_draw_bridge(x, y, grid_offset);
    } else if (building_is_fort(all_buildings[map_building_at(grid_offset)].type)) {
        if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
            struct building_t *fort = &all_buildings[map_building_at(grid_offset)];
            int offset = 0;
            switch (fort->subtype.fort_figure_type) {
                case FIGURE_FORT_LEGIONARY: offset = 4; break;
                case FIGURE_FORT_MOUNTED: offset = 3; break;
                case FIGURE_FORT_JAVELIN: offset = 2; break;
            }
            if (offset) {
                image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_FORT] + offset, x + 81, y + 5, draw_building_as_deleted_2(fort) ? COLOR_MASK_RED : 0);
            }
        }
    } else if (all_buildings[map_building_at(grid_offset)].type == BUILDING_GATEHOUSE) {
        int xy = edge_grid.items[grid_offset] & EDGE_MASK_XY;
        int orientation = view_data.orientation;
        if ((orientation == DIR_0_TOP && xy == EDGE_X1Y1) ||
            (orientation == DIR_2_RIGHT && xy == EDGE_X0Y1) ||
            (orientation == DIR_4_BOTTOM && xy == EDGE_X0Y0) ||
            (orientation == DIR_6_LEFT && xy == EDGE_X1Y0)) {
            struct building_t *gate = &all_buildings[map_building_at(grid_offset)];
            int gatehouse_image_id = image_data_s.group_image_ids[GROUP_BUILDING_GATEHOUSE];
            int color_mask = draw_building_as_deleted_2(gate) ? COLOR_MASK_RED : 0;
            if (gate->subtype.orientation == 1) {
                if (orientation == DIR_0_TOP || orientation == DIR_4_BOTTOM) {
                    image_draw_masked(gatehouse_image_id, x - 22, y - 80, color_mask);
                } else {
                    image_draw_masked(gatehouse_image_id + 1, x - 18, y - 81, color_mask);
                }
            } else if (gate->subtype.orientation == 2) {
                if (orientation == DIR_0_TOP || orientation == DIR_4_BOTTOM) {
                    image_draw_masked(gatehouse_image_id + 1, x - 18, y - 81, color_mask);
                } else {
                    image_draw_masked(gatehouse_image_id, x - 22, y - 80, color_mask);
                }
            }
        }
    }
}

static int map_grid_offset(int x, int y)
{
    return map_data.start_offset + x + y * GRID_SIZE;
}

static void city_view_get_selected_tile_pixels(int *x_pixels, int *y_pixels)
{
    *x_pixels = view_data.selected_tile.x_pixels;
    *y_pixels = view_data.selected_tile.y_pixels;
}

static int city_finance_can_afford(int cost)
{
    return -cost + city_data.finance.treasury >= -5000;
}

static void image_draw_blend(int image_id, int x, int y, color_t color)
{
    struct image_t *img = image_get(image_id);
    color_t *data = image_data(image_id);
    if (!data) {
        return;
    }

    if (img->draw.type == IMAGE_TYPE_ISOMETRIC) {
        return;
    }

    if (img->draw.is_fully_compressed) {
        struct clip_info_t *clip = graphics_get_clip_info(x, y, img->width, img->height);
        if (!clip || !clip->is_visible) {
            return;
        }
        int unclipped = clip->clip_x == CLIP_NONE;

        for (int yy = 0; yy < img->height - clip->clipped_pixels_bottom; yy++) {
            int xx = 0;
            while (xx < img->width) {
                color_t b = *data;
                data++;
                if (b == 255) {
                    // transparent pixels to skip
                    xx += *data;
                    data++;
                } else if (yy < clip->clipped_pixels_top) {
                    data += b;
                    xx += b;
                } else {
                    data += b;
                    color_t *dst = graphics_get_pixel(x + xx, y + yy);
                    if (unclipped) {
                        xx += b;
                        while (b) {
                            *dst &= color;
                            dst++;
                            b--;
                        }
                    } else {
                        while (b) {
                            if (xx >= clip->clipped_pixels_left && xx < img->width - clip->clipped_pixels_right) {
                                *dst &= color;
                            }
                            dst++;
                            xx++;
                            b--;
                        }
                    }
                }
            }
        }
    } else {
        draw_uncompressed(img, data, x, y, color, DRAW_TYPE_BLEND);
    }
}

static void draw_blocked_building_preview(int x, int y, int num_tiles, int *blocked_tiles, int completely_blocked)
{
    for (int i = 0; i < num_tiles; i++) {
        int x_offset = x + X_VIEW_OFFSETS[i];
        int y_offset = y + Y_VIEW_OFFSETS[i];
        if (completely_blocked || blocked_tiles[i]) {
            image_draw_blend(image_data_s.group_image_ids[GROUP_TERRAIN_FLAT_TILE], x_offset, y_offset, COLOR_MASK_RED);
        } else {
            image_draw_blend(image_data_s.group_image_ids[GROUP_TERRAIN_FLAT_TILE], x_offset, y_offset, COLOR_MASK_GREEN);
        }
    }
}

static void map_grid_bound_area(int *x_min, int *y_min, int *x_max, int *y_max)
{
    if (*x_min < 0) {
        *x_min = 0;
    }
    if (*y_min < 0) {
        *y_min = 0;
    }
    if (*x_max >= map_data.width) {
        *x_max = map_data.width - 1;
    }
    if (*y_max >= map_data.height) {
        *y_max = map_data.height - 1;
    }
}

static void map_grid_get_area(int x, int y, int size, int radius, int *x_min, int *y_min, int *x_max, int *y_max)
{
    *x_min = x - radius;
    *y_min = y - radius;
    *x_max = x + size + radius - 1;
    *y_max = y + size + radius - 1;
    map_grid_bound_area(x_min, y_min, x_max, y_max);
}

static int map_terrain_exists_tile_in_radius_with_type(int x, int y, int size, int radius, int terrain)
{
    int x_min, y_min, x_max, y_max;
    map_grid_get_area(x, y, size, radius, &x_min, &y_min, &x_max, &y_max);

    for (int yy = y_min; yy <= y_max; yy++) {
        for (int xx = x_min; xx <= x_max; xx++) {
            if (map_terrain_is(map_grid_offset(xx, yy), terrain)) {
                return 1;
            }
        }
    }
    return 0;
}

static int map_terrain_exist_multiple_tiles_in_radius_with_type(int x, int y, int size, int radius, int terrain, int count)
{
    int x_min, y_min, x_max, y_max;
    map_grid_get_area(x, y, size, radius, &x_min, &y_min, &x_max, &y_max);

    int tiles_found = 0;
    for (int yy = y_min; yy <= y_max; yy++) {
        for (int xx = x_min; xx <= x_max; xx++) {
            if (map_terrain_is(map_grid_offset(xx, yy), terrain)) {
                tiles_found++;
                if (tiles_found >= count) {
                    return 1;
                }
            }
        }
    }

    return 0;
}

static void set_warning(int *warning_id, int warning)
{
    if (warning_id) {
        *warning_id = warning;
    }
}

static int map_terrain_all_tiles_in_radius_are(int x, int y, int size, int radius, int terrain)
{
    int x_min, y_min, x_max, y_max;
    map_grid_get_area(x, y, size, radius, &x_min, &y_min, &x_max, &y_max);

    for (int yy = y_min; yy <= y_max; yy++) {
        for (int xx = x_min; xx <= x_max; xx++) {
            if (!map_terrain_is(map_grid_offset(xx, yy), terrain)) {
                return 0;
            }
        }
    }
    return 1;
}

static int check_building_terrain_requirements(int x, int y, int *warning_id)
{
    if (construction_data.required_terrain.meadow) {
        if (!map_terrain_exists_tile_in_radius_with_type(x, y, 3, 1, TERRAIN_MEADOW)) {
            set_warning(warning_id, WARNING_MEADOW_NEEDED);
            return 0;
        }
    } else if (construction_data.required_terrain.rock) {
        if (!map_terrain_exists_tile_in_radius_with_type(x, y, 2, 1, TERRAIN_ELEVATION)) {
            set_warning(warning_id, WARNING_ROCK_NEEDED);
            return 0;
        }
    } else if (construction_data.required_terrain.tree) {
        if (!map_terrain_exist_multiple_tiles_in_radius_with_type(x, y, 2, 1, TERRAIN_TREE | TERRAIN_SHRUB, 3)) {
            set_warning(warning_id, WARNING_TREE_NEEDED);
            return 0;
        }
    } else if (construction_data.required_terrain.water) {
        if (!map_terrain_exists_tile_in_radius_with_type(x, y, 2, 3, TERRAIN_WATER)) {
            set_warning(warning_id, WARNING_WATER_NEEDED);
            return 0;
        }
    } else if (construction_data.required_terrain.wall) {
        if (!map_terrain_all_tiles_in_radius_are(x, y, 2, 0, TERRAIN_WALL)) {
            set_warning(warning_id, WARNING_WALL_NEEDED);
            return 0;
        }
    }
    return 1;
}

static int map_orientation_for_gatehouse(int x, int y)
{
    switch (view_data.orientation) {
        case DIR_2_RIGHT: x--; break;
        case DIR_4_BOTTOM: x--; y--; break;
        case DIR_6_LEFT: y--; break;
    }
    int grid_offset = map_grid_offset(x, y);
    int num_road_tiles_within = 0;
    int road_tiles_within_flags = 0;
    // tiles within gate, flags:
    // 1  2
    // 4  8
    if (map_terrain_is(map_grid_offset(x, y), TERRAIN_ROAD)) {
        road_tiles_within_flags |= 1;
        num_road_tiles_within++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(1, 0), TERRAIN_ROAD)) {
        road_tiles_within_flags |= 2;
        num_road_tiles_within++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(0, 1), TERRAIN_ROAD)) {
        road_tiles_within_flags |= 4;
        num_road_tiles_within++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(1, 1), TERRAIN_ROAD)) {
        road_tiles_within_flags |= 8;
        num_road_tiles_within++;
    }

    if (num_road_tiles_within != 2 && num_road_tiles_within != 4) {
        return 0;
    }
    if (num_road_tiles_within == 2) {
        if (road_tiles_within_flags == 6 || road_tiles_within_flags == 9) { // diagonals
            return 0;
        }
        if (road_tiles_within_flags == 5 || road_tiles_within_flags == 10) { // top to bottom
            return 1;
        }
        if (road_tiles_within_flags == 3 || road_tiles_within_flags == 12) { // left to right
            return 2;
        }
        return 0;
    }
    // all 4 tiles are road: check adjacent roads
    int num_road_tiles_top = 0;
    int num_road_tiles_right = 0;
    int num_road_tiles_bottom = 0;
    int num_road_tiles_left = 0;
    // top
    if (map_terrain_is(grid_offset + map_grid_delta(0, -1), TERRAIN_ROAD)) {
        num_road_tiles_top++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(1, -1), TERRAIN_ROAD)) {
        num_road_tiles_top++;
    }
    // bottom
    if (map_terrain_is(grid_offset + map_grid_delta(0, 2), TERRAIN_ROAD)) {
        num_road_tiles_bottom++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(1, 2), TERRAIN_ROAD)) {
        num_road_tiles_bottom++;
    }
    // left
    if (map_terrain_is(grid_offset + map_grid_delta(-1, 0), TERRAIN_ROAD)) {
        num_road_tiles_left++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(-1, 1), TERRAIN_ROAD)) {
        num_road_tiles_left++;
    }
    // right
    if (map_terrain_is(grid_offset + map_grid_delta(2, 0), TERRAIN_ROAD)) {
        num_road_tiles_right++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(2, 1), TERRAIN_ROAD)) {
        num_road_tiles_right++;
    }
    // determine direction
    if (num_road_tiles_top || num_road_tiles_bottom) {
        if (num_road_tiles_left || num_road_tiles_right) {
            return 0;
        }
        return 1;
    } else if (num_road_tiles_left || num_road_tiles_right) {
        return 2;
    }
    return 0;
}

static int map_orientation_for_triumphal_arch(int x, int y)
{
    switch (view_data.orientation) {
        case DIR_2_RIGHT: x -= 2; break;
        case DIR_4_BOTTOM: x -= 2; y -= 2; break;
        case DIR_6_LEFT: y -= 2; break;
    }
    int num_road_tiles_top_bottom = 0;
    int num_road_tiles_left_right = 0;
    int num_blocked_tiles = 0;

    int grid_offset = map_grid_offset(x, y);
    // check corner tiles
    if (map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR)) {
        num_blocked_tiles++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(2, 0), TERRAIN_NOT_CLEAR)) {
        num_blocked_tiles++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(0, 2), TERRAIN_NOT_CLEAR)) {
        num_blocked_tiles++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(2, 2), TERRAIN_NOT_CLEAR)) {
        num_blocked_tiles++;
    }
    // road tiles top to bottom
    int top_offset = grid_offset + map_grid_delta(1, 0);
    if ((terrain_grid.items[top_offset] & TERRAIN_NOT_CLEAR) == TERRAIN_ROAD) {
        num_road_tiles_top_bottom++;
    } else if (map_terrain_is(top_offset, TERRAIN_NOT_CLEAR)) {
        num_blocked_tiles++;
    }
    int bottom_offset = grid_offset + map_grid_delta(1, 2);
    if ((terrain_grid.items[bottom_offset] & TERRAIN_NOT_CLEAR) == TERRAIN_ROAD) {
        num_road_tiles_top_bottom++;
    } else if (map_terrain_is(bottom_offset, TERRAIN_NOT_CLEAR)) {
        num_blocked_tiles++;
    }
    // road tiles left to right
    int left_offset = grid_offset + map_grid_delta(0, 1);
    if ((terrain_grid.items[left_offset] & TERRAIN_NOT_CLEAR) == TERRAIN_ROAD) {
        num_road_tiles_left_right++;
    } else if (map_terrain_is(left_offset, TERRAIN_NOT_CLEAR)) {
        num_blocked_tiles++;
    }
    int right_offset = grid_offset + map_grid_delta(2, 1);
    if ((terrain_grid.items[right_offset] & TERRAIN_NOT_CLEAR) == TERRAIN_ROAD) {
        num_road_tiles_left_right++;
    } else if (map_terrain_is(right_offset, TERRAIN_NOT_CLEAR)) {
        num_blocked_tiles++;
    }
    // center tile
    int center_offset = grid_offset + map_grid_delta(2, 1);
    if ((terrain_grid.items[center_offset] & TERRAIN_NOT_CLEAR) == TERRAIN_ROAD) {
        // do nothing
    } else if (map_terrain_is(center_offset, TERRAIN_NOT_CLEAR)) {
        num_blocked_tiles++;
    }
    // judgement time
    if (num_blocked_tiles) {
        return 0;
    }
    if (!num_road_tiles_left_right && !num_road_tiles_top_bottom) {
        return 0; // no road: can't determine direction
    }
    if (num_road_tiles_top_bottom == 2 && !num_road_tiles_left_right) {
        return 1;
    }
    if (num_road_tiles_left_right == 2 && !num_road_tiles_top_bottom) {
        return 2;
    }
    return 0;
}

static void image_draw_isometric_footprint(int image_id, int x, int y, color_t color_mask)
{
    struct image_t *img = image_get(image_id);
    if (img->draw.type != IMAGE_TYPE_ISOMETRIC) {
        return;
    }
    switch (img->width) {
        case 58:
            draw_footprint_size1(image_id, x, y, color_mask);
            break;
        case 118:
            draw_footprint_size2(image_id, x, y, color_mask);
            break;
        case 178:
            draw_footprint_size3(image_id, x, y, color_mask);
            break;
        case 238:
            draw_footprint_size4(image_id, x, y, color_mask);
            break;
        case 298:
            draw_footprint_size5(image_id, x, y, color_mask);
            break;
    }
}

static void image_draw_isometric_top(int image_id, int x, int y, color_t color_mask)
{
    struct image_t *img = image_get(image_id);
    if (img->draw.type != IMAGE_TYPE_ISOMETRIC) {
        return;
    }
    if (!img->draw.has_compressed_part) {
        return;
    }
    color_t *data = &image_data(image_id)[img->draw.uncompressed_length];

    int height = img->height;
    switch (img->width) {
        case 58:
            y -= img->height - 30;
            height -= 16;
            break;
        case 118:
            x -= 30;
            y -= img->height - 60;
            height -= 31;
            break;
        case 178:
            x -= 60;
            y -= img->height - 90;
            height -= 46;
            break;
        case 238:
            x -= 90;
            y -= img->height - 120;
            height -= 61;
            break;
        case 298:
            x -= 120;
            y -= img->height - 150;
            height -= 76;
            break;
    }
    if (!color_mask) {
        draw_compressed(img, data, x, y, height);
    } else {
        draw_compressed_and(img, data, x, y, height, color_mask);
    }
}

static void draw_building(int image_id, int x, int y)
{
    image_draw_isometric_footprint(image_id, x, y, COLOR_MASK_GREEN);
    image_draw_isometric_top(image_id, x, y, COLOR_MASK_GREEN);
}

static int map_can_place_road_under_aqueduct(int grid_offset)
{
    int image_id = images.items[grid_offset] - image_data_s.group_image_ids[GROUP_BUILDING_AQUEDUCT];
    int check_y;
    switch (image_id) {
        case 0:
        case 2:
        case 8:
        case 15:
        case 17:
        case 23:
            check_y = 1;
            break;
        case 1:
        case 3:
        case 9: case 10: case 11: case 12: case 13: case 14:
        case 16:
        case 18:
        case 24: case 25: case 26: case 27: case 28: case 29:
            check_y = 0;
            break;
        default: // not a straight aqueduct
            return 0;
    }
    if (view_data.orientation == DIR_6_LEFT || view_data.orientation == DIR_2_RIGHT) {
        check_y = !check_y;
    }
    if (check_y) {
        int dy_up = map_grid_delta(0, -1);
        int dy_down = map_grid_delta(0, 1);
        if (map_terrain_is(grid_offset + dy_up, TERRAIN_ROAD) ||
            routing_distance.items[grid_offset + dy_up] > 0) {
            return 0;
        }
        if (map_terrain_is(grid_offset + dy_down, TERRAIN_ROAD) ||
            routing_distance.items[grid_offset + dy_down] > 0) {
            return 0;
        }
    } else {
        int dx_left = map_grid_delta(-1, 0);
        int dx_right = map_grid_delta(1, 0);
        if (map_terrain_is(grid_offset + dx_left, TERRAIN_ROAD) ||
            routing_distance.items[grid_offset + dx_left] > 0) {
            return 0;
        }
        if (map_terrain_is(grid_offset + dx_right, TERRAIN_ROAD) ||
            routing_distance.items[grid_offset + dx_right] > 0) {
            return 0;
        }
    }
    return 1;
}

static int map_terrain_has_adjacent_x_with_type(int grid_offset, int terrain)
{
    if (map_terrain_is(grid_offset + map_grid_delta(0, -1), terrain) ||
        map_terrain_is(grid_offset + map_grid_delta(0, 1), terrain)) {
        return 1;
    }
    return 0;
}

static int map_terrain_has_adjacent_y_with_type(int grid_offset, int terrain)
{
    if (map_terrain_is(grid_offset + map_grid_delta(-1, 0), terrain) ||
        map_terrain_is(grid_offset + map_grid_delta(1, 0), terrain)) {
        return 1;
    }
    return 0;
}

static int building_preview_blocked(int grid_offset, int num_tiles, int *blocked_tiles, int type)
{
    int orientation_index = view_data.orientation / 2;
    int blocked = 0;
    for (int i = 0; i < num_tiles; i++) {
        int tile_offset = grid_offset + TILE_GRID_OFFSETS[orientation_index][i];
        int forbidden_terrain = terrain_grid.items[tile_offset] & TERRAIN_NOT_CLEAR;
        if (type == BUILDING_GATEHOUSE || type == BUILDING_TRIUMPHAL_ARCH) {
            forbidden_terrain &= ~TERRAIN_ROAD;
        }
        if (type == BUILDING_TOWER) {
            forbidden_terrain &= ~TERRAIN_WALL;
        }
        if (forbidden_terrain || (map_grid_is_valid_offset(tile_offset) && map_figures.items[tile_offset] > 0)) {
            blocked_tiles[i] = 1;
            blocked = 1;
        } else {
            blocked_tiles[i] = 0;
        }
    }
    return blocked;
}

static void draw_water_range_preview(int x, int y, int radius)
{
    int image_id = image_data_s.group_image_ids[GROUP_TERRAIN_FLAT_TILE];
    for (int i = 1; i <= radius; i++) {
        for (int j = 0; j <= radius; j++) {
            image_draw_blend_alpha(image_id, x + HALF_TILE_WIDTH_PIXELS * (i + j), y - HALF_TILE_HEIGHT_PIXELS * (i - j), COLOR_MASK_BLUE);
            image_draw_blend_alpha(image_id, x + HALF_TILE_WIDTH_PIXELS * (i - j), y + HALF_TILE_HEIGHT_PIXELS * (i + j), COLOR_MASK_BLUE);
            image_draw_blend_alpha(image_id, x - HALF_TILE_WIDTH_PIXELS * (i + j), y + HALF_TILE_HEIGHT_PIXELS * (i - j), COLOR_MASK_BLUE);
            image_draw_blend_alpha(image_id, x - HALF_TILE_WIDTH_PIXELS * (i - j), y - HALF_TILE_HEIGHT_PIXELS * (i + j), COLOR_MASK_BLUE);
        }
    }
}

static int map_grid_is_inside(int x, int y, int size)
{
    return x >= 0 && x + size <= map_data.width && y >= 0 && y + size <= map_data.height;
}

static int map_terrain_exists_tile_in_area_with_type(int x, int y, int size, int terrain)
{
    for (int yy = y; yy < y + size; yy++) {
        for (int xx = x; xx < x + size; xx++) {
            if (map_grid_is_inside(xx, yy, 1) && terrain_grid.items[map_grid_offset(xx, yy)] & terrain) {
                return 1;
            }
        }
    }
    return 0;
}

static int is_road_tile_for_aqueduct(int grid_offset, int gate_orientation)
{
    int is_road = map_terrain_is(grid_offset, TERRAIN_ROAD) ? 1 : 0;
    if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
        struct building_t *b = &all_buildings[map_building_at(grid_offset)];
        if (b->type == BUILDING_GATEHOUSE) {
            if (b->subtype.orientation == gate_orientation) {
                is_road = 1;
            }
        } else if (b->type == BUILDING_GRANARY) {
            if (terrain_land_citizen.items[grid_offset] == CITIZEN_0_ROAD) {
                is_road = 1;
            }
        }
    }
    return is_road;
}

static int map_tiles_is_paved_road(int grid_offset)
{
    if (desirability_grid.items[grid_offset] > 4) {
        return 1;
    }
    if (desirability_grid.items[grid_offset] > 0 && map_terrain_is(grid_offset, TERRAIN_FOUNTAIN_RANGE)) {
        return 1;
    }
    return 0;
}

static int map_terrain_count_directly_adjacent_with_type(int grid_offset, int terrain)
{
    int count = 0;
    if (map_terrain_is(grid_offset + map_grid_delta(0, -1), terrain)) {
        count++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(1, 0), terrain)) {
        count++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(0, 1), terrain)) {
        count++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(-1, 0), terrain)) {
        count++;
    }
    return count;
}

static int map_grid_direction_delta(int direction)
{
    if (direction >= 0 && direction < 8) {
        return DIRECTION_DELTA[direction];
    } else {
        return 0;
    }
}

static   struct terrain_image_t *get_image(int group, int tiles[MAX_TILES_TERRAIN])
{
    static struct terrain_image_t result;
    result.is_valid = 0;
    struct terrain_image_context *context = context_pointers[group].context;
    int size = context_pointers[group].size;
    for (int i = 0; i < size; i++) {
        int context_matches_tiles = 1;
        for (int j = 0; j < MAX_TILES_TERRAIN; j++) {
            if (context->tiles[j] != 2 && tiles[j] != context->tiles[j]) {
                context_matches_tiles = 0;
                break;
            }
        }
        if (context_matches_tiles) {
            context[i].current_item_offset++;
            if (context[i].current_item_offset >= context[i].max_item_offset) {
                context[i].current_item_offset = 0;
            }
            result.is_valid = 1;
            result.group_offset = context[i].offset_for_orientation[view_data.orientation / 2];
            result.item_offset = context[i].current_item_offset;
            result.aqueduct_offset = context[i].aqueduct_offset;
            break;
        }
    }
    return &result;
}

static void set_terrain_reservoir(int grid_offset, int direction, int multi_tile_mask, int tiles[MAX_TILES_TERRAIN], int include_construction)
{
    int offset = grid_offset + map_grid_direction_delta(direction);
    if (map_terrain_is(offset, TERRAIN_BUILDING)) {
        struct building_t *b = &all_buildings[map_building_at(offset)];
        if (b->type == BUILDING_RESERVOIR && (edge_grid.items[offset] & EDGE_MASK_XY) == multi_tile_mask) {
            tiles[direction] = 1;
            return;
        }
    }
    int reservoir_construction_entrance = 0;
    if (!(bitfields_grid.items[offset] & BIT_CONSTRUCTION)) {
        reservoir_construction_entrance = 0;
    } else if (bitfields_grid.items[offset + map_grid_direction_delta(0)] & BIT_CONSTRUCTION && bitfields_grid.items[offset + map_grid_direction_delta(4)] & BIT_CONSTRUCTION) {
        reservoir_construction_entrance = !(bitfields_grid.items[offset + 2 * map_grid_direction_delta(0)] & BIT_CONSTRUCTION) || !(bitfields_grid.items[offset + 2 * map_grid_direction_delta(4)] & BIT_CONSTRUCTION);
    } else if (bitfields_grid.items[offset + map_grid_direction_delta(2)] & BIT_CONSTRUCTION && bitfields_grid.items[offset + map_grid_direction_delta(6)] & BIT_CONSTRUCTION) {
        reservoir_construction_entrance = !(bitfields_grid.items[offset + 2 * map_grid_direction_delta(2)] & BIT_CONSTRUCTION) || !(bitfields_grid.items[offset + 2 * map_grid_direction_delta(6)] & BIT_CONSTRUCTION);
    }
    if (include_construction && reservoir_construction_entrance) {
        tiles[direction] = 1;
    }
}

static   struct terrain_image_t *map_image_context_get_aqueduct(int grid_offset, int include_construction)
{
    int tiles[MAX_TILES_TERRAIN] = { 0,0,0,0,0,0,0,0 };
    int has_road = map_terrain_is(grid_offset, TERRAIN_ROAD) ? 1 : 0;
    for (int i = 0; i < MAX_TILES_TERRAIN; i += 2) {
        int offset = grid_offset + map_grid_direction_delta(i);
        if (map_terrain_is(offset, TERRAIN_AQUEDUCT)) {
            if (has_road) {
                if (!map_terrain_is(offset, TERRAIN_ROAD)) {
                    tiles[i] = 1;
                }
            } else {
                tiles[i] = 1;
            }
        }
    }
    set_terrain_reservoir(grid_offset, 0, EDGE_X1Y2, tiles, include_construction);
    set_terrain_reservoir(grid_offset, 2, EDGE_X0Y1, tiles, include_construction);
    set_terrain_reservoir(grid_offset, 4, EDGE_X1Y0, tiles, include_construction);
    set_terrain_reservoir(grid_offset, 6, EDGE_X2Y1, tiles, include_construction);
    return get_image(CONTEXT_AQUEDUCT, tiles);
}

static int map_bridge_get_sprite_id(int index, int length, int direction, int is_ship_bridge)
{
    if (is_ship_bridge) {
        int pillar_distance = 0;
        switch (bridge.length) {
            case 9:
            case 10:
                pillar_distance = 4;
                break;
            case 11:
            case 12:
                pillar_distance = 5;
                break;
            case 13:
            case 14:
                pillar_distance = 6;
                break;
            case 15:
            case 16:
                pillar_distance = 7;
                break;
            default:
                pillar_distance = 8;
                break;
        }
        if (index == 1 || index == length - 2) {
            // platform after ramp
            return 13;
        } else if (index == 0) {
            // ramp at start
            switch (direction) {
                case DIR_0_TOP:
                    return 7;
                case DIR_2_RIGHT:
                    return 8;
                case DIR_4_BOTTOM:
                    return 9;
                case DIR_6_LEFT:
                    return 10;
            }
        } else if (index == length - 1) {
            // ramp at end
            switch (direction) {
                case DIR_0_TOP:
                    return 9;
                case DIR_2_RIGHT:
                    return 10;
                case DIR_4_BOTTOM:
                    return 7;
                case DIR_6_LEFT:
                    return 8;
            }
        } else if (index == pillar_distance) {
            if (direction == DIR_0_TOP || direction == DIR_4_BOTTOM) {
                return 14;
            } else {
                return 15;
            }
        } else {
            // middle of the bridge
            if (direction == DIR_0_TOP || direction == DIR_4_BOTTOM) {
                return 11;
            } else {
                return 12;
            }
        }
    } else {
        if (index == 0) {
            // ramp at start
            switch (direction) {
                case DIR_0_TOP:
                    return 1;
                case DIR_2_RIGHT:
                    return 2;
                case DIR_4_BOTTOM:
                    return 3;
                case DIR_6_LEFT:
                    return 4;
            }
        } else if (index == length - 1) {
            // ramp at end
            switch (direction) {
                case DIR_0_TOP:
                    return 3;
                case DIR_2_RIGHT:
                    return 4;
                case DIR_4_BOTTOM:
                    return 1;
                case DIR_6_LEFT:
                    return 2;
            }
        } else {
            // middle part
            if (direction == DIR_0_TOP || direction == DIR_4_BOTTOM) {
                return 5;
            } else {
                return 6;
            }
        }
    }
    return 0;
}

static int blocked_land_terrain(void)
{
    return
        TERRAIN_SHRUB | TERRAIN_ROCK | TERRAIN_WATER |
        TERRAIN_BUILDING | TERRAIN_TREE | TERRAIN_GARDEN |
        TERRAIN_ROAD | TERRAIN_ELEVATION | TERRAIN_RUBBLE;
}

static int map_water_determine_orientation_size2(int x, int y, int adjust_xy, int *orientation_absolute, int *orientation_relative)
{
    if (adjust_xy == 1) {
        switch (view_data.orientation) {
            case DIR_0_TOP: break;
            case DIR_2_RIGHT: x--; break;
            case DIR_6_LEFT: y--; break;
            case DIR_4_BOTTOM: x--; y--; break;
        }
    }
    if (!map_grid_is_inside(x, y, 2)) {
        return 999;
    }

    int base_offset = map_grid_offset(x, y);
    int tile_offsets[] = { OFFSET(0,0), OFFSET(1,0), OFFSET(0,1), OFFSET(1,1) };
    int should_be_water[4][4] = { {1, 1, 0, 0}, {0, 1, 0, 1}, {0, 0, 1, 1}, {1, 0, 1, 0} };
    for (int dir = 0; dir < 4; dir++) {
        int ok_tiles = 0;
        int blocked_tiles = 0;
        for (int i = 0; i < 4; i++) {
            int grid_offset = base_offset + tile_offsets[i];
            if (should_be_water[dir][i]) {
                if (!map_terrain_is(grid_offset, TERRAIN_WATER)) {
                    break;
                }
                ok_tiles++;
                if (map_terrain_is(grid_offset, TERRAIN_ROCK | TERRAIN_ROAD)) {
                    // bridge or map edge
                    blocked_tiles++;
                }
            } else {
                if (map_terrain_is(grid_offset, TERRAIN_WATER)) {
                    break;
                }
                ok_tiles++;
                if (map_terrain_is(grid_offset, blocked_land_terrain())) {
                    blocked_tiles++;
                }
            }
        }
        // check six water tiles in front
        int tiles_to_check[4][6] = {
          {OFFSET(-1,0), OFFSET(-1,-1), OFFSET(0,-1), OFFSET(1,-1), OFFSET(2,-1), OFFSET(2,0)},
          {OFFSET(1,-1), OFFSET(2,-1), OFFSET(2,0), OFFSET(2,1), OFFSET(2,2), OFFSET(1,2)},
          {OFFSET(2,1), OFFSET(2,2), OFFSET(1,2), OFFSET(0,2), OFFSET(-1,2), OFFSET(-1,1)},
          {OFFSET(0,2), OFFSET(-1,2), OFFSET(-1,1), OFFSET(-1,0), OFFSET(-1,-1), OFFSET(0,-1)},
        };
        for (int i = 0; i < 6; i++) {
            if (!map_terrain_is(base_offset + tiles_to_check[dir][i], TERRAIN_WATER)) {
                ok_tiles = 0;
            }
        }
        if (ok_tiles == 4) {
            // water/land is OK in this orientation
            if (orientation_absolute) {
                *orientation_absolute = dir;
            }
            if (orientation_relative) {
                *orientation_relative = (4 + dir - view_data.orientation / 2) % 4;
            }
            return blocked_tiles;
        }
    }
    return 999;
}

static int map_water_determine_orientation_size3(int x, int y, int adjust_xy, int *orientation_absolute, int *orientation_relative)
{
    if (adjust_xy == 1) {
        switch (view_data.orientation) {
            case DIR_0_TOP: break;
            case DIR_2_RIGHT: x -= 2; break;
            case DIR_6_LEFT: y -= 2; break;
            case DIR_4_BOTTOM: x -= 2; y -= 2; break;
        }
    }
    if (!map_grid_is_inside(x, y, 3)) {
        return 999;
    }

    int base_offset = map_grid_offset(x, y);
    int tile_offsets[] = {
        OFFSET(0,0), OFFSET(1,0), OFFSET(2,0),
        OFFSET(0,1), OFFSET(1,1), OFFSET(2,1),
        OFFSET(0,2), OFFSET(1,2), OFFSET(2,2)
    };
    int should_be_water[4][9] = {
        {1, 1, 1, 0, 0, 0, 0, 0, 0},
        {0, 0, 1, 0, 0, 1, 0, 0, 1},
        {0, 0, 0, 0, 0, 0, 1, 1, 1},
        {1, 0, 0, 1, 0, 0, 1, 0, 0}
    };
    for (int dir = 0; dir < 4; dir++) {
        int ok_tiles = 0;
        int blocked_tiles = 0;
        for (int i = 0; i < 9; i++) {
            int grid_offset = base_offset + tile_offsets[i];
            if (should_be_water[dir][i]) {
                if (!map_terrain_is(grid_offset, TERRAIN_WATER)) {
                    break;
                }
                ok_tiles++;
                if (map_terrain_is(grid_offset, TERRAIN_ROCK | TERRAIN_ROAD)) {
                    // bridge or map edge
                    blocked_tiles++;
                }
            } else {
                if (map_terrain_is(grid_offset, TERRAIN_WATER)) {
                    break;
                }
                ok_tiles++;
                if (map_terrain_is(grid_offset, blocked_land_terrain())) {
                    blocked_tiles++;
                }
            }
        }
        // check two water tiles at the side
        int tiles_to_check[4][2] = {
          {OFFSET(-1,0), OFFSET(3,0)}, {OFFSET(2,-1), OFFSET(2,3)},
          {OFFSET(3,2), OFFSET(-1,2)}, {OFFSET(0,-1), OFFSET(0,3)}
        };
        for (int i = 0; i < 2; i++) {
            if (!map_terrain_is(base_offset + tiles_to_check[dir][i], TERRAIN_WATER)) {
                ok_tiles = 0;
            }
        }
        if (ok_tiles == 9) {
            // water/land is OK in this orientation
            if (orientation_absolute) {
                *orientation_absolute = dir;
            }
            if (orientation_relative) {
                *orientation_relative = (4 + dir - view_data.orientation / 2) % 4;
            }
            return blocked_tiles;
        }
    }
    return 999;
}

static void city_building_ghost_draw(struct map_tile_t *tile)
{
    if (!tile->grid_offset || scroll_data.is_scrolling || scroll_data.drag.active) {
        return;
    }

    int type = construction_data.type;
    if (construction_data.draw_as_constructing || type == BUILDING_NONE || type == BUILDING_CLEAR_LAND) {
        return;
    }
    int x, y;
    city_view_get_selected_tile_pixels(&x, &y);
    struct building_properties_t *building_props = &building_properties[type];
    int building_size = type == BUILDING_WAREHOUSE ? 3 : building_props->size;
    int num_tiles = building_size * building_size;
    int blocked_tiles[num_tiles];
    int orientation_index = view_data.orientation / 2;
    if (!city_finance_can_afford(building_properties[type].cost)) {
        draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 1);
        if (type == BUILDING_HIPPODROME) {
            int blocked_tiles2[MAX_TILES_BUILDING_PREVIEW];
            int blocked_tiles3[MAX_TILES_BUILDING_PREVIEW];
            draw_blocked_building_preview(x + HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + HIPPODROME_Y_VIEW_OFFSETS[orientation_index], num_tiles, blocked_tiles2, 1);
            draw_blocked_building_preview(x + 2 * HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + 2 * HIPPODROME_Y_VIEW_OFFSETS[orientation_index], num_tiles, blocked_tiles3, 1);
        } else if (building_is_fort(type)) {
            int num_fort_ground_tiles = building_properties[BUILDING_FORT_GROUND].size * building_properties[BUILDING_FORT_GROUND].size;
            int blocked_tiles_ground[MAX_TILES_BUILDING_PREVIEW];
            draw_blocked_building_preview(x + FORT_GROUND_X_VIEW_OFFSETS[orientation_index], y + FORT_GROUND_Y_VIEW_OFFSETS[orientation_index], num_fort_ground_tiles, blocked_tiles_ground, 1);
        }
        return;
    }
    int x_dir_offset = 0;
    int y_dir_offset = 0;
    switch (view_data.orientation) {
        case DIR_0_TOP:
            x_dir_offset = tile->x;
            y_dir_offset = tile->y;
            break;
        case DIR_2_RIGHT:
            x_dir_offset = tile->x - building_size + 1;
            y_dir_offset = tile->y;
            break;
        case DIR_4_BOTTOM:
            x_dir_offset = tile->x - building_size + 1;
            y_dir_offset = tile->y - building_size + 1;
            break;
        case DIR_6_LEFT:
            x_dir_offset = tile->x;
            y_dir_offset = tile->y - building_size + 1;
            break;
        default:
            x_dir_offset = 0;
            y_dir_offset = 0;
    }
    if (!check_building_terrain_requirements(x_dir_offset, y_dir_offset, 0)) {
        draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 1);
        return;
    }
    int image_id = image_data_s.group_image_ids[building_props->image_group] + building_props->image_offset;
    if (type == BUILDING_GATEHOUSE) {
        int orientation = map_orientation_for_gatehouse(tile->x, tile->y);
        int image_offset;
        if (orientation == 2) {
            image_offset = 1;
        } else if (orientation == 1) {
            image_offset = 0;
        } else {
            image_offset = construction_data.road_orientation == 2 ? 1 : 0;
        }
        int map_orientation = view_data.orientation;
        if (map_orientation == DIR_6_LEFT || map_orientation == DIR_2_RIGHT) {
            image_offset = 1 - image_offset;
        }
        image_id += image_offset;
    } else if (type == BUILDING_TRIUMPHAL_ARCH) {
        int orientation = map_orientation_for_triumphal_arch(tile->x, tile->y);
        int image_offset;
        if (orientation == 2) {
            image_offset = 2;
        } else if (orientation == 1) {
            image_offset = 0;
        } else {
            image_offset = construction_data.road_orientation == 2 ? 2 : 0;
        }
        int map_orientation = view_data.orientation;
        if (map_orientation == DIR_6_LEFT || map_orientation == DIR_2_RIGHT) {
            image_offset = 2 - image_offset;
        }
        image_id += image_offset;
    }
    int dir_absolute;
    int dir_relative;
    switch (type) {
        case BUILDING_HOUSE_VACANT_LOT:
            if (map_terrain_is(tile->grid_offset, TERRAIN_NOT_CLEAR)) {
                image_draw_blend(image_data_s.group_image_ids[GROUP_TERRAIN_FLAT_TILE], x, y, COLOR_MASK_RED);
                return;
            }
            draw_building(image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_VACANT_LOT], x, y);
            return;
        case BUILDING_ROAD:
            if (map_terrain_is(tile->grid_offset, TERRAIN_NOT_CLEAR)) {
                image_draw_blend(image_data_s.group_image_ids[GROUP_TERRAIN_FLAT_TILE], x, y, COLOR_MASK_RED);
                return;
            }
            if (map_terrain_is(tile->grid_offset, TERRAIN_AQUEDUCT)) {
                if (map_can_place_road_under_aqueduct(tile->grid_offset)) {
                    image_id = images.items[tile->grid_offset];
                    switch (image_id) {
                        case 2:
                            image_id += 8;
                            break;
                        case 3:
                            image_id += 9;
                            break;
                        case 17:
                            image_id += 23;
                            break;
                        case 18:
                            image_id += 24;
                            break;
                        default:
                            break;
                            draw_building(image_id, x, y);
                    }
                } else {
                    image_draw_blend(image_data_s.group_image_ids[GROUP_TERRAIN_FLAT_TILE], x, y, COLOR_MASK_RED);
                }
            } else {
                if (!map_terrain_has_adjacent_x_with_type(tile->grid_offset, TERRAIN_ROAD) &&
                    map_terrain_has_adjacent_y_with_type(tile->grid_offset, TERRAIN_ROAD)) {
                    image_id++;
                }
                draw_building(image_id, x, y);
            }
            return;
        case BUILDING_RESERVOIR:
            if (building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, type)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                return;
            }
            // y + 30 to center mouse, 11 instead of 10 range to compensate for building size
            draw_water_range_preview(x, y + 30, 11);
            draw_building(image_id, x, y);
            if (map_terrain_exists_tile_in_area_with_type(tile->x - 1, tile->y - 1, 5, TERRAIN_WATER)) {
                struct image_t *img = image_get(image_id);
                int x_water = x - 58 + img->sprite_offset_x - 2;
                int y_water = y + img->sprite_offset_y - (img->height - 90);
                image_draw_masked(image_id + 1, x_water, y_water, COLOR_MASK_GREEN);
            }
            return;
        case BUILDING_AQUEDUCT:
            if (map_terrain_is(tile->grid_offset, TERRAIN_ROAD)) {
                int map_is_straight_road_for_aqueduct = 0;
                int road_tiles_x =
                    is_road_tile_for_aqueduct(tile->grid_offset + map_grid_delta(1, 0), 2) +
                    is_road_tile_for_aqueduct(tile->grid_offset + map_grid_delta(-1, 0), 2);
                int road_tiles_y =
                    is_road_tile_for_aqueduct(tile->grid_offset + map_grid_delta(0, -1), 1) +
                    is_road_tile_for_aqueduct(tile->grid_offset + map_grid_delta(0, 1), 1);
                if ((road_tiles_x == 2 && road_tiles_y == 0)
                || (road_tiles_y == 2 && road_tiles_x == 0)) {
                    map_is_straight_road_for_aqueduct = 1;
                }
                if (!map_is_straight_road_for_aqueduct || bitfields_grid.items[tile->grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
                    image_draw_blend(image_data_s.group_image_ids[GROUP_TERRAIN_FLAT_TILE], x, y, COLOR_MASK_RED);
                    return;
                }
            } else if (map_terrain_is(tile->grid_offset, TERRAIN_NOT_CLEAR)) {
                image_draw_blend(image_data_s.group_image_ids[GROUP_TERRAIN_FLAT_TILE], x, y, COLOR_MASK_RED);
                return;
            }
            struct terrain_image_t *terrain_img = map_image_context_get_aqueduct(tile->grid_offset, 1);
            if (map_terrain_is(tile->grid_offset, TERRAIN_ROAD)) {
                int group_offset = terrain_img->group_offset;
                if (!terrain_img->aqueduct_offset) {
                    if (map_terrain_is(tile->grid_offset + map_grid_delta(0, -1), TERRAIN_ROAD)) {
                        group_offset = 3;
                    } else {
                        group_offset = 2;
                    }
                }
                if (map_tiles_is_paved_road(tile->grid_offset)) {
                    image_id += group_offset + 13;
                } else {
                    image_id += group_offset + 21;
                }
            } else {
                image_id += terrain_img->group_offset + 15;
            }
            draw_building(image_id, x, y);
            return;
        case BUILDING_FOUNTAIN:
            if (map_terrain_is(tile->grid_offset, TERRAIN_NOT_CLEAR)) {
                image_draw_blend(image_data_s.group_image_ids[GROUP_TERRAIN_FLAT_TILE], x, y, COLOR_MASK_RED);
                return;
            }
            draw_water_range_preview(x, y, scenario.climate == CLIMATE_DESERT ? 3 : 4);
            draw_building(image_id, x, y);
            if (map_terrain_is(tile->grid_offset, TERRAIN_RESERVOIR_RANGE)) {
                struct image_t *img = image_get(image_id);
                image_draw_masked(image_id + 1, x + img->sprite_offset_x, y + img->sprite_offset_y, COLOR_MASK_GREEN);
            }
            return;
        case BUILDING_WELL:
            if (map_terrain_is(tile->grid_offset, TERRAIN_NOT_CLEAR)) {
                image_draw_blend(image_data_s.group_image_ids[GROUP_TERRAIN_FLAT_TILE], x, y, COLOR_MASK_RED);
                return;
            }
            draw_water_range_preview(x, y, 2);
            draw_building(image_id, x, y);
            return;
        case BUILDING_BATHHOUSE:
            if (building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, type)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                return;
            }
            draw_building(image_id, x, y);
            for (int i = 0; i < num_tiles; i++) {
                if (map_terrain_is(tile->grid_offset + TILE_GRID_OFFSETS[orientation_index][i], TERRAIN_RESERVOIR_RANGE)) {
                    struct image_t *img = image_get(image_id);
                    image_draw_masked(image_id - 1, x + img->sprite_offset_x - 7, y + img->sprite_offset_y + 6, COLOR_MASK_GREEN);
                    break;
                }
            }
            return;
        case BUILDING_HIPPODROME:
        {
            int blocked_tiles2[25];
            int blocked_tiles3[25];
            if (city_data.building.hippodrome_placed) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 1);
                draw_blocked_building_preview(x + HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + HIPPODROME_Y_VIEW_OFFSETS[orientation_index], num_tiles, blocked_tiles2, 1);
                draw_blocked_building_preview(x + 2 * HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + 2 * HIPPODROME_Y_VIEW_OFFSETS[orientation_index], num_tiles, blocked_tiles3, 1);
                return;
            }
            int blocked1 = building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, type);
            int blocked2 = building_preview_blocked(tile->grid_offset + map_grid_delta(5, 0), num_tiles, blocked_tiles2, type);
            int blocked3 = building_preview_blocked(tile->grid_offset + map_grid_delta(10, 0), num_tiles, blocked_tiles3, type);
            if (blocked1 || blocked2 || blocked3) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                draw_blocked_building_preview(x + HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + HIPPODROME_Y_VIEW_OFFSETS[orientation_index], num_tiles, blocked_tiles2, 0);
                draw_blocked_building_preview(x + 2 * HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + 2 * HIPPODROME_Y_VIEW_OFFSETS[orientation_index], num_tiles, blocked_tiles3, 0);
                return;
            }
            if (orientation_index == 0) {
                image_id = image_data_s.group_image_ids[GROUP_BUILDING_HIPPODROME_2];
                // part 1, 2, 3
                draw_building(image_id, x, y);
                draw_building(image_id + 2, x + HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + HIPPODROME_Y_VIEW_OFFSETS[orientation_index]);
                draw_building(image_id + 4, x + 2 * HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + 2 * HIPPODROME_Y_VIEW_OFFSETS[orientation_index]);
            } else if (orientation_index == 1) {
                image_id = image_data_s.group_image_ids[GROUP_BUILDING_HIPPODROME_1];
                // part 3, 2, 1
                draw_building(image_id, x + 2 * HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + 2 * HIPPODROME_Y_VIEW_OFFSETS[orientation_index]);
                draw_building(image_id + 2, x + HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + HIPPODROME_Y_VIEW_OFFSETS[orientation_index]);
                draw_building(image_id + 4, x, y);
            } else if (orientation_index == 2) {
                image_id = image_data_s.group_image_ids[GROUP_BUILDING_HIPPODROME_2];
                // part 1, 2, 3
                draw_building(image_id + 4, x, y);
                draw_building(image_id + 2, x + HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + HIPPODROME_Y_VIEW_OFFSETS[orientation_index]);
                draw_building(image_id, x + 2 * HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + 2 * HIPPODROME_Y_VIEW_OFFSETS[orientation_index]);
            } else if (orientation_index == 3) {
                image_id = image_data_s.group_image_ids[GROUP_BUILDING_HIPPODROME_1];
                // part 3, 2, 1
                draw_building(image_id + 4, x + 2 * HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + 2 * HIPPODROME_Y_VIEW_OFFSETS[orientation_index]);
                draw_building(image_id + 2, x + HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + HIPPODROME_Y_VIEW_OFFSETS[orientation_index]);
                draw_building(image_id, x, y);
            }
            return;
        }
        case BUILDING_SENATE:
            if (city_data.building.senate_placed) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 1);
                return;
            }
            if (building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, type)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                return;
            }
            draw_building(image_id, x, y);
            return;
        case BUILDING_TRIUMPHAL_ARCH:
            if (building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, type)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                return;
            }
            draw_building(image_id, x, y);
            struct image_t *img = image_get(image_id + 1);
            if (image_id == image_data_s.group_image_ids[GROUP_BUILDING_TRIUMPHAL_ARCH]) {
                image_draw_masked(image_id + 1, x + img->sprite_offset_x + 4, y + img->sprite_offset_y - 51, COLOR_MASK_GREEN);
            } else {
                image_draw_masked(image_id + 1, x + img->sprite_offset_x - 33, y + img->sprite_offset_y - 56, COLOR_MASK_GREEN);
            }
            return;
        case BUILDING_PLAZA:
            if (!map_terrain_is(tile->grid_offset, TERRAIN_ROAD)) {
                image_draw_blend(image_data_s.group_image_ids[GROUP_TERRAIN_FLAT_TILE], x, y, COLOR_MASK_RED);
                return;
            }
            draw_building(image_id, x, y);
            return;
        case BUILDING_LOW_BRIDGE:
        case BUILDING_SHIP_BRIDGE:
            int length, direction;
            int end_grid_offset = 0;
            int grid_offset = map_grid_offset(tile->x, tile->y);
            bridge.end_grid_offset = 0;
            bridge.direction_grid_delta = 0;
            bridge.length = length = 0;
            bridge.direction = direction = 0;
            if (!map_terrain_is(grid_offset, TERRAIN_WATER)) {
                end_grid_offset = 0;
            } else if (map_terrain_is(grid_offset, TERRAIN_ROAD | TERRAIN_BUILDING)) {
                end_grid_offset = 0;
            } else if (map_terrain_count_directly_adjacent_with_type(grid_offset, TERRAIN_WATER) != 3) {
                end_grid_offset = 0;
            } else {
                if (!map_terrain_is(grid_offset + map_grid_delta(0, -1), TERRAIN_WATER)) {
                    bridge.direction_grid_delta = map_grid_delta(0, 1);
                    bridge.direction = DIR_4_BOTTOM;
                } else if (!map_terrain_is(grid_offset + map_grid_delta(1, 0), TERRAIN_WATER)) {
                    bridge.direction_grid_delta = map_grid_delta(-1, 0);
                    bridge.direction = DIR_6_LEFT;
                } else if (!map_terrain_is(grid_offset + map_grid_delta(0, 1), TERRAIN_WATER)) {
                    bridge.direction_grid_delta = map_grid_delta(0, -1);
                    bridge.direction = DIR_0_TOP;
                } else if (!map_terrain_is(grid_offset + map_grid_delta(-1, 0), TERRAIN_WATER)) {
                    bridge.direction_grid_delta = map_grid_delta(1, 0);
                    bridge.direction = DIR_2_RIGHT;
                } else {
                    end_grid_offset = 0;
                }
                if (end_grid_offset) {
                    direction = bridge.direction;
                    bridge.length = 1;
                    for (int i = 0; i < 40; i++) {
                        grid_offset += bridge.direction_grid_delta;
                        bridge.length++;
                        int next_offset = grid_offset + bridge.direction_grid_delta;
                        if (map_terrain_is(next_offset, TERRAIN_SHRUB)) {
                            break;
                        }
                        if (!map_terrain_is(next_offset, TERRAIN_WATER)) {
                            bridge.end_grid_offset = grid_offset;
                            if (map_terrain_count_directly_adjacent_with_type(grid_offset, TERRAIN_WATER) != 3) {
                                bridge.end_grid_offset = 0;
                            }
                            length = bridge.length;
                            end_grid_offset = bridge.end_grid_offset;
                        } else {
                            if (map_terrain_is(next_offset, TERRAIN_ROAD | TERRAIN_BUILDING)) {
                                break;
                            }
                            int count = 0;
                            if (map_terrain_is(grid_offset + map_grid_delta(1, -1), TERRAIN_WATER)) {
                                count++;
                            }
                            if (map_terrain_is(grid_offset + map_grid_delta(1, 1), TERRAIN_WATER)) {
                                count++;
                            }
                            if (map_terrain_is(grid_offset + map_grid_delta(-1, 1), TERRAIN_WATER)) {
                                count++;
                            }
                            if (map_terrain_is(grid_offset + map_grid_delta(-1, -1), TERRAIN_WATER)) {
                                count++;
                            }
                            if (count != 4) {
                                break;
                            }
                        }
                    }
                    // invalid bridge
                    length = bridge.length;
                }
            }
            int dir = direction - view_data.orientation;
            if (dir < 0) {
                dir += 8;
            }
            int blocked = 0;
            if (type == BUILDING_SHIP_BRIDGE && length < 5) {
                blocked = 1;
            } else if (!end_grid_offset) {
                blocked = 1;
            }
            int x_delta, y_delta;
            switch (dir) {
                case DIR_0_TOP:
                    x_delta = 29;
                    y_delta = -15;
                    break;
                case DIR_2_RIGHT:
                    x_delta = 29;
                    y_delta = 15;
                    break;
                case DIR_4_BOTTOM:
                    x_delta = -29;
                    y_delta = 15;
                    break;
                case DIR_6_LEFT:
                    x_delta = -29;
                    y_delta = -15;
                    break;
                default:
                    return;
            }
            if (blocked) {
                image_draw_blend(image_data_s.group_image_ids[GROUP_TERRAIN_FLAT_TILE], x, y, length > 0 ? COLOR_MASK_GREEN : COLOR_MASK_RED);
                if (length > 1) {
                    image_draw_blend(image_data_s.group_image_ids[GROUP_TERRAIN_FLAT_TILE], x + x_delta * (length - 1), y + y_delta * (length - 1), COLOR_MASK_RED);
                }
                construction_data.cost_preview = 0;
            } else {
                if (dir == DIR_0_TOP || dir == DIR_6_LEFT) {
                    for (int i = length - 1; i >= 0; i--) {
                        int sprite_id = map_bridge_get_sprite_id(i, length, dir, type == BUILDING_SHIP_BRIDGE);
                        city_draw_bridge_tile(x + x_delta * i, y + y_delta * i, sprite_id, COLOR_MASK_GREEN);
                    }
                } else {
                    for (int i = 0; i < length; i++) {
                        int sprite_id = map_bridge_get_sprite_id(i, length, dir, type == BUILDING_SHIP_BRIDGE);
                        city_draw_bridge_tile(x + x_delta * i, y + y_delta * i, sprite_id, COLOR_MASK_GREEN);
                    }
                }
                construction_data.cost_preview = building_properties[type].cost * length;
            }
            break;
        case BUILDING_SHIPYARD:
        case BUILDING_WHARF:
            if (map_water_determine_orientation_size2(tile->x, tile->y, 1, &dir_absolute, &dir_relative)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 1);
                return;
            }
            image_id = image_data_s.group_image_ids[building_props->image_group] + building_props->image_offset + dir_relative;
            draw_building(image_id, x, y);
            return;
        case BUILDING_DOCK:
            if (map_water_determine_orientation_size3(tile->x, tile->y, 1, &dir_absolute, &dir_relative)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 1);
                return;
            }
            switch (dir_relative) {
                case 0: image_id = image_data_s.group_image_ids[GROUP_BUILDING_DOCK_1]; break;
                case 1: image_id = image_data_s.group_image_ids[GROUP_BUILDING_DOCK_2]; break;
                case 2: image_id = image_data_s.group_image_ids[GROUP_BUILDING_DOCK_3]; break;
                default:image_id = image_data_s.group_image_ids[GROUP_BUILDING_DOCK_4]; break;
            }
            draw_building(image_id, x, y);
            return;
        case BUILDING_GATEHOUSE:
            if (building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, type)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                return;
            }
            // update road required based on timer
            if (construction_data.road_orientation > 0) {
                if (current_time - construction_data.road_last_update > 1500) {
                    construction_data.road_last_update = current_time;
                    construction_data.road_orientation = construction_data.road_orientation == 1 ? 2 : 1;
                }
            }
            draw_building(image_id, x, y);
            return;
        case BUILDING_FORT_LEGIONARIES:
        case BUILDING_FORT_JAVELIN:
        case BUILDING_FORT_MOUNTED:
        {
            int num_fort_ground_tiles = building_properties[BUILDING_FORT_GROUND].size * building_properties[BUILDING_FORT_GROUND].size;
            int blocked_tiles_ground[MAX_TILES_BUILDING_PREVIEW];
            if (city_data.military.total_legions >= MAX_LEGIONS) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 1);
                draw_blocked_building_preview(x + FORT_GROUND_X_VIEW_OFFSETS[orientation_index], y + FORT_GROUND_Y_VIEW_OFFSETS[orientation_index], num_fort_ground_tiles, blocked_tiles_ground, 1);
                return;
            }
            int blocked1_f = building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, type);
            int blocked2_f = building_preview_blocked(tile->grid_offset + FORT_GROUND_GRID_OFFSETS[orientation_index], num_fort_ground_tiles, blocked_tiles_ground, type);
            if (blocked1_f || blocked2_f) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                draw_blocked_building_preview(x + FORT_GROUND_X_VIEW_OFFSETS[orientation_index], y + FORT_GROUND_Y_VIEW_OFFSETS[orientation_index], num_fort_ground_tiles, blocked_tiles_ground, 0);
                return;
            }
            if (orientation_index == 0 || orientation_index == 3) {
                draw_building(image_id, x, y);
                draw_building(image_id + 1, x + FORT_GROUND_X_VIEW_OFFSETS[orientation_index], y + FORT_GROUND_Y_VIEW_OFFSETS[orientation_index]);
            } else {
                draw_building(image_id + 1, x + FORT_GROUND_X_VIEW_OFFSETS[orientation_index], y + FORT_GROUND_Y_VIEW_OFFSETS[orientation_index]);
                draw_building(image_id, x, y);
            }
            return;
        }
        case BUILDING_BARRACKS:
            if (count_data.buildings[BUILDING_BARRACKS].total) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 1);
                return;
            }
            if (building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, type)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                return;
            }
            draw_building(image_id, x, y);
            return;
        case BUILDING_WHEAT_FARM:
        case BUILDING_VEGETABLE_FARM:
        case BUILDING_FRUIT_FARM:
        case BUILDING_OLIVE_FARM:
        case BUILDING_VINES_FARM:
        case BUILDING_PIG_FARM:
            if (building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, type)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                return;
            }
            draw_building(image_id, x, y);
            // fields
            for (int i = 4; i < 9; i++) {
                image_draw_isometric_footprint(image_id + 1, x + X_VIEW_OFFSETS[i], y + Y_VIEW_OFFSETS[i], COLOR_MASK_GREEN);
            }
            return;
        case BUILDING_GRANARY:
            if (building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, type)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                return;
            }
            image_draw_isometric_footprint(image_id, x, y, COLOR_MASK_GREEN);
            struct image_t *img_granary = image_get(image_id + 1);
            image_draw_masked(image_id + 1, x + img_granary->sprite_offset_x - 32, y + img_granary->sprite_offset_y - 64, COLOR_MASK_GREEN);
            return;
        case BUILDING_WAREHOUSE:
            if (building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, type)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                return;
            }
            draw_building(image_id, x, y);
            image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_WAREHOUSE] + 17, x - 4, y - 42, COLOR_MASK_GREEN);
            for (int i = 1; i < 9; i++) {
                draw_building(EMPTY_WAREHOUSE_IMG_ID, x + X_VIEW_OFFSETS[i], y + Y_VIEW_OFFSETS[i]);
            }
            return;
        default:
            if (building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, type)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                return;
            }
            draw_building(image_id, x, y);
            return;
    }
}

static void draw_elevated_figures_without_overlay(int x, int y, int grid_offset)
{
    int figure_id = map_grid_is_valid_offset(grid_offset) ? map_figures.items[grid_offset] : 0;
    while (figure_id > 0) {
        struct figure_t *f = &figures[figure_id];
        if ((f->use_cross_country && !f->is_invisible) || f->height_adjusted_ticks) {
            city_draw_figure(f, x, y, 0);
        }
        figure_id = f->next_figure_id_on_same_tile;
    }
}

static void draw_hippodrome_ornaments(int x, int y, int grid_offset)
{
    struct image_t *img = image_get(images.items[grid_offset]);
    struct building_t *b = &all_buildings[map_building_at(grid_offset)];
    if (img->num_animation_sprites
        && edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE
        && b->type == BUILDING_HIPPODROME) {
        image_draw_masked(images.items[grid_offset] + 1,
            x + img->sprite_offset_x, y + img->sprite_offset_y - img->height + 90,
            draw_building_as_deleted_2(b) ? COLOR_MASK_RED : 0
        );
    }
}

static int should_draw_top_before_deletion_without_overlay(int grid_offset)
{
    int has_adjacent_deletion = 0;
    int size = map_property_multi_tile_size(grid_offset);
    int total_adjacent_offsets = size * 2 + 1;
    int *adjacent_offset = ADJACENT_OFFSETS[size - 1][view_data.orientation / 2];
    for (int i = 0; i < total_adjacent_offsets; ++i) {
        if ((bitfields_grid.items[grid_offset + adjacent_offset[i]] & BIT_DELETED) ||
            draw_building_as_deleted_2(&all_buildings[map_building_at(grid_offset + adjacent_offset[i])])) {
            has_adjacent_deletion = 1;
            break;
        }
    }
    return is_multi_tile_terrain(grid_offset) && has_adjacent_deletion;
}

static void deletion_draw_terrain_top_without_overlay(int x, int y, int grid_offset)
{
    if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE && should_draw_top_before_deletion_without_overlay(grid_offset)) {
        draw_top_without_overlay(x, y, grid_offset);
    }
}

static void deletion_draw_figures_animations(int x, int y, int grid_offset)
{
    if (bitfields_grid.items[grid_offset] & BIT_DELETED || draw_building_as_deleted_2(&all_buildings[map_building_at(grid_offset)])) {
        image_draw_blend(image_data_s.group_image_ids[GROUP_TERRAIN_FLAT_TILE], x, y, COLOR_MASK_RED);
    }
    if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE && !should_draw_top_before_deletion_without_overlay(grid_offset)) {
        draw_top_without_overlay(x, y, grid_offset);
    }
    draw_figures_without_overlay(x, y, grid_offset);
    draw_animation_without_overlay(x, y, grid_offset);
}

static void deletion_draw_remaining(int x, int y, int grid_offset)
{
    draw_elevated_figures_without_overlay(x, y, grid_offset);
    draw_hippodrome_ornaments(x, y, grid_offset);
}

static void city_without_overlay_draw(int selected_figure_id, struct pixel_coordinate_t *figure_coord, struct map_tile_t *tile)
{
    int highlighted_formation = -1;
    if (values[CONFIG_UI_HIGHLIGHT_LEGIONS]) {
        highlighted_formation = formation_legion_at_grid_offset(tile->grid_offset);
        if (highlighted_formation > -1) {
            if (selected_legion_formation > -1 && highlighted_formation != selected_legion_formation) {
                highlighted_formation = -1;
            }
            if (legion_formations[highlighted_formation].in_distant_battle) {
                highlighted_formation = -1;
            }
        }
    }
    draw_context.advance_water_animation = 0;
    if (!selected_figure_id) {
        uint32_t now = current_time;
        if (now - draw_context.last_water_animation_time > 60) {
            draw_context.last_water_animation_time = now;
            draw_context.advance_water_animation = 1;
        }
    }
    draw_context.image_id_water_first = image_data_s.group_image_ids[GROUP_TERRAIN_WATER];
    draw_context.image_id_water_last = 5 + draw_context.image_id_water_first;
    draw_context.selected_figure_id = selected_figure_id;
    draw_context.selected_figure_coord = figure_coord;
    draw_context.highlighted_formation = highlighted_formation;
    int should_mark_deleting = city_building_ghost_mark_deleting(tile);
    city_view_foreach_map_tile(draw_footprint_without_overlay);
    if (!should_mark_deleting) {
        city_view_foreach_valid_map_tile(
            draw_top_without_overlay,
            draw_figures_without_overlay,
            draw_animation_without_overlay
        );
        if (!selected_figure_id) {
            city_building_ghost_draw(tile);
        }
        city_view_foreach_valid_map_tile(
            draw_elevated_figures_without_overlay,
            draw_hippodrome_ornaments,
            0
        );
    } else {
        city_view_foreach_map_tile(deletion_draw_terrain_top_without_overlay);
        city_view_foreach_map_tile(deletion_draw_figures_animations);
        city_view_foreach_map_tile(deletion_draw_remaining);
    }
}

static void translate_clip(int dx, int dy)
{
    clip_rectangle.x_start -= dx;
    clip_rectangle.x_end -= dx;
    clip_rectangle.y_start -= dy;
    clip_rectangle.y_end -= dy;
}

static void graphics_reset_clip_rectangle(void)
{
    clip_rectangle.x_start = 0;
    clip_rectangle.x_end = canvas.width;
    clip_rectangle.y_start = 0;
    clip_rectangle.y_end = canvas.height;
    translate_clip(translation.x, translation.y);
}

static void graphics_save_screenshot(int full_city)
{
    if (full_city) {
        if (window_data.current_window->id != WINDOW_CITY && window_data.current_window->id != WINDOW_CITY_MILITARY) {
            return;
        }
        struct pixel_view_coordinates_t original_camera_pixels;
        original_camera_pixels.x = view_data.camera.tile.x * TILE_WIDTH_PIXELS + view_data.camera.pixel.x;
        original_camera_pixels.y = view_data.camera.tile.y * HALF_TILE_HEIGHT_PIXELS + view_data.camera.pixel.y;
        int width = screen_data.width;
        int height = screen_data.height;

        int city_width_pixels = map_data.width * TILE_X_SIZE;
        int city_height_pixels = map_data.height * TILE_Y_SIZE;

        if (!create_bmp_chunk(city_width_pixels, IMAGE_HEIGHT_CHUNK)) {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to assign memory for full city screenshot creation", 0, 0));
            return;
        }
        char *filename = generate_filename(FULL_CITY_SCREENSHOT);
        FILE *fp = fopen(filename, "wb");
        if (!fp) {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to write screenshot to:", filename, 0));
            free_bmp_chunk();
            return;
        }
        uint8_t header[HEADER_SIZE_BMP];
        struct buffer_t buf;
        buffer_init(&buf, header, HEADER_SIZE_BMP);
        write_bmp_header(&buf, city_height_pixels + TILE_Y_SIZE);
        fwrite(header, 1, HEADER_SIZE_BMP, fp);
        int new_width = city_width_pixels + (view_data.sidebar_collapsed ? 40 : 160);
        screen_set_resolution(new_width, 24 + IMAGE_HEIGHT_CHUNK);
        graphics_set_clip_rectangle(0, 24, city_width_pixels, IMAGE_HEIGHT_CHUNK);
        int base_width = (GRID_SIZE * TILE_X_SIZE - city_width_pixels) / 2 + TILE_X_SIZE;
        int max_height = (GRID_SIZE * TILE_Y_SIZE + city_height_pixels) / 2;
        int min_height = max_height - city_height_pixels - TILE_Y_SIZE;
        struct map_tile_t dummy_tile = { 0, 0, 0 };
        for (int current_height = max_height - IMAGE_HEIGHT_CHUNK; current_height >= min_height; current_height -= IMAGE_HEIGHT_CHUNK) {
            city_view_set_camera_from_pixel_position(base_width, current_height);
            city_without_overlay_draw(0, 0, &dummy_tile);
            for (int y = IMAGE_HEIGHT_CHUNK - 1; y >= 0; y--) {
                for (int x = 0; x < city_width_pixels; x++) {
                    pixel(canvas.pixels[(y + 24) * new_width + x],
                        &bmp_chunk.pixels[3 * x + 2], &bmp_chunk.pixels[3 * x + 1], &bmp_chunk.pixels[3 * x]);
                }
                fwrite(bmp_chunk.pixels, sizeof(uint8_t), bmp_chunk.scanline_size, fp);
            }
        }
        graphics_reset_clip_rectangle();
        screen_set_resolution(width, height);
        city_view_set_camera_from_pixel_position(original_camera_pixels.x, original_camera_pixels.y);
        fclose(fp);
        free_bmp_chunk();
        SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Saved full city screenshot:", filename, 0));
        show_saved_notice(filename);
    } else {
        uint8_t header[HEADER_SIZE_BMP];
        struct buffer_t buf;
        buffer_init(&buf, header, HEADER_SIZE_BMP);
        int width = screen_data.width;
        int height = screen_data.height;
        if (!create_bmp_chunk(width, 1)) {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to create memory for screenshot", 0, 0));
            return;
        }
        char *filename = generate_filename(DISPLAY_SCREENSHOT);
        FILE *fp = fopen(filename, "wb");
        if (!fp) {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to write screenshot to:", filename, 0));
            free_bmp_chunk();
            return;
        }
        write_bmp_header(&buf, height);
        fwrite(header, 1, HEADER_SIZE_BMP, fp);
        for (int y = height - 1; y >= 0; y--) {
            for (int x = 0; x < width; x++) {
                pixel(canvas.pixels[y * width + x],
                    &bmp_chunk.pixels[3 * x + 2], &bmp_chunk.pixels[3 * x + 1], &bmp_chunk.pixels[3 * x]);
            }
            fwrite(bmp_chunk.pixels, sizeof(uint8_t), bmp_chunk.scanline_size, fp);
        }
        fclose(fp);
        free_bmp_chunk();
        SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Saved screenshot:", filename, 0));
        show_saved_notice(filename);
    }
}

static void update_button_state(struct mouse_button_t *button)
{
    button->went_down = (button->system_change & SYSTEM_DOWN) == SYSTEM_DOWN;
    button->went_up = (button->system_change & SYSTEM_UP) == SYSTEM_UP;
    button->double_click = (button->system_change & SYSTEM_DOUBLE_CLICK) == SYSTEM_DOUBLE_CLICK;
    button->system_change = SYSTEM_NONE;
    button->is_down = (button->is_down || button->went_down) && !button->went_up;
}

static int text_get_width(char *str, int font)
{
    struct font_definition_t *def = &font_data.font_definitions[font];
    int maxlen = 10000;
    int width = 0;
    while (*str && maxlen > 0) {
        int num_bytes = 1;
        if (*str == ' ') {
            width += def->space_width;
        } else {
            int letter_id = font_letter_id(def, str);
            if (letter_id >= 0) {
                width += def->letter_spacing + image_letter(letter_id)->width;
            }
        }
        str += num_bytes;
        maxlen -= num_bytes;
    }
    return width;
}

static void label_draw(int x, int y, int width_blocks, int type)
{
    int image_base = image_data_s.group_image_ids[GROUP_PANEL_BUTTON];
    for (int i = 0; i < width_blocks; i++) {
        int image_id;
        if (i == 0) {
            image_id = 3 * type + 40;
        } else if (i < width_blocks - 1) {
            image_id = 3 * type + 41;
        } else {
            image_id = 3 * type + 42;
        }
        image_draw(image_base + image_id, x + BLOCK_SIZE * i, y);
    }
}

static void text_draw_centered(char *str, int x, int y, int box_width, int font, color_t color)
{
    int offset = (box_width - text_get_width(str, font)) / 2;
    if (offset < 0) {
        offset = 0;
    }
    text_draw(str, offset + x, y, font, color);
}

static void set_cursor(int cursor_id)
{
    cursor_data.current_shape = cursor_id;
    SDL_SetCursor(cursor_data.cursors[cursor_id]);
}

static Mix_Chunk *load_chunk(char *filename)
{
    if (filename[0]) {
        return Mix_LoadWAV(filename);
    } else {
        return 0;
    }
}

static int load_channel(struct sound_channel_t *channel)
{
    if (!channel->chunk && channel->filename) {
        channel->chunk = load_chunk(channel->filename);
    }
    return channel->chunk ? 1 : 0;
}

static void set_channel_volume(int channel, int volume_pct)
{
    if (data_channels.channels[channel].chunk) {
        Mix_VolumeChunk(data_channels.channels[channel].chunk, volume_pct * SDL_MIX_MAXVOLUME / 100);
    }
}

static void game_draw(void)
{
    update_button_state(&mouse_data.left);
    update_button_state(&mouse_data.right);
    if (hotkey_data.global_hotkey_state.reset_window) {
        system_resize(1280, 800);
        post_event(USER_EVENT_CENTER_WINDOW);
    }
    if (hotkey_data.global_hotkey_state.toggle_fullscreen) {
        post_event(settings_values[SETTINGS_FULLSCREEN] ? USER_EVENT_WINDOWED : USER_EVENT_FULLSCREEN);
    }
    if (hotkey_data.global_hotkey_state.save_screenshot) {
        graphics_save_screenshot(0);
    }
    if (hotkey_data.global_hotkey_state.save_city_screenshot) {
        graphics_save_screenshot(1);
    }
    struct window_type_t *w = window_data.current_window;
    if (window_data.refresh_on_draw) {
        w->draw_background();
        window_data.refresh_on_draw = 0;
        window_data.refresh_immediate = 0;
    }
    w->draw_foreground();
    struct hotkeys_t *h = &hotkey_data.hotkey_state;
    w->handle_input(&mouse_data, h);
    if (window_data.current_window->id != WINDOW_CITY && window_data.current_window->id != WINDOW_EDITOR_MAP) {
        city_warning_clear_all();
    } else {
        int center = (screen_data.width - 180) / 2;
        for (int i = 0; i < MAX_WARNINGS; i++) {
            char *text = 0;
            if (warnings[i].in_use) {
                text = warnings[i].text;
            }
            if (!text) {
                continue;
            }
            int top_offset = 30 + i * 25;
            if (state_data.paused) {
                top_offset += 70;
            }
            int box_width = 0;
            int width = text_get_width(text, FONT_NORMAL_BLACK);
            if (width <= 100) {
                box_width = 200;
            } else if (width <= 200) {
                box_width = 300;
            } else if (width <= 300) {
                box_width = 400;
            } else {
                box_width = 460;
            }
            label_draw(center - box_width / 2 + 1, top_offset, box_width / BLOCK_SIZE + 1, 1);
            if (box_width < 460) {
                // ornaments at the side
                image_draw(image_data_s.group_image_ids[GROUP_CONTEXT_ICONS] + 15, center - box_width / 2 + 2, top_offset + 2);
                image_draw(image_data_s.group_image_ids[GROUP_CONTEXT_ICONS] + 15, center + box_width / 2 - 30, top_offset + 2);
            }
            text_draw_centered(text, center - box_width / 2 + 1, top_offset + 4, box_width, FONT_NORMAL_WHITE, 0);
        }
        for (int i = 0; i < MAX_WARNINGS; i++) {
            if (warnings[i].in_use && current_time - warnings[i].time > TIMEOUT_MS) {
                warnings[i].in_use = 0;
            }
        }
    }
    mouse_data.scrolled = SCROLL_NONE;
    if (window_data.current_window->id == WINDOW_CITY_MILITARY) {
        set_cursor(CURSOR_SWORD);
    } else if (window_data.current_window->id == WINDOW_CITY && construction_data.type == BUILDING_CLEAR_LAND) {
        set_cursor(CURSOR_SHOVEL);
    } else {
        set_cursor(CURSOR_ARROW);
    }
    uint32_t now = current_time;
    for (int i = 1; i < MAX_CITY_SOUNDS_CHANNELS; i++) {
        channels[i].should_play = 0;
        if (channels[i].available) {
            channels[i].available = 0;
            if (channels[i].total_views >= channels[i].views_threshold) {
                if (now - channels[i].last_played_time >= channels[i].delay_millis) {
                    channels[i].should_play = 1;
                }
            }
        } else {
            channels[i].total_views = 0;
            for (int d = 0; d < 5; d++) {
                channels[i].direction_views[d] = 0;
            }
        }
    }
    if (now - last_update_time < 10000) {
        // Only play 1 sound every 10 seconds
        return;
    }
    uint32_t max_delay = 0;
    int max_sound_id = 0;
    for (int i = 1; i < MAX_CITY_SOUNDS_CHANNELS; i++) {
        if (channels[i].should_play) {
            if (now - channels[i].last_played_time > max_delay) {
                max_delay = now - channels[i].last_played_time;
                max_sound_id = i;
            }
        }
    }
    if (!max_sound_id) {
        return;
    }
    // always only one channel available... use it
    int channel = channels[max_sound_id].channel;
    int direction;
    if (channels[max_sound_id].direction_views[SOUND_DIRECTION_CENTER] > 10) {
        direction = SOUND_DIRECTION_CENTER;
    } else if (channels[max_sound_id].direction_views[SOUND_DIRECTION_LEFT] > 10) {
        direction = SOUND_DIRECTION_LEFT;
    } else if (channels[max_sound_id].direction_views[SOUND_DIRECTION_RIGHT] > 10) {
        direction = SOUND_DIRECTION_RIGHT;
    } else {
        direction = SOUND_DIRECTION_CENTER;
    }
    // allows using alternative building sounds that already exist in the game; index 3 means 4 sounds in the same group
    int sound_variety_index = 0;
    switch (channel) {
        case SOUND_CHANNEL_CITY_HOUSE_POOR:
        case SOUND_CHANNEL_CITY_HOUSE_MEDIUM:
        case SOUND_CHANNEL_CITY_HOUSE_GOOD:
        case SOUND_CHANNEL_CITY_HOUSE_POSH:
        case SOUND_CHANNEL_CITY_GARDEN:
        case SOUND_CHANNEL_CITY_FORT:
        case SOUND_CHANNEL_CITY_TOWER:
        case SOUND_CHANNEL_CITY_MARKET:
            sound_variety_index = 3;
            break;
        case SOUND_CHANNEL_CITY_GRANARY:
        case SOUND_CHANNEL_CITY_WAREHOUSE:
        case SOUND_CHANNEL_CITY_SHIPYARD:
        case SOUND_CHANNEL_CITY_DOCK:
        case SOUND_CHANNEL_CITY_WHARF:
            sound_variety_index = 2;
            break;
        case SOUND_CHANNEL_CITY_VACANT_LOT:
        case SOUND_CHANNEL_CITY_HOUSE_SLUM:
            sound_variety_index = 1;
        default:
            break;
    }
    if (settings_values[SETTINGS_CITY_SOUNDS_ENABLED] && !(data_channels.channels[channel].chunk && Mix_Playing(channel))) {
        int left_pan;
        int right_pan;
        switch (direction) {
            case SOUND_DIRECTION_CENTER:
                left_pan = right_pan = 100;
                break;
            case SOUND_DIRECTION_LEFT:
                left_pan = 100;
                right_pan = 0;
                break;
            case SOUND_DIRECTION_RIGHT:
                left_pan = 0;
                right_pan = 100;
                break;
            default:
                left_pan = right_pan = 0;
                break;
        }
        if (data_channels.initialized) {
            int random_factor = 0;
            if (sound_variety_index) {
                random_factor = rand() % sound_variety_index;
                channel = channel + random_factor;
            }
            struct sound_channel_t *ch = &data_channels.channels[channel];
            if (load_channel(ch)) {
                Mix_SetPanning(channel, left_pan * 255 / 100, right_pan * 255 / 100);
                set_channel_volume(channel, settings_values[SETTINGS_CITY_SOUNDS_VOLUME]);
                Mix_PlayChannel(channel, ch->chunk, 0);
            }
        }
    }
    last_update_time = now;
    channels[max_sound_id].last_played_time = now;
    channels[max_sound_id].total_views = 0;
    for (int d = 0; d < 5; d++) {
        channels[max_sound_id].direction_views[d] = 0;
    }
    channels[max_sound_id].times_played++;
}

static int32_t calc_bound(int32_t value, int32_t min, int32_t max)
{
    if (value < min) {
        return min;
    } else if (value > max) {
        return max;
    } else {
        return value;
    }
}

static void add_to_terrain(int x, int y, int size, int desirability, int step, int step_size, int range)
{
    if (size > 0) {
        if (range > 6) {
            range = 6;
        }
        int tiles_within_step = 0;
        for (int distance = 1; distance <= range; distance++) {
            int partially_outside_map = 0;
            if (x - distance < -1 || x + distance + size - 1 > map_data.width) {
                partially_outside_map = 1;
            }
            if (y - distance < -1 || y + distance + size - 1 > map_data.height) {
                partially_outside_map = 1;
            }
            int base_offset = map_grid_offset(x, y);

            if (partially_outside_map) {
                for (int i = desirability_data.index[size][distance]; i < desirability_data.index[size][distance] + 4 * (size - 1) + 8 * distance; i++) {
                    struct ring_tile_t *tile = &desirability_data.tiles[i];
                    if (x + tile->x >= -1 && x <= map_data.width && y + tile->y >= -1 && y <= map_data.height) {
                        desirability_grid.items[base_offset + tile->grid_offset] += desirability;
                        // BUG: bounding on wrong tile:
                        desirability_grid.items[base_offset] = calc_bound(desirability_grid.items[base_offset], -100, 100);
                    }
                }
            } else {
                for (int i = desirability_data.index[size][distance]; i < desirability_data.index[size][distance] + 4 * (size - 1) + 8 * distance; i++) {
                    struct ring_tile_t *tile = &desirability_data.tiles[i];
                    desirability_grid.items[base_offset + tile->grid_offset] =
                        calc_bound(desirability_grid.items[base_offset + tile->grid_offset] + desirability, -100, 100);
                }
            }
            tiles_within_step++;
            if (tiles_within_step >= step) {
                desirability += step_size;
                tiles_within_step = 0;
            }
        }
    }
}

static void mark_native_land(int x, int y, int size, int radius)
{
    int x_min, y_min, x_max, y_max;
    map_grid_get_area(x, y, size, radius, &x_min, &y_min, &x_max, &y_max);
    for (int yy = y_min; yy <= y_max; yy++) {
        for (int xx = x_min; xx <= x_max; xx++) {
            edge_grid.items[map_grid_offset(xx, yy)] |= EDGE_NATIVE_LAND;
        }
    }
}

static void clear_buildings(void)
{
    undo_data.num_buildings = 0;
    memset(undo_data.buildings, 0, MAX_UNDO_BUILDINGS * sizeof(struct building_t));
}

static void decay(unsigned char *value)
{
    if (*value > 0) {
        *value = *value - 1;
    } else {
        *value = 0;
    }
}

static int check_evolve_desirability(struct building_t *house)
{
    int level = house->subtype.house_level;
    int evolve_des = house_properties[level].evolve_desirability;
    if (level >= HOUSE_LUXURY_PALACE) {
        evolve_des = 1000;
    }
    int current_des = house->desirability;
    int status;
    if (current_des <= house_properties[level].devolve_desirability) {
        status = DEVOLVE;
    } else if (current_des >= evolve_des) {
        status = EVOLVE;
    } else {
        status = NONE;
    }
    house->data.house.evolve_text_id = status; // BUG? -1 in an unsigned char?
    return status;
}

static int has_required_goods_and_services(struct building_t *house, int for_upgrade, struct house_demands_t *demands)
{
    int level = house->subtype.house_level;
    if (for_upgrade) {
        ++level;
    }
    // water
    if (!house->has_water_access) {
        if (house_properties[level].water >= 2) {
            ++demands->missing.fountain;
            return 0;
        }
        if (house_properties[level].water == 1 && !house->has_well_access) {
            ++demands->missing.well;
            return 0;
        }
    }
    // entertainment
    if (house->data.house.entertainment < house_properties[level].entertainment) {
        if (house->data.house.entertainment) {
            ++demands->missing.more_entertainment;
        } else {
            ++demands->missing.entertainment;
        }
        return 0;
    }
    // education
    if (house->data.house.education < house_properties[level].education) {
        if (house->data.house.education) {
            ++demands->missing.more_education;
        } else {
            ++demands->missing.education;
        }
        return 0;
    }
    if (house_properties[level].education == 2) {
        ++demands->requiring.school;
        ++demands->requiring.library;
    } else if (house_properties[level].education == 1) {
        ++demands->requiring.school;
    }
    // religion
    if (house->data.house.num_gods < house_properties[level].religion) {
        if (house_properties[level].religion == 1) {
            ++demands->missing.religion;
            return 0;
        } else if (house_properties[level].religion == 2) {
            ++demands->missing.second_religion;
            return 0;
        } else if (house_properties[level].religion == 3) {
            ++demands->missing.third_religion;
            return 0;
        }
    } else if (house_properties[level].religion > 0) {
        ++demands->requiring.religion;
    }
    // barber
    if (house->data.house.barber < house_properties[level].barber) {
        ++demands->missing.barber;
        return 0;
    }
    if (house_properties[level].barber == 1) {
        ++demands->requiring.barber;
    }
    // bathhouse
    if (house->data.house.bathhouse < house_properties[level].bathhouse) {
        ++demands->missing.bathhouse;
        return 0;
    }
    if (house_properties[level].bathhouse == 1) {
        ++demands->requiring.bathhouse;
    }
    // health
    if (house->data.house.health < house_properties[level].health) {
        if (house_properties[level].health < 2) {
            ++demands->missing.clinic;
        } else {
            ++demands->missing.hospital;
        }
        return 0;
    }
    if (house_properties[level].health >= 1) {
        ++demands->requiring.clinic;
    }
    // food types
    int foodtypes_available = 0;
    for (int i = INVENTORY_WHEAT; i <= INVENTORY_MEAT; i++) {
        if (house->data.house.inventory[i]) {
            foodtypes_available++;
        }
    }
    if (foodtypes_available < house_properties[level].food_types) {
        ++demands->missing.food;
        return 0;
    }
    // goods
    if (house->data.house.inventory[INVENTORY_POTTERY] < house_properties[level].pottery) {
        return 0;
    }
    if (house->data.house.inventory[INVENTORY_OIL] < house_properties[level].oil) {
        return 0;
    }
    if (house->data.house.inventory[INVENTORY_FURNITURE] < house_properties[level].furniture) {
        return 0;
    }
    int wine_required = house_properties[level].wine;
    if (wine_required && !house->data.house.inventory[INVENTORY_WINE]) {
        return 0;
    }
    if (wine_required > 1 && city_data.resource.wine_types_available <= 1) {
        ++demands->missing.second_wine;
        return 0;
    }
    return 1;
}

static int check_requirements(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_evolve_desirability(house);
    if (!has_required_goods_and_services(house, 0, demands)) {
        status = DEVOLVE;
    } else if (status == EVOLVE) {
        status = has_required_goods_and_services(house, 1, demands);
    }
    return status;
}

static void prepare_for_merge(int building_id, int num_tiles)
{
    for (int i = 0; i < INVENTORY_MAX; i++) {
        merge_data.inventory[i] = 0;
    }
    merge_data.population = 0;
    int grid_offset = map_grid_offset(merge_data.x, merge_data.y);
    for (int i = 0; i < num_tiles; i++) {
        int house_offset = grid_offset + HOUSE_TILE_OFFSETS[i];
        if (map_terrain_is(house_offset, TERRAIN_BUILDING)) {
            struct building_t *house = &all_buildings[map_building_at(house_offset)];
            if (house->id != building_id && house->house_size) {
                merge_data.population += house->house_population;
                for (int inv = 0; inv < INVENTORY_MAX; inv++) {
                    merge_data.inventory[inv] += house->data.house.inventory[inv];
                    house->house_population = 0;
                    house->state = BUILDING_STATE_DELETED_BY_GAME;
                }
            }
        }
    }
}

static int map_grid_offset_to_x(int grid_offset)
{
    return (grid_offset - map_data.start_offset) % GRID_SIZE;
}

static int map_grid_offset_to_y(int grid_offset)
{
    return (grid_offset - map_data.start_offset) / GRID_SIZE;
}

static int building_is_farm(int type)
{
    return type >= BUILDING_WHEAT_FARM && type <= BUILDING_VINES_FARM;
}

static void foreach_region_tile(int x_min, int y_min, int x_max, int y_max, void (*callback)(int x, int y, int grid_offset))
{
    map_grid_bound_area(&x_min, &y_min, &x_max, &y_max);
    int grid_offset = map_grid_offset(x_min, y_min);
    for (int yy = y_min; yy <= y_max; yy++) {
        for (int xx = x_min; xx <= x_max; xx++) {
            callback(xx, yy, grid_offset);
            ++grid_offset;
        }
        grid_offset += GRID_SIZE - (x_max - x_min + 1);
    }
}

static void fill_matches(int grid_offset, int terrain, int match_value, int no_match_value, int tiles[MAX_TILES_TERRAIN])
{
    for (int i = 0; i < MAX_TILES_TERRAIN; i++) {
        tiles[i] = map_terrain_is(grid_offset + map_grid_direction_delta(i), terrain) ? match_value : no_match_value;
    }
}

static void set_water_image(int x, int y, int grid_offset)
{
    if ((terrain_grid.items[grid_offset] & (TERRAIN_WATER | TERRAIN_BUILDING)) == TERRAIN_WATER) {
        int tiles[MAX_TILES_TERRAIN];
        fill_matches(grid_offset, TERRAIN_WATER, 0, 1, tiles);
        struct terrain_image_t *img = get_image(CONTEXT_WATER, tiles);
        int image_id = image_data_s.group_image_ids[GROUP_TERRAIN_WATER] + img->group_offset + img->item_offset;
        if (map_terrain_exists_tile_in_radius_with_type(x, y, 1, 2, TERRAIN_BUILDING)) {
            // fortified shore
            int base = image_data_s.group_image_ids[GROUP_TERRAIN_WATER_SHORE];
            switch (img->group_offset) {
                case 8: image_id = base + 10; break;
                case 12: image_id = base + 11; break;
                case 16: image_id = base + 9; break;
                case 20: image_id = base + 8; break;
                case 24: image_id = base + 18; break;
                case 28: image_id = base + 16; break;
                case 32: image_id = base + 19; break;
                case 36: image_id = base + 17; break;
                case 50: image_id = base + 12; break;
                case 51: image_id = base + 14; break;
                case 52: image_id = base + 13; break;
                case 53: image_id = base + 15; break;
            }
        }
        images.items[grid_offset] = image_id;
    }
}

static void map_tiles_set_water(int x, int y)
{
    terrain_grid.items[map_grid_offset(x, y)] |= TERRAIN_WATER;
    foreach_region_tile(x - 1, y - 1, x + 1, y + 1, set_water_image);
}

static void map_property_set_multi_tile_size(int grid_offset, int size)
{
    bitfields_grid.items[grid_offset] &= BIT_NO_SIZES;
    switch (size) {
        case 2: bitfields_grid.items[grid_offset] |= BIT_SIZE2; break;
        case 3: bitfields_grid.items[grid_offset] |= BIT_SIZE3; break;
        case 4: bitfields_grid.items[grid_offset] |= BIT_SIZE4; break;
        case 5: bitfields_grid.items[grid_offset] |= BIT_SIZE5; break;
    }
}

static void clear_empty_land_image(__attribute__((unused)) int x, __attribute__((unused)) int y, int grid_offset)
{
    if (!map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR | TERRAIN_MEADOW)) {
        images.items[grid_offset] = 0;
        map_property_set_multi_tile_size(grid_offset, 1);
        edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
    }
}

static void set_empty_land_image(int x, int y, int size, int image_id)
{
    if (!map_grid_is_inside(x, y, size)) {
        return;
    }
    int index = 0;
    for (int dy = 0; dy < size; dy++) {
        for (int dx = 0; dx < size; dx++) {
            int grid_offset = map_grid_offset(x + dx, y + dy);
            terrain_grid.items[grid_offset] &= ~TERRAIN_CLEARABLE;
            buildings_grid.items[grid_offset] = 0;
            bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
            map_property_set_multi_tile_size(grid_offset, 1);
            edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
            images.items[grid_offset] = image_id + index;
            index++;
        }
    }
}

static int is_clear(int x, int y, int size, int disallowed_terrain, int check_image)
{
    if (!map_grid_is_inside(x, y, size)) {
        return 0;
    }
    for (int dy = 0; dy < size; dy++) {
        for (int dx = 0; dx < size; dx++) {
            int grid_offset = map_grid_offset(x + dx, y + dy);
            if (map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR & disallowed_terrain)) {
                return 0;
            } else if (map_grid_is_valid_offset(grid_offset) && map_figures.items[grid_offset] > 0) {
                return 0;
            } else if (check_image && images.items[grid_offset]) {
                return 0;
            }
        }
    }
    return 1;
}

static void set_empty_land_pass1(int x, int y, int grid_offset)
{
    if (!map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR) && !images.items[grid_offset] &&
        !(random.items[grid_offset] & 0xf0)) {
        int image_id;
        if (bitfields_grid.items[grid_offset] & BIT_ALTERNATE_TERRAIN) {
            image_id = image_data_s.group_image_ids[GROUP_TERRAIN_GRASS_2];
        } else {
            image_id = image_data_s.group_image_ids[GROUP_TERRAIN_GRASS_1];
        }
        set_empty_land_image(x, y, 1, image_id + (random.items[grid_offset] & 7));
    }
}

static void set_empty_land_pass2(int x, int y, int grid_offset)
{
    if (!map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR) && !images.items[grid_offset]) {
        int image_id;
        if (bitfields_grid.items[grid_offset] & BIT_ALTERNATE_TERRAIN) {
            image_id = image_data_s.group_image_ids[GROUP_TERRAIN_GRASS_2];
        } else {
            image_id = image_data_s.group_image_ids[GROUP_TERRAIN_GRASS_1];
        }
        if (is_clear(x, y, 4, TERRAIN_ALL, 1)) {
            set_empty_land_image(x, y, 4, image_id + 42);
        } else if (is_clear(x, y, 3, TERRAIN_ALL, 1)) {
            set_empty_land_image(x, y, 3, image_id + 24 + 9 * (random.items[grid_offset] & 1));
        } else if (is_clear(x, y, 2, TERRAIN_ALL, 1)) {
            set_empty_land_image(x, y, 2, image_id + 8 + 4 * (random.items[grid_offset] & 3));
        } else {
            set_empty_land_image(x, y, 1, image_id + (random.items[grid_offset] & 7));
        }
    }
}

static void map_tiles_update_region_empty_land(int x_min, int y_min, int x_max, int y_max)
{
    foreach_region_tile(x_min, y_min, x_max, y_max, clear_empty_land_image);
    foreach_region_tile(x_min, y_min, x_max, y_max, set_empty_land_pass1);
    foreach_region_tile(x_min, y_min, x_max, y_max, set_empty_land_pass2);
}

static void set_meadow_image(int x, int y, int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_MEADOW) && !map_terrain_is(grid_offset, FORBIDDEN_TERRAIN_MEADOW)) {
        int image_id = image_data_s.group_image_ids[GROUP_TERRAIN_MEADOW];
        if (map_terrain_all_tiles_in_radius_are(x, y, 1, 2, TERRAIN_MEADOW)) {
            images.items[grid_offset] = image_id + (random.items[grid_offset] & 3) + 8;
        } else if (map_terrain_all_tiles_in_radius_are(x, y, 1, 1, TERRAIN_MEADOW)) {
            images.items[grid_offset] = image_id + (random.items[grid_offset] & 3) + 4;
        } else {
            images.items[grid_offset] = image_id + (random.items[grid_offset] & 3);
        }
        map_property_set_multi_tile_size(grid_offset, 1);
        edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
        aqueduct.items[grid_offset] = 0;
    }
}

static void update_meadow_tile(int x, int y, int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_MEADOW) && !map_terrain_is(grid_offset, FORBIDDEN_TERRAIN_MEADOW)) {
        foreach_region_tile(x - 1, y - 1, x + 1, y + 1, set_meadow_image);
    }
}

static void set_rubble_image(__attribute__((unused)) int x, __attribute__((unused)) int y, int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_RUBBLE) && !map_terrain_is(grid_offset, FORBIDDEN_TERRAIN_RUBBLE)) {
        images.items[grid_offset] = image_data_s.group_image_ids[GROUP_TERRAIN_RUBBLE] + (random.items[grid_offset] & 7);
        map_property_set_multi_tile_size(grid_offset, 1);
        edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
        aqueduct.items[grid_offset] = 0;
    }
}

static void map_building_tiles_remove(int building_id, int x, int y)
{
    if (!map_grid_is_inside(x, y, 1)) {
        return;
    }
    int size;
    int base_grid_offset = map_grid_offset(x, y);
    size = map_property_multi_tile_size(base_grid_offset);
    for (int i = 0; i < size && edge_grid.items[base_grid_offset] & EDGE_MASK_X; i++) {
        base_grid_offset += map_grid_delta(-1, 0);
    }
    for (int i = 0; i < size && edge_grid.items[base_grid_offset] & EDGE_MASK_Y; i++) {
        base_grid_offset += map_grid_delta(0, -1);
    }
    x = map_grid_offset_to_x(base_grid_offset);
    y = map_grid_offset_to_y(base_grid_offset);
    if (terrain_grid.items[base_grid_offset] == TERRAIN_ROCK) {
        return;
    }
    struct building_t *b = &all_buildings[building_id];
    if (building_id && building_is_farm(b->type)) {
        size = 3;
    }
    for (int dy = 0; dy < size; dy++) {
        for (int dx = 0; dx < size; dx++) {
            int grid_offset = map_grid_offset(x + dx, y + dy);
            if (building_id && map_building_at(grid_offset) != building_id) {
                continue;
            }
            if (building_id && b->type != BUILDING_BURNING_RUIN) {
                rubble_type_grid.items[grid_offset] = b->type;
            }
            bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
            map_property_set_multi_tile_size(grid_offset, 1);
            // only keep native land marker
            edge_grid.items[grid_offset] &= EDGE_NATIVE_LAND;
            edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
            aqueduct.items[grid_offset] = 0;
            buildings_grid.items[grid_offset] = 0;
            damage_grid.items[grid_offset] = 0;
            map_sprite_clear_tile(grid_offset);
            if (map_terrain_is(grid_offset, TERRAIN_WATER)) {
                terrain_grid.items[grid_offset] = TERRAIN_WATER; // clear other flags
                map_tiles_set_water(x + dx, y + dy);
            } else {
                images.items[grid_offset] = image_data_s.group_image_ids[GROUP_TERRAIN_UGLY_GRASS] + (random.items[grid_offset] & 7);
                terrain_grid.items[grid_offset] &= ~TERRAIN_CLEARABLE;
            }
        }
    }
    map_tiles_update_region_empty_land(x, y, x + size, y + size);
    foreach_region_tile(x, y, x + size, y + size, update_meadow_tile);
    foreach_region_tile(x, y, x + size, y + size, set_rubble_image);
}

static void map_property_set_multi_tile_xy(int grid_offset, int x, int y, int is_draw_tile)
{
    if (is_draw_tile) {
        edge_grid.items[grid_offset] = (8 * y + x) | EDGE_LEFTMOST_TILE;
    } else {
        edge_grid.items[grid_offset] = 8 * y + x;
    }
}

static void map_building_tiles_add(int building_id, int x, int y, int size, int image_id, int terrain)
{
    if (!map_grid_is_inside(x, y, size)) {
        return;
    }
    int x_leftmost, y_leftmost;
    switch (view_data.orientation) {
        case DIR_0_TOP:
            x_leftmost = 0;
            y_leftmost = size - 1;
            break;
        case DIR_2_RIGHT:
            x_leftmost = y_leftmost = 0;
            break;
        case DIR_4_BOTTOM:
            x_leftmost = size - 1;
            y_leftmost = 0;
            break;
        case DIR_6_LEFT:
            x_leftmost = y_leftmost = size - 1;
            break;
        default:
            return;
    }
    for (int dy = 0; dy < size; dy++) {
        for (int dx = 0; dx < size; dx++) {
            int grid_offset = map_grid_offset(x + dx, y + dy);
            terrain_grid.items[grid_offset] &= ~TERRAIN_CLEARABLE;
            terrain_grid.items[grid_offset] |= terrain;
            buildings_grid.items[grid_offset] = building_id;
            bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
            map_property_set_multi_tile_size(grid_offset, size);
            images.items[grid_offset] = image_id;
            map_property_set_multi_tile_xy(grid_offset, dx, dy, dx == x_leftmost && dy == y_leftmost);
        }
    }
}

static void building_house_merge(struct building_t *house)
{
    if (house->house_is_merged) {
        return;
    }
    if ((random.items[house->grid_offset] & 7) >= 5) {
        return;
    }
    int num_house_tiles = 0;
    for (int i = 0; i < 4; i++) {
        int tile_offset = house->grid_offset + HOUSE_TILE_OFFSETS[i];
        if (map_terrain_is(tile_offset, TERRAIN_BUILDING)) {
            struct building_t *other_house = &all_buildings[map_building_at(tile_offset)];
            if (other_house->id == house->id) {
                num_house_tiles++;
            } else if (other_house->state == BUILDING_STATE_IN_USE && other_house->house_size &&
                    other_house->subtype.house_level == house->subtype.house_level &&
                    !other_house->house_is_merged) {
                num_house_tiles++;
            }
        }
    }
    if (num_house_tiles == 4) {
        undo_data.available = 0;
        merge_data.x = house->x + EXPAND_DIRECTION_DELTA[0].x;
        merge_data.y = house->y + EXPAND_DIRECTION_DELTA[0].y;
        prepare_for_merge(house->id, 4);
        house->size = house->house_size = 2;
        house->house_population += merge_data.population;
        for (int i = 0; i < INVENTORY_MAX; i++) {
            house->data.house.inventory[i] += merge_data.inventory[i];
        }
        int image_id = image_data_s.group_image_ids[HOUSE_IMAGE[house->subtype.house_level].group] + 4;
        if (HOUSE_IMAGE[house->subtype.house_level].offset) {
            image_id += 1;
        }
        map_building_tiles_remove(house->id, house->x, house->y);
        house->x = merge_data.x;
        house->y = merge_data.y;
        house->grid_offset = map_grid_offset(house->x, house->y);
        house->house_is_merged = 1;
        map_building_tiles_add(house->id, house->x, house->y, 2, image_id, TERRAIN_BUILDING);
    }
}

static void building_house_change_to(struct building_t *house, int type)
{
    house->type = type;
    house->subtype.house_level = house->type - BUILDING_HOUSE_SMALL_TENT;
    int image_id = image_data_s.group_image_ids[HOUSE_IMAGE[house->subtype.house_level].group];
    if (house->house_is_merged) {
        image_id += 4;
        if (HOUSE_IMAGE[house->subtype.house_level].offset) {
            image_id += 1;
        }
    } else {
        image_id += HOUSE_IMAGE[house->subtype.house_level].offset;
        image_id += random.items[house->grid_offset] & (HOUSE_IMAGE[house->subtype.house_level].num_types - 1);
    }
    map_building_tiles_add(house->id, house->x, house->y, house->size, image_id, TERRAIN_BUILDING);
}

static int evolve_small_tent(struct building_t *house, struct house_demands_t *demands)
{
    if (house->house_population > 0) {
        building_house_merge(house);
        int status = check_requirements(house, demands);
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LARGE_TENT);
        }
    }
    return 0;
}

static int has_devolve_delay(struct building_t *house, int status)
{
    if (status == DEVOLVE && house->data.house.devolve_delay < 2) {
        house->data.house.devolve_delay++;
        return 1;
    } else {
        house->data.house.devolve_delay = 0;
        return 0;
    }
}

static int evolve_large_tent(struct building_t *house, struct house_demands_t *demands)
{
    if (house->house_population > 0) {
        building_house_merge(house);
        int status = check_requirements(house, demands);
        if (!has_devolve_delay(house, status)) {
            if (status == EVOLVE) {
                building_house_change_to(house, BUILDING_HOUSE_SMALL_SHACK);
            } else if (status == DEVOLVE) {
                building_house_change_to(house, BUILDING_HOUSE_SMALL_TENT);
            }
        }
    }
    return 0;
}

static int evolve_small_shack(struct building_t *house, struct house_demands_t *demands)
{
    building_house_merge(house);
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LARGE_SHACK);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LARGE_TENT);
        }
    }
    return 0;
}

static int evolve_large_shack(struct building_t *house, struct house_demands_t *demands)
{
    building_house_merge(house);
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_HOVEL);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_SHACK);
        }
    }
    return 0;
}

static int evolve_small_hovel(struct building_t *house, struct house_demands_t *demands)
{
    building_house_merge(house);
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LARGE_HOVEL);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LARGE_SHACK);
        }
    }
    return 0;
}

static int evolve_large_hovel(struct building_t *house, struct house_demands_t *demands)
{
    building_house_merge(house);
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_CASA);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_HOVEL);
        }
    }
    return 0;
}

static int evolve_small_casa(struct building_t *house, struct house_demands_t *demands)
{
    building_house_merge(house);
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LARGE_CASA);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LARGE_HOVEL);
        }
    }
    return 0;
}

static int evolve_large_casa(struct building_t *house, struct house_demands_t *demands)
{
    building_house_merge(house);
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_INSULA);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_CASA);
        }
    }
    return 0;
}

static int evolve_small_insula(struct building_t *house, struct house_demands_t *demands)
{
    building_house_merge(house);
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_MEDIUM_INSULA);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LARGE_CASA);
        }
    }
    return 0;
}

static int house_image_group(int level)
{
    return image_data_s.group_image_ids[HOUSE_IMAGE[level].group] + HOUSE_IMAGE[level].offset;
}

static   char *lang_get_string(int group, int index)
{
    char *str = &lang_data.text_data[lang_data.text_entries[group].offset];
    char prev = 0;
    while (index > 0) {
        if (!*str && (prev >= ' ' || prev == 0)) {
            --index;
        }
        prev = *str;
        ++str;
    }
    while (*str < ' ') { // skip non-printables
        ++str;
    }
    return str;
}

static void city_warning_show(int type)
{
    char *text;
    if (type == WARNING_ORIENTATION) {
        text = lang_get_string(17, view_data.orientation);
    } else {
        text = lang_get_string(19, type - 2);
    }
    city_warning_show_custom(text);
}

static struct building_t *building_create(int type, int x, int y)
{
    struct building_t *b = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        int undo_contains_building = 0;
        if (undo_data.ready && undo_data.available) {
            if (undo_data.num_buildings) {
                for (int j = 0; j < MAX_UNDO_BUILDINGS; j++) {
                    if (undo_data.buildings[j].id == i) {
                        undo_contains_building = 1;
                        break;
                    }
                }
            }
        }
        if (all_buildings[i].state == BUILDING_STATE_UNUSED && !undo_contains_building) {
            b = &all_buildings[i];
            break;
        }
    }
    if (!b) {
        city_warning_show(WARNING_DATA_LIMIT_REACHED);
        return &all_buildings[0];
    }
    memset(&(b->data), 0, sizeof(b->data));
    b->state = BUILDING_STATE_CREATED;
    b->type = type;
    b->size = building_properties[type].size;
    b->created_sequence = extra.created_sequence++;
    b->sentiment.house_happiness = 50;
    // house size
    b->house_size = 0;
    if (type >= BUILDING_HOUSE_VACANT_LOT && type <= BUILDING_HOUSE_MEDIUM_INSULA) {
        b->house_size = 1;
    } else if (type >= BUILDING_HOUSE_LARGE_INSULA && type <= BUILDING_HOUSE_MEDIUM_VILLA) {
        b->house_size = 2;
    } else if (type >= BUILDING_HOUSE_LARGE_VILLA && type <= BUILDING_HOUSE_MEDIUM_PALACE) {
        b->house_size = 3;
    } else if (type >= BUILDING_HOUSE_LARGE_PALACE && type <= BUILDING_HOUSE_LUXURY_PALACE) {
        b->house_size = 4;
    }
    // subtype
    if (building_is_house(type) && type != BUILDING_HOUSE_VACANT_LOT) {
        b->subtype.house_level = type - BUILDING_HOUSE_SMALL_TENT;
    } else {
        b->subtype.house_level = 0;
    }
    // input/output resources
    switch (type) {
        case BUILDING_WHEAT_FARM:
            b->output_resource_id = RESOURCE_WHEAT;
            break;
        case BUILDING_VEGETABLE_FARM:
            b->output_resource_id = RESOURCE_VEGETABLES;
            break;
        case BUILDING_FRUIT_FARM:
            b->output_resource_id = RESOURCE_FRUIT;
            break;
        case BUILDING_OLIVE_FARM:
            b->output_resource_id = RESOURCE_OLIVES;
            break;
        case BUILDING_VINES_FARM:
            b->output_resource_id = RESOURCE_VINES;
            break;
        case BUILDING_PIG_FARM:
            b->output_resource_id = RESOURCE_MEAT;
            break;
        case BUILDING_MARBLE_QUARRY:
            b->output_resource_id = RESOURCE_MARBLE;
            break;
        case BUILDING_IRON_MINE:
            b->output_resource_id = RESOURCE_IRON;
            break;
        case BUILDING_TIMBER_YARD:
            b->output_resource_id = RESOURCE_TIMBER;
            break;
        case BUILDING_CLAY_PIT:
            b->output_resource_id = RESOURCE_CLAY;
            break;
        case BUILDING_WINE_WORKSHOP:
            b->output_resource_id = RESOURCE_WINE;
            b->subtype.workshop_type = WORKSHOP_VINES_TO_WINE;
            break;
        case BUILDING_OIL_WORKSHOP:
            b->output_resource_id = RESOURCE_OIL;
            b->subtype.workshop_type = WORKSHOP_OLIVES_TO_OIL;
            break;
        case BUILDING_WEAPONS_WORKSHOP:
            b->output_resource_id = RESOURCE_WEAPONS;
            b->subtype.workshop_type = WORKSHOP_IRON_TO_WEAPONS;
            break;
        case BUILDING_FURNITURE_WORKSHOP:
            b->output_resource_id = RESOURCE_FURNITURE;
            b->subtype.workshop_type = WORKSHOP_TIMBER_TO_FURNITURE;
            break;
        case BUILDING_POTTERY_WORKSHOP:
            b->output_resource_id = RESOURCE_POTTERY;
            b->subtype.workshop_type = WORKSHOP_CLAY_TO_POTTERY;
            break;
        default:
            b->output_resource_id = RESOURCE_NONE;
            break;
    }
    if (type == BUILDING_GRANARY) {
        b->data.granary.resource_stored[RESOURCE_NONE] = 2400;
    }
    b->x = x;
    b->y = y;
    b->grid_offset = map_grid_offset(x, y);
    b->house_figure_generation_delay = random.items[b->grid_offset] & 0x7f;
    b->figure_roam_direction = b->house_figure_generation_delay & 6;
    b->fire_proof = building_properties[type].fire_proof;
    return b;
}

static void create_house_tile(int type, int x, int y, int image_id, int population, int *inventory)
{
    struct building_t *house = building_create(type, x, y);
    house->house_population = population;
    for (int i = 0; i < INVENTORY_MAX; i++) {
        house->data.house.inventory[i] = inventory[i];
    }
    map_building_tiles_add(house->id, house->x, house->y, 1, image_id + (random.items[house->grid_offset] & 1), TERRAIN_BUILDING);
}

static void split_size2(struct building_t *house, int new_type)
{
    int inventory_per_tile[INVENTORY_MAX];
    int inventory_remainder[INVENTORY_MAX];
    for (int i = 0; i < INVENTORY_MAX; i++) {
        inventory_per_tile[i] = house->data.house.inventory[i] / 4;
        inventory_remainder[i] = house->data.house.inventory[i] % 4;
    }
    int population_per_tile = house->house_population / 4;
    int population_remainder = house->house_population % 4;

    map_building_tiles_remove(house->id, house->x, house->y);

    // main tile
    house->type = new_type;
    house->subtype.house_level = house->type - BUILDING_HOUSE_SMALL_TENT;
    house->size = house->house_size = 1;
    house->house_is_merged = 0;
    house->house_population = population_per_tile + population_remainder;
    for (int i = 0; i < INVENTORY_MAX; i++) {
        house->data.house.inventory[i] = inventory_per_tile[i] + inventory_remainder[i];
    }

    int image_id = house_image_group(house->subtype.house_level);
    map_building_tiles_add(house->id, house->x, house->y, house->size,
                           image_id + (random.items[house->grid_offset] & 1), TERRAIN_BUILDING);

    // the other tiles (new buildings)
    create_house_tile(house->type, house->x + 1, house->y, image_id, population_per_tile, inventory_per_tile);
    create_house_tile(house->type, house->x, house->y + 1, image_id, population_per_tile, inventory_per_tile);
    create_house_tile(house->type, house->x + 1, house->y + 1, image_id, population_per_tile, inventory_per_tile);
}

static void split(struct building_t *house, int num_tiles)
{
    int grid_offset = map_grid_offset(merge_data.x, merge_data.y);
    for (int i = 0; i < num_tiles; i++) {
        int tile_offset = grid_offset + HOUSE_TILE_OFFSETS[i];
        if (map_terrain_is(tile_offset, TERRAIN_BUILDING)) {
            struct building_t *other_house = &all_buildings[map_building_at(tile_offset)];
            if (other_house->id != house->id && other_house->house_size) {
                if (other_house->house_is_merged == 1) {
                    split_size2(other_house, other_house->type);
                } else if (other_house->house_size == 2) {
                    split_size2(other_house, BUILDING_HOUSE_MEDIUM_INSULA);
                } else if (other_house->house_size == 3) {
                    int inventory_per_tile[INVENTORY_MAX];
                    int inventory_remainder[INVENTORY_MAX];
                    for (int ii = 0; ii < INVENTORY_MAX; ii++) {
                        inventory_per_tile[ii] = other_house->data.house.inventory[ii] / 9;
                        inventory_remainder[ii] = other_house->data.house.inventory[ii] % 9;
                    }
                    int population_per_tile = other_house->house_population / 9;
                    int population_remainder = other_house->house_population % 9;
                    map_building_tiles_remove(other_house->id, other_house->x, other_house->y);
                    // main tile
                    other_house->type = BUILDING_HOUSE_MEDIUM_INSULA;
                    other_house->subtype.house_level = other_house->type - BUILDING_HOUSE_SMALL_TENT;
                    other_house->size = other_house->house_size = 1;
                    other_house->house_is_merged = 0;
                    other_house->house_population = population_per_tile + population_remainder;
                    for (int ii = 0; ii < INVENTORY_MAX; ii++) {
                        other_house->data.house.inventory[ii] = inventory_per_tile[ii] + inventory_remainder[ii];
                    }

                    int image_id = house_image_group(other_house->subtype.house_level);
                    map_building_tiles_add(other_house->id, other_house->x, other_house->y, other_house->size,
                                           image_id + (random.items[other_house->grid_offset] & 1), TERRAIN_BUILDING);
                    // the other tiles (new buildings)
                    create_house_tile(other_house->type, other_house->x, other_house->y + 1, image_id, population_per_tile, inventory_per_tile);
                    create_house_tile(other_house->type, other_house->x + 1, other_house->y + 1, image_id, population_per_tile, inventory_per_tile);
                    create_house_tile(other_house->type, other_house->x + 2, other_house->y + 1, image_id, population_per_tile, inventory_per_tile);
                    create_house_tile(other_house->type, other_house->x, other_house->y + 2, image_id, population_per_tile, inventory_per_tile);
                    create_house_tile(other_house->type, other_house->x + 1, other_house->y + 2, image_id, population_per_tile, inventory_per_tile);
                    create_house_tile(other_house->type, other_house->x + 2, other_house->y + 2, image_id, population_per_tile, inventory_per_tile);
                }
            }
        }
    }
}

static int building_house_can_expand(struct building_t *house, int num_tiles)
{
    // merge with other houses
    for (int dir = 0; dir < MAX_DIR; dir++) {
        int base_offset = EXPAND_DIRECTION_DELTA[dir].offset + house->grid_offset;
        int ok_tiles = 0;
        for (int i = 0; i < num_tiles; i++) {
            int tile_offset = base_offset + HOUSE_TILE_OFFSETS[i];
            if (map_terrain_is(tile_offset, TERRAIN_BUILDING)) {
                struct building_t *other_house = &all_buildings[map_building_at(tile_offset)];
                if (other_house->id == house->id) {
                    ok_tiles++;
                } else if (other_house->state == BUILDING_STATE_IN_USE && other_house->house_size) {
                    if (other_house->subtype.house_level <= house->subtype.house_level) {
                        ok_tiles++;
                    }
                }
            }
        }
        if (ok_tiles == num_tiles) {
            merge_data.x = house->x + EXPAND_DIRECTION_DELTA[dir].x;
            merge_data.y = house->y + EXPAND_DIRECTION_DELTA[dir].y;
            return 1;
        }
    }
    // merge with houses and empty terrain
    for (int dir = 0; dir < MAX_DIR; dir++) {
        int base_offset = EXPAND_DIRECTION_DELTA[dir].offset + house->grid_offset;
        int ok_tiles = 0;
        for (int i = 0; i < num_tiles; i++) {
            int tile_offset = base_offset + HOUSE_TILE_OFFSETS[i];
            if (!map_terrain_is(tile_offset, TERRAIN_NOT_CLEAR)) {
                ok_tiles++;
            } else if (map_terrain_is(tile_offset, TERRAIN_BUILDING)) {
                struct building_t *other_house = &all_buildings[map_building_at(tile_offset)];
                if (other_house->id == house->id) {
                    ok_tiles++;
                } else if (other_house->state == BUILDING_STATE_IN_USE && other_house->house_size) {
                    if (other_house->subtype.house_level <= house->subtype.house_level) {
                        ok_tiles++;
                    }
                }
            }
        }
        if (ok_tiles == num_tiles) {
            merge_data.x = house->x + EXPAND_DIRECTION_DELTA[dir].x;
            merge_data.y = house->y + EXPAND_DIRECTION_DELTA[dir].y;
            return 1;
        }
    }
    // merge with houses, empty terrain and gardens
    for (int dir = 0; dir < MAX_DIR; dir++) {
        int base_offset = EXPAND_DIRECTION_DELTA[dir].offset + house->grid_offset;
        int ok_tiles = 0;
        for (int i = 0; i < num_tiles; i++) {
            int tile_offset = base_offset + HOUSE_TILE_OFFSETS[i];
            if (!map_terrain_is(tile_offset, TERRAIN_NOT_CLEAR)) {
                ok_tiles++;
            } else if (map_terrain_is(tile_offset, TERRAIN_BUILDING)) {
                struct building_t *other_house = &all_buildings[map_building_at(tile_offset)];
                if (other_house->id == house->id) {
                    ok_tiles++;
                } else if (other_house->state == BUILDING_STATE_IN_USE && other_house->house_size) {
                    if (other_house->subtype.house_level <= house->subtype.house_level) {
                        ok_tiles++;
                    }
                }
            } else if (map_terrain_is(tile_offset, TERRAIN_GARDEN)) {
                ok_tiles++;
            }
        }
        if (ok_tiles == num_tiles) {
            merge_data.x = house->x + EXPAND_DIRECTION_DELTA[dir].x;
            merge_data.y = house->y + EXPAND_DIRECTION_DELTA[dir].y;
            return 1;
        }
    }
    house->data.house.no_space_to_expand = 1;
    return 0;
}

static void map_tiles_update_all_gardens(void)
{
    // clear garden image
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (map_terrain_is(grid_offset, TERRAIN_GARDEN)
            && !map_terrain_is(grid_offset, TERRAIN_ELEVATION | TERRAIN_ACCESS_RAMP)) {
                images.items[grid_offset] = 0;
                map_property_set_multi_tile_size(grid_offset, 1);
                edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
            }
        }
    }
    // set garden image
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (map_terrain_is(grid_offset, TERRAIN_GARDEN)
                && !map_terrain_is(grid_offset, TERRAIN_ELEVATION | TERRAIN_ACCESS_RAMP)) {
                if (!images.items[grid_offset]) {
                    int image_id = image_data_s.group_image_ids[GROUP_TERRAIN_GARDEN];
                    int all_terrain_in_area_is_garden = 1;
                    if (map_grid_is_inside(x, y, 2)) {
                        for (int dy = 0; dy < 2; dy++) {
                            for (int dx = 0; dx < 2; dx++) {
                                int grid_offset2 = map_grid_offset(x + dx, y + dy);
                                if ((terrain_grid.items[grid_offset2] & TERRAIN_NOT_CLEAR) != TERRAIN_GARDEN) {
                                    all_terrain_in_area_is_garden = 0;
                                    break;
                                }
                                if (images.items[grid_offset2]) {
                                    all_terrain_in_area_is_garden = 0;
                                    break;
                                }
                            }
                        }
                    }
                    if (all_terrain_in_area_is_garden) {
                        switch (random.items[grid_offset] & 3) {
                            case 0: case 1:
                                image_id += 6;
                                break;
                            case 2:
                                image_id += 5;
                                break;
                            case 3:
                                image_id += 4;
                                break;
                        }
                        map_building_tiles_add(0, x, y, 2, image_id, TERRAIN_GARDEN);
                    } else {
                        if (y & 1) {
                            switch (x & 3) {
                                case 0: case 2:
                                    image_id += 2;
                                    break;
                                case 1: case 3:
                                    image_id += 3;
                                    break;
                            }
                        } else {
                            switch (x & 3) {
                                case 1: case 3:
                                    image_id += 1;
                                    break;
                            }
                        }
                        images.items[grid_offset] = image_id;
                    }
                }
            }
        }
    }
}

static int evolve_medium_insula(struct building_t *house, struct house_demands_t *demands)
{
    building_house_merge(house);
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            if (building_house_can_expand(house, 4)) {
                undo_data.available = 0;
                house->house_is_merged = 0;
                split(house, 4);
                prepare_for_merge(house->id, 4);

                house->type = BUILDING_HOUSE_LARGE_INSULA;
                house->subtype.house_level = HOUSE_LARGE_INSULA;
                house->size = house->house_size = 2;
                house->house_population += merge_data.population;
                for (int i = 0; i < INVENTORY_MAX; i++) {
                    house->data.house.inventory[i] += merge_data.inventory[i];
                }
                int image_id = house_image_group(house->subtype.house_level) + (random.items[house->grid_offset] & 1);
                map_building_tiles_remove(house->id, house->x, house->y);
                house->x = merge_data.x;
                house->y = merge_data.y;
                house->grid_offset = map_grid_offset(house->x, house->y);
                map_building_tiles_add(house->id, house->x, house->y, house->size, image_id, TERRAIN_BUILDING);
                map_tiles_update_all_gardens();
                return 1;
            }
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_INSULA);
        }
    }
    return 0;
}

static int evolve_large_insula(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_GRAND_INSULA);
        } else if (status == DEVOLVE) {
            undo_data.available = 0;
            split_size2(house, BUILDING_HOUSE_MEDIUM_INSULA);
        }
    }
    return 0;
}

static int evolve_grand_insula(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_VILLA);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LARGE_INSULA);
        }
    }
    return 0;
}

static int evolve_small_villa(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_MEDIUM_VILLA);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_GRAND_INSULA);
        }
    }
    return 0;
}

static int evolve_medium_villa(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            if (building_house_can_expand(house, 9)) {
                undo_data.available = 0;
                split(house, 9);
                prepare_for_merge(house->id, 9);

                house->type = BUILDING_HOUSE_LARGE_VILLA;
                house->subtype.house_level = HOUSE_LARGE_VILLA;
                house->size = house->house_size = 3;
                house->house_population += merge_data.population;
                for (int i = 0; i < INVENTORY_MAX; i++) {
                    house->data.house.inventory[i] += merge_data.inventory[i];
                }
                int image_id = house_image_group(house->subtype.house_level);
                map_building_tiles_remove(house->id, house->x, house->y);
                house->x = merge_data.x;
                house->y = merge_data.y;
                house->grid_offset = map_grid_offset(house->x, house->y);
                map_building_tiles_add(house->id, house->x, house->y, house->size, image_id, TERRAIN_BUILDING);
                map_tiles_update_all_gardens();
                return 1;
            }
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_VILLA);
        }
    }
    return 0;
}

static int evolve_large_villa(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_GRAND_VILLA);
        } else if (status == DEVOLVE) {
            undo_data.available = 0;
            int inventory_per_tile[INVENTORY_MAX];
            int inventory_remainder[INVENTORY_MAX];
            for (int i = 0; i < INVENTORY_MAX; i++) {
                inventory_per_tile[i] = house->data.house.inventory[i] / 6;
                inventory_remainder[i] = house->data.house.inventory[i] % 6;
            }
            int population_per_tile = house->house_population / 6;
            int population_remainder = house->house_population % 6;

            map_building_tiles_remove(house->id, house->x, house->y);

            // main tile
            house->type = BUILDING_HOUSE_MEDIUM_VILLA;
            house->subtype.house_level = house->type - BUILDING_HOUSE_SMALL_TENT;
            house->size = house->house_size = 2;
            house->house_is_merged = 0;
            house->house_population = population_per_tile + population_remainder;
            for (int i = 0; i < INVENTORY_MAX; i++) {
                house->data.house.inventory[i] = inventory_per_tile[i] + inventory_remainder[i];
            }

            int image_id = house_image_group(house->subtype.house_level);
            map_building_tiles_add(house->id, house->x, house->y, house->size, image_id + (random.items[house->grid_offset] & 1), TERRAIN_BUILDING);

            // the other tiles (new buildings)
            image_id = house_image_group(HOUSE_MEDIUM_INSULA);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x + 2, house->y, image_id, population_per_tile, inventory_per_tile);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x + 2, house->y + 1, image_id, population_per_tile, inventory_per_tile);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x, house->y + 2, image_id, population_per_tile, inventory_per_tile);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x + 1, house->y + 2, image_id, population_per_tile, inventory_per_tile);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x + 2, house->y + 2, image_id, population_per_tile, inventory_per_tile);
        }
    }
    return 0;
}

static int evolve_grand_villa(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_PALACE);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LARGE_VILLA);
        }
    }
    return 0;
}

static int evolve_small_palace(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_MEDIUM_PALACE);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_GRAND_VILLA);
        }
    }
    return 0;
}

static int evolve_medium_palace(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            if (building_house_can_expand(house, 16)) {
                undo_data.available = 0;
                split(house, 16);
                prepare_for_merge(house->id, 16);

                house->type = BUILDING_HOUSE_LARGE_PALACE;
                house->subtype.house_level = HOUSE_LARGE_PALACE;
                house->size = house->house_size = 4;
                house->house_population += merge_data.population;
                for (int i = 0; i < INVENTORY_MAX; i++) {
                    house->data.house.inventory[i] += merge_data.inventory[i];
                }
                int image_id = house_image_group(house->subtype.house_level);
                map_building_tiles_remove(house->id, house->x, house->y);
                house->x = merge_data.x;
                house->y = merge_data.y;
                house->grid_offset = map_grid_offset(house->x, house->y);
                map_building_tiles_add(house->id, house->x, house->y, house->size, image_id, TERRAIN_BUILDING);
                map_tiles_update_all_gardens();
                return 1;
            }
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_PALACE);
        }
    }
    return 0;
}

static int evolve_large_palace(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LUXURY_PALACE);
        } else if (status == DEVOLVE) {
            undo_data.available = 0;
            int inventory_per_tile[INVENTORY_MAX];
            int inventory_remainder[INVENTORY_MAX];
            for (int i = 0; i < INVENTORY_MAX; i++) {
                inventory_per_tile[i] = house->data.house.inventory[i] / 8;
                inventory_remainder[i] = house->data.house.inventory[i] % 8;
            }
            int population_per_tile = house->house_population / 8;
            int population_remainder = house->house_population % 8;

            map_building_tiles_remove(house->id, house->x, house->y);

            // main tile
            house->type = BUILDING_HOUSE_MEDIUM_PALACE;
            house->subtype.house_level = house->type - BUILDING_HOUSE_SMALL_TENT;
            house->size = house->house_size = 3;
            house->house_is_merged = 0;
            house->house_population = population_per_tile + population_remainder;
            for (int i = 0; i < INVENTORY_MAX; i++) {
                house->data.house.inventory[i] = inventory_per_tile[i] + inventory_remainder[i];
            }

            int image_id = house_image_group(house->subtype.house_level);
            map_building_tiles_add(house->id, house->x, house->y, house->size, image_id, TERRAIN_BUILDING);

            // the other tiles (new buildings)
            image_id = house_image_group(HOUSE_MEDIUM_INSULA);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x + 3, house->y, image_id, population_per_tile, inventory_per_tile);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x + 3, house->y + 1, image_id, population_per_tile, inventory_per_tile);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x + 3, house->y + 2, image_id, population_per_tile, inventory_per_tile);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x, house->y + 3, image_id, population_per_tile, inventory_per_tile);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x + 1, house->y + 3, image_id, population_per_tile, inventory_per_tile);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x + 2, house->y + 3, image_id, population_per_tile, inventory_per_tile);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x + 3, house->y + 3, image_id, population_per_tile, inventory_per_tile);
        }
    }
    return 0;
}

static int evolve_luxury_palace(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_evolve_desirability(house);
    if (!has_required_goods_and_services(house, 0, demands)) {
        status = DEVOLVE;
    }
    if (!has_devolve_delay(house, status) && status == DEVOLVE) {
        building_house_change_to(house, BUILDING_HOUSE_LARGE_PALACE);
    }
    return 0;
}

static int (*evolve_callback[])(struct building_t *, struct house_demands_t *) = {
    evolve_small_tent, evolve_large_tent, evolve_small_shack, evolve_large_shack,
    evolve_small_hovel, evolve_large_hovel, evolve_small_casa, evolve_large_casa,
    evolve_small_insula, evolve_medium_insula, evolve_large_insula, evolve_grand_insula,
    evolve_small_villa, evolve_medium_villa, evolve_large_villa, evolve_grand_villa,
    evolve_small_palace, evolve_medium_palace, evolve_large_palace, evolve_luxury_palace
};

static void consume_resource(struct building_t *b, int inventory, int amount)
{
    if (amount > 0) {
        if (amount > b->data.house.inventory[inventory]) {
            b->data.house.inventory[inventory] = 0;
        } else {
            b->data.house.inventory[inventory] -= amount;
        }
    }
}

static int map_water_get_wharf_for_new_fishing_boat(struct figure_t *boat, struct map_point_t *tile)
{
    struct building_t *wharf = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_WHARF) {
            int wharf_boat_id = b->data.industry.fishing_boat_id;
            if (!wharf_boat_id || wharf_boat_id == boat->id) {
                wharf = b;
                break;
            }
        }
    }
    if (!wharf) {
        return 0;
    }
    int dx, dy;
    switch (wharf->data.industry.orientation) {
        case 0: dx = 1; dy = -1; break;
        case 1: dx = 2; dy = 1; break;
        case 2: dx = 1; dy = 2; break;
        default: dx = -1; dy = 1; break;
    }
    tile->x = wharf->x + dx;
    tile->y = wharf->y + dy;
    return wharf->id;
}

static int building_dock_get_queue_destination(struct map_point_t *tile)
{
    if (!city_data.building.working_docks) {
        return 0;
    }
    // first queue position
    for (int i = 0; i < 10; i++) {
        int dock_id = city_data.building.working_dock_ids[i];
        if (!dock_id) continue;
        struct building_t *dock = &all_buildings[dock_id];
        int dx, dy;
        switch (dock->data.dock.orientation) {
            case 0: dx = 2; dy = -2; break;
            case 1: dx = 4; dy = 2; break;
            case 2: dx = 2; dy = 4; break;
            default: dx = -2; dy = 2; break;
        }
        tile->x = dock->x + dx;
        tile->y = dock->y + dy;
        if (!(map_grid_is_valid_offset(map_grid_offset(tile->x, tile->y)) && map_figures.items[map_grid_offset(tile->x, tile->y)] > 0)) {
            return dock_id;
        }
    }
    // second queue position
    for (int i = 0; i < 10; i++) {
        int dock_id = city_data.building.working_dock_ids[i];
        if (!dock_id) continue;
        struct building_t *dock = &all_buildings[dock_id];
        int dx, dy;
        switch (dock->data.dock.orientation) {
            case 0: dx = 2; dy = -3; break;
            case 1: dx = 5; dy = 2; break;
            case 2: dx = 2; dy = 5; break;
            default: dx = -3; dy = 2; break;
        }
        tile->x = dock->x + dx;
        tile->y = dock->y + dy;
        if (!(map_grid_is_valid_offset(map_grid_offset(tile->x, tile->y)) && map_figures.items[map_grid_offset(tile->x, tile->y)] > 0)) {
            return dock_id;
        }
    }
    return 0;
}

static int building_dock_get_free_destination(int ship_id, struct map_point_t *tile)
{
    if (!city_data.building.working_docks) {
        return 0;
    }
    int dock_id = 0;
    for (int i = 0; i < 10; i++) {
        dock_id = city_data.building.working_dock_ids[i];
        if (!dock_id) continue;
        struct building_t *dock = &all_buildings[dock_id];
        if (!dock->data.dock.trade_ship_id || dock->data.dock.trade_ship_id == ship_id) {
            break;
        }
    }
    // BUG: when 10 docks in city, always takes last one... regardless of whether it is free
    if (dock_id <= 0) {
        return 0;
    }
    struct building_t *dock = &all_buildings[dock_id];
    int dx, dy;
    switch (dock->data.dock.orientation) {
        case 0: dx = 1; dy = -1; break;
        case 1: dx = 3; dy = 1; break;
        case 2: dx = 1; dy = 3; break;
        default: dx = -1; dy = 1; break;
    }
    tile->x = dock->x + dx;
    tile->y = dock->y + dy;
    dock->data.dock.trade_ship_id = ship_id;
    return dock_id;
}

static int can_import_resource_from_trade_city(int city_id, int resource)
{
    if (!empire_objects[city_id].resource_sell_limit[resource]) {
        return 0;
    }
    if (city_data.resource.trade_status[resource] != TRADE_STATUS_IMPORT) {
        return 0;
    }
    if (empire_objects[city_id].resource_sold[resource] >= empire_objects[city_id].resource_sell_limit[resource]) {
        return 0;
    }
    int in_stock = city_data.resource.stored_in_warehouses[resource];
    int max_in_stock = 0;
    int finished_good = RESOURCE_NONE;
    switch (resource) {
        // food and finished materials
        case RESOURCE_WHEAT:
        case RESOURCE_VEGETABLES:
        case RESOURCE_FRUIT:
        case RESOURCE_MEAT:
        case RESOURCE_POTTERY:
        case RESOURCE_FURNITURE:
        case RESOURCE_OIL:
        case RESOURCE_WINE:
            if (city_data.population.population < 2000) {
                max_in_stock = 10;
            } else if (city_data.population.population < 4000) {
                max_in_stock = 20;
            } else if (city_data.population.population < 6000) {
                max_in_stock = 30;
            } else {
                max_in_stock = 40;
            }
            break;
        case RESOURCE_MARBLE:
        case RESOURCE_WEAPONS:
            max_in_stock = 10;
            break;

        case RESOURCE_CLAY:
            finished_good = RESOURCE_POTTERY;
            break;
        case RESOURCE_TIMBER:
            finished_good = RESOURCE_FURNITURE;
            break;
        case RESOURCE_OLIVES:
            finished_good = RESOURCE_OIL;
            break;
        case RESOURCE_VINES:
            finished_good = RESOURCE_WINE;
            break;
        case RESOURCE_IRON:
            finished_good = RESOURCE_WEAPONS;
            break;
    }
    if (finished_good) {
        max_in_stock = 2 + 2 * count_data.industry[finished_good].active;
    }
    return in_stock < max_in_stock ? 1 : 0;
}

static int can_export_resource_to_trade_city(int city_id, int resource)
{
    if (city_id && empire_objects[city_id].resource_bought[resource] >= empire_objects[city_id].resource_buy_limit[resource]) {
        // quota reached
        return 0;
    }
    if (city_data.resource.stored_in_warehouses[resource] <= city_data.resource.export_over[resource]) {
        // stocks too low
        return 0;
    }
    if (city_id == 0 || empire_objects[city_id].resource_buy_limit[resource]) {
        return city_data.resource.trade_status[resource] == TRADE_STATUS_EXPORT;
    } else {
        return 0;
    }
}

static int get_delta(int value1, int value2)
{
    if (value1 <= value2) {
        return value2 - value1;
    } else {
        return value1 - value2;
    }
}

static int calc_maximum_distance(int x1, int y1, int x2, int y2)
{
    int distance_x = get_delta(x1, x2);
    int distance_y = get_delta(y1, y2);
    if (distance_x >= distance_y) {
        return distance_x;
    } else {
        return distance_y;
    }
}

static int city_trade_next_caravan_import_resource(void)
{
    city_data.trade.caravan_import_resource++;
    if (city_data.trade.caravan_import_resource >= RESOURCE_TYPES_MAX) {
        city_data.trade.caravan_import_resource = RESOURCE_WHEAT;
    }
    return city_data.trade.caravan_import_resource;
}

static void find_minimum_road_tile(int x, int y, int size, int *min_value, int *min_grid_offset)
{
    int base_offset = map_grid_offset(x, y);
    for (int *tile_delta = ADJACENT_OFFSETS_MAP_GRID[size]; *tile_delta; tile_delta++) {
        int grid_offset = base_offset + *tile_delta;
        if (!map_terrain_is(grid_offset, TERRAIN_BUILDING) ||
            all_buildings[map_building_at(grid_offset)].type != BUILDING_GATEHOUSE) {
            if (map_terrain_is(grid_offset, TERRAIN_ROAD)) {
                int road_index = 11;
                for (int n = 0; n < 10; n++) {
                    if (city_data.map.largest_road_networks[n].id == network.items[grid_offset]) {
                        road_index = n;
                    }
                }
                if (road_index < *min_value) {
                    *min_value = road_index;
                    *min_grid_offset = grid_offset;
                }
            }
        }
    }
}

static int map_has_road_access(int x, int y, int size, struct map_point_t *road)
{
    int min_value = 12;
    int min_grid_offset = map_grid_offset(x, y);
    find_minimum_road_tile(x, y, size, &min_value, &min_grid_offset);
    if (min_value < 12) {
        if (road) {
            road->x = map_grid_offset_to_x(min_grid_offset);
            road->y = map_grid_offset_to_y(min_grid_offset);
        }
        return 1;
    }
    return 0;
}

static int get_closest_warehouse(struct figure_t *f, int x, int y, int city_id, struct map_point_t *warehouse)
{
    int exportable[RESOURCE_TYPES_MAX];
    int importable[RESOURCE_TYPES_MAX];
    exportable[RESOURCE_NONE] = 0;
    importable[RESOURCE_NONE] = 0;
    for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
        exportable[r] = can_export_resource_to_trade_city(city_id, r);
        if (f->trader_amount_bought >= 8) {
            exportable[r] = 0;
        }
        if (city_id) {
            importable[r] = can_import_resource_from_trade_city(city_id, r);
        } else { // Don't import goods from native traders
            importable[r] = 0;
        }
        if (f->loads_sold_or_carrying >= 8) {
            importable[r] = 0;
        }
    }
    int num_importable = 0;
    for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
        if (importable[r]) {
            num_importable++;
        }
    }
    int min_distance = 10000;
    struct building_t *min_building = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_WAREHOUSE) {
            continue;
        }
        if (!b->has_road_access) {
            continue;
        }
        struct building_storage_t *s = &storages[b->storage_id].storage;
        int num_imports_for_warehouse = 0;
        for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
            if (s->resource_state[r] != BUILDING_STORAGE_STATE_NOT_ACCEPTING
                && can_import_resource_from_trade_city(city_id, r)) {
                num_imports_for_warehouse++;
            }
        }
        int distance_penalty = 32;
        struct building_t *space = b;
        for (int space_cnt = 0; space_cnt < 8; space_cnt++) {
            space = &all_buildings[space->next_part_building_id];
            if (space->id && exportable[space->subtype.warehouse_resource_id]) {
                distance_penalty -= 4;
            }
            if (num_importable && num_imports_for_warehouse && !s->empty_all) {
                for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                    int import_resource = city_trade_next_caravan_import_resource();
                    if (s->resource_state[import_resource] != BUILDING_STORAGE_STATE_NOT_ACCEPTING) {
                        break;
                    }
                }
                int resource = city_data.trade.caravan_import_resource;
                if (s->resource_state[resource] != BUILDING_STORAGE_STATE_NOT_ACCEPTING) {
                    if (space->subtype.warehouse_resource_id == RESOURCE_NONE) {
                        distance_penalty -= 16;
                    }
                    if (space->id && importable[space->subtype.warehouse_resource_id] && space->loads_stored < 4 &&
                        space->subtype.warehouse_resource_id == resource) {
                        distance_penalty -= 8;
                    }
                }
            }
        }
        if (distance_penalty < 32) {
            int distance = calc_maximum_distance(b->x, b->y, x, y);
            distance += distance_penalty;
            if (distance < min_distance) {
                min_distance = distance;
                min_building = b;
            }
        }
    }
    if (!min_building) {
        return 0;
    }
    if (min_building->has_road_access == 1) {
        warehouse->x = min_building->x;
        warehouse->y = min_building->y;
    } else if (!map_has_road_access(min_building->x, min_building->y, 3, warehouse)) {
        return 0;
    }
    return min_building->id;
}

static void go_to_next_warehouse(struct figure_t *f, int x_src, int y_src)
{
    struct map_point_t dst;
    int warehouse_id = get_closest_warehouse(f, x_src, y_src, f->empire_city_id, &dst);
    if (warehouse_id) {
        f->destination_building_id = warehouse_id;
        f->action_state = FIGURE_ACTION_TRADE_CARAVAN_ARRIVING;
        f->destination_x = dst.x;
        f->destination_y = dst.y;
    } else {
        f->action_state = FIGURE_ACTION_TRADE_CARAVAN_LEAVING;
        f->destination_x = scenario.exit_point.x;
        f->destination_y = scenario.exit_point.y;
    }
}

static void city_resource_remove_from_warehouse(int resource, int amount)
{
    city_data.resource.space_in_warehouses[resource] += amount;
    city_data.resource.stored_in_warehouses[resource] -= amount;
}

static void city_finance_process_export(int price)
{
    city_data.finance.treasury += price;
    city_data.finance.this_year.income.exports += price;
    if (city_data.religion.neptune_double_trade_active) {
        city_data.finance.treasury += price;
        city_data.finance.this_year.income.exports += price;
    }
}

static int resource_image_offset(int resource, int type)
{
    if (resource == RESOURCE_MEAT && scenario.allowed_buildings[BUILDING_WHARF]) {
        switch (type) {
            case RESOURCE_IMAGE_STORAGE: return 40;
            case RESOURCE_IMAGE_CART: return 648;
            case RESOURCE_IMAGE_FOOD_CART: return 8;
            case RESOURCE_IMAGE_ICON: return 11;
            default: return 0;
        }
    } else {
        return 0;
    }
}

static void building_warehouse_space_set_image(struct building_t *space, int resource)
{
    int image_id;
    if (space->loads_stored <= 0) {
        image_id = EMPTY_WAREHOUSE_IMG_ID;
    } else {
        image_id = resource_images[resource].warehouse_space_img_id +
            resource_image_offset(resource, RESOURCE_IMAGE_STORAGE) +
            space->loads_stored - 1;
    }
    images.items[space->grid_offset] = image_id;
}

static int trader_get_buy_resource(int warehouse_id, int city_id)
{
    struct building_t *warehouse = &all_buildings[warehouse_id];
    if (warehouse->type != BUILDING_WAREHOUSE) {
        return RESOURCE_NONE;
    }
    struct building_t *space = warehouse;
    for (int i = 0; i < 8; i++) {
        space = &all_buildings[space->next_part_building_id];
        if (space->id <= 0) {
            continue;
        }
        int resource = space->subtype.warehouse_resource_id;
        if (space->loads_stored > 0 && can_export_resource_to_trade_city(city_id, resource)) {
            // update stocks
            city_resource_remove_from_warehouse(resource, 1);
            space->loads_stored--;
            if (space->loads_stored <= 0) {
                space->subtype.warehouse_resource_id = RESOURCE_NONE;
            }
            // update finances
            city_finance_process_export(trade_prices[resource].sell);

            // update graphics
            building_warehouse_space_set_image(space, resource);
            return resource;
        }
    }
    return 0;
}

static void figure_route_remove(struct figure_t *f)
{
    if (f->routing_path_id > 0) {
        if (figure_route_data.figure_ids[f->routing_path_id] == f->id) {
            figure_route_data.figure_ids[f->routing_path_id] = 0;
        }
        f->routing_path_id = 0;
    }
}

static int terrain_is_road_like(int grid_offset)
{
    return map_terrain_is(grid_offset, TERRAIN_ROAD | TERRAIN_ACCESS_RAMP) ? 1 : 0;
}

static int get_adjacent_road_tile_for_roaming(int grid_offset)
{
    int is_road = terrain_is_road_like(grid_offset);
    if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
        struct building_t *b = &all_buildings[map_building_at(grid_offset)];
        if (b->type == BUILDING_GATEHOUSE) {
            is_road = 0;
        } else if (b->type == BUILDING_GRANARY) {
            if (terrain_land_citizen.items[grid_offset] == CITIZEN_0_ROAD) {
                is_road = 1;
            }
        }
    }
    return is_road;
}

static int map_get_diagonal_road_tiles_for_roaming(int grid_offset, int *road_tiles)
{
    road_tiles[1] = terrain_is_road_like(grid_offset + map_grid_delta(1, -1));
    road_tiles[3] = terrain_is_road_like(grid_offset + map_grid_delta(1, 1));
    road_tiles[5] = terrain_is_road_like(grid_offset + map_grid_delta(-1, 1));
    road_tiles[7] = terrain_is_road_like(grid_offset + map_grid_delta(-1, -1));

    int max_stretch = 0;
    int stretch = 0;
    for (int i = 0; i < 16; i++) {
        if (road_tiles[i % 8]) {
            stretch++;
            if (stretch > max_stretch) {
                max_stretch = stretch;
            }
        } else {
            stretch = 0;
        }
    }
    return max_stretch;
}

static int calc_general_direction(int x_from, int y_from, int x_to, int y_to)
{
    if (x_from < x_to) {
        if (y_from > y_to) {
            return DIR_1_TOP_RIGHT;
        } else if (y_from == y_to) {
            return DIR_2_RIGHT;
        } else if (y_from < y_to) {
            return DIR_3_BOTTOM_RIGHT;
        }
    } else if (x_from == x_to) {
        if (y_from > y_to) {
            return DIR_0_TOP;
        } else if (y_from < y_to) {
            return DIR_4_BOTTOM;
        }
    } else if (x_from > x_to) {
        if (y_from > y_to) {
            return DIR_7_TOP_LEFT;
        } else if (y_from == y_to) {
            return DIR_6_LEFT;
        } else if (y_from < y_to) {
            return DIR_5_BOTTOM_LEFT;
        }
    }
    return DIR_8_NONE;
}

static void roam_set_direction(struct figure_t *f)
{
    int grid_offset = map_grid_offset(f->x, f->y);
    int direction = calc_general_direction(f->x, f->y, f->destination_x, f->destination_y);
    if (direction >= 8) {
        direction = 0;
    }
    int road_offset_dir1 = 0;
    int road_dir1 = 0;
    for (int i = 0, dir = direction; i < 8; i++) {
        if (dir % 2 == 0 && map_terrain_is(grid_offset + map_grid_direction_delta(dir), TERRAIN_ROAD)) {
            road_dir1 = dir;
            break;
        }
        dir++;
        if (dir > 7) dir = 0;
        road_offset_dir1++;
    }
    int road_offset_dir2 = 0;
    int road_dir2 = 0;
    for (int i = 0, dir = direction; i < 8; i++) {
        if (dir % 2 == 0 && map_terrain_is(grid_offset + map_grid_direction_delta(dir), TERRAIN_ROAD)) {
            road_dir2 = dir;
            break;
        }
        dir--;
        if (dir < 0) dir = 7;
        road_offset_dir2++;
    }
    if (road_offset_dir1 <= road_offset_dir2) {
        f->direction = road_dir1;
        f->roam_turn_direction = 2;
    } else {
        f->direction = road_dir2;
        f->roam_turn_direction = -2;
    }
    f->roam_ticks_until_next_turn = 5;
}

static void adjust_tile_in_direction(int direction, int *x, int *y, int *grid_offset)
{
    switch (direction) {
        case DIR_0_TOP:
            --*y;
            break;
        case DIR_1_TOP_RIGHT:
            ++*x;
            --*y;
            break;
        case DIR_2_RIGHT:
            ++*x;
            break;
        case DIR_3_BOTTOM_RIGHT:
            ++*x;
            ++*y;
            break;
        case DIR_4_BOTTOM:
            ++*y;
            break;
        case DIR_5_BOTTOM_LEFT:
            --*x;
            ++*y;
            break;
        case DIR_6_LEFT:
            --*x;
            break;
        case DIR_7_TOP_LEFT:
            --*x;
            --*y;
            break;
    }
    *grid_offset += map_grid_direction_delta(direction);
}

static int map_routing_get_path(uint8_t *path, int src_x, int src_y, int dst_x, int dst_y, int num_directions)
{
    int dst_grid_offset = map_grid_offset(dst_x, dst_y);
    int distance = routing_distance.items[dst_grid_offset];
    if (distance <= 0 || distance >= 998) {
        return 0;
    }
    int num_tiles = 0;
    int last_direction = -1;
    int x = dst_x;
    int y = dst_y;
    int grid_offset = dst_grid_offset;
    int step = num_directions == 8 ? 1 : 2;
    while (distance > 1) {
        distance = routing_distance.items[grid_offset];
        int direction = -1;
        int general_direction = calc_general_direction(x, y, src_x, src_y);
        for (int d = 0; d < 8; d += step) {
            if (d != last_direction) {
                int next_offset = grid_offset + map_grid_direction_delta(d);
                int next_distance = routing_distance.items[next_offset];
                if (next_distance) {
                    if (next_distance < distance) {
                        distance = next_distance;
                        direction = d;
                    } else if (next_distance == distance && (d == general_direction || direction == -1)) {
                        distance = next_distance;
                        direction = d;
                    }
                }
            }
        }
        if (direction == -1) {
            return 0;
        }
        adjust_tile_in_direction(direction, &x, &y, &grid_offset);
        int forward_direction = (direction + 4) % 8;
        direction_path[num_tiles++] = forward_direction;
        last_direction = forward_direction;
        if (num_tiles >= MAX_PATH) {
            return 0;
        }
    }
    for (int i = 0; i < num_tiles; i++) {
        path[i] = direction_path[num_tiles - i - 1];
    }
    return num_tiles;
}

static int map_routing_get_path_on_water(uint8_t *path, int dst_x, int dst_y, int is_flotsam)
{
    int rand = random_data.random1_7bit & 3;
    int dst_grid_offset = map_grid_offset(dst_x, dst_y);
    int distance = routing_distance.items[dst_grid_offset];
    if (distance <= 0 || distance >= 998) {
        return 0;
    }
    int num_tiles = 0;
    int last_direction = -1;
    int x = dst_x;
    int y = dst_y;
    int grid_offset = dst_grid_offset;
    while (distance > 1) {
        int current_rand = rand;
        distance = routing_distance.items[grid_offset];
        if (is_flotsam) {
            current_rand = random.items[grid_offset] & 3;
        }
        int direction = -1;
        for (int d = 0; d < 8; d++) {
            if (d != last_direction) {
                int next_offset = grid_offset + map_grid_direction_delta(d);
                int next_distance = routing_distance.items[next_offset];
                if (next_distance) {
                    if (next_distance < distance) {
                        distance = next_distance;
                        direction = d;
                    } else if (next_distance == distance && rand == current_rand) {
                        // allow flotsam to wander
                        distance = next_distance;
                        direction = d;
                    }
                }
            }
        }
        if (direction == -1) {
            return 0;
        }
        adjust_tile_in_direction(direction, &x, &y, &grid_offset);
        int forward_direction = (direction + 4) % 8;
        direction_path[num_tiles++] = forward_direction;
        last_direction = forward_direction;
        if (num_tiles >= MAX_PATH) {
            return 0;
        }
    }
    for (int i = 0; i < num_tiles; i++) {
        path[i] = direction_path[num_tiles - i - 1];
    }
    return num_tiles;
}

static void enqueue(int next_offset, int dist)
{
    routing_distance.items[next_offset] = dist;
    routing_queue.items[routing_queue.tail++] = next_offset;
    if (routing_queue.tail >= MAX_QUEUE_ROUTING) {
        routing_queue.tail = 0;
    }
}

static void callback_travel_citizen_land(int next_offset, int dist)
{
    if (terrain_land_citizen.items[next_offset] >= 0) {
        enqueue(next_offset, dist);
    }
}

static int valid_offset(int grid_offset)
{
    return map_grid_is_valid_offset(grid_offset) && routing_distance.items[grid_offset] == 0;
}

static void route_queue(int source, int dest, void (*callback)(int next_offset, int dist))
{
    memset(routing_distance.items, 0, GRID_SIZE * GRID_SIZE * sizeof(int16_t));
    routing_queue.head = routing_queue.tail = 0;
    enqueue(source, 1);
    while (routing_queue.head != routing_queue.tail) {
        int offset = routing_queue.items[routing_queue.head];
        if (offset == dest) {
            break;
        }
        int dist = 1 + routing_distance.items[offset];
        for (int i = 0; i < 4; i++) {
            if (valid_offset(offset + ROUTE_OFFSETS[i])) {
                callback(offset + ROUTE_OFFSETS[i], dist);
            }
        }
        if (++routing_queue.head >= MAX_QUEUE_ROUTING) {
            routing_queue.head = 0;
        }
    }
}

static int map_routing_citizen_can_travel_over_land(int src_x, int src_y, int dst_x, int dst_y)
{
    int src_offset = map_grid_offset(src_x, src_y);
    int dst_offset = map_grid_offset(dst_x, dst_y);
    ++stats.total_routes_calculated;
    route_queue(src_offset, dst_offset, callback_travel_citizen_land);
    return routing_distance.items[dst_offset] != 0;
}

static void callback_travel_walls(int next_offset, int dist)
{
    if (terrain_walls.items[next_offset] >= WALL_0_PASSABLE &&
        terrain_walls.items[next_offset] <= 2) {
        enqueue(next_offset, dist);
    }
}

static void callback_travel_citizen_road_garden(int next_offset, int dist)
{
    if (terrain_land_citizen.items[next_offset] >= CITIZEN_0_ROAD &&
        terrain_land_citizen.items[next_offset] <= CITIZEN_2_PASSABLE_TERRAIN) {
        enqueue(next_offset, dist);
    }
}

static int map_routing_citizen_can_travel_over_road_garden(int src_x, int src_y, int dst_x, int dst_y)
{
    int src_offset = map_grid_offset(src_x, src_y);
    int dst_offset = map_grid_offset(dst_x, dst_y);
    ++stats.total_routes_calculated;
    route_queue(src_offset, dst_offset, callback_travel_citizen_road_garden);
    return routing_distance.items[dst_offset] != 0;
}

static void labor_seeker_coverage(__attribute__((unused)) struct building_t *b)
{}

static void theater_coverage(struct building_t *b)
{
    b->data.house.theater = MAX_COVERAGE;
}

static void amphitheater_coverage(struct building_t *b, int shows)
{
    b->data.house.amphitheater_actor = MAX_COVERAGE;
    if (shows == 2) {
        b->data.house.amphitheater_gladiator = MAX_COVERAGE;
    }
}

static void colosseum_coverage(struct building_t *b, int shows)
{
    b->data.house.colosseum_gladiator = MAX_COVERAGE;
    if (shows == 2) {
        b->data.house.colosseum_lion = MAX_COVERAGE;
    }
}

static void hippodrome_coverage(struct building_t *b)
{
    b->data.house.hippodrome = MAX_COVERAGE;
}

static void bathhouse_coverage(struct building_t *b)
{
    b->data.house.bathhouse = MAX_COVERAGE;
}

static void religion_coverage_ceres(struct building_t *b)
{
    b->data.house.temple_ceres = MAX_COVERAGE;
}

static void religion_coverage_neptune(struct building_t *b)
{
    b->data.house.temple_neptune = MAX_COVERAGE;
}

static void religion_coverage_mercury(struct building_t *b)
{
    b->data.house.temple_mercury = MAX_COVERAGE;
}

static void religion_coverage_mars(struct building_t *b)
{
    b->data.house.temple_mars = MAX_COVERAGE;
}

static void religion_coverage_venus(struct building_t *b)
{
    b->data.house.temple_venus = MAX_COVERAGE;
}

static void school_coverage(struct building_t *b)
{
    b->data.house.school = MAX_COVERAGE;
}

static void academy_coverage(struct building_t *b)
{
    b->data.house.academy = MAX_COVERAGE;
}

static void library_coverage(struct building_t *b)
{
    b->data.house.library = MAX_COVERAGE;
}

static void barber_coverage(struct building_t *b)
{
    b->data.house.barber = MAX_COVERAGE;
}

static void clinic_coverage(struct building_t *b)
{
    b->data.house.clinic = MAX_COVERAGE;
}

static void hospital_coverage(struct building_t *b)
{
    b->data.house.hospital = MAX_COVERAGE;
}

static int provide_service(int x, int y, int *data, void (*callback)(struct building_t *, int *))
{
    int serviced = 0;
    int x_min, y_min, x_max, y_max;
    map_grid_get_area(x, y, 1, 2, &x_min, &y_min, &x_max, &y_max);
    for (int yy = y_min; yy <= y_max; yy++) {
        for (int xx = x_min; xx <= x_max; xx++) {
            int grid_offset = map_grid_offset(xx, yy);
            int building_id = map_building_at(grid_offset);
            if (building_id) {
                struct building_t *b = &all_buildings[building_id];
                callback(b, data);
                if (b->house_size && b->house_population > 0) {
                    serviced++;
                }
            }
        }
    }
    return serviced;
}

static void engineer_coverage(struct building_t *b, int *max_damage_seen)
{
    if (b->type == BUILDING_HIPPODROME) {
        b = building_main(b);
    }
    if (b->damage_risk > *max_damage_seen) {
        *max_damage_seen = b->damage_risk;
    }
    b->damage_risk = 0;
}

static int provide_culture(int x, int y, void (*callback)(struct building_t *))
{
    int serviced = 0;
    int x_min, y_min, x_max, y_max;
    map_grid_get_area(x, y, 1, 2, &x_min, &y_min, &x_max, &y_max);
    for (int yy = y_min; yy <= y_max; yy++) {
        for (int xx = x_min; xx <= x_max; xx++) {
            int grid_offset = map_grid_offset(xx, yy);
            int building_id = map_building_at(grid_offset);
            if (building_id) {
                struct building_t *b = &all_buildings[building_id];
                if (b->house_size && b->house_population > 0) {
                    callback(b);
                    serviced++;
                }
            }
        }
    }
    return serviced;
}

static int provide_entertainment(int x, int y, int shows, void (*callback)(struct building_t *, int))
{
    int serviced = 0;
    int x_min, y_min, x_max, y_max;
    map_grid_get_area(x, y, 1, 2, &x_min, &y_min, &x_max, &y_max);
    for (int yy = y_min; yy <= y_max; yy++) {
        for (int xx = x_min; xx <= x_max; xx++) {
            int grid_offset = map_grid_offset(xx, yy);
            int building_id = map_building_at(grid_offset);
            if (building_id) {
                struct building_t *b = &all_buildings[building_id];
                if (b->house_size && b->house_population > 0) {
                    callback(b, shows);
                    serviced++;
                }
            }
        }
    }
    return serviced;
}

static void tax_collector_coverage(struct building_t *b, int *max_tax_multiplier)
{
    if (b->house_size && b->house_population > 0) {
        if (house_properties[b->subtype.house_level].tax_multiplier > *max_tax_multiplier) {
            *max_tax_multiplier = house_properties[b->subtype.house_level].tax_multiplier;
        }
        b->house_tax_coverage = 50;
    }
}

static void prefect_coverage(struct building_t *b, int *min_happiness_seen)
{
    if (b->type == BUILDING_HIPPODROME) {
        b = building_main(b);
    }
    b->fire_risk = 0;
    if (b->sentiment.house_happiness < *min_happiness_seen) {
        *min_happiness_seen = b->sentiment.house_happiness;
    }
}

static void distribute_good(struct building_t *b, struct building_t *market, int stock_wanted, int inventory_resource)
{
    int amount_wanted = stock_wanted - b->data.house.inventory[inventory_resource];
    if (market->data.market.inventory[inventory_resource] > 0 && amount_wanted > 0) {
        if (amount_wanted <= market->data.market.inventory[inventory_resource]) {
            b->data.house.inventory[inventory_resource] += amount_wanted;
            market->data.market.inventory[inventory_resource] -= amount_wanted;
        } else {
            b->data.house.inventory[inventory_resource] += market->data.market.inventory[inventory_resource];
            market->data.market.inventory[inventory_resource] = 0;
        }
    }
}

static int city_message_get_text_id(int message_type)
{
    if (message_type > 50) {
        return message_type + 199;
    } else {
        return message_type + 99;
    }
}

static void play_sound_effect(int effect)
{
    if (!settings_values[SETTINGS_SOUND_EFFECTS_ENABLED]) {
        return;
    }
    if (data_channels.channels[effect].chunk && Mix_Playing(effect)) {
        return;
    }
    if (data_channels.initialized) {
        struct sound_channel_t *ch = &data_channels.channels[effect];
        if (load_channel(ch)) {
            set_channel_volume(effect, settings_values[SETTINGS_SOUND_EFFECTS_VOLUME]);
            Mix_PlayChannel(effect, ch->chunk, 0);
        }
    }
}

static void play_sound(int text_id)
{
    if (lang_data.message_entries[text_id].urgent == 1) {
        play_sound_effect(SOUND_EFFECT_FANFARE_URGENT);
    } else {
        play_sound_effect(SOUND_EFFECT_FANFARE);
    }
}

static void prepend_dir_to_path(char *dir_to_prepend, char *filepath, char *resulting_string)
{
    size_t dir_len = string_length(dir_to_prepend) + 1;
    string_copy(dir_to_prepend, resulting_string, DIR_PATH_MAX);
    resulting_string[dir_len - 1] = '\\';
    string_copy(filepath, &resulting_string[dir_len], DIR_PATH_MAX - dir_len - 1);
}

static int file_exists(char *dir, char *filename)
{
    if (dir) {
        static char filepath_to_save[DIR_PATH_MAX];
        filepath_to_save[DIR_PATH_MAX - 1] = 0;
        prepend_dir_to_path(dir, filename, filepath_to_save);
        if (access(filepath_to_save, F_OK) == 0) {
            return 1;
        } else {
            return 0;
        }
    } else {
        if (access(filename, F_OK) == 0) {
            return 1;
        } else {
            return 0;
        }
    }
}

static void decrease_queue_index(void)
{
    window_data.queue_index--;
    if (window_data.queue_index < 0) {
        window_data.queue_index = MAX_WINDOW_QUEUE - 1;
    }
}

static void increase_queue_index(void)
{
    window_data.queue_index++;
    if (window_data.queue_index >= MAX_WINDOW_QUEUE) {
        window_data.queue_index = 0;
    }
}

static void window_draw_underlying_window(void)
{
    if (window_data.underlying_windows_redrawing < MAX_WINDOW_QUEUE) {
        ++window_data.underlying_windows_redrawing;
        decrease_queue_index();
        struct window_type_t *window_behind = &window_data.window_queue[window_data.queue_index];
        if (window_behind->draw_background) {
            window_behind->draw_background();
        }
        if (window_behind->draw_foreground) {
            window_behind->draw_foreground();
        }
        increase_queue_index();
        --window_data.underlying_windows_redrawing;
    }
}

static void set_translation(int x, int y)
{
    int dx = x - translation.x;
    int dy = y - translation.y;
    translation.x = x;
    translation.y = y;
    translate_clip(dx, dy);
}

static void rich_text_set_fonts(int normal_font, int link_font, int line_spacing)
{
    rich_text_data.normal_font = &font_data.font_definitions[normal_font];
    rich_text_data.link_font = &font_data.font_definitions[link_font];
    rich_text_data.line_height = rich_text_data.normal_font->line_height + line_spacing;
    rich_text_data.paragraph_indent = 50;
}

static void rich_text_clear_links(void)
{
    for (int i = 0; i < MAX_LINKS; i++) {
        links[i].message_id = 0;
        links[i].x_min = 0;
        links[i].x_max = 0;
        links[i].y_min = 0;
        links[i].y_max = 0;
    }
    rich_text_data.num_links = 0;
}

static int string_to_int(char *str)
{
    static   int multipliers[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000 };
    char *ptr = str;
    int negative = 0;
    int num_chars = 0;
    if (*ptr == '-') {
        negative = 1;
        ptr++;
    }
    while (*ptr >= '0' && *ptr <= '9') {
        num_chars++;
        ptr++;
    }

    if (num_chars > 8) {
        return 0;
    }
    ptr = str;
    if (*ptr == '-') {
        ptr++;
    }
    int result = 0;
    while (num_chars) {
        --num_chars;
        result += multipliers[num_chars] * (*ptr - '0');
        ptr++;
    }
    if (negative) {
        result = -result;
    }
    return result;
}

static void on_scroll(void)
{
    rich_text_clear_links();
    window_invalidate();
}

static struct scrollbar_type_t scrollbar = { 0, 0, 0, on_scroll, 0, 0, 0, 0, 0, 0 };

static int draw_text(char *text, int x_offset, int y_offset, int box_width, int height_lines, color_t color, int measure_only)
{
    int image_height_lines = 0;
    int image_id = 0;
    int lines_before_image = 0;
    int paragraph = 0;
    int has_more_characters = 1;
    int y = y_offset;
    int guard = 0;
    int line = 0;
    int num_lines = 0;
    while (has_more_characters || image_height_lines) {
        if (++guard >= 1000) {
            break;
        }
        // clear line
        for (int i = 0; i < 200; i++) {
            tmp_line_rich_text[i] = 0;
        }
        int line_index = 0;
        int current_width, x_line_offset;
        current_width = x_line_offset = paragraph ? rich_text_data.paragraph_indent : 0;
        paragraph = 0;
        while ((has_more_characters || image_height_lines) && current_width < box_width) {
            if (image_height_lines) {
                image_height_lines--;
                break;
            }
            int word_num_chars;
            current_width += get_word_width_rich_text(text, &word_num_chars);
            if (current_width >= box_width) {
                if (current_width == 0) {
                    has_more_characters = 0;
                }
            } else {
                for (int i = 0; i < word_num_chars; i++) {
                    char c = *text++;
                    if (c == '@') {
                        if (*text == 'P') {
                            paragraph = 1;
                            text++;
                            current_width = box_width;
                            break;
                        } else if (*text == 'L') {
                            text++;
                            current_width = box_width;
                            break;
                        } else if (*text == 'G') {
                            if (line_index) {
                                num_lines++;
                            }
                            text++; // skip 'G'
                            current_width = box_width;
                            image_id = string_to_int(text);
                            c = *text++;
                            while (c >= '0' && c <= '9') {
                                c = *text++;
                            }
                            image_id += image_data_s.group_image_ids[GROUP_MESSAGE_IMAGES] - 1;
                            image_height_lines = image_get(image_id)->height / rich_text_data.line_height + 2;
                            if (line > 0) {
                                lines_before_image = 1;
                            }
                            break;
                        }
                    }
                    if (line_index || c != ' ') { // no space at start of line
                        tmp_line_rich_text[line_index++] = c;
                    }
                }
                if (!*text) {
                    has_more_characters = 0;
                }
            }
        }

        int outside_viewport = 0;
        if (!measure_only) {
            if (line < scrollbar.scroll_position || line >= scrollbar.scroll_position + height_lines) {
                outside_viewport = 1;
            }
        }
        if (!outside_viewport) {
            char *str = tmp_line_rich_text;
            int x = x_line_offset + x_offset;
            int num_link_chars = 0;
            while (*str) {
                if (*str == '@') {
                    int message_id = string_to_int(++str);
                    while (*str >= '0' && *str <= '9') {
                        str++;
                    }
                    int width = get_word_width_rich_text(str, &num_link_chars);
                    if (rich_text_data.num_links < MAX_LINKS) {
                        links[rich_text_data.num_links].message_id = message_id;
                        links[rich_text_data.num_links].x_min = x - 2;
                        links[rich_text_data.num_links].x_max = x + width + 2;
                        links[rich_text_data.num_links].y_min = y - 1;
                        links[rich_text_data.num_links].y_max = y + 13;
                        rich_text_data.num_links++;
                    }
                }
                if (*str >= ' ') {
                    struct font_definition_t *def = rich_text_data.normal_font;
                    if (num_link_chars > 0) {
                        def = rich_text_data.link_font;
                    }
                    int letter_id = font_letter_id(def, str);
                    if (letter_id < 0) {
                        x += def->space_width;
                    } else {
                        struct image_t *img = image_letter(letter_id);
                        if (!measure_only) {
                            int height = def->image_y_offset(*str, img->height, def->line_height);
                            image_draw_letter(letter_id, x, y - height, color);
                        }
                        x += img->width + def->letter_spacing;
                    }
                    if (num_link_chars > 0) {
                        num_link_chars -= 1;
                    }
                    str += 1;
                } else {
                    str++;
                }
            }
        }
        if (!measure_only) {
            if (image_id) {
                if (lines_before_image) {
                    lines_before_image--;
                } else {
                    struct image_t *img = image_get(image_id);
                    image_height_lines = img->height / rich_text_data.line_height + 2;
                    int image_offset_x = x_offset + (box_width - img->width) / 2 - 4;
                    if (line < height_lines + scrollbar.scroll_position) {
                        if (line >= scrollbar.scroll_position) {
                            image_draw(image_id, image_offset_x, y + 8);
                        } else {
                            image_draw(image_id, image_offset_x,
                                y + 8 - rich_text_data.line_height * (scrollbar.scroll_position - line));
                        }
                    }
                    image_id = 0;
                }
            }
        }
        line++;
        num_lines++;
        if (!outside_viewport) {
            y += rich_text_data.line_height;
        }
    }
    return num_lines;
}

static void outer_panel_draw(int x, int y, int width_blocks, int height_blocks)
{
    int image_base = image_data_s.group_image_ids[GROUP_DIALOG_BACKGROUND];
    int image_id;
    int image_y = 0;
    int y_add = 0;
    for (int yy = 0; yy < height_blocks; yy++) {
        int image_x = 0;
        for (int xx = 0; xx < width_blocks; xx++) {
            if (yy == 0) {
                if (xx == 0) {
                    image_id = 0;
                } else if (xx < width_blocks - 1) {
                    image_id = 1 + image_x++;
                } else {
                    image_id = 11;
                }
                y_add = 0;
            } else if (yy < height_blocks - 1) {
                if (xx == 0) {
                    image_id = 12 + image_y;
                } else if (xx < width_blocks - 1) {
                    image_id = 13 + image_y + image_x++;
                } else {
                    image_id = 23 + image_y;
                }
                y_add = 12;
            } else {
                if (xx == 0) {
                    image_id = 132;
                } else if (xx < width_blocks - 1) {
                    image_id = 133 + image_x++;
                } else {
                    image_id = 143;
                }
                y_add = 0;
            }
            image_draw(image_base + image_id, x + BLOCK_SIZE * xx, y + BLOCK_SIZE * yy);
            if (image_x >= 10) {
                image_x = 0;
            }
        }
        image_y += y_add;
        if (image_y >= 120) {
            image_y = 0;
        }
    }
}

static void graphics_draw_vertical_line(int x, int y1, int y2, color_t color)
{
    if (x < clip_rectangle.x_start || x >= clip_rectangle.x_end) {
        return;
    }
    int y_min = y1 < y2 ? y1 : y2;
    int y_max = y1 < y2 ? y2 : y1;
    y_min = y_min < clip_rectangle.y_start ? clip_rectangle.y_start : y_min;
    y_max = y_max >= clip_rectangle.y_end ? clip_rectangle.y_end - 1 : y_max;
    color_t *pixel = graphics_get_pixel(x, y_min);
    color_t *end_pixel = pixel + ((y_max - y_min) * canvas.width);
    while (pixel <= end_pixel) {
        *pixel = color;
        pixel += canvas.width;
    }
}

static void graphics_draw_rect(int x, int y, int width, int height, color_t color)
{
    graphics_draw_horizontal_line(x, x + width - 1, y, color);
    graphics_draw_horizontal_line(x, x + width - 1, y + height - 1, color);
    graphics_draw_vertical_line(x, y, y + height - 1, color);
    graphics_draw_vertical_line(x + width - 1, y, y + height - 1, color);
}

static void inner_panel_draw(int x, int y, int width_blocks, int height_blocks)
{
    int image_base = image_data_s.group_image_ids[GROUP_SUNKEN_TEXTBOX_BACKGROUND];
    int image_y = 0;
    int y_add = 0;
    for (int yy = 0; yy < height_blocks; yy++) {
        int image_x = 0;
        for (int xx = 0; xx < width_blocks; xx++) {
            int image_id;
            if (yy == 0) {
                if (xx == 0) {
                    image_id = 0;
                } else if (xx < width_blocks - 1) {
                    image_id = 1 + image_x++;
                } else {
                    image_id = 6;
                }
                y_add = 0;
            } else if (yy < height_blocks - 1) {
                if (xx == 0) {
                    image_id = 7 + image_y;
                } else if (xx < width_blocks - 1) {
                    image_id = 8 + image_y + image_x++;
                } else {
                    image_id = 13 + image_y;
                }
                y_add = 7;
            } else {
                if (xx == 0) {
                    image_id = 42;
                } else if (xx < width_blocks - 1) {
                    image_id = 43 + image_x++;
                } else {
                    image_id = 48;
                }
                y_add = 0;
            }
            image_draw(image_base + image_id, x + BLOCK_SIZE * xx, y + BLOCK_SIZE * yy);
            if (image_x >= 5) {
                image_x = 0;
            }
        }
        image_y += y_add;
        if (image_y >= 35) {
            image_y = 0;
        }
    }
}

static int text_draw_number(int value, char prefix, char *postfix, int x_offset, int y_offset, int font)
{
    char str[NUMBER_BUFFER_LENGTH];
    number_to_string(str, value, prefix, postfix);
    return text_draw(str, x_offset, y_offset, font, 0);
}

static int lang_text_draw(int group, int number, int x_offset, int y_offset, int font)
{
    char *str = lang_get_string(group, number);
    return text_draw(str, x_offset, y_offset, font, 0);
}

static int lang_text_draw_year(int year, int x_offset, int y_offset, int font)
{
    int width = 0;
    if (year >= 0) {
        width += text_draw_number(year, ' ', " ", x_offset + width, y_offset, font);
        width += lang_text_draw(20, 1, x_offset + width, y_offset, font);
    } else {
        width += text_draw_number(-year, ' ', " ", x_offset + width, y_offset, font);
        width += lang_text_draw(20, 0, x_offset + width, y_offset, font);
    }
    return width;
}

static int lang_text_draw_amount(int group, int number, int amount, int x_offset, int y_offset, int font)
{
    int amount_offset = 1;
    if (amount == 1 || amount == -1) {
        amount_offset = 0;
    }
    int desc_offset_x;
    if (amount >= 0) {
        desc_offset_x = text_draw_number(amount, ' ', " ", x_offset, y_offset, font);
    } else {
        desc_offset_x = text_draw_number(-amount, '-', " ", x_offset, y_offset, font);
    }
    return desc_offset_x + lang_text_draw(group, number + amount_offset, x_offset + desc_offset_x, y_offset, font);
}

static inline void *clear_malloc(size_t s)
{
    void *buf = malloc(s);
    if (buf) {
        memset(buf, 0, s);
    }
    return buf;
}

static int32_t read_i32(uint8_t *data)
{
    return (int32_t) (data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24));
}

static struct bitstream_t *bitstream_init(struct bitstream_t *bs, uint8_t *data, int len)
{
    bs->data = data;
    bs->length = len;
    bs->index = 0;
    bs->bit_index = 0;
    return bs;
}

static int read_bit(struct bitstream_t *bs)
{
    if (bs->index >= bs->length) {
        return 0;
    }
    int result = bs->data[bs->index] & (1 << bs->bit_index);
    if (++bs->bit_index >= 8) {
        bs->index++;
        bs->bit_index = 0;
    }
    return result ? 1 : 0;
}

static inline uint8_t read_byte(struct bitstream_t *bs)
{
    if (bs->bit_index == 0) {
        // special case: on exact byte boundary
        if (bs->index < bs->length) {
            return bs->data[bs->index++];
        } else {
            return 0;
        }
    }
    if (bs->index + 1 >= bs->length) {
        return 0;
    }
    uint8_t value = bs->data[bs->index] >> bs->bit_index;
    bs->index++;
    value |= (bs->data[bs->index] & BIT_MASKS[bs->bit_index]) << (8 - bs->bit_index);
    return value;
}

static struct huffnode8_t *build_tree8_nodes(struct bitstream_t *bs, struct hufftree8_t *tree)
{
    struct huffnode8_t *node = &tree->nodes[tree->size++];
    if (read_bit(bs)) {
        node->is_leaf = 0;
        node->b[0] = build_tree8_nodes(bs, tree);
        node->b[1] = build_tree8_nodes(bs, tree);
    } else {
        node->is_leaf = 1;
        node->value = read_byte(bs);
    }
    return node;
}

static struct hufftree8_t *create_tree8(struct bitstream_t *bs)
{
    if (read_bit(bs)) {
        struct hufftree8_t *tree = (struct hufftree8_t *) clear_malloc(sizeof(struct hufftree8_t));
        if (!tree) {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: no memory for 8-bit tree", 0, 0));
            return 0;
        }
        build_tree8_nodes(bs, tree);
        if (read_bit(bs) != 0) {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: 8-bit tree not closed", 0, 0));
            free(tree);
            return 0;
        }
        return tree;
    } else {
        SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: WARN: no 8-bit tree found", 0, 0));
        return 0;
    }
}

static uint8_t lookup_tree8(struct bitstream_t *bs, struct hufftree8_t *tree)
{
    struct huffnode8_t *node = &tree->nodes[0];
    while (!node->is_leaf) {
        node = node->b[read_bit(bs)];
    }
    return node->value;
}

static void reset_escape16(struct hufftree16_t *tree)
{
    if (tree) {
        for (int i = 0; i < 3; i++) {
            tree->escape_nodes[i]->value = 0;
        }
    }
}

static uint16_t lookup_tree16(struct bitstream_t *bs, struct hufftree16_t *tree)
{
    if (!tree) {
        return 0;
    }
    struct huffnode16_t *node = tree->root;
    while (!node->is_leaf) {
        node = node->b[read_bit(bs)];
    }

    uint16_t value = node->value;
    if (value != tree->escape_nodes[0]->value) {
        tree->escape_nodes[2]->value = tree->escape_nodes[1]->value;
        tree->escape_nodes[1]->value = tree->escape_nodes[0]->value;
        tree->escape_nodes[0]->value = value;
    }
    return value;
}

static int decode_frame(smacker s)
{
    int frame_id = s->current_frame;
    if (frame_id >= s->frames) {
        return SMACKER_FRAME_DONE;
    }
    if (fseek(s->fp, s->frame_data_offset_in_file + s->frame_offsets[frame_id], SEEK_SET) != 0) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: unable to seek to frame data", 0, frame_id));
        return SMACKER_FRAME_ERROR;
    }
    int frame_size = s->frame_sizes[frame_id];
    uint8_t *frame_data = (uint8_t *) clear_malloc(frame_size);
    if (!frame_data) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: no memory for frame data", 0, frame_id));
        return SMACKER_FRAME_ERROR;
    }
    if (fread(frame_data, 1, frame_size, s->fp) != (unsigned) frame_size) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: unable to read data for frame", 0, frame_id));
        free(frame_data);
        return SMACKER_FRAME_ERROR;
    }
    uint8_t frame_type = s->frame_types[frame_id];
    int data_index = 0;
    if (frame_type & 0x01) {
        int palette_size = frame_data[0] * 4;
        uint8_t *data = &frame_data[1];
        color_t new_palette[MAX_PALETTE];
        int index = 0;
        int color_index = 0;
        while (index < palette_size - 1 && color_index < MAX_PALETTE) {
            if (data[index] & 0x80) {
                // Copy from same position in previous palette
                int num_entries = 1 + (data[index] & 0x7f);
                if (num_entries + color_index > MAX_PALETTE) {
                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: invalid palette data", 0, 0));
                    free(frame_data);
                    return SMACKER_FRAME_ERROR;
                }
                memcpy(&new_palette[color_index], &s->frame_data.palette[color_index], sizeof(int32_t) * num_entries);
                color_index += num_entries;
                index++;
            } else if (data[index] & 0x40) {
                // Copy from 'offset' position in previous palette
                int num_entries = 1 + (data[index] & 0x3f);
                int offset = data[index + 1];
                if (num_entries + color_index > MAX_PALETTE || num_entries + offset > MAX_PALETTE) {
                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: invalid palette data", 0, 0));
                    free(frame_data);
                    return SMACKER_FRAME_ERROR;
                }
                memcpy(&new_palette[color_index], &s->frame_data.palette[offset], sizeof(int32_t) * num_entries);
                color_index += num_entries;
                index += 2;
            } else {
                // Literal color
                new_palette[color_index] =
                    (PALETTE_MAP[data[index] & 0x3f] << 16) |
                    (PALETTE_MAP[data[index + 1] & 0x3f] << 8) |
                    (PALETTE_MAP[data[index + 2] & 0x3f]);
                color_index++;
                index += 3;
            }
        }
        memcpy(s->frame_data.palette, new_palette, sizeof(color_t) * MAX_PALETTE);
        data_index += palette_size;
    }
    for (int i = 0; i < MAX_TRACKS; i++) {
        if (frame_type & (1 << (i + 1))) {
            int track_length = read_i32(&frame_data[data_index]);
            uint8_t *data = &frame_data[data_index + 4];
            if ((s->audio_rate[i] & AUDIO_FLAG_COMPRESSED) == 0) {
                // Uncompressed data, just copy and return
                memcpy(s->frame_data.audio[i], data, track_length - 4);
                s->frame_data.audio_len[i] = track_length - 4;
            } else {
                int32_t uncompressed_length = read_i32(data);
                struct bitstream_t bstream;
                struct bitstream_t *bs = bitstream_init(&bstream, &data[4], track_length - 4 - 4);
                if (!read_bit(bs)) {
                    s->frame_data.audio_len[i] = 0;
                } else {
                    int is_stereo = read_bit(bs);
                    int is_16bit = read_bit(bs);
                    int header_is_stereo = (s->audio_rate[i] & AUDIO_FLAG_STEREO) ? 1 : 0;
                    int header_is_16bit = (s->audio_rate[i] & AUDIO_FLAG_16BIT) ? 1 : 0;
                    if (is_stereo != header_is_stereo) {
                        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: stereo flag in frame does not match header", 0, 0));
                    } else if (is_16bit != header_is_16bit) {
                        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: 16-bit flag in frame does not match header", 0, 0));
                    } else {
                        int channels = is_stereo ? 2 : 1;
                        int rate_bytes = is_16bit ? 2 : 1;
                        int num_trees = channels * rate_bytes;
                        struct hufftree8_t *trees[4];
                        for (int j = 0; j < num_trees; j++) {
                            trees[j] = create_tree8(bs);
                            if (!trees[j]) {
                                for (int k = 0; k < j; k++) {
                                    free(trees[k]);
                                }
                                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: unable to read audio huffman trees", 0, 0));
                                break;
                            }
                        }
                        if (is_16bit) {
                            uint16_t *audio_data = (uint16_t *) s->frame_data.audio[i];
                            int index = 0;
                            for (int c = 0; c < channels; c++) {
                                // Base of channels is reversed
                                audio_data[channels - c - 1] = read_byte(bs) << 8 | read_byte(bs);
                            }
                            index = channels;
                            while (index < uncompressed_length / 2) {
                                for (int c = 0; c < channels; c++) {
                                    uint16_t value = lookup_tree8(bs, trees[c * 2]);
                                    value |= lookup_tree8(bs, trees[c * 2 + 1]) << 8;
                                    audio_data[index] = value + audio_data[index - channels];
                                    index++;
                                }
                            }
                            s->frame_data.audio_len[i] = index * 2;
                        } else {
                            uint8_t *audio_data = s->frame_data.audio[i];
                            int index = 0;
                            for (int c = 0; c < channels; c++) {
                                // Base of channels is reversed
                                audio_data[channels - c - 1] = read_byte(bs);
                            }
                            index = channels;
                            while (index < uncompressed_length) {
                                for (int c = 0; c < channels; c++) {
                                    audio_data[index] = lookup_tree8(bs, trees[c]) + audio_data[index - channels];
                                    index++;
                                }
                            }
                            s->frame_data.audio_len[i] = index;
                        }
                    }
                }
            }
            data_index += track_length;
        } else {
            s->frame_data.audio_len[i] = 0;
        }
    }
    reset_escape16(s->mclr_tree);
    reset_escape16(s->mmap_tree);
    reset_escape16(s->full_tree);
    reset_escape16(s->type_tree);
    struct bitstream_t bstream;
    struct bitstream_t *bs = bitstream_init(&bstream, &frame_data[data_index], s->frame_sizes[frame_id] - data_index);
    uint8_t *video = s->frame_data.video;
    int block_type = 0;
    int chain = 0;
    uint8_t solid_color = 0;
    for (int row = 0; row < s->height; row += 4) {
        for (int col = 0; col < s->width; col += 4) {
            if (chain <= 0) {
                uint16_t type = lookup_tree16(bs, s->type_tree);
                block_type = type & 0x03;
                chain = CHAIN_SIZE[(type >> 2) & 0x3f];
                solid_color = type >> 8;
            }
            if (block_type == BLOCK_MONO) {
                uint16_t colors = lookup_tree16(bs, s->mclr_tree);
                uint8_t color1 = colors & 0xff;
                uint8_t color2 = colors >> 8;
                uint16_t map = lookup_tree16(bs, s->mmap_tree);
                for (int y = 0; y < 4; y++) {
                    uint8_t *pixel = &video[(row + y) * s->width + col];
                    pixel[0] = (map & 1) ? color2 : color1;
                    pixel[1] = (map & 2) ? color2 : color1;
                    pixel[2] = (map & 4) ? color2 : color1;
                    pixel[3] = (map & 8) ? color2 : color1;
                    map >>= 4;
                }
            } else if (block_type == BLOCK_FULL) {
                for (int y = 0; y < 4; y++) {
                    uint8_t *pixel = &video[(row + y) * s->width + col];
                    uint16_t colors = lookup_tree16(bs, s->full_tree);
                    pixel[2] = colors & 0xff;
                    pixel[3] = colors >> 8;
                    colors = lookup_tree16(bs, s->full_tree);
                    pixel[0] = colors & 0xff;
                    pixel[1] = colors >> 8;
                }
            } else if (block_type == BLOCK_SOLID) {
                for (int y = 0; y < 4; y++) {
                    uint8_t *pixel = &video[(row + y) * s->width + col];
                    pixel[0] = pixel[1] = pixel[2] = pixel[3] = solid_color;
                }
            }
            chain--;
        }
    }
    free(frame_data);
    return SMACKER_FRAME_OK;
}

static void free_node16(struct huffnode16_t *node)
{
    if (!node) {
        return;
    }
    if (!node->is_leaf) {
        free_node16(node->b[0]);
        free_node16(node->b[1]);
    }
    free(node);
}

static void free_tree16(struct hufftree16_t *tree)
{
    if (!tree) {
        return;
    }
    for (int i = 0; i < 3; i++) {
        if (tree->escape_nodes[i]) {
            if (!tree->escape_nodes[i]->is_leaf) {
                // Free manually allocated node because it's not in the tree
                free(tree->escape_nodes[i]);
            }
        }
    }
    free_node16(tree->root);
    free(tree->low);
    free(tree->high);
    free(tree);
}

static void smacker_close(smacker s)
{
    fclose(s->fp);
    free(s->frame_offsets);
    free(s->frame_sizes);
    free(s->frame_types);
    free_tree16(s->mclr_tree);
    free_tree16(s->mmap_tree);
    free_tree16(s->full_tree);
    free_tree16(s->type_tree);
    for (int i = 0; i < MAX_TRACKS; i++) {
        free(s->frame_data.audio[i]);
    }
    free(s->frame_data.video);
    free(s);
}

static void close_smk(void)
{
    if (data_video.s) {
        smacker_close(data_video.s);
        data_video.s = 0;
    }
}

static void free_custom_audio_stream(void)
{
    if (custom_music.stream) {
        SDL_FreeAudioStream(custom_music.stream);
        custom_music.stream = 0;
    }
    return;
}

static int city_figures_total_invading_enemies(void)
{
    return city_data.figure.imperial_soldiers + city_data.figure.enemies;
}

static void stop_music(void)
{
    if (data_channels.initialized) {
        if (data_channels.music) {
            Mix_HaltMusic();
            Mix_FreeMusic(data_channels.music);
            data_channels.music = 0;
        }
    }
    sound_data.current_track = TRACK_NONE;
    sound_data.next_check = 0;
}

static int play_music(char *filename, int volume_pct)
{
    if (data_channels.initialized) {
        stop_music();
        if (!filename) {
            return 0;
        }
        data_channels.music = Mix_LoadMUS(filename);
        if (!data_channels.music) {
            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION,
                "Error opening music file '%s'. Reason: %s", filename, Mix_GetError());
        } else {
            if (Mix_PlayMusic(data_channels.music, -1) == -1) {
                data_channels.music = 0;
                SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION,
                    "Error playing music file '%s'. Reason: %s", filename, Mix_GetError());
            } else {
                Mix_VolumeMusic(volume_pct * SDL_MIX_MAXVOLUME / 100);
            }
        }
        return data_channels.music ? 1 : 0;
    }
    return 0;
}

static void play_track(int track)
{
    stop_music();
    if (track <= TRACK_NONE || track >= TRACK_MAX) {
        return;
    }
    if (!play_music(mp3_tracks[track], settings_values[SETTINGS_MUSIC_VOLUME])) {
        play_music(tracks[track], settings_values[SETTINGS_MUSIC_VOLUME]);
    }
    sound_data.current_track = track;
}

static void update_music(int force)
{
    if (sound_data.next_check && !force) {
        --sound_data.next_check;
        return;
    }
    if (!settings_values[SETTINGS_MUSIC_ENABLED]) {
        return;
    }
    int track;
    int total_enemies = city_figures_total_invading_enemies();
    if (total_enemies >= 32) {
        track = TRACK_COMBAT_LONG;
    } else if (total_enemies > 0) {
        track = TRACK_COMBAT_SHORT;
    } else if (city_data.population.population < 1000) {
        track = TRACK_CITY_1;
    } else if (city_data.population.population < 2000) {
        track = TRACK_CITY_2;
    } else if (city_data.population.population < 5000) {
        track = TRACK_CITY_3;
    } else if (city_data.population.population < 7000) {
        track = TRACK_CITY_4;
    } else {
        track = TRACK_CITY_5;
    }

    if (track == sound_data.current_track) {
        return;
    }
    play_track(track);
    sound_data.next_check = 10;
}

static void end_video(void)
{
    Mix_HookMusic(0, 0);
    free_custom_audio_stream();
    if (data_video.restart_music) {
        update_music(1);
    }
}

static void write_custom_music_data(unsigned char *audio_data, int len)
{
    if (!audio_data || len <= 0 || custom_music.stream == 0) {
        return;
    }
    SDL_AudioStreamPut(custom_music.stream, audio_data, len);
}

static int get_next_frame(void)
{
    if (!data_video.s) {
        return 0;
    }
    uint32_t now_millis = current_time;
    int frame_no = (now_millis - data_video.video.start_render_millis) * 1000 / data_video.video.micros_per_frame;
    int draw_frame = data_video.video.current_frame == 0;
    while (frame_no > data_video.video.current_frame) {
        data_video.s->current_frame++;
        if (decode_frame(data_video.s) != SMACKER_FRAME_OK) {
            close_smk();
            data_video.is_ended = 1;
            data_video.is_playing = 0;
            end_video();
            return 0;
        }
        data_video.video.current_frame++;
        draw_frame = 1;

        if (data_video.audio.has_audio) {
            int audio_len = data_video.s->frame_data.audio_len[0];
            if (audio_len > 0) {
                write_custom_music_data(data_video.s->frame_data.audio[0], audio_len);
            }
        }
    }
    return draw_frame;
}

static void fade_pressed_effect(struct image_button_t *buttons, int num_buttons)
{
    for (int i = 0; i < num_buttons; i++) {
        struct image_button_t *btn = &buttons[i];
        if (btn->pressed) {
            if (current_time - btn->pressed_since > PRESSED_EFFECT_MILLIS) {
                if (btn->button_type == IB_NORMAL) {
                    btn->pressed = 0;
                } else if (btn->button_type == IB_SCROLL && !mouse_data.left.is_down) {
                    btn->pressed = 0;
                }
            }
        }
    }
}

static void image_buttons_draw(int x, int y, struct image_button_t *buttons, int num_buttons)
{
    fade_pressed_effect(buttons, num_buttons);
    for (int i = 0; i < num_buttons; i++) {
        struct image_button_t *btn = &buttons[i];
        int image_id = image_data_s.group_image_ids[btn->image_collection] + btn->image_offset;
        if (btn->enabled) {
            if (btn->pressed) {
                image_id += 2;
            } else if (btn->focused) {
                image_id += 1;
            }
        } else {
            image_id += 3;
        }
        image_draw(image_id, x + btn->x_offset, y + btn->y_offset);
    }
}

static void video_stop(void)
{
    if (data_video.is_playing) {
        if (!data_video.is_ended) {
            end_video();
        }
        close_smk();
        data_video.is_playing = 0;
    }
}

static void cleanup_message_dialog(void)
{
    if (message_dialog_data.show_video) {
        video_stop();
        message_dialog_data.show_video = 0;
    }
    player_message.message_advisor = 0;
}

static void image_draw_fullscreen_background(int image_id)
{
    int s_width = screen_data.width;
    int s_height = screen_data.height;
    struct image_t *img = image_get(image_id);
    double scale_w = screen_data.width / (double) img->width;
    double scale_h = screen_data.height / (double) img->height;
    double scale = scale_w > scale_h ? scale_w : scale_h;

    if (scale <= 1.0f) {
        image_draw(image_id, (s_width - img->width) / 2, (s_height - img->height) / 2);
    } else {
        int x_offset = (int) ((s_width - img->width * scale) / 2);
        int y_offset = (int) ((s_height - img->height * scale) / 2);
        color_t *data = image_data(image_id);
        if (!data || img->draw.type == IMAGE_TYPE_ISOMETRIC || img->draw.is_fully_compressed || !scale) {
            return;
        }
        int width = (int) (img->width * scale);
        int height = (int) (img->height * scale);
        struct clip_info_t *clip = graphics_get_clip_info(x_offset, y_offset, width, height);
        if (!clip || !clip->is_visible) {
            return;
        }
        for (int y = clip->clipped_pixels_top; y < height - clip->clipped_pixels_bottom; y++) {
            color_t *dst = graphics_get_pixel(x_offset + clip->clipped_pixels_left, y_offset + y);
            int x_max = width - clip->clipped_pixels_right;
            int image_y_offset = (int) (y / scale) * img->width;
            for (int x = clip->clipped_pixels_left; x < x_max; x++, dst++) {
                color_t pixel = data[(int) (image_y_offset + x / scale)];
                if (pixel != COLOR_SG2_TRANSPARENT) {
                    *dst = pixel;
                }
            }
        }
    }
}

static void window_advisors_draw_dialog_background(void)
{
    image_draw_fullscreen_background(image_data_s.group_image_ids[GROUP_ADVISOR_BACKGROUND]);
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    image_draw(image_data_s.group_image_ids[GROUP_PANEL_WINDOWS] + 13, 0, 432);
    for (int i = 0; i < 13; i++) {
        int selected_offset = 0;
        if (current_advisor && i == current_advisor - 1) {
            selected_offset = 13;
        }
        image_draw(image_data_s.group_image_ids[GROUP_ADVISOR_ICONS] + i + selected_offset, 48 * i + 12, 441);
    }
    set_translation(0, 0);
}

static void draw_background_advisors(void)
{
    window_advisors_draw_dialog_background();
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    advisor_height = current_advisor_window->draw_background();
    set_translation(0, 0);
}


static void window_message_dialog_show(int text_id, void (*background_callback)(void));
static void button_help_advisor(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    if (current_advisor > 0 && current_advisor < 13) {
        window_message_dialog_show(ADVISOR_TO_MESSAGE_TEXT[current_advisor], 0);
    }
}

static void button_none(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{}

static struct image_button_t help_button = {
    11, -7, 27, 27, IB_NORMAL, GROUP_CONTEXT_ICONS, 0, button_help_advisor, button_none, 0, 0, 1, 0, 0, 0 };

static void draw_foreground_advisors(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    image_buttons_draw(0, BLOCK_SIZE * (advisor_height - 2), &help_button, 1);
    set_translation(0, 0);

    if (current_advisor_window->draw_foreground) {
        set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
        current_advisor_window->draw_foreground();
        set_translation(0, 0);
    }
}

static void clear_mouse_button(struct mouse_button_t *button)
{
    button->is_down = 0;
    button->went_down = 0;
    button->went_up = 0;
    button->double_click = 0;
    button->system_change = SYSTEM_NONE;
}

static void speed_clear(struct speed_type_t *speed)
{
    speed->cumulative_delta = 0.0;
    speed->fine_position = 0.0;
    speed->desired_speed = 0.0;
    speed->current_speed = 0.0;
    speed->speed_difference = 0.0;
    speed->start_time = 0;
    speed->total_time = 0;
    speed->last_speed_check = current_time;
}

static void clear_scroll_speed(void)
{
    speed_clear(&scroll_data.speed.x);
    speed_clear(&scroll_data.speed.y);
    scroll_data.x_align_direction = SPEED_DIRECTION_STOPPED;
    scroll_data.y_align_direction = SPEED_DIRECTION_STOPPED;
}

static int scale_logical_to_pixels(int logical_value)
{
    return logical_value * scale_percentage / 100;
}

static void mouse_set_position(int x, int y)
{
    if (x != mouse_data.x || y != mouse_data.y) {
        last_click = 0;
    }
    mouse_data.x = x;
    mouse_data.y = y;
    mouse_data.is_inside_window = 1;
}

static void set_relative_mouse_mode(int enabled)
{
    if (enabled == cursor_mouse_data.enabled) {
        return;
    }
    if (enabled) {
        SDL_GetMouseState(&cursor_mouse_data.x, &cursor_mouse_data.y);
        SDL_SetRelativeMouseMode(SDL_TRUE);
        // Discard the first value, which is incorrect
        // (the first one gives the relative position to center of window)
        SDL_GetRelativeMouseState(0, 0);
    } else {
        SDL_SetRelativeMouseMode(SDL_FALSE);
        cursor_mouse_data.x = calc_bound(cursor_mouse_data.x, 0, screen_data.width - 1);
        cursor_mouse_data.y = calc_bound(cursor_mouse_data.y, 0, screen_data.height - 1);
        SDL_WarpMouseInWindow(SDL.window, scale_logical_to_pixels(cursor_mouse_data.x), scale_logical_to_pixels(cursor_mouse_data.y));
        mouse_set_position(cursor_mouse_data.x, cursor_mouse_data.y);
    }
    cursor_mouse_data.enabled = enabled;
}

static void reset_input(void)
{
    last_click = 0;
    clear_mouse_button(&mouse_data.left);
    clear_mouse_button(&mouse_data.right);
    clear_scroll_speed();
    set_relative_mouse_mode(0);
    scroll_data.is_scrolling = 0;
    scroll_data.constant_input = 0;
    scroll_data.drag.active = 0;
    scroll_data.limits.active = 0;
}

static void noop(void)
{}

static void noop_input(__attribute__((unused))   struct mouse_t *m, __attribute__((unused))   struct hotkeys_t *h)
{}

static void window_show(struct window_type_t *window)
{
    reset_input();
    increase_queue_index();
    window_data.window_queue[window_data.queue_index] = *window;
    window_data.current_window = &window_data.window_queue[window_data.queue_index];
    if (!window_data.current_window->draw_background) {
        window_data.current_window->draw_background = noop;
    }
    if (!window_data.current_window->draw_foreground) {
        window_data.current_window->draw_foreground = noop;
    }
    if (!window_data.current_window->handle_input) {
        window_data.current_window->handle_input = noop_input;
    }
    window_invalidate();
}

static double adjust_speed_for_frame_time(double delta, int adjust_for_time, uint32_t last_time)
{
    return adjust_for_time ? ((delta / (double) (current_time - last_time)) * FRAME_TIME) : delta;
}

static void speed_set_target(struct speed_type_t *speed, double new_speed, uint32_t total_time, int adjust_for_time)
{
    speed->adjust_for_time = adjust_for_time;
    if (new_speed == speed->desired_speed) {
        return;
    }
    if (total_time == SPEED_CHANGE_IMMEDIATE) {
        speed->desired_speed = new_speed;
        speed->current_speed = new_speed;
        speed->total_time = total_time;
        if (!adjust_for_time && current_time - speed->last_speed_check > 0) {
            speed->adjusted_current_speed = adjust_speed_for_frame_time(new_speed, 1, speed->last_speed_check);
        } else {
            speed->adjusted_current_speed = new_speed;
        }
        return;
    }
    speed->cumulative_delta = 0.0;
    speed->fine_position = 0.0;
    double base_speed = adjust_for_time ? speed->adjusted_current_speed : speed->current_speed;
    speed->speed_difference = base_speed - new_speed;
    speed->desired_speed = new_speed;
    speed->start_time = current_time;
    speed->total_time = total_time;
}

static void city_view_toggle_sidebar(void)
{
    if (view_data.sidebar_collapsed) {
        view_data.sidebar_collapsed = 0;
        set_viewport(0, TOP_MENU_HEIGHT, view_data.screen_width - 160, view_data.screen_height - TOP_MENU_HEIGHT);
    } else {
        view_data.sidebar_collapsed = 1;
        set_viewport(0, TOP_MENU_HEIGHT, view_data.screen_width - 40, view_data.screen_height - TOP_MENU_HEIGHT);
    }
    check_camera_boundaries();
}

static void window_city_show(void);
static void slide_finished(void)
{
    city_view_toggle_sidebar();
    window_city_show();
}

static void set_city_clip_rectangle(void)
{
    int x, y, width, height;
    city_view_get_viewport(&x, &y, &width, &height);
    graphics_set_clip_rectangle(x, y, width, height);
}

static int show_building_fire_crime(struct building_t *b)
{
    return b->type == BUILDING_PREFECTURE || b->type == BUILDING_BURNING_RUIN;
}

static int show_figure_fire(struct figure_t *f)
{
    return f->type == FIGURE_PREFECT;
}

static int get_column_height_fire(struct building_t *b)
{
    return b->fire_risk > 0 ? b->fire_risk / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_fire(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_FIRE,
        COLUMN_TYPE_RISK,
        show_building_fire_crime,
        show_figure_fire,
        get_column_height_fire,
        0,
        0
    };
    return &overlay;
}

static int show_figure_crime(struct figure_t *f)
{
    return f->type == FIGURE_PREFECT || f->type == FIGURE_PROTESTER || f->type == FIGURE_CRIMINAL || f->type == FIGURE_RIOTER;
}

static int get_column_height_crime(struct building_t *b)
{
    if (b->house_size) {
        int happiness = b->sentiment.house_happiness;
        if (happiness <= 0) {
            return 10;
        } else if (happiness <= 10) {
            return 8;
        } else if (happiness <= 20) {
            return 6;
        } else if (happiness <= 30) {
            return 4;
        } else if (happiness <= 40) {
            return 2;
        } else if (happiness < 50) {
            return 1;
        }
    }
    return NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_crime(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_CRIME,
        COLUMN_TYPE_RISK,
        show_building_fire_crime,
        show_figure_crime,
        get_column_height_crime,
        0,
        0
    };
    return &overlay;
}

static int show_building_damage(struct building_t *b)
{
    return b->type == BUILDING_ENGINEERS_POST;
}

static int show_figure_damage(struct figure_t *f)
{
    return f->type == FIGURE_ENGINEER;
}

static int get_column_height_damage(struct building_t *b)
{
    return b->damage_risk > 0 ? b->damage_risk / 20 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_damage(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_DAMAGE,
        COLUMN_TYPE_RISK,
        show_building_damage,
        show_figure_damage,
        get_column_height_damage,
        0,
        0
    };
    return &overlay;
}

static int show_building_problems(struct building_t *b)
{
    return b->show_on_problem_overlay;
}

static int show_figure_problems(struct figure_t *f)
{
    if (f->type == FIGURE_LABOR_SEEKER) {
        return all_buildings[f->building_id].show_on_problem_overlay;
    } else if (f->type == FIGURE_CART_PUSHER) {
        return f->action_state == FIGURE_ACTION_CARTPUSHER_INITIAL || f->min_max_seen;
    } else {
        return 0;
    }
}

static int get_column_height_none(__attribute__((unused))   struct building_t *b)
{
    return NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_problems(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_PROBLEMS,
        COLUMN_TYPE_RISK,
        show_building_problems,
        show_figure_problems,
        get_column_height_none,
        0,
        0
    };
    return &overlay;
}

static int show_building_native(struct building_t *b)
{
    return b->type == BUILDING_NATIVE_HUT || b->type == BUILDING_NATIVE_MEETING || b->type == BUILDING_MISSION_POST;
}

static int show_figure_native(struct figure_t *f)
{
    return f->type == FIGURE_INDIGENOUS_NATIVE || f->type == FIGURE_MISSIONARY;
}

static int terrain_on_native_overlay(void)
{
    return
        TERRAIN_SHRUB | TERRAIN_ROCK | TERRAIN_WATER | TERRAIN_TREE |
        TERRAIN_GARDEN | TERRAIN_ELEVATION | TERRAIN_ACCESS_RAMP | TERRAIN_RUBBLE;
}

static int is_drawable_farmhouse(int grid_offset, int map_orientation)
{
    if (!(edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE)) {
        return 0;
    }
    int xy = edge_grid.items[grid_offset] & EDGE_MASK_XY;
    if (map_orientation == DIR_0_TOP && xy == EDGE_X0Y1) {
        return 1;
    }
    if (map_orientation == DIR_2_RIGHT && xy == EDGE_X0Y0) {
        return 1;
    }
    if (map_orientation == DIR_4_BOTTOM && xy == EDGE_X1Y0) {
        return 1;
    }
    if (map_orientation == DIR_2_RIGHT && xy == EDGE_X1Y1) {
        return 1;
    }
    return 0;
}

static int is_drawable_farm_corner(int grid_offset)
{
    if (!(edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE)) {
        return 0;
    }

    int map_orientation = view_data.orientation;
    int xy = edge_grid.items[grid_offset] & EDGE_MASK_XY;
    if (map_orientation == DIR_0_TOP && xy == EDGE_X0Y2) {
        return 1;
    } else if (map_orientation == DIR_2_RIGHT && xy == EDGE_X0Y0) {
        return 1;
    } else if (map_orientation == DIR_4_BOTTOM && xy == EDGE_X2Y0) {
        return 1;
    } else if (map_orientation == DIR_6_LEFT && xy == EDGE_X2Y2) {
        return 1;
    }
    return 0;
}

static void city_with_overlay_draw_building_footprint(int x, int y, int grid_offset, int image_offset)
{
    int building_id = map_building_at(grid_offset);
    if (!building_id) {
        return;
    }
    struct building_t *b = &all_buildings[building_id];
    if (overlay->show_building(b)) {
        if (building_is_farm(b->type)) {
            if (is_drawable_farmhouse(grid_offset, view_data.orientation)) {
                image_draw_isometric_footprint_from_draw_tile(images.items[grid_offset], x, y, 0);
            } else if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
                image_draw_isometric_footprint_from_draw_tile(images.items[grid_offset], x, y, 0);
            }
        } else {
            image_draw_isometric_footprint_from_draw_tile(images.items[grid_offset], x, y, 0);
        }
    } else {
        int draw = 1;
        if (b->size == 3 && building_is_farm(b->type)) {
            draw = is_drawable_farm_corner(grid_offset);
        }
        if (draw) {
            int image_base = image_data_s.group_image_ids[GROUP_TERRAIN_OVERLAY] + image_offset;
            if (b->house_size) {
                image_base += 4;
            }
            if (b->size == 1) {
                image_draw_isometric_footprint_from_draw_tile(image_base, x, y, 0);
            } else if (b->size == 2) {
                int x_tile_offset[] = { 30, 0, 60, 30 };
                int y_tile_offset[] = { -15, 0, 0, 15 };
                for (int i = 0; i < 4; i++) {
                    image_draw_isometric_footprint_from_draw_tile(image_base + i,
                        x + x_tile_offset[i], y + y_tile_offset[i], 0);
                }
            } else if (b->size == 3) {
                int image_tile_offset[] = { 0, 1, 2, 1, 3, 2, 3, 3, 3 };
                int x_tile_offset[] = { 60, 30, 90, 0, 60, 120, 30, 90, 60 };
                int y_tile_offset[] = { -30, -15, -15, 0, 0, 0, 15, 15, 30 };
                for (int i = 0; i < 9; i++) {
                    image_draw_isometric_footprint_from_draw_tile(image_base + image_tile_offset[i],
                        x + x_tile_offset[i], y + y_tile_offset[i], 0);
                }
            } else if (b->size == 4) {
                int image_tile_offset[] = { 0, 1, 2, 1, 3, 2, 1, 3, 3, 2, 3, 3, 3, 3, 3, 3 };
                int x_tile_offset[] = {
                  90,
                  60, 120,
                  30, 90, 150,
                  0, 60, 120, 180,
                  30, 90, 150,
                  60, 120,
                  90
                };
                int y_tile_offset[] = {
                  -45,
                  -30, -30,
                  -15, -15, -15,
                  0, 0, 0, 0,
                  15, 15, 15,
                  30, 30,
                  45
                };
                for (int i = 0; i < 16; i++) {
                    image_draw_isometric_footprint_from_draw_tile(image_base + image_tile_offset[i],
                        x + x_tile_offset[i], y + y_tile_offset[i], 0);
                }
            } else if (b->size == 5) {
                int image_tile_offset[] = { 0, 1, 2, 1, 3, 2, 1, 3, 3, 2, 1, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
                int x_tile_offset[] = {
                  120,
                  90, 150,
                  60, 120, 180,
                  30, 90, 150, 210,
                  0, 60, 120, 180, 240,
                  30, 90, 150, 210,
                  60, 120, 180,
                  90, 150,
                  120
                };
                int y_tile_offset[] = {
                  -60,
                  -45, -45,
                  -30, -30, -30,
                  -15, -15, -15, -15,
                  0, 0, 0, 0, 0,
                  15, 15, 15, 15,
                  30, 30, 30,
                  45, 45,
                  60
                };
                for (int i = 0; i < 25; i++) {
                    image_draw_isometric_footprint_from_draw_tile(image_base + image_tile_offset[i],
                        x + x_tile_offset[i], y + y_tile_offset[i], 0);
                }
            }
        }
    }
}

static void draw_footprint_native(int x, int y, int grid_offset)
{
    if (!(edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE)) {
        return;
    }
    if (map_terrain_is(grid_offset, terrain_on_native_overlay())) {
        if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
            city_with_overlay_draw_building_footprint(x, y, grid_offset, 0);
        } else {
            image_draw_isometric_footprint_from_draw_tile(images.items[grid_offset], x, y, 0);
        }
    } else if (map_terrain_is(grid_offset, TERRAIN_AQUEDUCT | TERRAIN_WALL)) {
        // display grass
        int image_id = image_data_s.group_image_ids[GROUP_TERRAIN_GRASS_1] + (random.items[grid_offset] & 7);
        image_draw_isometric_footprint_from_draw_tile(image_id, x, y, 0);
    } else if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
        city_with_overlay_draw_building_footprint(x, y, grid_offset, 0);
    } else {
        if (edge_grid.items[grid_offset] & EDGE_NATIVE_LAND) {
            image_draw_isometric_footprint_from_draw_tile(image_data_s.group_image_ids[GROUP_TERRAIN_DESIRABILITY] + 1, x, y, 0);
        } else {
            image_draw_isometric_footprint_from_draw_tile(images.items[grid_offset], x, y, 0);
        }
    }
}

static int is_problem_cartpusher(int figure_id)
{
    if (figure_id) {
        struct figure_t *fig = &figures[figure_id];
        return fig->action_state == FIGURE_ACTION_CARTPUSHER_INITIAL && fig->min_max_seen;
    } else {
        return 0;
    }
}

static int draw_building_as_deleted_1(struct building_t *b)
{
    if (!values[CONFIG_UI_VISUAL_FEEDBACK_ON_DELETE]) {
        return 0;
    }
    b = building_main(b);
    return b->id && (b->is_deleted || bitfields_grid.items[b->grid_offset] & BIT_DELETED);
}

static void city_with_overlay_draw_building_top(int x, int y, int grid_offset)
{
    struct building_t *b = &all_buildings[map_building_at(grid_offset)];
    if (overlay->type == OVERLAY_PROBLEMS) {
        if (!b->house_size) {
            if (b->type == BUILDING_FOUNTAIN || b->type == BUILDING_BATHHOUSE) {
                if (!b->has_water_access) {
                    b->show_on_problem_overlay = 1;
                }
            } else if (b->type >= BUILDING_WHEAT_FARM && b->type <= BUILDING_CLAY_PIT) {
                if (is_problem_cartpusher(b->figure_id)) {
                    b->show_on_problem_overlay = 1;
                }
            } else if (building_is_workshop(b->type)) {
                if (is_problem_cartpusher(b->figure_id)) {
                    b->show_on_problem_overlay = 1;
                } else if (b->loads_stored <= 0) {
                    b->show_on_problem_overlay = 1;
                }
            }
        }
    }
    if (overlay->show_building(b)) {
        color_t color_mask = draw_building_as_deleted_1(b) ? COLOR_MASK_RED : 0;
        if (building_is_farm(b->type)) {
            if (is_drawable_farmhouse(grid_offset, view_data.orientation)) {
                image_draw_isometric_top_from_draw_tile(images.items[grid_offset], x, y, color_mask);
            } else if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
                image_draw_isometric_top_from_draw_tile(images.items[grid_offset], x, y, color_mask);
            }
            return;
        } else if (b->type == BUILDING_GRANARY) {
            struct image_t *img = image_get(images.items[grid_offset]);
            image_draw(image_data_s.group_image_ids[GROUP_BUILDING_GRANARY] + 1,
                x + img->sprite_offset_x, y + img->sprite_offset_y - 30 - (img->height - 90));
            if (b->data.granary.resource_stored[RESOURCE_NONE] < 2400) {
                image_draw(image_data_s.group_image_ids[GROUP_BUILDING_GRANARY] + 2, x + 33, y - 60);
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 1800) {
                    image_draw(image_data_s.group_image_ids[GROUP_BUILDING_GRANARY] + 3, x + 56, y - 50);
                }
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 1200) {
                    image_draw(image_data_s.group_image_ids[GROUP_BUILDING_GRANARY] + 4, x + 91, y - 50);
                }
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 600) {
                    image_draw(image_data_s.group_image_ids[GROUP_BUILDING_GRANARY] + 5, x + 117, y - 62);
                }
            }
        } else if (b->type == BUILDING_WAREHOUSE) {
            image_draw(image_data_s.group_image_ids[GROUP_BUILDING_WAREHOUSE] + 17, x - 4, y - 42);
        }
        if (!building_is_farm(b->type)) {
            image_draw_isometric_top_from_draw_tile(images.items[grid_offset], x, y, color_mask);
        }
    } else {
        int column_height = overlay->get_column_height(b);
        if (column_height != NO_COLUMN) {
            int draw = 1;
            if (building_is_farm(b->type)) {
                draw = is_drawable_farm_corner(grid_offset);
            }
            if (draw) {
                int image_id = image_data_s.group_image_ids[GROUP_OVERLAY_COLUMN];
                if (overlay->column_type == COLUMN_TYPE_RISK) {
                    image_id += 9;
                }
                if (column_height > 10) {
                    column_height = 10;
                }
                int capital_height = image_get(image_id)->height;
                // base
                image_draw(image_id + 2, x + 9, y - 8);
                if (column_height) {
                    // column
                    for (int i = 1; i < column_height; i++) {
                        image_draw(image_id + 1, x + 17, y - 8 - 10 * i + 13);
                    }
                    // capital
                    image_draw(image_id, x + 5, y - 8 - capital_height - 10 * (column_height - 1) + 13);
                }
            }
        }
    }
}

static void draw_top_native(int x, int y, int grid_offset)
{
    if (!(edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE)) {
        return;
    }
    if (map_terrain_is(grid_offset, terrain_on_native_overlay())) {
        if (!map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
            color_t color_mask = 0;
            if (bitfields_grid.items[grid_offset] & BIT_DELETED && map_property_multi_tile_size(grid_offset) == 1) {
                color_mask = COLOR_MASK_RED;
            }
            image_draw_isometric_top_from_draw_tile(images.items[grid_offset], x, y, color_mask);
        }
    } else if (map_building_at(grid_offset)) {
        city_with_overlay_draw_building_top(x, y, grid_offset);
    }
}

static int show_building_entertainment(struct building_t *b)
{
    return
        b->type == BUILDING_ACTOR_COLONY || b->type == BUILDING_THEATER ||
        b->type == BUILDING_GLADIATOR_SCHOOL || b->type == BUILDING_AMPHITHEATER ||
        b->type == BUILDING_LION_HOUSE || b->type == BUILDING_COLOSSEUM ||
        b->type == BUILDING_CHARIOT_MAKER || b->type == BUILDING_HIPPODROME;
}

static int show_figure_entertainment(struct figure_t *f)
{
    return f->type == FIGURE_ACTOR || f->type == FIGURE_GLADIATOR ||
        f->type == FIGURE_LION_TAMER || f->type == FIGURE_CHARIOTEER;
}

static int get_column_height_entertainment(struct building_t *b)
{
    return b->house_size && b->data.house.entertainment ? b->data.house.entertainment / 10 : NO_COLUMN;
}


static   struct city_overlay_t *city_overlay_for_entertainment(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_ENTERTAINMENT,
        COLUMN_TYPE_ACCESS,
        show_building_entertainment,
        show_figure_entertainment,
        get_column_height_entertainment,
        0,
        0
    };
    return &overlay;
}

static int show_building_theater(struct building_t *b)
{
    return b->type == BUILDING_ACTOR_COLONY || b->type == BUILDING_THEATER;
}

static struct building_t *get_entertainment_building(struct figure_t *f)
{
    if (f->action_state == FIGURE_ACTION_ENTERTAINER_ROAMING ||
        f->action_state == FIGURE_ACTION_ENTERTAINER_RETURNING) {
        return &all_buildings[f->building_id];
    } else { // going to venue
        return &all_buildings[f->destination_building_id];
    }
}

static int show_figure_theater(struct figure_t *f)
{
    if (f->type == FIGURE_ACTOR) {
        return get_entertainment_building(f)->type == BUILDING_THEATER;
    }
    return 0;
}

static int get_column_height_theater(struct building_t *b)
{
    return b->house_size && b->data.house.theater ? b->data.house.theater / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_theater(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_THEATER,
        COLUMN_TYPE_ACCESS,
        show_building_theater,
        show_figure_theater,
        get_column_height_theater,
        0,
        0
    };
    return &overlay;
}

static int show_building_amphitheater(struct building_t *b)
{
    return b->type == BUILDING_ACTOR_COLONY
        || b->type == BUILDING_GLADIATOR_SCHOOL
        || b->type == BUILDING_AMPHITHEATER;
}

static int show_figure_amphitheater(struct figure_t *f)
{
    if (f->type == FIGURE_ACTOR || f->type == FIGURE_GLADIATOR) {
        return get_entertainment_building(f)->type == BUILDING_AMPHITHEATER;
    }
    return 0;
}

static int get_column_height_amphitheater(struct building_t *b)
{
    return b->house_size && b->data.house.amphitheater_actor ? b->data.house.amphitheater_actor / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_amphitheater(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_AMPHITHEATER,
        COLUMN_TYPE_ACCESS,
        show_building_amphitheater,
        show_figure_amphitheater,
        get_column_height_amphitheater,
        0,
        0
    };
    return &overlay;
}

static int show_building_colosseum(struct building_t *b)
{
    return b->type == BUILDING_GLADIATOR_SCHOOL || b->type == BUILDING_LION_HOUSE || b->type == BUILDING_COLOSSEUM;
}

static int show_figure_colosseum(struct figure_t *f)
{
    if (f->type == FIGURE_GLADIATOR) {
        return get_entertainment_building(f)->type == BUILDING_COLOSSEUM;
    } else if (f->type == FIGURE_LION_TAMER) {
        return 1;
    }
    return 0;
}

static int get_column_height_colosseum(struct building_t *b)
{
    return b->house_size && b->data.house.colosseum_gladiator ? b->data.house.colosseum_gladiator / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_colosseum(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_COLOSSEUM,
        COLUMN_TYPE_ACCESS,
        show_building_colosseum,
        show_figure_colosseum,
        get_column_height_colosseum,
        0,
        0
    };
    return &overlay;
}

static int show_building_hippodrome(struct building_t *b)
{
    return b->type == BUILDING_CHARIOT_MAKER || b->type == BUILDING_HIPPODROME;
}

static int show_figure_hippodrome(struct figure_t *f)
{
    return f->type == FIGURE_CHARIOTEER;
}

static int get_column_height_hippodrome(struct building_t *b)
{
    return b->house_size && b->data.house.hippodrome ? b->data.house.hippodrome / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_hippodrome(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_HIPPODROME,
        COLUMN_TYPE_ACCESS,
        show_building_hippodrome,
        show_figure_hippodrome,
        get_column_height_hippodrome,
        0,
        0
    };
    return &overlay;
}

static int show_building_education(struct building_t *b)
{
    return b->type == BUILDING_SCHOOL || b->type == BUILDING_LIBRARY || b->type == BUILDING_ACADEMY;
}

static int show_figure_education(struct figure_t *f)
{
    return f->type == FIGURE_SCHOOL_CHILD || f->type == FIGURE_LIBRARIAN || f->type == FIGURE_TEACHER;
}

static int get_column_height_education(struct building_t *b)
{
    return b->house_size && b->data.house.education ? b->data.house.education * 3 - 1 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_education(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_EDUCATION,
        COLUMN_TYPE_ACCESS,
        show_building_education,
        show_figure_education,
        get_column_height_education,
        0,
        0
    };
    return &overlay;
}

static int show_building_school(struct building_t *b)
{
    return b->type == BUILDING_SCHOOL;
}

static int show_figure_school(struct figure_t *f)
{
    return f->type == FIGURE_SCHOOL_CHILD;
}

static int get_column_height_school(struct building_t *b)
{
    return b->house_size && b->data.house.school ? b->data.house.school / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_school(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_SCHOOL,
        COLUMN_TYPE_ACCESS,
        show_building_school,
        show_figure_school,
        get_column_height_school,
        0,
        0
    };
    return &overlay;
}

static int show_building_library(struct building_t *b)
{
    return b->type == BUILDING_LIBRARY;
}

static int show_figure_library(struct figure_t *f)
{
    return f->type == FIGURE_LIBRARIAN;
}

static int get_column_height_library(struct building_t *b)
{
    return b->house_size && b->data.house.library ? b->data.house.library / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_library(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_LIBRARY,
        COLUMN_TYPE_ACCESS,
        show_building_library,
        show_figure_library,
        get_column_height_library,
        0,
        0
    };
    return &overlay;
}

static int show_building_academy(struct building_t *b)
{
    return b->type == BUILDING_ACADEMY;
}

static int show_figure_academy(struct figure_t *f)
{
    return f->type == FIGURE_TEACHER;
}

static int get_column_height_academy(struct building_t *b)
{
    return b->house_size && b->data.house.academy ? b->data.house.academy / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_academy(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_ACADEMY,
        COLUMN_TYPE_ACCESS,
        show_building_academy,
        show_figure_academy,
        get_column_height_academy,
        0,
        0
    };
    return &overlay;
}

static int show_building_barber(struct building_t *b)
{
    return b->type == BUILDING_BARBER;
}

static int show_figure_barber(struct figure_t *f)
{
    return f->type == FIGURE_BARBER;
}

static int get_column_height_barber(struct building_t *b)
{
    return b->house_size && b->data.house.barber ? b->data.house.barber / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_barber(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_BARBER,
        COLUMN_TYPE_ACCESS,
        show_building_barber,
        show_figure_barber,
        get_column_height_barber,
        0,
        0
    };
    return &overlay;
}

static int show_building_bathhouse(struct building_t *b)
{
    return b->type == BUILDING_BATHHOUSE;
}

static int show_figure_bathhouse(struct figure_t *f)
{
    return f->type == FIGURE_BATHHOUSE_WORKER;
}

static int get_column_height_bathhouse(struct building_t *b)
{
    return b->house_size && b->data.house.bathhouse ? b->data.house.bathhouse / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_bathhouse(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_BATHHOUSE,
        COLUMN_TYPE_ACCESS,
        show_building_bathhouse,
        show_figure_bathhouse,
        get_column_height_bathhouse,
        0,
        0
    };
    return &overlay;
}

static int show_building_clinic(struct building_t *b)
{
    return b->type == BUILDING_DOCTOR;
}

static int show_figure_clinic(struct figure_t *f)
{
    return f->type == FIGURE_DOCTOR;
}

static int get_column_height_clinic(struct building_t *b)
{
    return b->house_size && b->data.house.clinic ? b->data.house.clinic / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_clinic(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_CLINIC,
        COLUMN_TYPE_ACCESS,
        show_building_clinic,
        show_figure_clinic,
        get_column_height_clinic,
        0,
        0
    };
    return &overlay;
}

static int show_building_hospital(struct building_t *b)
{
    return b->type == BUILDING_HOSPITAL;
}

static int show_figure_hospital(struct figure_t *f)
{
    return f->type == FIGURE_SURGEON;
}

static int get_column_height_hospital(struct building_t *b)
{
    return b->house_size && b->data.house.hospital ? b->data.house.hospital / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_hospital(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_HOSPITAL,
        COLUMN_TYPE_ACCESS,
        show_building_hospital,
        show_figure_hospital,
        get_column_height_hospital,
        0,
        0
    };
    return &overlay;
}

static int show_building_religion(struct building_t *b)
{
    return
        b->type == BUILDING_ORACLE || b->type == BUILDING_SMALL_TEMPLE_CERES ||
        b->type == BUILDING_SMALL_TEMPLE_NEPTUNE || b->type == BUILDING_SMALL_TEMPLE_MERCURY ||
        b->type == BUILDING_SMALL_TEMPLE_MARS || b->type == BUILDING_SMALL_TEMPLE_VENUS ||
        b->type == BUILDING_LARGE_TEMPLE_CERES || b->type == BUILDING_LARGE_TEMPLE_NEPTUNE ||
        b->type == BUILDING_LARGE_TEMPLE_MERCURY || b->type == BUILDING_LARGE_TEMPLE_MARS ||
        b->type == BUILDING_LARGE_TEMPLE_VENUS;
}

static int show_figure_religion(struct figure_t *f)
{
    return f->type == FIGURE_PRIEST;
}

static int get_column_height_religion(struct building_t *b)
{
    return b->house_size && b->data.house.num_gods ? b->data.house.num_gods * 17 / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_religion(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_RELIGION,
        COLUMN_TYPE_ACCESS,
        show_building_religion,
        show_figure_religion,
        get_column_height_religion,
        0,
        0
    };
    return &overlay;
}

static int show_building_tax_income(struct building_t *b)
{
    return b->type == BUILDING_FORUM || b->type == BUILDING_SENATE;
}

static int show_figure_tax_income(struct figure_t *f)
{
    return f->type == FIGURE_TAX_COLLECTOR;
}

static int calc_adjust_with_percentage(int value, int percentage)
{
    return percentage * value / 100;
}

static int get_column_height_tax_income(struct building_t *b)
{
    if (b->house_size) {
        int pct = calc_adjust_with_percentage(b->tax_income_or_storage / 2, city_data.finance.tax_percentage);
        if (pct > 0) {
            return pct / 25;
        }
    }
    return NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_tax_income(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_TAX_INCOME,
        COLUMN_TYPE_ACCESS,
        show_building_tax_income,
        show_figure_tax_income,
        get_column_height_tax_income,
        0,
        0
    };
    return &overlay;
}

static int show_building_food_stocks(struct building_t *b)
{
    return b->type == BUILDING_MARKET || b->type == BUILDING_WHARF || b->type == BUILDING_GRANARY;
}

static int resource_is_food(int resource)
{
    return resource == RESOURCE_WHEAT || resource == RESOURCE_VEGETABLES ||
        resource == RESOURCE_FRUIT || resource == RESOURCE_MEAT;
}

static int show_figure_food_stocks(struct figure_t *f)
{
    if (f->type == FIGURE_MARKET_BUYER || f->type == FIGURE_MARKET_TRADER ||
        f->type == FIGURE_DELIVERY_BOY || f->type == FIGURE_FISHING_BOAT) {
        return 1;
    } else if (f->type == FIGURE_CART_PUSHER) {
        return resource_is_food(f->resource_id);
    }
    return 0;
}

static int get_column_height_food_stocks(struct building_t *b)
{
    if (b->house_size && house_properties[b->subtype.house_level].food_types) {
        int pop = b->house_population;
        int stocks = 0;
        for (int i = INVENTORY_WHEAT; i <= INVENTORY_MEAT; i++) {
            stocks += b->data.house.inventory[i];
        }
        int pct_stocks = calc_percentage(stocks, pop);
        if (pct_stocks <= 0) {
            return 10;
        } else if (pct_stocks < 100) {
            return 5;
        } else if (pct_stocks <= 200) {
            return 1;
        }
    }
    return NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_food_stocks(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_FOOD_STOCKS,
        COLUMN_TYPE_RISK,
        show_building_food_stocks,
        show_figure_food_stocks,
        get_column_height_food_stocks,
        0,
        0
    };
    return &overlay;
}

static int show_building_water(struct building_t *b)
{
    return b->type == BUILDING_WELL || b->type == BUILDING_FOUNTAIN || b->type == BUILDING_RESERVOIR;
}

static int show_figure_none(__attribute__((unused))   struct figure_t *f)
{
    return 0;
}

static int terrain_on_water_overlay(void)
{
    return
        TERRAIN_SHRUB | TERRAIN_ROCK | TERRAIN_WATER | TERRAIN_TREE |
        TERRAIN_GARDEN | TERRAIN_ROAD | TERRAIN_AQUEDUCT | TERRAIN_ELEVATION |
        TERRAIN_ACCESS_RAMP | TERRAIN_RUBBLE;
}

static void draw_footprint_water(int x, int y, int grid_offset)
{
    if (!(edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE)) {
        return;
    }
    if (map_terrain_is(grid_offset, terrain_on_water_overlay())) {
        if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
            city_with_overlay_draw_building_footprint(x, y, grid_offset, 0);
        } else {
            image_draw_isometric_footprint_from_draw_tile(images.items[grid_offset], x, y, 0);
        }
    } else if (map_terrain_is(grid_offset, TERRAIN_WALL)) {
        // display grass
        int image_id = image_data_s.group_image_ids[GROUP_TERRAIN_GRASS_1] + (random.items[grid_offset] & 7);
        image_draw_isometric_footprint_from_draw_tile(image_id, x, y, 0);
    } else if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
        struct building_t *b = &all_buildings[map_building_at(grid_offset)];
        int terrain = terrain_grid.items[grid_offset];
        if (b->id && (b->has_well_access || (b->house_size && b->has_water_access))) {
            terrain |= TERRAIN_FOUNTAIN_RANGE;
        }
        int image_offset;
        switch (terrain & (TERRAIN_RESERVOIR_RANGE | TERRAIN_FOUNTAIN_RANGE)) {
            case TERRAIN_RESERVOIR_RANGE | TERRAIN_FOUNTAIN_RANGE:
                image_offset = 24;
                break;
            case TERRAIN_RESERVOIR_RANGE:
                image_offset = 8;
                break;
            case TERRAIN_FOUNTAIN_RANGE:
                image_offset = 16;
                break;
            default:
                image_offset = 0;
                break;
        }
        city_with_overlay_draw_building_footprint(x, y, grid_offset, image_offset);
    } else {
        int image_id = image_data_s.group_image_ids[GROUP_TERRAIN_OVERLAY];
        switch (terrain_grid.items[grid_offset] & (TERRAIN_RESERVOIR_RANGE | TERRAIN_FOUNTAIN_RANGE)) {
            case TERRAIN_RESERVOIR_RANGE | TERRAIN_FOUNTAIN_RANGE:
                image_id += 27;
                break;
            case TERRAIN_RESERVOIR_RANGE:
                image_id += 11;
                break;
            case TERRAIN_FOUNTAIN_RANGE:
                image_id += 19;
                break;
            default:
                image_id = images.items[grid_offset];
                break;
        }
        image_draw_isometric_footprint_from_draw_tile(image_id, x, y, 0);
    }
}

static void draw_top_water(int x, int y, int grid_offset)
{
    if (!(edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE)) {
        return;
    }
    if (map_terrain_is(grid_offset, terrain_on_water_overlay())) {
        if (!map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
            color_t color_mask = 0;
            if (bitfields_grid.items[grid_offset] & BIT_DELETED && map_property_multi_tile_size(grid_offset) == 1) {
                color_mask = COLOR_MASK_RED;
            }
            image_draw_isometric_top_from_draw_tile(images.items[grid_offset], x, y, color_mask);
        }
    } else if (map_building_at(grid_offset)) {
        city_with_overlay_draw_building_top(x, y, grid_offset);
    }
}

static   struct city_overlay_t *city_overlay_for_water(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_WATER,
        COLUMN_TYPE_ACCESS,
        show_building_water,
        show_figure_none,
        get_column_height_none,
        draw_footprint_water,
        draw_top_water
    };
    return &overlay;
}

static int show_building_desirability(__attribute__((unused))   struct building_t *b)
{
    return 0;
}

static int terrain_on_desirability_overlay(void)
{
    return
        TERRAIN_SHRUB | TERRAIN_ROCK | TERRAIN_WATER |
        TERRAIN_TREE | TERRAIN_GARDEN | TERRAIN_ROAD |
        TERRAIN_ELEVATION | TERRAIN_ACCESS_RAMP | TERRAIN_RUBBLE;
}

static int has_deleted_building(int grid_offset)
{
    if (!values[CONFIG_UI_VISUAL_FEEDBACK_ON_DELETE]) {
        return 0;
    }
    struct building_t *b = &all_buildings[map_building_at(grid_offset)];
    b = building_main(b);
    return b->id && (b->is_deleted || bitfields_grid.items[b->grid_offset] & BIT_DELETED);
}

static int get_desirability_image_offset(int desirability)
{
    if (desirability < -10) {
        return 0;
    } else if (desirability < -5) {
        return 1;
    } else if (desirability < 0) {
        return 2;
    } else if (desirability == 1) {
        return 3;
    } else if (desirability < 5) {
        return 4;
    } else if (desirability < 10) {
        return 5;
    } else if (desirability < 15) {
        return 6;
    } else if (desirability < 20) {
        return 7;
    } else if (desirability < 25) {
        return 8;
    } else {
        return 9;
    }
}

static void draw_footprint_desirability(int x, int y, int grid_offset)
{
    color_t color_mask = bitfields_grid.items[grid_offset] & BIT_DELETED ? COLOR_MASK_RED : 0;
    if (map_terrain_is(grid_offset, terrain_on_desirability_overlay())
        && !map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
        // display normal tile
        if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
            image_draw_isometric_footprint_from_draw_tile(images.items[grid_offset], x, y, color_mask);
        }
    } else if (map_terrain_is(grid_offset, TERRAIN_AQUEDUCT | TERRAIN_WALL)) {
        // display empty land/grass
        int image_id = image_data_s.group_image_ids[GROUP_TERRAIN_GRASS_1] + (random.items[grid_offset] & 7);
        image_draw_isometric_footprint_from_draw_tile(image_id, x, y, color_mask);
    } else if (map_terrain_is(grid_offset, TERRAIN_BUILDING) || desirability_grid.items[grid_offset]) {
        if (has_deleted_building(grid_offset)) {
            color_mask = COLOR_MASK_RED;
        }
        int offset = get_desirability_image_offset(desirability_grid.items[grid_offset]);
        image_draw_isometric_footprint_from_draw_tile(
            image_data_s.group_image_ids[GROUP_TERRAIN_DESIRABILITY] + offset, x, y, color_mask);
    } else {
        image_draw_isometric_footprint_from_draw_tile(images.items[grid_offset], x, y, color_mask);
    }
}

static void draw_top_desirability(int x, int y, int grid_offset)
{
    color_t color_mask = bitfields_grid.items[grid_offset] & BIT_DELETED ? COLOR_MASK_RED : 0;
    if (map_terrain_is(grid_offset, terrain_on_desirability_overlay())
        && !map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
        // display normal tile
        if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
            image_draw_isometric_top_from_draw_tile(images.items[grid_offset], x, y, color_mask);
        }
    } else if (map_terrain_is(grid_offset, TERRAIN_AQUEDUCT | TERRAIN_WALL)) {
        // grass, no top needed
    } else if (map_terrain_is(grid_offset, TERRAIN_BUILDING) || desirability_grid.items[grid_offset]) {
        if (has_deleted_building(grid_offset)) {
            color_mask = COLOR_MASK_RED;
        }
        int offset = get_desirability_image_offset(desirability_grid.items[grid_offset]);
        image_draw_isometric_top_from_draw_tile(image_data_s.group_image_ids[GROUP_TERRAIN_DESIRABILITY] + offset, x, y, color_mask);
    } else {
        image_draw_isometric_top_from_draw_tile(images.items[grid_offset], x, y, color_mask);
    }
}

static   struct city_overlay_t *city_overlay_for_desirability(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_DESIRABILITY,
        COLUMN_TYPE_ACCESS,
        show_building_desirability,
        show_figure_none,
        get_column_height_none,
        draw_footprint_desirability,
        draw_top_desirability
    };
    return &overlay;
}

static int select_city_overlay(void)
{
    if (!overlay || overlay->type != state_data.current_overlay) {
        overlay = 0;
        switch (state_data.current_overlay) {
            case OVERLAY_FIRE:
                overlay = city_overlay_for_fire();
                break;
            case OVERLAY_CRIME:
                overlay = city_overlay_for_crime();
                break;
            case OVERLAY_DAMAGE:
                overlay = city_overlay_for_damage();
                break;
            case OVERLAY_PROBLEMS:
                overlay = city_overlay_for_problems();
                break;
            case OVERLAY_NATIVE:
                overlay->type = OVERLAY_NATIVE;
                overlay->column_type = COLUMN_TYPE_RISK;
                overlay->show_building = show_building_native;
                overlay->show_figure = show_figure_native;
                overlay->get_column_height = get_column_height_none;
                overlay->draw_custom_footprint = draw_footprint_native;
                overlay->draw_custom_top = draw_top_native;
                break;
            case OVERLAY_ENTERTAINMENT:
                overlay = city_overlay_for_entertainment();
                break;
            case OVERLAY_THEATER:
                overlay = city_overlay_for_theater();
                break;
            case OVERLAY_AMPHITHEATER:
                overlay = city_overlay_for_amphitheater();
                break;
            case OVERLAY_COLOSSEUM:
                overlay = city_overlay_for_colosseum();
                break;
            case OVERLAY_HIPPODROME:
                overlay = city_overlay_for_hippodrome();
                break;
            case OVERLAY_EDUCATION:
                overlay = city_overlay_for_education();
                break;
            case OVERLAY_SCHOOL:
                overlay = city_overlay_for_school();
                break;
            case OVERLAY_LIBRARY:
                overlay = city_overlay_for_library();
                break;
            case OVERLAY_ACADEMY:
                overlay = city_overlay_for_academy();
                break;
            case OVERLAY_BARBER:
                overlay = city_overlay_for_barber();
                break;
            case OVERLAY_BATHHOUSE:
                overlay = city_overlay_for_bathhouse();
                break;
            case OVERLAY_CLINIC:
                overlay = city_overlay_for_clinic();
                break;
            case OVERLAY_HOSPITAL:
                overlay = city_overlay_for_hospital();
                break;
            case OVERLAY_RELIGION:
                overlay = city_overlay_for_religion();
                break;
            case OVERLAY_TAX_INCOME:
                overlay = city_overlay_for_tax_income();
                break;
            case OVERLAY_FOOD_STOCKS:
                overlay = city_overlay_for_food_stocks();
                break;
            case OVERLAY_WATER:
                overlay = city_overlay_for_water();
                break;
            case OVERLAY_DESIRABILITY:
                overlay = city_overlay_for_desirability();
                break;
            default:
                break;
        }
    }
    return overlay != 0;
}

static void draw_footprint_with_overlay(int x, int y, int grid_offset)
{
    building_construction_record_view_position(x, y, grid_offset);
    if (grid_offset < 0) {
        // Outside map: draw black tile
        image_draw_isometric_footprint_from_draw_tile(image_data_s.group_image_ids[GROUP_TERRAIN_BLACK], x, y, 0);
    } else if (overlay->draw_custom_footprint) {
        overlay->draw_custom_footprint(x, y, grid_offset);
    } else if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
        if (terrain_grid.items[grid_offset] & (TERRAIN_AQUEDUCT | TERRAIN_WALL)) {
            // display grass
            int image_id = image_data_s.group_image_ids[GROUP_TERRAIN_GRASS_1] + (random.items[grid_offset] & 7);
            image_draw_isometric_footprint_from_draw_tile(image_id, x, y, 0);
        } else if ((terrain_grid.items[grid_offset] & TERRAIN_ROAD) && !(terrain_grid.items[grid_offset] & TERRAIN_BUILDING)) {
            image_draw_isometric_footprint_from_draw_tile(images.items[grid_offset], x, y, 0);
        } else if (terrain_grid.items[grid_offset] & TERRAIN_BUILDING) {
            city_with_overlay_draw_building_footprint(x, y, grid_offset, 0);
        } else {
            image_draw_isometric_footprint_from_draw_tile(images.items[grid_offset], x, y, 0);
        }
    }
}

static void draw_figures_with_overlay(int x, int y, int grid_offset)
{
    int figure_id = map_grid_is_valid_offset(grid_offset) ? map_figures.items[grid_offset] : 0;
    while (figure_id) {
        struct figure_t *f = &figures[figure_id];
        if (!f->is_invisible && overlay->show_figure(f)) {
            city_draw_figure(f, x, y, 0);
        }
        figure_id = f->next_figure_id_on_same_tile;
    }
}

static void draw_top_with_overlay(int x, int y, int grid_offset)
{
    if (overlay->draw_custom_top) {
        overlay->draw_custom_top(x, y, grid_offset);
    } else if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
        if (!map_terrain_is(grid_offset, TERRAIN_WALL | TERRAIN_AQUEDUCT | TERRAIN_ROAD)) {
            if (map_terrain_is(grid_offset, TERRAIN_BUILDING) && map_building_at(grid_offset)) {
                city_with_overlay_draw_building_top(x, y, grid_offset);
            } else if (!map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
                color_t color_mask = 0;
                if (bitfields_grid.items[grid_offset] & BIT_DELETED && !is_multi_tile_terrain(grid_offset)) {
                    color_mask = COLOR_MASK_RED;
                }
                // terrain
                image_draw_isometric_top_from_draw_tile(images.items[grid_offset], x, y, color_mask);
            }
        }
    }
}

static void draw_animation_with_overlay(int x, int y, int grid_offset)
{
    int draw = 0;
    if (map_building_at(grid_offset)) {
        int btype = all_buildings[map_building_at(grid_offset)].type;
        switch (overlay->type) {
            case OVERLAY_FIRE:
            case OVERLAY_CRIME:
                if (btype == BUILDING_PREFECTURE || btype == BUILDING_BURNING_RUIN) {
                    draw = 1;
                }
                break;
            case OVERLAY_DAMAGE:
                if (btype == BUILDING_ENGINEERS_POST) {
                    draw = 1;
                }
                break;
            case OVERLAY_WATER:
                if (btype == BUILDING_RESERVOIR || btype == BUILDING_FOUNTAIN) {
                    draw = 1;
                }
                break;
            case OVERLAY_FOOD_STOCKS:
                if (btype == BUILDING_MARKET || btype == BUILDING_GRANARY) {
                    draw = 1;
                }
                break;
        }
    }

    struct image_t *img = image_get(images.items[grid_offset]);
    if (img->num_animation_sprites && draw) {
        if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
            struct building_t *b = &all_buildings[map_building_at(grid_offset)];
            int color_mask = draw_building_as_deleted_1(b) ? COLOR_MASK_RED : 0;
            if (b->type == BUILDING_GRANARY) {
                image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_GRANARY] + 1,
                                  x + img->sprite_offset_x,
                                  y + 60 + img->sprite_offset_y - img->height,
                                  color_mask);
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 2400) {
                    image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_GRANARY] + 2, x + 33, y - 60, color_mask);
                }
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 1800) {
                    image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_GRANARY] + 3, x + 56, y - 50, color_mask);
                }
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 1200) {
                    image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_GRANARY] + 4, x + 91, y - 50, color_mask);
                }
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 600) {
                    image_draw_masked(image_data_s.group_image_ids[GROUP_BUILDING_GRANARY] + 5, x + 117, y - 62, color_mask);
                }
            } else {
                int animation_offset = building_animation_offset(b, images.items[grid_offset], grid_offset);
                if (animation_offset > 0) {
                    if (animation_offset > img->num_animation_sprites) {
                        animation_offset = img->num_animation_sprites;
                    }
                    int ydiff = 0;
                    switch (map_property_multi_tile_size(grid_offset)) {
                        case 1: ydiff = 30; break;
                        case 2: ydiff = 45; break;
                        case 3: ydiff = 60; break;
                        case 4: ydiff = 75; break;
                        case 5: ydiff = 90; break;
                    }
                    image_draw_masked(images.items[grid_offset] + animation_offset,
                                      x + img->sprite_offset_x,
                                      y + ydiff + img->sprite_offset_y - img->height,
                                      color_mask);
                }
            }
        }
    } else if (map_is_bridge(grid_offset)) {
        city_draw_bridge(x, y, grid_offset);
    }
}

static void draw_elevated_figures_with_overlay(int x, int y, int grid_offset)
{
    int figure_id = map_grid_is_valid_offset(grid_offset) ? map_figures.items[grid_offset] : 0;
    while (figure_id > 0) {
        struct figure_t *f = &figures[figure_id];
        if (((f->use_cross_country && !f->is_invisible) || f->height_adjusted_ticks) && overlay->show_figure(f)) {
            city_draw_figure(f, x, y, 0);
        }
        figure_id = f->next_figure_id_on_same_tile;
    }
}

static int should_draw_top_before_deletion_with_overlay(int grid_offset)
{
    int has_adjacent_deletion = 0;
    int size = map_property_multi_tile_size(grid_offset);
    int total_adjacent_offsets = size * 2 + 1;
    int *adjacent_offset = ADJACENT_OFFSETS[size - 1][view_data.orientation / 2];
    for (int i = 0; i < total_adjacent_offsets; ++i) {
        if ((bitfields_grid.items[grid_offset + adjacent_offset[i]] & BIT_DELETED) || draw_building_as_deleted_1(&all_buildings[map_building_at(grid_offset + adjacent_offset[i])])) {
            has_adjacent_deletion = 1;
            break;
        }
    }
    return is_multi_tile_terrain(grid_offset) && has_adjacent_deletion;
}

static void deletion_draw_terrain_top_with_overlay(int x, int y, int grid_offset)
{
    if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE && should_draw_top_before_deletion_with_overlay(grid_offset)) {
        draw_top_with_overlay(x, y, grid_offset);
    }
}

static void deletion_draw_animations(int x, int y, int grid_offset)
{
    if (bitfields_grid.items[grid_offset] & BIT_DELETED || draw_building_as_deleted_1(&all_buildings[map_building_at(grid_offset)])) {
        image_draw_blend(image_data_s.group_image_ids[GROUP_TERRAIN_FLAT_TILE], x, y, COLOR_MASK_RED);
    }
    if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE && !should_draw_top_before_deletion_with_overlay(grid_offset)) {
        draw_top_with_overlay(x, y, grid_offset);
    }
    draw_animation_with_overlay(x, y, grid_offset);
}

static void widget_city_draw(void)
{
    set_city_clip_rectangle();
    if (state_data.current_overlay && select_city_overlay()) {
        int should_mark_deleting = city_building_ghost_mark_deleting(&widget_city_data.current_tile);
        city_view_foreach_map_tile(draw_footprint_with_overlay);
        if (!should_mark_deleting) {
            city_view_foreach_valid_map_tile(
                draw_figures_with_overlay,
                draw_top_with_overlay,
                draw_animation_with_overlay
            );
            city_building_ghost_draw(&widget_city_data.current_tile);
            city_view_foreach_map_tile(draw_elevated_figures_with_overlay);
        } else {
            city_view_foreach_map_tile(draw_figures_with_overlay);
            city_view_foreach_map_tile(deletion_draw_terrain_top_with_overlay);
            city_view_foreach_map_tile(deletion_draw_animations);
            city_view_foreach_map_tile(draw_elevated_figures_with_overlay);
        }
    } else {
        city_without_overlay_draw(0, 0, &widget_city_data.current_tile);
    }
    graphics_reset_clip_rectangle();
}

static double adjust_speed_for_elapsed_time(double delta, int adjust_for_time, uint32_t last_time)
{
    return adjust_for_time ? (delta / FRAME_TIME) * (current_time - last_time) : delta;
}

static int speed_get_delta(struct speed_type_t *speed)
{
    if (speed->adjust_for_time && speed->last_speed_check == current_time) {
        return 0;
    }
    double delta;
    uint32_t elapsed = current_time - speed->start_time;
    double desired = 0.0;
    desired = adjust_speed_for_elapsed_time(speed->desired_speed, speed->adjust_for_time, speed->last_speed_check);
    if (speed->total_time == SPEED_CHANGE_IMMEDIATE) {
        delta = desired;
    } else if (speed->current_speed == speed->desired_speed || elapsed > speed->total_time * 4) {
        delta = desired;
        speed->current_speed = speed->desired_speed;
        speed->adjusted_current_speed = speed->desired_speed;
    } else {
        if (elapsed == 0) {
            delta = adjust_speed_for_elapsed_time(
                speed->current_speed, speed->adjust_for_time, speed->last_speed_check);
        } else {
            double full_delta = speed->speed_difference * (speed->total_time / FRAME_TIME);
            double exponent = exp(-((int) elapsed) / (double) speed->total_time);
            delta = full_delta - full_delta * exponent - speed->cumulative_delta;
            speed->cumulative_delta += delta;
            delta += desired;
            speed->current_speed = adjust_speed_for_frame_time(delta, speed->adjust_for_time, speed->last_speed_check);
            speed->adjusted_current_speed = speed->current_speed;
        }
    }
    speed->last_speed_check = current_time;
    int delta_rounded = (int) delta;
    speed->fine_position += delta - delta_rounded;
    int extra_position = (int) speed->fine_position;
    speed->fine_position -= extra_position;
    return delta_rounded + extra_position;
}

static void draw_sliding_foreground(void)
{
    window_data.refresh_on_draw = 1;
    widget_slide_data.position += speed_get_delta(&widget_slide_data.slide_speed);
    int is_finished = 0;
    if (widget_slide_data.position >= SIDEBAR_EXPANDED_WIDTH) {
        widget_slide_data.position = SIDEBAR_EXPANDED_WIDTH;
        is_finished = 1;
    }
    int x_offset = screen_data.width - SIDEBAR_EXPANDED_WIDTH;
    graphics_set_clip_rectangle(x_offset, TOP_MENU_HEIGHT, SIDEBAR_EXPANDED_WIDTH, screen_data.height - TOP_MENU_HEIGHT);

    if (widget_slide_data.direction == SLIDE_DIRECTION_IN) {
        if (widget_slide_data.position > SIDEBAR_DECELERATION_OFFSET) {
            speed_set_target(&widget_slide_data.slide_speed, 1, SLIDE_ACCELERATION_MILLIS, 1);
        }
        x_offset += SIDEBAR_EXPANDED_WIDTH - widget_slide_data.position;
    } else {
        x_offset += widget_slide_data.position;
    }
    widget_slide_data.back_sidebar_draw();
    widget_slide_data.front_sidebar_draw(x_offset);
    graphics_reset_clip_rectangle();
    if (is_finished) {
        widget_slide_data.finished_callback();
    }
}

static void draw_collapsed_background(void);
static void draw_expanded_background(int x_offset);
static void button_collapse_expand(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    set_viewport(0, TOP_MENU_HEIGHT, view_data.screen_width - 40, view_data.screen_height - TOP_MENU_HEIGHT);
    check_camera_boundaries();
    widget_slide_data.direction = !view_data.sidebar_collapsed;
    widget_slide_data.position = 0;
    speed_clear(&widget_slide_data.slide_speed);
    speed_set_target(&widget_slide_data.slide_speed, SLIDE_SPEED, !(view_data.sidebar_collapsed == SLIDE_DIRECTION_OUT) ? SLIDE_ACCELERATION_MILLIS : SPEED_CHANGE_IMMEDIATE, 1);
    widget_slide_data.back_sidebar_draw = draw_collapsed_background;
    widget_slide_data.front_sidebar_draw = draw_expanded_background;
    widget_slide_data.finished_callback = slide_finished;
    play_sound_effect(SOUND_EFFECT_SIDEBAR);
    struct window_type_t window = {
        WINDOW_SLIDING_SIDEBAR,
        widget_city_draw,
        draw_sliding_foreground,
        0,
    };
    window_show(&window);
}

static struct image_button_t button_expand_sidebar[] = {
    {6, 4, 31, 20, IB_NORMAL, 90, 4, button_collapse_expand, button_none, 0, 0, 1, 0, 0, 0}
};

static void building_construction_set_type(int type)
{
    construction_data.type = type;
    construction_data.in_progress = 0;
    construction_data.start.x = 0;
    construction_data.start.y = 0;
    construction_data.end.x = 0;
    construction_data.end.y = 0;
    construction_data.cost_preview = 0;
    if (type != BUILDING_NONE) {
        construction_data.required_terrain.wall = 0;
        construction_data.required_terrain.water = 0;
        construction_data.required_terrain.tree = 0;
        construction_data.required_terrain.rock = 0;
        construction_data.required_terrain.meadow = 0;
        construction_data.road_orientation = 0;
        construction_data.road_last_update = current_time;
        construction_data.start.grid_offset = 0;
        switch (type) {
            case BUILDING_WHEAT_FARM:
            case BUILDING_VEGETABLE_FARM:
            case BUILDING_FRUIT_FARM:
            case BUILDING_OLIVE_FARM:
            case BUILDING_VINES_FARM:
            case BUILDING_PIG_FARM:
                construction_data.required_terrain.meadow = 1;
                break;
            case BUILDING_MARBLE_QUARRY:
            case BUILDING_IRON_MINE:
                construction_data.required_terrain.rock = 1;
                break;
            case BUILDING_TIMBER_YARD:
                construction_data.required_terrain.tree = 1;
                break;
            case BUILDING_CLAY_PIT:
                construction_data.required_terrain.water = 1;
                break;
            case BUILDING_GATEHOUSE:
            case BUILDING_TRIUMPHAL_ARCH:
                construction_data.road_orientation = 1;
                break;
            case BUILDING_TOWER:
                construction_data.required_terrain.wall = 1;
                break;
            default:
                break;
        }
    }
}

static void window_build_menu_hide(void)
{
    build_menu_data.selected_menu = MENU_NONE;
    window_city_show();
}

static int lang_text_get_width(int group, int number, int font)
{
    char *str = lang_get_string(group, number);
    return text_get_width(str, font) + font_data.font_definitions[font].space_width;
}

static void menu_bar_draw(struct menu_bar_item_t *items, int num_items, int max_width)
{
    int total_text_width = 0;
    for (int i = 0; i < num_items; i++) {
        total_text_width += lang_text_get_width(items[i].text_group, 0, FONT_NORMAL_GREEN);
    }
    if (num_items > 1) {
        int spacing_width = (max_width - total_text_width - TOP_MENU_BASE_X_OFFSET) / (num_items - 1);
        spacing_width = calc_bound(spacing_width, 0, 32);

        short x_offset = TOP_MENU_BASE_X_OFFSET;
        for (int i = 0; i < num_items; i++) {
            items[i].x_start = x_offset;
            x_offset += lang_text_draw(items[i].text_group, 0, x_offset, MENU_BASE_TEXT_Y_OFFSET, FONT_NORMAL_GREEN);
            items[i].x_end = x_offset;
            x_offset += spacing_width;
        }
    }
}

static int lang_text_draw_colored(int group, int number, int x_offset, int y_offset, int font, color_t color)
{
    char *str = lang_get_string(group, number);
    return text_draw(str, x_offset, y_offset, font, color);
}

static void clear_state_top_menu(void)
{
    top_menu_data.open_sub_menu = 0;
    top_menu_data.focus_menu_id = 0;
    top_menu_data.focus_sub_menu_id = 0;
}

static int init_popup_dialog(int type, int custom_text_group, int custom_text_id, void (*close_func)(void), int has_ok_cancel_buttons)
{
    if (window_data.current_window->id == WINDOW_POPUP_DIALOG) {
        // don't show popup over popup
        return 0;
    }
    popup_dialog_data.type = type;
    popup_dialog_data.custom_text_group = custom_text_group;
    popup_dialog_data.custom_text_id = custom_text_id;
    popup_dialog_data.ok_clicked = 0;
    popup_dialog_data.close_func = close_func;
    popup_dialog_data.has_buttons = has_ok_cancel_buttons;
    return 1;
}

static int string_equals(char *a, char *b)
{
    while (*a && *b && *a == *b) {
        ++a;
        ++b;
    }
    if (*a == 0 && *b == 0) {
        return 1;
    } else {
        return 0;
    }
}

static int file_has_extension(char *filename, char *extension)
{
    if (!extension || !*extension) {
        return 1;
    }
    char c;
    do {
        c = *filename;
        filename++;
    } while (c != '.' && c);
    if (!c) {
        filename--;
    }
    return string_equals(filename, extension);
}

static void file_append_extension(char *filename, char *extension)
{
    char c;
    do {
        c = *filename;
        filename++;
    } while (c);
    filename--;
    filename[0] = '.';
    filename[1] = extension[0];
    filename[2] = extension[1];
    filename[3] = extension[2];
    filename[4] = 0;
}

static void city_victory_reset(void)
{
    victory_data.state = VICTORY_STATE_NONE;
    victory_data.force_win = 0;
}

static void city_data_init(void)
{
    memset(&city_data, 0, sizeof(struct city_data_t));
    city_data.sentiment.value = 60;
    city_data.health.target_value = 50;
    city_data.health.value = 50;
    city_data.labor.wages_rome = 30;
    city_data.labor.wages = 30;
    city_data.finance.tax_percentage = 7;
    city_data.trade.caravan_import_resource = RESOURCE_WHEAT;
    city_data.trade.caravan_backup_import_resource = RESOURCE_WHEAT;
    city_data.population.monthly.next_index = 0;
    city_data.population.monthly.count = 0;
    city_data.festival.months_since_festival = 1;
    city_data.festival.size = FESTIVAL_NONE;
    city_data.emperor.gifts[GIFT_MODEST].cost = 0;
    city_data.emperor.gifts[GIFT_GENEROUS].cost = 0;
    city_data.emperor.gifts[GIFT_LAVISH].cost = 0;
    for (int i = 0; i < MAX_GODS; i++) {
        city_data.religion.gods[i].target_happiness = 50;
        city_data.religion.gods[i].happiness = 50;
        city_data.religion.gods[i].wrath_bolts = 0;
        city_data.religion.gods[i].blessing_done = 0;
        city_data.religion.gods[i].small_curse_done = 0;
        city_data.religion.gods[i].months_since_festival = 0;
    }
    city_data.religion.angry_message_delay = 0;
}

static void city_message_init_problem_areas(void)
{
    message_data.problem_count = 0;
    message_data.problem_index = 0;
    message_data.problem_last_click_time = current_time;
}

static void city_message_init_scenario(void)
{
    for (int i = 0; i < MAX_MESSAGES; i++) {
        message_data.messages[i].message_type = 0;
    }
    for (int i = 0; i < MAX_MESSAGE_QUEUE; i++) {
        message_data.queue[i] = 0;
    }
    message_data.consecutive_message_delay = 0;
    message_data.next_message_sequence = 0;
    message_data.total_messages = 0;
    message_data.current_message_id = -1;
    for (int i = 0; i < MAX_MESSAGE_CATEGORIES; i++) {
        message_data.message_count[i] = 0;
        message_data.message_delay[i] = 0;
    }
    // population
    message_data.population_shown.pop500 = 0;
    message_data.population_shown.pop1000 = 0;
    message_data.population_shown.pop2000 = 0;
    message_data.population_shown.pop3000 = 0;
    message_data.population_shown.pop5000 = 0;
    message_data.population_shown.pop10000 = 0;
    message_data.population_shown.pop15000 = 0;
    message_data.population_shown.pop20000 = 0;
    message_data.population_shown.pop25000 = 0;

    for (int i = 0; i <= MESSAGE_CAT_RIOT_COLLAPSE; i++) {
        message_data.last_sound_time[i] = 0;
    }
    city_message_init_problem_areas();
}

static void city_view_set_camera(int x, int y)
{
    view_data.camera.tile.x = x;
    view_data.camera.tile.y = y;
    check_camera_boundaries();
}

static void random_generate_next(void)
{
    random_data.pool[random_data.pool_index++] = random_data.random1_7bit;
    if (random_data.pool_index >= MAX_RANDOM) {
        random_data.pool_index = 0;
    }
    for (int i = 0; i < 31; i++) {
        unsigned int r1 = (((random_data.iv1 & 0x10) >> 4) ^ random_data.iv1) & 1;
        unsigned int r2 = (((random_data.iv2 & 0x10) >> 4) ^ random_data.iv2) & 1;
        random_data.iv1 = random_data.iv1 >> 1;
        random_data.iv2 = random_data.iv2 >> 1;
        if (r1) {
            random_data.iv1 |= 0x40000000;
        }
        if (r2) {
            random_data.iv2 |= 0x40000000;
        }
    }
    random_data.random1_7bit = random_data.iv1 & 0x7f;
    random_data.random1_15bit = random_data.iv1 & 0x7fff;
    random_data.random2_7bit = random_data.iv2 & 0x7f;
    random_data.random2_15bit = random_data.iv2 & 0x7fff;
}

static void game_state_init(void)
{
    city_victory_reset();
    city_view_set_camera(76, 152);
    random_data.pool_index = 0;
    for (int i = 0; i < MAX_RANDOM; i++) {
        random_generate_next();
    }
    city_warning_clear_all();
}

static void game_animation_init(void)
{
    for (int i = 0; i < MAX_ANIM_TIMERS; i++) {
        timers[i].last_update = 0;
        timers[i].should_update = 0;
    }
}

static void initialize_city_sounds(void)
{
    last_update_time = current_time;
    memset(channels, 0, MAX_CITY_SOUNDS_CHANNELS * sizeof(struct city_channel_t));
    for (int i = 0; i < MAX_CITY_SOUNDS_CHANNELS; i++) {
        channels[i].last_played_time = last_update_time;
    }
    for (int i = 1; i < MAX_CITY_SOUNDS_CHANNELS; i++) {
        channels[i].in_use = 1;
        channels[i].views_threshold = 200;
        channels[i].delay_millis = 1000;
    }
    channels[1].channel = SOUND_CHANNEL_CITY_VACANT_LOT;
    channels[2].channel = SOUND_CHANNEL_CITY_HOUSE_SLUM;
    channels[3].channel = SOUND_CHANNEL_CITY_HOUSE_POOR;
    channels[4].channel = SOUND_CHANNEL_CITY_HOUSE_MEDIUM;
    channels[5].channel = SOUND_CHANNEL_CITY_HOUSE_GOOD;
    channels[6].channel = SOUND_CHANNEL_CITY_HOUSE_POSH;
    channels[7].channel = SOUND_CHANNEL_CITY_EMPTY_LAND;
    channels[8].channel = SOUND_CHANNEL_CITY_RESERVOIR;
    channels[9].channel = SOUND_CHANNEL_CITY_AQUEDUCT;
    channels[10].channel = SOUND_CHANNEL_CITY_FOUNTAIN;
    channels[11].channel = SOUND_CHANNEL_CITY_WELL;
    channels[12].channel = SOUND_CHANNEL_CITY_BARBER;
    channels[13].channel = SOUND_CHANNEL_CITY_BATHHOUSE;
    channels[14].channel = SOUND_CHANNEL_CITY_CLINIC;
    channels[15].channel = SOUND_CHANNEL_CITY_HOSPITAL;
    channels[16].channel = SOUND_CHANNEL_CITY_TEMPLE_CERES;
    channels[17].channel = SOUND_CHANNEL_CITY_TEMPLE_NEPTUNE;
    channels[18].channel = SOUND_CHANNEL_CITY_TEMPLE_MERCURY;
    channels[19].channel = SOUND_CHANNEL_CITY_TEMPLE_MARS;
    channels[20].channel = SOUND_CHANNEL_CITY_TEMPLE_VENUS;
    channels[21].channel = SOUND_CHANNEL_CITY_ORACLE;
    channels[22].channel = SOUND_CHANNEL_CITY_SCHOOL;
    channels[23].channel = SOUND_CHANNEL_CITY_ACADEMY;
    channels[24].channel = SOUND_CHANNEL_CITY_LIBRARY;
    channels[25].channel = SOUND_CHANNEL_CITY_THEATER;
    channels[26].channel = SOUND_CHANNEL_CITY_AMPHITHEATER;
    channels[27].channel = SOUND_CHANNEL_CITY_COLOSSEUM;
    channels[28].channel = SOUND_CHANNEL_CITY_HIPPODROME;
    channels[29].channel = SOUND_CHANNEL_CITY_GLADIATOR_SCHOOL;
    channels[30].channel = SOUND_CHANNEL_CITY_LION_PIT;
    channels[31].channel = SOUND_CHANNEL_CITY_ACTOR_COLONY;
    channels[32].channel = SOUND_CHANNEL_CITY_CHARIOT_MAKER;
    channels[33].channel = SOUND_CHANNEL_CITY_FORUM;
    channels[34].channel = SOUND_CHANNEL_CITY_SENATE;
    channels[35].channel = SOUND_CHANNEL_CITY_PALACE;
    channels[36].channel = SOUND_CHANNEL_CITY_STATUE;
    channels[37].channel = SOUND_CHANNEL_CITY_GARDEN;
    channels[38].channel = SOUND_CHANNEL_CITY_SHIPYARD;
    channels[39].channel = SOUND_CHANNEL_CITY_DOCK;
    channels[40].channel = SOUND_CHANNEL_CITY_WHARF;
    channels[41].channel = SOUND_CHANNEL_CITY_TOWER;
    channels[42].channel = SOUND_CHANNEL_CITY_FORT;
    channels[43].channel = SOUND_CHANNEL_CITY_MILITARY_ACADEMY;
    channels[44].channel = SOUND_CHANNEL_CITY_BARRACKS;
    channels[45].channel = SOUND_CHANNEL_CITY_WHEAT_FARM;
    channels[46].channel = SOUND_CHANNEL_CITY_VEGETABLE_FARM;
    channels[47].channel = SOUND_CHANNEL_CITY_FRUIT_FARM;
    channels[48].channel = SOUND_CHANNEL_CITY_OLIVE_FARM;
    channels[49].channel = SOUND_CHANNEL_CITY_VINE_FARM;
    channels[50].channel = SOUND_CHANNEL_CITY_PIG_FARM;
    channels[51].channel = SOUND_CHANNEL_CITY_CLAY_PIT;
    channels[52].channel = SOUND_CHANNEL_CITY_QUARRY;
    channels[53].channel = SOUND_CHANNEL_CITY_IRON_MINE;
    channels[54].channel = SOUND_CHANNEL_CITY_TIMBER_YARD;
    channels[55].channel = SOUND_CHANNEL_CITY_WINE_WORKSHOP;
    channels[56].channel = SOUND_CHANNEL_CITY_OIL_WORKSHOP;
    channels[57].channel = SOUND_CHANNEL_CITY_WEAPONS_WORKSHOP;
    channels[58].channel = SOUND_CHANNEL_CITY_FURNITURE_WORKSHOP;
    channels[59].channel = SOUND_CHANNEL_CITY_POTTERY_WORKSHOP;
    channels[60].channel = SOUND_CHANNEL_CITY_MARKET;
    channels[61].channel = SOUND_CHANNEL_CITY_GRANARY;
    channels[62].channel = SOUND_CHANNEL_CITY_WAREHOUSE;
    channels[63].channel = SOUND_CHANNEL_CITY_BURNING_RUIN;
}

static void building_clear_all(void)
{
    for (int i = 0; i < MAX_BUILDINGS; i++) {
        memset(&all_buildings[i], 0, sizeof(struct building_t));
        all_buildings[i].id = i;
    }
    extra.highest_id_in_use = 0;
    extra.highest_id_ever = 0;
    extra.created_sequence = 0;
    extra.incorrect_houses = 0;
    extra.unfixable_houses = 0;
}

static void figure_init_scenario(void)
{
    for (int i = 0; i < MAX_FIGURES; i++) {
        memset(&figures[i], 0, sizeof(struct figure_t));
        figures[i].id = i;
    }
}

static int32_t init_name(void)
{
    random_generate_next();
    return random_data.random1_7bit & 0xf;
}

static void figure_name_init(void)
{
    name_data.citizen_male = init_name();
    name_data.patrician = init_name();
    name_data.citizen_female = init_name();
    name_data.tax_collector = init_name();
    name_data.engineer = init_name();
    name_data.prefect = init_name();
    name_data.javelin_thrower = init_name();
    name_data.cavalry = init_name();
    name_data.legionary = init_name();
    name_data.actor = init_name();
    name_data.gladiator = init_name();
    name_data.lion_tamer = init_name();
    name_data.charioteer = init_name();
    name_data.barbarian = init_name();
    name_data.enemy_greek = init_name();
    name_data.enemy_egyptian = init_name();
    name_data.enemy_arabian = init_name();
    name_data.trader = init_name();
    name_data.ship = init_name();
}

static void reset_all_formations(void)
{
    selected_legion_formation = -1;
    for (int i = 0; i < MAX_LEGIONS; i++) {
        memset(&legion_formations[i], 0, sizeof(struct formation_t));
        legion_formations[i].id = i;
    }
    for (int i = 0; i < MAX_HERD_POINTS; i++) {
        memset(&herd_formations[i], 0, sizeof(struct formation_t));
        herd_formations[i].id = i;
    }
    for (int i = 0; i < MAX_ENEMY_FORMATIONS; i++) {
        memset(&enemy_formations[i], 0, sizeof(struct formation_t));
        enemy_formations[i].id = i;
    }
}

static void figure_route_clear_all(void)
{
    for (int i = 0; i < MAX_ROUTES; i++) {
        figure_route_data.figure_ids[i] = 0;
        for (int j = 0; j < MAX_PATH_LENGTH; j++) {
            figure_route_data.direction_paths[i][j] = 0;
        }
    }
}

static void game_time_init(int year)
{
    time_data.tick = 0;
    time_data.day = 0;
    time_data.month = 0;
    time_data.total_days = 0;
    time_data.year = year;
}

static void map_building_clear(void)
{
    memset(buildings_grid.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
    memset(damage_grid.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memset(rubble_type_grid.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
}

static void map_property_clear(void)
{
    memset(bitfields_grid.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memset(edge_grid.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
}

static void clear_current_offset(struct terrain_image_context *items, int num_items)
{
    for (int i = 0; i < num_items; i++) {
        items[i].current_item_offset = 0;
    }
}

static void map_random_init(void)
{
    int grid_offset = 0;
    for (int y = 0; y < GRID_SIZE; y++) {
        for (int x = 0; x < GRID_SIZE; x++, grid_offset++) {
            random_generate_next();
            random.items[grid_offset] = (uint8_t) random_data.random1_15bit;
        }
    }
}

static void buffer_reset(struct buffer_t *buf)
{
    buf->index = 0;
    buf->overflow = 0;
}

static void init_file_piece(struct file_piece_t *piece, int size)
{
    void *data = malloc(size);
    if (data) {
        memset(data, 0, size);
        buffer_init(&piece->buf, data, size);
    }
}

static struct buffer_t *create_scenario_piece(int size)
{
    struct file_piece_t *piece = &scenario_data.pieces[scenario_data.num_pieces++];
    init_file_piece(piece, size);
    return &piece->buf;
}

static void init_scenario_data(void)
{
    if (scenario_data.num_pieces > 0) {
        for (int i = 0; i < scenario_data.num_pieces; i++) {
            buffer_reset(&scenario_data.pieces[i].buf);
        }
        return;
    }
    struct scenario_state_t *state = &scenario_data.state;
    state->graphic_ids = create_scenario_piece(52488);
    state->edge = create_scenario_piece(26244);
    state->terrain = create_scenario_piece(78732);
    state->bitfields = create_scenario_piece(26244);
    state->random = create_scenario_piece(26244);
    state->random_iv = create_scenario_piece(8);
    state->camera = create_scenario_piece(8);
    state->scenario = create_scenario_piece(52424);
    state->empire_objects = create_scenario_piece(20600);
}

static void map_image_load_state(struct buffer_t *buf)
{
    for (int i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        images.items[i] = buffer_read_u16(buf);
    }
}

static int buffer_read_raw(struct buffer_t *buf, void *value, int max_size)
{
    int size = buf->size - buf->index;
    if (size > max_size) {
        size = max_size;
    }
    memcpy(value, &buf->data[buf->index], size);
    buf->index += size;
    return size;
}

static void map_terrain_load_state(struct buffer_t *buf)
{
    for (int i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        terrain_grid.items[i] = buffer_read_u16(buf);
    }
    buffer_read_raw(buf, terrain_elevation.items, GRID_SIZE * GRID_SIZE);
}

static void map_property_load_state(struct buffer_t *bitfields, struct buffer_t *edge)
{
    buffer_read_raw(bitfields, bitfields_grid.items, GRID_SIZE * GRID_SIZE);
    buffer_read_raw(edge, edge_grid.items, GRID_SIZE * GRID_SIZE);
}

static int32_t buffer_read_i32(struct buffer_t *buf)
{
    if (check_size(buf, 4)) {
        uint8_t b0 = buf->data[buf->index++];
        uint8_t b1 = buf->data[buf->index++];
        uint8_t b2 = buf->data[buf->index++];
        uint8_t b3 = buf->data[buf->index++];
        return (int32_t) (b0 | (b1 << 8) | (b2 << 16) | (b3 << 24));
    } else {
        return 0;
    }
}

static void city_view_load_scenario_state(struct buffer_t *camera)
{
    view_data.camera.tile.x = buffer_read_i32(camera);
    view_data.camera.tile.y = buffer_read_i32(camera);
}

static uint32_t buffer_read_u32(struct buffer_t *buf)
{
    if (check_size(buf, 4)) {
        uint8_t b0 = buf->data[buf->index++];
        uint8_t b1 = buf->data[buf->index++];
        uint8_t b2 = buf->data[buf->index++];
        uint8_t b3 = buf->data[buf->index++];
        return (uint32_t) (b0 | (b1 << 8) | (b2 << 16) | (b3 << 24));
    } else {
        return 0;
    }
}

static void random_load_state(struct buffer_t *buf)
{
    random_data.iv1 = buffer_read_u32(buf);
    random_data.iv2 = buffer_read_u32(buf);
}

static int16_t buffer_read_i16(struct buffer_t *buf)
{
    if (check_size(buf, 2)) {
        uint8_t b0 = buf->data[buf->index++];
        uint8_t b1 = buf->data[buf->index++];
        return (int16_t) (b0 | (b1 << 8));
    } else {
        return 0;
    }
}

static void scenario_load_state(struct buffer_t *buf)
{
    scenario.map.width = buffer_read_u16(buf);
    scenario.map.height = buffer_read_u16(buf);
    scenario.map.grid_start = buffer_read_u16(buf);
    scenario.map.grid_border_size = buffer_read_u16(buf);
    scenario.empire.id = buffer_read_u8(buf);
    scenario.empire.is_expanded = buffer_read_u8(buf);
    scenario.empire.expansion_year = buffer_read_u16(buf);
    scenario.empire.distant_battle_roman_travel_months = buffer_read_u8(buf);
    scenario.empire.distant_battle_enemy_travel_months = buffer_read_u8(buf);
    // Map name
    buffer_read_raw(buf, scenario.scenario_name, MAX_SCENARIO_NAME);
    // Brief description
    buffer_read_raw(buf, scenario.brief_description, MAX_BRIEF_DESCRIPTION);
    scenario.brief_description_image_id = buffer_read_u8(buf);
    // Scenario description
    buffer_read_raw(buf, scenario.briefing, MAX_BRIEFING);
    // Terrain set
    scenario.climate = buffer_read_u8(buf);
    // Starting conditions
    scenario.player_rank = buffer_read_u8(buf);
    scenario.start_year = buffer_read_i16(buf);
    scenario.initial_favor = buffer_read_u8(buf);
    scenario.initial_funds = buffer_read_u32(buf);
    scenario.rescue_loan = buffer_read_u32(buf);
    scenario.initial_personal_savings = buffer_read_u32(buf);
    scenario.rome_supplies_wheat = buffer_read_u8(buf);
    scenario.flotsam_enabled = buffer_read_u8(buf);
    // Win criteria
    scenario.population_win_criteria.enabled = buffer_read_u8(buf);
    scenario.population_win_criteria.goal = buffer_read_u32(buf);
    scenario.culture_win_criteria.enabled = buffer_read_u8(buf);
    scenario.culture_win_criteria.goal = buffer_read_u16(buf);
    scenario.prosperity_win_criteria.enabled = buffer_read_u8(buf);
    scenario.prosperity_win_criteria.goal = buffer_read_u16(buf);
    scenario.peace_win_criteria.enabled = buffer_read_u8(buf);
    scenario.peace_win_criteria.goal = buffer_read_u16(buf);
    scenario.favor_win_criteria.enabled = buffer_read_u8(buf);
    scenario.favor_win_criteria.goal = buffer_read_u16(buf);
    scenario.time_limit_win_criteria.enabled = buffer_read_u8(buf);
    scenario.time_limit_win_criteria.years = buffer_read_u16(buf);
    scenario.survival_time_win_criteria.enabled = buffer_read_u8(buf);
    scenario.survival_time_win_criteria.years = buffer_read_u16(buf);
    // Buildings allowed
    for (int i = 0; i < BUILDING_TYPE_MAX; i++) {
        scenario.allowed_buildings[i] = buffer_read_u8(buf);
    }
    // Special events
    scenario.gladiator_revolt.state = buffer_read_u8(buf);
    scenario.gladiator_revolt.month = buffer_read_u8(buf);
    scenario.gladiator_revolt.year = buffer_read_u16(buf);
    // random events
    scenario.random_events.sea_trade_problem = buffer_read_u8(buf);
    scenario.random_events.land_trade_problem = buffer_read_u8(buf);
    scenario.random_events.raise_wages = buffer_read_u8(buf);
    scenario.random_events.lower_wages = buffer_read_u8(buf);
    scenario.random_events.contaminated_water = buffer_read_u8(buf);
    // Requests
    for (int i = 0; i < MAX_REQUESTS; i++) {
        scenario.requests[i].year = buffer_read_u16(buf);
        scenario.requests[i].month = buffer_read_u8(buf);
        scenario.requests[i].amount = buffer_read_u16(buf);
        scenario.requests[i].resource = buffer_read_u8(buf);
        scenario.requests[i].years_deadline = buffer_read_u16(buf);
        scenario.requests[i].favor = buffer_read_u8(buf);
        scenario.requests[i].state = buffer_read_u8(buf);
        scenario.requests[i].visible = buffer_read_u8(buf);
        scenario.requests[i].months_to_comply = buffer_read_u16(buf);
        scenario.requests[i].can_comply_dialog_shown = buffer_read_u8(buf);
    }
    // Custom messages
    for (int i = 0; i < MAX_EDITOR_CUSTOM_MESSAGES; i++) {
        scenario.editor_custom_messages[i].year = buffer_read_u16(buf);
        scenario.editor_custom_messages[i].month = buffer_read_u8(buf);
        scenario.editor_custom_messages[i].urgent = buffer_read_u8(buf);
        scenario.editor_custom_messages[i].enabled = buffer_read_u8(buf);
        buffer_read_raw(buf, scenario.editor_custom_messages[i].title, MAX_CUSTOM_MESSAGE_TITLE);
        buffer_read_raw(buf, scenario.editor_custom_messages[i].text, MAX_CUSTOM_MESSAGE_TEXT);
        buffer_read_raw(buf, scenario.editor_custom_messages[i].video_file, MAX_CUSTOM_MESSAGE_VIDEO_TEXT);
    }
    // Earthquakes
    for (int i = 0; i < MAX_EARTHQUAKES; i++) {
        scenario.earthquakes[i].state = buffer_read_u8(buf);
        scenario.earthquakes[i].severity = buffer_read_u8(buf);
        scenario.earthquakes[i].month = buffer_read_u8(buf);
        scenario.earthquakes[i].year = buffer_read_u16(buf);
        scenario.earthquakes[i].duration = buffer_read_u16(buf);
        scenario.earthquakes[i].max_duration = buffer_read_u16(buf);
        scenario.earthquakes[i].delay = buffer_read_u8(buf);
        scenario.earthquakes[i].max_delay = buffer_read_u8(buf);
        scenario.earthquakes[i].point = buffer_read_u8(buf);
        for (int j = 0; j < MAX_EARTHQUAKE_BRANCHES; j++) {
            scenario.earthquakes[i].branch_coordinates[j].x = buffer_read_i32(buf);
            scenario.earthquakes[i].branch_coordinates[j].y = buffer_read_i32(buf);
        }
    }
    // Invasions
    for (int i = 0; i < MAX_INVASIONS; i++) {
        scenario.invasions[i].year_offset = buffer_read_u16(buf);
        scenario.invasions[i].month = buffer_read_u8(buf);
        scenario.invasions[i].amount = buffer_read_u16(buf);
        scenario.invasions[i].type = buffer_read_u8(buf);
        scenario.invasions[i].enemy_type = buffer_read_u8(buf);
        scenario.invasions[i].from = buffer_read_u8(buf);
        scenario.invasions[i].target_type = buffer_read_u8(buf);
    }
    scenario.invasion_upcoming = buffer_read_u8(buf);
    // Price changes
    for (int i = 0; i < MAX_PRICE_CHANGES; i++) {
        scenario.price_changes[i].year = buffer_read_u16(buf);
        scenario.price_changes[i].month = buffer_read_u8(buf);
        scenario.price_changes[i].resource = buffer_read_u8(buf);
        scenario.price_changes[i].is_rise = buffer_read_u8(buf);
        scenario.price_changes[i].amount = buffer_read_u8(buf);
    }
    // Demand changes
    for (int i = 0; i < MAX_DEMAND_CHANGES; i++) {
        scenario.demand_changes[i].year = buffer_read_u16(buf);
        scenario.demand_changes[i].month = buffer_read_u8(buf);
        scenario.demand_changes[i].resource = buffer_read_u8(buf);
        scenario.demand_changes[i].trade_city_id = buffer_read_u8(buf);
        scenario.demand_changes[i].is_rise = buffer_read_u8(buf);
    }
    // Earthquake points
    for (int i = 0; i < MAX_EARTHQUAKE_POINTS; i++) {
        scenario.earthquake_points[i].x = buffer_read_i16(buf);
        scenario.earthquake_points[i].y = buffer_read_i16(buf);
    }
    // Invasion points
    for (int i = 0; i < MAX_INVASION_POINTS; i++) {
        scenario.invasion_points[i].x = buffer_read_i16(buf);
        scenario.invasion_points[i].y = buffer_read_i16(buf);
    }
    // Entry/exit points
    scenario.entry_point.x = buffer_read_i16(buf);
    scenario.entry_point.y = buffer_read_i16(buf);
    scenario.exit_point.x = buffer_read_i16(buf);
    scenario.exit_point.y = buffer_read_i16(buf);
    // River entry/exit points
    scenario.river_entry_point.x = buffer_read_i16(buf);
    scenario.river_entry_point.y = buffer_read_i16(buf);
    scenario.river_exit_point.x = buffer_read_i16(buf);
    scenario.river_exit_point.y = buffer_read_i16(buf);
    // Native buildings
    scenario.native_images.hut = buffer_read_u32(buf);
    scenario.native_images.meeting = buffer_read_u32(buf);
    scenario.native_images.crops = buffer_read_u32(buf);
    scenario.native_images.vacant_lots = buffer_read_u32(buf);
    // Fishing points
    for (int i = 0; i < MAX_FISH_POINTS; i++) {
        scenario.fishing_points[i].x = buffer_read_i16(buf);
        scenario.fishing_points[i].y = buffer_read_i16(buf);
    }
    // Herd points
    for (int i = 0; i < MAX_HERD_POINTS; i++) {
        scenario.herd_points[i].x = buffer_read_i16(buf);
        scenario.herd_points[i].y = buffer_read_i16(buf);
    }
    scenario.is_saved = 1;
}

static void fix_image_ids(void)
{
    int image_id = 0;
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        if (empire_objects[i].in_use
            && empire_objects[i].type == EMPIRE_OBJECT_CITY
            && empire_objects[i].city_type == EMPIRE_CITY_OURS) {
            image_id = empire_objects[i].image_id;
            break;
        }
    }
    if (image_id > 0 && image_id != image_data_s.group_image_ids[GROUP_EMPIRE_CITY]) {
        // empire map uses old version of graphics: increase every graphic id
        int offset = image_data_s.group_image_ids[GROUP_EMPIRE_CITY] - image_id;
        for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
            if (!empire_objects[i].in_use) {
                continue;
            }
            if (empire_objects[i].image_id) {
                empire_objects[i].image_id += offset;
                if (empire_objects[i].expanded.image_id) {
                    empire_objects[i].expanded.image_id += offset;
                }
            }
        }
    }
}

static void empire_object_load_state(struct buffer_t *buf)
{
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        empire_objects[i].id = i;
        empire_objects[i].type = buffer_read_u8(buf);
        empire_objects[i].x = buffer_read_i16(buf);
        empire_objects[i].y = buffer_read_i16(buf);
        empire_objects[i].image_id = buffer_read_i16(buf);
        empire_objects[i].expanded.x = buffer_read_i16(buf);
        empire_objects[i].expanded.y = buffer_read_i16(buf);
        empire_objects[i].expanded.image_id = buffer_read_i16(buf);
        empire_objects[i].width = buffer_read_i16(buf);
        empire_objects[i].height = buffer_read_i16(buf);
        empire_objects[i].animation_index = buffer_read_u8(buf);
        empire_objects[i].in_use = buffer_read_u8(buf);
        empire_objects[i].city_type = buffer_read_u8(buf);
        empire_objects[i].city_name_id = buffer_read_u8(buf);
        empire_objects[i].trade_route_id = buffer_read_u8(buf);
        empire_objects[i].trade_route_open = buffer_read_u8(buf);
        empire_objects[i].trade_route_cost = buffer_read_u32(buf);
        empire_objects[i].trader_entry_delay = buffer_read_i16(buf);
        empire_objects[i].is_sea_trade = buffer_read_u8(buf);
        for (int f = 0; f < 3; f++) {
            empire_objects[i].trader_figure_ids[f] = buffer_read_i16(buf);
        }
        for (int r = 0; r < RESOURCE_TYPES_MAX; r++) {
            empire_objects[i].resource_buy_limit[r] = buffer_read_u8(buf);
            empire_objects[i].resource_sell_limit[r] = buffer_read_u8(buf);
            empire_objects[i].resource_bought[r] = buffer_read_u8(buf);
            empire_objects[i].resource_sold[r] = buffer_read_u8(buf);
        }
        empire_objects[i].invasion_path_id = buffer_read_u8(buf);
        empire_objects[i].invasion_years = buffer_read_u8(buf);
        empire_objects[i].distant_battle_travel_months = buffer_read_u8(buf);
    }
    fix_image_ids();
}

static int game_file_io_read_scenario(char *dir, char *filename)
{
    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Loading scenario", filename, 0));
    init_scenario_data();
    static char dir_prepended_filepath[DIR_PATH_MAX];
    prepend_dir_to_path(dir, filename, dir_prepended_filepath);
    FILE *fp = fopen(dir_prepended_filepath, "rb");
    if (!fp) {
        return 0;
    }
    for (int i = 0; i < scenario_data.num_pieces; i++) {
        size_t read_size = fread(scenario_data.pieces[i].buf.data, 1, scenario_data.pieces[i].buf.size, fp);
        if (read_size != (unsigned) scenario_data.pieces[i].buf.size) {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to load scenario", filename, 0));
            fclose(fp);
            return 0;
        }
    }
    fclose(fp);
    map_image_load_state(scenario_data.state.graphic_ids);
    map_terrain_load_state(scenario_data.state.terrain);
    map_property_load_state(scenario_data.state.bitfields, scenario_data.state.edge);
    buffer_read_raw(scenario_data.state.random, random.items, GRID_SIZE * GRID_SIZE);
    city_view_load_scenario_state(scenario_data.state.camera);
    random_load_state(scenario_data.state.random_iv);
    scenario_load_state(scenario_data.state.scenario);
    empire_object_load_state(scenario_data.state.empire_objects);
    return 1;
}

static void calculate_lookup(void)
{
    for (int y = 0; y < VIEW_Y_MAX; y++) {
        for (int x = 0; x < VIEW_X_MAX; x++) {
            view_to_grid_offset_lookup[x][y] = -1;
        }
    }
    int y_view_start;
    int y_view_skip;
    int y_view_step;
    int x_view_start;
    int x_view_skip;
    int x_view_step;
    switch (view_data.orientation) {
        default:
        case DIR_0_TOP:
            x_view_start = VIEW_X_MAX - 1;
            x_view_skip = -1;
            x_view_step = 1;
            y_view_start = 1;
            y_view_skip = 1;
            y_view_step = 1;
            break;
        case DIR_2_RIGHT:
            x_view_start = 3;
            x_view_skip = 1;
            x_view_step = 1;
            y_view_start = VIEW_X_MAX - 3;
            y_view_skip = 1;
            y_view_step = -1;
            break;
        case DIR_4_BOTTOM:
            x_view_start = VIEW_X_MAX - 1;
            x_view_skip = 1;
            x_view_step = -1;
            y_view_start = VIEW_Y_MAX - 2;
            y_view_skip = -1;
            y_view_step = -1;
            break;
        case DIR_6_LEFT:
            x_view_start = VIEW_Y_MAX;
            x_view_skip = -1;
            x_view_step = -1;
            y_view_start = VIEW_X_MAX - 3;
            y_view_skip = -1;
            y_view_step = 1;
            break;
    }

    for (int y = 0; y < GRID_SIZE; y++) {
        int x_view = x_view_start;
        int y_view = y_view_start;
        for (int x = 0; x < GRID_SIZE; x++) {
            int grid_offset = x + GRID_SIZE * y;
            if (images.items[grid_offset] < 6) {
                view_to_grid_offset_lookup[x_view / 2][y_view] = -1;
            } else {
                view_to_grid_offset_lookup[x_view / 2][y_view] = grid_offset;
            }
            x_view += x_view_step;
            y_view += y_view_step;
        }
        x_view_start += x_view_skip;
        y_view_start += y_view_skip;
    }
}

static void city_view_reset_orientation(void)
{
    view_data.orientation = 0;
    calculate_lookup();
}

static int game_file_load_scenario_data(char *scenario_file)
{
    if (!game_file_io_read_scenario(MAPS_DIR_PATH, scenario_file)) {
        return 0;
    }
    city_view_reset_orientation();
    return 1;
}

static void file_remove_extension(char *filename)
{
    uint8_t c;
    do {
        c = *filename;
        filename++;
    } while (c != '.' && c);
    if (c == '.') {
        filename--;
        *filename = 0;
    }
}

static void map_grid_init(int width, int height, int start_offset, int border_size)
{
    map_data.width = width;
    map_data.height = height;
    map_data.start_offset = start_offset;
    map_data.border_size = border_size;
}

static void clear_access_ramp_image(__attribute__((unused)) int x, __attribute__((unused)) int y, int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_ACCESS_RAMP)) {
        images.items[grid_offset] = 0;
    }
}

static void set_elevation_image(int x, int y, int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_ACCESS_RAMP) && !images.items[grid_offset]) {
        int image_offset = -1;
        if (map_grid_is_inside(x, y, 1)) {
            static   int offsets[4][6] = {
                {OFFSET(0,1), OFFSET(1,1), OFFSET(0,0), OFFSET(1,0), OFFSET(0,2), OFFSET(1,2)},
                {OFFSET(0,0), OFFSET(0,1), OFFSET(1,0), OFFSET(1,1), OFFSET(-1,0), OFFSET(-1,1)},
                {OFFSET(0,0), OFFSET(1,0), OFFSET(0,1), OFFSET(1,1), OFFSET(0,-1), OFFSET(1,-1)},
                {OFFSET(1,0), OFFSET(1,1), OFFSET(0,0), OFFSET(0,1), OFFSET(2,0), OFFSET(2,1)},
            };
            int base_offset = map_grid_offset(x, y);
            for (int dir = 0; dir < 4; dir++) {
                int right_tiles = 0;
                int height = -1;
                for (int i = 0; i < 6; i++) {
                    int grid_offset2 = base_offset + offsets[dir][i];
                    if (i < 2) { // 2nd row
                        if (map_terrain_is(grid_offset2, TERRAIN_ELEVATION)) {
                            right_tiles++;
                        }
                        height = terrain_elevation.items[grid_offset2];
                    } else if (i < 4) { // 1st row
                        if (map_terrain_is(grid_offset2, TERRAIN_ACCESS_RAMP) &&
                            terrain_elevation.items[grid_offset2] < height) {
                            right_tiles++;
                        }
                    } else { // higher row beyond access ramp
                        if (map_terrain_is(grid_offset2, TERRAIN_ELEVATION)) {
                            if (terrain_elevation.items[grid_offset2] != height) {
                                right_tiles++;
                            }
                        } else if (terrain_elevation.items[grid_offset2] >= height) {
                            right_tiles++;
                        }
                    }
                }
                if (right_tiles == 6) {
                    image_offset = dir;
                    break;
                }
            }
            if (image_offset > -1) {
                switch (view_data.orientation) {
                    case DIR_0_TOP: break;
                    case DIR_6_LEFT: image_offset += 1; break;
                    case DIR_4_BOTTOM: image_offset += 2; break;
                    case DIR_2_RIGHT: image_offset += 3; break;
                }
                if (image_offset >= 4) {
                    image_offset -= 4;
                }
            }
        }
        if (image_offset < 0) {
            // invalid map: remove access ramp
            terrain_grid.items[grid_offset] &= ~TERRAIN_ACCESS_RAMP;
            map_property_set_multi_tile_size(grid_offset, 1);
            edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
            if (terrain_elevation.items[grid_offset]) {
                terrain_grid.items[grid_offset] |= TERRAIN_ELEVATION;
            } else {
                terrain_grid.items[grid_offset] &= ~TERRAIN_ELEVATION;
                images.items[grid_offset] = image_data_s.group_image_ids[GROUP_TERRAIN_GRASS_1] + (random.items[grid_offset] & 7);
            }
        } else {
            map_building_tiles_add(0, x, y, 2,
                image_data_s.group_image_ids[GROUP_TERRAIN_ACCESS_RAMP] + image_offset, TERRAIN_ACCESS_RAMP);
        }
    }
    if (terrain_elevation.items[grid_offset]
    && !map_terrain_is(grid_offset, TERRAIN_ACCESS_RAMP)
    && !map_terrain_is(grid_offset, TERRAIN_WATER)
    && !map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
        int tiles[MAX_TILES_TERRAIN];
        for (int i = 0; i < MAX_TILES_TERRAIN; i++) {
            tiles[i] = terrain_elevation.items[grid_offset + map_grid_direction_delta(i)] >= terrain_elevation.items[grid_offset] ? 1 : 0;
        }
        struct terrain_image_t *img = get_image(CONTEXT_ELEVATION, tiles);
        if (img->group_offset == 44) {
            terrain_grid.items[grid_offset] &= ~TERRAIN_ELEVATION;
            map_property_set_multi_tile_xy(grid_offset, 0, 0, 1);
        } else {
            map_property_set_multi_tile_xy(grid_offset, 0, 0, 1);
            terrain_grid.items[grid_offset] |= TERRAIN_ELEVATION;
            images.items[grid_offset] = image_data_s.group_image_ids[GROUP_TERRAIN_ELEVATION] + img->group_offset + img->item_offset;
        }
    }
}

static void map_tiles_update_all_elevation(void)
{
    int width = map_data.width - 2;
    int height = map_data.height - 2;
    foreach_region_tile(0, 0, width, height, clear_access_ramp_image);
    foreach_region_tile(0, 0, width, height, set_elevation_image);
}

static void set_earthquake_image(__attribute__((unused)) int x, __attribute__((unused)) int y, int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_ROCK) && bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
        int tiles[MAX_TILES_TERRAIN];
        for (int i = 0; i < MAX_TILES_TERRAIN; i++) {
            int offset = grid_offset + map_grid_direction_delta(i);
            tiles[i] = (map_terrain_is(offset, TERRAIN_ROCK) && bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) ? 1 : 0;
        }
        struct terrain_image_t *img = get_image(CONTEXT_EARTHQUAKE, tiles);
        if (img->is_valid) {
            images.items[grid_offset] = image_data_s.group_image_ids[GROUP_TERRAIN_EARTHQUAKE] + img->group_offset + img->item_offset;
        } else {
            images.items[grid_offset] = image_data_s.group_image_ids[GROUP_TERRAIN_EARTHQUAKE];
        }
        map_property_set_multi_tile_size(grid_offset, 1);
        edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
    }
}

static void map_tiles_update_all_earthquake(void)
{
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (map_terrain_is(grid_offset, TERRAIN_ROCK) && bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
                terrain_grid.items[grid_offset] |= TERRAIN_ROCK;
                bitfields_grid.items[grid_offset] |= BIT_PLAZA_OR_EARTHQUAKE;
                foreach_region_tile(x - 1, y - 1, x + 1, y + 1, set_earthquake_image);
            }
        }
    }
}

static void map_tiles_add_entry_exit_flags(void)
{
    int entry_orientation;
    if (scenario.entry_point.x == 0) {
        entry_orientation = DIR_2_RIGHT;
    } else if (scenario.entry_point.x == map_data.width - 1) {
        entry_orientation = DIR_6_LEFT;
    } else if (scenario.entry_point.y == 0) {
        entry_orientation = DIR_0_TOP;
    } else if (scenario.entry_point.y == map_data.height - 1) {
        entry_orientation = DIR_4_BOTTOM;
    } else {
        entry_orientation = -1;
    }
    if (entry_orientation >= 0) {
        int grid_offset = map_grid_offset(scenario.entry_point.x, scenario.entry_point.y);
        terrain_grid.items[grid_offset] |= TERRAIN_ROCK;
        int orientation = (view_data.orientation + entry_orientation) % 8;
        images.items[grid_offset] = image_data_s.group_image_ids[GROUP_TERRAIN_ENTRY_EXIT_FLAGS] + orientation / 2;
    }
    int exit_orientation;
    if (scenario.exit_point.x == 0) {
        exit_orientation = DIR_2_RIGHT;
    } else if (scenario.exit_point.x == map_data.width - 1) {
        exit_orientation = DIR_6_LEFT;
    } else if (scenario.exit_point.y == 0) {
        exit_orientation = DIR_0_TOP;
    } else if (scenario.exit_point.y == map_data.height - 1) {
        exit_orientation = DIR_4_BOTTOM;
    } else {
        exit_orientation = -1;
    }
    if (exit_orientation >= 0) {
        int grid_offset = map_grid_offset(scenario.exit_point.x, scenario.exit_point.y);
        terrain_grid.items[grid_offset] |= TERRAIN_ROCK;
        int orientation = (view_data.orientation + exit_orientation) % 8;
        images.items[grid_offset] = image_data_s.group_image_ids[GROUP_TERRAIN_ENTRY_EXIT_FLAGS] + 4 + orientation / 2;
    }
}

static void map_tiles_update_all_empty_land(void)
{
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            clear_empty_land_image(x, y, grid_offset);
        }
    }
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            set_empty_land_pass1(x, y, grid_offset);
        }
    }
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            set_empty_land_pass2(x, y, grid_offset);
        }
    }
}

static void set_aqueduct_image(int grid_offset, int is_road, struct terrain_image_t *img)
{
    int group_offset = img->group_offset;
    if (is_road) {
        if (!img->aqueduct_offset || (group_offset != 2 && group_offset != 3)) {
            if (map_terrain_is(grid_offset + map_grid_delta(0, -1), TERRAIN_ROAD)) {
                group_offset = 3;
            } else {
                group_offset = 2;
            }
        }
        if (map_tiles_is_paved_road(grid_offset)) {
            group_offset -= 2;
        } else {
            group_offset += 6;
        }
    }
    int image_aqueduct = image_data_s.group_image_ids[GROUP_BUILDING_AQUEDUCT];
    int water_offset;
    if (images.items[grid_offset] >= image_aqueduct && images.items[grid_offset] < image_aqueduct + 15) {
        water_offset = 0;
    } else {
        water_offset = 15;
    }
    images.items[grid_offset] = image_aqueduct + water_offset + group_offset;
    map_property_set_multi_tile_size(grid_offset, 1);
    edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
}

static void set_tiles_road(int grid_offset, int tiles[MAX_TILES_TERRAIN])
{
    fill_matches(grid_offset, TERRAIN_ROAD, 1, 0, tiles);
    for (int i = 0; i < MAX_TILES_TERRAIN; i += 2) {
        int offset = grid_offset + map_grid_direction_delta(i);
        if (map_terrain_is(offset, TERRAIN_GATEHOUSE)) {
            struct building_t *b = &all_buildings[map_building_at(offset)];
            if (b->type == BUILDING_GATEHOUSE &&
                b->subtype.orientation == 1 + ((i / 2) & 1)) { // 1,2,1,2
                tiles[i] = 1;
            }
        } else if (map_terrain_is(offset, TERRAIN_ACCESS_RAMP)) {
            tiles[i] = 1;
        } else if (map_terrain_is(offset, TERRAIN_BUILDING)) {
            struct building_t *b = &all_buildings[map_building_at(offset)];
            if (b->type == BUILDING_GRANARY) {
                tiles[i] = (offset == b->grid_offset + map_grid_delta(1, 0)) ? 1 : 0;
                tiles[i] |= (offset == b->grid_offset + map_grid_delta(0, 1)) ? 1 : 0;
                tiles[i] |= (offset == b->grid_offset + map_grid_delta(2, 1)) ? 1 : 0;
                tiles[i] |= (offset == b->grid_offset + map_grid_delta(1, 2)) ? 1 : 0;
            }
        }
    }
}

static void set_road_image(__attribute__((unused)) int x, __attribute__((unused)) int y, int grid_offset)
{
    if (!map_terrain_is(grid_offset, TERRAIN_ROAD) ||
        map_terrain_is(grid_offset, TERRAIN_WATER | TERRAIN_BUILDING)) {
        return;
    }
    if (map_terrain_is(grid_offset, TERRAIN_AQUEDUCT)) {
        set_aqueduct_image(grid_offset, 1, map_image_context_get_aqueduct(grid_offset, 0));
        return;
    }
    if (bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
        return;
    }
    if (map_tiles_is_paved_road(grid_offset)) {
        int tiles[MAX_TILES_TERRAIN];
        set_tiles_road(grid_offset, tiles);
        struct terrain_image_t *img = get_image(CONTEXT_PAVED_ROAD, tiles);
        images.items[grid_offset] = image_data_s.group_image_ids[GROUP_TERRAIN_ROAD] + img->group_offset + img->item_offset;
    } else {
        int tiles[MAX_TILES_TERRAIN];
        set_tiles_road(grid_offset, tiles);
        struct terrain_image_t *img = get_image(CONTEXT_DIRT_ROAD, tiles);
        images.items[grid_offset] = image_data_s.group_image_ids[GROUP_TERRAIN_ROAD] + img->group_offset + img->item_offset + 49;
    }
    map_property_set_multi_tile_size(grid_offset, 1);
    edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
}

static void map_tiles_update_all_roads(void)
{
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            set_road_image(x, y, grid_offset);
        }
    }
}

static int is_tile_plaza(int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_ROAD) &&
        bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE &&
        !map_terrain_is(grid_offset, TERRAIN_WATER | TERRAIN_BUILDING) &&
        !images.items[grid_offset]) {
        return 1;
    }
    return 0;
}

static void map_tiles_update_all_plazas(void)
{
    // remove plaza below building
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (map_terrain_is(grid_offset, TERRAIN_ROAD)
                && bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
                if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
                    bitfields_grid.items[grid_offset] &= BIT_NO_PLAZA;
                }
            }
        }
    }
    // clear plaza image
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (map_terrain_is(grid_offset, TERRAIN_ROAD)
                && bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
                images.items[grid_offset] = 0;
                map_property_set_multi_tile_size(grid_offset, 1);
                edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
            }
        }
    }
    // set plaza image
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (map_terrain_is(grid_offset, TERRAIN_ROAD)
                && bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE
                && !images.items[grid_offset]) {
                int image_id = image_data_s.group_image_ids[GROUP_TERRAIN_PLAZA];
                if (is_tile_plaza(grid_offset + map_grid_delta(1, 0))
                && is_tile_plaza(grid_offset + map_grid_delta(0, 1))
                && is_tile_plaza(grid_offset + map_grid_delta(1, 1))) {
                    if (random.items[grid_offset] & 1) {
                        image_id += 7;
                    } else {
                        image_id += 6;
                    }
                    map_building_tiles_add(0, x, y, 2, image_id, TERRAIN_ROAD);
                } else {
                    // single tile plaza
                    switch ((x & 1) + (y & 1)) {
                        case 2: image_id += 1; break;
                        case 1: image_id += 2; break;
                    }
                    images.items[grid_offset] = image_id;
                }
            }
        }
    }
}

static int get_gatehouse_building_id(int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_GATEHOUSE)) {
        return map_building_at(grid_offset);
    }
    return 0;
}

static int get_gatehouse_position(int grid_offset, int direction, int building_id)
{
    int result = 0;
    if (direction == DIR_0_TOP) {
        if (map_terrain_is(grid_offset + map_grid_delta(1, -1), TERRAIN_GATEHOUSE) &&
                map_building_at(grid_offset + map_grid_delta(1, -1)) == building_id) {
            result = 1;
            if (!map_terrain_is(grid_offset + map_grid_delta(1, 0), TERRAIN_WALL)) {
                result = 0;
            }
            if (map_terrain_is(grid_offset + map_grid_delta(-1, 0), TERRAIN_WALL) &&
                map_terrain_is(grid_offset + map_grid_delta(-1, 1), TERRAIN_WALL)) {
                result = 2;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(0, 1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(1, 1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
        } else if (map_terrain_is(grid_offset + map_grid_delta(-1, -1), TERRAIN_GATEHOUSE) &&
                map_building_at(grid_offset + map_grid_delta(-1, -1)) == building_id) {
            result = 3;
            if (!map_terrain_is(grid_offset + map_grid_delta(-1, 0), TERRAIN_WALL)) {
                result = 0;
            }
            if (map_terrain_is(grid_offset + map_grid_delta(1, 0), TERRAIN_WALL) &&
                map_terrain_is(grid_offset + map_grid_delta(1, 1), TERRAIN_WALL)) {
                result = 4;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(0, 1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(-1, 1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
        }
    } else if (direction == DIR_6_LEFT) {
        if (map_terrain_is(grid_offset + map_grid_delta(-1, 1), TERRAIN_GATEHOUSE) &&
                map_building_at(grid_offset + map_grid_delta(-1, 1)) == building_id) {
            result = 1;
            if (!map_terrain_is(grid_offset + map_grid_delta(0, 1), TERRAIN_WALL)) {
                result = 0;
            }
            if (map_terrain_is(grid_offset + map_grid_delta(0, -1), TERRAIN_WALL) &&
                map_terrain_is(grid_offset + map_grid_delta(1, -1), TERRAIN_WALL)) {
                result = 2;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(1, 0), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(1, 1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
        } else if (map_terrain_is(grid_offset + map_grid_delta(-1, -1), TERRAIN_GATEHOUSE) &&
                map_building_at(grid_offset + map_grid_delta(-1, -1)) == building_id) {
            result = 3;
            if (!map_terrain_is(grid_offset + map_grid_delta(0, -1), TERRAIN_WALL)) {
                result = 0;
            }
            if (map_terrain_is(grid_offset + map_grid_delta(0, 1), TERRAIN_WALL) &&
                map_terrain_is(grid_offset + map_grid_delta(1, 1), TERRAIN_WALL)) {
                result = 4;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(1, 0), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(1, -1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
        }
    } else if (direction == DIR_4_BOTTOM) {
        if (map_terrain_is(grid_offset + map_grid_delta(1, 1), TERRAIN_GATEHOUSE) &&
                map_building_at(grid_offset + map_grid_delta(1, 1)) == building_id) {
            result = 1;
            if (!map_terrain_is(grid_offset + map_grid_delta(1, 0), TERRAIN_WALL)) {
                result = 0;
            }
            if (map_terrain_is(grid_offset + map_grid_delta(-1, 0), TERRAIN_WALL) &&
                map_terrain_is(grid_offset + map_grid_delta(-1, -1), TERRAIN_WALL)) {
                result = 2;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(0, -1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(1, -1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
        } else if (map_terrain_is(grid_offset + map_grid_delta(-1, 1), TERRAIN_GATEHOUSE) &&
                map_building_at(grid_offset + map_grid_delta(-1, 1)) == building_id) {
            result = 3;
            if (!map_terrain_is(grid_offset + map_grid_delta(-1, 0), TERRAIN_WALL)) {
                result = 0;
            }
            if (map_terrain_is(grid_offset + map_grid_delta(1, 0), TERRAIN_WALL) &&
                map_terrain_is(grid_offset + map_grid_delta(1, -1), TERRAIN_WALL)) {
                result = 4;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(0, -1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(-1, -1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
        }
    } else if (direction == DIR_2_RIGHT) {
        if (map_terrain_is(grid_offset + map_grid_delta(1, 1), TERRAIN_GATEHOUSE) &&
                map_building_at(grid_offset + map_grid_delta(1, 1)) == building_id) {
            result = 1;
            if (!map_terrain_is(grid_offset + map_grid_delta(0, 1), TERRAIN_WALL)) {
                result = 0;
            }
            if (map_terrain_is(grid_offset + map_grid_delta(0, -1), TERRAIN_WALL) &&
                map_terrain_is(grid_offset + map_grid_delta(-1, -1), TERRAIN_WALL)) {
                result = 2;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(-1, 0), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(-1, 1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
        } else if (map_terrain_is(grid_offset + map_grid_delta(1, -1), TERRAIN_GATEHOUSE) &&
                map_building_at(grid_offset + map_grid_delta(1, -1)) == building_id) {
            result = 3;
            if (!map_terrain_is(grid_offset + map_grid_delta(0, -1), TERRAIN_WALL)) {
                result = 0;
            }
            if (map_terrain_is(grid_offset + map_grid_delta(0, 1), TERRAIN_WALL) &&
                map_terrain_is(grid_offset + map_grid_delta(-1, 1), TERRAIN_WALL)) {
                result = 4;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(-1, 0), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(-1, -1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
        }
    }
    return result;
}

static void set_wall_image(__attribute__((unused)) int x, __attribute__((unused)) int y, int grid_offset)
{
    if (!map_terrain_is(grid_offset, TERRAIN_WALL) ||
        map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
        return;
    }
    int tiles[MAX_TILES_TERRAIN];
    fill_matches(grid_offset, TERRAIN_WALL, 0, 1, tiles);
    struct terrain_image_t *img = get_image(CONTEXT_WALL, tiles);
    images.items[grid_offset] = image_data_s.group_image_ids[GROUP_BUILDING_WALL] + img->group_offset + img->item_offset;
    map_property_set_multi_tile_size(grid_offset, 1);
    edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
    if (map_terrain_count_directly_adjacent_with_type(grid_offset, TERRAIN_GATEHOUSE) > 0) {
        for (int i = 0; i < MAX_TILES_TERRAIN; i += 2) {
            tiles[i] = map_terrain_is(grid_offset + map_grid_direction_delta(i), TERRAIN_WALL_OR_GATEHOUSE) ? 1 : 0;
        }
        img = get_image(CONTEXT_WALL_GATEHOUSE, tiles);
        if (img->is_valid) {
            images.items[grid_offset] = image_data_s.group_image_ids[GROUP_BUILDING_WALL] + img->group_offset + img->item_offset;
        } else {
            int gatehouse_up = get_gatehouse_building_id(grid_offset + map_grid_delta(0, -1));
            int gatehouse_left = get_gatehouse_building_id(grid_offset + map_grid_delta(-1, 0));
            int gatehouse_down = get_gatehouse_building_id(grid_offset + map_grid_delta(0, 1));
            int gatehouse_right = get_gatehouse_building_id(grid_offset + map_grid_delta(1, 0));
            int image_offset = 0;
            int map_orientation = view_data.orientation;
            if (map_orientation == DIR_0_TOP) {
                if (gatehouse_up && !gatehouse_left) {
                    int pos = get_gatehouse_position(grid_offset, DIR_0_TOP, gatehouse_up);
                    if (pos > 0) {
                        if (pos <= 2) {
                            image_offset = 29;
                        } else if (pos == 3) {
                            image_offset = 31;
                        } else {
                            image_offset = 33;
                        }
                    }
                } else if (gatehouse_left && !gatehouse_up) {
                    int pos = get_gatehouse_position(grid_offset, DIR_6_LEFT, gatehouse_left);
                    if (pos > 0) {
                        if (pos <= 2) {
                            image_offset = 30;
                        } else if (pos == 3) {
                            image_offset = 32;
                        } else {
                            image_offset = 33;
                        }
                    }
                }
            } else if (map_orientation == DIR_2_RIGHT) {
                if (gatehouse_up && !gatehouse_right) {
                    int pos = get_gatehouse_position(grid_offset, DIR_0_TOP, gatehouse_up);
                    if (pos > 0) {
                        if (pos == 1) {
                            image_offset = 32;
                        } else if (pos == 2) {
                            image_offset = 33;
                        } else {
                            image_offset = 30;
                        }
                    }
                } else if (gatehouse_right && !gatehouse_up) {
                    int pos = get_gatehouse_position(grid_offset, DIR_2_RIGHT, gatehouse_right);
                    if (pos > 0) {
                        if (pos <= 2) {
                            image_offset = 29;
                        } else if (pos == 3) {
                            image_offset = 31;
                        } else {
                            image_offset = 33;
                        }
                    }
                }
            } else if (map_orientation == DIR_4_BOTTOM) {
                if (gatehouse_down && !gatehouse_right) {
                    int pos = get_gatehouse_position(grid_offset, DIR_4_BOTTOM, gatehouse_down);
                    if (pos > 0) {
                        if (pos == 1) {
                            image_offset = 31;
                        } else if (pos == 2) {
                            image_offset = 33;
                        } else {
                            image_offset = 29;
                        }
                    }
                } else if (gatehouse_right && !gatehouse_down) {
                    int pos = get_gatehouse_position(grid_offset, DIR_2_RIGHT, gatehouse_right);
                    if (pos > 0) {
                        if (pos == 1) {
                            image_offset = 32;
                        } else if (pos == 2) {
                            image_offset = 33;
                        } else {
                            image_offset = 30;
                        }
                    }
                }
            } else if (map_orientation == DIR_6_LEFT) {
                if (gatehouse_down && !gatehouse_left) {
                    int pos = get_gatehouse_position(grid_offset, DIR_4_BOTTOM, gatehouse_down);
                    if (pos > 0) {
                        if (pos <= 2) {
                            image_offset = 30;
                        } else if (pos == 3) {
                            image_offset = 32;
                        } else {
                            image_offset = 33;
                        }
                    }
                } else if (gatehouse_left && !gatehouse_down) {
                    int pos = get_gatehouse_position(grid_offset, DIR_6_LEFT, gatehouse_left);
                    if (pos > 0) {
                        if (pos == 1) {
                            image_offset = 31;
                        } else if (pos == 2) {
                            image_offset = 33;
                        } else {
                            image_offset = 29;
                        }
                    }
                }
            }
            if (image_offset) {
                images.items[grid_offset] = image_data_s.group_image_ids[GROUP_BUILDING_WALL] + image_offset;
            }
        }
    }
}

static void map_tiles_update_all_walls(void)
{
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            set_wall_image(x, y, grid_offset);
        }
    }
}

static void update_aqueduct_tile(__attribute__((unused)) int x, __attribute__((unused)) int y, int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_AQUEDUCT) && aqueduct.items[grid_offset] <= 15) {
        struct terrain_image_t *img = map_image_context_get_aqueduct(grid_offset, aqueduct_include_construction);
        int is_road = map_terrain_is(grid_offset, TERRAIN_ROAD);
        if (is_road) {
            bitfields_grid.items[grid_offset] &= BIT_NO_PLAZA;
        }
        set_aqueduct_image(grid_offset, is_road, img);
        aqueduct.items[grid_offset] = img->aqueduct_offset;
    }
}

static void map_tiles_update_all_aqueducts(int include_construction)
{
    aqueduct_include_construction = include_construction;
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            update_aqueduct_tile(x, y, grid_offset);
        }
    }
    aqueduct_include_construction = 0;
}

static void building_list_small_add(int building_id)
{
    building_list_data.small.items[building_list_data.small.size++] = building_id;
    if (building_list_data.small.size >= MAX_SMALL) {
        building_list_data.small.size = MAX_SMALL - 1;
    }
}

static void city_view_init(void)
{
    calculate_lookup();
    check_camera_boundaries();
    minimap_data.refresh_requested = 1;
}

static int get_next_name(int32_t *field, int offset, int max)
{
    int name = offset + *field;
    *field = *field + 1;
    if (*field >= max) {
        *field = 0;
    }
    return name;
}

static void map_figure_add(struct figure_t *f)
{
    if (!map_grid_is_valid_offset(f->grid_offset)) {
        return;
    }
    f->next_figure_id_on_same_tile = 0;

    if (map_figures.items[f->grid_offset]) {
        struct figure_t *next = &figures[map_figures.items[f->grid_offset]];
        while (next->next_figure_id_on_same_tile) {
            next = &figures[next->next_figure_id_on_same_tile];
        }
        next->next_figure_id_on_same_tile = f->id;
    } else {
        map_figures.items[f->grid_offset] = f->id;
    }
}

static struct figure_t *figure_create(int type, int x, int y, int dir)
{
    int id = 0;
    for (int i = 1; i < MAX_FIGURES; i++) {
        if (!figures[i].in_use) {
            id = i;
            break;
        }
    }
    if (!id) {
        return &figures[0];
    }
    struct figure_t *f = &figures[id];
    f->in_use = 1;
    f->type = type;
    f->speed_multiplier = 1;
    f->direction = dir;
    f->source_x = f->destination_x = f->previous_tile_x = f->x = x;
    f->source_y = f->destination_y = f->previous_tile_y = f->y = y;
    f->grid_offset = map_grid_offset(x, y);
    f->cross_country_x = 15 * x;
    f->cross_country_y = 15 * y;
    f->progress_on_tile = 15;
    f->phrase_sequence_city = f->phrase_sequence_exact = random_data.random1_7bit & 3;
    switch (f->type) {
        case FIGURE_TAX_COLLECTOR:
            f->name_id = get_next_name(&name_data.tax_collector, 132, 32);
            break;
        case FIGURE_ENGINEER:
            f->name_id = get_next_name(&name_data.engineer, 165, 32);
            break;
        case FIGURE_PREFECT:
        case FIGURE_TOWER_SENTRY:
            f->name_id = get_next_name(&name_data.prefect, 198, 32);
            break;
        case FIGURE_ACTOR:
            f->name_id = get_next_name(&name_data.actor, 330, 32);
            break;
        case FIGURE_GLADIATOR:
            f->name_id = get_next_name(&name_data.gladiator, 363, 32);
            break;
        case FIGURE_LION_TAMER:
            f->name_id = get_next_name(&name_data.lion_tamer, 396, 16);
            break;
        case FIGURE_CHARIOTEER:
            f->name_id = get_next_name(&name_data.charioteer, 413, 16);
            break;
        case FIGURE_TRADE_CARAVAN:
        case FIGURE_TRADE_CARAVAN_DONKEY:
            f->name_id = get_next_name(&name_data.trader, 562, 16);
            break;
        case FIGURE_TRADE_SHIP:
        case FIGURE_FISHING_BOAT:
            f->name_id = get_next_name(&name_data.ship, 579, 16);
            break;
        case FIGURE_MARKET_TRADER:
        case FIGURE_MARKET_BUYER:
        case FIGURE_BATHHOUSE_WORKER:
            f->name_id = get_next_name(&name_data.citizen_female, 99, 32);
            break;
        case FIGURE_PRIEST:
        case FIGURE_TEACHER:
        case FIGURE_MISSIONARY:
        case FIGURE_LIBRARIAN:
        case FIGURE_DOCTOR:
        case FIGURE_SURGEON:
        case FIGURE_PATRICIAN:
            f->name_id = get_next_name(&name_data.patrician, 66, 32);
            break;
        case FIGURE_FORT_JAVELIN:
        case FIGURE_ENEMY_CAESAR_JAVELIN:
            f->name_id = get_next_name(&name_data.javelin_thrower, 231, 32);
            break;
        case FIGURE_FORT_MOUNTED:
        case FIGURE_ENEMY_CAESAR_MOUNTED:
            f->name_id = get_next_name(&name_data.cavalry, 264, 32);
            break;
        case FIGURE_FORT_LEGIONARY:
        case FIGURE_ENEMY_CAESAR_LEGIONARY:
            f->name_id = get_next_name(&name_data.legionary, 297, 32);
            break;
        case FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN:
        case FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT:
        case FIGURE_ENEMY_NUMIDIAN_SWORDSMAN:
        case FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER:
        case FIGURE_ENEMY_PERGAMUM_SWORDSMAN:
        case FIGURE_ENEMY_PERGAMUM_ARCHER:
            f->name_id = get_next_name(&name_data.enemy_arabian, 529, 32);
            break;
        case FIGURE_ENEMY_EGYPTIAN_SWORDSMAN:
        case FIGURE_ENEMY_EGYPTIAN_CAMEL:
            f->name_id = get_next_name(&name_data.enemy_egyptian, 496, 32);
            break;
        case FIGURE_ENEMY_ETRUSCAN_SWORDSMAN:
        case FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER:
        case FIGURE_ENEMY_SAMNITE_SWORDSMAN:
        case FIGURE_ENEMY_SAMNITE_SPEAR_THROWER:
            f->name_id = get_next_name(&name_data.prefect, 198, 32);
            break;
        case FIGURE_ENEMY_GREEK_SWORDSMAN:
        case FIGURE_ENEMY_GREEK_SPEAR_THROWER:
        case FIGURE_ENEMY_MACEDONIAN_SWORDSMAN:
        case FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER:
            f->name_id = get_next_name(&name_data.enemy_greek, 463, 32);
            break;
        case FIGURE_INDIGENOUS_NATIVE:
        case FIGURE_NATIVE_TRADER:
        case FIGURE_ENEMY_BARBARIAN_SWORDSMAN:
        case FIGURE_ENEMY_BRITON_SWORDSMAN:
        case FIGURE_ENEMY_BRITON_CHARIOT:
        case FIGURE_ENEMY_CELT_SWORDSMAN:
        case FIGURE_ENEMY_CELT_CHARIOT:
        case FIGURE_ENEMY_PICT_SWORDSMAN:
        case FIGURE_ENEMY_PICT_CHARIOT:
        case FIGURE_ENEMY_GAUL_SWORDSMAN:
        case FIGURE_ENEMY_GAUL_AXEMAN:
        case FIGURE_ENEMY_HELVETIUS_SWORDSMAN:
        case FIGURE_ENEMY_HELVETIUS_AXEMAN:
        case FIGURE_ENEMY_HUN_SWORDSMAN:
        case FIGURE_ENEMY_HUN_MOUNTED_ARCHER:
        case FIGURE_ENEMY_GOTH_SWORDSMAN:
        case FIGURE_ENEMY_GOTH_MOUNTED_ARCHER:
        case FIGURE_ENEMY_VISIGOTH_SWORDSMAN:
        case FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER:
        case FIGURE_ENEMY_IBERIAN_SWORDSMAN:
        case FIGURE_ENEMY_IBERIAN_SPEAR_THROWER:
        case FIGURE_ENEMY_JUDEAN_SWORDSMAN:
        case FIGURE_ENEMY_JUDEAN_SPEAR_THROWER:
        case FIGURE_ENEMY_SELEUCID_SWORDSMAN:
        case FIGURE_ENEMY_SELEUCID_SPEAR_THROWER:
            f->name_id = get_next_name(&name_data.barbarian, 430, 32);
            break;
        case FIGURE_EXPLOSION:
        case FIGURE_FORT_STANDARD:
        case FIGURE_FISH_GULLS:
        case FIGURE_HIPPODROME_HORSES:
            f->name_id = 0;
            break;
        case FIGURE_SCHOOL_CHILD:
        case FIGURE_DELIVERY_BOY:
        case FIGURE_BARBER:
        default:
            f->name_id = get_next_name(&name_data.citizen_male, 1, 64);
            break;
    }
    map_figure_add(f);
    if (type == FIGURE_TRADE_CARAVAN || type == FIGURE_TRADE_SHIP) {
        int trader_id = figure_trader_data.next_index++;
        if (figure_trader_data.next_index >= MAX_TRADERS) {
            figure_trader_data.next_index = 0;
        }
        memset(&figure_trader_data.traders[trader_id], 0, sizeof(struct trader));
        f->trader_id = trader_id;
    }
    return f;
}

static void figure_movement_set_cross_country_direction(struct figure_t *f, int x_src, int y_src, int x_dst, int y_dst, int is_missile)
{
    // all x/y are in 1/15th of a tile
    f->cc_destination_x = x_dst;
    f->cc_destination_y = y_dst;
    f->cc_delta_x = (x_src > x_dst) ? (x_src - x_dst) : (x_dst - x_src);
    f->cc_delta_y = (y_src > y_dst) ? (y_src - y_dst) : (y_dst - y_src);
    if (f->cc_delta_x < f->cc_delta_y) {
        f->cc_delta_xy = 2 * f->cc_delta_x - f->cc_delta_y;
    } else if (f->cc_delta_y < f->cc_delta_x) {
        f->cc_delta_xy = 2 * f->cc_delta_y - f->cc_delta_x;
    } else { // equal
        f->cc_delta_xy = 0;
    }
    if (is_missile) {
        int dx = x_src > x_dst ? x_src - x_dst : x_dst - x_src;
        int dy = y_src > y_dst ? y_src - y_dst : y_dst - y_src;
        int percentage;
        if (dx > dy) {
            percentage = calc_percentage(dx, dy);
        } else if (dx == dy) {
            percentage = 100;
        } else {
            percentage = -calc_percentage(dy, dx);
        }
        if (x_src == x_dst) {
            if (y_src < y_dst) {
                f->direction = 8;
            } else {
                f->direction = 0;
            }
        } else if (x_src > x_dst) {
            if (y_src == y_dst) {
                f->direction = 12;
            } else if (y_src > y_dst) {
                if (percentage >= 500) {
                    f->direction = 12;
                } else if (percentage >= 200) {
                    f->direction = 13;
                } else if (percentage > -200) {
                    f->direction = 14;
                } else if (percentage > -500) {
                    f->direction = 15;
                } else {
                    f->direction = 0;
                }
            } else {
                if (percentage >= 500) {
                    f->direction = 12;
                } else if (percentage >= 200) {
                    f->direction = 11;
                } else if (percentage > -200) {
                    f->direction = 10;
                } else if (percentage > -500) {
                    f->direction = 9;
                } else {
                    f->direction = 8;
                }
            }
        } else { // x_from < x_to
            if (y_src == y_dst) {
                f->direction = 4;
            } else if (y_src > y_dst) {
                if (percentage >= 500) {
                    f->direction = 4;
                } else if (percentage >= 200) {
                    f->direction = 3;
                } else if (percentage > -200) {
                    f->direction = 2;
                } else if (percentage > -500) {
                    f->direction = 1;
                } else {
                    f->direction = 0;
                }
            } else {
                if (percentage >= 500) {
                    f->direction = 4;
                } else if (percentage >= 200) {
                    f->direction = 5;
                } else if (percentage > -200) {
                    f->direction = 6;
                } else if (percentage > -500) {
                    f->direction = 7;
                } else {
                    f->direction = 8;
                }
            }
        }
    } else {
        f->direction = calc_general_direction(x_src, y_src, x_dst, y_dst);
        if (f->cc_delta_y > 2 * f->cc_delta_x) {
            switch (f->direction) {
                case DIR_1_TOP_RIGHT: case DIR_7_TOP_LEFT: f->direction = DIR_0_TOP; break;
                case DIR_3_BOTTOM_RIGHT: case DIR_5_BOTTOM_LEFT: f->direction = DIR_4_BOTTOM; break;
            }
        }
        if (f->cc_delta_x > 2 * f->cc_delta_y) {
            switch (f->direction) {
                case DIR_1_TOP_RIGHT: case DIR_3_BOTTOM_RIGHT: f->direction = DIR_2_RIGHT; break;
                case DIR_5_BOTTOM_LEFT: case DIR_7_TOP_LEFT: f->direction = DIR_6_LEFT; break;
            }
        }
    }
    if (f->cc_delta_x >= f->cc_delta_y) {
        f->cc_direction = 1;
    } else {
        f->cc_direction = 2;
    }
}

static void add_figure_to_formation(struct figure_t *f, struct formation_t *m)
{
    for (int i = 0; i < m->max_figures; i++) {
        if (!m->figures[i]) {
            m->figures[i] = f->id;
            m->num_figures++;
            f->index_in_formation = i;
            return;
        }
    }
}

static int figure_is_alive(struct figure_t *f)
{
    return f->in_use && !f->is_corpse;
}

static void map_figure_delete(struct figure_t *f)
{
    if (!map_grid_is_valid_offset(f->grid_offset) || !map_figures.items[f->grid_offset]) {
        f->next_figure_id_on_same_tile = 0;
        return;
    }

    if (map_figures.items[f->grid_offset] == f->id) {
        map_figures.items[f->grid_offset] = f->next_figure_id_on_same_tile;
    } else {
        struct figure_t *prev = &figures[map_figures.items[f->grid_offset]];
        while (prev->id && prev->next_figure_id_on_same_tile != f->id) {
            prev = &figures[prev->next_figure_id_on_same_tile];
        }
        prev->next_figure_id_on_same_tile = f->next_figure_id_on_same_tile;
    }
    f->next_figure_id_on_same_tile = 0;
}

static void figure_delete(struct figure_t *f)
{
    struct building_t *b = &all_buildings[f->building_id];
    switch (f->type) {
        case FIGURE_LABOR_SEEKER:
        case FIGURE_MARKET_BUYER:
            if (f->building_id) {
                b->figure_id2 = 0;
            }
            break;
        case FIGURE_BALLISTA:
            b->figure_id4 = 0;
            break;
        case FIGURE_DOCKER:
            for (int i = 0; i < 3; i++) {
                if (b->data.dock.docker_ids[i] == f->id) {
                    b->data.dock.docker_ids[i] = 0;
                }
            }
            break;
        default:
            if (f->building_id) {
                b->figure_id = 0;
            }
            break;
    }
    if (f->empire_city_id) {
        // remove trader
        for (int i = 0; i < 3; i++) {
            if (empire_objects[f->empire_city_id].trader_figure_ids[i] == f->id) {
                empire_objects[f->empire_city_id].trader_figure_ids[i] = 0;
            }
        }
    }
    if (f->immigrant_building_id) {
        b->immigrant_figure_id = 0;
    }
    struct formation_t *m = 0;
    // adjust unit-related counters
    if (figure_properties[f->type].is_player_legion_unit) {
        m = &legion_formations[f->formation_id];
        city_data.figure.soldiers--;
        if (f->type == FIGURE_FORT_LEGIONARY) {
            city_data.military.legionary_legions--;
        }
    } else if (f->type == FIGURE_RIOTER) {
        city_data.figure.rioters--;
    } else if (figure_properties[f->type].is_herd_animal) {
        m = &herd_formations[f->formation_id];
        city_data.figure.animals--;
    } else if (figure_properties[f->type].is_enemy_unit) {
        m = &enemy_formations[f->formation_id];
        city_data.figure.enemies--;
    } else if (figure_properties[f->type].is_caesar_legion_unit) {
        m = &enemy_formations[f->formation_id];
        city_data.figure.imperial_soldiers--;
        city_data.emperor.invasion.soldiers_killed++;
    }
    if (m) {  // refresh unit formation indexes and formation figures number
        for (int i = 0; i < m->num_figures; i++) {
            m->figures[i] = 0;
        }
        m->num_figures = 0;
        for (int i = 1; i < MAX_FIGURES; i++) {
            struct figure_t *unit = &figures[i];
            if (figure_is_alive(unit) && unit->type == m->figure_type && unit->formation_id == m->id) {
                for (int j = 0; j < m->max_figures; j++) {
                    if (!m->figures[j]) {
                        m->figures[j] = unit->id;
                        m->num_figures++;
                        unit->index_in_formation = j;
                        break;
                    }
                }
            }
        }
        if (!m->num_figures) { // non-legion formation empty, clear it
            if (figure_properties[f->type].is_herd_animal || figure_properties[f->type].is_enemy_unit || figure_properties[f->type].is_caesar_legion_unit) {
                memset(m, 0, sizeof(struct formation_t));
                m->id = f->formation_id;
            }
        }
    }
    figure_route_remove(f);
    map_figure_delete(f);
    int figure_id = f->id;
    memset(f, 0, sizeof(struct figure_t));
    f->id = figure_id;
}

static void figure_create_flotsam(void)
{
    if (scenario.river_entry_point.x == -1 || scenario.river_entry_point.y == -1 || scenario.river_exit_point.x == -1 || scenario.river_exit_point.y == -1 || !scenario.flotsam_enabled) {
        return;
    }
    for (int i = 1; i < MAX_FIGURES; i++) {
        struct figure_t *f = &figures[i];
        if (figure_is_alive(f) && f->type == FIGURE_FLOTSAM) {
            figure_delete(f);
        }
    }

    for (int i = 0; i < 20; i++) {
        struct figure_t *f = figure_create(FIGURE_FLOTSAM, scenario.river_entry_point.x, scenario.river_entry_point.y, DIR_0_TOP);
        f->terrain_usage = TERRAIN_USAGE_ANY;
        f->action_state = FIGURE_ACTION_FLOTSAM_CREATED;
        f->resource_id = FLOTSAM_RESOURCE_IDS[i];
        f->wait_ticks = FLOTSAM_WAIT_TICKS[i];
    }
}

static void map_routing_update_land_citizen(void)
{
    memset(terrain_land_citizen.items, -1, GRID_SIZE * GRID_SIZE * sizeof(int8_t));
    int grid_offset = map_data.start_offset;
    for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (terrain_grid.items[grid_offset] & TERRAIN_ROAD) {
                terrain_land_citizen.items[grid_offset] = CITIZEN_0_ROAD;
            } else if (terrain_grid.items[grid_offset] & (TERRAIN_RUBBLE | TERRAIN_ACCESS_RAMP | TERRAIN_GARDEN)) {
                terrain_land_citizen.items[grid_offset] = CITIZEN_2_PASSABLE_TERRAIN;
            } else if (terrain_grid.items[grid_offset] & (TERRAIN_BUILDING | TERRAIN_GATEHOUSE)) {
                if (!map_building_at(grid_offset)) {
                    // shouldn't happen
                    terrain_land_noncitizen.items[grid_offset] = CITIZEN_4_CLEAR_TERRAIN; // BUG: should be citizen?
                    terrain_grid.items[grid_offset] &= ~TERRAIN_BUILDING;
                    images.items[grid_offset] = (random.items[grid_offset] & 7) + image_data_s.group_image_ids[GROUP_TERRAIN_GRASS_1];
                    edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
                    map_property_set_multi_tile_size(grid_offset, 1);
                    continue;
                }
                struct building_t *b = &all_buildings[map_building_at(grid_offset)];
                switch (b->type) {
                    case BUILDING_WAREHOUSE:
                    case BUILDING_GATEHOUSE:
                        terrain_land_citizen.items[grid_offset] = CITIZEN_0_ROAD;
                        break;
                    case BUILDING_FORT_GROUND:
                        terrain_land_citizen.items[grid_offset] = CITIZEN_2_PASSABLE_TERRAIN;
                        break;
                    case BUILDING_TRIUMPHAL_ARCH:
                        if (b->subtype.orientation == 3) {
                            switch (edge_grid.items[grid_offset] & EDGE_MASK_XY) {
                                case EDGE_X0Y1:
                                case EDGE_X1Y1:
                                case EDGE_X2Y1:
                                    terrain_land_citizen.items[grid_offset] = CITIZEN_0_ROAD;
                                    break;
                            }
                        } else {
                            switch (edge_grid.items[grid_offset] & EDGE_MASK_XY) {
                                case EDGE_X1Y0:
                                case EDGE_X1Y1:
                                case EDGE_X1Y2:
                                    terrain_land_citizen.items[grid_offset] = CITIZEN_0_ROAD;
                                    break;
                            }
                        }
                        break;
                    case BUILDING_GRANARY:
                        switch (edge_grid.items[grid_offset] & EDGE_MASK_XY) {
                            case EDGE_X1Y0:
                            case EDGE_X0Y1:
                            case EDGE_X1Y1:
                            case EDGE_X2Y1:
                            case EDGE_X1Y2:
                                terrain_land_citizen.items[grid_offset] = CITIZEN_0_ROAD;
                                break;
                        }
                        break;
                    case BUILDING_RESERVOIR:
                        switch (edge_grid.items[grid_offset] & EDGE_MASK_XY) {
                            case EDGE_X1Y0:
                            case EDGE_X0Y1:
                            case EDGE_X2Y1:
                            case EDGE_X1Y2:
                                terrain_land_citizen.items[grid_offset] = CITIZEN_N4_RESERVOIR_CONNECTOR; // aqueduct connect points
                                break;
                        }
                        break;
                    default:
                        terrain_land_citizen.items[grid_offset] = CITIZEN_N1_BLOCKED;
                        break;
                }
            } else if (terrain_grid.items[grid_offset] & TERRAIN_AQUEDUCT) {
                int image_id = images.items[grid_offset] - image_data_s.group_image_ids[GROUP_BUILDING_AQUEDUCT];
                if (image_id <= 3) {
                    terrain_land_citizen.items[grid_offset] = CITIZEN_N3_AQUEDUCT;
                } else if (image_id <= 7) {
                    terrain_land_citizen.items[grid_offset] = CITIZEN_N1_BLOCKED;
                } else if (image_id <= 9) {
                    terrain_land_citizen.items[grid_offset] = CITIZEN_N3_AQUEDUCT;
                } else if (image_id <= 14) {
                    terrain_land_citizen.items[grid_offset] = CITIZEN_N1_BLOCKED;
                } else if (image_id <= 18) {
                    terrain_land_citizen.items[grid_offset] = CITIZEN_N3_AQUEDUCT;
                } else if (image_id <= 22) {
                    terrain_land_citizen.items[grid_offset] = CITIZEN_N1_BLOCKED;
                } else if (image_id <= 24) {
                    terrain_land_citizen.items[grid_offset] = CITIZEN_N3_AQUEDUCT;
                } else {
                    terrain_land_citizen.items[grid_offset] = CITIZEN_N1_BLOCKED;
                }
            } else if (terrain_grid.items[grid_offset] & TERRAIN_NOT_CLEAR) {
                terrain_land_citizen.items[grid_offset] = CITIZEN_N1_BLOCKED;
            } else {
                terrain_land_citizen.items[grid_offset] = CITIZEN_4_CLEAR_TERRAIN;
            }
        }
    }
}

static void map_routing_update_land(void)
{
    map_routing_update_land_citizen();
    memset(terrain_land_noncitizen.items, -1, GRID_SIZE * GRID_SIZE * sizeof(int8_t));
    int grid_offset = map_data.start_offset;
    for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (terrain_grid.items[grid_offset] & TERRAIN_GATEHOUSE) {
                terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_4_GATEHOUSE;
            } else if (terrain_grid.items[grid_offset] & TERRAIN_ROAD) {
                terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_0_PASSABLE;
            } else if (terrain_grid.items[grid_offset] & (TERRAIN_GARDEN | TERRAIN_ACCESS_RAMP | TERRAIN_RUBBLE)) {
                terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_2_CLEARABLE;
            } else if (terrain_grid.items[grid_offset] & TERRAIN_BUILDING) {
                switch (all_buildings[map_building_at(grid_offset)].type) {
                    case BUILDING_WAREHOUSE:
                    case BUILDING_FORT_GROUND:
                        terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_0_PASSABLE;
                        break;
                    case BUILDING_BURNING_RUIN:
                    case BUILDING_NATIVE_HUT:
                    case BUILDING_NATIVE_MEETING:
                    case BUILDING_NATIVE_CROPS:
                        terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_N1_BLOCKED;
                        break;
                    case BUILDING_FORT_LEGIONARIES:
                    case BUILDING_FORT_JAVELIN:
                    case BUILDING_FORT_MOUNTED:
                        terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_5_FORT;
                        break;
                    case BUILDING_GRANARY:
                        switch (edge_grid.items[grid_offset] & EDGE_MASK_XY) {
                            case EDGE_X1Y0:
                            case EDGE_X0Y1:
                            case EDGE_X1Y1:
                            case EDGE_X2Y1:
                            case EDGE_X1Y2:
                                terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_0_PASSABLE;
                                break;
                        }
                        break;
                    default:
                        terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_1_BUILDING;
                        break;
                }
            } else if (terrain_grid.items[grid_offset] & TERRAIN_AQUEDUCT) {
                terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_2_CLEARABLE;
            } else if (terrain_grid.items[grid_offset] & TERRAIN_WALL) {
                terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_3_WALL;
            } else if (terrain_grid.items[grid_offset] & TERRAIN_NOT_CLEAR) {
                terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_N1_BLOCKED;
            } else {
                terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_0_PASSABLE;
            }
        }
    }
}

static void map_routing_update_water(void)
{
    memset(terrain_water.items, -1, GRID_SIZE * GRID_SIZE * sizeof(int8_t));
    int grid_offset = map_data.start_offset;
    for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (map_terrain_is(grid_offset, TERRAIN_WATER)
            && map_terrain_is(grid_offset + map_grid_delta(0, -1), TERRAIN_WATER)
            && map_terrain_is(grid_offset + map_grid_delta(-1, 0), TERRAIN_WATER)
            && map_terrain_is(grid_offset + map_grid_delta(1, 0), TERRAIN_WATER)
            && map_terrain_is(grid_offset + map_grid_delta(0, 1), TERRAIN_WATER)) {
                if (x > 0 && x < map_data.width - 1 &&
                    y > 0 && y < map_data.height - 1) {
                    switch (sprite.items[grid_offset]) {
                        case 5:
                        case 6: // low bridge middle section
                            terrain_water.items[grid_offset] = WATER_N3_LOW_BRIDGE;
                            break;
                        case 13: // ship bridge pillar
                            terrain_water.items[grid_offset] = WATER_N1_BLOCKED;
                            break;
                        default:
                            terrain_water.items[grid_offset] = WATER_0_PASSABLE;
                            break;
                    }
                } else {
                    terrain_water.items[grid_offset] = WATER_N2_MAP_EDGE;
                }
            } else {
                terrain_water.items[grid_offset] = WATER_N1_BLOCKED;
            }
        }
    }
}

static int is_wall_tile(int grid_offset)
{
    return map_terrain_is(grid_offset, TERRAIN_WALL_OR_GATEHOUSE) ? 1 : 0;
}

static void map_routing_update_walls(void)
{
    memset(terrain_walls.items, -1, GRID_SIZE * GRID_SIZE * sizeof(int8_t));
    int grid_offset = map_data.start_offset;
    for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (map_terrain_is(grid_offset, TERRAIN_WALL)) {
                int adjacent_wall_tiles = 0;
                switch (view_data.orientation) {
                    case DIR_0_TOP:
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(0, 1));
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(1, 1));
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(1, 0));
                        break;
                    case DIR_2_RIGHT:
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(0, 1));
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(-1, 1));
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(-1, 0));
                        break;
                    case DIR_4_BOTTOM:
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(0, -1));
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(-1, -1));
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(-1, 0));
                        break;
                    case DIR_6_LEFT:
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(0, -1));
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(1, -1));
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(1, 0));
                        break;
                }
                if (adjacent_wall_tiles == 3) {
                    terrain_walls.items[grid_offset] = WALL_0_PASSABLE;
                } else {
                    terrain_walls.items[grid_offset] = WALL_N1_BLOCKED;
                }
            } else if (map_terrain_is(grid_offset, TERRAIN_GATEHOUSE)) {
                terrain_walls.items[grid_offset] = WALL_0_PASSABLE;
            } else {
                terrain_walls.items[grid_offset] = WALL_N1_BLOCKED;
            }
        }
    }
}

static void map_routing_update_all(void)
{
    map_routing_update_land();
    map_routing_update_water();
    map_routing_update_walls();
}

static void set_message_parameters(struct lang_message_t *m, char *title, char *text, int urgent, int message_type)
{
    m->type = TYPE_MESSAGE;
    m->message_type = message_type;
    m->x = 0;
    m->y = 0;
    m->width_blocks = 30;
    m->height_blocks = 20;
    m->title.x = 0;
    m->title.y = 0;
    m->urgent = urgent;
    m->title.text = title;
    m->content.text = text;
}

static void city_military_determine_distant_battle_city(void)
{
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        if (empire_objects[i].in_use && empire_objects[i].city_type == EMPIRE_CITY_VULNERABLE_ROMAN) {
            city_data.distant_battle.city = i;
        }
    }
}

static int read_file_into_buffer(char *filepath, void *buffer, int max_size, int is_binary)
{
    FILE *fp;
    if (is_binary) {
        fp = fopen(filepath, "rb");
    } else {
        fp = fopen(filepath, "r");
    }
    if (!fp) {
        return 0;
    }
    fseek(fp, 0, SEEK_END);
    long size = ftell(fp);
    if (size > max_size) {
        size = max_size;
    }
    fseek(fp, 0, SEEK_SET);
    int bytes_read = (int) fread(buffer, 1, (size_t) size, fp);
    fclose(fp);
    return bytes_read;
}

static int8_t buffer_read_i8(struct buffer_t *buf)
{
    if (check_size(buf, 1)) {
        return (int8_t) buf->data[buf->index++];
    } else {
        return 0;
    }
}

static void read_index(struct buffer_t *buf, struct image_t *images, int size)
{
    for (int i = 0; i < size; i++) {
        images[i].draw.offset = buffer_read_i32(buf);
        images[i].draw.data_length = buffer_read_i32(buf);
        images[i].draw.uncompressed_length = buffer_read_i32(buf);
        buf->index += 8;
        images[i].width = buffer_read_u16(buf);
        images[i].height = buffer_read_u16(buf);
        buf->index += 6;
        images[i].num_animation_sprites = buffer_read_u16(buf);
        buf->index += 2;
        images[i].sprite_offset_x = buffer_read_i16(buf);
        images[i].sprite_offset_y = buffer_read_i16(buf);
        buf->index += 10;
        images[i].animation_can_reverse = buffer_read_i8(buf);
        buf->index += 1;
        images[i].draw.type = buffer_read_u8(buf);
        images[i].draw.is_fully_compressed = buffer_read_i8(buf);
        images[i].draw.is_external = buffer_read_i8(buf);
        images[i].draw.has_compressed_part = buffer_read_i8(buf);
        buf->index += 2;
        images[i].draw.bitmap_id = buffer_read_u8(buf);
        buf->index += 1;
        images[i].animation_speed_id = buffer_read_u8(buf);
        buf->index += 5;
    }
    int offset = 4;
    for (int i = 1; i < size; i++) {
        struct image_t *img = &images[i];
        if (img->draw.is_external) {
            if (!img->draw.offset) {
                img->draw.offset = 1;
            }
        } else {
            img->draw.offset = offset;
            offset += img->draw.data_length;
        }
    }
}

static void convert_images(struct image_t *images, int size, struct buffer_t *buf, color_t *dst)
{
    color_t *start_dst = dst;
    dst++; // make sure img->offset > 0
    for (int i = 0; i < size; i++) {
        struct image_t *img = &images[i];
        if (img->draw.is_external) {
            continue;
        }
        buf->index = img->draw.offset;
        int img_offset = (int) (dst - start_dst);
        if (img->draw.is_fully_compressed) {
            dst += convert_compressed(buf, img->draw.data_length, dst);
        } else if (img->draw.has_compressed_part) { // isometric tile
            dst += convert_uncompressed(buf, img->draw.uncompressed_length, dst);
            dst += convert_compressed(buf, img->draw.data_length - img->draw.uncompressed_length, dst);
        } else {
            dst += convert_uncompressed(buf, img->draw.data_length, dst);
        }
        img->draw.offset = img_offset;
        img->draw.uncompressed_length /= 2;
    }
}

static int image_load_climate(int climate_id, int is_editor, int force_reload)
{
    if (climate_id == image_data_s.current_climate && is_editor == image_data_s.is_editor && !force_reload) {
        return 1;
    }
    char *filename_bmp = is_editor ? EDITOR_GRAPHICS_555[climate_id] : MAIN_GRAPHICS_555[climate_id];
    char *filename_idx = is_editor ? EDITOR_GRAPHICS_SG2[climate_id] : MAIN_GRAPHICS_SG2[climate_id];
    if (MAIN_INDEX_SIZE != read_file_into_buffer(filename_idx, image_data_s.tmp_data, MAIN_INDEX_SIZE, 1)) {
        return 0;
    }
    struct buffer_t buf;
    buffer_init(&buf, image_data_s.tmp_data, HEADER_SIZE_EMPIRE);
    buf.index += 80; // header integers
    for (int i = 0; i < 300; i++) {
        image_data_s.group_image_ids[i] = buffer_read_u16(&buf);
    }
    buffer_read_raw(&buf, image_data_s.bitmaps, 20000);
    buffer_init(&buf, &image_data_s.tmp_data[HEADER_SIZE_EMPIRE], ENTRY_SIZE * MAIN_ENTRIES);
    read_index(&buf, image_data_s.main, MAIN_ENTRIES);
    int data_size = read_file_into_buffer(filename_bmp, image_data_s.tmp_data, SCRATCH_DATA_SIZE, 1);
    if (!data_size) {
        return 0;
    }
    buffer_init(&buf, image_data_s.tmp_data, data_size);
    convert_images(image_data_s.main, MAIN_ENTRIES, &buf, image_data_s.main_data);
    image_data_s.current_climate = climate_id;
    image_data_s.is_editor = is_editor;
    int size = read_file_into_buffer(EMPIRE_555, image_data_s.tmp_data, EMPIRE_IMAGE_DATA_SIZE, 1);
    if (size != EMPIRE_IMAGE_DATA_SIZE / 2) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("unable to load empire data", EMPIRE_555, 0));
        return 0;
    }
    buffer_init(&buf, image_data_s.tmp_data, size);
    convert_uncompressed(&buf, size, image_data_s.empire_data);
    return 1;
}

static void city_data_init_scenario(void)
{
    city_data.finance.treasury = scenario.initial_funds;
    city_data.finance.last_year.balance = city_data.finance.treasury;
}

static void city_emperor_set_salary_rank(int player_rank)
{
    city_data.emperor.salary_rank = player_rank;
    city_data.emperor.salary_amount = SALARY_FOR_RANK[player_rank];
}

static void map_submenu_items(int menu_index, int submenu_index, int submenu_string_index)
{
    build_menus[menu_index].menu_items[submenu_index].submenu_string = submenu_strings[submenu_string_index];
    for (int k = 0; k < MAX_ITEMS_PER_SUBMENU; k++) {
        if (scenario.allowed_buildings[BUILDING_MENU_SUBMENU_ITEM_MAPPING[menu_index][submenu_index][k]]) {
            build_menus[menu_index].is_enabled = 1;
            build_menus[menu_index].menu_items[submenu_index].building_id = -1; // submenu is enabled (negative number to avoid conflict with actual building types)
            build_menus[menu_index].menu_items[submenu_index].submenu_items[k] = BUILDING_MENU_SUBMENU_ITEM_MAPPING[menu_index][submenu_index][k];
        }
    }
}

static void map_building_menu_items(void)
{
    // reset values so as to not carry over between maps
    for (int i = 0; i < BUILD_MENU_BUTTONS_COUNT; i++) {
        memset(&build_menus[i], 0, sizeof(struct build_menu_t));
    }
    for (int i = 0; i < BUILD_MENU_BUTTONS_COUNT; i++) {
        for (int j = 0; j < MAX_ITEMS_PER_BUILD_MENU; j++) {
            if (i == 5 && j == 0) { // small temples
                map_submenu_items(i, j, 0);
            } else if (i == 5 && j == 1) { // large temples
                map_submenu_items(i, j, 1);
            } else if (i == 10 && j == 4) { // forts
                map_submenu_items(i, j, 2);
            } else if (i == 11 && j == 0) { // farms
                map_submenu_items(i, j, 3);
            } else if (i == 11 && j == 1) { // raw materials
                map_submenu_items(i, j, 4);
            } else if (i == 11 && j == 2) { // workshops
                map_submenu_items(i, j, 5);
            } else {
                if (scenario.allowed_buildings[BUILDING_MENU_SUBMENU_ITEM_MAPPING[i][j][0]] && BUILDING_MENU_SUBMENU_ITEM_MAPPING[i][j][0] != BUILDING_TRIUMPHAL_ARCH) {
                    build_menus[i].is_enabled = 1;
                    build_menus[i].menu_items[j].building_id = BUILDING_MENU_SUBMENU_ITEM_MAPPING[i][j][0];
                }
            }
        }
    }
}

static void building_construction_clear_type(void)
{
    construction_data.cost_preview = 0;
    construction_data.type = BUILDING_NONE;
}

static int game_file_start_scenario(char *scenario_selected)
{
    // assume scenario can be passed in with or without .map extension
    char scenario_file[FILE_NAME_MAX];
    string_copy(scenario_selected, scenario_file, FILE_NAME_MAX - 1);
    if (!file_has_extension(scenario_file, "map")) {
        file_append_extension(scenario_file, "map");

    }
    if (!file_exists(MAPS_DIR_PATH, scenario_file)) {
        return 0;
    }
    for (int i = 0; i < MAX_BOOKMARKS; i++) {
        bookmarks[i].x = -1;
        bookmarks[i].y = -1;
    }
    city_victory_reset();
    building_construction_clear_type();
    city_data_init();
    city_message_init_scenario();
    game_state_init();
    game_animation_init();
    initialize_city_sounds();
    building_clear_all();
    memset(storages, 0, MAX_STORAGES * sizeof(struct data_storage));
    figure_init_scenario();
    figure_name_init();
    reset_all_formations();
    figure_route_clear_all();
    game_time_init(2098);
    memset(images.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
    map_building_clear();
    memset(terrain_grid.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
    memset(aqueduct.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memset(map_figures.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
    map_property_clear();
    memset(sprite.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memset(random.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memset(desirability_grid.items, 0, GRID_SIZE * GRID_SIZE * sizeof(int8_t));
    memset(terrain_elevation.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memset(network.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    for (int i = 0; i < CONTEXT_MAX_ITEMS; i++) {
        clear_current_offset(context_pointers[i].context, context_pointers[i].size);
    }
    map_random_init();
    if (!game_file_load_scenario_data(scenario_file)) {
        return 0;
    }
    // reset trade prices
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        trade_prices[i] = DEFAULT_PRICES[i];
    }
    if (file_has_extension(scenario_file, "map")) {
        file_remove_extension(scenario_file);
    }
    string_copy(scenario_file, scenario.scenario_name, MAX_SCENARIO_NAME);
    map_grid_init(scenario.map.width, scenario.map.height, scenario.map.grid_start, scenario.map.grid_border_size);
    map_tiles_update_all_elevation();
    map_tiles_update_all_earthquake();
    map_tiles_add_entry_exit_flags();
    map_tiles_update_all_empty_land();
    map_tiles_update_all_roads();
    map_tiles_update_all_plazas();
    map_tiles_update_all_walls();
    map_tiles_update_all_aqueducts(0);
    int meeting_center_set = 0;
    int native_image = image_data_s.group_image_ids[GROUP_BUILDING_NATIVE];
    int grid_offset = map_data.start_offset;
    for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (!map_terrain_is(grid_offset, TERRAIN_BUILDING) || map_building_at(grid_offset)) {
                continue;
            }
            int random_bit = random.items[grid_offset] & 1;
            int type;
            int image_id = images.items[grid_offset];
            if (image_id == scenario.native_images.hut) {
                type = BUILDING_NATIVE_HUT;
                images.items[grid_offset] = native_image;
            } else if (image_id == scenario.native_images.hut + 1) {
                type = BUILDING_NATIVE_HUT;
                images.items[grid_offset] = native_image + 1;
            } else if (image_id == scenario.native_images.meeting) {
                type = BUILDING_NATIVE_MEETING;
                images.items[grid_offset] = native_image + 2;
                images.items[grid_offset + map_grid_delta(1, 0)] = native_image + 2;
                images.items[grid_offset + map_grid_delta(0, 1)] = native_image + 2;
                images.items[grid_offset + map_grid_delta(1, 1)] = native_image + 2;
            } else if (image_id == scenario.native_images.crops) {
                type = BUILDING_NATIVE_CROPS;
                images.items[grid_offset] = image_data_s.group_image_ids[GROUP_BUILDING_FARM_CROPS] + random_bit;
            } else if (image_data_s.group_image_ids[GROUP_EDITOR_BUILDING_NATIVE] - 4) {
                type = BUILDING_HOUSE_VACANT_LOT;
                images.items[grid_offset] = image_data_s.group_image_ids[GROUP_EDITOR_BUILDING_NATIVE] - 4;
            } else { //unknown building
                map_building_tiles_remove(0, x, y);
                continue;
            }
            struct building_t *b = building_create(type, x, y);
            buildings_grid.items[grid_offset] = b->id;
            b->state = BUILDING_STATE_IN_USE;
            switch (type) {
                case BUILDING_NATIVE_CROPS:
                    b->data.industry.progress = random_bit;
                    break;
                case BUILDING_NATIVE_MEETING:
                    b->sentiment.native_anger = 100;
                    buildings_grid.items[grid_offset + map_grid_delta(1, 0)] = b->id;
                    buildings_grid.items[grid_offset + map_grid_delta(0, 1)] = b->id;
                    buildings_grid.items[grid_offset + map_grid_delta(1, 1)] = b->id;
                    mark_native_land(b->x, b->y, 2, 6);
                    if (!meeting_center_set) {
                        city_data.building.main_native_meeting.x = b->x;
                        city_data.building.main_native_meeting.y = b->y;
                    }
                    break;
                case BUILDING_NATIVE_HUT:
                    b->sentiment.native_anger = 100;
                    b->figure_spawn_delay = random_bit;
                    mark_native_land(b->x, b->y, 1, 3);
                    break;
                case BUILDING_HOUSE_VACANT_LOT:
                    buildings_grid.items[grid_offset] = b->id;
                    break;
            }
        }
    }
    // gather list of meeting centers
    building_list_data.small.size = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_NATIVE_MEETING) {
            building_list_small_add(i);
        }
    }
    if (building_list_data.small.size <= 0) {
        // determine closest meeting center for hut
        for (int i = 1; i < MAX_BUILDINGS; i++) {
            struct building_t *b = &all_buildings[i];
            if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_NATIVE_HUT) {
                int min_dist = 1000;
                int min_meeting_id = 0;
                for (int n = 0; n < building_list_data.small.size; n++) {
                    struct building_t *meeting = &all_buildings[building_list_data.small.items[n]];
                    int dist = calc_maximum_distance(b->x, b->y, meeting->x, meeting->y);
                    if (dist < min_dist) {
                        min_dist = dist;
                        min_meeting_id = building_list_data.small.items[n];
                    }
                }
                b->subtype.native_meeting_center_id = min_meeting_id;
            }
        }
    }
    city_view_init();
    for (int i = 0; i < MAX_FISH_POINTS; i++) {
        if (scenario.fishing_points[i].x > 0) {
            random_generate_next();
            struct figure_t *fish = figure_create(FIGURE_FISH_GULLS, scenario.fishing_points[i].x, scenario.fishing_points[i].y, DIR_0_TOP);
            fish->terrain_usage = TERRAIN_USAGE_ANY;
            fish->image_offset = random_data.random1_7bit & 0x1f;
            fish->progress_on_tile = random_data.random1_7bit & 7;
            figure_movement_set_cross_country_direction(fish,
                fish->cross_country_x, fish->cross_country_y,
                15 * fish->destination_x, 15 * fish->destination_y, 0);
        }
    }
    for (int i = 0; i < MAX_HERD_POINTS; i++) {
        if (scenario.herd_points[i].x > -1) {
            int herd_type;
            int num_animals;
            switch (scenario.climate) {
                case CLIMATE_NORTHERN:
                    herd_type = FIGURE_WOLF;
                    num_animals = WOLF_PACK_SIZE;
                    break;
                case CLIMATE_CENTRAL:
                    herd_type = FIGURE_SHEEP;
                    num_animals = SHEEP_HERD_SIZE;
                    break;
                case CLIMATE_DESERT:
                    herd_type = FIGURE_ZEBRA;
                    num_animals = ZEBRA_HERD_SIZE;
                    break;
                default:
                    break;
            }
            // create herd formation
            struct formation_t *m = &herd_formations[i];
            m->in_use = 1;
            m->figure_type = herd_type;
            m->max_figures = num_animals;
            m->wait_ticks_movement = 24;
            // create animal figures and assign to formation
            for (int fig = 0; fig < num_animals; fig++) {
                struct figure_t *f = figure_create(herd_type,
                    scenario.herd_points[i].x + HERD_FORMATION_LAYOUT_POSITION_X_OFFSETS[fig],
                    scenario.herd_points[i].y + HERD_FORMATION_LAYOUT_POSITION_Y_OFFSETS[fig],
                    DIR_0_TOP);
                f->is_targetable = 1;
                f->terrain_usage = TERRAIN_USAGE_ANIMAL;
                f->action_state = FIGURE_ACTION_HERD_ANIMAL_AT_REST;
                f->formation_id = m->id;
                add_figure_to_formation(f, m);
                city_data.figure.animals++;
            }
        }
    }
    figure_create_flotsam();
    map_routing_update_all();
    if (scenario.entry_point.x == -1 || scenario.entry_point.y == -1) {
        scenario.entry_point.x = scenario.map.width - 1;
        scenario.entry_point.y = scenario.map.height / 2;
    }
    if (scenario.exit_point.x == -1 || scenario.exit_point.y == -1) {
        scenario.exit_point.x = scenario.entry_point.x;
        scenario.exit_point.y = scenario.entry_point.y;
    }
    game_time_init(scenario.start_year);
    int i = 321;
    while (i < MAX_MESSAGE_ENTRIES) {
        if (!lang_data.message_entries[i].content.text) {
            break;
        }
        i++;
    }
    if (i >= MAX_MESSAGE_ENTRIES) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Message entry max exceeded", "", 0));
        return 0;
    }
    // distant battle won but triumphal arch disabled from the editor
    set_message_parameters(&lang_data.message_entries[i], "Roman city saved", "Your relief force defeated the invading barbarians. Caesar is pleased.", 0, MESSAGE_TYPE_GENERAL);
    lang_data.message_entries[i].video.text = "smk/army_win.smk";
    i += 1;
    // editor custom messages
    for (int j = 0; j < MAX_EDITOR_CUSTOM_MESSAGES; j++) {
        if (scenario.editor_custom_messages[j].enabled) {
            lang_data.message_entries[i].type = TYPE_MESSAGE;
            lang_data.message_entries[i].message_type = MESSAGE_TYPE_GENERAL;
            lang_data.message_entries[i].x = 0;
            lang_data.message_entries[i].y = 0;
            lang_data.message_entries[i].width_blocks = 30;
            lang_data.message_entries[i].height_blocks = 20;
            lang_data.message_entries[i].title.x = 0;
            lang_data.message_entries[i].title.y = 0;
            lang_data.message_entries[i].urgent = scenario.editor_custom_messages[j].urgent;
            lang_data.message_entries[i].title.text = scenario.editor_custom_messages[j].title;
            lang_data.message_entries[i].content.text = scenario.editor_custom_messages[j].text;
            lang_data.message_entries[i].video.text = scenario.editor_custom_messages[j].video_file;
            i += 1;
        }
    }
    empire_data.scroll_x = empire_data.initial_scroll_x;
    empire_data.scroll_y = empire_data.initial_scroll_y;
    empire_data.viewport_width = EMPIRE_WIDTH;
    empire_data.viewport_height = EMPIRE_HEIGHT;
    memset(&figure_trader_data, 0, sizeof(figure_trader_data));
    city_military_determine_distant_battle_city();
    image_load_climate(scenario.climate, 0, 0);
    city_data_init_scenario();
    state_data.paused = 0;
    string_copy(string_values[CONFIG_STRING_PLAYER_NAME], scenario_settings.player_name, MAX_PLAYER_NAME);
    city_data.ratings.favor = scenario.initial_favor;
    city_data.emperor.personal_savings = scenario.initial_personal_savings;
    city_data.emperor.player_rank = scenario.player_rank;
    city_emperor_set_salary_rank(city_data.emperor.player_rank);
    map_building_menu_items();
    city_message_init_scenario();
    return 1;
}

static void replay_map_confirmed(void)
{
    if (game_file_start_scenario(scenario.scenario_name)) {
        window_city_show();
    }
}

static void lang_text_draw_centered(int group, int number, int x_offset, int y_offset, int box_width, int font)
{
    char *str = lang_get_string(group, number);
    text_draw_centered(str, x_offset, y_offset, box_width, font, 0);
}

static int text_draw_multiline(char *str, int x_offset, int y_offset, int box_width, int font, uint32_t color)
{
    int line_height = font_data.font_definitions[font].line_height;
    if (line_height < 11) {
        line_height = 11;
    }
    int has_more_characters = 1;
    int guard = 0;
    int y = y_offset;
    while (has_more_characters) {
        if (++guard >= 100) {
            break;
        }
        // clear line
        for (int i = 0; i < 200; i++) {
            tmp_line_text[i] = 0;
        }
        int current_width = 0;
        int line_index = 0;
        while (has_more_characters && current_width < box_width) {
            int word_num_chars;
            struct font_definition_t *def = &font_data.font_definitions[font];
            int width = 0;
            int guard2 = 0;
            int word_char_seen = 0;
            int num_chars = 0;
            while (*str && ++guard2 < 200) {
                int num_bytes = 1;
                if (*str == ' ' || *str == '\n') {
                    if (word_char_seen) {
                        break;
                    }
                    width += def->space_width;
                } else if (*str == '$') {
                    if (word_char_seen) {
                        break;
                    }
                } else if (*str > ' ') {
                    // normal char
                    int letter_id = font_letter_id(def, str);
                    if (letter_id >= 0) {
                        width += image_letter(letter_id)->width + def->letter_spacing;
                    }
                    word_char_seen = 1;
                    if (num_bytes > 1) {
                        num_chars += num_bytes;
                        break;
                    }
                }
                str += num_bytes;
                num_chars += num_bytes;
            }
            word_num_chars = num_chars;
            current_width += width;
            if (current_width >= box_width) {
                if (current_width == 0) {
                    has_more_characters = 0;
                }
            } else {
                for (int i = 0; i < word_num_chars; i++) {
                    if (line_index == 0 && *str <= ' ') {
                        str++; // skip whitespace at start of line
                    } else {
                        tmp_line_text[line_index++] = *str++;
                    }
                }
                if (!*str) {
                    has_more_characters = 0;
                } else if (*str == '\n') {
                    str++;
                    break;
                }
            }
        }
        text_draw(tmp_line_text, x_offset, y, font, color);
        y += line_height + 5;
    }
    return y - y_offset;
}

static int lang_text_draw_multiline(int group, int number, int x_offset, int y_offset, int box_width, int font)
{
    char *str = lang_get_string(group, number);
    return text_draw_multiline(str, x_offset, y_offset, box_width, font, 0);
}

static void draw_background_popup_dialog(void)
{
    window_draw_underlying_window();
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    if (popup_dialog_data.has_buttons) {
        outer_panel_draw(80, 80, 30, 10);
    } else {
        outer_panel_draw(80, 80, 30, 7);
    }
    if (popup_dialog_data.type >= 0) {
        lang_text_draw_centered(GROUP, popup_dialog_data.type, 80, 100, 480, FONT_LARGE_BLACK);
        if (lang_text_get_width(GROUP, popup_dialog_data.type + 1, FONT_NORMAL_BLACK) >= 420) {
            lang_text_draw_multiline(GROUP, popup_dialog_data.type + 1, 110, 140, 420, FONT_NORMAL_BLACK);
        } else {
            lang_text_draw_centered(GROUP, popup_dialog_data.type + 1, 80, 140, 480, FONT_NORMAL_BLACK);
        }
    } else {
        lang_text_draw_centered(popup_dialog_data.custom_text_group, popup_dialog_data.custom_text_id, 80, 100, 480, FONT_LARGE_BLACK);
        lang_text_draw_centered(PROCEED_GROUP, PROCEED_TEXT, 80, 140, 480, FONT_NORMAL_BLACK);
    }
    set_translation(0, 0);
}

static void window_go_back(void)
{
    reset_input();
    decrease_queue_index();
    window_data.current_window = &window_data.window_queue[window_data.queue_index];
    window_invalidate();
}

static void confirm_popup_dialog(void)
{
    window_go_back();
    popup_dialog_data.close_func();
}

static void button_ok_popup_dialog(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    confirm_popup_dialog();
}

static void button_cancel_popup_dialog(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_go_back();
    // prevent getting stuck on top menu window (last active) when declining pop-up to exit scenario/editor
    if (window_data.current_window->id == WINDOW_TOP_MENU || window_data.current_window->id == WINDOW_EDITOR_TOP_MENU) {
        window_go_back();
    }
}

static struct image_button_t popup_dialog_buttons[] = {
    {192, 100, 39, 26, IB_NORMAL, GROUP_OK_CANCEL_SCROLL_BUTTONS, 0, button_ok_popup_dialog, button_none, 1, 0, 1, 0, 0, 0},
    {256, 100, 39, 26, IB_NORMAL, GROUP_OK_CANCEL_SCROLL_BUTTONS, 4, button_cancel_popup_dialog, button_none, 0, 0, 1, 0, 0, 0},
};

static void draw_foreground_popup_dialog(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    if (popup_dialog_data.has_buttons) {
        image_buttons_draw(80, 80, popup_dialog_buttons, sizeof(popup_dialog_buttons) / sizeof(struct image_button_t));
    }
    set_translation(0, 0);
}

static int image_buttons_handle_mouse(struct mouse_t *m, int x, int y, struct image_button_t *buttons, int num_buttons, int *focus_button_id)
{
    fade_pressed_effect(buttons, num_buttons);
    for (int i = 0; i < num_buttons; i++) {
        struct image_button_t *btn = &buttons[i];
        if (btn->pressed && btn->button_type == IB_BUILD) {
            btn->pressed--;
        }
    }
    struct image_button_t *hit_button = 0;
    if (focus_button_id) {
        *focus_button_id = 0;
    }
    for (int i = 0; i < num_buttons; i++) {
        struct image_button_t *btn = &buttons[i];
        if (btn->focused) {
            btn->focused--;
        }
        if (x + btn->x_offset <= m->x &&
            x + btn->x_offset + btn->width > m->x &&
            y + btn->y_offset <= m->y &&
            y + btn->y_offset + btn->height > m->y) {
            if (focus_button_id) {
                *focus_button_id = i + 1;
            }
            if (btn->enabled) {
                btn->focused = 2;
                hit_button = btn;
            }
        }
    }
    if (!hit_button) {
        return 0;
    }
    if (hit_button->button_type == IB_SCROLL) {
        if (!m->left.went_down && !m->left.is_down) {
            return 0;
        }
    } else if (hit_button->button_type == IB_BUILD || hit_button->button_type == IB_NORMAL) {
        int should_be_pressed = 0;
        if (((m->left.went_down || m->left.is_down) && hit_button->left_click_handler != button_none)
        || ((m->right.went_down || m->right.is_down) && hit_button->right_click_handler != button_none)) {
            should_be_pressed = 1;
        }
        if (should_be_pressed) {
            hit_button->pressed = 2;
            hit_button->pressed_since = current_time;
        }
        if (!m->left.went_up && !m->right.went_up) {
            return 0;
        }
    }
    if (m->left.went_up) {
        play_sound_effect(SOUND_EFFECT_ICON);
        hit_button->left_click_handler(hit_button->parameter1, hit_button->parameter2);
        return hit_button->left_click_handler != button_none;
    } else if (m->right.went_up) {
        hit_button->right_click_handler(hit_button->parameter1, hit_button->parameter2);
        return hit_button->right_click_handler != button_none;
    } else if (hit_button->button_type == IB_SCROLL && m->left.is_down) {
        uint32_t delay = hit_button->pressed == 2 ? PRESSED_REPEAT_MILLIS : PRESSED_REPEAT_INITIAL_MILLIS;
        if (current_time - hit_button->pressed_since >= delay) {
            hit_button->pressed = 2;
            hit_button->pressed_since = current_time;
            hit_button->left_click_handler(hit_button->parameter1, hit_button->parameter2);
        }
        return 1;
    }
    return 0;
}

static   struct mouse_t *mouse_in_dialog(struct mouse_t *m)
{
    dialog.left = m->left;
    dialog.right = m->right;
    dialog.scrolled = m->scrolled;
    dialog.is_inside_window = m->is_inside_window;

    dialog.x = m->x - screen_data.dialog_offset.x;
    dialog.y = m->y - screen_data.dialog_offset.y;
    return &dialog;
}

static void handle_input_popup_dialog(struct mouse_t *m, struct hotkeys_t *h)
{
    if (popup_dialog_data.has_buttons && image_buttons_handle_mouse(mouse_in_dialog(m), 80, 80, popup_dialog_buttons, sizeof(popup_dialog_buttons) / sizeof(struct image_button_t), 0)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        button_cancel_popup_dialog(0, 0);
    }
    if (h->enter_pressed) {
        confirm_popup_dialog();
    }
}

static void replay_map(void)
{
    building_construction_clear_type();
    if (init_popup_dialog(POPUP_DIALOG_NONE, 1, 2, replay_map_confirmed, 1)) {
        struct window_type_t window = {
            WINDOW_POPUP_DIALOG,
            draw_background_popup_dialog,
            draw_foreground_popup_dialog,
            handle_input_popup_dialog,
        };
        window_show(&window);
    }
}

static void top_menu_file_replay_map(__attribute__((unused)) int param)
{
    clear_state_top_menu();
    replay_map();
}

static void input_box_draw(struct input_box_t *box)
{
    inner_panel_draw(box->x, box->y, box->width_blocks, box->height_blocks);
    int text_x = box->x + 16;
    int text_y = box->y + 10;
    if (draw_cursor_input_box) {
        input_cursor.capture = 1;
        input_cursor.seen = 0;
        input_cursor.position = 0;
        input_cursor.width = 0;
        input_cursor.cursor_position = keyboard_data.cursor_position - keyboard_data.viewport_start;
        input_cursor.text_offset_start = keyboard_data.viewport_start;
        input_cursor.text_offset_end = keyboard_data.viewport_end;
    }
    text_draw(box->text, text_x, text_y, box->font, 0);
    if (draw_cursor_input_box) {
        if (input_cursor.capture) {
            input_cursor.capture = 0;
            graphics_fill_rect(text_x + input_cursor.x_offset, text_y + 1 + input_cursor.y_offset + 14, input_cursor.width, 2, COLOR_WHITE);
        }
    }
}

static void on_scroll_file_dialog(void)
{
    file_dialog_data.message_not_exist_start_time = 0;
}

static struct scrollbar_type_t scrollbar_file_dialog = { 464, 120, 206, on_scroll_file_dialog, 0, 0, 0, 0, 0, 0 };

static void text_ellipsize(char *str, int font, int requested_width)
{
    char *orig_str = str;
    struct font_definition_t *def = &font_data.font_definitions[font];
    int ellipsis_width = 0;
    if (!ellipsis.width[font]) {
        ellipsis.width[font] = text_get_width(ellipsis.string, font);
    }
    ellipsis_width = ellipsis.width[font];
    int maxlen = 10000;
    int width = 0;
    int length_with_ellipsis = 0;
    while (*str && maxlen > 0) {
        if (*str == ' ') {
            width += def->space_width;
        } else {
            int letter_id = font_letter_id(def, str);
            if (letter_id >= 0) {
                width += def->letter_spacing + image_letter(letter_id)->width;
            }
        }
        if (ellipsis_width + width <= requested_width) {
            length_with_ellipsis += 1;
        }
        if (width > requested_width) {
            break;
        }
        str += 1;
        maxlen -= 1;
    }
    if (10000 - maxlen < string_length(orig_str)) {
        string_copy(ellipsis.string, orig_str + length_with_ellipsis, ELLIPSIS_LENGTH);
    }
}

static void text_scroll(int is_down, int num_lines)
{
    struct scrollbar_type_t *scrollbar = current;
    if (is_down) {
        scrollbar->scroll_position += num_lines;
        if (scrollbar->scroll_position > scrollbar->max_scroll_position) {
            scrollbar->scroll_position = scrollbar->max_scroll_position;
        }
    } else {
        scrollbar->scroll_position -= num_lines;
        if (scrollbar->scroll_position < 0) {
            scrollbar->scroll_position = 0;
        }
    }
    scrollbar->is_dragging_scroll = 0;
    if (scrollbar->on_scroll_callback) {
        scrollbar->on_scroll_callback();
    }
}

static struct image_button_t image_button_scroll_up = {
    0, 0, SCROLL_BUTTON_WIDTH, SCROLL_BUTTON_HEIGHT, IB_SCROLL,
    GROUP_OK_CANCEL_SCROLL_BUTTONS, 8, text_scroll, button_none, 0, 1, 1, 0, 0, 0
};

static struct image_button_t image_button_scroll_down = {
    0, 0, SCROLL_BUTTON_WIDTH, SCROLL_BUTTON_HEIGHT, IB_SCROLL,
    GROUP_OK_CANCEL_SCROLL_BUTTONS, 12, text_scroll, button_none, 1, 1, 1, 0, 0, 0
};

static void scrollbar_draw(struct scrollbar_type_t *scrollbar)
{
    if (scrollbar->max_scroll_position > 0 || scrollbar->always_visible) {
        image_buttons_draw(scrollbar->x, scrollbar->y, &image_button_scroll_up, 1);
        image_buttons_draw(scrollbar->x, scrollbar->y + scrollbar->height - SCROLL_BUTTON_HEIGHT,
            &image_button_scroll_down, 1);

        int pct;
        if (scrollbar->scroll_position <= 0) {
            pct = 0;
        } else if (scrollbar->scroll_position >= scrollbar->max_scroll_position) {
            pct = 100;
        } else {
            pct = calc_percentage(scrollbar->scroll_position, scrollbar->max_scroll_position);
        }
        int offset = calc_adjust_with_percentage(
            scrollbar->height - TOTAL_BUTTON_HEIGHT - 2 * scrollbar->dot_padding, pct);
        if (scrollbar->is_dragging_scroll) {
            offset = scrollbar->scroll_position_drag;
        }
        image_draw(image_data_s.group_image_ids[GROUP_PANEL_BUTTON] + 39,
            scrollbar->x + (SCROLL_BUTTON_WIDTH - SCROLL_DOT_SIZE) / 2,
            scrollbar->y + offset + SCROLL_BUTTON_HEIGHT + scrollbar->dot_padding);
    }
}

static void input_box_stop(__attribute__((unused)) struct input_box_t *box)
{
    keyboard_data.capture = 0;
    keyboard_data.text = 0;
    keyboard_data.cursor_position = 0;
    keyboard_data.length = 0;
    keyboard_data.max_length = 0;
    keyboard_data.accepted = 0;
    SDL_StopTextInput();
    SDL_Rect rect = { 0, 0, 0, 0 };
    SDL_SetTextInputRect(&rect);
    draw_cursor_input_box = 0;
}

static struct buffer_t *create_savegame_piece(int size)
{
    struct file_piece_t *piece = &savegame_data.pieces[savegame_data.num_pieces++];
    init_file_piece(piece, size);
    return &piece->buf;
}

static void init_savegame_data(void)
{
    if (savegame_data.num_pieces > 0) {
        for (int i = 0; i < savegame_data.num_pieces; i++) {
            buffer_reset(&savegame_data.pieces[i].buf);
        }
        return;
    }
    struct savegame_state_t *state = &savegame_data.state;
    state->image_grid = create_savegame_piece(52488);
    state->edge_grid = create_savegame_piece(26244);
    state->building_grid = create_savegame_piece(52488);
    state->terrain_grid = create_savegame_piece(78732);
    state->aqueduct_grid = create_savegame_piece(26244);
    state->figure_grid = create_savegame_piece(52488);
    state->bitfields_grid = create_savegame_piece(26244);
    state->sprite_grid = create_savegame_piece(26244);
    state->random_grid = create_savegame_piece(26244);
    state->desirability_grid = create_savegame_piece(26244);
    state->building_damage_grid = create_savegame_piece(26244);
    state->aqueduct_backup_grid = create_savegame_piece(26244);
    state->sprite_backup_grid = create_savegame_piece(26244);
    state->figures = create_savegame_piece(136000);
    state->route_figures = create_savegame_piece(1200);
    state->route_paths = create_savegame_piece(300000);
    state->legion_formations = create_savegame_piece(420);
    state->herd_formations = create_savegame_piece(560);
    state->enemy_formations = create_savegame_piece(7000);
    state->city_data = create_savegame_piece(11551);
    state->player_name = create_savegame_piece(24);
    state->buildings = create_savegame_piece(154000);
    state->city_view_orientation = create_savegame_piece(4);
    state->game_time = create_savegame_piece(20);
    state->building_extra_highest_id_ever = create_savegame_piece(4);
    state->random_iv = create_savegame_piece(8);
    state->city_view_camera = create_savegame_piece(8);
    state->building_count_culture1 = create_savegame_piece(132);
    state->city_graph_order = create_savegame_piece(4);
    state->empire = create_savegame_piece(8);
    state->empire_objects = create_savegame_piece(20600);
    state->building_count_industry = create_savegame_piece(128);
    state->trade_prices = create_savegame_piece(64);
    state->figure_names = create_savegame_piece(76);
    state->culture_coverage = create_savegame_piece(56);
    state->scenario = create_savegame_piece(52424);
    state->messages = create_savegame_piece(14000);
    state->message_extra = create_savegame_piece(12);
    state->population_messages = create_savegame_piece(9);
    state->message_counts = create_savegame_piece(80);
    state->message_delays = create_savegame_piece(80);
    state->building_list_burning_totals = create_savegame_piece(8);
    state->city_sounds = create_savegame_piece(3920);
    state->building_extra_highest_id = create_savegame_piece(4);
    state->figure_traders = create_savegame_piece(4004);
    state->building_list_burning = create_savegame_piece(1000);
    state->building_list_small = create_savegame_piece(1000);
    state->building_list_large = create_savegame_piece(4000);
    state->building_count_military = create_savegame_piece(16);
    state->building_storages = create_savegame_piece(4400);
    state->building_count_culture2 = create_savegame_piece(32);
    state->building_count_support = create_savegame_piece(24);
    state->building_barracks_tower_sentry = create_savegame_piece(4);
    state->building_extra_sequence = create_savegame_piece(4);
    state->routing_counters = create_savegame_piece(8);
    state->building_count_culture3 = create_savegame_piece(40);
    state->building_extra_corrupt_houses = create_savegame_piece(8);
    state->bookmarks = create_savegame_piece(32);
}

static void buffer_write_raw(struct buffer_t *buf, void *value, int size)
{
    if (check_size(buf, size)) {
        memcpy(&buf->data[buf->index], value, size);
        buf->index += size;
    }
}

static void buffer_write_u16(struct buffer_t *buf, uint16_t value)
{
    if (check_size(buf, 2)) {
        buf->data[buf->index++] = value & 0xff;
        buf->data[buf->index++] = (value >> 8) & 0xff;
    }
}

static void map_image_save_state(struct buffer_t *buf)
{
    for (int i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        buffer_write_u16(buf, images.items[i]);
    }
}

static int is_industry_type(struct building_t *b)
{
    return b->output_resource_id || b->type == BUILDING_NATIVE_CROPS
        || b->type == BUILDING_SHIPYARD || b->type == BUILDING_WHARF;
}

static void map_terrain_save_state(struct buffer_t *buf)
{
    for (int i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        buffer_write_u16(buf, terrain_grid.items[i]);
    }
    buffer_write_raw(buf, terrain_elevation.items, GRID_SIZE * GRID_SIZE);
}

static void map_property_save_state(struct buffer_t *bitfields, struct buffer_t *edge)
{
    buffer_write_raw(bitfields, bitfields_grid.items, GRID_SIZE * GRID_SIZE);
    buffer_write_raw(edge, edge_grid.items, GRID_SIZE * GRID_SIZE);
}

static void buffer_write_u8(struct buffer_t *buf, uint8_t value)
{
    if (check_size(buf, 1)) {
        buf->data[buf->index++] = value;
    }
}

static void formation_save_state(struct buffer_t *buf, struct formation_t *m)
{
    buffer_write_u8(buf, m->in_use);
    buffer_write_u8(buf, m->layout);
    buffer_write_u8(buf, m->figure_type);
    buffer_write_u8(buf, m->num_figures);
    buffer_write_u8(buf, m->max_figures);
    for (int fig = 0; fig < MAX_FORMATION_FIGURES; fig++) {
        buffer_write_u16(buf, m->figures[fig]);
    }
    buffer_write_u8(buf, m->has_military_training);
    buffer_write_u8(buf, m->is_at_rest);
    buffer_write_u8(buf, m->deployed_duration_months);
    buffer_write_u8(buf, m->direction);
    buffer_write_u8(buf, m->morale);
    buffer_write_u8(buf, m->max_morale);
    buffer_write_u8(buf, m->routed);
    buffer_write_i16(buf, m->wait_ticks_movement);
    buffer_write_u16(buf, m->standard_x);
    buffer_write_u16(buf, m->standard_y);
    buffer_write_u16(buf, m->prev_standard_x);
    buffer_write_u16(buf, m->prev_standard_y);
    buffer_write_u16(buf, m->legion_standard__figure_id);
    buffer_write_u16(buf, m->building_id);
    buffer_write_u8(buf, m->empire_service);
    buffer_write_u8(buf, m->in_distant_battle);
    buffer_write_u8(buf, m->cursed_by_mars);
    buffer_write_u8(buf, m->recent_fight);
    buffer_write_u8(buf, m->missile_attack_timeout);
    buffer_write_u16(buf, m->destination_x);
    buffer_write_u16(buf, m->destination_y);
    buffer_write_u16(buf, m->wolf_spawn_delay);
    buffer_write_u8(buf, m->attack_priority);
}

static void buffer_write_u32(struct buffer_t *buf, uint32_t value)
{
    if (check_size(buf, 4)) {
        buf->data[buf->index++] = value & 0xff;
        buf->data[buf->index++] = (value >> 8) & 0xff;
        buf->data[buf->index++] = (value >> 16) & 0xff;
        buf->data[buf->index++] = (value >> 24) & 0xff;
    }
}

static void random_save_state(struct buffer_t *buf)
{
    buffer_write_u32(buf, random_data.iv1);
    buffer_write_u32(buf, random_data.iv2);
}

static void empire_object_save_state(struct buffer_t *buf)
{
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        // initialize extra fields
        if (empire_objects[i].in_use && empire_objects[i].type == EMPIRE_OBJECT_CITY) {
            // determine trade route type
            for (int j = 0; j < MAX_EMPIRE_OBJECTS; j++) {
                if (empire_objects[j].type == EMPIRE_OBJECT_SEA_TRADE_ROUTE
                && empire_objects[j].in_use
                && empire_objects[j].trade_route_id == empire_objects[i].trade_route_id) {
                    empire_objects[i].is_sea_trade = 1;
                }
            }
            empire_objects[i].trader_entry_delay = empire_objects[i].is_sea_trade ? 30 : 4;
        }
        buffer_write_u8(buf, empire_objects[i].type);
        buffer_write_i16(buf, empire_objects[i].x);
        buffer_write_i16(buf, empire_objects[i].y);
        buffer_write_i16(buf, empire_objects[i].image_id);
        buffer_write_i16(buf, empire_objects[i].expanded.x);
        buffer_write_i16(buf, empire_objects[i].expanded.y);
        buffer_write_i16(buf, empire_objects[i].expanded.image_id);
        buffer_write_i16(buf, empire_objects[i].width);
        buffer_write_i16(buf, empire_objects[i].height);
        buffer_write_u8(buf, empire_objects[i].animation_index);
        buffer_write_u8(buf, empire_objects[i].in_use);
        buffer_write_u8(buf, empire_objects[i].city_type);
        buffer_write_u8(buf, empire_objects[i].city_name_id);
        buffer_write_u8(buf, empire_objects[i].trade_route_id);
        buffer_write_u8(buf, empire_objects[i].trade_route_open);
        buffer_write_u32(buf, empire_objects[i].trade_route_cost);
        buffer_write_i16(buf, empire_objects[i].trader_entry_delay);
        buffer_write_u8(buf, empire_objects[i].is_sea_trade);
        for (int f = 0; f < 3; f++) {
            buffer_write_i16(buf, empire_objects[i].trader_figure_ids[f]);
        }
        for (int r = 0; r < RESOURCE_TYPES_MAX; r++) {
            buffer_write_u8(buf, empire_objects[i].resource_buy_limit[r]);
            buffer_write_u8(buf, empire_objects[i].resource_sell_limit[r]);
            buffer_write_u8(buf, empire_objects[i].resource_bought[r]);
            buffer_write_u8(buf, empire_objects[i].resource_sold[r]);
        }
        buffer_write_u8(buf, empire_objects[i].invasion_path_id);
        buffer_write_u8(buf, empire_objects[i].invasion_years);
        buffer_write_u8(buf, empire_objects[i].distant_battle_travel_months);
    }
}

static void scenario_save_state(struct buffer_t *buf)
{
    buffer_write_u16(buf, scenario.map.width);
    buffer_write_u16(buf, scenario.map.height);
    buffer_write_u16(buf, scenario.map.grid_start);
    buffer_write_u16(buf, scenario.map.grid_border_size);
    buffer_write_u8(buf, scenario.empire.id);
    buffer_write_u8(buf, scenario.empire.is_expanded);
    buffer_write_u16(buf, scenario.empire.expansion_year);
    buffer_write_u8(buf, scenario.empire.distant_battle_roman_travel_months);
    buffer_write_u8(buf, scenario.empire.distant_battle_enemy_travel_months);
    // Map name
    buffer_write_raw(buf, scenario.scenario_name, MAX_SCENARIO_NAME);
    // Brief description
    buffer_write_raw(buf, scenario.brief_description, MAX_BRIEF_DESCRIPTION);
    buffer_write_u8(buf, scenario.brief_description_image_id);
    // Scenario description
    buffer_write_raw(buf, scenario.briefing, MAX_BRIEFING);
    // Terrain set
    buffer_write_u8(buf, scenario.climate);
    // Starting conditions
    buffer_write_u8(buf, scenario.player_rank);
    buffer_write_i16(buf, scenario.start_year);
    buffer_write_u8(buf, scenario.initial_favor);
    buffer_write_u32(buf, scenario.initial_funds);
    buffer_write_u32(buf, scenario.rescue_loan);
    buffer_write_u32(buf, scenario.initial_personal_savings);
    buffer_write_u8(buf, scenario.rome_supplies_wheat);
    buffer_write_u8(buf, scenario.flotsam_enabled);
    // Win criteria
    buffer_write_u8(buf, scenario.population_win_criteria.enabled);
    buffer_write_u32(buf, scenario.population_win_criteria.goal);
    buffer_write_u8(buf, scenario.culture_win_criteria.enabled);
    buffer_write_u16(buf, scenario.culture_win_criteria.goal);
    buffer_write_u8(buf, scenario.prosperity_win_criteria.enabled);
    buffer_write_u16(buf, scenario.prosperity_win_criteria.goal);
    buffer_write_u8(buf, scenario.peace_win_criteria.enabled);
    buffer_write_u16(buf, scenario.peace_win_criteria.goal);
    buffer_write_u8(buf, scenario.favor_win_criteria.enabled);
    buffer_write_u16(buf, scenario.favor_win_criteria.goal);
    buffer_write_u8(buf, scenario.time_limit_win_criteria.enabled);
    buffer_write_u16(buf, scenario.time_limit_win_criteria.years);
    buffer_write_u8(buf, scenario.survival_time_win_criteria.enabled);
    buffer_write_u16(buf, scenario.survival_time_win_criteria.years);
    // Buildings allowed
    for (int i = 0; i < BUILDING_TYPE_MAX; i++) {
        buffer_write_u8(buf, scenario.allowed_buildings[i]);
    }
    // Special events
    buffer_write_u8(buf, scenario.gladiator_revolt.state);
    buffer_write_u8(buf, scenario.gladiator_revolt.month);
    buffer_write_u16(buf, scenario.gladiator_revolt.year);
    // random events
    buffer_write_u8(buf, scenario.random_events.sea_trade_problem);
    buffer_write_u8(buf, scenario.random_events.land_trade_problem);
    buffer_write_u8(buf, scenario.random_events.raise_wages);
    buffer_write_u8(buf, scenario.random_events.lower_wages);
    buffer_write_u8(buf, scenario.random_events.contaminated_water);
    // Requests
    for (int i = 0; i < MAX_REQUESTS; i++) {
        buffer_write_u16(buf, scenario.requests[i].year);
        buffer_write_u8(buf, scenario.requests[i].month);
        buffer_write_u16(buf, scenario.requests[i].amount);
        buffer_write_u8(buf, scenario.requests[i].resource);
        buffer_write_u16(buf, scenario.requests[i].years_deadline);
        buffer_write_u8(buf, scenario.requests[i].favor);
        buffer_write_u8(buf, scenario.requests[i].state);
        buffer_write_u8(buf, scenario.requests[i].visible);
        buffer_write_u16(buf, scenario.requests[i].months_to_comply);
        buffer_write_u8(buf, scenario.requests[i].can_comply_dialog_shown);
    }
    // Custom messages
    for (int i = 0; i < MAX_EDITOR_CUSTOM_MESSAGES; i++) {
        buffer_write_u16(buf, scenario.editor_custom_messages[i].year);
        buffer_write_u8(buf, scenario.editor_custom_messages[i].month);
        buffer_write_u8(buf, scenario.editor_custom_messages[i].urgent);
        buffer_write_u8(buf, scenario.editor_custom_messages[i].enabled);
        buffer_write_raw(buf, scenario.editor_custom_messages[i].title, MAX_CUSTOM_MESSAGE_TITLE);
        buffer_write_raw(buf, scenario.editor_custom_messages[i].text, MAX_CUSTOM_MESSAGE_TEXT);
        buffer_write_raw(buf, scenario.editor_custom_messages[i].video_file, MAX_CUSTOM_MESSAGE_VIDEO_TEXT);
    }
    // Earthquakes
    for (int i = 0; i < MAX_EARTHQUAKES; i++) {
        // link earthquake events to corresponding map points; leave a gap at the epicenter to prevent total map block-off and allow for more interesting building patterns
        scenario.earthquakes[i].branch_coordinates[0].x = scenario.earthquake_points[scenario.earthquakes[i].point].x;
        scenario.earthquakes[i].branch_coordinates[0].y = scenario.earthquake_points[scenario.earthquakes[i].point].y - 2;
        scenario.earthquakes[i].branch_coordinates[1].x = scenario.earthquake_points[scenario.earthquakes[i].point].x + 2;
        scenario.earthquakes[i].branch_coordinates[1].y = scenario.earthquake_points[scenario.earthquakes[i].point].y;
        scenario.earthquakes[i].branch_coordinates[2].x = scenario.earthquake_points[scenario.earthquakes[i].point].x;
        scenario.earthquakes[i].branch_coordinates[2].y = scenario.earthquake_points[scenario.earthquakes[i].point].y + 2;
        scenario.earthquakes[i].branch_coordinates[3].x = scenario.earthquake_points[scenario.earthquakes[i].point].x - 2;
        scenario.earthquakes[i].branch_coordinates[3].y = scenario.earthquake_points[scenario.earthquakes[i].point].y;
        buffer_write_u8(buf, scenario.earthquakes[i].state);
        buffer_write_u8(buf, scenario.earthquakes[i].severity);
        buffer_write_u8(buf, scenario.earthquakes[i].month);
        buffer_write_u16(buf, scenario.earthquakes[i].year);
        buffer_write_u16(buf, scenario.earthquakes[i].duration);
        buffer_write_u16(buf, scenario.earthquakes[i].max_duration);
        buffer_write_u8(buf, scenario.earthquakes[i].delay);
        buffer_write_u8(buf, scenario.earthquakes[i].max_delay);
        buffer_write_u8(buf, scenario.earthquakes[i].point);
        for (int j = 0; j < MAX_EARTHQUAKE_BRANCHES; j++) {
            buffer_write_i32(buf, scenario.earthquakes[i].branch_coordinates[j].x);
            buffer_write_i32(buf, scenario.earthquakes[i].branch_coordinates[j].y);
        }
    }
    // Invasions
    for (int i = 0; i < MAX_INVASIONS; i++) {
        buffer_write_u16(buf, scenario.invasions[i].year_offset);
        buffer_write_u8(buf, scenario.invasions[i].month);
        buffer_write_u16(buf, scenario.invasions[i].amount);
        buffer_write_u8(buf, scenario.invasions[i].type);
        buffer_write_u8(buf, scenario.invasions[i].enemy_type);
        buffer_write_u8(buf, scenario.invasions[i].from);
        buffer_write_u8(buf, scenario.invasions[i].target_type);
    }
    buffer_write_u8(buf, scenario.invasion_upcoming);
    // Price changes
    for (int i = 0; i < MAX_PRICE_CHANGES; i++) {
        buffer_write_u16(buf, scenario.price_changes[i].year);
        buffer_write_u8(buf, scenario.price_changes[i].month);
        buffer_write_u8(buf, scenario.price_changes[i].resource);
        buffer_write_u8(buf, scenario.price_changes[i].is_rise);
        buffer_write_u8(buf, scenario.price_changes[i].amount);
    }
    // Demand changes
    for (int i = 0; i < MAX_DEMAND_CHANGES; i++) {
        buffer_write_u16(buf, scenario.demand_changes[i].year);
        buffer_write_u8(buf, scenario.demand_changes[i].month);
        buffer_write_u8(buf, scenario.demand_changes[i].resource);
        buffer_write_u8(buf, scenario.demand_changes[i].trade_city_id);
        buffer_write_u8(buf, scenario.demand_changes[i].is_rise);
    }
    // Earthquake points
    for (int i = 0; i < MAX_EARTHQUAKE_POINTS; i++) {
        buffer_write_i16(buf, scenario.earthquake_points[i].x);
        buffer_write_i16(buf, scenario.earthquake_points[i].y);
    }
    // Invasion points
    for (int i = 0; i < MAX_INVASION_POINTS; i++) {
        buffer_write_i16(buf, scenario.invasion_points[i].x);
        buffer_write_i16(buf, scenario.invasion_points[i].y);
    }
    // Entry/exit points
    buffer_write_i16(buf, scenario.entry_point.x);
    buffer_write_i16(buf, scenario.entry_point.y);
    buffer_write_i16(buf, scenario.exit_point.x);
    buffer_write_i16(buf, scenario.exit_point.y);
    // River entry/exit points
    buffer_write_i16(buf, scenario.river_entry_point.x);
    buffer_write_i16(buf, scenario.river_entry_point.y);
    buffer_write_i16(buf, scenario.river_exit_point.x);
    buffer_write_i16(buf, scenario.river_exit_point.y);
    // Buildings
    buffer_write_u32(buf, scenario.native_images.hut);
    buffer_write_u32(buf, scenario.native_images.meeting);
    buffer_write_u32(buf, scenario.native_images.crops);
    buffer_write_u32(buf, scenario.native_images.vacant_lots);
    // Fishing points
    for (int i = 0; i < MAX_FISH_POINTS; i++) {
        buffer_write_i16(buf, scenario.fishing_points[i].x);
        buffer_write_i16(buf, scenario.fishing_points[i].y);
    }
    // Herd points
    for (int i = 0; i < MAX_HERD_POINTS; i++) {
        buffer_write_i16(buf, scenario.herd_points[i].x);
        buffer_write_i16(buf, scenario.herd_points[i].y);
    }
    scenario.is_saved = 1;
}

static int game_file_io_write_saved_game(char *dir, char *filename)
{
    init_savegame_data();
    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Saving game", filename, 0));
    buffer_write_raw(savegame_data.state.player_name, scenario_settings.player_name, MAX_PLAYER_NAME);
    map_image_save_state(savegame_data.state.image_grid);
    for (int i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        buffer_write_u16(savegame_data.state.building_grid, buildings_grid.items[i]);
    }
    buffer_write_raw(savegame_data.state.building_damage_grid, damage_grid.items, GRID_SIZE * GRID_SIZE);
    map_terrain_save_state(savegame_data.state.terrain_grid);
    buffer_write_raw(savegame_data.state.aqueduct_grid, aqueduct.items, GRID_SIZE * GRID_SIZE);
    buffer_write_raw(savegame_data.state.aqueduct_backup_grid, aqueduct_backup.items, GRID_SIZE * GRID_SIZE);
    for (int i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        buffer_write_u16(savegame_data.state.figure_grid, map_figures.items[i]);
    }
    buffer_write_raw(savegame_data.state.sprite_grid, sprite.items, GRID_SIZE * GRID_SIZE);
    buffer_write_raw(savegame_data.state.sprite_backup_grid, sprite_backup.items, GRID_SIZE * GRID_SIZE);
    map_property_save_state(savegame_data.state.bitfields_grid, savegame_data.state.edge_grid);
    buffer_write_raw(savegame_data.state.random_grid, random.items, GRID_SIZE * GRID_SIZE);
    buffer_write_raw(savegame_data.state.desirability_grid, desirability_grid.items, GRID_SIZE * GRID_SIZE);
    for (int i = 0; i < MAX_FIGURES; i++) {
        buffer_write_u8(savegame_data.state.figures, figures[i].in_use);
        buffer_write_u8(savegame_data.state.figures, figures[i].is_targetable);
        buffer_write_u8(savegame_data.state.figures, figures[i].is_corpse);
        buffer_write_u8(savegame_data.state.figures, figures[i].type);
        buffer_write_u8(savegame_data.state.figures, figures[i].action_state);
        buffer_write_u8(savegame_data.state.figures, figures[i].is_fleeing);
        buffer_write_u8(savegame_data.state.figures, figures[i].formation_id);
        buffer_write_u8(savegame_data.state.figures, figures[i].index_in_formation);
        buffer_write_u8(savegame_data.state.figures, figures[i].damage);
        buffer_write_u8(savegame_data.state.figures, figures[i].is_military_trained);
        buffer_write_u8(savegame_data.state.figures, figures[i].mounted_charge_ticks);
        buffer_write_u8(savegame_data.state.figures, figures[i].mounted_charge_ticks_max);
        buffer_write_u16(savegame_data.state.figures, figures[i].target_figure_id);
        for (int j = 0; j < MAX_MELEE_TARGETERS_PER_UNIT; j++) {
            buffer_write_u16(savegame_data.state.figures, figures[j].melee_targeter_ids[j]);
        }
        for (int j = 0; j < MAX_MELEE_COMBATANTS_PER_UNIT; j++) {
            buffer_write_u16(savegame_data.state.figures, figures[j].melee_combatant_ids[j]);
        }
        buffer_write_u8(savegame_data.state.figures, figures[i].num_melee_combatants);
        for (int j = 0; j < MAX_RANGED_TARGETERS_PER_UNIT; j++) {
            buffer_write_u16(savegame_data.state.figures, figures[j].ranged_targeter_ids[j]);
        }
        buffer_write_u8(savegame_data.state.figures, figures[i].prefect_recent_guard_duty);
        buffer_write_i8(savegame_data.state.figures, figures[i].attack_direction);
        buffer_write_u8(savegame_data.state.figures, figures[i].engaged_in_combat);
        buffer_write_i8(savegame_data.state.figures, figures[i].source_x);
        buffer_write_i8(savegame_data.state.figures, figures[i].source_y);
        buffer_write_u16(savegame_data.state.figures, figures[i].routing_path_id);
        buffer_write_u16(savegame_data.state.figures, figures[i].routing_path_current_tile);
        buffer_write_u16(savegame_data.state.figures, figures[i].routing_path_length);
        buffer_write_u8(savegame_data.state.figures, figures[i].terrain_usage);
        buffer_write_u8(savegame_data.state.figures, figures[i].speed_multiplier);
        buffer_write_i8(savegame_data.state.figures, figures[i].previous_tile_direction);
        buffer_write_i8(savegame_data.state.figures, figures[i].previous_tile_x);
        buffer_write_i8(savegame_data.state.figures, figures[i].previous_tile_y);
        buffer_write_i8(savegame_data.state.figures, figures[i].direction);
        buffer_write_u8(savegame_data.state.figures, figures[i].progress_on_tile);
        buffer_write_i16(savegame_data.state.figures, figures[i].x);
        buffer_write_i16(savegame_data.state.figures, figures[i].y);
        buffer_write_u16(savegame_data.state.figures, figures[i].grid_offset);
        buffer_write_i16(savegame_data.state.figures, figures[i].destination_x);
        buffer_write_i16(savegame_data.state.figures, figures[i].destination_y);
        buffer_write_u16(savegame_data.state.figures, figures[i].destination_grid_offset);
        buffer_write_u16(savegame_data.state.figures, figures[i].destination_building_id);
        buffer_write_u8(savegame_data.state.figures, figures[i].figure_is_halted);
        buffer_write_u8(savegame_data.state.figures, figures[i].use_cross_country);
        buffer_write_u8(savegame_data.state.figures, figures[i].cc_direction);
        buffer_write_u16(savegame_data.state.figures, figures[i].cross_country_x);
        buffer_write_u16(savegame_data.state.figures, figures[i].cross_country_y);
        buffer_write_i16(savegame_data.state.figures, figures[i].cc_delta_x);
        buffer_write_i16(savegame_data.state.figures, figures[i].cc_delta_y);
        buffer_write_i16(savegame_data.state.figures, figures[i].cc_delta_xy);
        buffer_write_u16(savegame_data.state.figures, figures[i].cc_destination_x);
        buffer_write_u16(savegame_data.state.figures, figures[i].cc_destination_y);
        buffer_write_u8(savegame_data.state.figures, figures[i].missile_offset);
        buffer_write_u16(savegame_data.state.figures, figures[i].roam_length);
        buffer_write_u8(savegame_data.state.figures, figures[i].roam_choose_destination);
        buffer_write_u8(savegame_data.state.figures, figures[i].roam_random_counter);
        buffer_write_i8(savegame_data.state.figures, figures[i].roam_turn_direction);
        buffer_write_i8(savegame_data.state.figures, figures[i].roam_ticks_until_next_turn);
        buffer_write_u8(savegame_data.state.figures, figures[i].in_building_wait_ticks);
        buffer_write_u8(savegame_data.state.figures, figures[i].height_adjusted_ticks);
        buffer_write_u8(savegame_data.state.figures, figures[i].current_height);
        buffer_write_u8(savegame_data.state.figures, figures[i].target_height);
        buffer_write_u16(savegame_data.state.figures, figures[i].next_figure_id_on_same_tile);
        buffer_write_u16(savegame_data.state.figures, figures[i].image_id);
        buffer_write_u8(savegame_data.state.figures, figures[i].image_offset);
        buffer_write_u8(savegame_data.state.figures, figures[i].attack_image_offset);
        buffer_write_u8(savegame_data.state.figures, figures[i].is_shooting);
        buffer_write_u16(savegame_data.state.figures, figures[i].cart_image_id);
        buffer_write_i8(savegame_data.state.figures, figures[i].x_offset_cart);
        buffer_write_i8(savegame_data.state.figures, figures[i].y_offset_cart);
        buffer_write_u8(savegame_data.state.figures, figures[i].enemy_image_group);
        buffer_write_i16(savegame_data.state.figures, figures[i].wait_ticks);
        buffer_write_u8(savegame_data.state.figures, figures[i].wait_ticks_missile);
        buffer_write_u16(savegame_data.state.figures, figures[i].name_id);
        buffer_write_u8(savegame_data.state.figures, figures[i].is_invisible);
        buffer_write_u16(savegame_data.state.figures, figures[i].building_id);
        buffer_write_u16(savegame_data.state.figures, figures[i].immigrant_building_id);
        buffer_write_u8(savegame_data.state.figures, figures[i].migrant_num_people);
        buffer_write_u8(savegame_data.state.figures, figures[i].min_max_seen);
        buffer_write_u8(savegame_data.state.figures, figures[i].phrase_sequence_exact);
        buffer_write_i8(savegame_data.state.figures, figures[i].phrase_id);
        buffer_write_u8(savegame_data.state.figures, figures[i].phrase_sequence_city);
        buffer_write_u8(savegame_data.state.figures, figures[i].empire_city_id);
        buffer_write_u8(savegame_data.state.figures, figures[i].resource_id);
        buffer_write_u8(savegame_data.state.figures, figures[i].collecting_item_id);
        buffer_write_u8(savegame_data.state.figures, figures[i].trader_id);
        buffer_write_u16(savegame_data.state.figures, figures[i].leading_figure_id);
        buffer_write_u8(savegame_data.state.figures, figures[i].trader_amount_bought);
        buffer_write_u8(savegame_data.state.figures, figures[i].loads_sold_or_carrying);
        buffer_write_u8(savegame_data.state.figures, figures[i].trade_ship_failed_dock_attempts);
        buffer_write_u8(savegame_data.state.figures, figures[i].flotsam_visible);
    }
    for (int i = 0; i < MAX_ROUTES; i++) {
        buffer_write_i16(savegame_data.state.route_figures, figure_route_data.figure_ids[i]);
        buffer_write_raw(savegame_data.state.route_paths, figure_route_data.direction_paths[i], MAX_PATH_LENGTH);
    }
    for (int i = 0; i < MAX_LEGIONS; i++) {
        formation_save_state(savegame_data.state.legion_formations, &legion_formations[i]);
    }
    for (int i = 0; i < MAX_HERD_POINTS; i++) {
        formation_save_state(savegame_data.state.herd_formations, &herd_formations[i]);
    }
    for (int i = 0; i < MAX_ENEMY_FORMATIONS; i++) {
        formation_save_state(savegame_data.state.enemy_formations, &enemy_formations[i]);
    }
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.tax_percentage);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.treasury);
    buffer_write_i32(savegame_data.state.city_data, city_data.sentiment.value);
    buffer_write_i32(savegame_data.state.city_data, city_data.health.target_value);
    buffer_write_i32(savegame_data.state.city_data, city_data.health.value);
    buffer_write_i32(savegame_data.state.city_data, city_data.health.num_hospital_workers);
    buffer_write_u32(savegame_data.state.city_data, city_data.population.population);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.population_last_year);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.school_age);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.academy_age);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.total_capacity);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.room_in_houses);
    for (int i = 0; i < 2400; i++) {
        buffer_write_i32(savegame_data.state.city_data, city_data.population.monthly.values[i]);
    }
    buffer_write_i32(savegame_data.state.city_data, city_data.population.monthly.next_index);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.monthly.count);
    for (int i = 0; i < 100; i++) {
        buffer_write_i16(savegame_data.state.city_data, city_data.population.at_age[i]);
    }
    for (int i = 0; i < 20; i++) {
        buffer_write_i32(savegame_data.state.city_data, city_data.population.at_level[i]);
    }
    buffer_write_i32(savegame_data.state.city_data, city_data.population.yearly_births);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.yearly_deaths);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.lost_removal);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.immigration_amount_per_batch);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.emigration_amount_per_batch);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.emigration_queue_size);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.immigration_queue_size);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.lost_homeless);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.last_change);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.average_per_year);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.total_all_years);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.people_in_tents_shacks);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.people_in_villas_palaces);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.total_years);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.yearly_update_requested);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.last_used_house_add);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.last_used_house_remove);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.immigrated_today);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.emigrated_today);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.refused_immigrants_today);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.percentage);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.immigration_duration);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.emigration_duration);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.newcomers);
    buffer_write_i16(savegame_data.state.city_data, city_data.resource.last_used_warehouse);
    buffer_write_u8(savegame_data.state.city_data, city_data.building.senate_x);
    buffer_write_u8(savegame_data.state.city_data, city_data.building.senate_y);
    buffer_write_i16(savegame_data.state.city_data, city_data.building.senate_grid_offset);
    buffer_write_i32(savegame_data.state.city_data, city_data.building.senate_building_id);
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        buffer_write_i16(savegame_data.state.city_data, city_data.resource.space_in_warehouses[i]);
    }
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        buffer_write_u16(savegame_data.state.city_data, city_data.resource.stored_in_warehouses[i]);
    }
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        buffer_write_i16(savegame_data.state.city_data, city_data.resource.trade_status[i]);
    }
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        buffer_write_i16(savegame_data.state.city_data, city_data.resource.export_over[i]);
    }
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        buffer_write_i16(savegame_data.state.city_data, city_data.resource.mothballed[i]);
    }
    for (int i = 0; i < FOOD_TYPES_MAX; i++) {
        buffer_write_i32(savegame_data.state.city_data, city_data.resource.granary_food_stored[i]);
    }
    for (int i = 0; i < 6; i++) {
        buffer_write_i32(savegame_data.state.city_data, city_data.resource.stored_in_workshops[i]);
    }
    for (int i = 0; i < 6; i++) {
        buffer_write_i32(savegame_data.state.city_data, city_data.resource.space_in_workshops[i]);
    }
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.granary_total_stored);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.food_types_available);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.food_types_eaten);
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        buffer_write_i32(savegame_data.state.city_data, city_data.resource.stockpiled[i]);
    }
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.food_supply_months);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.granaries.operating);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.percentage_plebs);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.working_age);
    buffer_write_i32(savegame_data.state.city_data, city_data.labor.workers_available);
    for (int i = 0; i < 10; i++) {
        buffer_write_i32(savegame_data.state.city_data, city_data.labor.categories[i].workers_needed);
        buffer_write_i32(savegame_data.state.city_data, city_data.labor.categories[i].workers_allocated);
        buffer_write_i32(savegame_data.state.city_data, city_data.labor.categories[i].total_houses_covered);
        buffer_write_i32(savegame_data.state.city_data, city_data.labor.categories[i].buildings);
        buffer_write_i32(savegame_data.state.city_data, city_data.labor.categories[i].priority);
    }
    buffer_write_i32(savegame_data.state.city_data, city_data.labor.workers_employed);
    buffer_write_i32(savegame_data.state.city_data, city_data.labor.workers_unemployed);
    buffer_write_i32(savegame_data.state.city_data, city_data.labor.unemployment_percentage);
    buffer_write_i32(savegame_data.state.city_data, city_data.labor.unemployment_percentage_for_senate);
    buffer_write_i32(savegame_data.state.city_data, city_data.labor.workers_needed);
    buffer_write_i32(savegame_data.state.city_data, city_data.labor.wages);
    buffer_write_i32(savegame_data.state.city_data, city_data.labor.wages_rome);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.wages_so_far);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.expenses.wages);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.expenses.wages);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.taxed_plebs);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.taxed_patricians);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.untaxed_plebs);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.untaxed_patricians);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.percentage_taxed_plebs);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.percentage_taxed_patricians);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.percentage_taxed_people);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.yearly.collected_plebs);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.yearly.collected_patricians);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.yearly.uncollected_plebs);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.yearly.uncollected_patricians);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.income.taxes);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.income.taxes);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.monthly.collected_plebs);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.monthly.uncollected_plebs);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.monthly.collected_patricians);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.monthly.uncollected_patricians);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.income.exports);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.income.exports);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.expenses.imports);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.expenses.imports);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.interest_so_far);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.expenses.interest);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.expenses.interest);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.expenses.sundries);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.expenses.sundries);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.expenses.construction);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.expenses.construction);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.expenses.salary);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.expenses.salary);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.salary_amount);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.salary_rank);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.salary_so_far);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.income.total);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.income.total);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.expenses.total);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.expenses.total);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.net_in_out);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.net_in_out);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.balance);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.balance);
    buffer_write_i32(savegame_data.state.city_data, city_data.trade.caravan_import_resource);
    buffer_write_i32(savegame_data.state.city_data, city_data.trade.caravan_backup_import_resource);
    buffer_write_u32(savegame_data.state.city_data, city_data.ratings.culture);
    buffer_write_u32(savegame_data.state.city_data, city_data.ratings.prosperity);
    buffer_write_u32(savegame_data.state.city_data, city_data.ratings.peace);
    buffer_write_u32(savegame_data.state.city_data, city_data.ratings.favor);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.prosperity_treasury_last_year);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.peace_num_criminals);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.peace_num_rioters);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.fountain);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.well);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.more_entertainment);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.more_education);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.education);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.requiring.school);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.requiring.library);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.barber);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.bathhouse);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.food);
    buffer_write_i32(savegame_data.state.city_data, city_data.building.hippodrome_placed);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.clinic);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.hospital);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.requiring.barber);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.requiring.bathhouse);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.requiring.clinic);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.religion);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.second_religion);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.third_religion);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.requiring.religion);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.theater_shows);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.theater_no_shows_weighted);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.amphitheater_shows);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.amphitheater_no_shows_weighted);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.colosseum_shows);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.colosseum_no_shows_weighted);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.hippodrome_shows);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.hippodrome_no_shows_weighted);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.venue_needing_shows);
    buffer_write_i32(savegame_data.state.city_data, city_data.culture.average_entertainment);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.entertainment);
    buffer_write_i32(savegame_data.state.city_data, city_data.festival.months_since_festival);
    for (int i = 0; i < MAX_GODS; i++) {
        buffer_write_i8(savegame_data.state.city_data, city_data.religion.gods[i].target_happiness);
    }
    for (int i = 0; i < MAX_GODS; i++) {
        buffer_write_i8(savegame_data.state.city_data, city_data.religion.gods[i].happiness);
    }
    for (int i = 0; i < MAX_GODS; i++) {
        buffer_write_i8(savegame_data.state.city_data, city_data.religion.gods[i].wrath_bolts);
    }
    for (int i = 0; i < MAX_GODS; i++) {
        buffer_write_i8(savegame_data.state.city_data, city_data.religion.gods[i].blessing_done);
    }
    for (int i = 0; i < MAX_GODS; i++) {
        buffer_write_i8(savegame_data.state.city_data, city_data.religion.gods[i].small_curse_done);
    }
    for (int i = 0; i < MAX_GODS; i++) {
        buffer_write_i32(savegame_data.state.city_data, city_data.religion.gods[i].months_since_festival);
    }
    buffer_write_i32(savegame_data.state.city_data, city_data.religion.least_happy_god);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.no_immigration_cause);
    buffer_write_i32(savegame_data.state.city_data, city_data.sentiment.protesters);
    buffer_write_i32(savegame_data.state.city_data, city_data.sentiment.criminals);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.health);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.religion);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.education);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.entertainment);
    buffer_write_i32(savegame_data.state.city_data, city_data.figure.rioters);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.selected);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.culture_explanation);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.prosperity_explanation);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.peace_explanation);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.favor_explanation);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.player_rank);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.personal_savings);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.income.donated);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.income.donated);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.donate_amount);
    for (int i = 0; i < 10; i++) {
        buffer_write_i16(savegame_data.state.city_data, city_data.building.working_dock_ids[i]);
    }
    buffer_write_i16(savegame_data.state.city_data, city_data.figure.animals);
    buffer_write_i16(savegame_data.state.city_data, city_data.trade.num_sea_routes);
    buffer_write_i16(savegame_data.state.city_data, city_data.trade.num_land_routes);
    buffer_write_i16(savegame_data.state.city_data, city_data.trade.sea_trade_problem_duration);
    buffer_write_i16(savegame_data.state.city_data, city_data.trade.land_trade_problem_duration);
    buffer_write_i16(savegame_data.state.city_data, city_data.building.working_docks);
    buffer_write_i16(savegame_data.state.city_data, city_data.building.senate_placed);
    buffer_write_i16(savegame_data.state.city_data, city_data.building.working_wharfs);
    buffer_write_i16(savegame_data.state.city_data, city_data.finance.stolen_this_year);
    buffer_write_i16(savegame_data.state.city_data, city_data.finance.stolen_last_year);
    buffer_write_i32(savegame_data.state.city_data, city_data.trade.docker_import_resource);
    buffer_write_i32(savegame_data.state.city_data, city_data.trade.docker_export_resource);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.debt_state);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.months_in_debt);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.cheated_money);
    buffer_write_i8(savegame_data.state.city_data, city_data.building.barracks_x);
    buffer_write_i8(savegame_data.state.city_data, city_data.building.barracks_y);
    buffer_write_i16(savegame_data.state.city_data, city_data.building.barracks_grid_offset);
    buffer_write_i32(savegame_data.state.city_data, city_data.building.barracks_building_id);
    buffer_write_i32(savegame_data.state.city_data, city_data.building.barracks_placed);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.lost_troop_request);
    buffer_write_i32(savegame_data.state.city_data, city_data.mission.has_won);
    buffer_write_i32(savegame_data.state.city_data, city_data.mission.continue_months_left);
    buffer_write_i32(savegame_data.state.city_data, city_data.mission.continue_months_chosen);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.wage_rate_paid_this_year);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.expenses.tribute);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.expenses.tribute);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.tribute_not_paid_last_year);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.tribute_not_paid_total_years);
    buffer_write_i8(savegame_data.state.city_data, city_data.festival.god);
    buffer_write_i8(savegame_data.state.city_data, city_data.festival.size);
    buffer_write_i32(savegame_data.state.city_data, city_data.festival.cost);
    buffer_write_i32(savegame_data.state.city_data, city_data.festival.months_to_go);
    buffer_write_i32(savegame_data.state.city_data, city_data.culture.average_religion);
    buffer_write_i32(savegame_data.state.city_data, city_data.culture.average_education);
    buffer_write_i32(savegame_data.state.city_data, city_data.culture.average_health);
    buffer_write_i32(savegame_data.state.city_data, city_data.culture.religion_coverage);
    buffer_write_i32(savegame_data.state.city_data, city_data.festival.first_festival_effect_months);
    buffer_write_i32(savegame_data.state.city_data, city_data.festival.second_festival_effect_months);
    buffer_write_i32(savegame_data.state.city_data, city_data.sentiment.previous_value);
    buffer_write_i32(savegame_data.state.city_data, city_data.sentiment.message_delay);
    buffer_write_i32(savegame_data.state.city_data, city_data.sentiment.low_mood_cause);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.months_since_gift);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.gift_overdose_penalty);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.gifts[GIFT_MODEST].id);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.gifts[GIFT_GENEROUS].id);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.gifts[GIFT_LAVISH].id);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.gifts[GIFT_MODEST].cost);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.gifts[GIFT_GENEROUS].cost);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.gifts[GIFT_LAVISH].cost);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.favor_salary_penalty);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.favor_ignored_request_penalty);
    buffer_write_u32(savegame_data.state.city_data, city_data.ratings.favor_last_year);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.favor_change);
    buffer_write_i32(savegame_data.state.city_data, city_data.military.native_attack_duration);
    buffer_write_i32(savegame_data.state.city_data, city_data.building.mission_post_operational);
    buffer_write_i32(savegame_data.state.city_data, city_data.building.main_native_meeting.x);
    buffer_write_i32(savegame_data.state.city_data, city_data.building.main_native_meeting.y);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.wage_rate_paid_last_year);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.food_needed_per_month);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.granaries.understaffed);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.granaries.not_operating);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.granaries.not_operating_with_food);
    buffer_write_i32(savegame_data.state.city_data, city_data.religion.venus_curse_active);
    buffer_write_i32(savegame_data.state.city_data, city_data.religion.neptune_double_trade_active);
    buffer_write_i32(savegame_data.state.city_data, city_data.religion.mars_spirit_power);
    buffer_write_i32(savegame_data.state.city_data, city_data.religion.angry_message_delay);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.food_consumed_last_month);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.food_produced_last_month);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.food_produced_this_month);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.peace_riot_cause);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.estimated_tax_income);
    buffer_write_i32(savegame_data.state.city_data, city_data.building.shipyard_boats_requested);
    buffer_write_i32(savegame_data.state.city_data, city_data.figure.enemies);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.people_in_tents);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.people_in_large_insula_and_above);
    buffer_write_i32(savegame_data.state.city_data, city_data.figure.imperial_soldiers);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.invasion.duration_day_countdown);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.invasion.warnings_given);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.invasion.days_until_invasion);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.invasion.retreat_message_shown);
    buffer_write_i16(savegame_data.state.city_data, city_data.emperor.invasion.from_editor);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.peace_destroyed_buildings);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.peace_years_of_peace);
    buffer_write_u8(savegame_data.state.city_data, city_data.distant_battle.city);
    buffer_write_u8(savegame_data.state.city_data, city_data.distant_battle.enemy_strength);
    buffer_write_u8(savegame_data.state.city_data, city_data.distant_battle.roman_strength);
    buffer_write_i8(savegame_data.state.city_data, city_data.distant_battle.months_until_battle);
    buffer_write_i8(savegame_data.state.city_data, city_data.distant_battle.roman_months_to_travel_back);
    buffer_write_i8(savegame_data.state.city_data, city_data.distant_battle.roman_months_to_travel_forth);
    buffer_write_i8(savegame_data.state.city_data, city_data.distant_battle.city_foreign_months_left);
    buffer_write_i8(savegame_data.state.city_data, city_data.building.triumphal_arches_available);
    buffer_write_i8(savegame_data.state.city_data, city_data.distant_battle.total_count);
    buffer_write_i8(savegame_data.state.city_data, city_data.distant_battle.won_count);
    buffer_write_i8(savegame_data.state.city_data, city_data.distant_battle.enemy_months_traveled);
    buffer_write_i8(savegame_data.state.city_data, city_data.distant_battle.roman_months_traveled);
    buffer_write_u8(savegame_data.state.city_data, city_data.military.total_legions);
    buffer_write_u8(savegame_data.state.city_data, city_data.sound.die_citizen);
    buffer_write_u8(savegame_data.state.city_data, city_data.sound.die_soldier);
    buffer_write_i32(savegame_data.state.city_data, city_data.building.trade_center_building_id);
    buffer_write_i32(savegame_data.state.city_data, city_data.figure.soldiers);
    buffer_write_u8(savegame_data.state.city_data, city_data.sound.hit_elephant);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.invasion.count);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.invasion.size);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.invasion.soldiers_killed);
    buffer_write_i32(savegame_data.state.city_data, city_data.military.legionary_legions);
    buffer_write_u32(savegame_data.state.city_data, city_data.population.highest_ever);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.estimated_wages);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.wine_types_available);
    buffer_write_u32(savegame_data.state.city_data, city_data.ratings.prosperity_max);
    for (int i = 0; i < 10; i++) {
        buffer_write_i32(savegame_data.state.city_data, city_data.map.largest_road_networks[i].id);
        buffer_write_i32(savegame_data.state.city_data, city_data.map.largest_road_networks[i].size);
    }
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.second_wine);
    buffer_write_i32(savegame_data.state.city_data, city_data.religion.neptune_sank_ships);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.hippodrome_has_race);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.hippodrome_message_shown);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.colosseum_message_shown);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.emigration_message_shown);
    buffer_write_i32(savegame_data.state.city_data, city_data.mission.fired_message_shown);
    buffer_write_i32(savegame_data.state.city_data, city_data.mission.victory_message_shown);
    buffer_write_i32(savegame_data.state.city_graph_order, city_data.population.graph_order);
    for (int i = 0; i < MAX_BUILDINGS; i++) {
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].state);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].size);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].house_is_merged);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].house_size);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].x);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].y);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].grid_offset);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].type);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].subtype.house_level); // which union field we use does not matter
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].road_network_id);
        buffer_write_u16(savegame_data.state.buildings, all_buildings[i].created_sequence);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].houses_covered);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].percentage_houses_covered);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].house_population);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].house_population_room);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].house_highest_population);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].road_access_x);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].road_access_y);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].figure_id);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].figure_id2);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].immigrant_figure_id);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].figure_id4);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].figure_spawn_delay);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].figure_roam_direction);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].has_water_access);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].prev_part_building_id);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].next_part_building_id);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].loads_stored);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].has_well_access);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].num_workers);
        buffer_write_i8(savegame_data.state.buildings, all_buildings[i].labor_category);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].output_resource_id);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].has_road_access);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].house_criminal_active);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].damage_risk);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].fire_risk);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].fire_duration);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].fire_proof);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].house_figure_generation_delay);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].house_tax_coverage);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].formation_id);
        if (building_is_house(all_buildings[i].type)) {
            for (int j = 0; j < INVENTORY_MAX; j++) {
                buffer_write_i16(savegame_data.state.buildings, all_buildings[j].data.house.inventory[j]);
            }
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.theater);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.amphitheater_actor);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.amphitheater_gladiator);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.colosseum_gladiator);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.colosseum_lion);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.hippodrome);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.school);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.library);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.academy);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.barber);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.clinic);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.bathhouse);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.hospital);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.temple_ceres);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.temple_neptune);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.temple_mercury);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.temple_mars);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.temple_venus);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.no_space_to_expand);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.num_foods);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.entertainment);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.education);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.health);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.num_gods);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.devolve_delay);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.evolve_text_id);
        } else if (all_buildings[i].type == BUILDING_MARKET) {
            for (int j = 0; j < INVENTORY_MAX; j++) {
                buffer_write_i16(savegame_data.state.buildings, all_buildings[j].data.market.inventory[j]);
            }
            buffer_write_i16(savegame_data.state.buildings, all_buildings[i].data.market.pottery_demand);
            buffer_write_i16(savegame_data.state.buildings, all_buildings[i].data.market.furniture_demand);
            buffer_write_i16(savegame_data.state.buildings, all_buildings[i].data.market.oil_demand);
            buffer_write_i16(savegame_data.state.buildings, all_buildings[i].data.market.wine_demand);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.market.fetch_inventory_id);
        } else if (all_buildings[i].type == BUILDING_GRANARY) {
            for (int j = 0; j < RESOURCE_TYPES_MAX; j++) {
                buffer_write_i16(savegame_data.state.buildings, all_buildings[j].data.granary.resource_stored[j]);
            }
        } else if (all_buildings[i].type == BUILDING_DOCK) {
            buffer_write_i16(savegame_data.state.buildings, all_buildings[i].data.dock.queued_docker_id);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.dock.num_ships);
            buffer_write_i8(savegame_data.state.buildings, all_buildings[i].data.dock.orientation);
            for (int j = 0; j < 3; j++) {
                buffer_write_i16(savegame_data.state.buildings, all_buildings[j].data.dock.docker_ids[j]);
            }
            buffer_write_i16(savegame_data.state.buildings, all_buildings[i].data.dock.trade_ship_id);
        } else if (is_industry_type(&all_buildings[i])) {
            buffer_write_i16(savegame_data.state.buildings, all_buildings[i].data.industry.progress);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.industry.has_fish);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.industry.blessing_days_left);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.industry.orientation);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.industry.has_raw_materials);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.industry.curse_days_left);
            buffer_write_i16(savegame_data.state.buildings, all_buildings[i].data.industry.fishing_boat_id);
        } else {
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.entertainment.num_shows);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.entertainment.days1);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.entertainment.days2);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.entertainment.play);
        }
        buffer_write_i32(savegame_data.state.buildings, all_buildings[i].tax_income_or_storage);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].house_days_without_food);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].ruin_has_plague);
        buffer_write_i8(savegame_data.state.buildings, all_buildings[i].desirability);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].is_deleted);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].storage_id);
        buffer_write_i8(savegame_data.state.buildings, all_buildings[i].sentiment.house_happiness); // which union field we use does not matter
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].show_on_problem_overlay);
    }
    buffer_write_i32(savegame_data.state.building_extra_highest_id, extra.highest_id_in_use);
    buffer_write_i32(savegame_data.state.building_extra_highest_id_ever, extra.highest_id_ever);
    buffer_write_i32(savegame_data.state.building_extra_sequence, extra.created_sequence);
    buffer_write_i32(savegame_data.state.building_extra_corrupt_houses, extra.incorrect_houses);
    buffer_write_i32(savegame_data.state.building_extra_corrupt_houses, extra.unfixable_houses);
    buffer_write_i32(savegame_data.state.building_barracks_tower_sentry, tower_sentry_request);
    buffer_write_i32(savegame_data.state.city_view_orientation, view_data.orientation);
    buffer_write_i32(savegame_data.state.city_view_camera, view_data.camera.tile.x);
    buffer_write_i32(savegame_data.state.city_view_camera, view_data.camera.tile.y);
    buffer_write_i32(savegame_data.state.game_time, time_data.tick);
    buffer_write_i32(savegame_data.state.game_time, time_data.day);
    buffer_write_i32(savegame_data.state.game_time, time_data.month);
    buffer_write_i32(savegame_data.state.game_time, time_data.year);
    buffer_write_i32(savegame_data.state.game_time, time_data.total_days);
    random_save_state(savegame_data.state.random_iv);
    // industry
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        buffer_write_i32(savegame_data.state.building_count_industry, count_data.industry[i].total);
    }
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        buffer_write_i32(savegame_data.state.building_count_industry, count_data.industry[i].active);
    }
    // culture 1
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_THEATER].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_THEATER].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_AMPHITHEATER].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_AMPHITHEATER].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_COLOSSEUM].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_COLOSSEUM].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_HIPPODROME].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_HIPPODROME].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_SCHOOL].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_SCHOOL].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_LIBRARY].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_LIBRARY].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_ACADEMY].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_ACADEMY].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_BARBER].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_BARBER].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_BATHHOUSE].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_BATHHOUSE].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_DOCTOR].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_DOCTOR].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_HOSPITAL].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_HOSPITAL].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_SMALL_TEMPLE_CERES].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_SMALL_TEMPLE_NEPTUNE].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_SMALL_TEMPLE_MERCURY].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_SMALL_TEMPLE_MARS].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_SMALL_TEMPLE_VENUS].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_LARGE_TEMPLE_CERES].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_LARGE_TEMPLE_NEPTUNE].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_LARGE_TEMPLE_MERCURY].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_LARGE_TEMPLE_MARS].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_LARGE_TEMPLE_VENUS].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_ORACLE].total);
    // culture 2
    buffer_write_i32(savegame_data.state.building_count_culture2, count_data.buildings[BUILDING_ACTOR_COLONY].total);
    buffer_write_i32(savegame_data.state.building_count_culture2, count_data.buildings[BUILDING_ACTOR_COLONY].active);
    buffer_write_i32(savegame_data.state.building_count_culture2, count_data.buildings[BUILDING_GLADIATOR_SCHOOL].total);
    buffer_write_i32(savegame_data.state.building_count_culture2, count_data.buildings[BUILDING_GLADIATOR_SCHOOL].active);
    buffer_write_i32(savegame_data.state.building_count_culture2, count_data.buildings[BUILDING_LION_HOUSE].total);
    buffer_write_i32(savegame_data.state.building_count_culture2, count_data.buildings[BUILDING_LION_HOUSE].active);
    buffer_write_i32(savegame_data.state.building_count_culture2, count_data.buildings[BUILDING_CHARIOT_MAKER].total);
    buffer_write_i32(savegame_data.state.building_count_culture2, count_data.buildings[BUILDING_CHARIOT_MAKER].active);
    // culture 3
    buffer_write_i32(savegame_data.state.building_count_culture3, count_data.buildings[BUILDING_SMALL_TEMPLE_CERES].active);
    buffer_write_i32(savegame_data.state.building_count_culture3, count_data.buildings[BUILDING_SMALL_TEMPLE_NEPTUNE].active);
    buffer_write_i32(savegame_data.state.building_count_culture3, count_data.buildings[BUILDING_SMALL_TEMPLE_MERCURY].active);
    buffer_write_i32(savegame_data.state.building_count_culture3, count_data.buildings[BUILDING_SMALL_TEMPLE_MARS].active);
    buffer_write_i32(savegame_data.state.building_count_culture3, count_data.buildings[BUILDING_SMALL_TEMPLE_VENUS].active);
    buffer_write_i32(savegame_data.state.building_count_culture3, count_data.buildings[BUILDING_LARGE_TEMPLE_CERES].active);
    buffer_write_i32(savegame_data.state.building_count_culture3, count_data.buildings[BUILDING_LARGE_TEMPLE_NEPTUNE].active);
    buffer_write_i32(savegame_data.state.building_count_culture3, count_data.buildings[BUILDING_LARGE_TEMPLE_MERCURY].active);
    buffer_write_i32(savegame_data.state.building_count_culture3, count_data.buildings[BUILDING_LARGE_TEMPLE_MARS].active);
    buffer_write_i32(savegame_data.state.building_count_culture3, count_data.buildings[BUILDING_LARGE_TEMPLE_VENUS].active);
    // military
    buffer_write_i32(savegame_data.state.building_count_military, count_data.buildings[BUILDING_MILITARY_ACADEMY].total);
    buffer_write_i32(savegame_data.state.building_count_military, count_data.buildings[BUILDING_MILITARY_ACADEMY].active);
    buffer_write_i32(savegame_data.state.building_count_military, count_data.buildings[BUILDING_BARRACKS].total);
    buffer_write_i32(savegame_data.state.building_count_military, count_data.buildings[BUILDING_BARRACKS].active);
    // support
    buffer_write_i32(savegame_data.state.building_count_support, count_data.buildings[BUILDING_MARKET].total);
    buffer_write_i32(savegame_data.state.building_count_support, count_data.buildings[BUILDING_MARKET].active);
    buffer_write_i32(savegame_data.state.building_count_support, count_data.buildings[BUILDING_RESERVOIR].total);
    buffer_write_i32(savegame_data.state.building_count_support, count_data.buildings[BUILDING_RESERVOIR].active);
    buffer_write_i32(savegame_data.state.building_count_support, count_data.buildings[BUILDING_FOUNTAIN].total);
    buffer_write_i32(savegame_data.state.building_count_support, count_data.buildings[BUILDING_FOUNTAIN].active);
    buffer_write_i32(savegame_data.state.empire, empire_data.scroll_x);
    buffer_write_i32(savegame_data.state.empire, empire_data.scroll_y);
    empire_object_save_state(savegame_data.state.empire_objects);
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        buffer_write_u16(savegame_data.state.trade_prices, trade_prices[i].buy);
        buffer_write_u16(savegame_data.state.trade_prices, trade_prices[i].sell);
    }
    buffer_write_i32(savegame_data.state.figure_names, name_data.citizen_male);
    buffer_write_i32(savegame_data.state.figure_names, name_data.patrician);
    buffer_write_i32(savegame_data.state.figure_names, name_data.citizen_female);
    buffer_write_i32(savegame_data.state.figure_names, name_data.tax_collector);
    buffer_write_i32(savegame_data.state.figure_names, name_data.engineer);
    buffer_write_i32(savegame_data.state.figure_names, name_data.prefect);
    buffer_write_i32(savegame_data.state.figure_names, name_data.javelin_thrower);
    buffer_write_i32(savegame_data.state.figure_names, name_data.cavalry);
    buffer_write_i32(savegame_data.state.figure_names, name_data.legionary);
    buffer_write_i32(savegame_data.state.figure_names, name_data.actor);
    buffer_write_i32(savegame_data.state.figure_names, name_data.gladiator);
    buffer_write_i32(savegame_data.state.figure_names, name_data.lion_tamer);
    buffer_write_i32(savegame_data.state.figure_names, name_data.charioteer);
    buffer_write_i32(savegame_data.state.figure_names, name_data.barbarian);
    buffer_write_i32(savegame_data.state.figure_names, name_data.enemy_greek);
    buffer_write_i32(savegame_data.state.figure_names, name_data.enemy_egyptian);
    buffer_write_i32(savegame_data.state.figure_names, name_data.enemy_arabian);
    buffer_write_i32(savegame_data.state.figure_names, name_data.trader);
    buffer_write_i32(savegame_data.state.figure_names, name_data.ship);
    buffer_write_i32(savegame_data.state.culture_coverage, culture_coverage.theater);
    buffer_write_i32(savegame_data.state.culture_coverage, culture_coverage.amphitheater);
    buffer_write_i32(savegame_data.state.culture_coverage, culture_coverage.colosseum);
    buffer_write_i32(savegame_data.state.culture_coverage, culture_coverage.hippodrome);
    for (int i = GOD_CERES; i <= GOD_VENUS; i++) {
        buffer_write_i32(savegame_data.state.culture_coverage, culture_coverage.religion[i]);
    }
    buffer_write_i32(savegame_data.state.culture_coverage, culture_coverage.oracle);
    buffer_write_i32(savegame_data.state.culture_coverage, culture_coverage.school);
    buffer_write_i32(savegame_data.state.culture_coverage, culture_coverage.library);
    buffer_write_i32(savegame_data.state.culture_coverage, culture_coverage.academy);
    buffer_write_i32(savegame_data.state.culture_coverage, culture_coverage.hospital);
    scenario_save_state(savegame_data.state.scenario);
    for (int i = 0; i < MAX_MESSAGES; i++) {
        struct city_message_t *msg = &message_data.messages[i];
        buffer_write_i32(savegame_data.state.messages, msg->param1);
        buffer_write_i16(savegame_data.state.messages, msg->year);
        buffer_write_i16(savegame_data.state.messages, msg->param2);
        buffer_write_i16(savegame_data.state.messages, msg->message_type);
        buffer_write_i16(savegame_data.state.messages, msg->sequence);
        buffer_write_u8(savegame_data.state.messages, msg->is_read);
        buffer_write_u8(savegame_data.state.messages, msg->month);
    }

    buffer_write_i32(savegame_data.state.message_extra, message_data.next_message_sequence);
    buffer_write_i32(savegame_data.state.message_extra, message_data.total_messages);
    buffer_write_i32(savegame_data.state.message_extra, message_data.current_message_id);

    for (int i = 0; i < MAX_MESSAGE_CATEGORIES; i++) {
        buffer_write_i32(savegame_data.state.message_counts, message_data.message_count[i]);
        buffer_write_i32(savegame_data.state.message_delays, message_data.message_delay[i]);
    }
    // population
    buffer_write_u8(savegame_data.state.population_messages, message_data.population_shown.pop500);
    buffer_write_u8(savegame_data.state.population_messages, message_data.population_shown.pop1000);
    buffer_write_u8(savegame_data.state.population_messages, message_data.population_shown.pop2000);
    buffer_write_u8(savegame_data.state.population_messages, message_data.population_shown.pop3000);
    buffer_write_u8(savegame_data.state.population_messages, message_data.population_shown.pop5000);
    buffer_write_u8(savegame_data.state.population_messages, message_data.population_shown.pop10000);
    buffer_write_u8(savegame_data.state.population_messages, message_data.population_shown.pop15000);
    buffer_write_u8(savegame_data.state.population_messages, message_data.population_shown.pop20000);
    buffer_write_u8(savegame_data.state.population_messages, message_data.population_shown.pop25000);
    for (int i = 0; i < MAX_CITY_SOUNDS_CHANNELS; i++) {
        struct city_channel_t *ch = &channels[i];
        buffer_write_i32(savegame_data.state.city_sounds, ch->available);
        buffer_write_i32(savegame_data.state.city_sounds, ch->total_views);
        buffer_write_i32(savegame_data.state.city_sounds, ch->views_threshold);
        for (int d = 0; d < 5; d++) {
            buffer_write_i32(savegame_data.state.city_sounds, ch->direction_views[d]);
        }
        buffer_write_i32(savegame_data.state.city_sounds, ch->channel);
        buffer_write_i32(savegame_data.state.city_sounds, ch->in_use);
        buffer_write_i32(savegame_data.state.city_sounds, ch->times_played);
        buffer_write_u32(savegame_data.state.city_sounds, ch->last_played_time);
        buffer_write_u32(savegame_data.state.city_sounds, ch->delay_millis);
        buffer_write_i32(savegame_data.state.city_sounds, ch->should_play);
    }
    for (int i = 0; i < MAX_TRADERS; i++) {
        struct trader *t = &figure_trader_data.traders[i];
        buffer_write_i32(savegame_data.state.figure_traders, t->bought_amount);
        buffer_write_i32(savegame_data.state.figure_traders, t->sold_amount);
        for (int r = 0; r < RESOURCE_TYPES_MAX; r++) {
            buffer_write_u8(savegame_data.state.figure_traders, t->bought_resources[r]);
        }
        for (int r = 0; r < RESOURCE_TYPES_MAX; r++) {
            buffer_write_u8(savegame_data.state.figure_traders, t->sold_resources[r]);
        }
    }
    buffer_write_i32(savegame_data.state.figure_traders, figure_trader_data.next_index);
    for (int i = 0; i < MAX_SMALL; i++) {
        buffer_write_i16(savegame_data.state.building_list_small, building_list_data.small.items[i]);
    }
    for (int i = 0; i < MAX_LARGE; i++) {
        buffer_write_i16(savegame_data.state.building_list_large, building_list_data.large.items[i]);
    }
    for (int i = 0; i < MAX_BURNING; i++) {
        buffer_write_i16(savegame_data.state.building_list_burning, building_list_data.burning.items[i]);
    }
    buffer_write_i32(savegame_data.state.building_list_burning_totals, building_list_data.burning.total);
    buffer_write_i32(savegame_data.state.building_list_burning_totals, building_list_data.burning.size);
    for (int i = 0; i < MAX_STORAGES; i++) {
        buffer_write_i32(savegame_data.state.building_storages, storages[i].building_id);
        buffer_write_u8(savegame_data.state.building_storages, (uint8_t) storages[i].in_use);
        buffer_write_u8(savegame_data.state.building_storages, (uint8_t) storages[i].storage.empty_all);
        for (int r = 0; r < RESOURCE_TYPES_MAX; r++) {
            buffer_write_u8(savegame_data.state.building_storages, storages[i].storage.resource_state[r]);
        }
    }
    buffer_write_i32(savegame_data.state.routing_counters, stats.enemy_routes_calculated);
    buffer_write_i32(savegame_data.state.routing_counters, stats.total_routes_calculated);
    for (int i = 0; i < MAX_BOOKMARKS; i++) {
        buffer_write_i32(savegame_data.state.bookmarks, bookmarks[i].x);
        buffer_write_i32(savegame_data.state.bookmarks, bookmarks[i].y);
    }

    static char dir_prepended_filepath[DIR_PATH_MAX];
    prepend_dir_to_path(dir, filename, dir_prepended_filepath);

    FILE *fp = fopen(dir_prepended_filepath, "wb");
    if (!fp) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to save game", 0, 0));
        return 0;
    }
    for (int i = 0; i < savegame_data.num_pieces; i++) {
        struct file_piece_t *piece = &savegame_data.pieces[i];
        fwrite(piece->buf.data, 1, piece->buf.size, fp);
    }
    fclose(fp);
    return 1;
}

static void formation_load_state(struct buffer_t *buf, struct formation_t *m)
{
    m->in_use = buffer_read_u8(buf);
    m->layout = buffer_read_u8(buf);
    m->figure_type = buffer_read_u8(buf);
    m->num_figures = buffer_read_u8(buf);
    m->max_figures = buffer_read_u8(buf);
    for (int fig = 0; fig < MAX_FORMATION_FIGURES; fig++) {
        m->figures[fig] = buffer_read_u16(buf);
    }
    m->has_military_training = buffer_read_u8(buf);
    m->is_at_rest = buffer_read_u8(buf);
    m->deployed_duration_months = buffer_read_u8(buf);
    m->direction = buffer_read_u8(buf);
    m->morale = buffer_read_u8(buf);
    m->max_morale = buffer_read_u8(buf);
    m->routed = buffer_read_u8(buf);
    m->wait_ticks_movement = buffer_read_i16(buf);
    m->standard_x = buffer_read_u16(buf);
    m->standard_y = buffer_read_u16(buf);
    m->prev_standard_x = buffer_read_u16(buf);
    m->prev_standard_y = buffer_read_u16(buf);
    m->legion_standard__figure_id = buffer_read_u16(buf);
    m->building_id = buffer_read_u16(buf);
    m->empire_service = buffer_read_u8(buf);
    m->in_distant_battle = buffer_read_u8(buf);
    m->cursed_by_mars = buffer_read_u8(buf);
    m->recent_fight = buffer_read_u8(buf);
    m->missile_attack_timeout = buffer_read_u8(buf);
    m->destination_x = buffer_read_u16(buf);
    m->destination_y = buffer_read_u16(buf);
    m->wolf_spawn_delay = buffer_read_u16(buf);
    m->attack_priority = buffer_read_u8(buf);
}

static int empire_object_init_distant_battle_travel_months(int object_type)
{
    int month = 0;
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        if (empire_objects[i].in_use && empire_objects[i].type == object_type) {
            month++;
            empire_objects[i].distant_battle_travel_months = month;
        }
    }
    return month;
}

static void add_road(int grid_offset)
{
    if (!map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR)) {
        terrain_grid.items[grid_offset] |= TERRAIN_ROAD;
    }
}

static void map_terrain_add_gatehouse_roads(int x, int y, int orientation)
{
    // roads under gatehouse
    terrain_grid.items[map_grid_offset(x, y)] |= TERRAIN_ROAD;
    terrain_grid.items[map_grid_offset(x + 1, y)] |= TERRAIN_ROAD;
    terrain_grid.items[map_grid_offset(x, y + 1)] |= TERRAIN_ROAD;
    terrain_grid.items[map_grid_offset(x + 1, y + 1)] |= TERRAIN_ROAD;

    // free roads before/after gate
    if (orientation == 1) {
        add_road(map_grid_offset(x, y - 1));
        add_road(map_grid_offset(x + 1, y - 1));
        add_road(map_grid_offset(x, y + 2));
        add_road(map_grid_offset(x + 1, y + 2));
    } else if (orientation == 2) {
        add_road(map_grid_offset(x - 1, y));
        add_road(map_grid_offset(x - 1, y + 1));
        add_road(map_grid_offset(x + 2, y));
        add_road(map_grid_offset(x + 2, y + 1));
    }
}

static void map_terrain_add_triumphal_arch_roads(int x, int y, int orientation)
{
    if (orientation == 1) {
        // road in the middle
        terrain_grid.items[map_grid_offset(x + 1, y)] |= TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 1, y + 1)] |= TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 1, y + 2)] |= TERRAIN_ROAD;
        // no roads on other tiles
        terrain_grid.items[map_grid_offset(x, y)] &= ~TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x, y + 1)] &= ~TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x, y + 2)] &= ~TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 2, y)] &= ~TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 2, y + 1)] &= ~TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 2, y + 2)] &= ~TERRAIN_ROAD;
    } else if (orientation == 2) {
        // road in the middle
        terrain_grid.items[map_grid_offset(x, y + 1)] |= TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 1, y + 1)] |= TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 2, y + 1)] |= TERRAIN_ROAD;
        // no roads on other tiles
        terrain_grid.items[map_grid_offset(x, y)] &= ~TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 1, y)] &= ~TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 2, y)] &= ~TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x, y + 2)] &= ~TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 1, y + 2)] &= ~TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 2, y + 2)] &= ~TERRAIN_ROAD;
    }
}

static void map_water_add_building(int building_id, int x, int y, int size, int image_id)
{
    if (!map_grid_is_inside(x, y, size)) {
        return;
    }
    struct map_point_t leftmost;
    switch (view_data.orientation) {
        case DIR_0_TOP:
            leftmost.x = 0;
            leftmost.y = size - 1;
            break;
        case DIR_2_RIGHT:
            leftmost.x = leftmost.y = 0;
            break;
        case DIR_4_BOTTOM:
            leftmost.x = size - 1;
            leftmost.y = 0;
            break;
        case DIR_6_LEFT:
            leftmost.x = leftmost.y = size - 1;
            break;
        default:
            return;
    }
    for (int dy = 0; dy < size; dy++) {
        for (int dx = 0; dx < size; dx++) {
            int grid_offset = map_grid_offset(x + dx, y + dy);
            terrain_grid.items[grid_offset] |= TERRAIN_BUILDING;
            if (!map_terrain_is(grid_offset, TERRAIN_WATER)) {
                terrain_grid.items[grid_offset] &= ~TERRAIN_CLEARABLE;
                terrain_grid.items[grid_offset] |= TERRAIN_BUILDING;
            }
            buildings_grid.items[grid_offset] = building_id;
            bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
            map_property_set_multi_tile_size(grid_offset, size);
            images.items[grid_offset] = image_id;
            map_property_set_multi_tile_xy(grid_offset, dx, dy,
                dx == leftmost.x && dy == leftmost.y);
        }
    }
}

static void map_orientation_update_buildings(void)
{
    int map_orientation = view_data.orientation;
    int orientation_is_top_bottom = map_orientation == DIR_0_TOP || map_orientation == DIR_4_BOTTOM;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_UNUSED || b->state == BUILDING_STATE_DELETED_BY_GAME) {
            continue;
        }
        int image_id;
        int image_offset;
        switch (b->type) {
            case BUILDING_GATEHOUSE:
                if (b->subtype.orientation == 1) {
                    if (orientation_is_top_bottom) {
                        image_id = image_data_s.group_image_ids[GROUP_BUILDING_TOWER] + 1;
                    } else {
                        image_id = image_data_s.group_image_ids[GROUP_BUILDING_TOWER] + 2;
                    }
                } else {
                    if (orientation_is_top_bottom) {
                        image_id = image_data_s.group_image_ids[GROUP_BUILDING_TOWER] + 2;
                    } else {
                        image_id = image_data_s.group_image_ids[GROUP_BUILDING_TOWER] + 1;
                    }
                }
                map_building_tiles_add(i, b->x, b->y, b->size, image_id, TERRAIN_GATEHOUSE | TERRAIN_BUILDING);
                map_terrain_add_gatehouse_roads(b->x, b->y, 0);
                break;
            case BUILDING_TRIUMPHAL_ARCH:
                if (b->subtype.orientation == 1) {
                    if (orientation_is_top_bottom) {
                        image_id = image_data_s.group_image_ids[GROUP_BUILDING_TRIUMPHAL_ARCH];
                    } else {
                        image_id = image_data_s.group_image_ids[GROUP_BUILDING_TRIUMPHAL_ARCH] + 2;
                    }
                } else {
                    if (orientation_is_top_bottom) {
                        image_id = image_data_s.group_image_ids[GROUP_BUILDING_TRIUMPHAL_ARCH] + 2;
                    } else {
                        image_id = image_data_s.group_image_ids[GROUP_BUILDING_TRIUMPHAL_ARCH];
                    }
                }
                map_building_tiles_add(i, b->x, b->y, b->size, image_id, TERRAIN_BUILDING);
                map_terrain_add_triumphal_arch_roads(b->x, b->y, b->subtype.orientation);
                break;
            case BUILDING_HIPPODROME:
                if (map_orientation == DIR_0_TOP) {
                    image_id = image_data_s.group_image_ids[GROUP_BUILDING_HIPPODROME_2];
                    switch (b->subtype.orientation) {
                        case 0: case 3: image_id += 0; break;
                        case 1: case 4: image_id += 2; break;
                        case 2: case 5: image_id += 4; break;
                    }
                } else if (map_orientation == DIR_4_BOTTOM) {
                    image_id = image_data_s.group_image_ids[GROUP_BUILDING_HIPPODROME_2];
                    switch (b->subtype.orientation) {
                        case 0: case 3: image_id += 4; break;
                        case 1: case 4: image_id += 2; break;
                        case 2: case 5: image_id += 0; break;
                    }
                } else if (map_orientation == DIR_6_LEFT) {
                    image_id = image_data_s.group_image_ids[GROUP_BUILDING_HIPPODROME_1];
                    switch (b->subtype.orientation) {
                        case 0: case 3: image_id += 0; break;
                        case 1: case 4: image_id += 2; break;
                        case 2: case 5: image_id += 4; break;
                    }
                } else { // DIR_2_RIGHT
                    image_id = image_data_s.group_image_ids[GROUP_BUILDING_HIPPODROME_1];
                    switch (b->subtype.orientation) {
                        case 0: case 3: image_id += 4; break;
                        case 1: case 4: image_id += 2; break;
                        case 2: case 5: image_id += 0; break;
                    }
                }
                map_building_tiles_add(i, b->x, b->y, b->size, image_id, TERRAIN_BUILDING);
                break;
            case BUILDING_SHIPYARD:
                image_offset = (4 + b->data.industry.orientation - map_orientation / 2) % 4;
                image_id = image_data_s.group_image_ids[GROUP_BUILDING_SHIPYARD] + image_offset;
                map_water_add_building(i, b->x, b->y, 2, image_id);
                break;
            case BUILDING_WHARF:
                image_offset = (4 + b->data.industry.orientation - map_orientation / 2) % 4;
                image_id = image_data_s.group_image_ids[GROUP_BUILDING_WHARF] + image_offset;
                map_water_add_building(i, b->x, b->y, 2, image_id);
                break;
            case BUILDING_DOCK:
                image_offset = (4 + b->data.dock.orientation - map_orientation / 2) % 4;
                switch (image_offset) {
                    case 0: image_id = image_data_s.group_image_ids[GROUP_BUILDING_DOCK_1]; break;
                    case 1: image_id = image_data_s.group_image_ids[GROUP_BUILDING_DOCK_2]; break;
                    case 2: image_id = image_data_s.group_image_ids[GROUP_BUILDING_DOCK_3]; break;
                    default:image_id = image_data_s.group_image_ids[GROUP_BUILDING_DOCK_4]; break;
                }
                map_water_add_building(i, b->x, b->y, 3, image_id);
                break;
        }
    }
}

static int map_routing_citizen_is_passable(int grid_offset)
{
    return terrain_land_citizen.items[grid_offset] == CITIZEN_0_ROAD ||
        terrain_land_citizen.items[grid_offset] == CITIZEN_2_PASSABLE_TERRAIN;
}

static void map_road_network_update(void)
{
    for (int i = 0; i < 10; i++) {
        city_data.map.largest_road_networks[i].id = 0;
        city_data.map.largest_road_networks[i].size = 0;
    }
    memset(network.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    int network_id = 1;
    int grid_offset = map_data.start_offset;
    for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (map_terrain_is(grid_offset, TERRAIN_ROAD) && !network.items[grid_offset]) {
                memset(&road_network_queue, 0, sizeof(road_network_queue));
                int guard = 0;
                int next_offset;
                int size = 1;
                do {
                    if (++guard >= GRID_SIZE * GRID_SIZE) {
                        break;
                    }
                    network.items[grid_offset] = network_id;
                    next_offset = -1;
                    for (int i = 0; i < 4; i++) {
                        int new_offset = grid_offset + ADJACENT_OFFSETS_ROUTING[i];
                        if (map_routing_citizen_is_passable(new_offset) && !network.items[new_offset]) {
                            if (terrain_land_citizen.items[new_offset] == CITIZEN_0_ROAD || map_terrain_is(new_offset, TERRAIN_ACCESS_RAMP)) {
                                network.items[new_offset] = network_id;
                                size++;
                                if (next_offset == -1) {
                                    next_offset = new_offset;
                                } else {
                                    road_network_queue.items[road_network_queue.tail++] = new_offset;
                                    if (road_network_queue.tail >= MAX_QUEUE) {
                                        road_network_queue.tail = 0;
                                    }
                                }
                            }
                        }
                    }
                    if (next_offset == -1) {
                        if (road_network_queue.head == road_network_queue.tail) {
                            break;
                        }
                        next_offset = road_network_queue.items[road_network_queue.head++];
                        if (road_network_queue.head >= MAX_QUEUE) {
                            road_network_queue.head = 0;
                        }
                    }
                    grid_offset = next_offset;
                } while (next_offset > -1);
                for (int n = 0; n < 10; n++) {
                    if (size > city_data.map.largest_road_networks[n].size) {
                        // move everyone down
                        for (int m = 9; m > n; m--) {
                            city_data.map.largest_road_networks[m].id = city_data.map.largest_road_networks[m - 1].id;
                            city_data.map.largest_road_networks[m].size = city_data.map.largest_road_networks[m - 1].size;
                        }
                        city_data.map.largest_road_networks[n].id = network_id;
                        city_data.map.largest_road_networks[n].size = size;
                        break;
                    }
                }
                network_id++;
            }
        }
    }
}

static void building_granaries_calculate_stocks(void)
{
    non_getting_granaries.num_items = 0;
    for (int i = 0; i < MAX_GRANARIES; i++) {
        non_getting_granaries.building_ids[i] = 0;
    }
    non_getting_granaries.total_storage_wheat = 0;
    non_getting_granaries.total_storage_vegetables = 0;
    non_getting_granaries.total_storage_fruit = 0;
    non_getting_granaries.total_storage_meat = 0;

    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_GRANARY) {
            continue;
        }
        if (!b->has_road_access) {
            continue;
        }
        struct building_storage_t *s = &storages[b->storage_id].storage;
        int total_non_getting = 0;
        if (s->resource_state[RESOURCE_WHEAT] != BUILDING_STORAGE_STATE_GETTING) {
            total_non_getting += b->data.granary.resource_stored[RESOURCE_WHEAT];
            non_getting_granaries.total_storage_wheat += b->data.granary.resource_stored[RESOURCE_WHEAT];
        }
        if (s->resource_state[RESOURCE_VEGETABLES] != BUILDING_STORAGE_STATE_GETTING) {
            total_non_getting += b->data.granary.resource_stored[RESOURCE_VEGETABLES];
            non_getting_granaries.total_storage_vegetables += b->data.granary.resource_stored[RESOURCE_VEGETABLES];
        }
        if (s->resource_state[RESOURCE_FRUIT] != BUILDING_STORAGE_STATE_GETTING) {
            total_non_getting += b->data.granary.resource_stored[RESOURCE_FRUIT];
            non_getting_granaries.total_storage_fruit += b->data.granary.resource_stored[RESOURCE_FRUIT];
        }
        if (s->resource_state[RESOURCE_MEAT] != BUILDING_STORAGE_STATE_GETTING) {
            total_non_getting += b->data.granary.resource_stored[RESOURCE_MEAT];
            non_getting_granaries.total_storage_meat += b->data.granary.resource_stored[RESOURCE_MEAT];
        }
        if (total_non_getting > MAX_GRANARIES) {
            non_getting_granaries.building_ids[non_getting_granaries.num_items] = i;
            if (non_getting_granaries.num_items < MAX_GRANARIES - 2) {
                non_getting_granaries.num_items++;
            }
        }
    }
}

static void game_state_reset_overlay(void)
{
    state_data.current_overlay = OVERLAY_NONE;
    state_data.previous_overlay = OVERLAY_NONE;
}

static int building_storage_create(void)
{
    for (int i = 1; i < MAX_STORAGES; i++) {
        if (!storages[i].in_use) {
            memset(&storages[i], 0, sizeof(struct data_storage));
            storages[i].in_use = 1;
            return i;
        }
    }
    return 0;
}

static void building_storage_reset_building_ids(void)
{
    for (int i = 1; i < MAX_STORAGES; i++) {
        storages[i].building_id = 0;
    }

    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_UNUSED) {
            continue;
        }
        if (b->type == BUILDING_GRANARY || b->type == BUILDING_WAREHOUSE) {
            if (b->storage_id) {
                if (storages[b->storage_id].building_id) {
                    // storage is already connected to a building: corrupt, create new
                    b->storage_id = building_storage_create();
                } else {
                    storages[b->storage_id].building_id = i;
                }
            }
        }
    }
}

static   struct dir_listing *dir_list_files(char *extension)
{
    memset(listing.files, 0, sizeof(listing.files));
    listing.num_files = 0;
    listing.file_overflow = 0;
    DIR *dir = 0;
    struct dirent *file_info;
    if (string_equals(extension, "map")) {
        dir = opendir(MAPS_DIR_PATH);
    } else if (string_equals(extension, "sav")) {
        dir = opendir(SAVES_DIR_PATH);
    }
    if (dir) {
        while ((file_info = readdir(dir)) != 0) {
            if (listing.num_files >= MAX_NUM_FILES) {
                listing.file_overflow = 1;
                return &listing;
            }
            if (file_has_extension(file_info->d_name, extension)) {
                if (string_length(file_info->d_name) < FILE_NAME_MAX) {
                    string_copy(file_info->d_name, listing.files[listing.num_files], FILE_NAME_MAX);
                    listing.num_files++;
                }
            }
        }
        closedir(dir);
    }
    return &listing;
}

static void graphics_clear_screen(void)
{
    memset(canvas.pixels, 0, sizeof(color_t) * canvas.width * canvas.height);
}

static void city_view_get_camera(int *x, int *y)
{
    *x = view_data.camera.tile.x;
    *y = view_data.camera.tile.y;
}

static void city_view_get_viewport_size_tiles(int *width, int *height)
{
    *width = view_data.viewport.width_tiles;
    *height = view_data.viewport.height_tiles;
}

static void set_bounds_minimap(int x_offset, int y_offset, int width, int height)
{
    minimap_data.width_tiles = width / 2;
    minimap_data.height_tiles = height;
    minimap_data.x_offset = x_offset;
    minimap_data.y_offset = y_offset;
    minimap_data.width = width;
    minimap_data.height = height;
    minimap_data.absolute_x = (VIEW_X_MAX - minimap_data.width_tiles) / 2;
    minimap_data.absolute_y = (VIEW_Y_MAX - minimap_data.height_tiles) / 2;

    city_view_get_camera(&minimap_data.camera_x, &minimap_data.camera_y);
    int view_width_tiles, view_height_tiles;
    city_view_get_viewport_size_tiles(&view_width_tiles, &view_height_tiles);

    if ((map_data.width - minimap_data.width_tiles) / 2 > 0) {
        if (minimap_data.camera_x < minimap_data.absolute_x) {
            minimap_data.absolute_x = minimap_data.camera_x;
        } else if (minimap_data.camera_x > minimap_data.width_tiles + minimap_data.absolute_x - view_width_tiles) {
            minimap_data.absolute_x = view_width_tiles + minimap_data.camera_x - minimap_data.width_tiles;
        }
    }
    if ((2 * map_data.height - minimap_data.height_tiles) / 2 > 0) {
        if (minimap_data.camera_y < minimap_data.absolute_y) {
            minimap_data.absolute_y = minimap_data.camera_y;
        } else if (minimap_data.camera_y > minimap_data.height_tiles + minimap_data.absolute_y - view_height_tiles) {
            minimap_data.absolute_y = view_height_tiles + minimap_data.camera_y - minimap_data.height_tiles;
        }
    }
    // ensure even height
    minimap_data.absolute_y &= ~1;
}

static void city_view_foreach_minimap_tile(int x_offset, int y_offset, int absolute_x, int absolute_y, int width_tiles, int height_tiles, map_callback *callback)
{
    int odd = 0;
    int y_abs = absolute_y - 4;
    int y_view = y_offset - 4;
    for (int y_rel = -4; y_rel < height_tiles + 4; y_rel++, y_abs++, y_view++) {
        int x_view;
        if (odd) {
            x_view = x_offset - 9;
            odd = 0;
        } else {
            x_view = x_offset - 8;
            odd = 1;
        }
        int x_abs = absolute_x - 4;
        for (int x_rel = -4; x_rel < width_tiles; x_rel++, x_abs++, x_view += 2) {
            if (x_abs >= 0 && x_abs < VIEW_X_MAX && y_abs >= 0 && y_abs < VIEW_Y_MAX) {
                callback(x_view, y_view, view_to_grid_offset_lookup[x_abs][y_abs]);
            }
        }
    }
}

static void draw_minimap_tile(int x_view, int y_view, int grid_offset)
{
    if (grid_offset < 0) {
        image_draw(image_data_s.group_image_ids[GROUP_MINIMAP_BLACK], x_view, y_view);
        return;
    }
    int color_type = FIGURE_COLOR_NONE;
    if (map_figures.items[grid_offset] > 0) {
        int figure_id = map_figures.items[grid_offset];
        while (figure_id) {
            struct figure_t *f = &figures[figure_id];
            if (figure_properties[f->type].is_player_legion_unit) {
                color_type = selected_legion_formation == f->formation_id ? FIGURE_COLOR_SELECTED_SOLDIER : FIGURE_COLOR_SOLDIER;
                break;
            } else if (figure_properties[f->type].is_enemy_unit || figure_properties[f->type].is_caesar_legion_unit || (figure_properties[f->type].is_native_unit && f->action_state == FIGURE_ACTION_NATIVE_ATTACKING)) {
                color_type = FIGURE_COLOR_ENEMY;
                break;
            } else if (f->type == FIGURE_WOLF) {
                color_type = FIGURE_COLOR_WOLF;
                break;
            }
            figure_id = f->next_figure_id_on_same_tile;
        }
    }
    if (color_type) {
        color_t color = COLOR_MINIMAP_WOLF;
        if (color_type == FIGURE_COLOR_SOLDIER) {
            color = COLOR_MINIMAP_SOLDIER;
        } else if (color_type == FIGURE_COLOR_SELECTED_SOLDIER) {
            color = COLOR_MINIMAP_SELECTED_SOLDIER;
        } else if (color_type == FIGURE_COLOR_ENEMY) {
            color = minimap_data.enemy_color;
        }
        graphics_draw_horizontal_line(x_view, x_view + 1, y_view, color);
        return;
    }
    int terrain = terrain_grid.items[grid_offset];
    // exception for fort ground: display as empty land
    if (terrain & TERRAIN_BUILDING) {
        if (all_buildings[map_building_at(grid_offset)].type == BUILDING_FORT_GROUND) {
            terrain = 0;
        }
    }
    if (terrain & TERRAIN_BUILDING) {
        if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
            int image_id;
            struct building_t *b = &all_buildings[map_building_at(grid_offset)];
            if (b->house_size) {
                image_id = image_data_s.group_image_ids[GROUP_MINIMAP_HOUSE];
            } else if (b->type == BUILDING_RESERVOIR) {
                image_id = image_data_s.group_image_ids[GROUP_MINIMAP_AQUEDUCT] - 1;
            } else {
                image_id = image_data_s.group_image_ids[GROUP_MINIMAP_BUILDING];
            }
            switch (map_property_multi_tile_size(grid_offset)) {
                case 1: image_draw(image_id, x_view, y_view); break;
                case 2: image_draw(image_id + 1, x_view, y_view - 1); break;
                case 3: image_draw(image_id + 2, x_view, y_view - 2); break;
                case 4: image_draw(image_id + 3, x_view, y_view - 3); break;
                case 5: image_draw(image_id + 4, x_view, y_view - 4); break;
            }
        }
    } else {
        int rand = random.items[grid_offset];
        int image_id;
        if (terrain & TERRAIN_ROAD) {
            image_id = image_data_s.group_image_ids[GROUP_MINIMAP_ROAD];
        } else if (terrain & TERRAIN_WATER) {
            image_id = image_data_s.group_image_ids[GROUP_MINIMAP_WATER] + (rand & 3);
        } else if (terrain & (TERRAIN_TREE | TERRAIN_SHRUB)) {
            image_id = image_data_s.group_image_ids[GROUP_MINIMAP_TREE] + (rand & 3);
        } else if (terrain & (TERRAIN_ROCK | TERRAIN_ELEVATION)) {
            image_id = image_data_s.group_image_ids[GROUP_MINIMAP_ROCK] + (rand & 3);
        } else if (terrain & TERRAIN_AQUEDUCT) {
            image_id = image_data_s.group_image_ids[GROUP_MINIMAP_AQUEDUCT];
        } else if (terrain & TERRAIN_WALL) {
            image_id = image_data_s.group_image_ids[GROUP_MINIMAP_WALL];
        } else if (terrain & TERRAIN_MEADOW) {
            image_id = image_data_s.group_image_ids[GROUP_MINIMAP_MEADOW] + (rand & 3);
        } else {
            image_id = image_data_s.group_image_ids[GROUP_MINIMAP_EMPTY_LAND] + (rand & 7);
        }
        image_draw(image_id, x_view, y_view);
    }
}

static void graphics_save_to_buffer(int x, int y, int width, int height, color_t *buffer)
{
    struct clip_info_t *current_clip = graphics_get_clip_info(x, y, width, height);
    if (!current_clip->is_visible) {
        return;
    }
    int min_x = x + current_clip->clipped_pixels_left;
    int min_dy = current_clip->clipped_pixels_top;
    int max_dy = height - current_clip->clipped_pixels_bottom;
    for (int dy = min_dy; dy < max_dy; dy++) {
        memcpy(&buffer[dy * width], graphics_get_pixel(min_x, y + dy),
            sizeof(color_t) * current_clip->visible_pixels_x);
    }
}

static void draw_viewport_rectangle(void)
{
    int camera_x, camera_y;
    int camera_pixels_x;
    city_view_get_camera(&camera_x, &camera_y);
    camera_pixels_x = view_data.camera.pixel.x;
    int view_width_tiles, view_height_tiles;
    city_view_get_viewport_size_tiles(&view_width_tiles, &view_height_tiles);

    int x_offset = minimap_data.x_offset + 2 * (camera_x - minimap_data.absolute_x) - 2 + camera_pixels_x / 30;
    if (x_offset < minimap_data.x_offset) {
        x_offset = minimap_data.x_offset;
    }
    if (x_offset + 2 * view_width_tiles + 4 > minimap_data.x_offset + minimap_data.width_tiles) {
        x_offset -= 2;
    }
    int y_offset = minimap_data.y_offset + camera_y - minimap_data.absolute_y + 2;
    graphics_draw_rect(x_offset, y_offset,
        view_width_tiles * 2 + 4,
        view_height_tiles - 4,
        COLOR_MINIMAP_VIEWPORT);
}

static void draw_minimap(void)
{
    graphics_set_clip_rectangle(minimap_data.x_offset, minimap_data.y_offset, minimap_data.width, minimap_data.height);
    city_view_foreach_minimap_tile(minimap_data.x_offset, minimap_data.y_offset,
                               minimap_data.absolute_x, minimap_data.absolute_y,
                               minimap_data.width_tiles, minimap_data.height_tiles,
                               draw_minimap_tile);
    graphics_save_to_buffer(minimap_data.x_offset, minimap_data.y_offset, minimap_data.width, minimap_data.height, minimap_data.cache);
    draw_viewport_rectangle();
    graphics_reset_clip_rectangle();
}

static void draw_uncached(int x_offset, int y_offset, int width, int height)
{
    minimap_data.enemy_color = ENEMY_COLOR_BY_CLIMATE[scenario.climate];
    if (width != minimap_data.width || height != minimap_data.height) {
        free(minimap_data.cache);
        minimap_data.cache = (color_t *) malloc(sizeof(color_t) * width * height);
    }
    set_bounds_minimap(x_offset, y_offset, width, height);
    draw_minimap();
}

static void graphics_draw_from_buffer(int x, int y, int width, int height, color_t *buffer)
{
    struct clip_info_t *current_clip = graphics_get_clip_info(x, y, width, height);
    if (!current_clip->is_visible) {
        return;
    }
    int min_x = x + current_clip->clipped_pixels_left;
    int min_dy = current_clip->clipped_pixels_top;
    int max_dy = height - current_clip->clipped_pixels_bottom;
    for (int dy = min_dy; dy < max_dy; dy++) {
        memcpy(graphics_get_pixel(min_x, y + dy), &buffer[dy * width],
            sizeof(color_t) * current_clip->visible_pixels_x);
    }
}

static void widget_minimap_draw(int x_offset, int y_offset, int width, int height, int force)
{
    int refresh_type = REFRESH_NOT_NEEDED;
    if (minimap_data.refresh_requested || force) {
        minimap_data.refresh_requested = 0;
        refresh_type = REFRESH_FULL;
    } else {
        int new_x, new_y;
        city_view_get_camera(&new_x, &new_y);
        if (minimap_data.camera_x != new_x || minimap_data.camera_y != new_y) {
            refresh_type = REFRESH_CAMERA_MOVED;
        }
    }
    if (refresh_type) {
        if (refresh_type == REFRESH_FULL) {
            draw_uncached(x_offset, y_offset, width, height);
        } else {
            if (width != minimap_data.width || height != minimap_data.height || x_offset != minimap_data.x_offset) {
                draw_uncached(x_offset, y_offset, width, height);
            } else {
                int old_absolute_x = minimap_data.absolute_x;
                int old_absolute_y = minimap_data.absolute_y;
                set_bounds_minimap(x_offset, y_offset, width, height);
                if (minimap_data.absolute_x != old_absolute_x || minimap_data.absolute_y != old_absolute_y) {
                    draw_minimap();
                } else {
                    graphics_set_clip_rectangle(x_offset, y_offset, width, height);
                    graphics_draw_from_buffer(x_offset, y_offset, minimap_data.width, minimap_data.height, minimap_data.cache);
                    draw_viewport_rectangle();
                    graphics_reset_clip_rectangle();
                }
            }
        }
        graphics_draw_horizontal_line(x_offset - 1, x_offset - 1 + width, y_offset - 1, COLOR_MINIMAP_DARK);
        graphics_draw_vertical_line(x_offset - 1, y_offset, y_offset + height, COLOR_MINIMAP_DARK);
        graphics_draw_vertical_line(x_offset - 1 + width, y_offset,
            y_offset + height, COLOR_MINIMAP_LIGHT);
    }
}

static void show_editor_map(void);
static void show_editor_attributes(void);
static void hide_editor_build_menu(void)
{
    selected_submenu_build_menu = MENU_NONE;
    show_editor_map();
}

static void button_attributes(int show, __attribute__((unused)) int param2)
{
    hide_editor_build_menu();
    if (show) {
        if (window_data.current_window->id != WINDOW_EDITOR_ATTRIBUTES) {
            show_editor_attributes();
        }
    } else {
        if (window_data.current_window->id != WINDOW_EDITOR_MAP) {
            show_editor_map();
        }
    }
}

static int map_viewport_width(void)
{
    return empire_editor_x_max - empire_editor_x_min - 32;
}

static int map_viewport_height(void)
{
    return empire_editor_y_max - empire_editor_y_min - 136;
}

static void empire_load(int empire_id)
{
    char raw_data[EMPIRE_DATA_SIZE];
    char *filename = "c32.emp";
    // read header with scroll positions
    if (!io_read_file_part_into_buffer(filename, raw_data, 4, 32 * empire_id)) {
        memset(raw_data, 0, 4);
    }
    struct buffer_t buf;
    buffer_init(&buf, raw_data, 4);
    empire_data.initial_scroll_x = buffer_read_i16(&buf);
    empire_data.initial_scroll_y = buffer_read_i16(&buf);
    // read data section with objects
    int offset = EMPIRE_HEADER_SIZE + EMPIRE_DATA_SIZE * empire_id;
    int read_size = io_read_file_part_into_buffer(filename, raw_data, EMPIRE_DATA_SIZE, offset);
    if (read_size != EMPIRE_DATA_SIZE) {
        // load empty empire when loading fails
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to load empire data from file", filename, 0));
        memset(raw_data, 0, EMPIRE_DATA_SIZE);
    }
    buffer_init(&buf, raw_data, EMPIRE_DATA_SIZE);
    // load initial state
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        empire_objects[i].id = i;
        empire_objects[i].type = buffer_read_u8(&buf);
        empire_objects[i].in_use = buffer_read_u8(&buf);
        empire_objects[i].animation_index = buffer_read_u8(&buf);
        buf.index += 1;
        empire_objects[i].x = buffer_read_i16(&buf);
        empire_objects[i].y = buffer_read_i16(&buf);
        empire_objects[i].width = buffer_read_i16(&buf);
        empire_objects[i].height = buffer_read_i16(&buf);
        empire_objects[i].image_id = buffer_read_i16(&buf);
        empire_objects[i].expanded.image_id = buffer_read_i16(&buf);
        buf.index += 1;
        empire_objects[i].distant_battle_travel_months = buffer_read_u8(&buf);
        buf.index += 2;
        empire_objects[i].expanded.x = buffer_read_i16(&buf);
        empire_objects[i].expanded.y = buffer_read_i16(&buf);
        empire_objects[i].city_type = buffer_read_u8(&buf);
        empire_objects[i].city_name_id = buffer_read_u8(&buf);
        empire_objects[i].trade_route_id = buffer_read_u8(&buf);
        empire_objects[i].trade_route_open = buffer_read_u8(&buf);
        empire_objects[i].trade_route_cost = buffer_read_i16(&buf);
        buf.index += 10; // resource to sell
        buf.index += 2;
        buf.index += 8; // resource to buy
        empire_objects[i].invasion_path_id = buffer_read_u8(&buf);
        empire_objects[i].invasion_years = buffer_read_u8(&buf);
        buf.index += 6; // resource quantities (trade40, trade25, trade15)
        buf.index += 6;
    }
    fix_image_ids();
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        if (empire_objects[i].in_use
        && (empire_objects[i].city_type == EMPIRE_CITY_TRADE || empire_objects[i].city_type == EMPIRE_CITY_FUTURE_TRADE)) {
        }
        for (int r = 0; r < RESOURCE_TYPES_MAX; r++) {
            empire_objects[i].resource_buy_limit[r] = 0;
            empire_objects[i].resource_sell_limit[r] = 0;
        }
    }
}

static struct empire_object_t *empire_object_get_our_city(void)
{
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        if (empire_objects[i].in_use && empire_objects[i].type == EMPIRE_OBJECT_CITY && empire_objects[i].city_type == EMPIRE_CITY_OURS) {
            return &empire_objects[i];
        }
    }
    return 0;
}

static void empire_object_our_city_set_resources_sell(void)
{
    struct empire_object_t *our_city = empire_object_get_our_city();
    for (int resource = RESOURCE_WHEAT; resource < RESOURCE_TYPES_MAX; resource++) {
        if (resource == RESOURCE_MEAT) {
            our_city->resource_sell_limit[resource] = (scenario.allowed_buildings[BUILDING_WHARF] || scenario.allowed_buildings[BUILDING_PIG_FARM]) ? 1 : 0;
        } else {
            our_city->resource_sell_limit[resource] = scenario.allowed_buildings[resource + BUILDING_WHEAT_FARM - 1] ? 1 : 0;
        }
    }
}

static void check_scroll_boundaries(void)
{
    int max_x = EMPIRE_WIDTH - empire_data.viewport_width;
    int max_y = EMPIRE_HEIGHT - empire_data.viewport_height;

    empire_data.scroll_x = calc_bound(empire_data.scroll_x, 0, max_x);
    empire_data.scroll_y = calc_bound(empire_data.scroll_y, 0, max_y);
}

static void button_change_empire(int value, __attribute__((unused)) int param2)
{
    if (scenario.empire.id == 39 && value == 1) {
        scenario.empire.id = 0;
    } else if (scenario.empire.id == 0 && value == -1) {
        scenario.empire.id = 39;
    } else {
        scenario.empire.id += value;
    }
    scenario.is_saved = 0;
    empire_load(scenario.empire.id);
    empire_object_our_city_set_resources_sell();
    struct empire_object_t *our_city = empire_object_get_our_city();
    empire_data.viewport_width = map_viewport_width();
    empire_data.viewport_height = map_viewport_height();
    if (our_city) {
        empire_data.scroll_x = our_city->x - empire_data.viewport_width / 2;
        empire_data.scroll_y = our_city->y - empire_data.viewport_height / 2;
    } else {
        empire_data.scroll_x = empire_data.initial_scroll_x;
        empire_data.scroll_y = empire_data.initial_scroll_y;
    }
    check_scroll_boundaries();
    // reset demand changes to prevent possible city/resource mixups
    for (int i = 0; i < MAX_DEMAND_CHANGES; i++) {
        scenario.demand_changes[i].trade_city_id = 0;
    }
    window_data.refresh_on_draw = 1;
}

static struct arrow_button_t arrow_buttons_empire[] = {
    {28, -52, 17, 24, button_change_empire, -1, 0, 0, 0},
    {52, -52, 15, 24, button_change_empire, 1, 0, 0, 0}
};

static void set_city_type(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    if (selected_empire_object_editor->city_type == EMPIRE_CITY_DISTANT_ROMAN) {
        selected_empire_object_editor->city_type = EMPIRE_CITY_TRADE;
    } else if (selected_empire_object_editor->city_type == EMPIRE_CITY_TRADE) {
        selected_empire_object_editor->city_type = EMPIRE_CITY_FUTURE_TRADE;
    } else {
        selected_empire_object_editor->city_type = EMPIRE_CITY_DISTANT_ROMAN;
    }
    // fix graphics for city sprite and flag color when changing city types
    if (selected_empire_object_editor->city_type == EMPIRE_CITY_TRADE || selected_empire_object_editor->city_type == EMPIRE_CITY_FUTURE_TRADE) {
        selected_empire_object_editor->image_id = image_data_s.group_image_ids[GROUP_EMPIRE_CITY_TRADE];
        selected_empire_object_editor->expanded.image_id = image_data_s.group_image_ids[GROUP_EMPIRE_CITY_TRADE];
    } else if (selected_empire_object_editor->city_type == EMPIRE_CITY_DISTANT_ROMAN) {
        selected_empire_object_editor->image_id = image_data_s.group_image_ids[GROUP_EMPIRE_CITY_DISTANT_ROMAN];
        selected_empire_object_editor->expanded.image_id = image_data_s.group_image_ids[GROUP_EMPIRE_CITY_DISTANT_ROMAN];
    }
    window_data.refresh_on_draw = 1;
}

static struct arrow_button_t arrow_buttons_set_city_type[] = {
    {0, 0, 21, 24, set_city_type, 0, 0, 0, 0}
};

static void set_resource_sell_limit(int resource, __attribute__((unused)) int param2)
{
    switch (selected_empire_object_editor->resource_sell_limit[resource]) {
        case 0:
            selected_empire_object_editor->resource_sell_limit[resource] = 15;
            break;
        case 15:
            selected_empire_object_editor->resource_sell_limit[resource] = 25;
            break;
        case 25:
            selected_empire_object_editor->resource_sell_limit[resource] = 40;
            break;
        default:
            selected_empire_object_editor->resource_sell_limit[resource] = 0;
    }
    // if resource to buy already enabled, disable
    selected_empire_object_editor->resource_buy_limit[resource] = 0;
}

static struct generic_button_t button_toggle_sell_resource_limit[] = {
    {0, 0, 26, 26, set_resource_sell_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_sell_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_sell_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_sell_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_sell_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_sell_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_sell_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_sell_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_sell_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_sell_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_sell_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_sell_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_sell_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_sell_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_sell_limit, button_none, 0, 0},
};

static void set_resource_buy_limit(int resource, __attribute__((unused)) int param2)
{
    switch (selected_empire_object_editor->resource_buy_limit[resource]) {
        case 0:
            selected_empire_object_editor->resource_buy_limit[resource] = 15;
            break;
        case 15:
            selected_empire_object_editor->resource_buy_limit[resource] = 25;
            break;
        case 25:
            selected_empire_object_editor->resource_buy_limit[resource] = 40;
            break;
        default:
            selected_empire_object_editor->resource_buy_limit[resource] = 0;
    }
    // if resource to sell already enabled, disable
    selected_empire_object_editor->resource_sell_limit[resource] = 0;
}

static struct generic_button_t button_toggle_buy_resource_limit[] = {
    {0, 0, 26, 26, set_resource_buy_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_buy_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_buy_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_buy_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_buy_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_buy_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_buy_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_buy_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_buy_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_buy_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_buy_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_buy_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_buy_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_buy_limit, button_none, 0, 0},
    {0, 0, 26, 26, set_resource_buy_limit, button_none, 0, 0},
};

static void set_trade_route_cost_callback(int value)
{
    selected_empire_object_editor->trade_route_cost = value;
}

static void window_numeric_input_show(int x, int y, int max_digits, int max_value, void (*callback)(int));
static void set_trade_route_cost(__attribute__((unused)) int param1, __attribute__((unused)) int param2);
static struct generic_button_t button_set_trade_route_cost[] = {
    {0, 0, 65, 26, set_trade_route_cost, button_none, 0, 0},
};
static void set_trade_route_cost(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(button_set_trade_route_cost->x - 150, button_set_trade_route_cost->y - 150, 5, 99999, set_trade_route_cost_callback);
}

static void input_number_numeric_input(int number)
{
    if (numeric_input_data.num_digits < numeric_input_data.max_digits) {
        numeric_input_data.value = numeric_input_data.value * 10 + number;
        numeric_input_data.num_digits++;
        play_sound_effect(SOUND_EFFECT_BUILD);
    }
}

static void button_number_numeric_input(int number, __attribute__((unused)) int param2)
{
    input_number_numeric_input(number);
}

static void close_numeric_input(void)
{
    keyboard_data.capture_numeric = 0;
    keyboard_data.capture_numeric_callback = 0;
    SDL_StopTextInput();
    window_go_back();
}

static void button_cancel_numeric_input(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    close_numeric_input();
}

static void input_accept_numeric_input(void)
{
    close_numeric_input();
    if (numeric_input_data.value > numeric_input_data.max_value) {
        numeric_input_data.value = numeric_input_data.max_value;
    }
    numeric_input_data.callback(numeric_input_data.value);
}

static void button_accept_numeric_input(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    input_accept_numeric_input();
}

static struct generic_button_t buttons_numeric_input[] = {
    {21, 51, 25, 25, button_number_numeric_input, button_none, 1, 0},
    {51, 51, 25, 25, button_number_numeric_input, button_none, 2, 0},
    {81, 51, 25, 25, button_number_numeric_input, button_none, 3, 0},
    {21, 81, 25, 25, button_number_numeric_input, button_none, 4, 0},
    {51, 81, 25, 25, button_number_numeric_input, button_none, 5, 0},
    {81, 81, 25, 25, button_number_numeric_input, button_none, 6, 0},
    {21, 111, 25, 25, button_number_numeric_input, button_none, 7, 0},
    {51, 111, 25, 25, button_number_numeric_input, button_none, 8, 0},
    {81, 111, 25, 25, button_number_numeric_input, button_none, 9, 0},
    {21, 141, 25, 25, button_number_numeric_input, button_none, 0, 0},
    {51, 141, 55, 25, button_accept_numeric_input, button_none, 1, 0},
    {21, 171, 85, 25, button_cancel_numeric_input, button_none, 1, 0}
};

static void draw_number_button(int x, int y, int number, int is_selected)
{
    color_t color = is_selected ? COLOR_FONT_BLUE : COLOR_BLACK;
    graphics_draw_rect(x, y, 25, 25, color);
    char number_string[2];
    number_string[0] = '0' + number;
    number_string[1] = 0;
    text_draw_centered(number_string, x, y, 25, FONT_LARGE_PLAIN, color);
}

static void text_draw_number_centered_colored(int value, int x_offset, int y_offset, int box_width, int font, color_t color)
{
    char str[NUMBER_BUFFER_LENGTH];
    number_to_string(str, value, '@', " ");
    text_draw_centered(str, x_offset, y_offset, box_width, font, color);
}

static void lang_text_draw_centered_colored(int group, int number, int x_offset, int y_offset, int box_width, int font, color_t color)
{
    char *str = lang_get_string(group, number);
    text_draw_centered(str, x_offset, y_offset, box_width, font, color);
}

static void draw_foreground_numeric_input(void)
{
    outer_panel_draw(numeric_input_data.x, numeric_input_data.y, 8, 14);
    graphics_fill_rect(numeric_input_data.x + 16, numeric_input_data.y + 16, 96, 30, COLOR_BLACK);
    if (numeric_input_data.num_digits > 0) {
        text_draw_number_centered_colored(numeric_input_data.value, numeric_input_data.x + 16, numeric_input_data.y + 19, 92, FONT_LARGE_PLAIN, COLOR_FONT_RED);
    }
    draw_number_button(numeric_input_data.x + 21, numeric_input_data.y + 51, 1, numeric_input_data.focus_button_id == 1);
    draw_number_button(numeric_input_data.x + 51, numeric_input_data.y + 51, 2, numeric_input_data.focus_button_id == 2);
    draw_number_button(numeric_input_data.x + 81, numeric_input_data.y + 51, 3, numeric_input_data.focus_button_id == 3);
    draw_number_button(numeric_input_data.x + 21, numeric_input_data.y + 81, 4, numeric_input_data.focus_button_id == 4);
    draw_number_button(numeric_input_data.x + 51, numeric_input_data.y + 81, 5, numeric_input_data.focus_button_id == 5);
    draw_number_button(numeric_input_data.x + 81, numeric_input_data.y + 81, 6, numeric_input_data.focus_button_id == 6);
    draw_number_button(numeric_input_data.x + 21, numeric_input_data.y + 111, 7, numeric_input_data.focus_button_id == 7);
    draw_number_button(numeric_input_data.x + 51, numeric_input_data.y + 111, 8, numeric_input_data.focus_button_id == 8);
    draw_number_button(numeric_input_data.x + 81, numeric_input_data.y + 111, 9, numeric_input_data.focus_button_id == 9);
    draw_number_button(numeric_input_data.x + 21, numeric_input_data.y + 141, 0, numeric_input_data.focus_button_id == 10);
    graphics_draw_rect(numeric_input_data.x + 51, numeric_input_data.y + 141, 55, 25, numeric_input_data.focus_button_id == 11 ? COLOR_FONT_BLUE : COLOR_BLACK);
    lang_text_draw_centered_colored(44, 16, numeric_input_data.x + 51, numeric_input_data.y + 147, 55, FONT_NORMAL_PLAIN,
            numeric_input_data.focus_button_id == 11 ? COLOR_FONT_BLUE : COLOR_BLACK);

    graphics_draw_rect(numeric_input_data.x + 21, numeric_input_data.y + 171, 85, 25, numeric_input_data.focus_button_id == 12 ? COLOR_FONT_BLUE : COLOR_BLACK);
    lang_text_draw_centered_colored(44, 17, numeric_input_data.x + 21, numeric_input_data.y + 177, 85, FONT_NORMAL_PLAIN,
            numeric_input_data.focus_button_id == 12 ? COLOR_FONT_BLUE : COLOR_BLACK);
}

static int generic_buttons_handle_mouse(struct mouse_t *m, int x, int y, struct generic_button_t *buttons, int num_buttons, int *focus_button_id)
{
    int button_id = 0;
    for (int i = 0; i < num_buttons; i++) {
        if (x + buttons[i].x <= m->x &&
            x + buttons[i].x + buttons[i].width > m->x &&
            y + buttons[i].y <= m->y &&
            y + buttons[i].y + buttons[i].height > m->y) {
            button_id = i + 1;
            break;
        }
    }
    if (focus_button_id) {
        *focus_button_id = button_id;
    }
    if (!button_id) {
        return 0;
    }
    struct generic_button_t *button = &buttons[button_id - 1];
    if (m->left.went_up) {
        button->left_click_handler(button->parameter1, button->parameter2);
        return button->left_click_handler != button_none;
    } else if (m->right.went_up) {
        button->right_click_handler(button->parameter1, button->parameter2);
        return button->right_click_handler != button_none;
    } else {
        return 0;
    }
}

static void handle_input_numeric_input(struct mouse_t *m, struct hotkeys_t *h)
{
    if (generic_buttons_handle_mouse(m, numeric_input_data.x, numeric_input_data.y, buttons_numeric_input, 12, &numeric_input_data.focus_button_id)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        close_numeric_input();
    }
    if (h->enter_pressed) {
        input_accept_numeric_input();
    }
}

static void window_numeric_input_show(int x, int y, int max_digits, int max_value, void (*callback)(int))
{
    struct window_type_t window = {
        WINDOW_NUMERIC_INPUT,
        window_draw_underlying_window,
        draw_foreground_numeric_input,
        handle_input_numeric_input,
    };
    numeric_input_data.x = x;
    numeric_input_data.y = y;
    numeric_input_data.max_digits = max_digits;
    numeric_input_data.max_value = max_value;
    numeric_input_data.callback = callback;
    numeric_input_data.num_digits = 0;
    numeric_input_data.value = 0;
    numeric_input_data.focus_button_id = 0;
    keyboard_data.capture_numeric = 1;
    keyboard_data.capture_numeric_callback = input_number_numeric_input;
    SDL_StartTextInput();
    window_show(&window);
}

static void set_expansion_year_offset_callback(int value)
{
    scenario.empire.expansion_year = value;
}

static void set_expansion_year_offset(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(empire_editor_x_min + 500, empire_editor_y_max - 250, 3, 500, set_expansion_year_offset_callback);
}

static struct generic_button_t button_set_expansion_year[] = {
    {0, 0, 38, 26, set_expansion_year_offset, button_none, 0, 0},
};

static void draw_background_editor_empire(void)
{
    int s_width = screen_data.width;
    int s_height = screen_data.height;
    empire_editor_x_min = s_width <= MAX_EMPIRE_WIDTH ? 0 : (s_width - MAX_EMPIRE_WIDTH) / 2;
    empire_editor_x_max = s_width <= MAX_EMPIRE_WIDTH ? s_width : empire_editor_x_min + MAX_EMPIRE_WIDTH;
    empire_editor_y_min = s_height <= MAX_EMPIRE_HEIGHT ? 0 : (s_height - MAX_EMPIRE_HEIGHT) / 2;
    empire_editor_y_max = s_height <= MAX_EMPIRE_HEIGHT ? s_height : empire_editor_y_min + MAX_EMPIRE_HEIGHT;

    if (empire_editor_x_min || empire_editor_y_min) {
        graphics_clear_screen();
    }

    int image_base = image_data_s.group_image_ids[GROUP_EDITOR_EMPIRE_PANELS];
    // bottom panel background
    graphics_set_clip_rectangle(empire_editor_x_min, empire_editor_y_min, empire_editor_x_max - empire_editor_x_min, empire_editor_y_max - empire_editor_y_min);
    for (int x = empire_editor_x_min; x < empire_editor_x_max; x += 70) {
        image_draw(image_base + 3, x, empire_editor_y_max - 120);
        image_draw(image_base + 3, x, empire_editor_y_max - 80);
        image_draw(image_base + 3, x, empire_editor_y_max - 40);
    }
    // horizontal bar borders
    for (int x = empire_editor_x_min; x < empire_editor_x_max; x += 86) {
        image_draw(image_base + 1, x, empire_editor_y_min);
        image_draw(image_base + 1, x, empire_editor_y_max - 120);
        image_draw(image_base + 1, x, empire_editor_y_max - 16);
    }
    // vertical bar borders
    for (int y = empire_editor_y_min + 16; y < empire_editor_y_max; y += 86) {
        image_draw(image_base, empire_editor_x_min, y);
        image_draw(image_base, empire_editor_x_max - 16, y);
    }
    // crossbars
    image_draw(image_base + 2, empire_editor_x_min, empire_editor_y_min);
    image_draw(image_base + 2, empire_editor_x_min, empire_editor_y_max - 120);
    image_draw(image_base + 2, empire_editor_x_min, empire_editor_y_max - 16);
    image_draw(image_base + 2, empire_editor_x_max - 16, empire_editor_y_min);
    image_draw(image_base + 2, empire_editor_x_max - 16, empire_editor_y_max - 120);
    image_draw(image_base + 2, empire_editor_x_max - 16, empire_editor_y_max - 16);
    graphics_reset_clip_rectangle();
}

static void draw_shadowed_number(int value, int x, int y, color_t color)
{
    text_draw_number_colored(value, '@', " ", x + 1, y - 1, FONT_SMALL_PLAIN, COLOR_BLACK);
    text_draw_number_colored(value, '@', " ", x, y, FONT_SMALL_PLAIN, color);
}

static void draw_resource_trade_city(int resource, int trade_max, int x_offset, int y_offset)
{
    int image_id = resource_images[resource].editor_empire_icon_img_id + resource_image_offset(resource, RESOURCE_IMAGE_ICON);
    switch (trade_max) {
        case 15:
            image_draw(image_id, x_offset, y_offset);
            image_draw(image_data_s.group_image_ids[GROUP_EDITOR_TRADE_AMOUNT], x_offset + 17, y_offset);
            break;
        case 25:
            image_draw(image_id, x_offset, y_offset);
            image_draw(image_data_s.group_image_ids[GROUP_EDITOR_TRADE_AMOUNT] + 1, x_offset + 13, y_offset);
            break;
        case 40:
            image_draw(image_id, x_offset, y_offset);
            image_draw(image_data_s.group_image_ids[GROUP_EDITOR_TRADE_AMOUNT] + 2, x_offset + 11, y_offset);
            break;
        default:
            image_draw(image_id, x_offset, y_offset);
    }
}

static void arrow_buttons_draw(int x, int y, struct arrow_button_t *buttons, int num_buttons)
{
    for (int i = 0; i < num_buttons; i++) {
        int image_id = buttons[i].image_id;
        if (buttons[i].pressed) {
            image_id += 1;
        }
        image_draw(image_id, x + buttons[i].x_offset, y + buttons[i].y_offset);
    }
}

static void button_border_draw(int x, int y, int width_pixels, int height_pixels, int has_focus)
{
    int width_blocks = width_pixels / BLOCK_SIZE;
    if (width_pixels % BLOCK_SIZE) {
        width_blocks++;
    }
    int height_blocks = height_pixels / BLOCK_SIZE;
    if (height_pixels % BLOCK_SIZE) {
        height_blocks++;
    }
    int last_block_offset_x = BLOCK_SIZE * width_blocks - width_pixels;
    int last_block_offset_y = BLOCK_SIZE * height_blocks - height_pixels;

    int image_base = image_data_s.group_image_ids[GROUP_BORDERED_BUTTON];
    if (has_focus) {
        image_base += 8;
    }

    for (int yy = 0; yy < height_blocks; yy++) {
        int draw_offset_y = y + BLOCK_SIZE * yy;
        for (int xx = 0; xx < width_blocks; xx++) {
            int draw_offset_x = x + BLOCK_SIZE * xx;
            if (yy == 0) {
                if (xx == 0) {
                    image_draw(image_base, draw_offset_x, draw_offset_y);
                } else if (xx < width_blocks - 1) {
                    image_draw(image_base + 1, draw_offset_x, draw_offset_y);
                } else {
                    image_draw(image_base + 2, draw_offset_x - last_block_offset_x, draw_offset_y);
                }
            } else if (yy < height_blocks - 1) {
                if (xx == 0) {
                    image_draw(image_base + 7, draw_offset_x, draw_offset_y);
                } else if (xx >= width_blocks - 1) {
                    image_draw(image_base + 3, draw_offset_x - last_block_offset_x, draw_offset_y);
                }
            } else {
                if (xx == 0) {
                    image_draw(image_base + 6, draw_offset_x, draw_offset_y - last_block_offset_y);
                } else if (xx < width_blocks - 1) {
                    image_draw(image_base + 5, draw_offset_x, draw_offset_y - last_block_offset_y);
                } else {
                    image_draw(image_base + 4,
                        draw_offset_x - last_block_offset_x, draw_offset_y - last_block_offset_y);
                }
            }
        }
    }
}

static void text_draw_number_centered(int value, int x_offset, int y_offset, int box_width, int font)
{
    char str[NUMBER_BUFFER_LENGTH];
    number_to_string(str, value, '@', " ");
    text_draw_centered(str, x_offset, y_offset, box_width, font, 0);
}

static void draw_trade_city_info_editor_empire(int x_offset, int y_offset, int width)
{
    // draw arrow buttons for city type switching
    arrow_buttons_set_city_type[0].x_offset = x_offset + 20 + width;
    arrow_buttons_draw(0, 0, arrow_buttons_set_city_type, 1);

    // draw "Sells" and the resources to sell
    width += lang_text_draw(47, 5, x_offset + 100 + width, y_offset, FONT_NORMAL_GREEN);
    int resource_x_offset = x_offset + 110 + width;
    for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
        button_toggle_sell_resource_limit[r - 1].x = resource_x_offset;
        button_toggle_sell_resource_limit[r - 1].y = y_offset - 9;
        button_toggle_sell_resource_limit[r - 1].parameter1 = r;
        if (selected_empire_object_editor->resource_sell_limit[r]) {
            draw_resource_trade_city(r, selected_empire_object_editor->resource_sell_limit[r], resource_x_offset + 1, y_offset - 8);
        } else {
            image_draw_blend(871, resource_x_offset + 1, y_offset - 8, COLOR_MOUSE_DARK_GRAY);
        }
        resource_x_offset += 32;
    }

    resource_x_offset += 30;
    // draw "Buys" and the resources to buy
    resource_x_offset += lang_text_draw(47, 4, resource_x_offset, y_offset, FONT_NORMAL_GREEN);
    resource_x_offset += 10;
    for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
        button_toggle_buy_resource_limit[r - 1].x = resource_x_offset;
        button_toggle_buy_resource_limit[r - 1].y = y_offset - 9;
        button_toggle_buy_resource_limit[r - 1].parameter1 = r;
        if (selected_empire_object_editor->resource_buy_limit[r]) {
            draw_resource_trade_city(r, selected_empire_object_editor->resource_buy_limit[r], resource_x_offset + 1, y_offset - 8);
        } else {
            image_draw_blend(871, resource_x_offset + 1, y_offset - 8, COLOR_MOUSE_DARK_GRAY);
        }
        resource_x_offset += 32;
    }

    // draw the trade route cost
    button_set_trade_route_cost->x = resource_x_offset + 255;
    button_set_trade_route_cost->y = y_offset - 8;
    text_draw("Cost to open trade route: ", resource_x_offset + 50, y_offset, FONT_NORMAL_GREEN, 0);
    button_border_draw(button_set_trade_route_cost->x, button_set_trade_route_cost->y, button_set_trade_route_cost->width, 24, empire_editor_focus_trade_route_cost_button_id == 1);
    text_draw_number_centered(selected_empire_object_editor->trade_route_cost, button_set_trade_route_cost->x, y_offset, button_set_trade_route_cost->width, FONT_NORMAL_GREEN);
}

static void empire_set_viewport(int width, int height)
{
    empire_data.viewport_width = width;
    empire_data.viewport_height = height;
    check_scroll_boundaries();
}

static void empire_adjust_scroll(int *x_offset, int *y_offset)
{
    *x_offset = *x_offset - empire_data.scroll_x;
    *y_offset = *y_offset - empire_data.scroll_y;
}

static struct empire_object_t *get_trade_city_by_trade_route(int trade_route_id)
{
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        if (empire_objects[i].in_use
        && (empire_objects[i].city_type == EMPIRE_CITY_TRADE || empire_objects[i].city_type == EMPIRE_CITY_FUTURE_TRADE)
        && empire_objects[i].trade_route_id == trade_route_id) {
            return &empire_objects[i];
        }
    }
    return 0;
}

static int empire_object_update_animation(struct empire_object_t *obj, int image_id)
{
    if (obj->animation_index <= 0) {
        obj->animation_index = 1;
    }
    struct image_t *img = image_get(image_id);
    if (!timers[img->animation_speed_id].should_update) {
        return obj->animation_index;
    }
    if (img->animation_can_reverse) {
        int is_reverse = 0;
        if (obj->animation_index & 0x80) {
            is_reverse = 1;
        }
        int current_sprite = obj->animation_index & 0x7f;
        if (is_reverse) {
            obj->animation_index = current_sprite - 1;
            if (obj->animation_index < 1) {
                obj->animation_index = 1;
                is_reverse = 0;
            }
        } else {
            obj->animation_index = current_sprite + 1;
            if (obj->animation_index > img->num_animation_sprites) {
                obj->animation_index = img->num_animation_sprites;
                is_reverse = 1;
            }
        }
        if (is_reverse) {
            obj->animation_index = obj->animation_index | 0x80;
        }
    } else {
        // Absolutely normal case
        obj->animation_index++;
        if (obj->animation_index > img->num_animation_sprites) {
            obj->animation_index = 1;
        }
    }
    return obj->animation_index;
}

static void graphics_draw_inset_rect(int x, int y, int width, int height)
{
    graphics_draw_horizontal_line(x, x + width - 1, y, COLOR_INSET_DARK);
    graphics_draw_vertical_line(x + width - 1, y, y + height - 1, COLOR_INSET_LIGHT);
    graphics_draw_horizontal_line(x, x + width - 1, y + height - 1, COLOR_INSET_LIGHT);
    graphics_draw_vertical_line(x, y, y + height - 1, COLOR_INSET_DARK);
}

static void draw_foreground_editor_empire(void)
{
    int viewport_width = map_viewport_width();
    int viewport_height = map_viewport_height();
    graphics_set_clip_rectangle(empire_editor_x_min + 16, empire_editor_y_min + 16, viewport_width, viewport_height);
    empire_set_viewport(viewport_width, viewport_height);
    empire_editor_x_draw_offset = empire_editor_x_min + 16;
    empire_editor_y_draw_offset = empire_editor_y_min + 16;
    empire_adjust_scroll(&empire_editor_x_draw_offset, &empire_editor_y_draw_offset);
    image_draw(image_data_s.group_image_ids[GROUP_EDITOR_EMPIRE_MAP], empire_editor_x_draw_offset, empire_editor_y_draw_offset);
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        if (empire_objects[i].in_use) {
            // don't draw trade route if trade city switched to non-trade city
            if (empire_objects[i].type == EMPIRE_OBJECT_LAND_TRADE_ROUTE || empire_objects[i].type == EMPIRE_OBJECT_SEA_TRADE_ROUTE) {
                struct empire_object_t *trade_city = get_trade_city_by_trade_route(empire_objects[i].trade_route_id);
                if (!trade_city) {
                    continue;
                }
            }
            if (!empire_editor_show_battle_objects && (
                empire_objects[i].type == EMPIRE_OBJECT_BATTLE_ICON ||
                empire_objects[i].type == EMPIRE_OBJECT_ROMAN_ARMY ||
                empire_objects[i].type == EMPIRE_OBJECT_ENEMY_ARMY)) {
                continue;
            }

            if (empire_objects[i].type == EMPIRE_OBJECT_BATTLE_ICON) {
                draw_shadowed_number(empire_objects[i].invasion_path_id, empire_editor_x_draw_offset + empire_objects[i].x - 9, empire_editor_y_draw_offset + empire_objects[i].y - 9, COLOR_WHITE);
                draw_shadowed_number(empire_objects[i].invasion_years, empire_editor_x_draw_offset + empire_objects[i].x + 15, empire_editor_y_draw_offset + empire_objects[i].y - 9, COLOR_FONT_RED);
            } else if (empire_objects[i].type == EMPIRE_OBJECT_ROMAN_ARMY || empire_objects[i].type == EMPIRE_OBJECT_ENEMY_ARMY) {
                draw_shadowed_number(empire_objects[i].distant_battle_travel_months, empire_editor_x_draw_offset + empire_objects[i].x + 7, empire_editor_y_draw_offset + empire_objects[i].y - 9,
                    empire_objects[i].type == EMPIRE_OBJECT_ROMAN_ARMY ? COLOR_WHITE : COLOR_FONT_RED);
            }
            image_draw(empire_objects[i].image_id, empire_editor_x_draw_offset + empire_objects[i].x, empire_editor_y_draw_offset + empire_objects[i].y);
            struct image_t *img = image_get(empire_objects[i].image_id);
            if (img->animation_speed_id) {
                image_draw(empire_objects[i].image_id + empire_object_update_animation(&empire_objects[i], empire_objects[i].image_id),
                    empire_editor_x_draw_offset + empire_objects[i].x + img->sprite_offset_x,
                    empire_editor_y_draw_offset + empire_objects[i].y + img->sprite_offset_y);
            }
        }
    }
    graphics_reset_clip_rectangle();
    arrow_buttons_draw(empire_editor_x_min, empire_editor_y_max, arrow_buttons_empire, 2);
    if (selected_empire_object_editor && selected_empire_object_editor->type == EMPIRE_OBJECT_CITY) {
        // draw city info
        int x_offset = empire_editor_x_min + 28;
        int y_offset = empire_editor_y_max - 85;

        int width = lang_text_draw(21, selected_empire_object_editor->city_name_id, x_offset, y_offset, FONT_NORMAL_WHITE);
        arrow_buttons_set_city_type[0].y_offset = y_offset - 8;

        switch (selected_empire_object_editor->city_type) {
            case EMPIRE_CITY_DISTANT_ROMAN:
            case EMPIRE_CITY_VULNERABLE_ROMAN:
                width += lang_text_draw(47, 12, x_offset + 20 + width, y_offset, FONT_NORMAL_GREEN);
                if (selected_empire_object_editor->trade_route_id) {
                    arrow_buttons_set_city_type[0].x_offset = x_offset + 20 + width;
                    arrow_buttons_draw(0, 0, arrow_buttons_set_city_type, 1);
                }
                break;
            case EMPIRE_CITY_FUTURE_TRADE:
                width += text_draw("A future trade city", x_offset + 20 + width, y_offset, FONT_NORMAL_GREEN, 0);
                draw_trade_city_info_editor_empire(x_offset, y_offset, width);
                // draw empire expansion year (offset from scenario start year)
                text_draw("Year offset for empire expansion: ", x_offset + 350, y_offset + 40, FONT_NORMAL_GREEN, 0);
                button_border_draw(x_offset + 620, y_offset + 32, button_set_expansion_year->width, button_set_expansion_year->height, empire_editor_focus_expansion_year_button_id == 1);
                text_draw_number_centered(scenario.empire.expansion_year, x_offset + 620, y_offset + 40, button_set_expansion_year->width, FONT_NORMAL_GREEN);
                break;
            case EMPIRE_CITY_DISTANT_FOREIGN:
            case EMPIRE_CITY_FUTURE_ROMAN:
                lang_text_draw(47, 0, x_offset + 20 + width, y_offset, FONT_NORMAL_GREEN);
                break;
            case EMPIRE_CITY_OURS:
            {
                // draw "Our city!"
                width += lang_text_draw(47, 1, x_offset + 20 + width, y_offset, FONT_NORMAL_GREEN);
                // draw icons for available resources based on the "Buildings allowed" menu
                int resource_x_offset = x_offset + 30 + width;
                for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                    if (selected_empire_object_editor->resource_sell_limit[r]) {
                        graphics_draw_inset_rect(resource_x_offset, y_offset - 9, 26, 26);
                        int image_id = resource_images[r].editor_empire_icon_img_id + resource_image_offset(r, RESOURCE_IMAGE_ICON);
                        image_draw(image_id, resource_x_offset + 1, y_offset - 8);
                        resource_x_offset += 32;
                    }
                }
                break;
            }
            case EMPIRE_CITY_TRADE:
            {
                width += text_draw("A trade city", x_offset + 20 + width, y_offset, FONT_NORMAL_GREEN, 0);
                draw_trade_city_info_editor_empire(x_offset, y_offset, width);
                break;
            }
        }
    } else {
        lang_text_draw_centered(150, scenario.empire.id, empire_editor_x_min, empire_editor_y_max - 85, empire_editor_x_max - empire_editor_x_min, FONT_NORMAL_GREEN);
    }
}

static int get_arrow_key_value(struct key_t *arrow)
{
    if (arrow->state == KEY_STATE_AXIS) {
        return arrow->value;
    }
    return arrow->state != KEY_STATE_UNPRESSED;
}

static int set_arrow_input(struct key_t *arrow, struct key_t *opposite_arrow, float *modifier)
{
    if (get_arrow_key_value(arrow) && (!opposite_arrow || opposite_arrow->value == 0)) {
        if (arrow->state == KEY_STATE_AXIS) {
            scroll_data.constant_input = 1;
            int value = get_arrow_key_value(arrow);
            if (value == SCROLL_KEY_PRESSED) {
                *modifier = 1.0f;
            } else {
                *modifier = fminf(arrow->value / SCROLL_KEY_MAX_VALUE, 1.0f);
            }
        }
        return 1;
    }
    return 0;
}

static int speed_get_current_direction(struct speed_type_t *speed)
{
    if (!speed->current_speed) {
        return SPEED_DIRECTION_STOPPED;
    }
    return (speed->current_speed > 0) ? SPEED_DIRECTION_POSITIVE : SPEED_DIRECTION_NEGATIVE;
}

static int scroll_get_delta(struct mouse_t *m, struct pixel_view_coordinates_t *delta, int type)
{
    if (scroll_data.drag.active) {
        int delta_x = 0;
        int delta_y = 0;
        SDL_GetRelativeMouseState(&delta_x, &delta_y);
        scroll_data.drag.delta.x += delta_x;
        scroll_data.drag.delta.y += delta_y;
        if ((delta_x != 0 || delta_y != 0)) {
            set_relative_mouse_mode(1);
            // Store tiny movements until we decide that it's enough to move into scroll mode
            if (!scroll_data.drag.has_started) {
                scroll_data.drag.has_started = abs(scroll_data.drag.delta.x) > SCROLL_DRAG_MIN_DELTA
                    || abs(scroll_data.drag.delta.y) > SCROLL_DRAG_MIN_DELTA;
            }
        }
        if (scroll_data.drag.has_started) {
            speed_set_target(&scroll_data.speed.x, scroll_data.drag.delta.x, SPEED_CHANGE_IMMEDIATE, 0);
            speed_set_target(&scroll_data.speed.y, scroll_data.drag.delta.y, SPEED_CHANGE_IMMEDIATE, 0);
            scroll_data.drag.delta.x = 0;
            scroll_data.drag.delta.y = 0;
        }
        scroll_data.is_scrolling = 1;
    } else {
        int direction;
        int is_inside_window = m->is_inside_window;
        int width = screen_data.width;
        int height = screen_data.height;
        if (settings_values[SETTINGS_FULLSCREEN] && m->x < width && m->y < height) {
            // For Windows 10, in fullscreen mode, on HiDPI screens, this is needed
            // to get scrolling to work
            is_inside_window = 1;
        }
        if (is_inside_window) {
            int top = 0;
            int bottom = 0;
            int left = 0;
            int right = 0;
            int border = MOUSE_BORDER;
            int x = m->x;
            int y = m->y;
            scroll_data.constant_input = 0;
            scroll_data.speed.modifier_x = 0.0f;
            scroll_data.speed.modifier_y = 0.0f;
            if (scroll_data.limits.active) {
                border = TOUCH_BORDER;
                width = scroll_data.limits.width;
                height = scroll_data.limits.height;
                x -= scroll_data.limits.x;
                y -= scroll_data.limits.y;
                scroll_data.constant_input = 1;
            }
            // mouse near map edge
            // NOTE: using <= width/height (instead of <) to compensate for rounding
            // errors caused by scaling the display. SDL adds a 1px border to either
            // the right or the bottom when the aspect ratio does not match exactly.
            if (((!values[CONFIG_UI_DISABLE_MOUSE_EDGE_SCROLLING]) || scroll_data.limits.active) &&
                (x >= 0 && x <= width && y >= 0 && y <= height)) {
                if (x < border) {
                    left = 1;
                    scroll_data.speed.modifier_x = 1 - x / (float) border;
                } else if (x >= width - border) {
                    right = 1;
                    scroll_data.speed.modifier_x = 1 - (width - x) / (float) border;
                }
                if (y < border) {
                    top = 1;
                    scroll_data.speed.modifier_y = 1 - y / (float) border;
                } else if (y >= height - border) {
                    bottom = 1;
                    scroll_data.speed.modifier_y = 1 - (height - y) / (float) border;
                }
            }
            // keyboard/joystick arrow keys
            left |= set_arrow_input(&scroll_data.arrow_key.left, 0, &scroll_data.speed.modifier_x);
            right |= set_arrow_input(&scroll_data.arrow_key.right, &scroll_data.arrow_key.left, &scroll_data.speed.modifier_x);
            top |= set_arrow_input(&scroll_data.arrow_key.up, 0, &scroll_data.speed.modifier_y);
            bottom |= set_arrow_input(&scroll_data.arrow_key.down, &scroll_data.arrow_key.up, &scroll_data.speed.modifier_y);

            if (scroll_data.constant_input) {
                if (!scroll_data.speed.modifier_x) {
                    scroll_data.speed.modifier_x = scroll_data.speed.modifier_y;
                }
                if (!scroll_data.speed.modifier_y) {
                    scroll_data.speed.modifier_y = scroll_data.speed.modifier_x;
                }
            }
            // two sides
            if (left && top) {
                direction = DIR_7_TOP_LEFT;
            } else if (left && bottom) {
                direction = DIR_5_BOTTOM_LEFT;
            } else if (right && top) {
                direction = DIR_1_TOP_RIGHT;
            } else if (right && bottom) {
                direction = DIR_3_BOTTOM_RIGHT;
            } else if (left) { // one side
                direction = DIR_6_LEFT;
            } else if (right) {
                direction = DIR_2_RIGHT;
            } else if (top) {
                direction = DIR_0_TOP;
            } else if (bottom) {
                direction = DIR_4_BOTTOM;
            } else { // none of them
                direction = DIR_8_NONE;
            }
        } else {
            direction = DIR_8_NONE;
        }
        if (direction == DIR_8_NONE) {
            uint32_t time = SPEED_CHANGE_IMMEDIATE;
            speed_set_target(&scroll_data.speed.x, 0, time, 1);
            speed_set_target(&scroll_data.speed.y, 0, time, 1);
            scroll_data.is_scrolling = 0;
        } else {
            int dir_x = DIRECTION_X[direction];
            int dir_y = DIRECTION_Y[direction];
            int y_fraction = type == SCROLL_TYPE_CITY ? 2 : 1;
            int max_speed = SCROLL_STEP[type][calc_bound((100 - settings_values[SETTINGS_SCROLL_SPEED]) / 10, 0, 10)];
            int max_speed_x = max_speed * dir_x;
            int max_speed_y = (max_speed / y_fraction) * dir_y;
            if (!scroll_data.constant_input) {
                if (speed_get_current_direction(&scroll_data.speed.x) * dir_x < 0) {
                    speed_set_target(&scroll_data.speed.x, -scroll_data.speed.x.current_speed, SPEED_CHANGE_IMMEDIATE, scroll_data.speed.x.adjust_for_time);
                } else if (scroll_data.speed.x.desired_speed != max_speed_x) {
                    speed_set_target(&scroll_data.speed.x, max_speed_x, SPEED_CHANGE_IMMEDIATE, 1);
                }
                if (speed_get_current_direction(&scroll_data.speed.y) * dir_y < 0) {
                    speed_set_target(&scroll_data.speed.y, -scroll_data.speed.y.current_speed, SPEED_CHANGE_IMMEDIATE, scroll_data.speed.y.adjust_for_time);
                } else if (scroll_data.speed.y.desired_speed != max_speed_y) {
                    speed_set_target(&scroll_data.speed.y, max_speed_y, SPEED_CHANGE_IMMEDIATE, 1);
                }
            } else {
                speed_set_target(&scroll_data.speed.x, (int) (max_speed_x * scroll_data.speed.modifier_x), SPEED_CHANGE_IMMEDIATE, 1);
                speed_set_target(&scroll_data.speed.y, (int) (max_speed_y * scroll_data.speed.modifier_y), SPEED_CHANGE_IMMEDIATE, 1);
            }
            scroll_data.is_scrolling = 1;
        }
    }
    delta->x = speed_get_delta(&scroll_data.speed.x);
    delta->y = speed_get_delta(&scroll_data.speed.y);
    return delta->x != 0 || delta->y != 0;
}

static void empire_scroll_map(int x, int y)
{
    empire_data.scroll_x += x;
    empire_data.scroll_y += y;
    check_scroll_boundaries();
}

static int arrow_buttons_handle_mouse(struct mouse_t *m, int x, int y, struct arrow_button_t *buttons, int num_buttons, int *focus_button_id)
{
    static uint32_t last_time = 0;
    uint32_t curr_time = current_time;
    int should_repeat = 0;
    if (curr_time - last_time >= REPEAT_MILLIS) {
        should_repeat = 1;
        last_time = curr_time;
    }
    for (int i = 0; i < num_buttons; i++) {
        struct arrow_button_t *btn = &buttons[i];
        if (btn->pressed) {
            btn->pressed--;
            if (!btn->pressed) {
                btn->repeats = 0;
            }
        } else {
            btn->repeats = 0;
        }
    }
    int button_id = 0;
    for (int i = 0; i < num_buttons; i++) {
        if (x + buttons[i].x_offset <= m->x &&
            x + buttons[i].x_offset + buttons[i].size > m->x &&
            y + buttons[i].y_offset <= m->y &&
            y + buttons[i].y_offset + buttons[i].size > m->y) {
            button_id = i + 1;
            break;
        }
    }
    if (focus_button_id) {
        *focus_button_id = button_id;
    }
    if (!button_id) {
        return 0;
    }
    struct arrow_button_t *btn = &buttons[button_id - 1];
    if (m->left.went_down) {
        btn->pressed = BUTTON_PRESSED_FRAMES;
        btn->repeats = 0;
        btn->left_click_handler(btn->parameter1, btn->parameter2);
        return button_id;
    }
    if (m->left.is_down) {
        btn->pressed = BUTTON_PRESSED_FRAMES;
        if (should_repeat) {
            btn->repeats++;
            if (btn->repeats < 48) {
                if (!REPEATS[btn->repeats]) {
                    return 0;
                }
            } else {
                btn->repeats = 47;
            }
            btn->left_click_handler(btn->parameter1, btn->parameter2);
        }
        return button_id;
    }
    return 0;
}

static struct empire_object_t *empire_select_object(int x, int y)
{
    int map_x = x + empire_data.scroll_x;
    int map_y = y + empire_data.scroll_y;
    int min_dist = 10000;
    int min_obj_id = 0;
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        int obj_x, obj_y;
        if (scenario.empire.is_expanded) {
            obj_x = empire_objects[i].expanded.x;
            obj_y = empire_objects[i].expanded.y;
        } else {
            obj_x = empire_objects[i].x;
            obj_y = empire_objects[i].y;
        }
        if (obj_x - 8 > x || obj_x + empire_objects[i].width + 8 <= map_x) {
            continue;
        }
        if (obj_y - 8 > y || obj_y + empire_objects[i].height + 8 <= map_y) {
            continue;
        }
        int dist = calc_maximum_distance(map_x, map_y, obj_x + empire_objects[i].width / 2, obj_y + empire_objects[i].height / 2);
        if (dist < min_dist) {
            min_dist = dist;
            min_obj_id = i + 1;
        }
    }
    return min_obj_id ? &empire_objects[min_obj_id] : 0; // first object is not empty
}

static void handle_input_editor_empire(struct mouse_t *m, struct hotkeys_t *h)
{
    struct pixel_view_coordinates_t position;
    if (scroll_get_delta(m, &position, SCROLL_TYPE_EMPIRE)) {
        empire_scroll_map(position.x, position.y);
    }
    if (h->toggle_editor_battle_info) {
        empire_editor_show_battle_objects = !empire_editor_show_battle_objects;
    }
    if (h->show_empire_map) {
        show_editor_map();
    }
    if (arrow_buttons_handle_mouse(m, empire_editor_x_min, empire_editor_y_max, arrow_buttons_empire, 2, 0)) {
        return;
    }
    if (m->left.went_up
    && (m->x >= empire_editor_x_min + 16 && m->x <= empire_editor_x_max - 16 && m->y >= empire_editor_y_min + 16 && m->y <= empire_editor_y_max - 120) // mouse inside map
    ) {
        selected_empire_object_editor = empire_select_object(m->x - empire_editor_x_min - 16, m->y - empire_editor_y_min - 16);
        // place border flag on empty map spot
        if (!selected_empire_object_editor
        || !selected_empire_object_editor->in_use
        || (selected_empire_object_editor->type == EMPIRE_OBJECT_ORNAMENT && selected_empire_object_editor->image_id != 3323)) {
            for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
                if (!empire_objects[i].in_use) {
                    empire_objects[i].in_use = 1;
                    empire_objects[i].image_id = 3323;
                    empire_objects[i].x = m->x - empire_editor_x_min - 16;
                    empire_objects[i].y = m->y - empire_editor_y_min - 16;
                    return;
                }
            }
        }
        // if border flag selected, remove it
        if (selected_empire_object_editor && selected_empire_object_editor->image_id == 3323) {
            selected_empire_object_editor->in_use = 0;
        }
        window_invalidate();
    }
    if (selected_empire_object_editor && selected_empire_object_editor->type == EMPIRE_OBJECT_CITY) {
        if (selected_empire_object_editor->trade_route_id) {
            arrow_buttons_handle_mouse(m, 0, 0, arrow_buttons_set_city_type, 1, 0);
            if (generic_buttons_handle_mouse(m, 0, 0, button_toggle_sell_resource_limit, sizeof(button_toggle_sell_resource_limit) / sizeof(struct generic_button_t), 0)) {
                return;
            }
            if (generic_buttons_handle_mouse(m, 0, 0, button_toggle_buy_resource_limit, sizeof(button_toggle_buy_resource_limit) / sizeof(struct generic_button_t), 0)) {
                return;
            }
            if (generic_buttons_handle_mouse(m, 0, 0, button_set_trade_route_cost, 1, &empire_editor_focus_trade_route_cost_button_id)) {
                return;
            }
            if (selected_empire_object_editor->city_type == EMPIRE_CITY_FUTURE_TRADE) {
                if (generic_buttons_handle_mouse(m, empire_editor_x_min + 648, empire_editor_y_max - 53, button_set_expansion_year, 1, &empire_editor_focus_expansion_year_button_id)) {
                    return;
                }
            }
        }
        if (m->right.went_up || h->escape_pressed) {
            selected_empire_object_editor = 0;
            window_invalidate();
        }
    } else if (m->right.went_up || h->escape_pressed) {
        show_editor_map();
    }
}

static void show_editor_empire(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    struct window_type_t window = {
        WINDOW_EDITOR_EMPIRE,
        draw_background_editor_empire,
        draw_foreground_editor_empire,
        handle_input_editor_empire,
    };
    selected_empire_object_editor = 0;
    empire_editor_focus_trade_route_cost_button_id = 0;
    empire_editor_focus_expansion_year_button_id = 0;
    window_show(&window);
}

static void editor_tool_set_with_id(int type, int id)
{
    tool_data.active = 1;
    tool_data.type = type;
    tool_data.id = id;
}

static void button_build_tool(int tool, __attribute__((unused)) int param2)
{
    hide_editor_build_menu();
    current_tile.grid_offset = 0;
    editor_tool_set_with_id(tool, 0);
    if (window_data.current_window->id == WINDOW_EDITOR_BUILD_MENU) {
        show_editor_map();
    } else {
        window_data.refresh_on_draw = 1;
    }
}

static void draw_footprint(int x, int y, int grid_offset)
{
    if (grid_offset < 0) {
        // Outside map: draw black tile
        image_draw_isometric_footprint_from_draw_tile(image_data_s.group_image_ids[GROUP_TERRAIN_BLACK], x, y, 0);
    } else if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
        // Valid grid_offset and leftmost tile -> draw
        color_t color_mask = 0;
        int image_id = images.items[grid_offset];
        if (draw_context_water.advance_water_animation &&
            image_id >= draw_context_water.image_id_water_first &&
            image_id <= draw_context_water.image_id_water_last) {
            image_id++;
            if (image_id > draw_context_water.image_id_water_last) {
                image_id = draw_context_water.image_id_water_first;
            }
            images.items[grid_offset] = image_id;
        }
        image_draw_isometric_footprint_from_draw_tile(image_id, x, y, color_mask);
    }
}

static void draw_flags(int x, int y, int grid_offset)
{
    int figure_id = map_grid_is_valid_offset(grid_offset) ? map_figures.items[grid_offset] : 0;
    while (figure_id) {
        struct figure_t *f = &figures[figure_id];
        if (!f->is_invisible) {
            city_draw_figure(f, x, y, 0);
        }
        figure_id = f->next_figure_id_on_same_tile;
    }
}

static void draw_top(int x, int y, int grid_offset)
{
    if (!(edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE)) {
        return;
    }
    int image_id = images.items[grid_offset];
    color_t color_mask = 0;
    image_draw_isometric_top_from_draw_tile(image_id, x, y, color_mask);
}

static int can_place_building_editor(struct map_tile_t *tile, int num_tiles, int *blocked_tiles)
{
    int blocked = 0;
    for (int i = 0; i < num_tiles; i++) {
        int tile_offset = tile->grid_offset + TILE_GRID_OFFSETS_EDITOR[i];
        if ((terrain_grid.items[tile_offset] & TERRAIN_NOT_CLEAR) || (map_grid_is_valid_offset(tile_offset) && map_figures.items[tile_offset] > 0)) {
            blocked = 1;
            if (blocked_tiles) blocked_tiles[i] = 1;
        } else {
            if (blocked_tiles) blocked_tiles[i] = 0;
        }
    }
    return !blocked;
}

static void draw_flat_tile(int x, int y, color_t color_mask)
{
    if (color_mask == COLOR_MASK_GREEN && scenario.climate != CLIMATE_DESERT) {
        image_draw_blend_alpha(image_data_s.group_image_ids[GROUP_TERRAIN_FLAT_TILE], x, y, ALPHA_MASK_SEMI_TRANSPARENT | color_mask);
    } else {
        image_draw_blend(image_data_s.group_image_ids[GROUP_TERRAIN_FLAT_TILE], x, y, color_mask);
    }
}

static void draw_partially_blocked(int x, int y, int num_tiles, int *blocked_tiles)
{
    for (int i = 0; i < num_tiles; i++) {
        int x_offset = x + TILE_X_VIEW_OFFSETS[i];
        int y_offset = y + TILE_Y_VIEW_OFFSETS[i];
        if (blocked_tiles[i]) {
            draw_flat_tile(x_offset, y_offset, COLOR_MASK_RED);
        } else {
            draw_flat_tile(x_offset, y_offset, COLOR_MASK_GREEN);
        }
    }
}

static void draw_building_image(int image_id, int x, int y)
{
    image_draw_isometric_footprint(image_id, x, y, COLOR_MASK_GREEN);
    image_draw_isometric_top(image_id, x, y, COLOR_MASK_GREEN);
}

static void draw_building_editor(struct map_tile_t *tile, int x_view, int y_view, int type)
{
    int num_tiles = building_properties[type].size * building_properties[type].size;
    int blocked_tiles[MAX_TILES_OFFSETS];
    int blocked = !can_place_building_editor(tile, num_tiles, blocked_tiles);
    if (blocked) {
        draw_partially_blocked(x_view, y_view, num_tiles, blocked_tiles);
    } else if (tool_data.build_in_progress) {
        int image_id = image_data_s.group_image_ids[GROUP_TERRAIN_OVERLAY];
        for (int i = 0; i < num_tiles; i++) {
            int x_offset = x_view + TILE_X_VIEW_OFFSETS[i];
            int y_offset = y_view + TILE_Y_VIEW_OFFSETS[i];
            image_draw_isometric_footprint(image_id, x_offset, y_offset, 0);
        }
    } else {
        int image_id;
        if (type == BUILDING_NATIVE_CROPS) {
            image_id = image_data_s.group_image_ids[GROUP_EDITOR_BUILDING_CROPS];
        } else if (type == BUILDING_HOUSE_VACANT_LOT) {
            image_id = image_data_s.group_image_ids[GROUP_EDITOR_BUILDING_NATIVE] - 4;
        } else {
            image_id = image_data_s.group_image_ids[building_properties[type].image_group] + building_properties[type].image_offset;
        }
        draw_building_image(image_id, x_view, y_view);
    }
}

static int is_clear_terrain(struct map_tile_t *tile, int *warning)
{
    int result = !map_terrain_is(tile->grid_offset, TERRAIN_NOT_CLEAR ^ TERRAIN_ROAD);
    if (!result && warning) {
        *warning = WARNING_EDITOR_CANNOT_PLACE;
    }
    return result;
}

static int is_edge(struct map_tile_t *tile, int *warning)
{
    int result = tile->x == 0 || tile->y == 0 || tile->x == map_data.width - 1 || tile->y == map_data.height - 1;
    if (!result && warning) {
        *warning = WARNING_EDITOR_NEED_MAP_EDGE;
    }
    return result;
}

static int can_place_flag_editor(int type, struct map_tile_t *tile, int *warning)
{
    switch (type) {
        case TOOL_ENTRY_POINT:
        case TOOL_EXIT_POINT:
        case TOOL_INVASION_POINT:
            return is_clear_terrain(tile, warning) && is_edge(tile, warning);
        case TOOL_EARTHQUAKE_POINT:
        case TOOL_HERD_POINT:
            return is_clear_terrain(tile, warning);
        case TOOL_FISHING_POINT:
        {
            int is_water = map_terrain_is(tile->grid_offset, TERRAIN_WATER);
            if (!is_water && warning) {
                *warning = WARNING_EDITOR_NEED_OPEN_WATER;
            }
            return is_water;
        }
        case TOOL_RIVER_ENTRY_POINT:
        case TOOL_RIVER_EXIT_POINT:
        {
            int is_deep_water = map_terrain_is(tile->grid_offset, TERRAIN_WATER) && map_terrain_count_directly_adjacent_with_type(tile->grid_offset, TERRAIN_WATER) == 4;
            if (!is_deep_water && warning) {
                *warning = WARNING_EDITOR_NEED_OPEN_WATER;
            }
            return is_edge(tile, warning) && is_deep_water;
        }
        default:
            return 0;
    }
}

static int can_place_access_ramp_editor(struct map_tile_t *tile, int *orientation_index)
{
    if (!map_grid_is_inside(tile->x, tile->y, 2)) {
        return 0;
    }
    for (int orientation = 0; orientation < 4; orientation++) {
        int right_tiles = 0;
        int top_elevation = 0;
        for (int index = 0; index < 6; index++) {
            int tile_offset = tile->grid_offset + ACCESS_RAMP_TILE_OFFSETS_BY_ORIENTATION[orientation][index];
            int elevation = terrain_elevation.items[tile_offset];
            if (index < 2) {
                if (map_terrain_is(tile_offset, TERRAIN_ELEVATION)) {
                    right_tiles++;
                }
                top_elevation = elevation;
            } else if (index < 4) {
                if (map_terrain_is(tile_offset, TERRAIN_ELEVATION)) {
                    if (elevation != top_elevation) {
                        right_tiles++;
                    }
                } else if (elevation >= top_elevation) {
                    right_tiles++;
                }
            } else {
                if (elevation < top_elevation) {
                    right_tiles++;
                }
            }
        }
        if (right_tiles == 6) {
            if (orientation_index) {
                *orientation_index = orientation;
            }
            return 1;
        }
    }
    return 0;
}

static void draw_editor_map(void)
{
    int x, y, width, height;
    city_view_get_viewport(&x, &y, &width, &height);
    graphics_set_clip_rectangle(x, y, width, height);

    draw_context_water.advance_water_animation = 0;
    uint32_t now = current_time;
    if (now - draw_context_water.last_water_animation_time > 60) {
        draw_context_water.last_water_animation_time = now;
        draw_context_water.advance_water_animation = 1;
    }
    draw_context_water.image_id_water_first = image_data_s.group_image_ids[GROUP_TERRAIN_WATER];
    draw_context_water.image_id_water_last = 5 + draw_context_water.image_id_water_first;
    city_view_foreach_map_tile(draw_footprint);
    city_view_foreach_valid_map_tile(draw_flags, draw_top, 0);

    // draw editor tool
    if (!current_tile.grid_offset || scroll_data.is_scrolling || scroll_data.drag.active || !tool_data.active) {
        graphics_reset_clip_rectangle();
        return;
    }
    city_view_get_selected_tile_pixels(&x, &y);
    switch (tool_data.type) {
        case TOOL_NATIVE_CENTER:
            draw_building_editor(&current_tile, x, y, BUILDING_NATIVE_MEETING);
            break;
        case TOOL_NATIVE_HUT:
            draw_building_editor(&current_tile, x, y, BUILDING_NATIVE_HUT);
            break;
        case TOOL_NATIVE_FIELD:
            draw_building_editor(&current_tile, x, y, BUILDING_NATIVE_CROPS);
            break;
        case TOOL_HOUSE_VACANT_LOT:
            draw_building_editor(&current_tile, x, y, BUILDING_HOUSE_VACANT_LOT);
            break;
        case TOOL_EARTHQUAKE_POINT:
        case TOOL_ENTRY_POINT:
        case TOOL_EXIT_POINT:
        case TOOL_RIVER_ENTRY_POINT:
        case TOOL_RIVER_EXIT_POINT:
        case TOOL_INVASION_POINT:
        case TOOL_FISHING_POINT:
        case TOOL_HERD_POINT:
            draw_flat_tile(x, y, can_place_flag_editor(tool_data.type, &current_tile, 0) ? COLOR_MASK_GREEN : COLOR_MASK_RED);
            break;
        case TOOL_ACCESS_RAMP:
        {
            int orientation;
            if (can_place_access_ramp_editor(&current_tile, &orientation)) {
                int image_id = image_data_s.group_image_ids[GROUP_TERRAIN_ACCESS_RAMP] + orientation;
                draw_building_image(image_id, x, y);
            } else {
                int blocked[4] = { 1, 1, 1, 1 };
                draw_partially_blocked(x, y, 4, blocked);
            }
            break;
        }
        case TOOL_GRASS:
        case TOOL_SMALL_SHRUB:
        case TOOL_MEDIUM_SHRUB:
        case TOOL_LARGE_SHRUB:
        case TOOL_LARGEST_SHRUB:
        case TOOL_TREES:
        case TOOL_WATER:
        case TOOL_RAISE_LAND:
        case TOOL_LOWER_LAND:
        case TOOL_SMALL_ROCK:
        case TOOL_MEDIUM_ROCK:
        case TOOL_LARGE_ROCK:
        case TOOL_MEADOW:
            // draw brush
            draw_flat_tile(x, y, COLOR_MASK_GREEN);
            int tiles_remaining = tool_data.brush_size;
            while (tiles_remaining) {
                for (int i = 1; i <= tiles_remaining; i++) {
                    draw_flat_tile(x + HALF_TILE_WIDTH_PIXELS * (i + (tool_data.brush_size - tiles_remaining)), y - HALF_TILE_HEIGHT_PIXELS * (i - (tool_data.brush_size - tiles_remaining)), COLOR_MASK_GREEN);
                    draw_flat_tile(x + HALF_TILE_WIDTH_PIXELS * (i - (tool_data.brush_size - tiles_remaining)), y + HALF_TILE_HEIGHT_PIXELS * (i + (tool_data.brush_size - tiles_remaining)), COLOR_MASK_GREEN);
                    draw_flat_tile(x - HALF_TILE_WIDTH_PIXELS * (i + (tool_data.brush_size - tiles_remaining)), y + HALF_TILE_HEIGHT_PIXELS * (i - (tool_data.brush_size - tiles_remaining)), COLOR_MASK_GREEN);
                    draw_flat_tile(x - HALF_TILE_WIDTH_PIXELS * (i - (tool_data.brush_size - tiles_remaining)), y - HALF_TILE_HEIGHT_PIXELS * (i + (tool_data.brush_size - tiles_remaining)), COLOR_MASK_GREEN);
                }
                tiles_remaining--;
            }
            break;
        case TOOL_ROAD:
        {
            int blocked = 0;
            int image_id = 0;
            if (map_terrain_is(current_tile.grid_offset, TERRAIN_NOT_CLEAR)) {
                blocked = 1;
            } else {
                image_id = image_data_s.group_image_ids[GROUP_TERRAIN_ROAD];
                if (!map_terrain_has_adjacent_x_with_type(current_tile.grid_offset, TERRAIN_ROAD) &&
                    map_terrain_has_adjacent_y_with_type(current_tile.grid_offset, TERRAIN_ROAD)) {
                    image_id++;
                }
            }
            if (blocked) {
                draw_flat_tile(x, y, COLOR_MASK_RED);
            } else {
                draw_building_image(image_id, x, y);
            }
            break;
        }
    }
    graphics_reset_clip_rectangle();
}

static int get_sidebar_x_offset(void)
{
    int view_x, view_y, view_width, view_height;
    city_view_get_viewport(&view_x, &view_y, &view_width, &view_height);
    return view_x + view_width;
}

static void draw_foreground_build_menu_editor(void)
{
    draw_editor_map();
    // draw menu buttons
    int x_offset = get_sidebar_x_offset();
    for (int i = 0; i < num_items_build_menu; i++) {
        label_draw(x_offset - MENU_X_OFFSET, 180 + MENU_Y_OFFSET + MENU_ITEM_HEIGHT * i, 10, focus_button_id_build_menu == i + 1 ? 1 : 2);
        text_draw_centered(editor_menu_types_strings[selected_submenu_build_menu][i], x_offset - MENU_X_OFFSET, 180 + MENU_Y_OFFSET + 3 + MENU_ITEM_HEIGHT * i,
            MENU_ITEM_WIDTH_EDITOR, FONT_NORMAL_GREEN, COLOR_BLACK);
    }
}

static void button_menu_item(int index, __attribute__((unused)) int param2)
{
    current_tile.grid_offset = 0;
    switch (selected_submenu_build_menu) {
        case MENU_SHRUB:
            switch (index) {
                case 0: editor_tool_set_with_id(TOOL_SMALL_SHRUB, 0); break;
                case 1: editor_tool_set_with_id(TOOL_MEDIUM_SHRUB, 0); break;
                case 2: editor_tool_set_with_id(TOOL_LARGE_SHRUB, 0); break;
                case 3: editor_tool_set_with_id(TOOL_LARGEST_SHRUB, 0); break;
            }
            break;
        case MENU_ELEVATION:
            switch (index) {
                case 0: editor_tool_set_with_id(TOOL_RAISE_LAND, 0); break;
                case 1: editor_tool_set_with_id(TOOL_LOWER_LAND, 0); break;
                case 2: editor_tool_set_with_id(TOOL_ACCESS_RAMP, 0); break;
            }
            break;
        case MENU_ROCK:
            switch (index) {
                case 0: editor_tool_set_with_id(TOOL_SMALL_ROCK, 0); break;
                case 1: editor_tool_set_with_id(TOOL_MEDIUM_ROCK, 0); break;
                case 2: editor_tool_set_with_id(TOOL_LARGE_ROCK, 0); break;
            }
            break;
        case MENU_BRUSH_SIZE:
            tool_data.brush_size = index;
            break;
        case MENU_EARTHQUAKE_POINTS:
            editor_tool_set_with_id(TOOL_EARTHQUAKE_POINT, index);
            break;
        case MENU_INVASION_POINTS:
            editor_tool_set_with_id(TOOL_INVASION_POINT, index);
            break;
        case MENU_PEOPLE_POINTS:
            switch (index) {
                case 0: editor_tool_set_with_id(TOOL_ENTRY_POINT, 0); break;
                case 1: editor_tool_set_with_id(TOOL_EXIT_POINT, 0); break;
            }
            break;
        case MENU_RIVER_POINTS:
            switch (index) {
                case 0: editor_tool_set_with_id(TOOL_RIVER_ENTRY_POINT, 0); break;
                case 1: editor_tool_set_with_id(TOOL_RIVER_EXIT_POINT, 0); break;
            }
            break;
        case MENU_NATIVE_BUILDINGS:
            switch (index) {
                case 0: editor_tool_set_with_id(TOOL_NATIVE_HUT, 0); break;
                case 1: editor_tool_set_with_id(TOOL_NATIVE_CENTER, 0); break;
                case 2: editor_tool_set_with_id(TOOL_NATIVE_FIELD, 0); break;
                case 3: editor_tool_set_with_id(TOOL_HOUSE_VACANT_LOT, 0); break;
            }
            break;
        case MENU_ANIMAL_POINTS:
            if (index < MAX_FISH_POINTS) {
                editor_tool_set_with_id(TOOL_FISHING_POINT, index);
            } else {
                editor_tool_set_with_id(TOOL_HERD_POINT, index - MAX_FISH_POINTS);
            }
            break;
    }
    selected_submenu_build_menu = MENU_NONE;
    show_editor_map();
}

static struct generic_button_t build_menu_buttons_editor[] = {
    {0, 0, 160, 20, button_menu_item, button_none, 0, 0},
    {0, 24, 160, 20, button_menu_item, button_none, 1, 0},
    {0, 48, 160, 20, button_menu_item, button_none, 2, 0},
    {0, 72, 160, 20, button_menu_item, button_none, 3, 0},
    {0, 96, 160, 20, button_menu_item, button_none, 4, 0},
    {0, 120, 160, 20, button_menu_item, button_none, 5, 0},
    {0, 144, 160, 20, button_menu_item, button_none, 6, 0},
    {0, 168, 160, 20, button_menu_item, button_none, 7, 0},
    {0, 192, 160, 20, button_menu_item, button_none, 8, 0},
    {0, 216, 160, 20, button_menu_item, button_none, 9, 0},
    {0, 240, 160, 20, button_menu_item, button_none, 10, 0},
    {0, 264, 160, 20, button_menu_item, button_none, 11, 0},
    {0, 288, 160, 20, button_menu_item, button_none, 12, 0},
    {0, 312, 160, 20, button_menu_item, button_none, 13, 0},
    {0, 336, 160, 20, button_menu_item, button_none, 14, 0},
    {0, 360, 160, 20, button_menu_item, button_none, 15, 0}
};

static void handle_input_build_menu_editor(struct mouse_t *m, struct hotkeys_t *h)
{
    if (generic_buttons_handle_mouse(m, get_sidebar_x_offset() - MENU_X_OFFSET, 180 + MENU_Y_OFFSET, build_menu_buttons_editor, num_items_build_menu, &focus_button_id_build_menu)) {
        return;
    }
    if (m->right.went_up
    || h->escape_pressed
    || (m->left.went_up
        && (m->x < get_sidebar_x_offset() - MENU_X_OFFSET - MENU_CLICK_MARGIN || m->x > get_sidebar_x_offset() + MENU_CLICK_MARGIN
            || m->y < 180 + MENU_Y_OFFSET - MENU_CLICK_MARGIN || m->y > 180 + MENU_Y_OFFSET + MENU_CLICK_MARGIN + MENU_ITEM_HEIGHT * num_items_build_menu)) // click outside menu
    ) {
        selected_submenu_build_menu = MENU_NONE;
        show_editor_map();
    }
}

static void show_editor_build_menu(int submenu, __attribute__((unused)) int param2)
{
    if (submenu == MENU_NONE || submenu == selected_submenu_build_menu) {
        hide_editor_build_menu();
        return;
    }
    selected_submenu_build_menu = submenu;
    num_items_build_menu = 0;
    for (int i = 0; i < MAX_ITEMS_PER_MENU; i++) {
        if (editor_menu_types_strings[selected_submenu_build_menu][i][0]) {
            num_items_build_menu++;
        }
    }
    struct window_type_t window = {
        WINDOW_EDITOR_BUILD_MENU,
        0,
        draw_foreground_build_menu_editor,
        handle_input_build_menu_editor,
    };
    window_show(&window);
}

static struct image_button_t buttons_build[] = {
    {7, 123, 71, 23, IB_NORMAL, GROUP_EDITOR_SIDEBAR_BUTTONS, 48, button_attributes, button_none, 1, 0, 1, 0, 0, 0},
    {84, 123, 71, 23, IB_NORMAL, GROUP_SIDEBAR_ADVISORS_EMPIRE, 3, show_editor_empire, button_none, 0, 0, 1, 0, 0, 0},
    {13, 267, 39, 26, IB_NORMAL, GROUP_EDITOR_SIDEBAR_BUTTONS, 0, button_build_tool, button_none, TOOL_GRASS, 0, 1, 0, 0, 0},
    {63, 267, 39, 26, IB_BUILD, GROUP_EDITOR_SIDEBAR_BUTTONS, 3, show_editor_build_menu, button_none, MENU_SHRUB, 0, 1, 0, 0, 0},
    {113, 267, 39, 26, IB_NORMAL, GROUP_EDITOR_SIDEBAR_BUTTONS, 6, button_build_tool, button_none, TOOL_WATER, 0, 1, 0, 0, 0},
    {13, 303, 39, 26, IB_BUILD, GROUP_EDITOR_SIDEBAR_BUTTONS, 21, show_editor_build_menu, button_none, MENU_ELEVATION, 0, 1, 0, 0, 0},
    {63, 303, 39, 26, IB_NORMAL, GROUP_EDITOR_SIDEBAR_BUTTONS, 12, button_build_tool, button_none, TOOL_TREES, 0, 1, 0, 0, 0},
    {113, 303, 39, 26, IB_NORMAL, GROUP_EDITOR_SIDEBAR_BUTTONS, 15, show_editor_build_menu, button_none, MENU_ROCK, 0, 1, 0, 0, 0},
    {13, 339, 39, 26, IB_NORMAL, GROUP_EDITOR_SIDEBAR_BUTTONS, 18, button_build_tool, button_none, TOOL_MEADOW, 0, 1, 0, 0, 0},
    {63, 339, 39, 26, IB_NORMAL, GROUP_EDITOR_SIDEBAR_BUTTONS, 30, button_build_tool, button_none, TOOL_ROAD, 0, 1, 0, 0, 0},
    {113, 339, 39, 26, IB_BUILD, GROUP_EDITOR_SIDEBAR_BUTTONS, 24, show_editor_build_menu, button_none, MENU_BRUSH_SIZE, 0, 1, 0, 0, 0},
    {13, 375, 39, 26, IB_BUILD, GROUP_EDITOR_SIDEBAR_BUTTONS, 9, show_editor_build_menu, button_none, MENU_EARTHQUAKE_POINTS, 0, 1, 0, 0, 0},
    {63, 375, 39, 26, IB_BUILD, GROUP_EDITOR_SIDEBAR_BUTTONS, 39, show_editor_build_menu, button_none, MENU_INVASION_POINTS, 0, 1, 0, 0, 0},
    {113, 375, 39, 26, IB_BUILD, GROUP_EDITOR_SIDEBAR_BUTTONS, 42, show_editor_build_menu, button_none, MENU_PEOPLE_POINTS, 0, 1, 0, 0, 0},
    {13, 411, 39, 26, IB_BUILD, GROUP_EDITOR_SIDEBAR_BUTTONS, 33, show_editor_build_menu, button_none, MENU_RIVER_POINTS, 0, 1, 0, 0, 0},
    {63, 411, 39, 26, IB_BUILD, GROUP_EDITOR_SIDEBAR_BUTTONS, 27, show_editor_build_menu, button_none, MENU_NATIVE_BUILDINGS, 0, 1, 0, 0, 0},
    {113, 411, 39, 26, IB_BUILD, GROUP_EDITOR_SIDEBAR_BUTTONS, 51, show_editor_build_menu, button_none, MENU_ANIMAL_POINTS, 0, 1, 0, 0, 0},
};

static void sidebar_common_draw_relief(int x_offset, int y_offset, int image, int is_collapsed)
{
    // relief images below panel
    int image_base = image_data_s.group_image_ids[image];
    int image_offset = image == GROUP_SIDE_PANEL ? 2 : 1;
    int y_max = screen_data.height;
    while (y_offset < y_max) {
        if (y_max - y_offset <= 120) {
            image_draw(image_base + image_offset + is_collapsed, x_offset, y_offset);
            y_offset += 120;
        } else {
            image_draw(image_base + image_offset + image_offset + is_collapsed, x_offset, y_offset);
            y_offset += 285;
        }
    }
}

static void button_fullscreen(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    post_event(settings_values[SETTINGS_FULLSCREEN] ? USER_EVENT_WINDOWED : USER_EVENT_FULLSCREEN);
}

static void button_reset_window(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    system_resize(1280, 800);
    post_event(USER_EVENT_CENTER_WINDOW);
}

static struct generic_button_t display_top_menu_buttons[] = {
    {128, 136, 224, 20, button_fullscreen, button_none, 1, 0},
    {128, 160, 224, 20, button_reset_window, button_none, 0, 0},
};

static void draw_foreground_display_options(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);

    outer_panel_draw(96, 80, 18, 8);

    label_draw(128, 136, 14, display_options_data.focus_button_id == 1 ? 1 : 2);
    label_draw(128, 160, 14, display_options_data.focus_button_id == 2 ? 1 : 2);

    // Display Options
    lang_text_draw_centered(42, 0, 128, 94, 224, FONT_LARGE_BLACK);

    // Full screen/Windowed screen
    lang_text_draw_centered(42, settings_values[SETTINGS_FULLSCREEN] ? 2 : 1, 128, 140, 224, FONT_NORMAL_GREEN);

    // Reset resolution
    text_draw_centered("Reset window", 128, 164, 224, FONT_NORMAL_GREEN, COLOR_BLACK);

    set_translation(0, 0);
}

static void handle_input_display_options(struct mouse_t *m, struct hotkeys_t *h)
{
    if (generic_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, display_top_menu_buttons, sizeof(display_top_menu_buttons) / (sizeof(struct generic_button_t)), &display_options_data.focus_button_id)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        display_options_data.close_callback();
    }
}

static void window_display_options_show(void (*close_callback)(void))
{
    struct window_type_t window = {
        WINDOW_DISPLAY_OPTIONS,
        window_draw_underlying_window,
        draw_foreground_display_options,
        handle_input_display_options,
    };
    display_options_data.focus_button_id = 0;
    display_options_data.close_callback = close_callback;
    window_show(&window);
}

static void clear_state(void)
{
    open_sub_menu_top_menu_editor = 0;
    focus_menu_id_top_menu_editor = 0;
    focus_sub_menu_id_top_menu_editor = 0;
}

static void menu_options_display_editor(__attribute__((unused)) int param)
{
    clear_state();
    show_editor_map();
    window_display_options_show(show_editor_map);
}

static void stop_sound_channel(int channel)
{
    if (data_channels.initialized) {
        struct sound_channel_t *ch = &data_channels.channels[channel];
        if (ch->chunk) {
            Mix_HaltChannel(channel);
            Mix_FreeChunk(ch->chunk);
            ch->chunk = 0;
        }
    }
}

static void button_toggle_sound_options(int type, __attribute__((unused)) int param2)
{
    switch (type) {
        case SOUND_MUSIC:
            settings_values[SETTINGS_MUSIC_ENABLED] = settings_values[SETTINGS_MUSIC_ENABLED] ? 0 : 1;
            if (settings_values[SETTINGS_MUSIC_ENABLED]) {
                update_music(1);
            } else {
                stop_music();
            }
            break;
        case SOUND_SPEECH:
            settings_values[SETTINGS_SPEECH_ENABLED] = settings_values[SETTINGS_SPEECH_ENABLED] ? 0 : 1;
            if (!settings_values[SETTINGS_SPEECH_ENABLED]) {
                stop_sound_channel(SOUND_CHANNEL_SPEECH);
            }
            break;
        case SOUND_EFFECTS:
            settings_values[SETTINGS_SOUND_EFFECTS_ENABLED] = settings_values[SETTINGS_SOUND_EFFECTS_ENABLED] ? 0 : 1;
            break;
        case SOUND_CITY:
            settings_values[SETTINGS_CITY_SOUNDS_ENABLED] = settings_values[SETTINGS_CITY_SOUNDS_ENABLED] ? 0 : 1;
            break;
    }
}

static struct generic_button_t buttons_sound_options[] = {
    {64, 162, 224, 20, button_toggle_sound_options, button_none, SOUND_MUSIC, 0},
    {64, 192, 224, 20, button_toggle_sound_options, button_none, SOUND_SPEECH, 0},
    {64, 222, 224, 20, button_toggle_sound_options, button_none, SOUND_EFFECTS, 0},
    {64, 252, 224, 20, button_toggle_sound_options, button_none, SOUND_CITY, 0},
};

static void arrow_button_music(int value, __attribute__((unused)) int param2)
{
    settings_values[SETTINGS_MUSIC_VOLUME] = calc_bound(settings_values[SETTINGS_MUSIC_VOLUME] + value, 0, 100);
    Mix_VolumeMusic(settings_values[SETTINGS_MUSIC_VOLUME] * SDL_MIX_MAXVOLUME / 100);

}

static void arrow_button_speech(int value, __attribute__((unused)) int param2)
{
    settings_values[SETTINGS_SPEECH_VOLUME] = calc_bound(settings_values[SETTINGS_SPEECH_VOLUME] + value, 0, 100);
    set_channel_volume(SOUND_CHANNEL_SPEECH, settings_values[SETTINGS_SPEECH_VOLUME]);
}

static void arrow_button_effects(int value, __attribute__((unused)) int param2)
{
    settings_values[SETTINGS_SOUND_EFFECTS_VOLUME] = calc_bound(settings_values[SETTINGS_SOUND_EFFECTS_VOLUME] + value, 0, 100);
    for (int i = SOUND_CHANNEL_EFFECTS_MIN; i <= SOUND_CHANNEL_EFFECTS_MAX; i++) {
        set_channel_volume(i, settings_values[SETTINGS_SOUND_EFFECTS_VOLUME]);
    }
}

static void arrow_button_city(int value, __attribute__((unused)) int param2)
{
    settings_values[SETTINGS_CITY_SOUNDS_VOLUME] = calc_bound(settings_values[SETTINGS_CITY_SOUNDS_VOLUME] + value, 0, 100);
    for (int i = SOUND_CHANNEL_CITY_MIN; i <= SOUND_CHANNEL_CITY_MAX; i++) {
        set_channel_volume(i, settings_values[SETTINGS_CITY_SOUNDS_VOLUME]);
    }
}

static struct arrow_button_t arrow_buttons_sound_options[] = {
    {112, 100, 17, 24, arrow_button_music, -1, 0, 0, 0},
    {136, 100, 15, 24, arrow_button_music, 1, 0, 0, 0},
    {112, 130, 17, 24, arrow_button_speech, -1, 0, 0, 0},
    {136, 130, 15, 24, arrow_button_speech, 1, 0, 0, 0},
    {112, 160, 17, 24, arrow_button_effects, -1, 0, 0, 0},
    {136, 160, 15, 24, arrow_button_effects, 1, 0, 0, 0},
    {112, 190, 17, 24, arrow_button_city, -1, 0, 0, 0},
    {136, 190, 15, 24, arrow_button_city, 1, 0, 0, 0},
};

static int text_draw_percentage(int value, int x_offset, int y_offset, int font)
{
    char str[NUMBER_BUFFER_LENGTH];
    number_to_string(str, value, '@', "%");
    return text_draw(str, x_offset, y_offset, font, 0);
}

static void draw_foreground_sound_options(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    outer_panel_draw(48, 80, 24, 15);
    // on/off labels
    label_draw(64, 162, 14, sound_options_data.focus_button_id == 1 ? 1 : 2);
    label_draw(64, 192, 14, sound_options_data.focus_button_id == 2 ? 1 : 2);
    label_draw(64, 222, 14, sound_options_data.focus_button_id == 3 ? 1 : 2);
    label_draw(64, 252, 14, sound_options_data.focus_button_id == 4 ? 1 : 2);
    lang_text_draw_centered(46, 0, 96, 92, 288, FONT_LARGE_BLACK);     // title
    lang_text_draw(46, 10, 112, 142, FONT_SMALL_PLAIN);
    lang_text_draw(46, 11, 336, 142, FONT_SMALL_PLAIN);
    lang_text_draw_centered(46, settings_values[SETTINGS_MUSIC_ENABLED] ? 2 : 1, 64, 166, 224, FONT_NORMAL_GREEN);
    text_draw_percentage(settings_values[SETTINGS_MUSIC_VOLUME], 374, 166, FONT_NORMAL_PLAIN);
    lang_text_draw_centered(46, settings_values[SETTINGS_SPEECH_ENABLED] ? 4 : 3, 64, 196, 224, FONT_NORMAL_GREEN);
    text_draw_percentage(settings_values[SETTINGS_SPEECH_VOLUME], 374, 196, FONT_NORMAL_PLAIN);
    lang_text_draw_centered(46, settings_values[SETTINGS_SOUND_EFFECTS_ENABLED] ? 6 : 5, 64, 226, 224, FONT_NORMAL_GREEN);
    text_draw_percentage(settings_values[SETTINGS_SOUND_EFFECTS_VOLUME], 374, 226, FONT_NORMAL_PLAIN);
    lang_text_draw_centered(46, settings_values[SETTINGS_CITY_SOUNDS_ENABLED] ? 8 : 7, 64, 256, 224, FONT_NORMAL_GREEN);
    text_draw_percentage(settings_values[SETTINGS_CITY_SOUNDS_VOLUME], 374, 256, FONT_NORMAL_PLAIN);
    arrow_buttons_draw(208, 60, arrow_buttons_sound_options, sizeof(arrow_buttons_sound_options) / sizeof(struct arrow_button_t));
    set_translation(0, 0);
}

static int building_construction_is_updatable(void)
{
    switch (construction_data.type) {
        case BUILDING_CLEAR_LAND:
        case BUILDING_ROAD:
        case BUILDING_AQUEDUCT:
        case BUILDING_WALL:
        case BUILDING_PLAZA:
        case BUILDING_GARDENS:
        case BUILDING_HOUSE_VACANT_LOT:
            return 1;
        default:
            return 0;
    }
}

static void map_property_restore(void)
{
    memcpy(bitfields_grid.items, bitfields_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memcpy(edge_grid.items, edge_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
}

static void restore_map_images(void)
{
    for (int y = 0; y < map_data.height; y++) {
        for (int x = 0; x < map_data.width; x++) {
            int grid_offset = map_grid_offset(x, y);
            if (!map_building_at(grid_offset)) {
                images.items[grid_offset] = images_backup.items[grid_offset];
            }
        }
    }
}

static void game_undo_restore_map(int include_properties)
{
    memcpy(terrain_grid.items, terrain_grid_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
    memcpy(aqueduct.items, aqueduct_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    if (include_properties) {
        map_property_restore();
    }
    restore_map_images();
}

static void building_construction_cancel(void)
{
    map_property_clear_constructing_and_deleted();
    if (construction_data.in_progress && building_construction_is_updatable()) {
        game_undo_restore_map(1);
        construction_data.in_progress = 0;
        construction_data.cost_preview = 0;
    } else {
        building_construction_clear_type();
    }
}

static void clear_map_data(void)
{
    memset(images.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
    map_building_clear();
    memset(terrain_grid.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
    memset(aqueduct.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memset(map_figures.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
    map_property_clear();
    memset(sprite.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memset(random.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memset(desirability_grid.items, 0, GRID_SIZE * GRID_SIZE * sizeof(int8_t));
    memset(terrain_elevation.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memset(network.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    for (int i = 0; i < CONTEXT_MAX_ITEMS; i++) {
        clear_current_offset(context_pointers[i].context, context_pointers[i].size);
    }
    int y_start = (GRID_SIZE - map_data.height) / 2;
    int x_start = (GRID_SIZE - map_data.width) / 2;
    for (int y = 0; y < GRID_SIZE; y++) {
        int y_outside_map = y < y_start || y >= y_start + map_data.height;
        for (int x = 0; x < GRID_SIZE; x++) {
            if (y_outside_map || x < x_start || x >= x_start + map_data.width) {
                terrain_grid.items[x + GRID_SIZE * y] = TERRAIN_SHRUB | TERRAIN_WATER;
            }
        }
    }
    map_random_init();
    for (int y = 0; y < map_data.height; y++) {
        for (int x = 0; x < map_data.width; x++) {
            int grid_offset = map_grid_offset(x, y);
            if (random.items[grid_offset] & 1) {
                bitfields_grid.items[grid_offset] |= BIT_ALTERNATE_TERRAIN;
            }
        }
    }
}

static void prepare_map_for_editing(int map_is_new)
{
    image_load_climate(scenario.climate, 1, 0);
    if (map_is_new) {
        empire_load(0);
        empire_object_our_city_set_resources_sell();
    }
    figure_init_scenario();
    for (int id = MAP_FLAG_MIN; id < MAP_FLAG_MAX; id++) {
        figure_create(FIGURE_MAP_FLAG, -1, -1, 0)->resource_id = id;
    }
    figure_create_flotsam();
    map_tiles_update_all_elevation();
    map_tiles_update_all_earthquake();
    map_tiles_update_all_empty_land();
    map_tiles_update_all_roads();
    map_tiles_update_all_plazas();
    map_tiles_update_all_walls();
    map_tiles_update_all_aqueducts(0);
    int native_image = image_data_s.group_image_ids[GROUP_EDITOR_BUILDING_NATIVE];
    int grid_offset = map_data.start_offset;
    for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (!map_terrain_is(grid_offset, TERRAIN_BUILDING) || map_building_at(grid_offset)) {
                continue;
            }
            int type;
            int image_id = images.items[grid_offset];
            if (image_id == scenario.native_images.hut) {
                type = BUILDING_NATIVE_HUT;
                images.items[grid_offset] = native_image;
            } else if (image_id == scenario.native_images.hut + 1) {
                type = BUILDING_NATIVE_HUT;
                images.items[grid_offset] = native_image + 1;
            } else if (image_id == scenario.native_images.meeting) {
                type = BUILDING_NATIVE_MEETING;
                images.items[grid_offset] = native_image + 2;
                images.items[grid_offset + map_grid_delta(1, 0)] = native_image + 2;
                images.items[grid_offset + map_grid_delta(0, 1)] = native_image + 2;
                images.items[grid_offset + map_grid_delta(1, 1)] = native_image + 2;
            } else if (image_id == scenario.native_images.crops) {
                type = BUILDING_NATIVE_CROPS;
                images.items[grid_offset] = image_data_s.group_image_ids[GROUP_EDITOR_BUILDING_CROPS];
            } else if (image_data_s.group_image_ids[GROUP_EDITOR_BUILDING_NATIVE] - 4) {
                type = BUILDING_HOUSE_VACANT_LOT;
                images.items[grid_offset] = image_data_s.group_image_ids[GROUP_EDITOR_BUILDING_NATIVE] - 4;
            } else { //unknown building
                map_building_tiles_remove(0, x, y);
                continue;
            }
            struct building_t *b = building_create(type, x, y);
            b->state = BUILDING_STATE_IN_USE;
            buildings_grid.items[grid_offset] = b->id;
            if (type == BUILDING_NATIVE_MEETING) {
                buildings_grid.items[grid_offset + map_grid_delta(1, 0)] = b->id;
                buildings_grid.items[grid_offset + map_grid_delta(0, 1)] = b->id;
                buildings_grid.items[grid_offset + map_grid_delta(1, 1)] = b->id;
            }
        }
    }
    map_routing_update_all();
    city_view_init();
    state_data.paused = 0;
}

static void button_ok_cancel(int is_ok, __attribute__((unused)) int param2)
{
    if (!is_ok) {
        input_box_stop(&file_name_input);
        window_go_back();
        return;
    }
    char *filename;
    char selected_name[FILE_NAME_MAX];
    string_copy(file_dialog_data.selected_file, selected_name, FILE_NAME_MAX);
    file_remove_extension(selected_name);
    if (string_equals(selected_name, file_dialog_data.typed_name)) {
        // User has not modified the string after selecting it: use filename
        filename = file_dialog_data.selected_file;
    } else {
        // We should use the typed name
        static char typed_file[FILE_NAME_MAX];
        string_copy(file_dialog_data.typed_name, typed_file, FILE_NAME_MAX);
        file_append_extension(typed_file, file_dialog_data.file_data->extension);
        filename = typed_file;
    }
    if (file_dialog_data.type == FILE_TYPE_SAVED_GAME) {
        if (file_dialog_data.dialog_type != FILE_DIALOG_SAVE && !file_exists(SAVES_DIR_PATH, filename)) {
            file_dialog_data.message_not_exist_start_time = current_time;
            return;
        }
        if (file_dialog_data.dialog_type == FILE_DIALOG_SAVE) {
            input_box_stop(&file_name_input);
            game_file_io_write_saved_game(SAVES_DIR_PATH, filename);
            window_city_show();
        } else if (file_dialog_data.dialog_type == FILE_DIALOG_LOAD) {
            init_savegame_data();
            SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Loading saved game", filename, 0));
            static char dir_prepended_filepath[DIR_PATH_MAX];
            prepend_dir_to_path(SAVES_DIR_PATH, filename, dir_prepended_filepath);
            FILE *fp = fopen(dir_prepended_filepath, "rb");
            if (!fp) {
                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to load game", 0, 0));
                file_dialog_data.message_not_exist_start_time = current_time;
                return;
            }
            int result = 0;
            for (int i = 0; i < savegame_data.num_pieces; i++) {
                struct file_piece_t *piece = &savegame_data.pieces[i];
                result = fread(piece->buf.data, 1, piece->buf.size, fp) == (unsigned) piece->buf.size;
                // The last piece may be smaller than buf.size
                if (!result && i != (savegame_data.num_pieces - 1)) {
                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to load game", 0, 0));
                    fclose(fp);
                    file_dialog_data.message_not_exist_start_time = current_time;
                    return;
                }
            }
            fclose(fp);
            buffer_read_raw(savegame_data.state.player_name, scenario_settings.player_name, MAX_PLAYER_NAME);
            map_image_load_state(savegame_data.state.image_grid);
            for (int i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                buildings_grid.items[i] = buffer_read_u16(savegame_data.state.building_grid);
            }
            buffer_read_raw(savegame_data.state.building_damage_grid, damage_grid.items, GRID_SIZE * GRID_SIZE);
            map_terrain_load_state(savegame_data.state.terrain_grid);
            buffer_read_raw(savegame_data.state.aqueduct_grid, aqueduct.items, GRID_SIZE * GRID_SIZE);
            buffer_read_raw(savegame_data.state.aqueduct_backup_grid, aqueduct_backup.items, GRID_SIZE * GRID_SIZE);
            for (int i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                map_figures.items[i] = buffer_read_u16(savegame_data.state.figure_grid);
            }
            buffer_read_raw(savegame_data.state.sprite_grid, sprite.items, GRID_SIZE * GRID_SIZE);
            buffer_read_raw(savegame_data.state.sprite_backup_grid, sprite_backup.items, GRID_SIZE * GRID_SIZE);
            map_property_load_state(savegame_data.state.bitfields_grid, savegame_data.state.edge_grid);
            buffer_read_raw(savegame_data.state.random_grid, random.items, GRID_SIZE * GRID_SIZE);
            buffer_read_raw(savegame_data.state.desirability_grid, desirability_grid.items, GRID_SIZE * GRID_SIZE);
            for (int i = 0; i < MAX_FIGURES; i++) {
                figures[i].in_use = buffer_read_u8(savegame_data.state.figures);
                figures[i].is_targetable = buffer_read_u8(savegame_data.state.figures);
                figures[i].is_corpse = buffer_read_u8(savegame_data.state.figures);
                figures[i].type = buffer_read_u8(savegame_data.state.figures);
                figures[i].action_state = buffer_read_u8(savegame_data.state.figures);
                figures[i].is_fleeing = buffer_read_u8(savegame_data.state.figures);
                figures[i].formation_id = buffer_read_u8(savegame_data.state.figures);
                figures[i].index_in_formation = buffer_read_u8(savegame_data.state.figures);
                figures[i].damage = buffer_read_u8(savegame_data.state.figures);
                figures[i].is_military_trained = buffer_read_u8(savegame_data.state.figures);
                figures[i].mounted_charge_ticks = buffer_read_u8(savegame_data.state.figures);
                figures[i].mounted_charge_ticks_max = buffer_read_u8(savegame_data.state.figures);
                figures[i].target_figure_id = buffer_read_u16(savegame_data.state.figures);
                for (int j = 0; j < MAX_MELEE_TARGETERS_PER_UNIT; j++) {
                    figures[j].melee_targeter_ids[j] = buffer_read_u16(savegame_data.state.figures);
                }
                for (int j = 0; j < MAX_MELEE_COMBATANTS_PER_UNIT; j++) {
                    figures[j].melee_combatant_ids[j] = buffer_read_u16(savegame_data.state.figures);
                }
                figures[i].num_melee_combatants = buffer_read_u8(savegame_data.state.figures);
                for (int j = 0; j < MAX_RANGED_TARGETERS_PER_UNIT; j++) {
                    figures[j].ranged_targeter_ids[j] = buffer_read_u16(savegame_data.state.figures);
                }
                figures[i].prefect_recent_guard_duty = buffer_read_u8(savegame_data.state.figures);
                figures[i].attack_direction = buffer_read_i8(savegame_data.state.figures);
                figures[i].engaged_in_combat = buffer_read_u8(savegame_data.state.figures);
                figures[i].source_x = buffer_read_i8(savegame_data.state.figures);
                figures[i].source_y = buffer_read_i8(savegame_data.state.figures);
                figures[i].routing_path_id = buffer_read_u16(savegame_data.state.figures);
                figures[i].routing_path_current_tile = buffer_read_u16(savegame_data.state.figures);
                figures[i].routing_path_length = buffer_read_u16(savegame_data.state.figures);
                figures[i].terrain_usage = buffer_read_u8(savegame_data.state.figures);
                figures[i].speed_multiplier = buffer_read_u8(savegame_data.state.figures);
                figures[i].previous_tile_direction = buffer_read_i8(savegame_data.state.figures);
                figures[i].previous_tile_x = buffer_read_i8(savegame_data.state.figures);
                figures[i].previous_tile_y = buffer_read_i8(savegame_data.state.figures);
                figures[i].direction = buffer_read_i8(savegame_data.state.figures);
                figures[i].progress_on_tile = buffer_read_u8(savegame_data.state.figures);
                figures[i].x = buffer_read_i16(savegame_data.state.figures);
                figures[i].y = buffer_read_i16(savegame_data.state.figures);
                figures[i].grid_offset = buffer_read_u16(savegame_data.state.figures);
                figures[i].destination_x = buffer_read_i16(savegame_data.state.figures);
                figures[i].destination_y = buffer_read_i16(savegame_data.state.figures);
                figures[i].destination_grid_offset = buffer_read_u16(savegame_data.state.figures);
                figures[i].destination_building_id = buffer_read_u16(savegame_data.state.figures);
                figures[i].figure_is_halted = buffer_read_u8(savegame_data.state.figures);
                figures[i].use_cross_country = buffer_read_u8(savegame_data.state.figures);
                figures[i].cc_direction = buffer_read_u8(savegame_data.state.figures);
                figures[i].cross_country_x = buffer_read_u16(savegame_data.state.figures);
                figures[i].cross_country_y = buffer_read_u16(savegame_data.state.figures);
                figures[i].cc_delta_x = buffer_read_i16(savegame_data.state.figures);
                figures[i].cc_delta_y = buffer_read_i16(savegame_data.state.figures);
                figures[i].cc_delta_xy = buffer_read_i16(savegame_data.state.figures);
                figures[i].cc_destination_x = buffer_read_u16(savegame_data.state.figures);
                figures[i].cc_destination_y = buffer_read_u16(savegame_data.state.figures);
                figures[i].missile_offset = buffer_read_u8(savegame_data.state.figures);
                figures[i].roam_length = buffer_read_u16(savegame_data.state.figures);
                figures[i].roam_choose_destination = buffer_read_u8(savegame_data.state.figures);
                figures[i].roam_random_counter = buffer_read_u8(savegame_data.state.figures);
                figures[i].roam_turn_direction = buffer_read_i8(savegame_data.state.figures);
                figures[i].roam_ticks_until_next_turn = buffer_read_i8(savegame_data.state.figures);
                figures[i].in_building_wait_ticks = buffer_read_u8(savegame_data.state.figures);
                figures[i].height_adjusted_ticks = buffer_read_u8(savegame_data.state.figures);
                figures[i].current_height = buffer_read_u8(savegame_data.state.figures);
                figures[i].target_height = buffer_read_u8(savegame_data.state.figures);
                figures[i].next_figure_id_on_same_tile = buffer_read_u16(savegame_data.state.figures);
                figures[i].image_id = buffer_read_u16(savegame_data.state.figures);
                figures[i].image_offset = buffer_read_u8(savegame_data.state.figures);
                figures[i].attack_image_offset = buffer_read_u8(savegame_data.state.figures);
                figures[i].is_shooting = buffer_read_u8(savegame_data.state.figures);
                figures[i].cart_image_id = buffer_read_u16(savegame_data.state.figures);
                figures[i].x_offset_cart = buffer_read_i8(savegame_data.state.figures);
                figures[i].y_offset_cart = buffer_read_i8(savegame_data.state.figures);
                figures[i].enemy_image_group = buffer_read_u8(savegame_data.state.figures);
                figures[i].wait_ticks = buffer_read_i16(savegame_data.state.figures);
                figures[i].wait_ticks_missile = buffer_read_u8(savegame_data.state.figures);
                figures[i].name_id = buffer_read_u16(savegame_data.state.figures);
                figures[i].is_invisible = buffer_read_u8(savegame_data.state.figures);
                figures[i].building_id = buffer_read_u16(savegame_data.state.figures);
                figures[i].immigrant_building_id = buffer_read_u16(savegame_data.state.figures);
                figures[i].migrant_num_people = buffer_read_u8(savegame_data.state.figures);
                figures[i].min_max_seen = buffer_read_u8(savegame_data.state.figures);
                figures[i].phrase_sequence_exact = buffer_read_u8(savegame_data.state.figures);
                figures[i].phrase_id = buffer_read_i8(savegame_data.state.figures);
                figures[i].phrase_sequence_city = buffer_read_u8(savegame_data.state.figures);
                figures[i].empire_city_id = buffer_read_u8(savegame_data.state.figures);
                figures[i].resource_id = buffer_read_u8(savegame_data.state.figures);
                figures[i].collecting_item_id = buffer_read_u8(savegame_data.state.figures);
                figures[i].trader_id = buffer_read_u8(savegame_data.state.figures);
                figures[i].leading_figure_id = buffer_read_u16(savegame_data.state.figures);
                figures[i].trader_amount_bought = buffer_read_u8(savegame_data.state.figures);
                figures[i].loads_sold_or_carrying = buffer_read_u8(savegame_data.state.figures);
                figures[i].trade_ship_failed_dock_attempts = buffer_read_u8(savegame_data.state.figures);
                figures[i].flotsam_visible = buffer_read_u8(savegame_data.state.figures);
                figures[i].id = i;
            }
            for (int i = 0; i < MAX_ROUTES; i++) {
                figure_route_data.figure_ids[i] = buffer_read_i16(savegame_data.state.route_figures);
                buffer_read_raw(savegame_data.state.route_paths, figure_route_data.direction_paths[i], MAX_PATH_LENGTH);
            }
            selected_legion_formation = -1;
            for (int i = 0; i < MAX_LEGIONS; i++) {
                legion_formations[i].id = i;
                formation_load_state(savegame_data.state.legion_formations, &legion_formations[i]);
            }
            for (int i = 0; i < MAX_HERD_POINTS; i++) {
                herd_formations[i].id = i;
                formation_load_state(savegame_data.state.herd_formations, &herd_formations[i]);
            }
            for (int i = 0; i < MAX_ENEMY_FORMATIONS; i++) {
                enemy_formations[i].id = i;
                formation_load_state(savegame_data.state.enemy_formations, &enemy_formations[i]);
            }
            city_data.finance.tax_percentage = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.treasury = buffer_read_i32(savegame_data.state.city_data);
            city_data.sentiment.value = buffer_read_i32(savegame_data.state.city_data);
            city_data.health.target_value = buffer_read_i32(savegame_data.state.city_data);
            city_data.health.value = buffer_read_i32(savegame_data.state.city_data);
            city_data.health.num_hospital_workers = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.population = buffer_read_u32(savegame_data.state.city_data);
            city_data.population.population_last_year = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.school_age = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.academy_age = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.total_capacity = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.room_in_houses = buffer_read_i32(savegame_data.state.city_data);
            for (int i = 0; i < 2400; i++) {
                city_data.population.monthly.values[i] = buffer_read_i32(savegame_data.state.city_data);
            }
            city_data.population.monthly.next_index = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.monthly.count = buffer_read_i32(savegame_data.state.city_data);
            for (int i = 0; i < 100; i++) {
                city_data.population.at_age[i] = buffer_read_i16(savegame_data.state.city_data);
            }
            for (int i = 0; i < 20; i++) {
                city_data.population.at_level[i] = buffer_read_i32(savegame_data.state.city_data);
            }
            city_data.population.yearly_births = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.yearly_deaths = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.lost_removal = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.immigration_amount_per_batch = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.emigration_amount_per_batch = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.emigration_queue_size = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.immigration_queue_size = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.lost_homeless = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.last_change = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.average_per_year = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.total_all_years = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.people_in_tents_shacks = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.people_in_villas_palaces = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.total_years = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.yearly_update_requested = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.last_used_house_add = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.last_used_house_remove = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.immigrated_today = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.emigrated_today = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.refused_immigrants_today = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.percentage = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.immigration_duration = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.emigration_duration = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.newcomers = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.last_used_warehouse = buffer_read_i16(savegame_data.state.city_data);
            city_data.building.senate_x = buffer_read_u8(savegame_data.state.city_data);
            city_data.building.senate_y = buffer_read_u8(savegame_data.state.city_data);
            city_data.building.senate_grid_offset = buffer_read_i16(savegame_data.state.city_data);
            city_data.building.senate_building_id = buffer_read_i32(savegame_data.state.city_data);
            for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
                city_data.resource.space_in_warehouses[i] = buffer_read_i16(savegame_data.state.city_data);
            }
            for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
                city_data.resource.stored_in_warehouses[i] = buffer_read_u16(savegame_data.state.city_data);
            }
            for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
                city_data.resource.trade_status[i] = buffer_read_i16(savegame_data.state.city_data);
            }
            for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
                city_data.resource.export_over[i] = buffer_read_i16(savegame_data.state.city_data);
            }
            for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
                city_data.resource.mothballed[i] = buffer_read_i16(savegame_data.state.city_data);
            }
            for (int i = 0; i < FOOD_TYPES_MAX; i++) {
                city_data.resource.granary_food_stored[i] = buffer_read_i32(savegame_data.state.city_data);
            }
            for (int i = 0; i < 6; i++) {
                city_data.resource.stored_in_workshops[i] = buffer_read_i32(savegame_data.state.city_data);
            }
            for (int i = 0; i < 6; i++) {
                city_data.resource.space_in_workshops[i] = buffer_read_i32(savegame_data.state.city_data);
            }
            city_data.resource.granary_total_stored = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.food_types_available = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.food_types_eaten = buffer_read_i32(savegame_data.state.city_data);
            for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
                city_data.resource.stockpiled[i] = buffer_read_i32(savegame_data.state.city_data);
            }
            city_data.resource.food_supply_months = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.granaries.operating = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.percentage_plebs = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.working_age = buffer_read_i32(savegame_data.state.city_data);
            city_data.labor.workers_available = buffer_read_i32(savegame_data.state.city_data);
            for (int i = 0; i < 10; i++) {
                city_data.labor.categories[i].workers_needed = buffer_read_i32(savegame_data.state.city_data);
                city_data.labor.categories[i].workers_allocated = buffer_read_i32(savegame_data.state.city_data);
                city_data.labor.categories[i].total_houses_covered = buffer_read_i32(savegame_data.state.city_data);
                city_data.labor.categories[i].buildings = buffer_read_i32(savegame_data.state.city_data);
                city_data.labor.categories[i].priority = buffer_read_i32(savegame_data.state.city_data);
            }
            city_data.labor.workers_employed = buffer_read_i32(savegame_data.state.city_data);
            city_data.labor.workers_unemployed = buffer_read_i32(savegame_data.state.city_data);
            city_data.labor.unemployment_percentage = buffer_read_i32(savegame_data.state.city_data);
            city_data.labor.unemployment_percentage_for_senate = buffer_read_i32(savegame_data.state.city_data);
            city_data.labor.workers_needed = buffer_read_i32(savegame_data.state.city_data);
            city_data.labor.wages = buffer_read_i32(savegame_data.state.city_data);
            city_data.labor.wages_rome = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.wages_so_far = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.expenses.wages = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.expenses.wages = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.taxed_plebs = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.taxed_patricians = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.untaxed_plebs = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.untaxed_patricians = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.percentage_taxed_plebs = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.percentage_taxed_patricians = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.percentage_taxed_people = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.yearly.collected_plebs = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.yearly.collected_patricians = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.yearly.uncollected_plebs = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.yearly.uncollected_patricians = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.income.taxes = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.income.taxes = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.monthly.collected_plebs = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.monthly.uncollected_plebs = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.monthly.collected_patricians = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.monthly.uncollected_patricians = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.income.exports = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.income.exports = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.expenses.imports = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.expenses.imports = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.interest_so_far = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.expenses.interest = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.expenses.interest = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.expenses.sundries = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.expenses.sundries = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.expenses.construction = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.expenses.construction = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.expenses.salary = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.expenses.salary = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.salary_amount = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.salary_rank = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.salary_so_far = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.income.total = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.income.total = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.expenses.total = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.expenses.total = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.net_in_out = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.net_in_out = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.balance = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.balance = buffer_read_i32(savegame_data.state.city_data);
            city_data.trade.caravan_import_resource = buffer_read_i32(savegame_data.state.city_data);
            city_data.trade.caravan_backup_import_resource = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.culture = buffer_read_u32(savegame_data.state.city_data);
            city_data.ratings.prosperity = buffer_read_u32(savegame_data.state.city_data);
            city_data.ratings.peace = buffer_read_u32(savegame_data.state.city_data);
            city_data.ratings.favor = buffer_read_u32(savegame_data.state.city_data);
            city_data.ratings.prosperity_treasury_last_year = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.peace_num_criminals = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.peace_num_rioters = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.fountain = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.well = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.more_entertainment = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.more_education = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.education = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.requiring.school = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.requiring.library = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.barber = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.bathhouse = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.food = buffer_read_i32(savegame_data.state.city_data);
            city_data.building.hippodrome_placed = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.clinic = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.hospital = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.requiring.barber = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.requiring.bathhouse = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.requiring.clinic = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.religion = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.second_religion = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.third_religion = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.requiring.religion = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.theater_shows = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.theater_no_shows_weighted = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.amphitheater_shows = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.amphitheater_no_shows_weighted = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.colosseum_shows = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.colosseum_no_shows_weighted = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.hippodrome_shows = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.hippodrome_no_shows_weighted = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.venue_needing_shows = buffer_read_i32(savegame_data.state.city_data);
            city_data.culture.average_entertainment = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.entertainment = buffer_read_i32(savegame_data.state.city_data);
            city_data.festival.months_since_festival = buffer_read_i32(savegame_data.state.city_data);
            for (int i = 0; i < MAX_GODS; i++) {
                city_data.religion.gods[i].target_happiness = buffer_read_i8(savegame_data.state.city_data);
            }
            for (int i = 0; i < MAX_GODS; i++) {
                city_data.religion.gods[i].happiness = buffer_read_i8(savegame_data.state.city_data);
            }
            for (int i = 0; i < MAX_GODS; i++) {
                city_data.religion.gods[i].wrath_bolts = buffer_read_i8(savegame_data.state.city_data);
            }
            for (int i = 0; i < MAX_GODS; i++) {
                city_data.religion.gods[i].blessing_done = buffer_read_i8(savegame_data.state.city_data);
            }
            for (int i = 0; i < MAX_GODS; i++) {
                city_data.religion.gods[i].small_curse_done = buffer_read_i8(savegame_data.state.city_data);
            }
            for (int i = 0; i < MAX_GODS; i++) {
                city_data.religion.gods[i].months_since_festival = buffer_read_i32(savegame_data.state.city_data);
            }
            city_data.religion.least_happy_god = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.no_immigration_cause = buffer_read_i32(savegame_data.state.city_data);
            city_data.sentiment.protesters = buffer_read_i32(savegame_data.state.city_data);
            city_data.sentiment.criminals = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.health = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.religion = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.education = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.entertainment = buffer_read_i32(savegame_data.state.city_data);
            city_data.figure.rioters = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.selected = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.culture_explanation = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.prosperity_explanation = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.peace_explanation = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.favor_explanation = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.player_rank = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.personal_savings = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.income.donated = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.income.donated = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.donate_amount = buffer_read_i32(savegame_data.state.city_data);
            for (int i = 0; i < 10; i++) {
                city_data.building.working_dock_ids[i] = buffer_read_i16(savegame_data.state.city_data);
            }
            city_data.figure.animals = buffer_read_i16(savegame_data.state.city_data);
            city_data.trade.num_sea_routes = buffer_read_i16(savegame_data.state.city_data);
            city_data.trade.num_land_routes = buffer_read_i16(savegame_data.state.city_data);
            city_data.trade.sea_trade_problem_duration = buffer_read_i16(savegame_data.state.city_data);
            city_data.trade.land_trade_problem_duration = buffer_read_i16(savegame_data.state.city_data);
            city_data.building.working_docks = buffer_read_i16(savegame_data.state.city_data);
            city_data.building.senate_placed = buffer_read_i16(savegame_data.state.city_data);
            city_data.building.working_wharfs = buffer_read_i16(savegame_data.state.city_data);
            city_data.finance.stolen_this_year = buffer_read_i16(savegame_data.state.city_data);
            city_data.finance.stolen_last_year = buffer_read_i16(savegame_data.state.city_data);
            city_data.trade.docker_import_resource = buffer_read_i32(savegame_data.state.city_data);
            city_data.trade.docker_export_resource = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.debt_state = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.months_in_debt = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.cheated_money = buffer_read_i32(savegame_data.state.city_data);
            city_data.building.barracks_x = buffer_read_i8(savegame_data.state.city_data);
            city_data.building.barracks_y = buffer_read_i8(savegame_data.state.city_data);
            city_data.building.barracks_grid_offset = buffer_read_i16(savegame_data.state.city_data);
            city_data.building.barracks_building_id = buffer_read_i32(savegame_data.state.city_data);
            city_data.building.barracks_placed = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.lost_troop_request = buffer_read_i32(savegame_data.state.city_data);
            city_data.mission.has_won = buffer_read_i32(savegame_data.state.city_data);
            city_data.mission.continue_months_left = buffer_read_i32(savegame_data.state.city_data);
            city_data.mission.continue_months_chosen = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.wage_rate_paid_this_year = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.expenses.tribute = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.expenses.tribute = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.tribute_not_paid_last_year = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.tribute_not_paid_total_years = buffer_read_i32(savegame_data.state.city_data);
            city_data.festival.god = buffer_read_i8(savegame_data.state.city_data);
            city_data.festival.size = buffer_read_i8(savegame_data.state.city_data);
            city_data.festival.cost = buffer_read_i32(savegame_data.state.city_data);
            city_data.festival.months_to_go = buffer_read_i32(savegame_data.state.city_data);
            city_data.culture.average_religion = buffer_read_i32(savegame_data.state.city_data);
            city_data.culture.average_education = buffer_read_i32(savegame_data.state.city_data);
            city_data.culture.average_health = buffer_read_i32(savegame_data.state.city_data);
            city_data.culture.religion_coverage = buffer_read_i32(savegame_data.state.city_data);
            city_data.festival.first_festival_effect_months = buffer_read_i32(savegame_data.state.city_data);
            city_data.festival.second_festival_effect_months = buffer_read_i32(savegame_data.state.city_data);
            city_data.sentiment.previous_value = buffer_read_i32(savegame_data.state.city_data);
            city_data.sentiment.message_delay = buffer_read_i32(savegame_data.state.city_data);
            city_data.sentiment.low_mood_cause = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.months_since_gift = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.gift_overdose_penalty = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.gifts[GIFT_MODEST].id = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.gifts[GIFT_GENEROUS].id = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.gifts[GIFT_LAVISH].id = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.gifts[GIFT_MODEST].cost = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.gifts[GIFT_GENEROUS].cost = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.gifts[GIFT_LAVISH].cost = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.favor_salary_penalty = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.favor_ignored_request_penalty = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.favor_last_year = buffer_read_u32(savegame_data.state.city_data);
            city_data.ratings.favor_change = buffer_read_i32(savegame_data.state.city_data);
            city_data.military.native_attack_duration = buffer_read_i32(savegame_data.state.city_data);
            city_data.building.mission_post_operational = buffer_read_i32(savegame_data.state.city_data);
            city_data.building.main_native_meeting.x = buffer_read_i32(savegame_data.state.city_data);
            city_data.building.main_native_meeting.y = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.wage_rate_paid_last_year = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.food_needed_per_month = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.granaries.understaffed = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.granaries.not_operating = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.granaries.not_operating_with_food = buffer_read_i32(savegame_data.state.city_data);
            city_data.religion.venus_curse_active = buffer_read_i32(savegame_data.state.city_data);
            city_data.religion.neptune_double_trade_active = buffer_read_i32(savegame_data.state.city_data);
            city_data.religion.mars_spirit_power = buffer_read_i32(savegame_data.state.city_data);
            city_data.religion.angry_message_delay = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.food_consumed_last_month = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.food_produced_last_month = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.food_produced_this_month = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.peace_riot_cause = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.estimated_tax_income = buffer_read_i32(savegame_data.state.city_data);
            city_data.building.shipyard_boats_requested = buffer_read_i32(savegame_data.state.city_data);
            city_data.figure.enemies = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.people_in_tents = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.people_in_large_insula_and_above = buffer_read_i32(savegame_data.state.city_data);
            city_data.figure.imperial_soldiers = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.invasion.duration_day_countdown = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.invasion.warnings_given = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.invasion.days_until_invasion = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.invasion.retreat_message_shown = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.invasion.from_editor = buffer_read_i16(savegame_data.state.city_data);
            city_data.ratings.peace_destroyed_buildings = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.peace_years_of_peace = buffer_read_i32(savegame_data.state.city_data);
            city_data.distant_battle.city = buffer_read_u8(savegame_data.state.city_data);
            city_data.distant_battle.enemy_strength = buffer_read_u8(savegame_data.state.city_data);
            city_data.distant_battle.roman_strength = buffer_read_u8(savegame_data.state.city_data);
            city_data.distant_battle.months_until_battle = buffer_read_i8(savegame_data.state.city_data);
            city_data.distant_battle.roman_months_to_travel_back = buffer_read_i8(savegame_data.state.city_data);
            city_data.distant_battle.roman_months_to_travel_forth = buffer_read_i8(savegame_data.state.city_data);
            city_data.distant_battle.city_foreign_months_left = buffer_read_i8(savegame_data.state.city_data);
            city_data.building.triumphal_arches_available = buffer_read_i8(savegame_data.state.city_data);
            city_data.distant_battle.total_count = buffer_read_i8(savegame_data.state.city_data);
            city_data.distant_battle.won_count = buffer_read_i8(savegame_data.state.city_data);
            city_data.distant_battle.enemy_months_traveled = buffer_read_i8(savegame_data.state.city_data);
            city_data.distant_battle.roman_months_traveled = buffer_read_i8(savegame_data.state.city_data);
            city_data.military.total_legions = buffer_read_u8(savegame_data.state.city_data);
            city_data.sound.die_citizen = buffer_read_u8(savegame_data.state.city_data);
            city_data.sound.die_soldier = buffer_read_u8(savegame_data.state.city_data);
            city_data.building.trade_center_building_id = buffer_read_i32(savegame_data.state.city_data);
            city_data.figure.soldiers = buffer_read_i32(savegame_data.state.city_data);
            city_data.sound.hit_elephant = buffer_read_u8(savegame_data.state.city_data);
            city_data.emperor.invasion.count = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.invasion.size = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.invasion.soldiers_killed = buffer_read_i32(savegame_data.state.city_data);
            city_data.military.legionary_legions = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.highest_ever = buffer_read_u32(savegame_data.state.city_data);
            city_data.finance.estimated_wages = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.wine_types_available = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.prosperity_max = buffer_read_u32(savegame_data.state.city_data);
            for (int i = 0; i < 10; i++) {
                city_data.map.largest_road_networks[i].id = buffer_read_i32(savegame_data.state.city_data);
                city_data.map.largest_road_networks[i].size = buffer_read_i32(savegame_data.state.city_data);
            }
            city_data.houses.missing.second_wine = buffer_read_i32(savegame_data.state.city_data);
            city_data.religion.neptune_sank_ships = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.hippodrome_has_race = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.hippodrome_message_shown = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.colosseum_message_shown = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.emigration_message_shown = buffer_read_i32(savegame_data.state.city_data);
            city_data.mission.fired_message_shown = buffer_read_i32(savegame_data.state.city_data);
            city_data.mission.victory_message_shown = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.graph_order = buffer_read_i32(savegame_data.state.city_graph_order);
            for (int i = 0; i < MAX_BUILDINGS; i++) {
                all_buildings[i].state = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].size = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].house_is_merged = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].house_size = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].x = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].y = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].grid_offset = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].type = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].subtype.house_level = buffer_read_i16(savegame_data.state.buildings); // which union field we use does not matter
                all_buildings[i].road_network_id = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].created_sequence = buffer_read_u16(savegame_data.state.buildings);
                all_buildings[i].houses_covered = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].percentage_houses_covered = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].house_population = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].house_population_room = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].house_highest_population = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].road_access_x = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].road_access_y = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].figure_id = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].figure_id2 = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].immigrant_figure_id = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].figure_id4 = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].figure_spawn_delay = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].figure_roam_direction = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].has_water_access = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].prev_part_building_id = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].next_part_building_id = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].loads_stored = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].has_well_access = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].num_workers = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].labor_category = buffer_read_i8(savegame_data.state.buildings);
                all_buildings[i].output_resource_id = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].has_road_access = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].house_criminal_active = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].damage_risk = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].fire_risk = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].fire_duration = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].fire_proof = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].house_figure_generation_delay = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].house_tax_coverage = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].formation_id = buffer_read_i16(savegame_data.state.buildings);
                if (building_is_house(all_buildings[i].type)) {
                    for (int j = 0; j < INVENTORY_MAX; j++) {
                        all_buildings[j].data.house.inventory[j] = buffer_read_i16(savegame_data.state.buildings);
                    }
                    all_buildings[i].data.house.theater = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.amphitheater_actor = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.amphitheater_gladiator = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.colosseum_gladiator = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.colosseum_lion = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.hippodrome = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.school = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.library = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.academy = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.barber = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.clinic = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.bathhouse = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.hospital = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.temple_ceres = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.temple_neptune = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.temple_mercury = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.temple_mars = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.temple_venus = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.no_space_to_expand = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.num_foods = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.entertainment = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.education = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.health = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.num_gods = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.devolve_delay = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.evolve_text_id = buffer_read_u8(savegame_data.state.buildings);
                } else if (all_buildings[i].type == BUILDING_MARKET) {
                    for (int j = 0; j < INVENTORY_MAX; j++) {
                        all_buildings[j].data.market.inventory[j] = buffer_read_i16(savegame_data.state.buildings);
                    }
                    all_buildings[i].data.market.pottery_demand = buffer_read_i16(savegame_data.state.buildings);
                    all_buildings[i].data.market.furniture_demand = buffer_read_i16(savegame_data.state.buildings);
                    all_buildings[i].data.market.oil_demand = buffer_read_i16(savegame_data.state.buildings);
                    all_buildings[i].data.market.wine_demand = buffer_read_i16(savegame_data.state.buildings);
                    all_buildings[i].data.market.fetch_inventory_id = buffer_read_u8(savegame_data.state.buildings);
                } else if (all_buildings[i].type == BUILDING_GRANARY) {
                    for (int j = 0; j < RESOURCE_TYPES_MAX; j++) {
                        all_buildings[j].data.granary.resource_stored[j] = buffer_read_i16(savegame_data.state.buildings);
                    }
                } else if (all_buildings[i].type == BUILDING_DOCK) {
                    all_buildings[i].data.dock.queued_docker_id = buffer_read_i16(savegame_data.state.buildings);
                    all_buildings[i].data.dock.num_ships = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.dock.orientation = buffer_read_i8(savegame_data.state.buildings);
                    for (int j = 0; j < 3; j++) {
                        all_buildings[j].data.dock.docker_ids[j] = buffer_read_i16(savegame_data.state.buildings);
                    }
                    all_buildings[i].data.dock.trade_ship_id = buffer_read_i16(savegame_data.state.buildings);
                } else if (is_industry_type(&all_buildings[i])) {
                    all_buildings[i].data.industry.progress = buffer_read_i16(savegame_data.state.buildings);
                    all_buildings[i].data.industry.has_fish = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.industry.blessing_days_left = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.industry.orientation = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.industry.has_raw_materials = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.industry.curse_days_left = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.industry.fishing_boat_id = buffer_read_i16(savegame_data.state.buildings);
                } else {
                    all_buildings[i].data.entertainment.num_shows = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.entertainment.days1 = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.entertainment.days2 = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.entertainment.play = buffer_read_u8(savegame_data.state.buildings);
                }
                all_buildings[i].tax_income_or_storage = buffer_read_i32(savegame_data.state.buildings);
                all_buildings[i].house_days_without_food = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].ruin_has_plague = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].desirability = buffer_read_i8(savegame_data.state.buildings);
                all_buildings[i].is_deleted = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].storage_id = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].sentiment.house_happiness = buffer_read_i8(savegame_data.state.buildings); // which union field we use does not matter
                all_buildings[i].show_on_problem_overlay = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].id = i;
            }
            extra.highest_id_in_use = buffer_read_i32(savegame_data.state.building_extra_highest_id);
            extra.highest_id_ever = buffer_read_i32(savegame_data.state.building_extra_highest_id_ever);
            extra.created_sequence = buffer_read_i32(savegame_data.state.building_extra_sequence);
            extra.incorrect_houses = buffer_read_i32(savegame_data.state.building_extra_corrupt_houses);
            extra.unfixable_houses = buffer_read_i32(savegame_data.state.building_extra_corrupt_houses);
            tower_sentry_request = buffer_read_i32(savegame_data.state.building_barracks_tower_sentry);
            view_data.orientation = buffer_read_i32(savegame_data.state.city_view_orientation);
            city_view_load_scenario_state(savegame_data.state.city_view_camera);
            if (view_data.orientation >= 0 && view_data.orientation <= 6) {
                // ensure even number
                view_data.orientation = 2 * (view_data.orientation / 2);
            } else {
                view_data.orientation = 0;
            }
            time_data.tick = buffer_read_i32(savegame_data.state.game_time);
            time_data.day = buffer_read_i32(savegame_data.state.game_time);
            time_data.month = buffer_read_i32(savegame_data.state.game_time);
            time_data.year = buffer_read_i32(savegame_data.state.game_time);
            time_data.total_days = buffer_read_i32(savegame_data.state.game_time);
            random_load_state(savegame_data.state.random_iv);
            // industry
            for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
                count_data.industry[i].total = buffer_read_i32(savegame_data.state.building_count_industry);
            }
            for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
                count_data.industry[i].active = buffer_read_i32(savegame_data.state.building_count_industry);
            }
            // culture 1
            count_data.buildings[BUILDING_THEATER].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_THEATER].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_AMPHITHEATER].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_AMPHITHEATER].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_COLOSSEUM].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_COLOSSEUM].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_HIPPODROME].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_HIPPODROME].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_SCHOOL].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_SCHOOL].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_LIBRARY].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_LIBRARY].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_ACADEMY].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_ACADEMY].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_BARBER].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_BARBER].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_BATHHOUSE].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_BATHHOUSE].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_DOCTOR].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_DOCTOR].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_HOSPITAL].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_HOSPITAL].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_SMALL_TEMPLE_CERES].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_SMALL_TEMPLE_NEPTUNE].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_SMALL_TEMPLE_MERCURY].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_SMALL_TEMPLE_MARS].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_SMALL_TEMPLE_VENUS].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_LARGE_TEMPLE_CERES].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_LARGE_TEMPLE_NEPTUNE].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_LARGE_TEMPLE_MERCURY].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_LARGE_TEMPLE_MARS].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_LARGE_TEMPLE_VENUS].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_ORACLE].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            // culture 2
            count_data.buildings[BUILDING_ACTOR_COLONY].total = buffer_read_i32(savegame_data.state.building_count_culture2);
            count_data.buildings[BUILDING_ACTOR_COLONY].active = buffer_read_i32(savegame_data.state.building_count_culture2);
            count_data.buildings[BUILDING_GLADIATOR_SCHOOL].total = buffer_read_i32(savegame_data.state.building_count_culture2);
            count_data.buildings[BUILDING_GLADIATOR_SCHOOL].active = buffer_read_i32(savegame_data.state.building_count_culture2);
            count_data.buildings[BUILDING_LION_HOUSE].total = buffer_read_i32(savegame_data.state.building_count_culture2);
            count_data.buildings[BUILDING_LION_HOUSE].active = buffer_read_i32(savegame_data.state.building_count_culture2);
            count_data.buildings[BUILDING_CHARIOT_MAKER].total = buffer_read_i32(savegame_data.state.building_count_culture2);
            count_data.buildings[BUILDING_CHARIOT_MAKER].active = buffer_read_i32(savegame_data.state.building_count_culture2);
            // culture 3
            count_data.buildings[BUILDING_SMALL_TEMPLE_CERES].active = buffer_read_i32(savegame_data.state.building_count_culture3);
            count_data.buildings[BUILDING_SMALL_TEMPLE_NEPTUNE].active = buffer_read_i32(savegame_data.state.building_count_culture3);
            count_data.buildings[BUILDING_SMALL_TEMPLE_MERCURY].active = buffer_read_i32(savegame_data.state.building_count_culture3);
            count_data.buildings[BUILDING_SMALL_TEMPLE_MARS].active = buffer_read_i32(savegame_data.state.building_count_culture3);
            count_data.buildings[BUILDING_SMALL_TEMPLE_VENUS].active = buffer_read_i32(savegame_data.state.building_count_culture3);
            count_data.buildings[BUILDING_LARGE_TEMPLE_CERES].active = buffer_read_i32(savegame_data.state.building_count_culture3);
            count_data.buildings[BUILDING_LARGE_TEMPLE_NEPTUNE].active = buffer_read_i32(savegame_data.state.building_count_culture3);
            count_data.buildings[BUILDING_LARGE_TEMPLE_MERCURY].active = buffer_read_i32(savegame_data.state.building_count_culture3);
            count_data.buildings[BUILDING_LARGE_TEMPLE_MARS].active = buffer_read_i32(savegame_data.state.building_count_culture3);
            count_data.buildings[BUILDING_LARGE_TEMPLE_VENUS].active = buffer_read_i32(savegame_data.state.building_count_culture3);
            // military
            count_data.buildings[BUILDING_MILITARY_ACADEMY].total = buffer_read_i32(savegame_data.state.building_count_military);
            count_data.buildings[BUILDING_MILITARY_ACADEMY].active = buffer_read_i32(savegame_data.state.building_count_military);
            count_data.buildings[BUILDING_BARRACKS].total = buffer_read_i32(savegame_data.state.building_count_military);
            count_data.buildings[BUILDING_BARRACKS].active = buffer_read_i32(savegame_data.state.building_count_military);
            // support
            count_data.buildings[BUILDING_MARKET].total = buffer_read_i32(savegame_data.state.building_count_support);
            count_data.buildings[BUILDING_MARKET].active = buffer_read_i32(savegame_data.state.building_count_support);
            count_data.buildings[BUILDING_RESERVOIR].total = buffer_read_i32(savegame_data.state.building_count_support);
            count_data.buildings[BUILDING_RESERVOIR].active = buffer_read_i32(savegame_data.state.building_count_support);
            count_data.buildings[BUILDING_FOUNTAIN].total = buffer_read_i32(savegame_data.state.building_count_support);
            count_data.buildings[BUILDING_FOUNTAIN].active = buffer_read_i32(savegame_data.state.building_count_support);
            empire_data.scroll_x = buffer_read_i32(savegame_data.state.empire);
            empire_data.scroll_y = buffer_read_i32(savegame_data.state.empire);
            empire_object_load_state(savegame_data.state.empire_objects);
            for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
                trade_prices[i].buy = buffer_read_u16(savegame_data.state.trade_prices);
                trade_prices[i].sell = buffer_read_u16(savegame_data.state.trade_prices);
            }
            name_data.citizen_male = buffer_read_i32(savegame_data.state.figure_names);
            name_data.patrician = buffer_read_i32(savegame_data.state.figure_names);
            name_data.citizen_female = buffer_read_i32(savegame_data.state.figure_names);
            name_data.tax_collector = buffer_read_i32(savegame_data.state.figure_names);
            name_data.engineer = buffer_read_i32(savegame_data.state.figure_names);
            name_data.prefect = buffer_read_i32(savegame_data.state.figure_names);
            name_data.javelin_thrower = buffer_read_i32(savegame_data.state.figure_names);
            name_data.cavalry = buffer_read_i32(savegame_data.state.figure_names);
            name_data.legionary = buffer_read_i32(savegame_data.state.figure_names);
            name_data.actor = buffer_read_i32(savegame_data.state.figure_names);
            name_data.gladiator = buffer_read_i32(savegame_data.state.figure_names);
            name_data.lion_tamer = buffer_read_i32(savegame_data.state.figure_names);
            name_data.charioteer = buffer_read_i32(savegame_data.state.figure_names);
            name_data.barbarian = buffer_read_i32(savegame_data.state.figure_names);
            name_data.enemy_greek = buffer_read_i32(savegame_data.state.figure_names);
            name_data.enemy_egyptian = buffer_read_i32(savegame_data.state.figure_names);
            name_data.enemy_arabian = buffer_read_i32(savegame_data.state.figure_names);
            name_data.trader = buffer_read_i32(savegame_data.state.figure_names);
            name_data.ship = buffer_read_i32(savegame_data.state.figure_names);
            culture_coverage.theater = buffer_read_i32(savegame_data.state.culture_coverage);
            culture_coverage.amphitheater = buffer_read_i32(savegame_data.state.culture_coverage);
            culture_coverage.colosseum = buffer_read_i32(savegame_data.state.culture_coverage);
            culture_coverage.hippodrome = buffer_read_i32(savegame_data.state.culture_coverage);
            for (int i = GOD_CERES; i <= GOD_VENUS; i++) {
                culture_coverage.religion[i] = buffer_read_i32(savegame_data.state.culture_coverage);
            }
            culture_coverage.oracle = buffer_read_i32(savegame_data.state.culture_coverage);
            culture_coverage.school = buffer_read_i32(savegame_data.state.culture_coverage);
            culture_coverage.library = buffer_read_i32(savegame_data.state.culture_coverage);
            culture_coverage.academy = buffer_read_i32(savegame_data.state.culture_coverage);
            culture_coverage.hospital = buffer_read_i32(savegame_data.state.culture_coverage);
            scenario_load_state(savegame_data.state.scenario);
            for (int i = 0; i < MAX_MESSAGES; i++) {
                struct city_message_t *msg = &message_data.messages[i];
                msg->param1 = buffer_read_i32(savegame_data.state.messages);
                msg->year = buffer_read_i16(savegame_data.state.messages);
                msg->param2 = buffer_read_i16(savegame_data.state.messages);
                msg->message_type = buffer_read_i16(savegame_data.state.messages);
                msg->sequence = buffer_read_i16(savegame_data.state.messages);
                msg->is_read = buffer_read_u8(savegame_data.state.messages);
                msg->month = buffer_read_u8(savegame_data.state.messages);
            }

            message_data.next_message_sequence = buffer_read_i32(savegame_data.state.message_extra);
            message_data.total_messages = buffer_read_i32(savegame_data.state.message_extra);
            message_data.current_message_id = buffer_read_i32(savegame_data.state.message_extra);

            for (int i = 0; i < MAX_MESSAGE_CATEGORIES; i++) {
                message_data.message_count[i] = buffer_read_i32(savegame_data.state.message_counts);
                message_data.message_delay[i] = buffer_read_i32(savegame_data.state.message_delays);
            }
            // population
            message_data.population_shown.pop500 = buffer_read_u8(savegame_data.state.population_messages);
            message_data.population_shown.pop1000 = buffer_read_u8(savegame_data.state.population_messages);
            message_data.population_shown.pop2000 = buffer_read_u8(savegame_data.state.population_messages);
            message_data.population_shown.pop3000 = buffer_read_u8(savegame_data.state.population_messages);
            message_data.population_shown.pop5000 = buffer_read_u8(savegame_data.state.population_messages);
            message_data.population_shown.pop10000 = buffer_read_u8(savegame_data.state.population_messages);
            message_data.population_shown.pop15000 = buffer_read_u8(savegame_data.state.population_messages);
            message_data.population_shown.pop20000 = buffer_read_u8(savegame_data.state.population_messages);
            message_data.population_shown.pop25000 = buffer_read_u8(savegame_data.state.population_messages);
            for (int i = 0; i < MAX_CITY_SOUNDS_CHANNELS; i++) {
                struct city_channel_t *ch = &channels[i];
                ch->available = buffer_read_i32(savegame_data.state.city_sounds);
                ch->total_views = buffer_read_i32(savegame_data.state.city_sounds);
                ch->views_threshold = buffer_read_i32(savegame_data.state.city_sounds);
                for (int d = 0; d < 5; d++) {
                    ch->direction_views[d] = buffer_read_i32(savegame_data.state.city_sounds);
                }
                ch->channel = buffer_read_i32(savegame_data.state.city_sounds);
                ch->in_use = buffer_read_i32(savegame_data.state.city_sounds);
                ch->times_played = buffer_read_i32(savegame_data.state.city_sounds);
                ch->last_played_time = buffer_read_u32(savegame_data.state.city_sounds);
                ch->delay_millis = buffer_read_u32(savegame_data.state.city_sounds);
                ch->should_play = buffer_read_i32(savegame_data.state.city_sounds);
            }
            for (int i = 0; i < MAX_TRADERS; i++) {
                struct trader *t = &figure_trader_data.traders[i];
                t->bought_amount = buffer_read_i32(savegame_data.state.figure_traders);
                t->sold_amount = buffer_read_i32(savegame_data.state.figure_traders);
                for (int r = 0; r < RESOURCE_TYPES_MAX; r++) {
                    t->bought_resources[r] = buffer_read_u8(savegame_data.state.figure_traders);
                }
                for (int r = 0; r < RESOURCE_TYPES_MAX; r++) {
                    t->sold_resources[r] = buffer_read_u8(savegame_data.state.figure_traders);
                }
            }
            figure_trader_data.next_index = buffer_read_i32(savegame_data.state.figure_traders);
            for (int i = 0; i < MAX_SMALL; i++) {
                building_list_data.small.items[i] = buffer_read_i16(savegame_data.state.building_list_small);
            }
            for (int i = 0; i < MAX_LARGE; i++) {
                building_list_data.large.items[i] = buffer_read_i16(savegame_data.state.building_list_large);
            }
            for (int i = 0; i < MAX_BURNING; i++) {
                building_list_data.burning.items[i] = buffer_read_i16(savegame_data.state.building_list_burning);
            }
            building_list_data.burning.total = buffer_read_i32(savegame_data.state.building_list_burning_totals);
            building_list_data.burning.size = buffer_read_i32(savegame_data.state.building_list_burning_totals);



            for (int i = 0; i < MAX_STORAGES; i++) {
                storages[i].building_id = buffer_read_i32(savegame_data.state.building_storages);
                storages[i].in_use = buffer_read_u8(savegame_data.state.building_storages);
                storages[i].storage.empty_all = buffer_read_u8(savegame_data.state.building_storages);
                for (int r = 0; r < RESOURCE_TYPES_MAX; r++) {
                    storages[i].storage.resource_state[r] = buffer_read_u8(savegame_data.state.building_storages);
                }
            }
            stats.enemy_routes_calculated = buffer_read_i32(savegame_data.state.routing_counters);
            stats.total_routes_calculated = buffer_read_i32(savegame_data.state.routing_counters);
            for (int i = 0; i < MAX_BOOKMARKS; i++) {
                bookmarks[i].x = buffer_read_i32(savegame_data.state.bookmarks);
                bookmarks[i].y = buffer_read_i32(savegame_data.state.bookmarks);
            }
            scenario.empire.distant_battle_roman_travel_months = empire_object_init_distant_battle_travel_months(EMPIRE_OBJECT_ROMAN_ARMY);
            scenario.empire.distant_battle_enemy_travel_months = empire_object_init_distant_battle_travel_months(EMPIRE_OBJECT_ENEMY_ARMY);
            map_grid_init(scenario.map.width, scenario.map.height, scenario.map.grid_start, scenario.map.grid_border_size);
            city_view_init();
            map_routing_update_all();
            map_orientation_update_buildings();
            for (int i = 0; i < MAX_ROUTES; i++) {
                int figure_id = figure_route_data.figure_ids[i];
                if (figure_id > 0 && figure_id < MAX_FIGURES) {
                    struct figure_t *f = &figures[figure_id];
                    if (!figure_is_alive(f) || f->routing_path_id != i) {
                        figure_route_data.figure_ids[i] = 0;
                    }
                }
            }
            map_road_network_update();
            building_granaries_calculate_stocks();
            map_building_menu_items();
            city_message_init_problem_areas();
            initialize_city_sounds();
            building_construction_clear_type();
            undo_data.available = 0;
            game_state_reset_overlay();
            image_load_climate(scenario.climate, 0, 0);
            city_military_determine_distant_battle_city();
            for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
                for (int x = 0; x < map_data.width; x++, grid_offset++) {
                    int base_image = image_data_s.group_image_ids[GROUP_TERRAIN_GARDEN];
                    if (images.items[grid_offset] >= base_image && images.items[grid_offset] <= base_image + 6) {
                        terrain_grid.items[grid_offset] |= TERRAIN_GARDEN;
                        bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
                        aqueduct.items[grid_offset] = 0;
                    }
                }
            }
            message_data.scroll_position = 0;
            state_data.paused = 0;
            building_storage_reset_building_ids();
            update_music(1);
            input_box_stop(&file_name_input);
            window_city_show();
        } else if (file_dialog_data.dialog_type == FILE_DIALOG_DELETE) {
            SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Deleting game", filename, 0));
            static char dir_prepended_filepath[DIR_PATH_MAX];
            prepend_dir_to_path(SAVES_DIR_PATH, filename, dir_prepended_filepath);
            int result = remove(dir_prepended_filepath);
            if (result == -1) {
                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to delete game", 0, 0));
                return;
            } else {
                dir_list_files(file_dialog_data.file_data->extension);
                if (scrollbar_file_dialog.scroll_position + NUM_FILES_IN_VIEW >= file_dialog_data.file_list->num_files) {
                    --scrollbar_file_dialog.scroll_position;
                }
                if (scrollbar_file_dialog.scroll_position < 0) {
                    scrollbar_file_dialog.scroll_position = 0;
                }
            }
        }
    } else if (file_dialog_data.type == FILE_TYPE_SCENARIO) {
        if (file_dialog_data.dialog_type != FILE_DIALOG_SAVE && !file_exists(MAPS_DIR_PATH, filename)) {
            file_dialog_data.message_not_exist_start_time = current_time;
            return;
        }
        if (file_dialog_data.dialog_type == FILE_DIALOG_SAVE) {
            input_box_stop(&file_name_input);
            scenario.native_images.hut = image_data_s.group_image_ids[GROUP_EDITOR_BUILDING_NATIVE];
            scenario.native_images.meeting = image_data_s.group_image_ids[GROUP_EDITOR_BUILDING_NATIVE] + 2;
            scenario.native_images.crops = image_data_s.group_image_ids[GROUP_EDITOR_BUILDING_CROPS];
            scenario.empire.distant_battle_roman_travel_months = empire_object_init_distant_battle_travel_months(EMPIRE_OBJECT_ROMAN_ARMY);
            scenario.empire.distant_battle_enemy_travel_months = empire_object_init_distant_battle_travel_months(EMPIRE_OBJECT_ENEMY_ARMY);
            SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Saving scenario", filename, 0));
            init_scenario_data();
            map_image_save_state(scenario_data.state.graphic_ids);
            map_terrain_save_state(scenario_data.state.terrain);
            map_property_save_state(scenario_data.state.bitfields, scenario_data.state.edge);
            buffer_write_raw(scenario_data.state.random, random.items, GRID_SIZE * GRID_SIZE);
            buffer_write_i32(scenario_data.state.camera, view_data.camera.tile.x);
            buffer_write_i32(scenario_data.state.camera, view_data.camera.tile.y);
            random_save_state(scenario_data.state.random_iv);
            scenario_save_state(scenario_data.state.scenario);
            empire_object_save_state(scenario_data.state.empire_objects);
            static char dir_prepended_filepath[DIR_PATH_MAX];
            prepend_dir_to_path(MAPS_DIR_PATH, filename, dir_prepended_filepath);
            FILE *fp = fopen(dir_prepended_filepath, "wb");
            if (!fp) {
                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to save scenario", 0, 0));
                fclose(fp);
                return;
            }
            for (int i = 0; i < scenario_data.num_pieces; i++) {
                fwrite(scenario_data.pieces[i].buf.data, 1, scenario_data.pieces[i].buf.size, fp);
            }
            fclose(fp);
            show_editor_map();
        } else if (file_dialog_data.dialog_type == FILE_DIALOG_LOAD) {
            clear_map_data();
            if (game_file_io_read_scenario(MAPS_DIR_PATH, filename)) {
                map_grid_init(scenario.map.width, scenario.map.height, scenario.map.grid_start, scenario.map.grid_border_size);
                prepare_map_for_editing(0);
                input_box_stop(&file_name_input);
                show_editor_map();
            } else {
                file_dialog_data.message_not_exist_start_time = current_time;
                return;
            }
        }
    }
    play_sound_effect(SOUND_EFFECT_ICON);
    string_copy(filename, file_dialog_data.file_data->last_loaded_file, FILE_NAME_MAX - 1);
}

static struct image_button_t image_buttons_file_dialog[] = {
    {344, 335, 39, 26, IB_NORMAL, GROUP_OK_CANCEL_SCROLL_BUTTONS, 0, button_ok_cancel, button_none, 1, 0, 1, 0, 0, 0},
    {392, 335, 39, 26, IB_NORMAL, GROUP_OK_CANCEL_SCROLL_BUTTONS, 4, button_ok_cancel, button_none, 0, 0, 1, 0, 0, 0},
};

static void draw_foreground_file_dialog(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    char file[FILE_NAME_MAX];
    outer_panel_draw(128, 40, 22, 21);
    input_box_draw(&file_name_input);
    inner_panel_draw(144, 120, 20, 13);
    // title
    if (file_dialog_data.message_not_exist_start_time
        && current_time - file_dialog_data.message_not_exist_start_time < NOT_EXIST_MESSAGE_TIMEOUT) {
        lang_text_draw_centered(43, 2, 160, 50, 304, FONT_LARGE_BLACK);
    } else if (file_dialog_data.dialog_type == FILE_DIALOG_DELETE) {
        lang_text_draw_centered(43, 6, 160, 50, 304, FONT_LARGE_BLACK);
    } else {
        int text_id = file_dialog_data.dialog_type + (file_dialog_data.type == FILE_TYPE_SCENARIO ? 3 : 0);
        lang_text_draw_centered(43, text_id, 160, 50, 304, FONT_LARGE_BLACK);
    }
    lang_text_draw(43, 5, 224, 342, FONT_NORMAL_BLACK);
    for (int i = 0; i < NUM_FILES_IN_VIEW; i++) {
        if (i >= file_dialog_data.file_list->num_files) {
            break;
        }
        int font = FONT_NORMAL_GREEN;
        if (file_dialog_data.focus_button_id == i + 1) {
            font = FONT_NORMAL_WHITE;
        }
        string_copy(file_dialog_data.file_list->files[scrollbar_file_dialog.scroll_position + i], file, FILE_NAME_MAX);
        file_remove_extension(file);
        text_ellipsize(file, font, MAX_FILE_WINDOW_TEXT_WIDTH);
        text_draw(file, 160, 130 + 16 * i, font, 0);
    }
    if (file_dialog_data.file_list->file_overflow) {
        inner_panel_draw(184, 22, 15, 1);
        text_draw_centered(too_many_files_string, 184, 25, 240, FONT_NORMAL_PLAIN, COLOR_RED);
    }
    image_buttons_draw(0, 0, image_buttons_file_dialog, 2);
    scrollbar_draw(&scrollbar_file_dialog);
    set_translation(0, 0);
}

static int get_letter_width(char *str, struct font_definition_t *def, int *num_bytes)
{
    *num_bytes = 1;
    if (*str == ' ') {
        return def->space_width;
    }
    int letter_id = font_letter_id(def, str);
    if (letter_id >= 0) {
        return def->letter_spacing + image_letter(letter_id)->width;
    } else {
        return 0;
    }
}

static unsigned int text_get_max_length_for_width(char *str, int length, int font, unsigned int requested_width, int invert)
{
    struct font_definition_t *def = &font_data.font_definitions[font];
    if (!length) {
        length = string_length(str);
    }
    if (invert) {
        unsigned int maxlen = length;
        unsigned int width = 0;
        char *s = str;
        while (maxlen) {
            int num_bytes;
            width += get_letter_width(s, def, &num_bytes);
            s += num_bytes;
            maxlen -= num_bytes;
        }

        maxlen = length;
        while (maxlen && width > requested_width) {
            int num_bytes;
            width -= get_letter_width(str, def, &num_bytes);
            str += num_bytes;
            maxlen -= num_bytes;
        }
        return maxlen;
    } else {
        unsigned int maxlen = length;
        unsigned int width = 0;
        while (maxlen) {
            int num_bytes;
            width += get_letter_width(str, def, &num_bytes);
            if (width > requested_width) {
                break;
            }
            str += num_bytes;
            maxlen -= num_bytes;
        }
        return length - maxlen;
    }
}

static void set_viewport_to_start(void)
{
    keyboard_data.viewport_start = 0;
    keyboard_data.viewport_end = text_get_max_length_for_width(keyboard_data.text, keyboard_data.length, keyboard_data.font, keyboard_data.box_width, 0);
}

static void set_viewport_to_end(void)
{
    keyboard_data.viewport_end = keyboard_data.length;
    int maxlen = text_get_max_length_for_width(keyboard_data.text, keyboard_data.length, keyboard_data.font, keyboard_data.box_width, 1);
    keyboard_data.viewport_start = keyboard_data.length - maxlen;
}

static void update_viewport(int has_changed)
{
    int is_within_viewport = keyboard_data.cursor_position >= keyboard_data.viewport_start && keyboard_data.cursor_position <= keyboard_data.viewport_end;
    if (!has_changed && is_within_viewport) {
        // no update necessary
    } else if (keyboard_data.cursor_position == 0) {
        set_viewport_to_start();
    } else if (keyboard_data.cursor_position == keyboard_data.length) {
        set_viewport_to_end();
    } else {
        // first check if we can keep the viewport
        int new_start = keyboard_data.viewport_start;
        int new_end = text_get_max_length_for_width(keyboard_data.text, keyboard_data.length - new_start, keyboard_data.font, keyboard_data.box_width, 0);
        if (keyboard_data.cursor_position < new_start && keyboard_data.cursor_position >= new_end && new_start + new_end >= keyboard_data.length) {
            if (keyboard_data.cursor_position <= keyboard_data.viewport_cursor_position) {
                // move toward start
                int maxlen = text_get_max_length_for_width(
                    keyboard_data.text + keyboard_data.cursor_position,
                    keyboard_data.length - keyboard_data.cursor_position,
                    keyboard_data.font, keyboard_data.box_width, 0);
                if (keyboard_data.cursor_position + maxlen < keyboard_data.length) {
                    keyboard_data.viewport_start = keyboard_data.cursor_position;
                    keyboard_data.viewport_end = keyboard_data.cursor_position + maxlen;
                } else {
                    // all remaining text fits: set to end
                    set_viewport_to_end();
                }
            } else {
                // move toward end
                int viewport_length = keyboard_data.cursor_position + 1;
                int maxlen = text_get_max_length_for_width(
                    keyboard_data.text, viewport_length, keyboard_data.font, keyboard_data.box_width, 1);
                if (maxlen < viewport_length) {
                    keyboard_data.viewport_start = viewport_length - maxlen;
                    keyboard_data.viewport_end = viewport_length;
                } else {
                    // all remaining text fits: set to start
                    set_viewport_to_start();
                }
            }
        }
    }
    keyboard_data.viewport_cursor_position = keyboard_data.cursor_position;
}

static void button_select_file(int index, __attribute__((unused)) int param2)
{
    if (index < file_dialog_data.file_list->num_files) {
        string_copy(file_dialog_data.file_list->files[scrollbar_file_dialog.scroll_position + index], file_dialog_data.selected_file, FILE_NAME_MAX - 1);
        string_copy(file_dialog_data.selected_file, file_dialog_data.typed_name, FILE_NAME_MAX);
        file_remove_extension(file_dialog_data.typed_name);
        string_copy(file_dialog_data.typed_name, file_dialog_data.previously_seen_typed_name, FILE_NAME_MAX);
        keyboard_data.length = string_length(keyboard_data.text);
        keyboard_data.cursor_position = keyboard_data.length;
        update_viewport(1);
        file_dialog_data.message_not_exist_start_time = 0;
    }
    if (file_dialog_data.dialog_type != FILE_DIALOG_DELETE && file_dialog_data.double_click) {
        file_dialog_data.double_click = 0;
        button_ok_cancel(1, 0);
    }
}

static struct generic_button_t file_buttons_file_dialog[] = {
    {160, 128, 288, 16, button_select_file, button_none, 0, 0},
    {160, 144, 288, 16, button_select_file, button_none, 1, 0},
    {160, 160, 288, 16, button_select_file, button_none, 2, 0},
    {160, 176, 288, 16, button_select_file, button_none, 3, 0},
    {160, 192, 288, 16, button_select_file, button_none, 4, 0},
    {160, 208, 288, 16, button_select_file, button_none, 5, 0},
    {160, 224, 288, 16, button_select_file, button_none, 6, 0},
    {160, 240, 288, 16, button_select_file, button_none, 7, 0},
    {160, 256, 288, 16, button_select_file, button_none, 8, 0},
    {160, 272, 288, 16, button_select_file, button_none, 9, 0},
    {160, 288, 288, 16, button_select_file, button_none, 10, 0},
    {160, 304, 288, 16, button_select_file, button_none, 11, 0},
};

static int scrollbar_handle_mouse(struct scrollbar_type_t *scrollbar, struct mouse_t *m)
{
    if (scrollbar->max_scroll_position <= 0) {
        return 0;
    }
    current = scrollbar;
    if (m->scrolled == SCROLL_DOWN) {
        text_scroll(1, 3);
    } else if (m->scrolled == SCROLL_UP) {
        text_scroll(0, 3);
    }
    if (image_buttons_handle_mouse(m,
        scrollbar->x, scrollbar->y, &image_button_scroll_up, 1, 0)) {
        return 1;
    }
    if (image_buttons_handle_mouse(m,
        scrollbar->x, scrollbar->y + scrollbar->height - SCROLL_BUTTON_HEIGHT,
        &image_button_scroll_down, 1, 0)) {
        return 1;
    }
    if (scrollbar->max_scroll_position <= 0 || !m->left.is_down) {
        return 0;
    }
    int track_height = scrollbar->height - TOTAL_BUTTON_HEIGHT - 2 * scrollbar->dot_padding;
    if (m->x < scrollbar->x || m->x >= scrollbar->x + SCROLL_BUTTON_WIDTH) {
        return 0;
    }
    if (m->y < scrollbar->y + SCROLL_BUTTON_HEIGHT + scrollbar->dot_padding ||
        m->y > scrollbar->y + scrollbar->height - SCROLL_BUTTON_HEIGHT - scrollbar->dot_padding) {
        return 0;
    }
    int dot_offset = m->y - scrollbar->y - SCROLL_DOT_SIZE / 2 - SCROLL_BUTTON_HEIGHT;
    if (dot_offset < 0) {
        dot_offset = 0;
    }
    if (dot_offset > track_height) {
        dot_offset = track_height;
    }
    int pct_scrolled = calc_percentage(dot_offset, track_height);
    scrollbar->scroll_position = calc_adjust_with_percentage(
        scrollbar->max_scroll_position, pct_scrolled);
    scrollbar->is_dragging_scroll = 1;
    scrollbar->scroll_position_drag = dot_offset;
    if (scrollbar->scroll_position_drag < 0) {
        scrollbar->scroll_position_drag = 0;
    }
    if (scrollbar->on_scroll_callback) {
        scrollbar->on_scroll_callback();
    }
    return 1;
}

static void scrollbar_reset(struct scrollbar_type_t *scrollbar, int scroll_position)
{
    scrollbar->scroll_position = scroll_position;
    scrollbar->is_dragging_scroll = 0;
}

static void scroll_to_typed_text(void)
{
    if (file_dialog_data.file_list->num_files <= NUM_FILES_IN_VIEW) {
        // No need to scroll
        return;
    }
    int index;
    int len = string_length((char *) file_dialog_data.typed_name);
    if (!len) {
        index = -1;
    } else {
        int left = 0;
        int right = file_dialog_data.file_list->num_files;
        while (left < right) {
            int middle = (left + right) / 2;
            if (strncmp(file_dialog_data.file_list->files[middle], (char *) file_dialog_data.typed_name, len) >= 0) {
                right = middle;
            } else {
                left = middle + 1;
            }
        }
        if (strncmp(file_dialog_data.file_list->files[left], (char *) file_dialog_data.typed_name, len) == 0) {
            index = left;
        } else {
            index = -1;
        }
    }
    if (index >= 0) {
        scrollbar_reset(&scrollbar_file_dialog, calc_bound(index, 0, file_dialog_data.file_list->num_files - NUM_FILES_IN_VIEW));
    }
}

static void handle_input_file_dialog(struct mouse_t *m, struct hotkeys_t *h)
{
    file_dialog_data.double_click = m->left.double_click;
    if (keyboard_data.accepted) {
        keyboard_data.accepted = 0;
        button_ok_cancel(1, 0);
        return;
    }
    struct mouse_t *m_dialog = mouse_in_dialog(m);
    if (generic_buttons_handle_mouse(m_dialog, 0, 0, file_buttons_file_dialog, NUM_FILES_IN_VIEW, &file_dialog_data.focus_button_id) ||
        image_buttons_handle_mouse(m_dialog, 0, 0, image_buttons_file_dialog, 2, 0) ||
        scrollbar_handle_mouse(&scrollbar_file_dialog, m_dialog)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        input_box_stop(&file_name_input);
        window_go_back();
    }
    if (string_equals(file_dialog_data.previously_seen_typed_name, file_dialog_data.typed_name)) {
        return;
    } else {
        // Only scroll when adding characters to the typed name
        if (string_length(file_dialog_data.typed_name) > string_length(file_dialog_data.previously_seen_typed_name)) {
            scroll_to_typed_text();
        }
        string_copy(file_dialog_data.typed_name, file_dialog_data.previously_seen_typed_name, FILE_NAME_MAX);
    }
}

static void scrollbar_init(struct scrollbar_type_t *scrollbar, int scroll_position, int max_scroll_position)
{
    if (max_scroll_position < 0) {
        max_scroll_position = 0;
    }
    scrollbar->scroll_position = calc_bound(scroll_position, 0, max_scroll_position);
    scrollbar->max_scroll_position = max_scroll_position;
    scrollbar->is_dragging_scroll = 0;
}

static void input_box_start(struct input_box_t *box)
{
    int text_width = (box->width_blocks - 2) * BLOCK_SIZE;
    keyboard_data.capture = 1;
    keyboard_data.text = box->text;
    keyboard_data.length = string_length(box->text);
    keyboard_data.cursor_position = keyboard_data.length;
    keyboard_data.max_length = box->text_length;
    keyboard_data.allow_punctuation = box->allow_punctuation;
    keyboard_data.accepted = 0;
    keyboard_data.box_width = text_width;
    keyboard_data.font = box->font;
    update_viewport(1);
    SDL_StartTextInput();
    SDL_Rect rect = { box->x, box->y, box->width_blocks * BLOCK_SIZE, box->height_blocks * BLOCK_SIZE };
    SDL_SetTextInputRect(&rect);
    draw_cursor_input_box = 1;
}

static void window_file_dialog_show(int type, int dialog_type)
{
    struct window_type_t window = {
        WINDOW_FILE_DIALOG,
        0,
        draw_foreground_file_dialog,
        handle_input_file_dialog,
    };
    file_dialog_data.type = type;
    file_dialog_data.file_data = type == FILE_TYPE_SCENARIO ? &file_type_scenario_data : &saved_game_data;
    file_dialog_data.dialog_type = dialog_type;
    file_dialog_data.message_not_exist_start_time = 0;
    file_dialog_data.double_click = 0;
    file_dialog_data.focus_button_id = 0;
    if (string_length(file_dialog_data.file_data->last_loaded_file) > 0) {
        string_copy(file_dialog_data.file_data->last_loaded_file, file_dialog_data.typed_name, FILE_NAME_MAX);
        file_remove_extension(file_dialog_data.typed_name);
    } else if (dialog_type == FILE_DIALOG_SAVE) {
        // Suggest default filename
        string_copy(lang_get_string(9, type == FILE_TYPE_SCENARIO ? 7 : 6), file_dialog_data.typed_name, FILE_NAME_MAX);
    } else {
        // Use empty string
        file_dialog_data.typed_name[0] = 0;
    }
    string_copy(file_dialog_data.typed_name, file_dialog_data.previously_seen_typed_name, FILE_NAME_MAX);
    file_dialog_data.file_list = dir_list_files(file_dialog_data.file_data->extension);
    scrollbar_init(&scrollbar_file_dialog, 0, file_dialog_data.file_list->num_files - NUM_FILES_IN_VIEW);
    scroll_to_typed_text();
    string_copy(file_dialog_data.file_data->last_loaded_file, file_dialog_data.selected_file, FILE_NAME_MAX - 1);
    input_box_start(&file_name_input);
    window_show(&window);
}

static void top_menu_file_load_game(__attribute__((unused)) int param)
{
    clear_state_top_menu();
    building_construction_clear_type();
    window_go_back();
    window_file_dialog_show(FILE_TYPE_SAVED_GAME, FILE_DIALOG_LOAD);
}

static void top_menu_file_save_game(__attribute__((unused)) int param)
{
    clear_state_top_menu();
    window_go_back();
    window_file_dialog_show(FILE_TYPE_SAVED_GAME, FILE_DIALOG_SAVE);
}

static void top_menu_file_delete_game(__attribute__((unused)) int param)
{
    clear_state_top_menu();
    window_go_back();
    window_file_dialog_show(FILE_TYPE_SAVED_GAME, FILE_DIALOG_DELETE);
}

static void window_popup_dialog_show(int type, void (*close_func)(void), int has_ok_cancel_buttons)
{
    if (init_popup_dialog(type, 0, 0, close_func, has_ok_cancel_buttons)) {
        struct window_type_t window = {
            WINDOW_POPUP_DIALOG,
            draw_background_popup_dialog,
            draw_foreground_popup_dialog,
            handle_input_popup_dialog,
        };
        window_show(&window);
    }
}

static void window_main_menu_show(int restart_music);
static void confirm_exit_to_main_menu(void)
{
    building_construction_clear_type();
    undo_data.available = 0;
    game_state_reset_overlay();
    window_main_menu_show(1);
}

static void top_menu_file_exit_game(__attribute__((unused)) int param)
{
    clear_state_top_menu();
    window_popup_dialog_show(POPUP_DIALOG_QUIT, confirm_exit_to_main_menu, 1);
}

static struct menu_item_t top_menu_file[] = {
    {1, 2, top_menu_file_replay_map, 0, 0},
    {1, 3, top_menu_file_load_game, 0, 0},
    {1, 4, top_menu_file_save_game, 0, 0},
    {1, 6, top_menu_file_delete_game, 0, 0},
    {1, 5, top_menu_file_exit_game, 0, 0},
};

static void window_city_military_show(int legion_formation_id);
static void window_city_return(void)
{
    if (selected_legion_formation > -1) {
        window_city_military_show(selected_legion_formation);
    } else {
        window_city_show();
    }
}

static void top_menu_options_display(__attribute__((unused)) int param)
{
    clear_state_top_menu();
    window_display_options_show(window_city_return);
}

static void handle_input_sound_options(struct mouse_t *m, struct hotkeys_t *h)
{
    struct mouse_t *m_dialog = mouse_in_dialog(m);
    if (generic_buttons_handle_mouse(m_dialog, 0, 0, buttons_sound_options, 6, &sound_options_data.focus_button_id) ||
        arrow_buttons_handle_mouse(m_dialog, 208, 60, arrow_buttons_sound_options, sizeof(arrow_buttons_sound_options) / sizeof(struct arrow_button_t), 0)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        if (sound_options_data.from_editor) {
            show_editor_map();
        } else {
            window_city_return();
        }
    }
}

static void window_sound_options_show(int from_editor)
{
    struct window_type_t window = {
        WINDOW_SOUND_OPTIONS,
        window_draw_underlying_window,
        draw_foreground_sound_options,
        handle_input_sound_options,
    };
    sound_options_data.focus_button_id = 0;
    sound_options_data.from_editor = from_editor;
    window_show(&window);
}

static void top_menu_options_sound(__attribute__((unused)) int param)
{
    clear_state_top_menu();
    window_sound_options_show(0);
}

static void window_speed_options_show(int from_editor);
static void top_menu_options_speed(__attribute__((unused)) int param)
{
    clear_state_top_menu();
    window_speed_options_show(0);
}

static void menu_update_text(struct menu_bar_item_t *menu, int index, int text_number)
{
    menu->items[index].text_number = text_number;
    if (menu->calculated_width_blocks > 0) {
        int item_width = lang_text_get_width(
            menu->items[index].text_group, text_number, FONT_NORMAL_BLACK);
        int blocks = (item_width + 8) / BLOCK_SIZE + 1;
        if (blocks > menu->calculated_width_blocks) {
            menu->calculated_width_blocks = blocks;
        }
    }
}

static void top_menu_options_autosave(__attribute__((unused)) int param);
static struct menu_item_t top_menu_options[] = {
    {2, 1, top_menu_options_display, 0, 0},
    {2, 2, top_menu_options_sound, 0, 0},
    {2, 3, top_menu_options_speed, 0, 0},
    {19, 51, top_menu_options_autosave, 0, 0},
};

static void window_city_draw_all(void);
static void top_menu_help_help(__attribute__((unused)) int param)
{
    clear_state_top_menu();
    window_go_back();
    window_message_dialog_show(MESSAGE_DIALOG_HELP, window_city_draw_all);
}

static void top_menu_help_about(__attribute__((unused)) int param)
{
    clear_state_top_menu();
    window_go_back();
    window_message_dialog_show(MESSAGE_DIALOG_ABOUT, window_city_draw_all);
}

static void top_menu_help_warnings(__attribute__((unused)) int param);
static struct menu_item_t top_menu_help[] = {
    {3, 1, top_menu_help_help, 0, 0},
    {3, 5, top_menu_help_warnings, 0, 0},
    {3, 7, top_menu_help_about, 0, 0},
};

static struct menu_bar_item_t top_menu[] = {
    {1, top_menu_file, 5, 0, 0, 0, 0},
    {2, top_menu_options, 4, 0, 0, 0, 0},
    {3, top_menu_help, 3, 0, 0, 0, 0},
};

static void top_menu_options_autosave(__attribute__((unused)) int param)
{
    settings_values[SETTINGS_MONTHLY_AUTOSAVE_ENABLED] = settings_values[SETTINGS_MONTHLY_AUTOSAVE_ENABLED] ? 0 : 1;
    menu_update_text(&top_menu[INDEX_OPTIONS], 3, settings_values[SETTINGS_MONTHLY_AUTOSAVE_ENABLED] ? 51 : 52);
}

static void top_menu_help_warnings(__attribute__((unused)) int param)
{
    settings_values[SETTINGS_WARNINGS_ENABLED] = settings_values[SETTINGS_WARNINGS_ENABLED] ? 0 : 1;
    menu_update_text(&top_menu[INDEX_HELP], 1, settings_values[SETTINGS_WARNINGS_ENABLED] ? 6 : 5);
}

static void lang_text_draw_month_year_max_width(int month, int year, int x_offset, int y_offset, int box_width, int font, color_t color)
{
    int month_width = lang_text_get_width(25, month, font);
    int ad_bc_width = lang_text_get_width(20, year >= 0 ? 1 : 0, font);
    int space_width = font_data.font_definitions[font].space_width;
    int negative_padding = 0;
    // assume 3 digits in the year times 11 pixels plus letter spacing = approx 35px
    int total_width = month_width + ad_bc_width + 35 + 2 * space_width;
    if (total_width > box_width) {
        // take the overflow and divide it by two since we have two places to correct: after month, and after year
        negative_padding = (box_width - total_width) / 2;
        if (negative_padding < -2 * (space_width - 2)) {
            negative_padding = -2 * (space_width - 2);
        }
    }
    int width = negative_padding + lang_text_draw_colored(25, month, x_offset, y_offset, font, color);
    if (year >= 0) {
        width += negative_padding +
            text_draw_number_colored(year, ' ', " ", x_offset + width, y_offset, font, color);
        lang_text_draw_colored(20, 1, x_offset + width, y_offset, font, color);
    } else {
        width += negative_padding + text_draw_number_colored(-year, ' ', " ", x_offset + width, y_offset, font, color);
        lang_text_draw_colored(20, 0, x_offset + width, y_offset, font, color);
    }
}

static void widget_top_menu_draw(int force)
{
    if (!force && drawn.treasury == city_data.finance.treasury &&
        drawn.population == city_data.population.population &&
        drawn.month == time_data.month) {
        return;
    }
    int s_width = screen_data.width;
    int block_width = 24;
    int image_base = image_data_s.group_image_ids[GROUP_TOP_MENU];
    for (int i = 0; i * block_width < s_width; i++) {
        image_draw(image_base + i % 8, i * block_width, 0);
    }
    // black panels for funds/pop/time
    if (s_width < 800) {
        image_draw(image_base + 14, 336, 0);
    } else if (s_width < 1024) {
        image_draw(image_base + 14, 336, 0);
        image_draw(image_base + 14, 456, 0);
        image_draw(image_base + 14, 648, 0);
    } else {
        image_draw(image_base + 14, 480, 0);
        image_draw(image_base + 14, 624, 0);
        image_draw(image_base + 14, 840, 0);
    }
    menu_bar_draw(top_menu, sizeof(top_menu) / sizeof(struct menu_bar_item_t), s_width < 1024 ? 338 : 493);
    color_t treasure_color = COLOR_WHITE;
    if (city_data.finance.treasury < 0) {
        treasure_color = COLOR_FONT_RED;
    }
    if (s_width < 800) {
        top_menu_data.offset_funds = 338;
        top_menu_data.offset_population = 453;
        top_menu_data.offset_date = 547;
        int width = lang_text_draw_colored(6, 0, 350, 5, FONT_NORMAL_PLAIN, treasure_color);
        text_draw_number_colored(city_data.finance.treasury, '@', " ", 346 + width, 5, FONT_NORMAL_PLAIN, treasure_color);
        width = lang_text_draw(6, 1, 458, 5, FONT_NORMAL_GREEN);
        text_draw_number(city_data.population.population, '@', " ", 450 + width, 5, FONT_NORMAL_GREEN);
        lang_text_draw_month_year_max_width(time_data.month, time_data.year, 540, 5, 100, FONT_NORMAL_GREEN, 0);
    } else if (s_width < 1024) {
        top_menu_data.offset_funds = 338;
        top_menu_data.offset_population = 458;
        top_menu_data.offset_date = 652;
        int width = lang_text_draw_colored(6, 0, 350, 5, FONT_NORMAL_PLAIN, treasure_color);
        text_draw_number_colored(city_data.finance.treasury, '@', " ", 346 + width, 5, FONT_NORMAL_PLAIN, treasure_color);
        width = lang_text_draw_colored(6, 1, 470, 5, FONT_NORMAL_PLAIN, COLOR_WHITE);
        text_draw_number_colored(city_data.population.population, '@', " ", 466 + width, 5, FONT_NORMAL_PLAIN, COLOR_WHITE);
        lang_text_draw_month_year_max_width(time_data.month, time_data.year,
            655, 5, 110, FONT_NORMAL_PLAIN, COLOR_FONT_YELLOW);
    } else {
        top_menu_data.offset_funds = 493;
        top_menu_data.offset_population = 637;
        top_menu_data.offset_date = 852;
        int width = lang_text_draw_colored(6, 0, 495, 5, FONT_NORMAL_PLAIN, treasure_color);
        text_draw_number_colored(city_data.finance.treasury, '@', " ", 501 + width, 5, FONT_NORMAL_PLAIN, treasure_color);
        width = lang_text_draw_colored(6, 1, 645, 5, FONT_NORMAL_PLAIN, COLOR_WHITE);
        text_draw_number_colored(city_data.population.population, '@', " ", 651 + width, 5, FONT_NORMAL_PLAIN, COLOR_WHITE);
        lang_text_draw_month_year_max_width(time_data.month, time_data.year,
            850, 5, 110, FONT_NORMAL_PLAIN, COLOR_FONT_YELLOW);
    }
    drawn.treasury = city_data.finance.treasury;
    drawn.population = city_data.population.population;
    drawn.month = time_data.month;
}

static void window_city_draw_background(void)
{
    if (view_data.sidebar_collapsed) {
        draw_collapsed_background();
    } else {
        draw_expanded_background(screen_data.width - SIDEBAR_EXPANDED_WIDTH);
    }
    widget_top_menu_draw(1);
}

static void draw_buttons_collapsed(int x_offset);
static void draw_buttons_expanded(int x_offset);

static void draw_overlay_text(int x_offset)
{
    if (state_data.current_overlay) {
        lang_text_draw_centered(14, state_data.current_overlay, x_offset, 32, 117, FONT_NORMAL_GREEN);
    } else {
        lang_text_draw_centered(6, 4, x_offset, 32, 117, FONT_NORMAL_GREEN);
    }
}

static int update_extra_info_value(int value, int *field)
{
    if (value == *field) {
        return 0;
    } else {
        *field = value;
        return 1;
    }
}

static int update_extra_info(int is_background)
{
    int changed = 0;
    if (extra_widget_data.info_to_display & SIDEBAR_EXTRA_DISPLAY_GAME_SPEED) {
        changed |= update_extra_info_value(settings_values[SETTINGS_GAME_SPEED], &extra_widget_data.game_speed);
    }
    if (extra_widget_data.info_to_display & SIDEBAR_EXTRA_DISPLAY_UNEMPLOYMENT) {
        changed |= update_extra_info_value(city_data.labor.unemployment_percentage, &extra_widget_data.unemployment_percentage);
        changed |= update_extra_info_value(
                       city_data.labor.workers_unemployed - city_data.labor.workers_needed,
                       &extra_widget_data.unemployment_amount
        );
    }
    if (extra_widget_data.info_to_display & SIDEBAR_EXTRA_DISPLAY_RATINGS) {
        if (is_background) {
            extra_widget_data.culture.target = 0;
            extra_widget_data.prosperity.target = 0;
            extra_widget_data.peace.target = 0;
            extra_widget_data.favor.target = 0;
            extra_widget_data.population.target = 0;
            if (scenario.culture_win_criteria.enabled) {
                extra_widget_data.culture.target = scenario.culture_win_criteria.goal;
            }
            if (scenario.prosperity_win_criteria.enabled) {
                extra_widget_data.prosperity.target = scenario.prosperity_win_criteria.goal;
            }
            if (scenario.peace_win_criteria.enabled) {
                extra_widget_data.peace.target = scenario.peace_win_criteria.goal;
            }
            if (scenario.favor_win_criteria.enabled) {
                extra_widget_data.favor.target = scenario.favor_win_criteria.goal;
            }
            if (scenario.population_win_criteria.enabled) {
                extra_widget_data.population.target = scenario.population_win_criteria.goal;
            }
        }
        changed |= update_extra_info_value(city_data.ratings.culture, &extra_widget_data.culture.value);
        changed |= update_extra_info_value(city_data.ratings.prosperity, &extra_widget_data.prosperity.value);
        changed |= update_extra_info_value(city_data.ratings.peace, &extra_widget_data.peace.value);
        changed |= update_extra_info_value(city_data.ratings.favor, &extra_widget_data.favor.value);
        changed |= update_extra_info_value(city_data.population.population, &extra_widget_data.population.value);
    }
    return changed;
}

static int draw_extra_info_objective(int x_offset, int y_offset, int text_group, int text_id, struct objective_t *obj)
{
    lang_text_draw(text_group, text_id, x_offset + 11, y_offset, FONT_NORMAL_WHITE);
    int font = obj->value >= obj->target ? FONT_NORMAL_GREEN : FONT_NORMAL_RED;
    int width = text_draw_number(obj->value, '@', "", x_offset + 11, y_offset + EXTRA_INFO_LINE_SPACE, font);
    text_draw_number(obj->target, '(', ")", x_offset + 11 + width, y_offset + EXTRA_INFO_LINE_SPACE, font);
    return EXTRA_INFO_LINE_SPACE * 2;
}

static void draw_extra_info_panel(void)
{
    graphics_draw_vertical_line(extra_widget_data.x_offset, extra_widget_data.y_offset, extra_widget_data.y_offset + extra_widget_data.height, COLOR_WHITE);
    graphics_draw_vertical_line(extra_widget_data.x_offset + extra_widget_data.width - 1, extra_widget_data.y_offset,
        extra_widget_data.y_offset + extra_widget_data.height, COLOR_SIDEBAR);
    inner_panel_draw(extra_widget_data.x_offset + 1, extra_widget_data.y_offset, extra_widget_data.width / BLOCK_SIZE, extra_widget_data.height / BLOCK_SIZE);
    int y_current_line = extra_widget_data.y_offset + EXTRA_INFO_VERTICAL_PADDING;
    if (extra_widget_data.info_to_display & SIDEBAR_EXTRA_DISPLAY_GAME_SPEED) {
        y_current_line += EXTRA_INFO_VERTICAL_PADDING;
        lang_text_draw(45, 2, extra_widget_data.x_offset + 10, y_current_line, FONT_NORMAL_WHITE);
        y_current_line += EXTRA_INFO_LINE_SPACE + EXTRA_INFO_VERTICAL_PADDING;
        text_draw_percentage(extra_widget_data.game_speed, extra_widget_data.x_offset + 60, y_current_line - 2, FONT_NORMAL_GREEN);
        y_current_line += EXTRA_INFO_VERTICAL_PADDING * 3;
    }
    if (extra_widget_data.info_to_display & SIDEBAR_EXTRA_DISPLAY_UNEMPLOYMENT) {
        y_current_line += EXTRA_INFO_VERTICAL_PADDING;
        lang_text_draw(68, 148, extra_widget_data.x_offset + 10, y_current_line, FONT_NORMAL_WHITE);
        y_current_line += EXTRA_INFO_LINE_SPACE;
        int text_width = text_draw_percentage(extra_widget_data.unemployment_percentage, extra_widget_data.x_offset + 10, y_current_line, FONT_NORMAL_GREEN);
        text_draw_number(extra_widget_data.unemployment_amount, '(', ")", extra_widget_data.x_offset + 10 + text_width, y_current_line, FONT_NORMAL_GREEN);
        y_current_line += EXTRA_INFO_VERTICAL_PADDING * 3;
    }
    if (extra_widget_data.info_to_display & SIDEBAR_EXTRA_DISPLAY_RATINGS) {
        y_current_line += EXTRA_INFO_VERTICAL_PADDING;
        y_current_line += draw_extra_info_objective(extra_widget_data.x_offset, y_current_line, 53, 1, &extra_widget_data.culture);
        y_current_line += draw_extra_info_objective(extra_widget_data.x_offset, y_current_line, 53, 2, &extra_widget_data.prosperity);
        y_current_line += draw_extra_info_objective(extra_widget_data.x_offset, y_current_line, 53, 3, &extra_widget_data.peace);
        y_current_line += draw_extra_info_objective(extra_widget_data.x_offset, y_current_line, 53, 4, &extra_widget_data.favor);
        draw_extra_info_objective(extra_widget_data.x_offset, y_current_line, 4, 6, &extra_widget_data.population);
    }
}

static void setting_decrease_game_speed(void)
{
    if (settings_values[SETTINGS_GAME_SPEED] > 100) {
        settings_values[SETTINGS_GAME_SPEED] -= 100;
    } else {
        settings_values[SETTINGS_GAME_SPEED] = calc_bound(settings_values[SETTINGS_GAME_SPEED] - 10, 10, 100);
    }
}

static void setting_increase_game_speed(void)
{
    if (settings_values[SETTINGS_GAME_SPEED] >= 100) {
        if (settings_values[SETTINGS_GAME_SPEED] < 500) {
            settings_values[SETTINGS_GAME_SPEED] += 100;
        }
    } else {
        settings_values[SETTINGS_GAME_SPEED] = calc_bound(settings_values[SETTINGS_GAME_SPEED] + 10, 10, 100);
    }
}

static void button_game_speed(int is_down, __attribute__((unused)) int param2)
{
    if (is_down) {
        setting_decrease_game_speed();
    } else {
        setting_increase_game_speed();
    }
}

static struct arrow_button_t arrow_buttons_speed[] = {
    {11, 30, 17, 24, button_game_speed, 1, 0, 0, 0},
    {35, 30, 15, 24, button_game_speed, 0, 0, 0, 0},
};

static void draw_extra_info_buttons(void)
{
    if (update_extra_info(0)) {
        // Updates displayed speed % after clicking the arrows
        draw_extra_info_panel();
    }
    if (extra_widget_data.info_to_display & SIDEBAR_EXTRA_DISPLAY_GAME_SPEED) {
        arrow_buttons_draw(extra_widget_data.x_offset, extra_widget_data.y_offset, arrow_buttons_speed, 2);
    }
}

static int center_in_city(int element_width_pixels)
{
    int x, y, width, height;
    city_view_get_viewport(&x, &y, &width, &height);
    int margin = (width - element_width_pixels) / 2;
    return x + margin;
}

static void draw_number_of_messages(int x_offset);
static void show_message_popup(int message_id);
static void draw_foreground_city(void)
{
    widget_top_menu_draw(0);
    widget_city_draw();
    if (view_data.sidebar_collapsed) {
        int x_offset = screen_data.width - SIDEBAR_COLLAPSED_WIDTH;
        draw_buttons_collapsed(x_offset);
    } else {
        int x_offset = screen_data.width - SIDEBAR_EXPANDED_WIDTH;
        draw_buttons_expanded(x_offset);
        draw_overlay_text(x_offset + 4);
        widget_minimap_draw(x_offset + 8, MINIMAP_Y_OFFSET, MINIMAP_WIDTH, MINIMAP_HEIGHT, 0);
        draw_number_of_messages(x_offset);
    }
    draw_extra_info_buttons();
    if (window_data.current_window->id == WINDOW_CITY || window_data.current_window->id == WINDOW_CITY_MILITARY) {
        if (scenario.time_limit_win_criteria.enabled && !city_data.mission.has_won) {
            int remaining_months;
            if (scenario.start_year + scenario.time_limit_win_criteria.years <= time_data.year + 1) {
                remaining_months = 12 - time_data.month;
            } else {
                remaining_months = 12 - time_data.month + 12 * (scenario.start_year + scenario.time_limit_win_criteria.years - time_data.year - 1);
            }
            label_draw(1, 25, 15, 1);
            int width = lang_text_draw(6, 2, 6, 29, FONT_NORMAL_BLACK);
            text_draw_number(remaining_months, ' ', 0, 6 + width, 29, FONT_NORMAL_BLACK);
        } else if (scenario.survival_time_win_criteria.enabled && !city_data.mission.has_won) {
            int remaining_months;
            if (scenario.start_year + scenario.survival_time_win_criteria.years <= time_data.year + 1) {
                remaining_months = 12 - time_data.month;
            } else {
                remaining_months = 12 - time_data.month + 12 * (scenario.start_year + scenario.survival_time_win_criteria.years - time_data.year - 1);
            }
            label_draw(1, 25, 15, 1);
            int width = lang_text_draw(6, 3, 6, 29, FONT_NORMAL_BLACK);
            text_draw_number(remaining_months, ' ', 0, 6 + width, 29, FONT_NORMAL_BLACK);
        }
        if (state_data.paused) {
            int x_offset = center_in_city(448);
            outer_panel_draw(x_offset, 40, 28, 3);
            text_draw_centered("Game paused", x_offset, 58, 448, FONT_NORMAL_BLACK, COLOR_BLACK);
        }
    }
    if (!scroll_data.is_scrolling && !scroll_data.drag.active) {
        int size_x, size_y;
        int cost = construction_data.cost_preview;
        int has_size;
        if (!building_construction_is_updatable() || !construction_data.in_progress || (construction_data.type != BUILDING_CLEAR_LAND && !construction_data.cost_preview)) {
            has_size = 0;
        } else {
            size_x = construction_data.end.x - construction_data.start.x;
            size_y = construction_data.end.y - construction_data.start.y;
            if (size_x < 0) {
                size_x = -size_x;
            }
            if (size_y < 0) {
                size_y = -size_y;
            }
            size_x++;
            size_y++;
            has_size = 1;
        }
        if (cost && has_size) {
            set_city_clip_rectangle();
            int x, y;
            city_view_get_selected_tile_pixels(&x, &y);
            color_t color;
            if (cost <= city_data.finance.treasury) {
                // Color blind friendly
                color = scenario.climate == CLIMATE_DESERT ? COLOR_FONT_ORANGE : COLOR_FONT_ORANGE_LIGHT;
            } else {
                color = COLOR_FONT_RED;
            }
            text_draw_number_colored(cost, '@', " ", x + 58 + 1, y + 1, FONT_NORMAL_PLAIN, COLOR_BLACK);
            text_draw_number_colored(cost, '@', " ", x + 58, y, FONT_NORMAL_PLAIN, color);
            int width = -text_get_width(string_from_ascii("  "), FONT_SMALL_PLAIN);
            width += text_draw_number_colored(size_x, '@', "x", x - 15 + 1, y + 25 + 1, FONT_SMALL_PLAIN, COLOR_BLACK);
            text_draw_number_colored(size_x, '@', "x", x - 15, y + 25, FONT_SMALL_PLAIN, COLOR_FONT_YELLOW);
            text_draw_number_colored(size_y, '@', " ", x - 15 + width + 1, y + 25 + 1, FONT_SMALL_PLAIN, COLOR_BLACK);
            text_draw_number_colored(size_y, '@', " ", x - 15 + width, y + 25, FONT_SMALL_PLAIN, COLOR_FONT_YELLOW);
            graphics_reset_clip_rectangle();
        }
    }
    if (window_data.current_window->id == WINDOW_CITY) {
        if (message_data.consecutive_message_delay > 0) {
            message_data.consecutive_message_delay--;
            return;
        }
        int sequence = 0;
        for (int i = 0; i < MAX_MESSAGE_QUEUE; i++) {
            if (message_data.queue[i]) {
                sequence = message_data.queue[i];
                message_data.queue[i] = 0;
                break;
            }
        }
        if (sequence == 0) {
            return;
        }
        int message_id = -1;
        for (int i = 0; i < 999; i++) {
            if (!message_data.messages[i].message_type) {
                return;
            }
            if (message_data.messages[i].sequence == sequence) {
                message_id = i;
                break;
            }
        }
        if (message_id >= 0) {
            show_message_popup(message_id);
        }
    }
}

static int get_center_grid_offset(void)
{
    int x_center = view_data.camera.tile.x + view_data.viewport.width_tiles / 2;
    int y_center = view_data.camera.tile.y + view_data.viewport.height_tiles / 2;
    return view_to_grid_offset_lookup[x_center][y_center];
}

static void city_view_grid_offset_to_xy_view(int grid_offset, int *x_view, int *y_view)
{
    *x_view = *y_view = 0;
    for (int y = 0; y < VIEW_Y_MAX; y++) {
        for (int x = 0; x < VIEW_X_MAX; x++) {
            if (view_to_grid_offset_lookup[x][y] == grid_offset) {
                *x_view = x;
                *y_view = y;
                return;
            }
        }
    }
}

static void city_view_rotate_left(void)
{
    int center_grid_offset = get_center_grid_offset();
    view_data.orientation += 2;
    if (view_data.orientation > 6) {
        view_data.orientation = DIR_0_TOP;
    }
    calculate_lookup();
    if (center_grid_offset >= 0) {
        int x, y;
        city_view_grid_offset_to_xy_view(center_grid_offset, &x, &y);
        view_data.camera.tile.x = x - view_data.viewport.width_tiles / 2;
        view_data.camera.tile.y = y - view_data.viewport.height_tiles / 2;
    }
    check_camera_boundaries();
}

static void update_water_tile(int x, int y, int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_WATER) && !map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
        foreach_region_tile(x - 1, y - 1, x + 1, y + 1, set_water_image);
    }
}

static void map_tiles_update_all_water(void)
{
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            update_water_tile(x, y, grid_offset);
        }
    }
}

static int map_routing_wall_tile_in_radius(int x, int y, int radius, int *x_wall, int *y_wall)
{
    for (int i = 1; i <= radius; i++) {
        int wall_tile_in_radius = 0;
        int size = 1;
        int x_min, y_min, x_max, y_max;
        map_grid_get_area(x, y, size, i, &x_min, &y_min, &x_max, &y_max);
        for (int yy = y_min; yy <= y_max; yy++) {
            for (int xx = x_min; xx <= x_max; xx++) {
                if (terrain_walls.items[map_grid_offset(xx, yy)] == WALL_0_PASSABLE) {
                    *x_wall = xx;
                    *y_wall = yy;
                    wall_tile_in_radius = 1;
                    break;
                }
            }
        }
        if (wall_tile_in_radius) {
            return 1;
        }
    }
    return 0;
}

static void figure_tower_sentry_reroute(void)
{
    for (int i = 1; i < MAX_FIGURES; i++) {
        struct figure_t *f = &figures[i];
        if (f->type != FIGURE_TOWER_SENTRY || terrain_walls.items[f->grid_offset] == WALL_0_PASSABLE) {
            continue;
        }
        // tower sentry got off wall due to rotation
        int x_tile, y_tile;
        if (map_routing_wall_tile_in_radius(f->x, f->y, 2, &x_tile, &y_tile)) {
            figure_route_remove(f);
            f->progress_on_tile = 0;
            map_figure_delete(f);
            f->previous_tile_x = f->x = x_tile;
            f->previous_tile_y = f->y = y_tile;
            f->cross_country_x = 15 * x_tile;
            f->cross_country_y = 15 * y_tile;
            f->grid_offset = map_grid_offset(x_tile, y_tile);
            map_figure_add(f);
            f->action_state = FIGURE_ACTION_TOWER_SENTRY_RETURNING;
            f->destination_x = f->source_x;
            f->destination_y = f->source_y;
        } else {
            // Teleport back to tower
            map_figure_delete(f);
            struct building_t *b = &all_buildings[f->building_id];
            f->source_x = f->x = b->x;
            f->source_y = f->y = b->y;
            f->grid_offset = map_grid_offset(f->x, f->y);
            map_figure_add(f);
            f->action_state = FIGURE_ACTION_TOWER_SENTRY_AT_REST;
            figure_route_remove(f);
        }
    }
}

static void set_horse_destination(struct figure_t *f, int state)
{
    struct building_t *b = &all_buildings[f->building_id];
    int orientation = view_data.orientation;
    if (state == HORSE_CREATED) {
        map_figure_delete(f);
        if (orientation == DIR_0_TOP || orientation == DIR_6_LEFT) {
            f->destination_x = b->x + HORSE_DESTINATION_1[f->wait_ticks_missile].x;
            f->destination_y = b->y + HORSE_DESTINATION_1[f->wait_ticks_missile].y;
        } else {
            f->destination_x = b->x + HORSE_DESTINATION_2[f->wait_ticks_missile].x;
            f->destination_y = b->y + HORSE_DESTINATION_2[f->wait_ticks_missile].y;
        }
        if (f->resource_id == 1) {
            f->destination_y++;
        }
        f->x = f->destination_x;
        f->y = f->destination_y;
        f->cross_country_x = 15 * f->x;
        f->cross_country_y = 15 * f->y;
        f->grid_offset = map_grid_offset(f->x, f->y);
        map_figure_add(f);
    } else if (state == HORSE_RACING) {
        if (orientation == DIR_0_TOP || orientation == DIR_6_LEFT) {
            f->destination_x = b->x + HORSE_DESTINATION_1[f->wait_ticks_missile].x;
            f->destination_y = b->y + HORSE_DESTINATION_1[f->wait_ticks_missile].y;
        } else {
            f->destination_x = b->x + HORSE_DESTINATION_2[f->wait_ticks_missile].x;
            f->destination_y = b->y + HORSE_DESTINATION_2[f->wait_ticks_missile].y;
        }
    } else if (state == HORSE_FINISHED) {
        if (orientation == DIR_0_TOP || orientation == DIR_6_LEFT) {
            if (f->resource_id) {
                f->destination_x = b->x + 1;
                f->destination_y = b->y + 2;
            } else {
                f->destination_x = b->x + 1;
                f->destination_y = b->y + 1;
            }
        } else {
            if (f->resource_id) {
                f->destination_x = b->x + 12;
                f->destination_y = b->y + 3;
            } else {
                f->destination_x = b->x + 12;
                f->destination_y = b->y + 2;
            }
        }
    }
}

static void map_orientation_change(int counter_clockwise)
{
    undo_data.available = 0;
    int orientation = view_data.orientation;
    int grid_offset = map_data.start_offset;
    for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            int size = map_property_multi_tile_size(grid_offset);
            if (size == 1) {
                edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
                continue;
            }
            edge_grid.items[grid_offset] &= ~EDGE_LEFTMOST_TILE;
            int dx = orientation == DIR_4_BOTTOM || orientation == DIR_6_LEFT ? size - 1 : 0;
            int dy = orientation == DIR_0_TOP || orientation == DIR_6_LEFT ? size - 1 : 0;
            if ((edge_grid.items[grid_offset] & EDGE_MASK_XY) == 8 * dy + dx) {
                edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
            }
        }
    }
    map_tiles_update_all_elevation();
    map_tiles_update_all_water();
    map_tiles_update_all_earthquake();
    map_tiles_update_all_gardens();
    map_tiles_add_entry_exit_flags();
    map_tiles_update_all_empty_land();
    for (int y = 0, grid_offset2 = map_data.start_offset; y < map_data.height; y++, grid_offset2 += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset2++) {
            set_rubble_image(x, y, grid_offset2);
        }
    }
    map_tiles_update_all_roads();
    map_tiles_update_all_plazas();
    map_tiles_update_all_walls();
    map_tiles_update_all_aqueducts(0);
    map_orientation_update_buildings();
    int grid_offset3 = map_data.start_offset;
    for (int y = 0; y < map_data.height; y++, grid_offset3 += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset3++) {
            if (map_is_bridge(grid_offset3)) {
                int new_value;
                switch (sprite.items[grid_offset3]) {
                    case 1: new_value = counter_clockwise ? 2 : 4; break;
                    case 2: new_value = counter_clockwise ? 3 : 1; break;
                    case 3: new_value = counter_clockwise ? 4 : 2; break;
                    case 4: new_value = counter_clockwise ? 1 : 3; break;
                    case 5: new_value = 6; break;
                    case 6: new_value = 5; break;
                    case 7: new_value = counter_clockwise ? 8 : 10; break;
                    case 8: new_value = counter_clockwise ? 9 : 7; break;
                    case 9: new_value = counter_clockwise ? 10 : 8; break;
                    case 10: new_value = counter_clockwise ? 7 : 9; break;
                    case 11: new_value = 12; break;
                    case 12: new_value = 11; break;
                    case 13: new_value = 13; break;
                    case 14: new_value = 15; break;
                    case 15: new_value = 14; break;
                    default: new_value = sprite.items[grid_offset3];
                }
                sprite.items[grid_offset3] = new_value;
            }
        }
    }
    map_routing_update_walls();
    figure_tower_sentry_reroute();
    if (city_data.entertainment.hippodrome_has_race) {
        for (int i = 1; i < MAX_FIGURES; i++) {
            struct figure_t *f = &figures[i];
            if (figure_is_alive(f) && f->type == FIGURE_HIPPODROME_HORSES) {
                f->wait_ticks_missile = 0;
                set_horse_destination(f, HORSE_CREATED);
            }
        }
    }
}

static void game_orientation_rotate_left(void)
{
    city_view_rotate_left();
    map_orientation_change(0);
    minimap_data.refresh_requested = 1;
    city_warning_show(WARNING_ORIENTATION);
}

static void city_view_rotate_right(void)
{
    int center_grid_offset = get_center_grid_offset();

    view_data.orientation -= 2;
    if (view_data.orientation < 0) {
        view_data.orientation = DIR_6_LEFT;
    }
    calculate_lookup();
    if (center_grid_offset >= 0) {
        int x, y;
        city_view_grid_offset_to_xy_view(center_grid_offset, &x, &y);
        view_data.camera.tile.x = x - view_data.viewport.width_tiles / 2;
        view_data.camera.tile.y = y - view_data.viewport.height_tiles / 2;
    }
    check_camera_boundaries();
}

static void game_orientation_rotate_right(void)
{
    city_view_rotate_right();
    map_orientation_change(1);
    minimap_data.refresh_requested = 1;
    city_warning_show(WARNING_ORIENTATION);
}

static void callback_calc_distance(int next_offset, int dist)
{
    if (terrain_land_citizen.items[next_offset] >= CITIZEN_0_ROAD) {
        enqueue(next_offset, dist);
    }
}

static void map_routing_calculate_distances(int x, int y)
{
    ++stats.total_routes_calculated;
    route_queue(map_grid_offset(x, y), -1, callback_calc_distance);
}

static void update_legion_standard_map_location(struct formation_t *legion_formation)
{
    struct figure_t *standard = &figures[legion_formation->legion_standard__figure_id];
    map_figure_delete(standard);
    standard->grid_offset = map_grid_offset(legion_formation->standard_x, legion_formation->standard_y);
    map_figure_add(standard);
}

static void return_legion_formation_home(struct formation_t *m)
{
    map_routing_calculate_distances(m->standard_x, m->standard_y);
    m->standard_x = all_buildings[m->building_id].x + 3;
    m->standard_y = all_buildings[m->building_id].y - 1;
    update_legion_standard_map_location(m);

    for (int i = 0; i < MAX_FORMATION_FIGURES && m->figures[i]; i++) {
        struct figure_t *f = &figures[m->figures[i]];
        f->action_state = FIGURE_ACTION_SOLDIER_GOING_TO_FORT;
        figure_route_remove(f);
    }
}

static void city_message_sort_and_compact(void)
{
    for (int i = 0; i < MAX_MESSAGES; i++) {
        for (int a = 0; a < MAX_MESSAGES - 1; a++) {
            int swap = 0;
            if (message_data.messages[a].message_type) {
                if (message_data.messages[a].sequence < message_data.messages[a + 1].sequence) {
                    if (message_data.messages[a + 1].message_type) {
                        swap = 1;
                    }
                }
            } else if (message_data.messages[a + 1].message_type) {
                swap = 1;
            }
            if (swap) {
                struct city_message_t tmp_message = message_data.messages[a];
                message_data.messages[a] = message_data.messages[a + 1];
                message_data.messages[a + 1] = tmp_message;
            }
        }
    }
    message_data.total_messages = 0;
    for (int i = 0; i < MAX_MESSAGES; i++) {
        if (message_data.messages[i].message_type) {
            message_data.total_messages++;
        }
    }
}

static void city_view_go_to_grid_offset(int grid_offset)
{
    int x, y;
    city_view_grid_offset_to_xy_view(grid_offset, &x, &y);
    view_data.camera.tile.x = x - view_data.viewport.width_tiles / 2;
    view_data.camera.tile.y = y - view_data.viewport.height_tiles / 2;
    view_data.camera.tile.y &= ~1;
    check_camera_boundaries();
}

static void button_go_to_problem(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_build_menu_hide();
    uint32_t now = current_time;
    if (now - message_data.problem_last_click_time > 3000) {
        message_data.problem_index = 0;
    }
    message_data.problem_last_click_time = now;
    city_message_sort_and_compact();
    message_data.problem_count = 0;
    for (int i = 0; i < 999; i++) {
        struct city_message_t *msg = &message_data.messages[i];
        if (msg->message_type && msg->year >= time_data.year - 1) {
            struct lang_message_t *lang_msg = &lang_data.message_entries[city_message_get_text_id(msg->message_type)];
            int lang_msg_type = lang_msg->message_type;
            if (lang_msg_type == MESSAGE_TYPE_DISASTER || lang_msg_type == MESSAGE_TYPE_INVASION) {
                message_data.problem_count++;
            }
        }
    }
    if (message_data.problem_count <= 0) {
        message_data.problem_index = 0;
        window_invalidate();
        return;
    }
    if (message_data.problem_index >= message_data.problem_count) {
        message_data.problem_index = 0;
    }
    int index = 0;
    int current_year = time_data.year;
    for (int i = 0; i < 999; i++) {
        struct city_message_t *msg = &message_data.messages[i];
        if (msg->message_type && msg->year >= current_year - 1) {
            int text_id = city_message_get_text_id(msg->message_type);
            int lang_msg_type = lang_data.message_entries[text_id].message_type;
            if (lang_msg_type == MESSAGE_TYPE_DISASTER || lang_msg_type == MESSAGE_TYPE_INVASION) {
                index++;
                if (message_data.problem_index < index) {
                    message_data.problem_index++;
                    city_view_go_to_grid_offset(msg->param2);
                    window_city_show();
                }
            }
        }
    }
}

static void set_construction_building_type(int type)
{
    building_construction_cancel();
    building_construction_set_type(type);
    window_data.refresh_on_draw = 1;
}

static void city_finance_process_construction(int cost)
{
    city_data.finance.treasury -= cost;
    city_data.finance.this_year.expenses.construction += cost;
}

static void set_crop_tile(int building_id, int x, int y, int dx, int dy, int crop_image_id, int growth)
{
    int grid_offset = map_grid_offset(x + dx, y + dy);
    terrain_grid.items[grid_offset] &= ~TERRAIN_CLEARABLE;
    terrain_grid.items[grid_offset] |= TERRAIN_BUILDING;
    buildings_grid.items[grid_offset] = building_id;
    bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
    map_property_set_multi_tile_xy(grid_offset, dx, dy, 1);
    images.items[grid_offset] = crop_image_id + (growth < 4 ? growth : 4);
}

static void map_building_tiles_add_farm(int building_id, int x, int y, int crop_image_id, int progress)
{
    if (!map_grid_is_inside(x, y, 3)) {
        return;
    }
    // farmhouse
    int x_leftmost, y_leftmost;
    switch (view_data.orientation) {
        case DIR_0_TOP:
            x_leftmost = 0;
            y_leftmost = 1;
            break;
        case DIR_2_RIGHT:
            x_leftmost = 0;
            y_leftmost = 0;
            break;
        case DIR_4_BOTTOM:
            x_leftmost = 1;
            y_leftmost = 0;
            break;
        case DIR_6_LEFT:
            x_leftmost = 1;
            y_leftmost = 1;
            break;
        default:
            return;
    }
    for (int dy = 0; dy < 2; dy++) {
        for (int dx = 0; dx < 2; dx++) {
            int grid_offset = map_grid_offset(x + dx, y + dy);
            terrain_grid.items[grid_offset] &= ~TERRAIN_CLEARABLE;
            terrain_grid.items[grid_offset] |= TERRAIN_BUILDING;
            buildings_grid.items[grid_offset] = building_id;
            bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
            map_property_set_multi_tile_size(grid_offset, 2);
            images.items[grid_offset] = image_data_s.group_image_ids[GROUP_BUILDING_FARM_HOUSE];
            map_property_set_multi_tile_xy(grid_offset, dx, dy,
                dx == x_leftmost && dy == y_leftmost);
        }
    }
    // crop tile 1
    int growth = progress / 10;
    set_crop_tile(building_id, x, y, 0, 2, crop_image_id, growth);

    // crop tile 2
    growth -= 4;
    if (growth < 0) {
        growth = 0;
    }
    set_crop_tile(building_id, x, y, 1, 2, crop_image_id, growth);

    // crop tile 3
    growth -= 4;
    if (growth < 0) {
        growth = 0;
    }
    set_crop_tile(building_id, x, y, 2, 2, crop_image_id, growth);

    // crop tile 4
    growth -= 4;
    if (growth < 0) {
        growth = 0;
    }
    set_crop_tile(building_id, x, y, 2, 1, crop_image_id, growth);

    // crop tile 5
    growth -= 4;
    if (growth < 0) {
        growth = 0;
    }
    set_crop_tile(building_id, x, y, 2, 0, crop_image_id, growth);
}

static void city_resource_add_to_warehouse(int resource, int amount)
{
    city_data.resource.space_in_warehouses[resource] -= amount;
    city_data.resource.stored_in_warehouses[resource] += amount;
}

static int building_warehouse_add_resource(struct building_t *b, int resource)
{
    if (b->id <= 0) {
        return 0;
    }
    // check building itself
    int find_space = 0;
    if (b->subtype.warehouse_resource_id && b->subtype.warehouse_resource_id != resource) {
        find_space = 1;
    } else if (b->loads_stored >= 4) {
        find_space = 1;
    } else if (b->type == BUILDING_WAREHOUSE) {
        find_space = 1;
    }
    if (find_space) {
        int space_found = 0;
        struct building_t *space = building_main(b);
        for (int i = 0; i < 8; i++) {
            space = &all_buildings[space->next_part_building_id];
            if (!space->id) {
                return 0;
            }
            if (!space->subtype.warehouse_resource_id || space->subtype.warehouse_resource_id == resource) {
                if (space->loads_stored < 4) {
                    space_found = 1;
                    b = space;
                    break;
                }
            }
        }
        if (!space_found) {
            return 0;
        }
    }
    city_resource_add_to_warehouse(resource, 1);
    b->subtype.warehouse_resource_id = resource;
    b->loads_stored++;
    building_warehouse_space_set_image(b, resource);
    return 1;
}

static void set_destination__closest_building_of_type(int closest_to__building_id, int closest_building_of_type__type, struct map_point_t *closest_building_of_type__road_tile)
{
    int min_distance = 10000;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_IN_USE && b->type == closest_building_of_type__type && b->num_workers >= building_properties[closest_building_of_type__type].n_laborers) {
            struct building_t *closest_to__building = &all_buildings[closest_to__building_id];
            int dist = calc_maximum_distance(closest_to__building->x, closest_to__building->y, b->x, b->y);
            if (dist < min_distance) {
                if (map_has_road_access(b->x, b->y, b->size, closest_building_of_type__road_tile)) {
                    min_distance = dist;
                }
            }
        }
    }
}

static void building_clear_related_data(struct building_t *b)
{
    if (b->storage_id) {
        storages[b->storage_id].in_use = 0;
        b->storage_id = 0;
    }
    if (b->type == BUILDING_SENATE) {
        if (b->grid_offset == city_data.building.senate_grid_offset) {
            city_data.building.senate_grid_offset = 0;
            city_data.building.senate_x = 0;
            city_data.building.senate_y = 0;
            city_data.building.senate_placed = 0;
        }
    }
    if (b->type == BUILDING_DOCK) {
        city_data.building.working_docks--;
    }
    if (b->type == BUILDING_BARRACKS) {
        if (b->grid_offset == city_data.building.barracks_grid_offset) {
            city_data.building.barracks_grid_offset = 0;
            city_data.building.barracks_x = 0;
            city_data.building.barracks_y = 0;
            city_data.building.barracks_placed = 0;
        }
    }
    if (building_is_fort(b->type)) {
        city_data.military.total_legions--;
        struct formation_t *m = &legion_formations[b->formation_id];
        if (m->in_use) {
            for (int i = 0; i < m->num_figures; i++) {
                struct figure_t *f = &figures[m->figures[i]];
                struct map_point_t nearest_barracks_road_tile = { 0 };
                set_destination__closest_building_of_type(b->id, BUILDING_BARRACKS, &nearest_barracks_road_tile);
                figure_route_remove(f);
                if (nearest_barracks_road_tile.x) {
                    f->destination_x = nearest_barracks_road_tile.x;
                    f->destination_y = nearest_barracks_road_tile.y;
                } else {
                    f->destination_x = scenario.exit_point.x;
                    f->destination_y = scenario.exit_point.y;
                }
                f->action_state = FIGURE_ACTION_SOLDIER_RETURNING_TO_BARRACKS;
            }
            map_figure_delete(&figures[m->legion_standard__figure_id]);
            memset(&legion_formations[b->formation_id], 0, sizeof(struct formation_t));
            m->id = b->formation_id;
        }
    }
    if (b->type == BUILDING_HIPPODROME) {
        city_data.building.hippodrome_placed = 0;
    }
}

static void building_delete(struct building_t *b)
{
    building_clear_related_data(b);
    int id = b->id;
    memset(b, 0, sizeof(struct building_t));
    b->id = id;
}

static void remove_from_census(int num_people)
{
    int index = 0;
    int empty_buckets = 0;
    // remove people randomly up to age 63
    while (num_people > 0 && empty_buckets < 100) {
        int age = random_data.pool[(random_data.pool_index + index) % MAX_RANDOM] & 0x3f;
        index++;
        if (city_data.population.at_age[age] <= 0) {
            empty_buckets++;
        } else {
            city_data.population.at_age[age]--;
            num_people--;
            empty_buckets = 0;
        }
    }
    // if random didn't work: remove from age 10 and up
    empty_buckets = 0;
    int age = 10;
    while (num_people > 0 && empty_buckets < 100) {
        if (city_data.population.at_age[age] <= 0) {
            empty_buckets++;
        } else {
            city_data.population.at_age[age]--;
            num_people--;
            empty_buckets = 0;
        }
        age++;
        if (age >= 100) {
            age = 0;
        }
    }
}

static void recalculate_population(void)
{
    city_data.population.population = 0;
    for (int i = 0; i < 100; i++) {
        city_data.population.population += city_data.population.at_age[i];
    }
    if (city_data.population.population > city_data.population.highest_ever) {
        city_data.population.highest_ever = city_data.population.population;
    }
}

static void city_population_remove_home_removed(int num_people)
{
    city_data.population.lost_removal += num_people;
    remove_from_census(num_people);
    recalculate_population();
}

static void destroy_on_fire(struct building_t *b, int plagued)
{
    undo_data.available = 0;
    b->fire_risk = 0;
    b->damage_risk = 0;
    if (b->house_size && b->house_population) {
        city_population_remove_home_removed(b->house_population);
    }
    int was_tent = b->house_size && b->subtype.house_level <= HOUSE_LARGE_TENT;
    b->house_population = 0;
    b->house_size = 0;
    b->output_resource_id = 0;
    building_clear_related_data(b);

    int waterside_building = 0;
    if (b->type == BUILDING_DOCK || b->type == BUILDING_WHARF || b->type == BUILDING_SHIPYARD) {
        waterside_building = 1;
    }
    int num_tiles;
    if (b->size >= 2 && b->size <= 5) {
        num_tiles = b->size * b->size;
    } else {
        num_tiles = 0;
    }
    map_building_tiles_remove(b->id, b->x, b->y);
    if (map_terrain_is(b->grid_offset, TERRAIN_WATER)) {
        b->state = BUILDING_STATE_DELETED_BY_GAME;
    } else {
        b->type = BUILDING_BURNING_RUIN;
        b->figure_id4 = 0;
        b->tax_income_or_storage = 0;
        b->fire_duration = (b->house_figure_generation_delay & 7) + 1;
        b->fire_proof = 1;
        b->size = 1;
        b->ruin_has_plague = plagued;
        memset(&b->data, 0, 42);
        int image_id;
        if (was_tent) {
            image_id = image_data_s.group_image_ids[GROUP_TERRAIN_RUBBLE_TENT];
        } else {
            image_id = image_data_s.group_image_ids[GROUP_TERRAIN_RUBBLE_GENERAL] + 9 * (random.items[b->grid_offset] & 3);
        }
        map_building_tiles_add(b->id, b->x, b->y, 1, image_id, TERRAIN_BUILDING);
    }
    static   int x_tiles[] = {
        0, 1, 1, 0, 2, 2, 2, 1, 0, 3, 3, 3, 3, 2, 1, 0, 4, 4, 4, 4, 4, 3, 2, 1, 0, 5, 5, 5, 5, 5, 5, 4, 3, 2, 1, 0
    };
    static   int y_tiles[] = {
        0, 0, 1, 1, 0, 1, 2, 2, 2, 0, 1, 2, 3, 3, 3, 3, 0, 1, 2, 3, 4, 4, 4, 4, 4, 0, 1, 2, 3, 4, 5, 5, 5, 5, 5, 5
    };
    for (int tile = 1; tile < num_tiles; tile++) {
        int x = x_tiles[tile] + b->x;
        int y = y_tiles[tile] + b->y;
        if (map_terrain_is(map_grid_offset(x, y), TERRAIN_WATER)) {
            continue;
        }
        struct building_t *ruin = building_create(BUILDING_BURNING_RUIN, x, y);
        int image_id;
        if (was_tent) {
            image_id = image_data_s.group_image_ids[GROUP_TERRAIN_RUBBLE_TENT];
        } else {
            image_id = image_data_s.group_image_ids[GROUP_TERRAIN_RUBBLE_GENERAL] + 9 * (random.items[ruin->grid_offset] & 3);
        }
        map_building_tiles_add(ruin->id, ruin->x, ruin->y, 1, image_id, TERRAIN_BUILDING);
        ruin->fire_duration = (ruin->house_figure_generation_delay & 7) + 1;
        ruin->figure_id4 = 0;
        ruin->fire_proof = 1;
        ruin->ruin_has_plague = plagued;
    }
    if (waterside_building) {
        map_routing_update_water();
    }
}

static void building_update_state(void)
{
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_CREATED) {
            b->state = BUILDING_STATE_IN_USE;
        }
        if (b->state != BUILDING_STATE_IN_USE || !b->house_size) {
            if (b->state == BUILDING_STATE_UNDO || b->state == BUILDING_STATE_DELETED_BY_PLAYER) {
                if (b->type == BUILDING_TOWER || b->type == BUILDING_GATEHOUSE) {
                    map_tiles_update_all_walls();
                    map_tiles_update_all_roads();
                } else if (b->type == BUILDING_RESERVOIR) {
                    map_tiles_update_all_aqueducts(0);
                } else if (b->type == BUILDING_GRANARY) {
                    map_tiles_update_all_roads();
                }
                map_building_tiles_remove(i, b->x, b->y);
                map_routing_update_land();
                building_delete(b);
            } else if (b->state == BUILDING_STATE_RUBBLE) {
                if (b->house_size) {
                    city_population_remove_home_removed(b->house_population);
                }
                building_delete(b);
            } else if (b->state == BUILDING_STATE_DELETED_BY_GAME) {
                building_delete(b);
            }
        }
        if (b->type == BUILDING_TIMBER_YARD && !map_terrain_exist_multiple_tiles_in_radius_with_type(b->x, b->y, 2, 1, TERRAIN_TREE | TERRAIN_SHRUB, 3)) {
            destroy_on_fire(b, 1);
        }
    }
}

static void game_undo_perform(void)
{
    if (!undo_data.ready || !undo_data.available) {
        return;
    }
    undo_data.available = 0;
    city_finance_process_construction(-undo_data.building_cost);
    if (undo_data.type == BUILDING_CLEAR_LAND) {
        for (int i = 0; i < undo_data.num_buildings; i++) {
            if (undo_data.buildings[i].id) {
                struct building_t *b = &all_buildings[undo_data.buildings[i].id];
                memcpy(b, &undo_data.buildings[i], sizeof(struct building_t));
                if (b->type == BUILDING_WAREHOUSE || b->type == BUILDING_GRANARY) {
                    if (storages[b->storage_id].in_use) {
                        building_storage_reset_building_ids();
                    } else {
                        storages[b->storage_id].in_use = 1;
                    }
                }
                if (b->id) {
                    if (building_is_farm(b->type)) {
                        int image_offset;
                        switch (b->type) {
                            default:
                            case BUILDING_WHEAT_FARM: image_offset = 0; break;
                            case BUILDING_VEGETABLE_FARM: image_offset = 5; break;
                            case BUILDING_FRUIT_FARM: image_offset = 10; break;
                            case BUILDING_OLIVE_FARM: image_offset = 15; break;
                            case BUILDING_VINES_FARM: image_offset = 20; break;
                            case BUILDING_PIG_FARM: image_offset = 25; break;
                        }
                        map_building_tiles_add_farm(b->id, b->x, b->y, image_data_s.group_image_ids[GROUP_BUILDING_FARM_CROPS] + image_offset, 0);
                    } else {
                        int size = b->size;
                        if (building_is_house(b->type) && b->house_is_merged) {
                            size = 2;
                        }
                        map_building_tiles_add(b->id, b->x, b->y, size, 0, 0);
                        if (b->type == BUILDING_WHARF) {
                            b->data.industry.fishing_boat_id = 0;
                        }
                    }
                    b->state = BUILDING_STATE_IN_USE;
                }
            }
        }
        memcpy(terrain_grid.items, terrain_grid_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
        memcpy(aqueduct.items, aqueduct_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
        memcpy(sprite.items, sprite_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
        memcpy(images.items, images_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
        map_property_restore();
        map_property_clear_constructing_and_deleted();
    } else if (undo_data.type == BUILDING_AQUEDUCT || undo_data.type == BUILDING_ROAD ||
            undo_data.type == BUILDING_WALL) {
        memcpy(terrain_grid.items, terrain_grid_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
        memcpy(aqueduct.items, aqueduct_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
        restore_map_images();
    } else if (undo_data.type == BUILDING_LOW_BRIDGE || undo_data.type == BUILDING_SHIP_BRIDGE) {
        memcpy(terrain_grid.items, terrain_grid_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
        memcpy(sprite.items, sprite_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
        restore_map_images();
    } else if (undo_data.type == BUILDING_PLAZA || undo_data.type == BUILDING_GARDENS) {
        memcpy(terrain_grid.items, terrain_grid_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
        memcpy(aqueduct.items, aqueduct_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
        map_property_restore();
        restore_map_images();
    } else if (undo_data.num_buildings) {
        for (int i = 0; i < undo_data.num_buildings; i++) {
            if (undo_data.buildings[i].id) {
                struct building_t *b = &all_buildings[undo_data.buildings[i].id];
                if (b->type == BUILDING_ORACLE || (b->type >= BUILDING_LARGE_TEMPLE_CERES && b->type <= BUILDING_LARGE_TEMPLE_VENUS)) {
                    int building_id = city_data.resource.last_used_warehouse;
                    for (int j = 1; j < MAX_BUILDINGS; j++) {
                        building_id++;
                        if (building_id >= MAX_BUILDINGS) {
                            building_id = 1;
                        }
                        struct building_t *bb = &all_buildings[building_id];
                        if (bb->state == BUILDING_STATE_IN_USE && bb->type == BUILDING_WAREHOUSE) {
                            city_data.resource.last_used_warehouse = building_id;
                            building_warehouse_add_resource(b, RESOURCE_MARBLE);
                            building_warehouse_add_resource(b, RESOURCE_MARBLE);
                            break;
                        }
                    }
                }
                b->state = BUILDING_STATE_UNDO;
                building_update_state();
            }
        }
    }
    map_routing_update_land();
    map_routing_update_walls();
    undo_data.num_buildings = 0;
}

static void game_state_set_overlay(int overlay)
{
    if (overlay == OVERLAY_NONE) {
        state_data.previous_overlay = state_data.current_overlay;
    } else {
        state_data.previous_overlay = OVERLAY_NONE;
    }
    state_data.current_overlay = overlay;
}

static void city_message_post(int use_popup, int message_type, int param1, int param2)
{
    for (int i = 0; i < MAX_MESSAGES; i++) {
        if (!message_data.messages[i].message_type) {
            message_data.current_message_id = i;
            break;
        }
    }
    if (message_data.current_message_id < 0) {
        return;
    }
    message_data.total_messages++;
    message_data.messages[message_data.current_message_id].message_type = message_type;
    message_data.messages[message_data.current_message_id].is_read = 0;
    message_data.messages[message_data.current_message_id].year = time_data.year;
    message_data.messages[message_data.current_message_id].month = time_data.month;
    message_data.messages[message_data.current_message_id].param1 = param1;
    message_data.messages[message_data.current_message_id].param2 = param2;
    message_data.messages[message_data.current_message_id].sequence = message_data.next_message_sequence++;
    int text_id = city_message_get_text_id(message_type);
    int lang_msg_type = lang_data.message_entries[text_id].message_type;
    if (lang_msg_type == MESSAGE_TYPE_DISASTER || lang_msg_type == MESSAGE_TYPE_INVASION) {
        message_data.problem_count = 1;
        window_invalidate();
    }
    if (use_popup && window_data.current_window->id == WINDOW_CITY) {
        show_message_popup(message_data.current_message_id);
    } else if (use_popup) {
        // add to queue to be processed when player returns to city
        for (int i = 0; i < MAX_MESSAGE_QUEUE; i++) {
            if (!message_data.queue[i]) {
                message_data.queue[i] = message_data.messages[message_data.current_message_id].sequence;
                break;
            }
        }
    } else if (should_play_sound) {
        play_sound(text_id);
    }
    should_play_sound = 1;
}

static void map_building_tiles_set_rubble(int building_id, int x, int y, int size)
{
    if (!map_grid_is_inside(x, y, size)) {
        return;
    }
    struct building_t *b = &all_buildings[building_id];
    for (int dy = 0; dy < size; dy++) {
        for (int dx = 0; dx < size; dx++) {
            int grid_offset = map_grid_offset(x + dx, y + dy);
            if (map_building_at(grid_offset) != building_id) {
                continue;
            }
            if (building_id && all_buildings[map_building_at(grid_offset)].type != BUILDING_BURNING_RUIN) {
                rubble_type_grid.items[grid_offset] = b->type;
            } else if (!building_id && terrain_grid.items[grid_offset] & TERRAIN_WALL) {
                rubble_type_grid.items[grid_offset] = BUILDING_WALL;
            }
            bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
            map_property_set_multi_tile_size(grid_offset, 1);
            aqueduct.items[grid_offset] = 0;
            buildings_grid.items[grid_offset] = 0;
            damage_grid.items[grid_offset] = 0;
            map_sprite_clear_tile(grid_offset);
            map_property_set_multi_tile_xy(grid_offset, 0, 0, 1);
            if (map_terrain_is(grid_offset, TERRAIN_WATER)) {
                terrain_grid.items[grid_offset] = TERRAIN_WATER; // clear other flags
                map_tiles_set_water(x + dx, y + dy);
            } else {
                terrain_grid.items[grid_offset] &= ~TERRAIN_CLEARABLE;
                terrain_grid.items[grid_offset] |= TERRAIN_RUBBLE;
                images.items[grid_offset] = image_data_s.group_image_ids[GROUP_TERRAIN_RUBBLE] + (random.items[grid_offset] & 7);
            }
        }
    }
}

static void figure_create_explosion_cloud(int x, int y, int size)
{
    int tile_offset = CLOUD_TILE_OFFSETS[size];
    int cc_offset = CLOUD_CC_OFFSETS[size];
    for (int i = 0; i < 16; i++) {
        struct figure_t *f = figure_create(FIGURE_EXPLOSION,
            x + tile_offset, y + tile_offset, DIR_0_TOP);
        if (f->id) {
            f->cross_country_x += cc_offset;
            f->cross_country_y += cc_offset;
            f->destination_x += CLOUD_DIRECTION[i].x;
            f->destination_y += CLOUD_DIRECTION[i].y;
            figure_movement_set_cross_country_direction(f,
                f->cross_country_x, f->cross_country_y,
                15 * f->destination_x + cc_offset,
                15 * f->destination_y + cc_offset, 0);
            f->speed_multiplier = CLOUD_SPEED[i];
        }
    }
}

static void destroy_linked_parts(struct building_t *b, int on_fire)
{
    struct building_t *part = b;
    for (int i = 0; i < 9; i++) {
        if (part->prev_part_building_id <= 0) {
            break;
        }
        int part_id = part->prev_part_building_id;
        part = &all_buildings[part_id];
        if (on_fire) {
            destroy_on_fire(part, 0);
        } else {
            map_building_tiles_set_rubble(part_id, part->x, part->y, part->size);
            part->state = BUILDING_STATE_RUBBLE;
        }
    }
    part = b;
    for (int i = 0; i < 9; i++) {
        part = &all_buildings[part->next_part_building_id];
        if (part->id <= 0) {
            break;
        }
        if (on_fire) {
            destroy_on_fire(part, 0);
        } else {
            map_building_tiles_set_rubble(part->id, part->x, part->y, part->size);
            part->state = BUILDING_STATE_RUBBLE;
        }
    }
    // Unlink the buildings to prevent corrupting the building table
    part = building_main(b);
    for (int i = 0; i < 9 && part->id > 0; i++) {
        struct building_t *next_part = &all_buildings[part->next_part_building_id];
        part->next_part_building_id = 0;
        part->prev_part_building_id = 0;
        part = next_part;
    }
}

static void building_destroy_by_collapse(struct building_t *b)
{
    b->state = BUILDING_STATE_RUBBLE;
    map_building_tiles_set_rubble(b->id, b->x, b->y, b->size);
    figure_create_explosion_cloud(b->x, b->y, b->size);
    destroy_linked_parts(b, 0);
    play_sound_effect(SOUND_EFFECT_EXPLOSION);
}

static void building_destroy_by_enemy(int x, int y, int grid_offset)
{
    int building_id = map_building_at(grid_offset);
    if (building_id > 0) {
        struct building_t *b = &all_buildings[building_id];
        if (b->state == BUILDING_STATE_IN_USE) {
            switch (b->type) {
                case BUILDING_HOUSE_SMALL_TENT:
                case BUILDING_HOUSE_LARGE_TENT:
                case BUILDING_PREFECTURE:
                case BUILDING_ENGINEERS_POST:
                case BUILDING_WELL:
                case BUILDING_GATEHOUSE:
                case BUILDING_TOWER:
                    break;
                default:
                    city_data.ratings.peace_destroyed_buildings++;
                    break;
            }
            if (city_data.ratings.peace_destroyed_buildings >= 12) {
                city_data.ratings.peace_destroyed_buildings = 12;
            }
            building_destroy_by_collapse(b);
        }
    } else {
        if (map_terrain_is(grid_offset, TERRAIN_WALL)) {
            for (int i = 0; i < MAX_FIGURES; i++) {
                struct figure_t *f = &figures[i];
                if (figure_is_alive(f) && f->type == FIGURE_TOWER_SENTRY) {
                    if (calc_maximum_distance(f->x, f->y, x, y) <= 1) {
                        figure_delete(f);
                    }
                }
            }
        }
        map_building_tiles_set_rubble(0, x, y, 1);
    }
    figure_tower_sentry_reroute();
    foreach_region_tile(x - 1, y - 1, x + 3 - 2, y + 3 - 2, set_wall_image);
    foreach_region_tile(x - 3, y - 3, x + 3, y + 3, update_aqueduct_tile);
    map_routing_update_land();
    map_routing_update_walls();
}

static int terrain_at_offset_clear(int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_SHRUB | TERRAIN_ROCK | TERRAIN_TREE | TERRAIN_ELEVATION)
    || (map_terrain_is(grid_offset, TERRAIN_WATER) && !map_terrain_is(grid_offset, TERRAIN_ROAD))) {
        return 0;
    } else {
        if (map_terrain_is(grid_offset, TERRAIN_BUILDING | TERRAIN_AQUEDUCT | TERRAIN_GATEHOUSE | TERRAIN_WALL)) {
            building_destroy_by_enemy(map_grid_offset_to_x(grid_offset), map_grid_offset_to_y(grid_offset), grid_offset);
        }
        return 1;
    }
}

static int find_closest_clear_x_offset(int x, int y)
{
    for (int j = x; j < scenario.map.width; j++) {
        int grid_offset = map_grid_offset(j, y);
        if (terrain_at_offset_clear(grid_offset)) {
            return j;
        } else {
            continue;
        }
    }
    for (int j = x; j < scenario.map.width; j--) {
        int grid_offset = map_grid_offset(j, y);
        if (terrain_at_offset_clear(grid_offset)) {
            return j;
        } else {
            continue;
        }
    }
    return -1;
}

static void create_enemy_formation(int figure_type, int enemy_type, int x, int y, int figures_amount_to_spawn, int orientation, int formation_index, int enemy_attack_priority)
{
    for (int i = 0; i < MAX_ENEMY_FORMATIONS; i++) {
        if (!enemy_formations[i].in_use) {
            struct formation_t *m = &enemy_formations[i];
            m->in_use = 1;
            m->figure_type = figure_type;
            m->layout = ENEMY_PROPERTIES[enemy_type].formation_layout;
            if (ENEMY_PROPERTIES[enemy_type].formation_layout == FORMATION_DOUBLE_LINE_1) {
                if (orientation == DIR_2_RIGHT || orientation == DIR_6_LEFT) {
                    m->layout = FORMATION_DOUBLE_LINE_2;
                }
            }
            m->max_figures = figures_amount_to_spawn;
            m->attack_priority = enemy_attack_priority;
            switch (enemy_type) {
                case ENEMY_TYPE_BARBARIAN:
                case ENEMY_TYPE_BRITON:
                case ENEMY_TYPE_CELT:
                case ENEMY_TYPE_PICT:
                case ENEMY_TYPE_GAUL:
                case ENEMY_TYPE_HELVETIUS:
                case ENEMY_TYPE_HUN:
                case ENEMY_TYPE_GOTH:
                case ENEMY_TYPE_VISIGOTH:
                case ENEMY_TYPE_NUMIDIAN:
                    m->max_morale = 80;
                    break;
                case ENEMY_TYPE_CARTHAGINIAN:
                case ENEMY_TYPE_GREEK:
                case ENEMY_TYPE_MACEDONIAN:
                    m->max_morale = 90;
                    break;
                case ENEMY_TYPE_PERGAMUM:
                case ENEMY_TYPE_IBERIAN:
                case ENEMY_TYPE_JUDEAN:
                case ENEMY_TYPE_SELEUCID:
                case ENEMY_TYPE_EGYPTIAN:
                case ENEMY_TYPE_ETRUSCAN:
                case ENEMY_TYPE_SAMNITE:
                    m->max_morale = 70;
                    break;
                case ENEMY_TYPE_CAESAR:
                    m->max_morale = 100;
                    break;
            }
            m->morale = m->max_morale;
            if (orientation == DIR_0_TOP) {
                if (formation_index % 2) {
                    m->destination_x = x;
                    m->destination_y = y - LAYOUT_OFFSETS_FROM_MAP_EDGE[m->layout][1];
                } else {
                    m->destination_x = x;
                    m->destination_y = y - LAYOUT_OFFSETS_FROM_MAP_EDGE[m->layout][0];
                }
            } else if (orientation == DIR_4_BOTTOM) {
                if (formation_index % 2) {
                    m->destination_x = x;
                    m->destination_y = y + LAYOUT_OFFSETS_FROM_MAP_EDGE[m->layout][1];
                } else {
                    m->destination_x = x;
                    m->destination_y = y + LAYOUT_OFFSETS_FROM_MAP_EDGE[m->layout][0];
                }
            } else if (orientation == DIR_2_RIGHT) {
                if (formation_index % 2) {
                    m->destination_x = x + LAYOUT_OFFSETS_FROM_MAP_EDGE[m->layout][1];
                    m->destination_y = y;
                } else {
                    m->destination_x = x + LAYOUT_OFFSETS_FROM_MAP_EDGE[m->layout][0];
                    m->destination_y = y;
                }
            } else if (orientation == DIR_6_LEFT) {
                if (formation_index % 2) {
                    m->destination_x = x - LAYOUT_OFFSETS_FROM_MAP_EDGE[m->layout][1];
                    m->destination_y = y;
                } else {
                    m->destination_x = x - LAYOUT_OFFSETS_FROM_MAP_EDGE[m->layout][0];
                    m->destination_y = y;
                }
            }

            for (int fig = 0; fig < figures_amount_to_spawn; fig++) {
                struct figure_t *f = figure_create(figure_type, x, y, orientation);
                f->is_targetable = 1;
                f->action_state = FIGURE_ACTION_ENEMY_SPAWNING;
                f->formation_id = m->id;
                f->enemy_image_group = ENEMY_PROPERTIES[enemy_type].enemy_img_group;
                if (formation_index) {
                    f->wait_ticks = 50 * formation_index + 15 * fig + 300;
                } else { // first formation is "scouting party"
                    f->wait_ticks = 15 * fig + 10;
                }

                f->terrain_usage = TERRAIN_USAGE_ENEMY;
                f->is_invisible = 1;
                switch (figure_type) {
                    case FIGURE_ENEMY_BARBARIAN_SWORDSMAN:
                    case FIGURE_ENEMY_HUN_SWORDSMAN:
                    case FIGURE_ENEMY_GOTH_SWORDSMAN:
                    case FIGURE_ENEMY_VISIGOTH_SWORDSMAN:
                    case FIGURE_ENEMY_NUMIDIAN_SWORDSMAN:
                    case FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER:
                        f->speed_multiplier = 2;
                        break;
                    case FIGURE_ENEMY_BRITON_CHARIOT:
                    case FIGURE_ENEMY_CELT_CHARIOT:
                    case FIGURE_ENEMY_PICT_CHARIOT:
                        f->speed_multiplier = 3;
                        f->mounted_charge_ticks = 8;
                        f->mounted_charge_ticks_max = 8;
                        break;
                    case FIGURE_ENEMY_HUN_MOUNTED_ARCHER:
                    case FIGURE_ENEMY_GOTH_MOUNTED_ARCHER:
                    case FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER:
                        f->speed_multiplier = 3;
                        break;
                    default:
                        break;
                }
                add_figure_to_formation(f, m);
                if (enemy_type == ENEMY_TYPE_CAESAR) {
                    city_data.figure.imperial_soldiers++;
                } else {
                    city_data.figure.enemies++;
                }
            }
            break;
        }
    }
}

static int find_closest_clear_y_offset(int x, int y)
{
    for (int j = y; j < scenario.map.height; j++) {
        int grid_offset = map_grid_offset(x, j);
        if (terrain_at_offset_clear(grid_offset)) {
            return j;
        } else {
            continue;
        }
    }
    for (int j = y; j < scenario.map.height; j--) {
        int grid_offset = map_grid_offset(x, j);
        if (terrain_at_offset_clear(grid_offset)) {
            return j;
        } else {
            continue;
        }
    }
    return -1;
}

static int start_invasion(int enemy_type, int amount, int invasion_point, int enemy_attack_priority)
{
    if (amount <= 0) {
        return -1;
    }
    int x, y;
    // determine invasion point
    if (enemy_type == ENEMY_TYPE_CAESAR) {
        x = scenario.entry_point.x;
        y = scenario.entry_point.y;
    } else {
        int invasion_flags_placed = 0;
        for (int i = 0; i < MAX_INVASION_POINTS; i++) {
            if (scenario.invasion_points[i].x != -1) {
                invasion_flags_placed++;
            }
        }
        if (invasion_point == MAX_INVASION_POINTS) { // random
            if (invasion_flags_placed) {
                // one or more, not necessarily sequential
                int rnd_point = rand() % MAX_INVASION_POINTS;
                x = scenario.invasion_points[rnd_point].x;
                y = scenario.invasion_points[rnd_point].y;
                while (x == -1) {
                    if (rnd_point < MAX_INVASION_POINTS - 1) {
                        rnd_point++;
                    } else {
                        rnd_point = 0;
                    }
                    x = scenario.invasion_points[rnd_point].x;
                    y = scenario.invasion_points[rnd_point].y;
                }
            } else {
                // no invasion flags placed
                x = scenario.exit_point.x;
                y = scenario.exit_point.y;
            }
        } else {
            x = scenario.invasion_points[invasion_point].x;
            y = scenario.invasion_points[invasion_point].y;
        }
    }
    // determine orientation
    int orientation = DIR_0_TOP;
    if (y == 0) {
        orientation = DIR_4_BOTTOM;
    } else if (x == 0) {
        orientation = DIR_2_RIGHT;
    } else if (x >= scenario.map.width - 1) {
        orientation = DIR_6_LEFT;
    }
    int enemy_count_per_type[MAX_ENEMY_TYPES_PER_ARMY];
    for (int i = 0; i < MAX_ENEMY_TYPES_PER_ARMY; i++) {
        enemy_count_per_type[i] = calc_adjust_with_percentage(amount, ENEMY_PROPERTIES[enemy_type].pct_type[i]);
    }
    enemy_count_per_type[0] += amount - (enemy_count_per_type[0] + enemy_count_per_type[1] + enemy_count_per_type[2]); // assign leftovers to first type
    int formation_index = 0;
    for (int i = 0; i < MAX_ENEMY_TYPES_PER_ARMY; i++) {
        while (enemy_count_per_type[i]) {
            int figures_amount_to_spawn = enemy_count_per_type[i] >= MAX_FORMATION_FIGURES ? MAX_FORMATION_FIGURES : enemy_count_per_type[i];
            // determine spawn point for each formation
            if (orientation == DIR_0_TOP || orientation == DIR_4_BOTTOM) {
                int x_offseted = -1;
                if (x >= scenario.map.width / 2) {
                    if (formation_index % 2) {
                        x_offseted = find_closest_clear_x_offset(x - LAYOUT_SPACING_BETWEEN_FORMATIONS[ENEMY_PROPERTIES[enemy_type].formation_layout] * formation_index, y);
                    } else {
                        x_offseted = find_closest_clear_x_offset(x - LAYOUT_SPACING_BETWEEN_FORMATIONS[ENEMY_PROPERTIES[enemy_type].formation_layout] * (formation_index + 1), y);
                    }
                } else {
                    if (formation_index % 2) {
                        x_offseted = find_closest_clear_x_offset(x + LAYOUT_SPACING_BETWEEN_FORMATIONS[ENEMY_PROPERTIES[enemy_type].formation_layout] * formation_index, y);
                    } else {
                        x_offseted = find_closest_clear_x_offset(x + LAYOUT_SPACING_BETWEEN_FORMATIONS[ENEMY_PROPERTIES[enemy_type].formation_layout] * (formation_index + 1), y);
                    }
                }
                if (x_offseted > -1) {
                    create_enemy_formation(ENEMY_PROPERTIES[enemy_type].figure_types[i], enemy_type, x_offseted, y, figures_amount_to_spawn, orientation, formation_index, enemy_attack_priority);
                    enemy_count_per_type[i] -= figures_amount_to_spawn;
                    formation_index++;
                }
            } else { // left/right
                int y_offseted = -1;
                if (y >= scenario.map.height / 2) {
                    if (formation_index % 2) {
                        y_offseted = find_closest_clear_y_offset(x, y - LAYOUT_SPACING_BETWEEN_FORMATIONS[ENEMY_PROPERTIES[enemy_type].formation_layout] * formation_index);
                    } else {
                        y_offseted = find_closest_clear_y_offset(x, y - LAYOUT_SPACING_BETWEEN_FORMATIONS[ENEMY_PROPERTIES[enemy_type].formation_layout] * (formation_index + 1));
                    }
                } else {
                    if (formation_index % 2) {
                        y_offseted = find_closest_clear_y_offset(x, y + LAYOUT_SPACING_BETWEEN_FORMATIONS[ENEMY_PROPERTIES[enemy_type].formation_layout] * formation_index);
                    } else {
                        y_offseted = find_closest_clear_y_offset(x, y + LAYOUT_SPACING_BETWEEN_FORMATIONS[ENEMY_PROPERTIES[enemy_type].formation_layout] * (formation_index + 1));
                    }
                }
                if (y_offseted > -1) {
                    create_enemy_formation(ENEMY_PROPERTIES[enemy_type].figure_types[i], enemy_type, x, y_offseted, figures_amount_to_spawn, orientation, formation_index, enemy_attack_priority);
                    enemy_count_per_type[i] -= figures_amount_to_spawn;
                    formation_index++;
                }
            }
        }
    }
    return map_grid_offset(x, y);
}

static void window_advisors_show(int advisor);
static void window_empire_show(void);
static void window_message_list_show(void);
static void handle_hotkeys_city(struct hotkeys_t *h)
{
    if (h->load_file) {
        window_file_dialog_show(FILE_TYPE_SAVED_GAME, FILE_DIALOG_LOAD);
    }
    if (h->save_file) {
        window_file_dialog_show(FILE_TYPE_SAVED_GAME, FILE_DIALOG_SAVE);
    }
    if (h->decrease_game_speed) {
        setting_decrease_game_speed();
    }
    if (h->increase_game_speed) {
        setting_increase_game_speed();
    }
    if (h->toggle_pause) {
        state_data.paused = state_data.paused ? 0 : 1;
        city_warning_clear_all();
    }
    if (h->rotate_map_left) {
        game_orientation_rotate_left();
        window_invalidate();
    }
    if (h->rotate_map_right) {
        game_orientation_rotate_right();
        window_invalidate();
    }
    if (h->replay_map) {
        replay_map();
    }
    if (h->cycle_legion) {
        if (city_data.military.total_legions) {
            int selectable_legions_count = 0;
            for (int i = 0; i < MAX_LEGIONS; i++) {
                struct formation_t *m = &legion_formations[i];
                if (m->in_use && !m->in_distant_battle && m->num_figures && m->morale > ROUT_MORALE_THRESHOLD) {
                    selectable_legions_count++;
                }
            }
            // handle wrap around and index mismatches caused by fort delete/recreate, formation rout/destruction, allocation to distant battle
            if (current_selected_legion_index >= selectable_legions_count) {
                current_selected_legion_index = 0;
            }
            int next_available_legion_index = 0;
            for (int i = 0; i < MAX_LEGIONS; i++) {
                struct formation_t *m = &legion_formations[i];
                if (m->in_use && !m->in_distant_battle && m->num_figures && m->morale > ROUT_MORALE_THRESHOLD) {
                    if (next_available_legion_index == current_selected_legion_index) {
                        window_city_military_show(m->id);
                        current_selected_legion_index++;
                        return;
                    }
                    next_available_legion_index++;
                }
            }
        }
    }
    if (h->return_legions_to_fort) {
        for (int i = 0; i < MAX_LEGIONS; i++) {
            if (legion_formations[i].in_use && !legion_formations[i].in_distant_battle) {
                return_legion_formation_home(&legion_formations[i]);
            }
        }
    }
    if (h->show_last_advisor) {
        window_advisors_show(settings_values[SETTINGS_LAST_ADVISOR]);
    }
    if (h->show_empire_map) {
        window_empire_show();
    }
    if (h->show_messages) {
        window_message_list_show();
    }
    if (h->go_to_problem) {
        button_go_to_problem(0, 0);
    }
    if (h->clone_building) {
        int type = BUILDING_NONE;
        if (terrain_grid.items[widget_city_data.current_tile.grid_offset] & TERRAIN_BUILDING) {
            int building_id = map_building_at(widget_city_data.current_tile.grid_offset);
            if (building_id) {
                struct building_t *b = building_main(&all_buildings[building_id]);
                int clone_type = b->type;
                if (building_is_house(clone_type)) {
                    type = BUILDING_HOUSE_VACANT_LOT;
                } else {
                    type = clone_type;
                }
            }
        } else if (terrain_grid.items[widget_city_data.current_tile.grid_offset] & TERRAIN_AQUEDUCT) {
            type = BUILDING_AQUEDUCT;
        } else if (terrain_grid.items[widget_city_data.current_tile.grid_offset] & TERRAIN_WALL) {
            type = BUILDING_WALL;
        } else if (terrain_grid.items[widget_city_data.current_tile.grid_offset] & TERRAIN_GARDEN) {
            type = BUILDING_GARDENS;
        } else if (terrain_grid.items[widget_city_data.current_tile.grid_offset] & TERRAIN_ROAD) {
            if (terrain_grid.items[widget_city_data.current_tile.grid_offset] & TERRAIN_WATER) {
                if (sprite.items[widget_city_data.current_tile.grid_offset] > 6) {
                    type = BUILDING_SHIP_BRIDGE;
                } else {
                    type = BUILDING_LOW_BRIDGE;
                }
            } else if (bitfields_grid.items[widget_city_data.current_tile.grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
                type = BUILDING_PLAZA;
            } else {
                type = BUILDING_ROAD;
            }
        }
        if (type) {
            set_construction_building_type(type);
        }
    }
    if (h->cycle_buildings) {
        int last_building_type_selected = construction_data.type;
        if (last_building_type_selected < BUILDING_RESERVOIR) {
            last_building_type_selected = BUILDING_RESERVOIR;
        } else {
            last_building_type_selected++;
        }
        while (last_building_type_selected <= BUILDING_WAREHOUSE) {
            if (last_building_type_selected == BUILDING_TRIUMPHAL_ARCH) {
                if (!city_data.building.triumphal_arches_available) {
                    last_building_type_selected++;
                }
            }
            if (scenario.allowed_buildings[last_building_type_selected]) {
                set_construction_building_type(last_building_type_selected);
                break;
            }
            last_building_type_selected++;
        }
    }
    if (h->cycle_buildings_reverse) {
        int last_building_type_selected = construction_data.type;
        if (last_building_type_selected < BUILDING_RESERVOIR) {
            last_building_type_selected = BUILDING_WAREHOUSE;
        } else {
            last_building_type_selected--;
        }
        while (last_building_type_selected >= BUILDING_RESERVOIR) {
            if (last_building_type_selected == BUILDING_TRIUMPHAL_ARCH) {
                if (!city_data.building.triumphal_arches_available) {
                    last_building_type_selected--;
                }
            }
            if (scenario.allowed_buildings[last_building_type_selected]) {
                set_construction_building_type(last_building_type_selected);
                break;
            }
            last_building_type_selected--;
        }
    }
    if (h->undo) {
        game_undo_perform();
    }
    if (h->building) {
        if (h->building == BUILDING_CLEAR_LAND
        || (h->building == BUILDING_TRIUMPHAL_ARCH && city_data.building.triumphal_arches_available && scenario.allowed_buildings[h->building])
        || (h->building != BUILDING_TRIUMPHAL_ARCH && scenario.allowed_buildings[h->building])) {
            set_construction_building_type(h->building);
        }
    }
    if (h->show_overlay) {
        if (state_data.current_overlay == h->show_overlay) {
            game_state_set_overlay(OVERLAY_NONE);
        } else {
            game_state_set_overlay(h->show_overlay);
        }
        select_city_overlay();
        window_invalidate();
    }
    if (h->go_to_bookmark) {
        if (h->go_to_bookmark - 1 >= 0 && h->go_to_bookmark - 1 < MAX_BOOKMARKS) {
            int x = bookmarks[h->go_to_bookmark - 1].x;
            int y = bookmarks[h->go_to_bookmark - 1].y;
            if (x > -1 && map_grid_offset(x, y) > -1) {
                city_view_set_camera(x, y);
                window_invalidate();
            }
        }
    }
    if (h->set_bookmark) {
        if (h->set_bookmark - 1 >= 0 && h->set_bookmark - 1 < MAX_BOOKMARKS) {
            city_view_get_camera(&bookmarks[h->set_bookmark - 1].x, &bookmarks[h->set_bookmark - 1].y);
        }
    }
    if (h->cheat_money) {
        if (city_data.finance.treasury < 50000) {
            city_data.finance.treasury += 1000;
            city_data.finance.cheated_money += 1000;
        }
        window_invalidate();
    }
    if (h->cheat_invasion) {
        city_message_post(1, MESSAGE_ENEMY_ARMY_ATTACK, 0, start_invasion(rand() % (ENEMY_TYPE_MAX_COUNT + 1), 160, MAX_INVASION_POINTS, FORMATION_ATTACK_RANDOM));
    }
    if (h->cheat_victory) {
        victory_data.force_win = 1;
    }
}

static int menu_bar_handle_mouse(struct mouse_t *m, struct menu_bar_item_t *items, int num_items, int *focus_menu_id)
{
    int menu_id = 0;
    for (int i = 0; i < num_items; i++) {
        if (items[i].x_start <= m->x &&
            items[i].x_end > m->x &&
            MENU_BASE_TEXT_Y_OFFSET <= m->y &&
            MENU_BASE_TEXT_Y_OFFSET + 12 > m->y) {
            menu_id = i + 1;
            break;
        }
    }

    if (focus_menu_id) {
        *focus_menu_id = menu_id;
    }
    return menu_id;
}

static int menu_handle_mouse(struct mouse_t *m, struct menu_bar_item_t *menu, int *focus_item_id)
{
    int item_id = 0;
    int y_offset = TOP_MENU_HEIGHT + MENU_BASE_TEXT_Y_OFFSET * 2;
    for (int i = 0; i < menu->num_items; i++) {
        if (menu->items[i].hidden) {
            continue;
        }
        if (menu->x_start <= m->x &&
            menu->x_start + BLOCK_SIZE * menu->calculated_width_blocks > m->x &&
            y_offset - 2 <= m->y &&
            y_offset + 19 > m->y) {
            item_id = i + 1;
            break;
        }
        y_offset += TOP_MENU_ITEM_HEIGHT;
    }

    if (focus_item_id) {
        *focus_item_id = item_id;
    }
    if (!item_id) {
        return 0;
    }
    if (m->left.went_up) {
        struct menu_item_t *item = &menu->items[item_id - 1];
        item->left_click_handler(item->parameter);
    }
    return item_id;
}

static void draw_background_top_menu(void)
{
    window_city_draw_background();
    widget_city_draw();
}

static void menu_draw(struct menu_bar_item_t *menu, int focus_item_id)
{
    if (menu->calculated_width_blocks == 0 || menu->calculated_height_blocks == 0) {
        int max_width = 0;
        int height_pixels = TOP_MENU_ITEM_HEIGHT;
        for (int i = 0; i < menu->num_items; i++) {
            struct menu_item_t *sub = &menu->items[i];
            if (sub->hidden) {
                continue;
            }
            int width_pixels = lang_text_get_width(
                sub->text_group, sub->text_number, FONT_NORMAL_BLACK);
            if (width_pixels > max_width) {
                max_width = width_pixels;
            }
            height_pixels += TOP_MENU_ITEM_HEIGHT;
        }
        int blocks = (max_width + 8) / BLOCK_SIZE + 1; // 1 block padding
        menu->calculated_width_blocks = blocks < 10 ? 10 : blocks;
        menu->calculated_height_blocks = height_pixels / BLOCK_SIZE;
    }
    int image_base = image_data_s.group_image_ids[GROUP_DIALOG_BACKGROUND];
    int image_y = 0;
    for (int yy = 0; yy < menu->calculated_height_blocks; yy++) {
        int image_x = 0;
        for (int xx = 0; xx < menu->calculated_width_blocks; xx++) {
            int image_id = 13 + image_y + image_x++;
            image_draw(image_base + image_id, menu->x_start + BLOCK_SIZE * xx, TOP_MENU_HEIGHT + BLOCK_SIZE * yy);
            if (image_x >= 10) {
                image_x = 0;
            }
        }
        image_y += 12;
        if (image_y >= 120) {
            image_y = 0;
        }
    }
    int y_offset = TOP_MENU_HEIGHT + MENU_BASE_TEXT_Y_OFFSET * 2;
    for (int i = 0; i < menu->num_items; i++) {
        struct menu_item_t *sub = &menu->items[i];
        if (sub->hidden) {
            continue;
        }
        if (i == focus_item_id - 1) {
            graphics_fill_rect(menu->x_start, y_offset - 4, BLOCK_SIZE * menu->calculated_width_blocks, 20, COLOR_BLACK);
            if (sub->text_group == 10 && sub->text_number == 4) {
                text_draw(editor_top_menu_clear_earthquakes_string, menu->x_start + 8, y_offset, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
            } else {
                lang_text_draw_colored(sub->text_group, sub->text_number, menu->x_start + 8, y_offset, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
            }
        } else {
            if (sub->text_group == 10 && sub->text_number == 4) {
                text_draw(editor_top_menu_clear_earthquakes_string, menu->x_start + 8, y_offset, FONT_NORMAL_BLACK, COLOR_BLACK);
            } else {
                lang_text_draw(sub->text_group, sub->text_number, menu->x_start + 8, y_offset, FONT_NORMAL_BLACK);
            }
        }
        y_offset += TOP_MENU_ITEM_HEIGHT;
    }
}

static void draw_foreground_top_menu(void)
{
    if (top_menu_data.open_sub_menu) {
        menu_draw(&top_menu[top_menu_data.open_sub_menu - 1], top_menu_data.focus_sub_menu_id);
    }
}

static int widget_top_menu_handle_input(struct mouse_t *m, struct hotkeys_t *h);
static void handle_input_top_menu(struct mouse_t *m, struct hotkeys_t *h)
{
    widget_top_menu_handle_input(m, h);
}

static int widget_top_menu_handle_input(struct mouse_t *m, struct hotkeys_t *h)
{
    if (widget_city_data.capture_input) {
        return 0;
    }
    if (top_menu_data.open_sub_menu) {
        if (m->right.went_up || h->escape_pressed) {
            clear_state_top_menu();
            window_go_back();
            return 1;
        }
        int menu_id = menu_bar_handle_mouse(m, top_menu, sizeof(top_menu) / sizeof(struct menu_bar_item_t), &top_menu_data.focus_menu_id);
        if (menu_id && menu_id != top_menu_data.open_sub_menu) {
            window_data.refresh_on_draw = 1;
            top_menu_data.open_sub_menu = menu_id;
        }
        if (!menu_handle_mouse(m, &top_menu[top_menu_data.open_sub_menu - 1], &top_menu_data.focus_sub_menu_id)) {
            if (m->left.went_up) {
                clear_state_top_menu();
                window_go_back();
                return 1;
            }
        }
        return 0;
    } else {
        int menu_id = menu_bar_handle_mouse(m, top_menu, sizeof(top_menu) / sizeof(struct menu_bar_item_t), &top_menu_data.focus_menu_id);
        if (menu_id && m->left.went_up) {
            top_menu_data.open_sub_menu = menu_id;
            struct window_type_t window = {
                WINDOW_TOP_MENU,
                draw_background_top_menu,
                draw_foreground_top_menu,
                handle_input_top_menu,
            };
            top_menu[INDEX_OPTIONS].items[0].hidden = 0;
            menu_update_text(&top_menu[INDEX_OPTIONS], 3, settings_values[SETTINGS_MONTHLY_AUTOSAVE_ENABLED] ? 51 : 52);
            menu_update_text(&top_menu[INDEX_HELP], 1, settings_values[SETTINGS_WARNINGS_ENABLED] ? 6 : 5);
            window_show(&window);
            return 1;
        }
        if (m->right.went_up) {
            int type;
            if (m->y < 4 || m->y >= 18) {
                type = INFO_NONE;
            } else if (m->x > top_menu_data.offset_funds && m->x < top_menu_data.offset_funds + 128) {
                type = INFO_FUNDS;
            } else if (m->x > top_menu_data.offset_population && m->x < top_menu_data.offset_population + 128) {
                type = INFO_POPULATION;
            } else if (m->x > top_menu_data.offset_date && m->x < top_menu_data.offset_date + 128) {
                type = INFO_DATE;
            }
            if (type) {
                if (type == INFO_FUNDS) {
                    window_message_dialog_show(MESSAGE_DIALOG_TOP_FUNDS, window_city_draw_all);
                } else if (type == INFO_POPULATION) {
                    window_message_dialog_show(MESSAGE_DIALOG_TOP_POPULATION, window_city_draw_all);
                } else if (type == INFO_DATE) {
                    window_message_dialog_show(MESSAGE_DIALOG_TOP_DATE, window_city_draw_all);
                }
                return 1;
            }
        }
    }
    return 0;
}

static void update_city_view_coords(int x, int y, struct map_tile_t *tile)
{
    struct pixel_view_coordinates_t view;
    if (x < view_data.viewport.x ||
            x >= view_data.viewport.x + view_data.viewport.width_pixels ||
            y < view_data.viewport.y ||
            y >= view_data.viewport.y + view_data.viewport.height_pixels) {
        tile->grid_offset = tile->x = tile->y = 0;
    } else {

        x += view_data.camera.pixel.x;
        y += view_data.camera.pixel.y;
        int odd = ((x - view_data.viewport.x) / HALF_TILE_WIDTH_PIXELS +
            (y - view_data.viewport.y) / HALF_TILE_HEIGHT_PIXELS) & 1;
        int x_is_odd = ((x - view_data.viewport.x) / HALF_TILE_WIDTH_PIXELS) & 1;
        int y_is_odd = ((y - view_data.viewport.y) / HALF_TILE_HEIGHT_PIXELS) & 1;
        int x_mod = ((x - view_data.viewport.x) % HALF_TILE_WIDTH_PIXELS) / 2;
        int y_mod = (y - view_data.viewport.y) % HALF_TILE_HEIGHT_PIXELS;
        int x_view_offset = (x - view_data.viewport.x) / TILE_WIDTH_PIXELS;
        int y_view_offset = (y - view_data.viewport.y) / HALF_TILE_HEIGHT_PIXELS;
        if (odd) {
            if (x_mod + y_mod >= HALF_TILE_HEIGHT_PIXELS - 1) {
                y_view_offset++;
                if (x_is_odd && !y_is_odd) {
                    x_view_offset++;
                }
            }
        } else {
            if (y_mod > x_mod) {
                y_view_offset++;
            } else if (x_is_odd && y_is_odd) {
                x_view_offset++;
            }
        }
        view.x = view_data.camera.tile.x + x_view_offset;
        view.y = view_data.camera.tile.y + y_view_offset;
        int grid_offset = view_to_grid_offset_lookup[view.x][view.y];
        tile->grid_offset = grid_offset < 0 ? 0 : grid_offset;
        x_view_offset = view.x - view_data.camera.tile.x;
        y_view_offset = view.y - view_data.camera.tile.y;
        view_data.selected_tile.x_pixels = view_data.viewport.x + TILE_WIDTH_PIXELS * x_view_offset - view_data.camera.pixel.x;
        if (y_view_offset & 1) {
            view_data.selected_tile.x_pixels -= HALF_TILE_WIDTH_PIXELS;
        }
        view_data.selected_tile.y_pixels = view_data.viewport.y + HALF_TILE_HEIGHT_PIXELS * y_view_offset
            - HALF_TILE_HEIGHT_PIXELS - view_data.camera.pixel.y;
        tile->x = map_grid_offset_to_x(tile->grid_offset);
        tile->y = map_grid_offset_to_y(tile->grid_offset);
    }
}

static void update_mouse_grid_offset(int x_view, int y_view, int grid_offset)
{
    if (minimap_data.mouse.y == y_view && (minimap_data.mouse.x == x_view || minimap_data.mouse.x == x_view + 1)) {
        minimap_data.mouse.grid_offset = grid_offset < 0 ? 0 : grid_offset;
    }
}

static int widget_minimap_handle_mouse(struct mouse_t *m)
{
    if ((m->left.went_down || m->right.went_down)
    && (m->x >= minimap_data.x_offset && m->x < minimap_data.x_offset + minimap_data.width && // in minimap
        m->y >= minimap_data.y_offset && m->y < minimap_data.y_offset + minimap_data.height)) {
        minimap_data.mouse.x = m->x;
        minimap_data.mouse.y = m->y;
        minimap_data.mouse.grid_offset = 0;
        city_view_foreach_minimap_tile(minimap_data.x_offset, minimap_data.y_offset,
                                       minimap_data.absolute_x, minimap_data.absolute_y,
                                       minimap_data.width_tiles, minimap_data.height_tiles,
                                       update_mouse_grid_offset);
        int grid_offset = minimap_data.mouse.grid_offset;
        if (grid_offset > 0) {
            city_view_go_to_grid_offset(grid_offset);
            return 1;
        }
    }
    return 0;
}

static void scroll_map(struct mouse_t *m)
{
    struct pixel_view_coordinates_t delta;
    if (scroll_get_delta(m, &delta, SCROLL_TYPE_CITY)) {
        view_data.camera.pixel.x += delta.x;
        view_data.camera.pixel.y += delta.y;
        while (view_data.camera.pixel.x < 0) {
            view_data.camera.tile.x--;
            view_data.camera.pixel.x += TILE_WIDTH_PIXELS;
        }
        while (view_data.camera.pixel.y < 0) {
            view_data.camera.tile.y -= 2;
            view_data.camera.pixel.y += TILE_HEIGHT_PIXELS;
        }
        while (view_data.camera.pixel.x >= TILE_WIDTH_PIXELS) {
            view_data.camera.tile.x++;
            view_data.camera.pixel.x -= TILE_WIDTH_PIXELS;
        }
        while (view_data.camera.pixel.y >= TILE_HEIGHT_PIXELS) {
            view_data.camera.tile.y += 2;
            view_data.camera.pixel.y -= TILE_HEIGHT_PIXELS;
        }
        check_camera_boundaries();
        for (int i = 0; i < MAX_CITY_SOUNDS_CHANNELS; i++) {
            for (int d = 0; d < 5; d++) {
                channels[i].direction_views[d] = 0;
            }
            channels[i].total_views /= 2;
        }
    }
}

static void play_speech_file(char *filename)
{
    if (!settings_values[SETTINGS_SPEECH_ENABLED]) {
        return;
    }
    stop_sound_channel(SOUND_CHANNEL_SPEECH);
    if (filename) {
        if (data_channels.initialized) {
            stop_sound_channel(SOUND_CHANNEL_SPEECH);
            data_channels.channels[SOUND_CHANNEL_SPEECH].chunk = load_chunk(filename);
            if (data_channels.channels[SOUND_CHANNEL_SPEECH].chunk) {
                set_channel_volume(SOUND_CHANNEL_SPEECH, settings_values[SETTINGS_SPEECH_VOLUME]);
                Mix_PlayChannel(SOUND_CHANNEL_SPEECH, data_channels.channels[SOUND_CHANNEL_SPEECH].chunk, 0);
            }
        }
    }
}

static void set_destination_for_soldier(struct figure_t *soldier, int dst_x, int dst_y, int dst_grid_offset)
{
    soldier->destination_x = dst_x;
    soldier->destination_y = dst_y;
    soldier->destination_grid_offset = dst_grid_offset;
    soldier->action_state = FIGURE_ACTION_SOLDIER_GOING_TO_STANDARD;
}

static int destination_is_clear(struct figure_t *legion_unit, int target_grid_offset)
{
    // check terrain at destination
    if (map_terrain_is(target_grid_offset, TERRAIN_IMPASSABLE)) {
        return 0;
    }
    // check if any legion unit is heading towards the destination
    for (int i = 1; i < MAX_FIGURES; i++) {
        struct figure_t *f = &figures[i];
        if (figure_is_alive(f) && figure_properties[f->type].is_player_legion_unit && f->id != legion_unit->id) {
            if (f->destination_grid_offset == target_grid_offset) {
                if (f->formation_id == legion_unit->formation_id) { // same formation, stationary units may not have received the command to move yet
                    if (f->action_state == FIGURE_ACTION_SOLDIER_GOING_TO_STANDARD) {
                        return 0;
                    }
                } else {
                    return 0;
                }
            }
        }
    }
    return 1;
}

static void deploy_legion_unit_to_formation_location(struct figure_t *legion_unit, struct formation_t *legion_formation)
{
    figure_route_remove(legion_unit);
    int target_dst_x = legion_formation->standard_x + FORMATION_LAYOUT_POSITION_X[legion_formation->layout][legion_unit->index_in_formation];
    int target_dst_y = legion_formation->standard_y + FORMATION_LAYOUT_POSITION_Y[legion_formation->layout][legion_unit->index_in_formation];
    int target_dst_grid_offset = map_grid_offset(target_dst_x, target_dst_y);
    if (destination_is_clear(legion_unit, target_dst_grid_offset)) {
        set_destination_for_soldier(legion_unit, target_dst_x, target_dst_y, target_dst_grid_offset);
    } else {
        // attempt to route to nearest clear tile
        for (int j = 1; j < 10; j++) {
            target_dst_grid_offset = map_grid_offset(target_dst_x + j, target_dst_y); // +x
            if (destination_is_clear(legion_unit, target_dst_grid_offset)) {
                set_destination_for_soldier(legion_unit, target_dst_x + j, target_dst_y, target_dst_grid_offset);
                break;
            }
            target_dst_grid_offset = map_grid_offset(target_dst_x - j, target_dst_y); // -x
            if (destination_is_clear(legion_unit, target_dst_grid_offset)) {
                set_destination_for_soldier(legion_unit, target_dst_x - j, target_dst_y, target_dst_grid_offset);
                break;
            }
            target_dst_grid_offset = map_grid_offset(target_dst_x, target_dst_y + j); // +y
            if (destination_is_clear(legion_unit, target_dst_grid_offset)) {
                set_destination_for_soldier(legion_unit, target_dst_x, target_dst_y + j, target_dst_grid_offset);
                break;
            }
            target_dst_grid_offset = map_grid_offset(target_dst_x, target_dst_y - j); // -y
            if (destination_is_clear(legion_unit, target_dst_grid_offset)) {
                set_destination_for_soldier(legion_unit, target_dst_x, target_dst_y - j, target_dst_grid_offset);
                break;
            }
            target_dst_grid_offset = map_grid_offset(target_dst_x + j, target_dst_y - j); // +x, -y
            if (destination_is_clear(legion_unit, target_dst_grid_offset)) {
                set_destination_for_soldier(legion_unit, target_dst_x + j, target_dst_y - j, target_dst_grid_offset);
                break;
            }
            target_dst_grid_offset = map_grid_offset(target_dst_x - j, target_dst_y + j); // -x, +y
            if (destination_is_clear(legion_unit, target_dst_grid_offset)) {
                set_destination_for_soldier(legion_unit, target_dst_x - j, target_dst_y + j, target_dst_grid_offset);
                break;
            }
            target_dst_grid_offset = map_grid_offset(target_dst_x + j, target_dst_y + j); // +x, +y
            if (destination_is_clear(legion_unit, target_dst_grid_offset)) {
                set_destination_for_soldier(legion_unit, target_dst_x + j, target_dst_y + j, target_dst_grid_offset);
                break;
            }
            target_dst_grid_offset = map_grid_offset(target_dst_x - j, target_dst_y - j); // -x, -y
            if (destination_is_clear(legion_unit, target_dst_grid_offset)) {
                set_destination_for_soldier(legion_unit, target_dst_x - j, target_dst_y - j, target_dst_grid_offset);
                break;
            }
        }
    }
}

static void handle_input_military(struct mouse_t *m, struct hotkeys_t *h)
{
    handle_hotkeys_city(h);
    if (widget_top_menu_handle_input(m, h)) {
        return;
    }
    struct map_tile_t *tile = &widget_city_data.current_tile;
    update_city_view_coords(m->x, m->y, tile);
    if (!view_data.sidebar_collapsed && widget_minimap_handle_mouse(m)) {
        return;
    }
    scroll_map(m);
    if (m->right.went_up || h->escape_pressed) {
        widget_city_data.capture_input = 0;
        city_warning_clear_all();
        window_city_show();
    } else {
        update_city_view_coords(m->x, m->y, tile);
        if (m->left.went_down) {
            if (!tile->grid_offset) {
                return;
            }
            struct formation_t *legion_formation = &legion_formations[selected_legion_formation];
            if (legion_formation->in_distant_battle || legion_formation->cursed_by_mars) {
                return;
            }
            // return legion home upon clicking on own fort/fort ground
            struct building_t *b = &all_buildings[map_building_at(tile->grid_offset)];
            if (b && b->state == BUILDING_STATE_IN_USE && (building_is_fort(b->type) || b->type == BUILDING_FORT_GROUND) && b->formation_id == selected_legion_formation) {
                return_legion_formation_home(legion_formation);
            } else { // move legion if route available
                map_routing_calculate_distances(legion_formation->standard_x, legion_formation->standard_y);
                if (routing_distance.items[tile->grid_offset]
                && !legion_formation->cursed_by_mars
                && legion_formation->morale > ROUT_MORALE_THRESHOLD
                && legion_formation->num_figures) {
                    play_speech_file("wavs/cohort5.wav");
                    legion_formation->standard_x = tile->x;
                    legion_formation->standard_y = tile->y;
                    update_legion_standard_map_location(legion_formation);
                    for (int i = 0; i < legion_formation->num_figures && legion_formation->figures[i]; i++) {
                        struct figure_t *f = &figures[legion_formation->figures[i]];
                        deploy_legion_unit_to_formation_location(f, legion_formation);
                    }
                } else if (legion_formation->morale <= ROUT_MORALE_THRESHOLD) {
                    city_warning_show(WARNING_LEGION_MORALE_TOO_LOW);
                }
            }
            window_city_show();
        }
    }
}

static void window_city_military_show(int legion_formation_id)
{
    if (construction_data.type) {
        building_construction_cancel();
        building_construction_clear_type();
    }
    selected_legion_formation = legion_formation_id;
    struct window_type_t window = {
        WINDOW_CITY_MILITARY,
        window_city_draw_background,
        draw_foreground_city,
        handle_input_military,

    };
    window_show(&window);
}

static void menu_options_sound_editor(__attribute__((unused)) int param)
{
    clear_state();
    show_editor_map();
    window_sound_options_show(1);
}

static void arrow_button_game(int is_down, __attribute__((unused)) int param2)
{
    if (is_down) {
        setting_decrease_game_speed();
    } else {
        setting_increase_game_speed();
    }
}

static void arrow_button_scroll(int is_down, __attribute__((unused)) int param2)
{
    if (is_down) {
        settings_values[SETTINGS_SCROLL_SPEED] = calc_bound(settings_values[SETTINGS_SCROLL_SPEED] - 10, 0, 100);
    } else {
        settings_values[SETTINGS_SCROLL_SPEED] = calc_bound(settings_values[SETTINGS_SCROLL_SPEED] + 10, 0, 100);
    }
}

static struct arrow_button_t arrow_buttons_speed_options[] = {
    {112, 100, 17, 24, arrow_button_game, 1, 0, 0, 0},
    {136, 100, 15, 24, arrow_button_game, 0, 0, 0, 0},
    {112, 136, 17, 24, arrow_button_scroll, 1, 0, 0, 0},
    {136, 136, 15, 24, arrow_button_scroll, 0, 0, 0, 0},
};

static void draw_foreground_speed_options(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);

    outer_panel_draw(80, 80, 20, 10);

    // title
    lang_text_draw_centered(45, 0, 96, 92, 288, FONT_LARGE_BLACK);
    // game speed
    lang_text_draw(45, 2, 112, 146, FONT_NORMAL_PLAIN);
    text_draw_percentage(settings_values[SETTINGS_GAME_SPEED], 328, 146, FONT_NORMAL_PLAIN);
    // scroll speed
    lang_text_draw(45, 3, 112, 182, FONT_NORMAL_PLAIN);
    text_draw_percentage(settings_values[SETTINGS_SCROLL_SPEED], 328, 182, FONT_NORMAL_PLAIN);

    arrow_buttons_draw(160, 40, arrow_buttons_speed_options, sizeof(arrow_buttons_speed_options) / sizeof(struct arrow_button_t));
    set_translation(0, 0);
}

static void handle_input_speed_options(struct mouse_t *m, struct hotkeys_t *h)
{
    struct mouse_t *m_dialog = mouse_in_dialog(m);
    if (arrow_buttons_handle_mouse(m_dialog, 160, 40, arrow_buttons_speed_options, sizeof(arrow_buttons_speed_options) / sizeof(struct arrow_button_t), 0)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        if (speed_options_data.from_editor) {
            show_editor_map();
        } else {
            window_city_return();
        }
    }
}

static void window_speed_options_show(int from_editor)
{
    struct window_type_t window = {
        WINDOW_SPEED_OPTIONS,
        window_draw_underlying_window,
        draw_foreground_speed_options,
        handle_input_speed_options,
    };
    speed_options_data.focus_button_id = 0;
    speed_options_data.from_editor = from_editor;
    speed_options_data.original_game_speed = settings_values[SETTINGS_GAME_SPEED];
    speed_options_data.original_scroll_speed = settings_values[SETTINGS_SCROLL_SPEED];
    window_show(&window);
}

static void menu_options_speed_editor(__attribute__((unused)) int param)
{
    clear_state();
    show_editor_map();
    window_speed_options_show(1);
}

static struct menu_item_t menu_options[] = {
    {2, 1, menu_options_display_editor, 0, 0},
    {2, 2, menu_options_sound_editor, 0, 0},
    {2, 3, menu_options_speed_editor, 0, 0},
};

static void draw_background_editor_map(void);
static void draw_foreground_editor_map(void);
static void window_editor_map_draw_all(void)
{
    draw_background_editor_map();
    draw_foreground_editor_map();
}

static void menu_editor_help(__attribute__((unused)) int param)
{
    clear_state();
    window_go_back();
    window_message_dialog_show(MESSAGE_DIALOG_EDITOR_HELP, window_editor_map_draw_all);
}

static void menu_help_editor_about(__attribute__((unused)) int param)
{
    clear_state();
    window_go_back();
    window_message_dialog_show(MESSAGE_DIALOG_EDITOR_ABOUT, window_editor_map_draw_all);
}

static struct menu_item_t menu_help[] = {
    {3, 1, menu_editor_help, 0, 0},
    {3, 7, menu_help_editor_about, 0, 0},
};

static void menu_resets_herds(__attribute__((unused)) int param)
{
    for (int i = 0; i < MAX_HERD_POINTS; i++) {
        scenario.herd_points[i].x = -1;
        scenario.herd_points[i].y = -1;
    }
    scenario.is_saved = 0;
    clear_state();
    window_go_back();
}

static void menu_resets_fish(__attribute__((unused)) int param)
{
    for (int i = 0; i < MAX_FISH_POINTS; i++) {
        scenario.fishing_points[i].x = -1;
        scenario.fishing_points[i].y = -1;
    }
    scenario.is_saved = 0;
    clear_state();
    window_go_back();
}

static void menu_resets_invasions(__attribute__((unused)) int param)
{
    for (int i = 0; i < MAX_INVASION_POINTS; i++) {
        scenario.invasion_points[i].x = -1;
        scenario.invasion_points[i].y = -1;
    }
    scenario.is_saved = 0;
    clear_state();
    window_go_back();
}

static void menu_resets_earthquakes(__attribute__((unused)) int param)
{
    for (int i = 0; i < MAX_EARTHQUAKE_POINTS; i++) {
        scenario.earthquake_points[i].x = -1;
        scenario.earthquake_points[i].y = -1;
    }
    scenario.is_saved = 0;
    clear_state();
    window_go_back();
}

static struct menu_item_t menu_resets[] = {
    {10, 1, menu_resets_herds, 0, 0},
    {10, 2, menu_resets_fish, 0, 0},
    {10, 3, menu_resets_invasions, 0, 0},
    {10, 4, menu_resets_earthquakes, 0, 0},
};

static void init_point(struct map_point_t *point)
{
    point->x = -1;
    point->y = -1;
}

static void game_file_editor_create_scenario(int size)
{
    memset(&scenario, 0, sizeof(scenario));
    scenario.map.width = MAP_SIZES[size].width;
    scenario.map.height = MAP_SIZES[size].height;
    scenario.map.grid_border_size = GRID_SIZE - scenario.map.width;
    scenario.map.grid_start = (GRID_SIZE - scenario.map.height) / 2 * GRID_SIZE + (GRID_SIZE - scenario.map.width) / 2;
    // Brief description
    string_copy(lang_get_string(44, 37), scenario.brief_description, MAX_BRIEF_DESCRIPTION);
    // Scenario description/briefing
    string_copy(lang_get_string(44, 38), scenario.briefing, MAX_BRIEFING);
    // Starting conditions
    scenario.start_year = -500;
    scenario.initial_favor = 40;
    scenario.initial_funds = 1000;
    scenario.rescue_loan = 500;
    // Win criteria
    scenario.culture_win_criteria.enabled = 1;
    scenario.culture_win_criteria.goal = 10;
    scenario.prosperity_win_criteria.enabled = 1;
    scenario.prosperity_win_criteria.goal = 10;
    scenario.peace_win_criteria.enabled = 1;
    scenario.peace_win_criteria.goal = 10;
    scenario.favor_win_criteria.enabled = 1;
    scenario.favor_win_criteria.goal = 10;
    // Buildings allowed
    for (int i = 1; i < BUILDING_TYPE_MAX; i++) {
        scenario.allowed_buildings[i] = 1;
    }
    // Special events
    scenario.gladiator_revolt.year = 1;
    // Requests
    for (int i = 0; i < MAX_REQUESTS; i++) {
        scenario.requests[i].year = 1;
        scenario.requests[i].amount = 1;
        scenario.requests[i].years_deadline = 5;
        scenario.requests[i].months_to_comply = 60;
        scenario.requests[i].favor = 8;
    }
    // Custom messages
    for (int i = 0; i < MAX_REQUESTS; i++) {
        scenario.editor_custom_messages[i].year = 1;
    }
    // Earthquakes
    for (int i = 0; i < MAX_EARTHQUAKES; i++) {
        scenario.earthquakes[i].year = 1;
        for (int j = 0; j < MAX_EARTHQUAKE_BRANCHES; j++) {
            init_point(&scenario.earthquakes[i].branch_coordinates[j]);
        }
    }
    // Invasions
    for (int i = 0; i < MAX_INVASIONS; i++) {
        scenario.invasions[i].year_offset = 1;
        scenario.invasions[i].from = 8;
    }
    // Price changes
    for (int i = 0; i < MAX_PRICE_CHANGES; i++) {
        scenario.price_changes[i].year = 1;
        scenario.price_changes[i].amount = 1;
    }
    // Demand changes
    for (int i = 0; i < MAX_DEMAND_CHANGES; i++) {
        scenario.demand_changes[i].year = 1;
    }
    for (int i = 0; i < MAX_EARTHQUAKE_POINTS; i++) {
        init_point(&scenario.earthquake_points[i]);
    }
    for (int i = 0; i < MAX_INVASION_POINTS; i++) {
        init_point(&scenario.invasion_points[i]);
    }
    init_point(&scenario.entry_point);
    init_point(&scenario.exit_point);
    init_point(&scenario.river_entry_point);
    init_point(&scenario.river_exit_point);
    for (int i = 0; i < MAX_FISH_POINTS; i++) {
        init_point(&scenario.fishing_points[i]);
    }
    for (int i = 0; i < MAX_HERD_POINTS; i++) {
        init_point(&scenario.herd_points[i]);
    }
    scenario.is_saved = 1;
    map_grid_init(scenario.map.width, scenario.map.height, scenario.map.grid_start, scenario.map.grid_border_size);
    clear_map_data();
    for (int x = 1; x < map_data.width; x++) {
        images.items[map_grid_offset(x, map_data.height)] = 1;
    }
    for (int y = 1; y < map_data.height; y++) {
        images.items[map_grid_offset(map_data.width, y)] = 2;
    }
    images.items[map_grid_offset(0, map_data.height)] = 3;
    images.items[map_grid_offset(map_data.width, 0)] = 4;
    images.items[map_grid_offset(map_data.width, map_data.height)] = 5;
    city_view_set_camera(76, 152);
    city_view_reset_orientation();
    prepare_map_for_editing(1);
}

static void map_size_selected(int size)
{
    clear_state();
    if (size >= 0 && size <= 5) {
        game_file_editor_create_scenario(size);
        show_editor_map();
    } else {
        window_go_back();
    }
}

static void window_select_list_show(int x, int y, int group, int num_items, void (*callback)(int));
static void menu_file_new_map(__attribute__((unused)) int param)
{
    window_select_list_show(50, 50, 33, 7, map_size_selected);
}

static void menu_file_load_map(__attribute__((unused)) int param)
{
    clear_state();
    show_editor_map();
    window_file_dialog_show(FILE_TYPE_SCENARIO, FILE_DIALOG_LOAD);
}

static void menu_file_save_map(__attribute__((unused)) int param)
{
    clear_state();
    show_editor_map();
    window_file_dialog_show(FILE_TYPE_SCENARIO, FILE_DIALOG_SAVE);
}

static char *get_message_text(int32_t offset)
{
    if (!offset) {
        return 0;
    }
    return &lang_data.message_data[offset];
}

static int load_files(char *text_filename, char *message_filename)
{
    uint8_t *buffer = (uint8_t *) malloc(BUFFER_SIZE);
    if (!buffer) {
        return 0;
    }
    int success;
    struct buffer_t buf;
    int filesize = read_file_into_buffer(text_filename, buffer, BUFFER_SIZE, 1);
    if (filesize < MIN_TEXT_SIZE || filesize > MAX_TEXT_SIZE) {
        success = 0;
    } else {
        buffer_init(&buf, buffer, filesize);
        buf.index += 28; // header
        for (int i = 0; i < MAX_TEXT_ENTRIES; i++) {
            lang_data.text_entries[i].offset = buffer_read_i32(&buf);
            lang_data.text_entries[i].in_use = buffer_read_i32(&buf);
        }
        buffer_read_raw(&buf, lang_data.text_data, MAX_TEXT_DATA);
        success = 1;
    }
    filesize = read_file_into_buffer(message_filename, buffer, BUFFER_SIZE, 1);
    if (filesize < MIN_MESSAGE_SIZE || filesize > MAX_MESSAGE_SIZE) {
        success = 0;
    } else {
        buffer_init(&buf, buffer, filesize);
        buf.index += 24; // header
        for (int i = 0; i < MAX_MESSAGE_ENTRIES; i++) {
            struct lang_message_t *m = &lang_data.message_entries[i];
            m->type = buffer_read_i16(&buf);
            m->message_type = buffer_read_i16(&buf);
            buf.index += 2;
            m->x = buffer_read_i16(&buf);
            m->y = buffer_read_i16(&buf);
            m->width_blocks = buffer_read_i16(&buf);
            m->height_blocks = buffer_read_i16(&buf);
            m->image.id = buffer_read_i16(&buf);
            m->image.x = buffer_read_i16(&buf);
            m->image.y = buffer_read_i16(&buf);
            buf.index += 6; // unused image2 id, x, y
            m->title.x = buffer_read_i16(&buf);
            m->title.y = buffer_read_i16(&buf);
            m->subtitle.x = buffer_read_i16(&buf);
            m->subtitle.y = buffer_read_i16(&buf);
            buf.index += 4;
            m->video.x = buffer_read_i16(&buf);
            m->video.y = buffer_read_i16(&buf);
            buf.index += 14;
            m->urgent = buffer_read_i32(&buf);
            m->video.text = get_message_text(buffer_read_i32(&buf));
            buf.index += 4;
            m->title.text = get_message_text(buffer_read_i32(&buf));
            m->subtitle.text = get_message_text(buffer_read_i32(&buf));
            m->content.text = get_message_text(buffer_read_i32(&buf));
        }
        buffer_read_raw(&buf, &lang_data.message_data, MAX_MESSAGE_DATA);
        success = 1;
    }
    free(buffer);
    return success;
}

static int lang_load(int is_editor)
{
    if (is_editor) {
        return load_files(FILE_EDITOR_TEXT_ENG, FILE_EDITOR_MM_ENG);
    }
    return
        load_files(FILE_TEXT_ENG, FILE_MM_ENG) ||
        load_files(FILE_TEXT_ENG, FILE_MM_ENG);
}

static int reload_language(int is_editor, int reload_images)
{
    if (!lang_load(is_editor)) {
        if (is_editor) {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("'c3_map.eng' or 'c3_map_mm.eng' files not found or too large.", 0, 0));
        } else {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("'c3.eng' or 'c3_mm.eng' files not found or too large.", 0, 0));
        }
        return 0;
    }

    if (!image_load_climate(scenario.climate, is_editor, reload_images)) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("unable to load main graphics", 0, 0));
        return 0;
    }
    return 1;
}

static void exit_editor_to_main_menu(void)
{
    if (!reload_language(0, 0)) {
        return;
    }
    editor_active = 0;
    window_main_menu_show(1);
}

static void request_exit_editor(void)
{
    if (scenario.is_saved) {
        exit_editor_to_main_menu();
    } else {
        window_popup_dialog_show(POPUP_DIALOG_EDITOR_QUIT_WITHOUT_SAVING, exit_editor_to_main_menu, 1);
    }
}

static void menu_file_exit_editor(__attribute__((unused)) int param)
{
    clear_state();
    request_exit_editor();
}

static struct menu_item_t menu_file[] = {
    {7, 1, menu_file_new_map, 0, 0},
    {7, 2, menu_file_load_map, 0, 0},
    {7, 3, menu_file_save_map, 0, 0},
    {7, 4, menu_file_exit_editor, 0, 0},
};

static struct menu_bar_item_t top_menu_editor[] = {
    {7, menu_file, 4, 0, 0, 0, 0},
    {2, menu_options, 3, 0, 0, 0, 0},
    {3, menu_help, 2, 0, 0, 0, 0},
    {10, menu_resets, 4, 0, 0, 0, 0},
};

static void draw_background_editor_map(void)
{
    graphics_clear_screen();
    int image_base = image_data_s.group_image_ids[GROUP_EDITOR_SIDE_PANEL];
    int x_offset = screen_data.width - SIDEBAR_EXPANDED_WIDTH;
    image_draw(image_base, x_offset, TOP_MENU_HEIGHT);
    image_buttons_draw(screen_data.width - SIDEBAR_EXPANDED_WIDTH, TOP_MENU_HEIGHT, buttons_build, sizeof(buttons_build) / sizeof(struct image_button_t));
    widget_minimap_draw(x_offset + 8, MINIMAP_Y_OFFSET_EDITOR, MINIMAP_WIDTH, MINIMAP_HEIGHT, 1);

    // draw status
    inner_panel_draw(x_offset + 1, 175, 10, 7);
    int text_offset = x_offset + 6;
    text_draw(editor_sidebar_menu_label_strings[tool_data.type], text_offset, 178, FONT_NORMAL_WHITE, 0);
    switch (tool_data.type) {
        case TOOL_GRASS:
        case TOOL_SMALL_SHRUB:
        case TOOL_MEDIUM_SHRUB:
        case TOOL_LARGE_SHRUB:
        case TOOL_LARGEST_SHRUB:
        case TOOL_WATER:
        case TOOL_TREES:
        case TOOL_SMALL_ROCK:
        case TOOL_MEDIUM_ROCK:
        case TOOL_LARGE_ROCK:
        case TOOL_MEADOW:
        case TOOL_RAISE_LAND:
        case TOOL_LOWER_LAND:
            lang_text_draw(48, tool_data.brush_size, text_offset, 194, FONT_NORMAL_GREEN);
            break;
        default:
            break;
    }
    int people_text;
    int people_font = FONT_NORMAL_RED;
    if (scenario.entry_point.x == -1) {
        if (scenario.exit_point.x == -1) {
            people_text = 60;
        } else {
            people_text = 59;
        }
    } else if (scenario.exit_point.x == -1) {
        people_text = 61;
    } else {
        people_text = 62;
        people_font = FONT_NORMAL_GREEN;
    }
    lang_text_draw(44, people_text, text_offset, 224, people_font);
    if (scenario.entry_point.x != -1 || scenario.exit_point.x != -1) {
        if (scenario.entry_point.x == -1) {
            lang_text_draw(44, 137, text_offset, 239, FONT_NORMAL_RED);
        } else if (scenario.exit_point.x == -1) {
            lang_text_draw(44, 138, text_offset, 239, FONT_NORMAL_RED);
        } else {
            lang_text_draw(44, 67, text_offset, 239, FONT_NORMAL_GREEN);
        }
    }
    int invasion_points = 0;
    for (int i = 0; i < MAX_INVASION_POINTS; i++) {
        if (scenario.invasion_points[i].x != -1) {
            invasion_points++;
        }
    }
    if (invasion_points == 1) {
        lang_text_draw(44, 64, text_offset, 254, FONT_NORMAL_GREEN);
    } else if (invasion_points > 1) {
        int width = text_draw_number(invasion_points, '@', " ", text_offset - 2, 254, FONT_NORMAL_GREEN);
        lang_text_draw(44, 65, text_offset + width - 8, 254, FONT_NORMAL_GREEN);
    } else {
        if (scenario.invasions[0].type) {
            lang_text_draw(44, 63, text_offset, 254, FONT_NORMAL_RED);
        }
    }
    sidebar_common_draw_relief(x_offset, SIDEBAR_FILLER_Y_OFFSET, GROUP_EDITOR_SIDE_PANEL, 0);
    // draw top menu
    int block_width = 24;
    image_base = image_data_s.group_image_ids[GROUP_TOP_MENU];
    int s_width = screen_data.width;
    for (int i = 0; i * block_width < s_width; i++) {
        image_draw(image_base + i % 8, i * block_width, 0);
    }
    menu_bar_draw(top_menu_editor, sizeof(top_menu_editor) / sizeof(struct menu_bar_item_t), s_width);
}

static void draw_foreground_editor_map(void)
{
    image_buttons_draw(screen_data.width - SIDEBAR_EXPANDED_WIDTH, TOP_MENU_HEIGHT, buttons_build, sizeof(buttons_build) / sizeof(struct image_button_t));
    widget_minimap_draw(screen_data.width - SIDEBAR_EXPANDED_WIDTH + 8, MINIMAP_Y_OFFSET_EDITOR, MINIMAP_WIDTH, MINIMAP_HEIGHT, 0);
    draw_editor_map();
}

static int game_undo_start_build(int type)
{
    undo_data.ready = 0;
    undo_data.available = 1;
    undo_data.timeout_ticks = 0;
    undo_data.building_cost = 0;
    undo_data.type = type;
    clear_buildings();
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_UNDO) {
            undo_data.available = 0;
            return 0;
        }
        if (b->state == BUILDING_STATE_DELETED_BY_PLAYER) {
            undo_data.available = 0;
        }
    }
    memcpy(images_backup.items, images.items, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
    memcpy(terrain_grid_backup.items, terrain_grid.items, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
    memcpy(aqueduct_backup.items, aqueduct.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memcpy(bitfields_backup.items, bitfields_grid.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memcpy(edge_backup.items, edge_grid.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memcpy(sprite_backup.items, sprite.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    return 1;
}

static void scroll_drag_start(void)
{
    if (scroll_data.drag.active || values[CONFIG_UI_DISABLE_RIGHT_CLICK_MAP_DRAG]) {
        return;
    }
    scroll_data.drag.active = 1;
    scroll_data.drag.delta.x = 0;
    scroll_data.drag.delta.y = 0;
    SDL_GetRelativeMouseState(0, 0);
    clear_scroll_speed();
}

static void update_terrain_after_elevation_changes(void)
{
    // elevation is max 5, so we need 4 passes to fix the lot
    for (int level = 0; level < 4; level++) {
        int grid_offset = map_data.start_offset;
        for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
            for (int x = 0; x < map_data.width; x++, grid_offset++) {
                if (terrain_elevation.items[grid_offset] > 0) {
                    // reduce elevation when the surrounding tiles are at least 2 lower
                    int max = terrain_elevation.items[grid_offset] - 1;
                    if (terrain_elevation.items[grid_offset + map_grid_delta(-1, 0)] < max ||
                        terrain_elevation.items[grid_offset + map_grid_delta(0, -1)] < max ||
                        terrain_elevation.items[grid_offset + map_grid_delta(1, 0)] < max ||
                        terrain_elevation.items[grid_offset + map_grid_delta(0, 1)] < max) {
                        terrain_elevation.items[grid_offset]--;
                    }
                }
            }
        }
    }
    clear_current_offset(context_pointers[CONTEXT_WATER].context, context_pointers[CONTEXT_WATER].size);
    clear_current_offset(context_pointers[CONTEXT_ELEVATION].context, context_pointers[CONTEXT_ELEVATION].size);
    map_tiles_update_all_elevation();
    map_tiles_update_all_empty_land();
    scenario.is_saved = 0;
}

static void callback_calc_distance_build_wall(int next_offset, int dist)
{
    if (terrain_land_citizen.items[next_offset] == CITIZEN_4_CLEAR_TERRAIN) {
        enqueue(next_offset, dist);
    }
}

static int map_can_place_aqueduct_on_road(int grid_offset)
{
    int image_id = images.items[grid_offset] - image_data_s.group_image_ids[GROUP_TERRAIN_ROAD];
    if (image_id != 0 && image_id != 1 && image_id != 49 && image_id != 50) {
        return 0;
    }
    int check_y = image_id == 0 || image_id == 49;
    if (view_data.orientation == DIR_6_LEFT || view_data.orientation == DIR_2_RIGHT) {
        check_y = !check_y;
    }
    if (check_y) {
        if (routing_distance.items[grid_offset + map_grid_delta(0, -1)] > 0 ||
            routing_distance.items[grid_offset + map_grid_delta(0, 1)] > 0) {
            return 0;
        }
    } else {
        if (routing_distance.items[grid_offset + map_grid_delta(-1, 0)] > 0 ||
            routing_distance.items[grid_offset + map_grid_delta(1, 0)] > 0) {
            return 0;
        }
    }
    return 1;
}

static void callback_calc_distance_build_aqueduct(int next_offset, int dist)
{
    int blocked = 0;
    switch (terrain_land_citizen.items[next_offset]) {
        case CITIZEN_N3_AQUEDUCT:
        case CITIZEN_2_PASSABLE_TERRAIN: // rubble, garden, access ramp
        case CITIZEN_N1_BLOCKED: // non-empty land
            blocked = 1;
            break;
        default:
            if (map_terrain_is(next_offset, TERRAIN_BUILDING)) {
                if (terrain_land_citizen.items[next_offset] != CITIZEN_N4_RESERVOIR_CONNECTOR) {
                    blocked = 1;
                }
            }
            break;
    }
    if (map_terrain_is(next_offset, TERRAIN_ROAD) && !map_can_place_aqueduct_on_road(next_offset)) {
        routing_distance.items[next_offset] = -1;
        blocked = 1;
    }
    if (!blocked) {
        enqueue(next_offset, dist);
    }
}

static void callback_calc_distance_build_road(int next_offset, int dist)
{
    int blocked = 0;
    switch (terrain_land_citizen.items[next_offset]) {
        case CITIZEN_N3_AQUEDUCT:
            if (!map_can_place_road_under_aqueduct(next_offset)) {
                routing_distance.items[next_offset] = -1;
                blocked = 1;
            }
            break;
        case CITIZEN_2_PASSABLE_TERRAIN: // rubble, garden, access ramp
        case CITIZEN_N1_BLOCKED: // non-empty land
            blocked = 1;
            break;
        default:
            if (map_terrain_is(next_offset, TERRAIN_BUILDING)) {
                blocked = 1;
            }
            break;
    }
    if (!blocked) {
        enqueue(next_offset, dist);
    }
}

static int map_routing_calculate_distances_for_building(int type, int x, int y)
{
    if (type == ROUTED_BUILDING_WALL) {
        route_queue(map_grid_offset(x, y), -1, callback_calc_distance_build_wall);
        return 1;
    }
    memset(routing_distance.items, 0, GRID_SIZE * GRID_SIZE * sizeof(int16_t));
    int source_offset = map_grid_offset(x, y);
    int can_place_init_road_or_aqueduct = 1;
    if (terrain_land_citizen.items[source_offset] == CITIZEN_N1_BLOCKED) {
        // not open land, can only if:
        // - aqueduct should be placed, and:
        // - land is a reservoir building OR an aqueduct
        if (!type != ROUTED_BUILDING_ROAD) {
            can_place_init_road_or_aqueduct = 0;
        } else if (map_terrain_is(source_offset, TERRAIN_AQUEDUCT)) {
            can_place_init_road_or_aqueduct = 1;
        } else if (map_terrain_is(source_offset, TERRAIN_BUILDING)) {
            if (all_buildings[map_building_at(source_offset)].type == BUILDING_RESERVOIR) {
                can_place_init_road_or_aqueduct = 1;
            }
        } else {
            can_place_init_road_or_aqueduct = 0;
        }
    } else if (terrain_land_citizen.items[source_offset] == CITIZEN_2_PASSABLE_TERRAIN) {
        // rubble, access ramp, garden
        can_place_init_road_or_aqueduct = 0;
    } else if (terrain_land_citizen.items[source_offset] == CITIZEN_N3_AQUEDUCT) {
        if (type != ROUTED_BUILDING_ROAD) {
            can_place_init_road_or_aqueduct = 0;
        } else if (map_can_place_road_under_aqueduct(source_offset)) {
            can_place_init_road_or_aqueduct = 1;
        } else {
            can_place_init_road_or_aqueduct = 0;
        }
    }
    if (!can_place_init_road_or_aqueduct) {
        return 0;
    }
    if (map_terrain_is(source_offset, TERRAIN_ROAD) &&
        type != ROUTED_BUILDING_ROAD && !map_can_place_aqueduct_on_road(source_offset)) {
        return 0;
    }
    ++stats.total_routes_calculated;
    if (type == ROUTED_BUILDING_ROAD) {
        route_queue(source_offset, -1, callback_calc_distance_build_road);
    } else {
        route_queue(source_offset, -1, callback_calc_distance_build_aqueduct);
    }
    return 1;
}

static int place_routed_building(int x_start, int y_start, int x_end, int y_end, int type, int *items)
{
    static   int direction_indices[8][4] = {
        {0, 2, 6, 4},
        {0, 2, 6, 4},
        {2, 4, 0, 6},
        {2, 4, 0, 6},
        {4, 6, 2, 0},
        {4, 6, 2, 0},
        {6, 0, 4, 2},
        {6, 0, 4, 2}
    };
    *items = 0;
    int grid_offset = map_grid_offset(x_end, y_end);
    int guard = 0;
    // reverse routing
    while (1) {
        if (++guard >= 400) {
            return 0;
        }
        int distance = routing_distance.items[grid_offset];
        if (distance <= 0) {
            return 0;
        }
        switch (type) {
            case ROUTED_BUILDING_ROAD:
                if (!map_terrain_is(grid_offset, TERRAIN_ROAD)) {
                    *items += 1;
                }
                terrain_grid.items[grid_offset] |= TERRAIN_ROAD;
                bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
                foreach_region_tile(x_end - 1, y_end - 1, x_end + 1, y_end + 1, set_road_image);
                break;
            case ROUTED_BUILDING_WALL:
                if (!map_terrain_is(grid_offset, TERRAIN_WALL)) {
                    *items += 1;
                }
                terrain_grid.items[grid_offset] = TERRAIN_WALL;
                bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
                foreach_region_tile(x_end - 1, y_end - 1, x_end + 1, y_end + 1, set_wall_image);
                break;
            case ROUTED_BUILDING_AQUEDUCT:
                terrain_grid.items[grid_offset] |= TERRAIN_AQUEDUCT;
                bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
                break;
            case ROUTED_BUILDING_AQUEDUCT_WITHOUT_GRAPHIC:
                *items += 1;
                break;
        }
        int direction = calc_general_direction(x_end, y_end, x_start, y_start);
        if (direction == DIR_8_NONE) {
            return 1; // destination reached
        }
        int routed = 0;
        for (int i = 0; i < 4; i++) {
            int index = direction_indices[direction][i];
            int new_grid_offset = grid_offset + map_grid_direction_delta(index);
            int new_dist = routing_distance.items[new_grid_offset];
            if (new_dist > 0 && new_dist < distance) {
                grid_offset = new_grid_offset;
                x_end = map_grid_offset_to_x(grid_offset);
                y_end = map_grid_offset_to_y(grid_offset);
                routed = 1;
                break;
            }
        }
        if (!routed) {
            return 0;
        }
    }
}

static int building_construction_place_road(int measure_only, int x_start, int y_start, int x_end, int y_end)
{
    game_undo_restore_map(0);
    int start_offset = map_grid_offset(x_start, y_start);
    int end_offset = map_grid_offset(x_end, y_end);
    int forbidden_terrain_mask =
        TERRAIN_SHRUB | TERRAIN_ROCK | TERRAIN_WATER |
        TERRAIN_TREE | TERRAIN_GARDEN | TERRAIN_ELEVATION |
        TERRAIN_RUBBLE | TERRAIN_BUILDING | TERRAIN_WALL;
    if (map_terrain_is(start_offset, forbidden_terrain_mask)) {
        return 0;
    }
    if (map_terrain_is(end_offset, forbidden_terrain_mask)) {
        return 0;
    }
    int items_placed = 0;
    if (map_routing_calculate_distances_for_building(ROUTED_BUILDING_ROAD, x_start, y_start) &&
            place_routed_building(x_start, y_start, x_end, y_end, ROUTED_BUILDING_ROAD, &items_placed)) {
        if (!measure_only) {
            map_routing_update_land();
            window_invalidate();
        }
    }
    return items_placed;
}

static void end_editor_tool_use(struct map_tile_t *tile)
{
    if (!tool_data.build_in_progress) {
        return;
    }
    tool_data.build_in_progress = 0;
    if (!tile->grid_offset) {
        return;
    }

    int warning = 0;
    switch (tool_data.type) {
        case TOOL_ENTRY_POINT:
            if (can_place_flag_editor(tool_data.type, tile, &warning)) {
                scenario.entry_point.x = tile->x;
                scenario.entry_point.y = tile->y;
            }
            break;
        case TOOL_EXIT_POINT:
            if (can_place_flag_editor(tool_data.type, tile, &warning)) {
                scenario.exit_point.x = tile->x;
                scenario.exit_point.y = tile->y;
            }
            break;
        case TOOL_RIVER_ENTRY_POINT:
            if (can_place_flag_editor(tool_data.type, tile, &warning)) {
                scenario.river_entry_point.x = tile->x;
                scenario.river_entry_point.y = tile->y;
                figure_create_flotsam();
                map_routing_update_water();
            }
            break;
        case TOOL_RIVER_EXIT_POINT:
            if (can_place_flag_editor(tool_data.type, tile, &warning)) {
                scenario.river_exit_point.x = tile->x;
                scenario.river_exit_point.y = tile->y;
                figure_create_flotsam();
                map_routing_update_water();
            }
            break;
        case TOOL_EARTHQUAKE_POINT:
            if (can_place_flag_editor(tool_data.type, tile, &warning)) {
                scenario.earthquake_points[tool_data.id].x = tile->x;
                scenario.earthquake_points[tool_data.id].y = tile->y;
                window_data.refresh_on_draw = 1;
            }
            break;
        case TOOL_INVASION_POINT:
            if (can_place_flag_editor(tool_data.type, tile, &warning)) {
                scenario.invasion_points[tool_data.id].x = tile->x;
                scenario.invasion_points[tool_data.id].y = tile->y;
            }
            break;
        case TOOL_FISHING_POINT:
            if (can_place_flag_editor(tool_data.type, tile, &warning)) {
                scenario.fishing_points[tool_data.id].x = tile->x;
                scenario.fishing_points[tool_data.id].y = tile->y;
            }
            break;
        case TOOL_HERD_POINT:
            if (can_place_flag_editor(tool_data.type, tile, &warning)) {
                scenario.herd_points[tool_data.id].x = tile->x;
                scenario.herd_points[tool_data.id].y = tile->y;
            }
            break;
        case TOOL_NATIVE_CENTER:
        case TOOL_NATIVE_FIELD:
        case TOOL_NATIVE_HUT:
        case TOOL_HOUSE_VACANT_LOT:
        {
            int image_id;
            int size;
            int type;
            switch (tool_data.type) {
                case TOOL_NATIVE_HUT:
                    type = BUILDING_NATIVE_HUT;
                    image_id = image_data_s.group_image_ids[GROUP_EDITOR_BUILDING_NATIVE] + (random_data.random1_7bit & 1);
                    size = 1;
                    break;
                case TOOL_NATIVE_CENTER:
                    type = BUILDING_NATIVE_MEETING;
                    image_id = image_data_s.group_image_ids[GROUP_EDITOR_BUILDING_NATIVE] + 2;
                    size = 2;
                    break;
                case TOOL_NATIVE_FIELD:
                    type = BUILDING_NATIVE_CROPS;
                    image_id = image_data_s.group_image_ids[GROUP_EDITOR_BUILDING_CROPS];
                    size = 1;
                    break;
                case TOOL_HOUSE_VACANT_LOT:
                    type = BUILDING_HOUSE_VACANT_LOT;
                    image_id = image_data_s.group_image_ids[GROUP_EDITOR_BUILDING_NATIVE] - 4;
                    size = 1;
                    break;
                default:
                    return;
            }
            if (can_place_building_editor(tile, size * size, 0)) {
                struct building_t *b = building_create(type, tile->x, tile->y);
                map_building_tiles_add(b->id, tile->x, tile->y, size, image_id, TERRAIN_BUILDING);
                scenario.is_saved = 0;
            } else {
                city_warning_show(WARNING_EDITOR_CANNOT_PLACE);
            }
            break;
        }
        case TOOL_RAISE_LAND:
        case TOOL_LOWER_LAND:
            update_terrain_after_elevation_changes();
            break;
        case TOOL_ACCESS_RAMP:
        {
            int orientation = 0;
            if (can_place_access_ramp_editor(tile, &orientation)) {
                int terrain_mask = ~(TERRAIN_ROCK | TERRAIN_WATER | TERRAIN_BUILDING | TERRAIN_GARDEN | TERRAIN_AQUEDUCT);
                for (int dy = 0; dy < 2; dy++) {
                    for (int dx = 0; dx < 2; dx++) {
                        int grid_offset = tile->grid_offset + map_grid_delta(dx, dy);
                        terrain_grid.items[grid_offset] = terrain_grid.items[grid_offset] & terrain_mask;
                    }
                }
                map_building_tiles_add(0, tile->x, tile->y, 2,
                    image_data_s.group_image_ids[GROUP_TERRAIN_ACCESS_RAMP] + orientation, TERRAIN_ACCESS_RAMP);

                update_terrain_after_elevation_changes();
                scenario.is_saved = 0;
            } else {
                city_warning_show(WARNING_EDITOR_CANNOT_PLACE);
            }
            break;
        case TOOL_ROAD:
            building_construction_place_road(0, tool_data.start_tile.x, tool_data.start_tile.y, tile->x, tile->y);
            break;
        default:
            break;
        }
    }
    scenario.is_saved = 0;
    if (warning) {
        city_warning_show(warning);
    }
}

static int scroll_drag_end(void)
{
    if (!scroll_data.drag.active) {
        return 0;
    }
    int has_scrolled = scroll_data.drag.has_started;
    scroll_data.drag.active = 0;
    scroll_data.drag.has_started = 0;
    set_relative_mouse_mode(0);
    scroll_data.x_align_direction = speed_get_current_direction(&scroll_data.speed.x);
    scroll_data.y_align_direction = speed_get_current_direction(&scroll_data.speed.y);
    speed_set_target(&scroll_data.speed.x, 0, SPEED_CHANGE_IMMEDIATE, 1);
    speed_set_target(&scroll_data.speed.y, 0, SPEED_CHANGE_IMMEDIATE, 1);
    return has_scrolled;
}

static void editor_tool_deactivate(void)
{
    if (tool_data.type == TOOL_ROAD && tool_data.build_in_progress) {
        game_undo_restore_map(1);
        tool_data.build_in_progress = 0;
    } else {
        tool_data.active = 0;
    }
}

static void place_rock_at(int x, int y, int grid_offset, int size)
{
    int x_size_adjusted = size > 1 ? size - 1 : size; // use x - 1 for medium/large rocks; technically causes image overlap but looks better
    // check if all needed tiles are clear and within the map grid
    for (int dy = 0; dy < size; dy++) {
        for (int dx = 0; dx < size; dx++) { // separate full x-size check to avoid protrusion beyond the map grid
            if (!map_grid_is_inside(x + dx, y - dy, 1)) {
                return;
            }
        }
        for (int dx = 0; dx < x_size_adjusted; dx++) {
            if (map_terrain_is(map_grid_offset(x + dx, y - dy), TERRAIN_NOT_DISPLACEABLE)) {
                return;
            }
        }
    }
    // set terrain rock for all covered tiles
    for (int dy = 0; dy < size; dy++) {
        for (int dx = 0; dx < x_size_adjusted; dx++) {
            terrain_grid.items[map_grid_offset(x + dx, y - dy)] = TERRAIN_ROCK;
        }
    }
    // set multitile rock image
    int image_id;
    if (size == 1) { // small rock
        image_id = random.items[grid_offset] & 7;
    } else if (size == 2) { // medium rock
        image_id = 8 + (random.items[grid_offset] & 3);
    } else { // large rock
        image_id = 12 + (random.items[grid_offset] & 1);
    }
    if (map_terrain_exists_tile_in_radius_with_type(x, y, size, 4, TERRAIN_ELEVATION)) {
        image_id += image_data_s.group_image_ids[GROUP_TERRAIN_ELEVATION_ROCK];
    } else {
        image_id += image_data_s.group_image_ids[GROUP_TERRAIN_ROCK];
    }
    images.items[grid_offset] = image_id;
}

static void add_terrain_at(int x, int y)
{
    if (!map_grid_is_inside(x, y, 1)) {
        return;
    }
    int grid_offset = map_grid_offset(x, y);
    int shrub_rnd = random.items[grid_offset] & 7;
    int elevation = terrain_elevation.items[grid_offset];
    switch (tool_data.type) {
        case TOOL_GRASS:
            if (!map_terrain_is(grid_offset, TERRAIN_ELEVATION | TERRAIN_ACCESS_RAMP)) {
                if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
                    map_building_tiles_remove(0, x, y);
                }
                terrain_grid.items[grid_offset] = 0;
            }
            break;
        case TOOL_SMALL_SHRUB:
            if (!map_terrain_is(grid_offset, TERRAIN_NOT_DISPLACEABLE)) {
                terrain_grid.items[grid_offset] = TERRAIN_SHRUB;
                images.items[grid_offset] = image_data_s.group_image_ids[GROUP_TERRAIN_SHRUB] + shrub_rnd;
            }
            break;
        case TOOL_MEDIUM_SHRUB:
            if (!map_terrain_is(grid_offset, TERRAIN_NOT_DISPLACEABLE)) {
                terrain_grid.items[grid_offset] = TERRAIN_SHRUB;
                images.items[grid_offset] = image_data_s.group_image_ids[GROUP_TERRAIN_SHRUB] + shrub_rnd + 8;
            }
            break;
        case TOOL_LARGE_SHRUB:
            if (!map_terrain_is(grid_offset, TERRAIN_NOT_DISPLACEABLE)) {
                terrain_grid.items[grid_offset] = TERRAIN_SHRUB;
                images.items[grid_offset] = image_data_s.group_image_ids[GROUP_TERRAIN_SHRUB] + shrub_rnd + 16;
            }
            break;
        case TOOL_LARGEST_SHRUB:
            if (!map_terrain_is(grid_offset, TERRAIN_NOT_DISPLACEABLE)) {
                terrain_grid.items[grid_offset] = TERRAIN_SHRUB;
                images.items[grid_offset] = image_data_s.group_image_ids[GROUP_TERRAIN_SHRUB] + shrub_rnd + 24;
            }
            break;
        case TOOL_SMALL_ROCK:
            place_rock_at(x, y, grid_offset, 1);
            break;
        case TOOL_MEDIUM_ROCK:
            place_rock_at(x, y, grid_offset, 2);
            break;
        case TOOL_LARGE_ROCK:
            place_rock_at(x, y, grid_offset, 3);
            break;
        case TOOL_WATER:
            if (!map_terrain_is(grid_offset, TERRAIN_NOT_DISPLACEABLE)) {
                terrain_grid.items[grid_offset] = TERRAIN_WATER;
            }
            break;
        case TOOL_TREES:
            if (!map_terrain_is(grid_offset, TERRAIN_NOT_DISPLACEABLE)) {
                terrain_grid.items[grid_offset] = TERRAIN_TREE;
                images.items[grid_offset] = image_data_s.group_image_ids[GROUP_TERRAIN_TREE] + (random.items[grid_offset] & 7);
            }
            break;
        case TOOL_MEADOW:
            if (!map_terrain_is(grid_offset, TERRAIN_NOT_DISPLACEABLE)) {
                terrain_grid.items[grid_offset] = TERRAIN_MEADOW;
                // dupl with set_meadow_image
                int image_id = image_data_s.group_image_ids[GROUP_TERRAIN_MEADOW];
                if (map_terrain_all_tiles_in_radius_are(x, y, 1, 2, TERRAIN_MEADOW)) {
                    images.items[grid_offset] = image_id + (random.items[grid_offset] & 3) + 8;
                } else if (map_terrain_all_tiles_in_radius_are(x, y, 1, 1, TERRAIN_MEADOW)) {
                    images.items[grid_offset] = image_id + (random.items[grid_offset] & 3) + 4;
                } else {
                    images.items[grid_offset] = image_id + (random.items[grid_offset] & 3);
                }
            }
            break;
        case TOOL_RAISE_LAND:
            if (elevation < 5 && elevation == tool_data.start_elevation) {
                map_property_set_multi_tile_size(grid_offset, 1);
                terrain_elevation.items[grid_offset] = elevation + 1;
                terrain_grid.items[grid_offset] = TERRAIN_ELEVATION;
            }
            break;
        case TOOL_LOWER_LAND:
            if (elevation == tool_data.start_elevation) {
                if (elevation == 1) {
                    terrain_elevation.items[grid_offset] = 0;
                    terrain_grid.items[grid_offset] = 0;
                } else if (elevation) {
                    terrain_elevation.items[grid_offset] = elevation - 1;
                    terrain_grid.items[grid_offset] = TERRAIN_ELEVATION;
                }
            }
            break;
        default:
            break;
    }
}

static void show_editor_top_menu_window(void);
static void handle_input_top_menu_editor(struct mouse_t *m, struct hotkeys_t *h)
{
    if (open_sub_menu_top_menu_editor) {
        if (m->right.went_up || h->escape_pressed) {
            clear_state();
            window_go_back();
            return;
        }
        int menu_id = menu_bar_handle_mouse(m, top_menu_editor, sizeof(top_menu_editor) / sizeof(struct menu_bar_item_t), &focus_menu_id_top_menu_editor);
        if (menu_id && menu_id != open_sub_menu_top_menu_editor) {
            window_data.refresh_on_draw = 1;
            open_sub_menu_top_menu_editor = menu_id;
        }
        if (!menu_handle_mouse(m, &top_menu_editor[open_sub_menu_top_menu_editor - 1], &focus_sub_menu_id_top_menu_editor)) {
            if (m->left.went_up) {
                clear_state();
                window_go_back();
                return;
            }
        }
    } else {
        int menu_id = menu_bar_handle_mouse(m, top_menu_editor, sizeof(top_menu_editor) / sizeof(struct menu_bar_item_t), &focus_menu_id_top_menu_editor);
        if (menu_id && m->left.went_up) {
            open_sub_menu_top_menu_editor = menu_id;
            show_editor_top_menu_window();
        }
    }
}

static void handle_input_editor_map(struct mouse_t *m, struct hotkeys_t *h)
{
    if (h->load_file) {
        window_file_dialog_show(FILE_TYPE_SCENARIO, FILE_DIALOG_LOAD);
        return;
    }
    if (h->save_file) {
        window_file_dialog_show(FILE_TYPE_SCENARIO, FILE_DIALOG_SAVE);
        return;
    }
    if (h->show_empire_map) {
        show_editor_empire(0, 0);
        return;
    }
    if (widget_minimap_handle_mouse(m)) {
        return;
    }
    if (image_buttons_handle_mouse(m, screen_data.width - SIDEBAR_EXPANDED_WIDTH, 24, buttons_build, sizeof(buttons_build) / sizeof(struct image_button_t), 0)) {
        return;
    }
    int x_offset, y_offset, width, height;
    city_view_get_viewport(&x_offset, &y_offset, &width, &height);
    if (m->right.went_down
    && (m->x - x_offset >= 0 && m->x - x_offset < width && m->y - y_offset >= 0 && m->y - y_offset < height) // mouse on map
    && !tool_data.active) {
        scroll_drag_start();
    }

    struct map_tile_t *tile = &current_tile;
    update_city_view_coords(m->x, m->y, tile);
    if (m->left.went_up && tool_data.build_in_progress) {
        end_editor_tool_use(tile);
        play_sound_effect(SOUND_EFFECT_BUILD);
    }
    if (m->right.went_up) {
        if (!tool_data.active) {
            int has_scrolled = scroll_drag_end();
            if (!has_scrolled) {
                editor_tool_deactivate();
            }
        } else {
            editor_tool_deactivate();
            end_editor_tool_use(tile);
        }
    }
    if (h->escape_pressed) {
        if (tool_data.active) {
            editor_tool_deactivate();
            end_editor_tool_use(tile);
        } else {
            request_exit_editor();
        }
    }
    if (tool_data.active && tile->grid_offset) {
        if (m->left.went_down) {
            if (!tool_data.build_in_progress) {
                // start tool use
                tool_data.build_in_progress = 1;
                tool_data.start_elevation = terrain_elevation.items[tile->grid_offset];
                tool_data.start_tile = *tile;
                if (tool_data.type == TOOL_ROAD) {
                    game_undo_start_build(BUILDING_ROAD);
                    map_routing_update_land();
                }
            }
        } else if (m->left.is_down || tool_data.build_in_progress) {
            if (tool_data.type == TOOL_ROAD) {
                building_construction_place_road(1, tool_data.start_tile.x, tool_data.start_tile.y, tile->x, tile->y);
                return;
            }
            switch (tool_data.type) {
                case TOOL_GRASS:
                case TOOL_SMALL_SHRUB:
                case TOOL_MEDIUM_SHRUB:
                case TOOL_LARGE_SHRUB:
                case TOOL_LARGEST_SHRUB:
                case TOOL_WATER:
                case TOOL_TREES:
                case TOOL_SMALL_ROCK:
                case TOOL_MEDIUM_ROCK:
                case TOOL_LARGE_ROCK:
                case TOOL_MEADOW:
                case TOOL_RAISE_LAND:
                case TOOL_LOWER_LAND:
                    break;
                default:
                    return;
            }
            add_terrain_at(tile->x, tile->y);
            int tiles_remaining = tool_data.brush_size;
            while (tiles_remaining) {
                for (int i = 1; i <= tiles_remaining; i++) {
                    add_terrain_at(tile->x + (tool_data.brush_size - tiles_remaining), tile->y - i); // top to right
                    add_terrain_at(tile->x + i, tile->y + (tool_data.brush_size - tiles_remaining)); // right to bottom
                    add_terrain_at(tile->x - (tool_data.brush_size - tiles_remaining), tile->y + i); // bottom to left
                    add_terrain_at(tile->x - i, tile->y - (tool_data.brush_size - tiles_remaining)); // left to top
                }
                tiles_remaining--;
            }
            int x_min = tile->x - tool_data.brush_size;
            int x_max = tile->x + tool_data.brush_size;
            int y_min = tile->y - tool_data.brush_size;
            int y_max = tile->y + tool_data.brush_size;
            clear_current_offset(context_pointers[CONTEXT_WATER].context, context_pointers[CONTEXT_WATER].size);
            foreach_region_tile(x_min, y_min, x_max, y_max, update_water_tile);
            switch (tool_data.type) {
                case TOOL_GRASS:
                    foreach_region_tile(x_min, y_min, x_max, y_max, update_water_tile);
                    map_tiles_update_region_empty_land(x_min, y_min, x_max, y_max);
                    break;
                case TOOL_RAISE_LAND:
                case TOOL_LOWER_LAND:
                    clear_current_offset(context_pointers[CONTEXT_WATER].context, context_pointers[CONTEXT_WATER].size);
                    clear_current_offset(context_pointers[CONTEXT_ELEVATION].context, context_pointers[CONTEXT_ELEVATION].size);
                    map_tiles_update_all_elevation();
                    foreach_region_tile(x_min, y_min, x_max, y_max, update_water_tile);
                    map_tiles_update_region_empty_land(x_min, y_min, x_max, y_max);
                    break;
                default:
                    break;
            }
            scenario.is_saved = 0;
            minimap_data.refresh_requested = 1;
        }
    }
    scroll_map(m);
    handle_input_top_menu_editor(m, h);
}

static void show_editor_map(void)
{
    struct window_type_t window = {
        WINDOW_EDITOR_MAP,
        draw_background_editor_map,
        draw_foreground_editor_map,
        handle_input_editor_map,
    };
    window_show(&window);
}

static int get_sidebar_x_offset_build_menu(void)
{
    int view_x, view_y, view_width, view_height;
    city_view_get_viewport(&view_x, &view_y, &view_width, &view_height);
    return view_x + view_width;
}

static int text_draw_money(int value, int x_offset, int y_offset, int font)
{
    char str[NUMBER_BUFFER_LENGTH];
    int money_len = number_to_string(str, value, '@', " ");
    char *postfix;
    postfix = lang_get_string(6, 0);
    string_copy(postfix, str + money_len, NUMBER_BUFFER_LENGTH - money_len - 1);
    return text_draw(str, x_offset, y_offset, font, 0);
}

static void draw_foreground_build_menu(void)
{
    widget_city_draw();
    int x_offset = get_sidebar_x_offset_build_menu();
    int item_x_align = x_offset - MENU_X_OFFSET_BUILD_MENU - 8;
    int n_skipped_items = 0;
    for (int j = 0; j < build_menu_data.num_items_to_draw; j++) {
        label_draw(item_x_align, build_menu_data.y_offset + MENU_Y_OFFSET_BUILD_MENU + MENU_ITEM_HEIGHT * j, 16, build_menu_data.focus_button_id == j + 1 ? 1 : 2);
        if (build_menu_data.selected_submenu > MENU_NONE) { // drawing items from a submenu
            for (int k = j + n_skipped_items; k < MAX_ITEMS_PER_SUBMENU; k++) { // draw next enabled item
                if (build_menus[build_menu_data.selected_menu].menu_items[build_menu_data.selected_submenu].submenu_items[k]) {
                    text_draw_centered(all_buildings_strings[build_menus[build_menu_data.selected_menu].menu_items[build_menu_data.selected_submenu].submenu_items[k]], item_x_align, build_menu_data.y_offset + MENU_Y_OFFSET_BUILD_MENU + 4 + MENU_ITEM_HEIGHT * j, MENU_ITEM_WIDTH, FONT_NORMAL_GREEN, COLOR_BLACK);
                    text_draw_money(building_properties[build_menus[build_menu_data.selected_menu].menu_items[build_menu_data.selected_submenu].submenu_items[k]].cost, x_offset - 82, build_menu_data.y_offset + MENU_Y_OFFSET_BUILD_MENU + 4 + MENU_ITEM_HEIGHT * j, FONT_NORMAL_GREEN);
                    break;
                } else {
                    n_skipped_items++;
                }
            }
        } else { // drawing items from a menu
            for (int k = j + n_skipped_items; k < MAX_ITEMS_PER_BUILD_MENU; k++) {
                if (build_menus[build_menu_data.selected_menu].menu_items[k].building_id) { // building or submenu is enabled
                    if (build_menus[build_menu_data.selected_menu].menu_items[k].building_id == -1) { // submenu item
                        text_draw_centered(build_menus[build_menu_data.selected_menu].menu_items[k].submenu_string, item_x_align, build_menu_data.y_offset + MENU_Y_OFFSET_BUILD_MENU + 4 + MENU_ITEM_HEIGHT * j, MENU_ITEM_WIDTH, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else { // building item
                        text_draw_centered(all_buildings_strings[build_menus[build_menu_data.selected_menu].menu_items[k].building_id], item_x_align, build_menu_data.y_offset + MENU_Y_OFFSET_BUILD_MENU + 4 + MENU_ITEM_HEIGHT * j, MENU_ITEM_WIDTH, FONT_NORMAL_GREEN, COLOR_BLACK);
                        text_draw_money(building_properties[build_menus[build_menu_data.selected_menu].menu_items[k].building_id].cost, x_offset - 82, build_menu_data.y_offset + MENU_Y_OFFSET_BUILD_MENU + 4 + MENU_ITEM_HEIGHT * j, FONT_NORMAL_GREEN);
                    }
                    break;
                } else {
                    n_skipped_items++;
                }
            }
        }
    }
}

static void select_building_type(int building_type)
{
    building_construction_set_type(building_type);
    build_menu_data.selected_menu = MENU_NONE;
    build_menu_data.selected_submenu = MENU_NONE;
    window_city_show();
}

static void button_submenu_or_building(int param1, __attribute__((unused)) int param2)
{
    int n_skipped_items = 0;
    if (build_menu_data.selected_submenu > MENU_NONE) { // selecting items from a submenu
        for (int k = 0; k < MAX_ITEMS_PER_SUBMENU; k++) { // select next enabled item
            if (build_menus[build_menu_data.selected_menu].menu_items[build_menu_data.selected_submenu].submenu_items[k]) {
                if (k - n_skipped_items >= param1) {
                    select_building_type(build_menus[build_menu_data.selected_menu].menu_items[build_menu_data.selected_submenu].submenu_items[k]);
                    break;
                }
            } else {
                n_skipped_items++;
            }
        }
    } else { // selecting items from a menu
        for (int j = 0; j < MAX_ITEMS_PER_BUILD_MENU; j++) { // select next enabled item
            if (build_menus[build_menu_data.selected_menu].menu_items[j].building_id) { // building or submenu is enabled
                if (j - n_skipped_items >= param1) { // align button index with item
                    if (build_menus[build_menu_data.selected_menu].menu_items[j].building_id == -1) { // submenu item
                        build_menu_data.selected_submenu = j;
                        build_menu_data.num_items_to_draw = 0;
                        for (int k = 0; k < MAX_ITEMS_PER_SUBMENU; k++) {
                            if (build_menus[build_menu_data.selected_menu].menu_items[j].submenu_items[k]) {
                                build_menu_data.num_items_to_draw++;
                            }
                        }
                    } else { // building item
                        select_building_type(build_menus[build_menu_data.selected_menu].menu_items[j].building_id);
                    }
                    break;
                }
            } else {
                n_skipped_items++;
            }
        }
    }
}

static struct generic_button_t build_menu_buttons[MAX_ITEMS_PER_BUILD_MENU] = {
    {0, 0, 256, 20, button_submenu_or_building, button_none, 0, 0},
    {0, 24, 256, 20, button_submenu_or_building, button_none, 1, 0},
    {0, 48, 256, 20, button_submenu_or_building, button_none, 2, 0},
    {0, 72, 256, 20, button_submenu_or_building, button_none, 3, 0},
    {0, 96, 256, 20, button_submenu_or_building, button_none, 4, 0},
    {0, 120, 256, 20, button_submenu_or_building, button_none, 5, 0},
    {0, 144, 256, 20, button_submenu_or_building, button_none, 6, 0},
    {0, 168, 256, 20, button_submenu_or_building, button_none, 7, 0},
    {0, 192, 256, 20, button_submenu_or_building, button_none, 8, 0},
    {0, 216, 256, 20, button_submenu_or_building, button_none, 9, 0},
    {0, 240, 256, 20, button_submenu_or_building, button_none, 10, 0},
};

static void handle_input_build_menu(struct mouse_t *m, struct hotkeys_t *h);

static void button_build_city_widget(int menu, __attribute__((unused)) int param2)
{
    if (menu == MENU_VACANT_HOUSE || menu == MENU_CLEAR_LAND || menu == MENU_ROAD) {
        building_construction_set_type(BUILDING_MENU_SUBMENU_ITEM_MAPPING[menu][0][0]);
    } else {
        if (menu == MENU_NONE || menu == build_menu_data.selected_menu) {
            window_build_menu_hide();
            return;
        }
        build_menu_data.selected_menu = menu;
        build_menu_data.selected_submenu = MENU_NONE;
        build_menu_data.num_items_to_draw = 0;
        for (int j = 0; j < MAX_ITEMS_PER_BUILD_MENU; j++) {
            if (build_menus[menu].menu_items[j].building_id) {
                build_menu_data.num_items_to_draw++;
            }
        }
        build_menu_data.y_offset = Y_MENU_OFFSETS[build_menu_data.num_items_to_draw];
        struct window_type_t window = {
            WINDOW_BUILD_MENU,
            window_city_draw_background,
            draw_foreground_build_menu,
            handle_input_build_menu,
        };
        window_show(&window);
    }
}

static struct image_button_t buttons_build_collapsed[] = {
    {2, 32, 39, 26, IB_NORMAL, GROUP_SIDEBAR_BUTTONS, 0, button_build_city_widget, button_none, MENU_VACANT_HOUSE, 0, 1, 0, 0, 0},
    {2, 67, 39, 26, IB_NORMAL, GROUP_SIDEBAR_BUTTONS, 8, button_build_city_widget, button_none, MENU_CLEAR_LAND, 0, 1, 0, 0, 0},
    {2, 102, 39, 26, IB_NORMAL, GROUP_SIDEBAR_BUTTONS, 12, button_build_city_widget, button_none, MENU_ROAD, 0, 1, 0, 0, 0},
    {2, 137, 39, 26, IB_BUILD, GROUP_SIDEBAR_BUTTONS, 4, button_build_city_widget, button_none, MENU_WATER, 0, 1, 0, 0, 0},
    {2, 172, 39, 26, IB_BUILD, GROUP_SIDEBAR_BUTTONS, 40, button_build_city_widget, button_none, MENU_HEALTH, 0, 1, 0, 0, 0},
    {2, 207, 39, 26, IB_BUILD, GROUP_SIDEBAR_BUTTONS, 28, button_build_city_widget, button_none, MENU_TEMPLES, 0, 1, 0, 0, 0},
    {2, 242, 39, 26, IB_BUILD, GROUP_SIDEBAR_BUTTONS, 24, button_build_city_widget, button_none, MENU_EDUCATION, 0, 1, 0, 0, 0},
    {2, 277, 39, 26, IB_BUILD, GROUP_SIDEBAR_BUTTONS, 20, button_build_city_widget, button_none, MENU_ENTERTAINMENT, 0, 1, 0, 0, 0},
    {2, 312, 39, 26, IB_BUILD, GROUP_SIDEBAR_BUTTONS, 16, button_build_city_widget, button_none, MENU_ADMINISTRATION, 0, 1, 0, 0, 0},
    {2, 347, 39, 26, IB_BUILD, GROUP_SIDEBAR_BUTTONS, 44, button_build_city_widget, button_none, MENU_ENGINEERING, 0, 1, 0, 0, 0},
    {2, 382, 39, 26, IB_BUILD, GROUP_SIDEBAR_BUTTONS, 36, button_build_city_widget, button_none, MENU_SECURITY, 0, 1, 0, 0, 0},
    {2, 417, 39, 26, IB_BUILD, GROUP_SIDEBAR_BUTTONS, 32, button_build_city_widget, button_none, MENU_INDUSTRY, 0, 1, 0, 0, 0},
};

static void draw_buttons_collapsed(int x_offset)
{
    image_buttons_draw(x_offset, 24, button_expand_sidebar, 1);
    image_buttons_draw(x_offset, 24, buttons_build_collapsed, 12);
}

static void draw_sidebar_remainder(int x_offset, int is_collapsed)
{
    int width = SIDEBAR_EXPANDED_WIDTH;
    if (is_collapsed) {
        width = SIDEBAR_COLLAPSED_WIDTH;
    }
    int available_height = screen_data.height - TOP_MENU_HEIGHT - SIDEBAR_MAIN_SECTION_HEIGHT;
    extra_widget_data.is_collapsed = is_collapsed;
    extra_widget_data.x_offset = x_offset;
    extra_widget_data.y_offset = SIDEBAR_FILLER_Y_OFFSET;
    extra_widget_data.width = width;
    if (extra_widget_data.is_collapsed || !values[CONFIG_UI_SIDEBAR_INFO] || SIDEBAR_EXTRA_DISPLAY_ALL == SIDEBAR_EXTRA_DISPLAY_NONE) {
        extra_widget_data.info_to_display = SIDEBAR_EXTRA_DISPLAY_NONE;
    } else {
        if (available_height >= EXTRA_INFO_HEIGHT_GAME_SPEED) {
            if (SIDEBAR_EXTRA_DISPLAY_ALL & SIDEBAR_EXTRA_DISPLAY_GAME_SPEED) {
                available_height -= EXTRA_INFO_HEIGHT_GAME_SPEED;
                extra_widget_data.info_to_display |= SIDEBAR_EXTRA_DISPLAY_GAME_SPEED;
            }
        }
        if (available_height >= EXTRA_INFO_HEIGHT_UNEMPLOYMENT) {
            if (SIDEBAR_EXTRA_DISPLAY_ALL & SIDEBAR_EXTRA_DISPLAY_UNEMPLOYMENT) {
                available_height -= EXTRA_INFO_HEIGHT_UNEMPLOYMENT;
                extra_widget_data.info_to_display |= SIDEBAR_EXTRA_DISPLAY_UNEMPLOYMENT;
            }
        }
        if (available_height >= EXTRA_INFO_HEIGHT_RATINGS) {
            if (SIDEBAR_EXTRA_DISPLAY_ALL & SIDEBAR_EXTRA_DISPLAY_RATINGS) {
                extra_widget_data.info_to_display |= SIDEBAR_EXTRA_DISPLAY_RATINGS;
            }
        }
    }
    extra_widget_data.height = 0;
    if (extra_widget_data.info_to_display & SIDEBAR_EXTRA_DISPLAY_GAME_SPEED) {
        extra_widget_data.height += EXTRA_INFO_HEIGHT_GAME_SPEED;
    }
    if (extra_widget_data.info_to_display & SIDEBAR_EXTRA_DISPLAY_UNEMPLOYMENT) {
        extra_widget_data.height += EXTRA_INFO_HEIGHT_UNEMPLOYMENT;
    }
    if (extra_widget_data.info_to_display & SIDEBAR_EXTRA_DISPLAY_RATINGS) {
        extra_widget_data.height += EXTRA_INFO_HEIGHT_RATINGS;
    }
    if (extra_widget_data.info_to_display != SIDEBAR_EXTRA_DISPLAY_NONE) {
        update_extra_info(1);
        draw_extra_info_panel();
    }
    draw_extra_info_buttons();
    int relief_y_offset = SIDEBAR_FILLER_Y_OFFSET + extra_widget_data.height;
    sidebar_common_draw_relief(x_offset, relief_y_offset, GROUP_SIDE_PANEL, is_collapsed);
}

static void draw_collapsed_background(void)
{
    int x_offset = screen_data.width - SIDEBAR_COLLAPSED_WIDTH;
    image_draw(image_data_s.group_image_ids[GROUP_SIDE_PANEL], x_offset, 24);
    draw_buttons_collapsed(x_offset);
    draw_sidebar_remainder(x_offset, 1);
}

static void draw_expanded_background(int x_offset)
{
    image_draw(image_data_s.group_image_ids[GROUP_SIDE_PANEL] + 1, x_offset, 24);
    draw_buttons_expanded(x_offset);
    draw_overlay_text(x_offset + 4);
    draw_number_of_messages(x_offset);
    int image_base = image_data_s.group_image_ids[GROUP_PANEL_WINDOWS];
    switch (build_menu_data.selected_menu) {
        case MENU_CLEAR_LAND:
            if (scenario.climate == CLIMATE_DESERT) {
                image_base = image_data_s.group_image_ids[GROUP_PANEL_WINDOWS_DESERT];
            } else {
                image_base = image_base + 11;
            }
            break;
        case MENU_ROAD:
            if (scenario.climate == CLIMATE_DESERT) {
                image_base = image_data_s.group_image_ids[GROUP_PANEL_WINDOWS_DESERT] + 1;
            } else {
                image_base = image_base + 10;
            }
            break;
        case MENU_WATER:
            if (scenario.climate == CLIMATE_DESERT) {
                image_base = image_data_s.group_image_ids[GROUP_PANEL_WINDOWS_DESERT] + 2;
            } else {
                image_base = image_base + 3;
            }
            break;
        case MENU_HEALTH:
            image_base = image_base + 5;
            break;
        case MENU_TEMPLES:
            image_base = image_base + 1;
            break;
        case MENU_EDUCATION:
            image_base = image_base + 6;
            break;
        case MENU_ENTERTAINMENT:
            image_base = image_base + 4;
            break;
        case MENU_ADMINISTRATION:
            image_base = image_base + 2;
            break;
        case MENU_ENGINEERING:
            image_base = image_base + 7;
            break;
        case MENU_SECURITY:
            if (scenario.climate == CLIMATE_DESERT) {
                image_base = image_data_s.group_image_ids[GROUP_PANEL_WINDOWS_DESERT] + 3;
            } else {
                image_base = image_base + 8;
            }
            break;
        case MENU_INDUSTRY:
            image_base = image_base + 9;
            break;
        default:
            image_base = image_base + 12;
            break;
    }
    image_draw(image_base, x_offset + 6, 239);
    widget_minimap_draw(x_offset + 8, MINIMAP_Y_OFFSET, MINIMAP_WIDTH, MINIMAP_HEIGHT, 1);
    draw_sidebar_remainder(x_offset, 0);
}

static int get_sidebar_x_offset_overlay_menu(void)
{
    int view_x, view_y, view_width, view_height;
    city_view_get_viewport(&view_x, &view_y, &view_width, &view_height);
    return view_x + view_width;
}

static void draw_foreground_overlay_menu(void)
{
    widget_city_draw();
    int x_offset = get_sidebar_x_offset_overlay_menu();
    for (int i = 0; i < 8; i++) {
        label_draw(x_offset - 170, 74 + 24 * i, 10, overlay_menu_data.menu_focus_button_id == i + 1 ? 1 : 2);
        lang_text_draw_centered(14, MENU_ID_TO_OVERLAY[i], x_offset - 170, 77 + 24 * i, 160, FONT_NORMAL_GREEN);
    }
    if (overlay_menu_data.selected_submenu > 0) {
        image_draw(image_data_s.group_image_ids[GROUP_BULLET], x_offset - 185, 80 + 24 * overlay_menu_data.selected_menu);
        for (int i = 0; i < overlay_menu_data.num_submenu_items; i++) {
            label_draw(x_offset - 348, 74 + 24 * (i + overlay_menu_data.selected_menu),
                10, overlay_menu_data.submenu_focus_button_id == i + 1 ? 1 : 2);
            lang_text_draw_centered(14, SUBMENU_ID_TO_OVERLAY[overlay_menu_data.selected_submenu][i],
                x_offset - 348, 77 + 24 * (i + overlay_menu_data.selected_menu), 160, FONT_NORMAL_GREEN);
        }
    }
}

static void close_submenu(void)
{
    overlay_menu_data.keep_submenu_open = 0;
    overlay_menu_data.selected_menu = 0;
    overlay_menu_data.selected_submenu = 0;
    overlay_menu_data.num_submenu_items = 0;
}

static void open_submenu(int index, int keep_open)
{
    overlay_menu_data.keep_submenu_open = keep_open;
    overlay_menu_data.selected_menu = index;
    overlay_menu_data.selected_submenu = MENU_ID_TO_SUBMENU_ID[index];
    overlay_menu_data.num_submenu_items = 0;
    for (int i = 0; i < 8 && SUBMENU_ID_TO_OVERLAY[overlay_menu_data.selected_submenu][i] > 0; i++) {
        overlay_menu_data.num_submenu_items++;
    }
}

static void button_menu_item_overlay_menu(int index, __attribute__((unused)) int param2)
{
    if (MENU_ID_TO_SUBMENU_ID[index] == 0) {
        game_state_set_overlay(MENU_ID_TO_OVERLAY[index]);
        close_submenu();
        window_city_show();
    } else {
        if (overlay_menu_data.keep_submenu_open && overlay_menu_data.selected_submenu == MENU_ID_TO_SUBMENU_ID[index]) {
            close_submenu();
        } else {
            open_submenu(index, 1);
        }
    }
}

static struct generic_button_t menu_buttons[] = {
    {0, 0, 160, 24, button_menu_item_overlay_menu, button_none, 0, 0},
    {0, 24, 160, 24, button_menu_item_overlay_menu, button_none, 1, 0},
    {0, 48, 160, 24, button_menu_item_overlay_menu, button_none, 2, 0},
    {0, 72, 160, 24, button_menu_item_overlay_menu, button_none, 3, 0},
    {0, 96, 160, 24, button_menu_item_overlay_menu, button_none, 4, 0},
    {0, 120, 160, 24, button_menu_item_overlay_menu, button_none, 5, 0},
    {0, 144, 160, 24, button_menu_item_overlay_menu, button_none, 6, 0},
    {0, 168, 160, 24, button_menu_item_overlay_menu, button_none, 7, 0},
    {0, 192, 160, 24, button_menu_item_overlay_menu, button_none, 8, 0},
    {0, 216, 160, 24, button_menu_item_overlay_menu, button_none, 9, 0},
};

static void button_submenu_item_overlay_menu(int index, int param2); static void button_submenu_item_overlay_menu(int index, __attribute__((unused)) int param2)
{
    int overlay = SUBMENU_ID_TO_OVERLAY[overlay_menu_data.selected_submenu][index];
    if (overlay) {
        game_state_set_overlay(overlay);
    }
    close_submenu();
    window_city_show();
}

static struct generic_button_t submenu_buttons[] = {
    {0, 0, 160, 24, button_submenu_item_overlay_menu, button_none, 0, 0},
    {0, 24, 160, 24, button_submenu_item_overlay_menu, button_none, 1, 0},
    {0, 48, 160, 24, button_submenu_item_overlay_menu, button_none, 2, 0},
    {0, 72, 160, 24, button_submenu_item_overlay_menu, button_none, 3, 0},
    {0, 96, 160, 24, button_submenu_item_overlay_menu, button_none, 4, 0},
    {0, 120, 160, 24, button_submenu_item_overlay_menu, button_none, 5, 0},
    {0, 144, 160, 24, button_submenu_item_overlay_menu, button_none, 6, 0},
    {0, 168, 160, 24, button_submenu_item_overlay_menu, button_none, 7, 0},
    {0, 192, 160, 24, button_submenu_item_overlay_menu, button_none, 8, 0},
    {0, 216, 160, 24, button_submenu_item_overlay_menu, button_none, 9, 0},
};

static void handle_input_overlay_menu(struct mouse_t *m, struct hotkeys_t *h)
{
    int x_offset = get_sidebar_x_offset_overlay_menu();
    int handled = 0;
    handled |= generic_buttons_handle_mouse(m, x_offset - MENU_X_OFFSET_OVERLAY_MENU, MENU_Y_OFFSET_OVERLAY_MENU,
        menu_buttons, MAX_BUTTONS_OVERLAY_MENU, &overlay_menu_data.menu_focus_button_id);

    if (!overlay_menu_data.keep_submenu_open) {
        if (overlay_menu_data.menu_focus_button_id || overlay_menu_data.submenu_focus_button_id) {
            overlay_menu_data.submenu_focus_time = current_time;
            if (overlay_menu_data.menu_focus_button_id) {
                open_submenu(overlay_menu_data.menu_focus_button_id - 1, 0);
            }
        } else if (current_time - overlay_menu_data.submenu_focus_time > 500) {
            close_submenu();
        }
    }
    if (overlay_menu_data.selected_submenu) {
        handled |= generic_buttons_handle_mouse(
            m, x_offset - SUBMENU_X_OFFSET, MENU_Y_OFFSET_OVERLAY_MENU + MENU_ITEM_HEIGHT * overlay_menu_data.selected_menu,
            submenu_buttons, overlay_menu_data.num_submenu_items, &overlay_menu_data.submenu_focus_button_id);
    }
    if (!handled && (m->right.went_up || h->escape_pressed)) {
        if (overlay_menu_data.keep_submenu_open) {
            close_submenu();
        } else {
            window_city_show();
        }
        return;
    }
    if (!handled
    && (m->left.went_up && // click outside menu
        (m->x < x_offset - MENU_CLICK_MARGIN - (overlay_menu_data.selected_submenu ? SUBMENU_X_OFFSET : MENU_X_OFFSET_OVERLAY_MENU) ||
            m->x > x_offset + MENU_CLICK_MARGIN ||
            m->y < MENU_Y_OFFSET_OVERLAY_MENU - MENU_CLICK_MARGIN ||
            m->y > MENU_Y_OFFSET_OVERLAY_MENU + MENU_CLICK_MARGIN + MENU_ITEM_HEIGHT * MAX_BUTTONS_OVERLAY_MENU))) {
        close_submenu();
        window_city_show();
    }
}

static void button_overlay_city_widget(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    struct window_type_t window = {
        WINDOW_OVERLAY_MENU,
        window_city_draw_background,
        draw_foreground_overlay_menu,
        handle_input_overlay_menu,
    };
    overlay_menu_data.selected_submenu = 0;
    overlay_menu_data.num_submenu_items = 0;
    window_show(&window);
}

static void button_help_city_widget(__attribute__((unused)) int param1, int param2)
{
    window_build_menu_hide();
    window_message_dialog_show(param2, window_city_draw_all);
}

static struct image_button_t buttons_overlays_collapse_sidebar[] = {
    {127, 5, 31, 20, IB_NORMAL, 90, 0, button_collapse_expand, button_none, 0, 0, 1, 0, 0, 0},
    {4, 3, 117, 31, IB_NORMAL, 93, 0, button_overlay_city_widget, button_help_city_widget, 0, MESSAGE_DIALOG_OVERLAYS, 1, 0, 0, 0}
};

static void handle_input_city(struct mouse_t *m, struct hotkeys_t *h);
static void window_city_show(void)
{
    if (selected_legion_formation > -1) {
        selected_legion_formation = -1;
    }
    struct window_type_t window = {
        WINDOW_CITY,
        window_city_draw_background,
        draw_foreground_city,
        handle_input_city,
    };
    window_show(&window);
}

static void increase_count(int type, int active)
{
    ++count_data.buildings[type].total;
    if (active) {
        ++count_data.buildings[type].active;
    }
}

static void increase_industry_count(int resource, int active)
{
    ++count_data.industry[resource].total;
    if (active) {
        ++count_data.industry[resource].active;
    }
}

static void limit_hippodrome(void)
{
    if (count_data.buildings[BUILDING_HIPPODROME].total > 1) {
        count_data.buildings[BUILDING_HIPPODROME].total = 1;
    }
    if (count_data.buildings[BUILDING_HIPPODROME].active > 1) {
        count_data.buildings[BUILDING_HIPPODROME].active = 1;
    }
}

static void building_destroy_by_fire(struct building_t *b)
{
    destroy_on_fire(b, 0);
    destroy_linked_parts(b, 1);
}

static void check_labor_problem(struct building_t *b)
{
    if (b->houses_covered <= 0) {
        b->show_on_problem_overlay = 2;
    }
}

static void map_grid_bound(int *x, int *y)
{
    if (*x < 0) {
        *x = 0;
    }
    if (*y < 0) {
        *y = 0;
    }
    if (*x >= map_data.width) {
        *x = map_data.width - 1;
    }
    if (*y >= map_data.height) {
        *y = map_data.height - 1;
    }
}

static int map_closest_road_within_radius(int x, int y, int size, int radius, int *x_road, int *y_road)
{
    for (int r = 1; r <= radius; r++) {
        int x_min, y_min, x_max, y_max;
        map_grid_get_area(x, y, size, r, &x_min, &y_min, &x_max, &y_max);
        for (int yy = y_min; yy <= y_max; yy++) {
            for (int xx = x_min; xx <= x_max; xx++) {
                if (map_terrain_is(map_grid_offset(xx, yy), TERRAIN_ROAD)) {
                    if (x_road && y_road) {
                        *x_road = xx;
                        *y_road = yy;
                    }
                    return 1;
                }
            }
        }
    }
    return 0;
}

static void figure_movement_init_roaming(struct figure_t *f)
{
    struct building_t *b = &all_buildings[f->building_id];
    f->progress_on_tile = 15;
    f->roam_choose_destination = 0;
    f->roam_ticks_until_next_turn = -1;
    f->roam_turn_direction = 2;
    int roam_dir = b->figure_roam_direction;
    b->figure_roam_direction += 2;
    if (b->figure_roam_direction > 6) {
        b->figure_roam_direction = 0;
    }
    int x = b->x;
    int y = b->y;
    switch (roam_dir) {
        case DIR_0_TOP: y -= 8; break;
        case DIR_2_RIGHT: x += 8; break;
        case DIR_4_BOTTOM: y += 8; break;
        case DIR_6_LEFT: x -= 8; break;
    }
    map_grid_bound(&x, &y);
    int x_road, y_road;
    if (map_closest_road_within_radius(x, y, 1, 6, &x_road, &y_road)) {
        f->destination_x = x_road;
        f->destination_y = y_road;
    } else {
        f->roam_choose_destination = 1;
    }
}

static void generate_labor_seeker(struct building_t *b, int x, int y)
{
    if (city_data.population.population <= 0) {
        return;
    }
    if (b->figure_id2) {
        struct figure_t *f = &figures[b->figure_id2];
        if (!figure_is_alive(f) || f->type != FIGURE_LABOR_SEEKER || f->building_id != b->id) {
            b->figure_id2 = 0;
        }
    } else {
        struct figure_t *f = figure_create(FIGURE_LABOR_SEEKER, x, y, DIR_0_TOP);
        f->action_state = FIGURE_ACTION_ROAMING;
        f->is_targetable = 1;
        f->terrain_usage = TERRAIN_USAGE_ROADS;
        f->building_id = b->id;
        b->figure_id2 = f->id;
        figure_movement_init_roaming(f);
    }
}

static void spawn_labor_seeker(struct building_t *b, int x, int y, int min_houses)
{
    if (b->houses_covered <= min_houses) {
        generate_labor_seeker(b, x, y);
    }
}

static int has_figure_of_types(struct building_t *b, int type1, int type2)
{
    if (b->figure_id <= 0) {
        return 0;
    }
    struct figure_t *f = &figures[b->figure_id];
    if (figure_is_alive(f) && f->building_id == b->id && (f->type == type1 || f->type == type2)) {
        return 1;
    } else {
        b->figure_id = 0;
        return 0;
    }
}

static int default_spawn_delay(struct building_t *b)
{
    int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
    if (pct_workers >= 100) {
        return 3;
    } else if (pct_workers >= 75) {
        return 7;
    } else if (pct_workers >= 50) {
        return 15;
    } else if (pct_workers >= 25) {
        return 29;
    } else if (pct_workers >= 1) {
        return 44;
    } else {
        return 0;
    }
}

static void create_roaming_figure(struct building_t *b, int x, int y, int type)
{
    struct figure_t *f = figure_create(type, x, y, DIR_0_TOP);
    f->action_state = FIGURE_ACTION_ROAMING;
    f->is_targetable = 1;
    f->terrain_usage = TERRAIN_USAGE_ROADS;
    f->building_id = b->id;
    b->figure_id = f->id;
    figure_movement_init_roaming(f);
}

static int contains_non_stockpiled_food(struct building_t *space, int *resources)
{
    if (space->id <= 0) {
        return 0;
    }
    if (space->loads_stored <= 0) {
        return 0;
    }
    int resource = space->subtype.warehouse_resource_id;
    if (city_data.resource.stockpiled[resource]) {
        return 0;
    }
    if (resource == RESOURCE_WHEAT || resource == RESOURCE_VEGETABLES ||
        resource == RESOURCE_FRUIT || resource == RESOURCE_MEAT) {
        if (resources[resource] > 0) {
            return 1;
        }
    }
    return 0;
}

static void update_food_resource(struct resource_data *data, int resource, struct building_t *b, int distance)
{
    if (b->data.granary.resource_stored[resource]) {
        data->num_buildings++;
        if (distance < data->distance) {
            data->distance = distance;
            data->building_id = b->id;
        }
    }
}

static int building_warehouse_get_amount(struct building_t *warehouse, int resource)
{
    int loads = 0;
    struct building_t *space = warehouse;
    for (int i = 0; i < 8; i++) {
        space = &all_buildings[space->next_part_building_id];
        if (space->id <= 0) {
            return 0;
        }
        if (space->subtype.warehouse_resource_id && space->subtype.warehouse_resource_id == resource) {
            loads += space->loads_stored;
        }
    }
    return loads;
}

static void update_good_resource(struct resource_data *data, int resource, struct building_t *b, int distance)
{
    if (!city_data.resource.stockpiled[resource] && building_warehouse_get_amount(b, resource) > 0) {
        data->num_buildings++;
        if (distance < data->distance) {
            data->distance = distance;
            data->building_id = b->id;
        }
    }
}

static int map_terrain_get_adjacent_road_or_clear_land(int x, int y, int size, int *x_tile, int *y_tile)
{
    int base_offset = map_grid_offset(x, y);
    for (int *tile_delta = ADJACENT_OFFSETS_MAP_GRID[size]; *tile_delta; tile_delta++) {
        int grid_offset = base_offset + *tile_delta;
        if (map_terrain_is(grid_offset, TERRAIN_ROAD) ||
            !map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR)) {
            *x_tile = map_grid_offset_to_x(grid_offset);
            *y_tile = map_grid_offset_to_y(grid_offset);
            return 1;
        }
    }
    return 0;
}

static int map_has_road_access_granary(int x, int y, struct map_point_t *road)
{
    int rx = -1, ry = -1;
    if (map_terrain_is(map_grid_offset(x + 1, y - 1), TERRAIN_ROAD)) {
        rx = x + 1;
        ry = y - 1;
    } else if (map_terrain_is(map_grid_offset(x + 3, y + 1), TERRAIN_ROAD)) {
        rx = x + 3;
        ry = y + 1;
    } else if (map_terrain_is(map_grid_offset(x + 1, y + 3), TERRAIN_ROAD)) {
        rx = x + 1;
        ry = y + 3;
    } else if (map_terrain_is(map_grid_offset(x - 1, y + 1), TERRAIN_ROAD)) {
        rx = x - 1;
        ry = y + 1;
    }
    if (rx >= 0 && ry >= 0) {
        if (road) {
            road->x = rx;
            road->y = ry;
        }
        return 1;
    }
    return 0;
}

static int building_granary_add_resource(struct building_t *granary, int resource, int is_produced)
{
    if (granary->id <= 0) {
        return 1;
    }
    if (!resource_is_food(resource)) {
        return 0;
    }
    if (granary->type != BUILDING_GRANARY) {
        return 0;
    }
    if (granary->data.granary.resource_stored[RESOURCE_NONE] <= 0) {
        return 0; // no space
    }
    if (is_produced) {
        city_data.resource.food_produced_this_month += ONE_LOAD;
    }
    if (granary->data.granary.resource_stored[RESOURCE_NONE] <= ONE_LOAD) {
        granary->data.granary.resource_stored[resource] += granary->data.granary.resource_stored[RESOURCE_NONE];
        granary->data.granary.resource_stored[RESOURCE_NONE] = 0;
    } else {
        granary->data.granary.resource_stored[resource] += ONE_LOAD;
        granary->data.granary.resource_stored[RESOURCE_NONE] -= ONE_LOAD;
    }
    return 1;
}

static int building_granary_remove_resource(struct building_t *granary, int resource, int amount)
{
    if (amount <= 0) {
        return 0;
    }
    int removed;
    if (granary->data.granary.resource_stored[resource] >= amount) {
        removed = amount;
    } else {
        removed = granary->data.granary.resource_stored[resource];
    }
    city_data.resource.granary_food_stored[resource] -= removed;
    granary->data.granary.resource_stored[resource] -= removed;
    granary->data.granary.resource_stored[RESOURCE_NONE] += removed;
    return amount - removed;
}

static void update_farm_image(struct building_t *b)
{
    map_building_tiles_add_farm(b->id, b->x, b->y,
        image_data_s.group_image_ids[GROUP_BUILDING_FARM_CROPS] + resource_images[b->output_resource_id].farm_field_img_id,
        b->data.industry.progress);
}

static void building_list_large_clear(int clear_entries)
{
    building_list_data.large.size = 0;
    if (clear_entries) {
        memset(building_list_data.large.items, 0, MAX_LARGE * sizeof(int));
    }
}

static void building_list_large_add(int building_id)
{
    if (building_list_data.large.size < MAX_LARGE) {
        building_list_data.large.items[building_list_data.large.size++] = building_id;
    }
}

static   int *building_list_large_items(void)
{
    return building_list_data.large.items;
}

static int building_market_get_max_food_stock(struct building_t *market)
{
    int max_stock = 0;
    if (market->id > 0 && market->type == BUILDING_MARKET) {
        for (int i = INVENTORY_WHEAT; i <= INVENTORY_MEAT; i++) {
            int stock = market->data.market.inventory[i];
            if (stock > max_stock) {
                max_stock = stock;
            }
        }
    }
    return max_stock;
}

static int building_warehouse_remove_resource(struct building_t *warehouse, int resource, int amount)
{
    // returns amount still needing removal
    if (warehouse->type != BUILDING_WAREHOUSE) {
        return amount;
    }
    struct building_t *space = warehouse;
    for (int i = 0; i < 8; i++) {
        if (amount <= 0) {
            return 0;
        }
        space = &all_buildings[space->next_part_building_id];
        if (space->id <= 0) {
            continue;
        }
        if (space->subtype.warehouse_resource_id != resource || space->loads_stored <= 0) {
            continue;
        }
        if (space->loads_stored > amount) {
            city_resource_remove_from_warehouse(resource, amount);
            space->loads_stored -= amount;
            amount = 0;
        } else {
            city_resource_remove_from_warehouse(resource, space->loads_stored);
            amount -= space->loads_stored;
            space->loads_stored = 0;
            space->subtype.warehouse_resource_id = RESOURCE_NONE;
        }
        building_warehouse_space_set_image(space, resource);
    }
    return amount;
}

static void window_building_info_show_storage_orders(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    b_info_context.storage_show_special_orders = 1;
    window_invalidate();
}

static struct generic_button_t go_to_orders_button[] = {
    {0, 0, 304, 20, window_building_info_show_storage_orders, button_none, 0, 0}
};

static void building_storage_cycle_resource_state(int storage_id, int resource_id)
{
    int state = storages[storage_id].storage.resource_state[resource_id];
    if (state == BUILDING_STORAGE_STATE_ACCEPTING) {
        state = BUILDING_STORAGE_STATE_NOT_ACCEPTING;
    } else if (state == BUILDING_STORAGE_STATE_NOT_ACCEPTING) {
        state = BUILDING_STORAGE_STATE_GETTING;
    } else if (state == BUILDING_STORAGE_STATE_GETTING) {
        state = BUILDING_STORAGE_STATE_ACCEPTING;
    }
    storages[storage_id].storage.resource_state[resource_id] = state;
}

static void toggle_resource_state(int index, __attribute__((unused)) int param2)
{
    struct building_t *b = &all_buildings[distribution_data.building_id];
    int resource;
    if (b->type == BUILDING_WAREHOUSE) {
        resource = available.resource_list.items[index - 1];
    } else {
        resource = available.food_list.items[index - 1];
    }
    building_storage_cycle_resource_state(b->storage_id, resource);
    window_invalidate();
}

static struct generic_button_t orders_resource_buttons[] = {
    {0, 0, 210, 22, toggle_resource_state, button_none, 1, 0},
    {0, 22, 210, 22, toggle_resource_state, button_none, 2, 0},
    {0, 44, 210, 22, toggle_resource_state, button_none, 3, 0},
    {0, 66, 210, 22, toggle_resource_state, button_none, 4, 0},
    {0, 88, 210, 22, toggle_resource_state, button_none, 5, 0},
    {0, 110, 210, 22, toggle_resource_state, button_none, 6, 0},
    {0, 132, 210, 22, toggle_resource_state, button_none, 7, 0},
    {0, 154, 210, 22, toggle_resource_state, button_none, 8, 0},
    {0, 176, 210, 22, toggle_resource_state, button_none, 9, 0},
    {0, 198, 210, 22, toggle_resource_state, button_none, 10, 0},
    {0, 220, 210, 22, toggle_resource_state, button_none, 11, 0},
    {0, 242, 210, 22, toggle_resource_state, button_none, 12, 0},
    {0, 264, 210, 22, toggle_resource_state, button_none, 13, 0},
    {0, 286, 210, 22, toggle_resource_state, button_none, 14, 0},
    {0, 308, 210, 22, toggle_resource_state, button_none, 15, 0},
};

static void building_storage_accept_none(int storage_id)
{
    for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
        storages[storage_id].storage.resource_state[r] = BUILDING_STORAGE_STATE_NOT_ACCEPTING;
    }
}

static void granary_orders(int index, __attribute__((unused)) int param2)
{
    int storage_id = all_buildings[distribution_data.building_id].storage_id;
    if (index == 0) {
        storages[storage_id].storage.empty_all = 1 - storages[storage_id].storage.empty_all;
    } else if (index == 1) {
        building_storage_accept_none(storage_id);
    }
    window_invalidate();
}

static struct generic_button_t granary_order_buttons[] = {
    {0, 0, 304, 20, granary_orders, button_none, 0, 0},
    {314, 0, 20, 20, granary_orders, button_none, 1, 0},
};

static void warehouse_orders(int index, __attribute__((unused)) int param2)
{
    if (index == 0) {
        int storage_id = all_buildings[distribution_data.building_id].storage_id;
        storages[storage_id].storage.empty_all = 1 - storages[storage_id].storage.empty_all;
    } else if (index == 1) {
        city_data.building.trade_center_building_id = distribution_data.building_id;
    } else if (index == 2) {
        int storage_id = all_buildings[distribution_data.building_id].storage_id;
        building_storage_accept_none(storage_id);
    }
    window_invalidate();
}

static struct generic_button_t warehouse_order_buttons[] = {
    {0, 0, 304, 20, warehouse_orders, button_none, 0, 0},
    {0, -22, 304, 20, warehouse_orders, button_none, 1, 0},
    {314, 0, 20, 20, warehouse_orders, button_none, 2, 0},
};

static void draw_accept_none_button(int x, int y, int focused)
{
    char refuse_button_text[] = { 'x', 0 };
    button_border_draw(x, y, 20, 20, focused ? 1 : 0);
    text_draw_centered(refuse_button_text, x + 1, y + 4, 20, FONT_NORMAL_BLACK, 0);
}

static void window_building_play_figure_phrase(struct building_info_context_t *c)
{
    int figure_id = c->figure.figure_ids[c->figure.selected_index];
    struct figure_t *f = &figures[figure_id];

    c->figure.sound_id = figure_properties[f->type].sound_category;
    c->figure.phrase_id = f->phrase_id;
    if (figure_properties[f->type].sound_category >= 0 && f->phrase_id >= 0) {
        char path[SOUND_FILENAME_MAX];
        string_copy("wavs/", path, SOUND_FILENAME_MAX - 1);
        strcat(path, FIGURE_SOUNDS[figure_properties[f->type].sound_category][f->phrase_id]);
        play_speech_file(path);
    }
}

static void select_figure(int index, __attribute__((unused)) int param2)
{
    building_figures_data.context_for_callback->figure.selected_index = index;
    window_building_play_figure_phrase(building_figures_data.context_for_callback);
    window_invalidate();
}

static struct generic_button_t figure_buttons[] = {
    {26, 46, 50, 50, select_figure, button_none, 0, 0},
    {86, 46, 50, 50, select_figure, button_none, 1, 0},
    {146, 46, 50, 50, select_figure, button_none, 2, 0},
    {206, 46, 50, 50, select_figure, button_none, 3, 0},
    {266, 46, 50, 50, select_figure, button_none, 4, 0},
    {326, 46, 50, 50, select_figure, button_none, 5, 0},
    {386, 46, 50, 50, select_figure, button_none, 6, 0},
};

static void window_building_play_sound(struct building_info_context_t *c, char *sound_file)
{
    if (c->can_play_sound) {
        play_speech_file(sound_file);
        c->can_play_sound = 0;
    }
}

static void window_building_draw_description_at(struct building_info_context_t *c, int y_offset, int text_group, int text_id)
{
    lang_text_draw_multiline(text_group, text_id, c->x_offset + 32, c->y_offset + y_offset, BLOCK_SIZE * (c->width_blocks - 4), FONT_NORMAL_BLACK);
}

static void draw_employment_details(struct building_info_context_t *c, struct building_t *b, int y_offset, int text_id)
{
    y_offset += c->y_offset;
    image_draw(image_data_s.group_image_ids[GROUP_CONTEXT_ICONS] + 14, c->x_offset + 40, y_offset + 6);
    if (text_id) {
        int width = lang_text_draw_amount(8, 12, b->num_workers,
            c->x_offset + 60, y_offset + 10, FONT_NORMAL_BROWN);
        width += text_draw_number(building_properties[b->type].n_laborers, '(', "",
            c->x_offset + 70 + width, y_offset + 10, FONT_NORMAL_BROWN);
        lang_text_draw(69, 0, c->x_offset + 70 + width, y_offset + 10, FONT_NORMAL_BROWN);
        lang_text_draw(69, text_id, c->x_offset + 70, y_offset + 26, FONT_NORMAL_BROWN);
    } else {
        int width = lang_text_draw_amount(8, 12, b->num_workers,
            c->x_offset + 60, y_offset + 16, FONT_NORMAL_BROWN);
        width += text_draw_number(building_properties[b->type].n_laborers, '(', "",
            c->x_offset + 70 + width, y_offset + 16, FONT_NORMAL_BROWN);
        lang_text_draw(69, 0, c->x_offset + 70 + width, y_offset + 16, FONT_NORMAL_BROWN);
    }
}

static int draw_employment_info(struct building_t *b, int consider_house_covering)
{
    int text_id;
    if (b->num_workers >= building_properties[b->type].n_laborers) {
        text_id = 0;
    } else if (city_data.population.population <= 0) {
        text_id = 16; // no people in city
    } else if (!consider_house_covering) {
        text_id = 19;
    } else if (b->houses_covered <= 0) {
        text_id = 17; // no employees nearby
    } else if (b->houses_covered < 40) {
        text_id = 20; // poor access to employees
    } else if (!city_data.labor.categories[b->labor_category].workers_allocated) {
        text_id = 18; // no people allocated
    } else {
        text_id = 19; // too few people allocated
    }
    if (!text_id && consider_house_covering && b->houses_covered < 40) {
        text_id = 20; // poor access to employees
    }
    return text_id;
}

static void window_building_draw_employment(struct building_info_context_t *c, int y_offset)
{
    struct building_t *b = &all_buildings[c->building_id];
    int text_id = draw_employment_info(b, 1);
    draw_employment_details(c, b, y_offset, text_id);
}

static void draw_farm(struct building_info_context_t *c, int help_id, char *sound_file, int group_id, int resource)
{
    c->help_id = help_id;
    window_building_play_sound(c, sound_file);

    outer_panel_draw(c->x_offset, c->y_offset, c->width_blocks, c->height_blocks);
    image_draw(resource_images[resource].icon_img_id, c->x_offset + 10, c->y_offset + 10);
    lang_text_draw_centered(group_id, 0, c->x_offset, c->y_offset + 10, BLOCK_SIZE * c->width_blocks, FONT_LARGE_BLACK);

    struct building_t *b = &all_buildings[c->building_id];
    int pct_grown = calc_percentage(b->data.industry.progress, 200);
    int width = lang_text_draw(group_id, 2, c->x_offset + 32, c->y_offset + 44, FONT_NORMAL_BLACK);
    width += text_draw_percentage(pct_grown, c->x_offset + 32 + width, c->y_offset + 44, FONT_NORMAL_BLACK);
    lang_text_draw(group_id, 3, c->x_offset + 32 + width, c->y_offset + 44, FONT_NORMAL_BLACK);
    if (!c->has_road_access) {
        window_building_draw_description_at(c, 70, 69, 25);
    } else if (city_data.resource.mothballed[resource]) {
        window_building_draw_description_at(c, 70, group_id, 4);
    } else if (b->data.industry.curse_days_left > 4) {
        window_building_draw_description_at(c, 70, group_id, 11);
    } else if (b->num_workers <= 0) {
        window_building_draw_description_at(c, 70, group_id, 5);
    } else if (c->worker_percentage >= 100) {
        window_building_draw_description_at(c, 70, group_id, 6);
    } else if (c->worker_percentage >= 75) {
        window_building_draw_description_at(c, 70, group_id, 7);
    } else if (c->worker_percentage >= 50) {
        window_building_draw_description_at(c, 70, group_id, 8);
    } else if (c->worker_percentage >= 25) {
        window_building_draw_description_at(c, 70, group_id, 9);
    } else {
        window_building_draw_description_at(c, 70, group_id, 10);
    }
    inner_panel_draw(c->x_offset + 16, c->y_offset + 136, c->width_blocks - 2, 4);
    window_building_draw_employment(c, 142);
    window_building_draw_description_at(c, BLOCK_SIZE * c->height_blocks - 136, group_id, 1);
}

static void draw_raw_material(struct building_info_context_t *c, int help_id, char *sound_file, int group_id, int resource)
{
    c->help_id = help_id;
    window_building_play_sound(c, sound_file);
    outer_panel_draw(c->x_offset, c->y_offset, c->width_blocks, c->height_blocks);
    image_draw(resource_images[resource].icon_img_id, c->x_offset + 10, c->y_offset + 10);
    lang_text_draw_centered(group_id, 0, c->x_offset, c->y_offset + 10, BLOCK_SIZE * c->width_blocks, FONT_LARGE_BLACK);
    struct building_t *b = &all_buildings[c->building_id];
    int pct_done = calc_percentage(b->data.industry.progress, 200);
    int width = lang_text_draw(group_id, 2, c->x_offset + 32, c->y_offset + 44, FONT_NORMAL_BLACK);
    width += text_draw_percentage(pct_done, c->x_offset + 32 + width, c->y_offset + 44, FONT_NORMAL_BLACK);
    lang_text_draw(group_id, 3, c->x_offset + 32 + width, c->y_offset + 44, FONT_NORMAL_BLACK);
    if (!c->has_road_access) {
        window_building_draw_description_at(c, 70, 69, 25);
    } else if (city_data.resource.mothballed[resource]) {
        window_building_draw_description_at(c, 70, group_id, 4);
    } else if (b->num_workers <= 0) {
        window_building_draw_description_at(c, 70, group_id, 5);
    } else if (c->worker_percentage >= 100) {
        window_building_draw_description_at(c, 70, group_id, 6);
    } else if (c->worker_percentage >= 75) {
        window_building_draw_description_at(c, 70, group_id, 7);
    } else if (c->worker_percentage >= 50) {
        window_building_draw_description_at(c, 70, group_id, 8);
    } else if (c->worker_percentage >= 25) {
        window_building_draw_description_at(c, 70, group_id, 9);
    } else {
        window_building_draw_description_at(c, 70, group_id, 10);
    }
    inner_panel_draw(c->x_offset + 16, c->y_offset + 136, c->width_blocks - 2, 4);
    window_building_draw_employment(c, 142);
    window_building_draw_description_at(c, BLOCK_SIZE * c->height_blocks - 136, group_id, 1);
}

static void draw_workshop(struct building_info_context_t *c, int help_id, char *sound_file, int group_id, int resource, int input_resource)
{
    c->help_id = help_id;
    window_building_play_sound(c, sound_file);

    outer_panel_draw(c->x_offset, c->y_offset, c->width_blocks, c->height_blocks);
    image_draw(resource_images[resource].icon_img_id, c->x_offset + 10, c->y_offset + 10);
    lang_text_draw_centered(group_id, 0, c->x_offset, c->y_offset + 10,
        BLOCK_SIZE * c->width_blocks, FONT_LARGE_BLACK);

    struct building_t *b = &all_buildings[c->building_id];
    int pct_done = calc_percentage(b->data.industry.progress, 400);
    int width = lang_text_draw(group_id, 2, c->x_offset + 32, c->y_offset + 40, FONT_NORMAL_BLACK);
    width += text_draw_percentage(pct_done, c->x_offset + 32 + width, c->y_offset + 40, FONT_NORMAL_BLACK);
    lang_text_draw(group_id, 3, c->x_offset + 32 + width, c->y_offset + 40, FONT_NORMAL_BLACK);

    image_draw(resource_images[input_resource].icon_img_id, c->x_offset + 32, c->y_offset + 56);
    width = lang_text_draw(group_id, 12, c->x_offset + 60, c->y_offset + 60, FONT_NORMAL_BLACK);
    if (b->loads_stored < 1) {
        lang_text_draw_amount(8, 10, 0, c->x_offset + 60 + width, c->y_offset + 60, FONT_NORMAL_BLACK);
    } else {
        lang_text_draw_amount(8, 10, b->loads_stored, c->x_offset + 60 + width, c->y_offset + 60, FONT_NORMAL_BLACK);
    }
    if (!c->has_road_access) {
        window_building_draw_description_at(c, 86, 69, 25);
    } else if (city_data.resource.mothballed[resource]) {
        window_building_draw_description_at(c, 86, group_id, 4);
    } else if (b->num_workers <= 0) {
        window_building_draw_description_at(c, 86, group_id, 5);
    } else if (b->loads_stored <= 0) {
        window_building_draw_description_at(c, 86, group_id, 11);
    } else if (c->worker_percentage >= 100) {
        window_building_draw_description_at(c, 86, group_id, 6);
    } else if (c->worker_percentage >= 75) {
        window_building_draw_description_at(c, 86, group_id, 7);
    } else if (c->worker_percentage >= 50) {
        window_building_draw_description_at(c, 86, group_id, 8);
    } else if (c->worker_percentage >= 25) {
        window_building_draw_description_at(c, 86, group_id, 9);
    } else {
        window_building_draw_description_at(c, 86, group_id, 10);
    }
    inner_panel_draw(c->x_offset + 16, c->y_offset + 136, c->width_blocks - 2, 4);
    window_building_draw_employment(c, 142);
}

static void window_config_show(void);

static void draw_title_advisors(int y, int text_id)
{
    image_draw(image_data_s.group_image_ids[GROUP_BULLET], 32, y + 1);
    lang_text_draw(61, text_id, 52, y, FONT_NORMAL_WHITE);
}

static int city_military_distant_battle_roman_army_is_traveling(void)
{
    return city_data.distant_battle.roman_months_to_travel_forth > 0 ||
        city_data.distant_battle.roman_months_to_travel_back > 0;
}

static int city_migration_no_room_for_immigrants(void)
{
    return city_data.migration.refused_immigrants_today || city_data.population.room_in_houses <= 0;
}

static int draw_background_chief_advisor(void)
{
    int width;
    outer_panel_draw(0, 0, 40, CHIEF_ADVISOR_HEIGHT);
    image_draw(image_data_s.group_image_ids[GROUP_ADVISOR_ICONS] + 11, 10, 10);
    lang_text_draw(61, 0, 60, 12, FONT_LARGE_BLACK);
    inner_panel_draw(24, 60, 37, 16);
    // workers
    draw_title_advisors(66, 1);
    if (city_data.labor.unemployment_percentage > 0) {
        width = lang_text_draw(61, 12, X_OFFSET, 66, FONT_NORMAL_RED);
        width += text_draw_percentage(city_data.labor.unemployment_percentage, X_OFFSET + width, 66, FONT_NORMAL_RED);
        text_draw_number(city_data.labor.workers_unemployed - city_data.labor.workers_needed, '(', ")",
            X_OFFSET + width, 66, FONT_NORMAL_RED);
    } else if (city_data.labor.workers_needed > 0) {
        width = lang_text_draw(61, 13, X_OFFSET, 66, FONT_NORMAL_RED);
        lang_text_draw_amount(8, 12, city_data.labor.workers_needed, X_OFFSET + width, 66, FONT_NORMAL_RED);
    } else {
        lang_text_draw(61, 14, X_OFFSET, 66, FONT_NORMAL_GREEN);
    }
    // finance
    draw_title_advisors(86, 2);
    if (city_data.finance.treasury > city_data.finance.last_year.balance) {
        width = lang_text_draw(61, 15, X_OFFSET, 86, FONT_NORMAL_GREEN);
        text_draw_money(city_data.finance.treasury - city_data.finance.last_year.balance, X_OFFSET + width, 86, FONT_NORMAL_GREEN);
    } else if (city_data.finance.treasury < city_data.finance.last_year.balance) {
        width = lang_text_draw(61, 16, X_OFFSET, 86, FONT_NORMAL_RED);
        text_draw_money(city_data.finance.last_year.balance - city_data.finance.treasury, X_OFFSET + width, 86, FONT_NORMAL_RED);
    } else {
        lang_text_draw(61, 17, X_OFFSET, 86, FONT_NORMAL_GREEN);
    }
    // migration
    draw_title_advisors(106, 3);
    if (city_figures_total_invading_enemies() > 3) {
        lang_text_draw(61, 79, X_OFFSET, 106, FONT_NORMAL_GREEN);
    } else if (city_data.migration.newcomers >= 5) {
        lang_text_draw(61, 25, X_OFFSET, 106, FONT_NORMAL_GREEN);
    } else if (city_migration_no_room_for_immigrants()) {
        lang_text_draw(61, 18, X_OFFSET, 106, FONT_NORMAL_RED);
    } else if (city_data.migration.percentage >= 80) {
        lang_text_draw(61, 25, X_OFFSET, 106, FONT_NORMAL_GREEN);
    } else {
        int text_id;
        switch (city_data.migration.no_immigration_cause) {
            case NO_IMMIGRATION_LOW_WAGES: text_id = 19; break;
            case NO_IMMIGRATION_NO_JOBS: text_id = 20; break;
            case NO_IMMIGRATION_NO_FOOD: text_id = 21; break;
            case NO_IMMIGRATION_HIGH_TAXES: text_id = 22; break;
            case NO_IMMIGRATION_MANY_TENTS: text_id = 70; break;
            case NO_IMMIGRATION_LOW_MOOD: text_id = 71; break;
            default: text_id = 0; break;
        }
        if (text_id) {
            lang_text_draw(61, text_id, X_OFFSET, 106, FONT_NORMAL_GREEN);
        }
    }
    // food stocks
    draw_title_advisors(126, 4);
    if (scenario.rome_supplies_wheat) {
        lang_text_draw(61, 26, X_OFFSET, 126, FONT_NORMAL_GREEN);
    } else if (city_data.resource.food_supply_months > 0) {
        width = lang_text_draw(61, 28, X_OFFSET, 126, FONT_NORMAL_GREEN);
        lang_text_draw_amount(8, 4, city_data.resource.food_supply_months, X_OFFSET + width, 126, FONT_NORMAL_GREEN);
    } else {
        lang_text_draw(61, 27, X_OFFSET, 126, FONT_NORMAL_RED);
    }
    // food consumption
    draw_title_advisors(146, 62);
    if (scenario.rome_supplies_wheat) {
        lang_text_draw(61, 26, X_OFFSET, 146, FONT_NORMAL_GREEN);
    } else {
        int pct = calc_percentage(city_data.resource.food_produced_last_month, city_data.resource.food_consumed_last_month);
        if (pct > 150) {
            lang_text_draw(61, 63, X_OFFSET, 146, FONT_NORMAL_GREEN);
        } else if (pct > 105) {
            lang_text_draw(61, 64, X_OFFSET, 146, FONT_NORMAL_GREEN);
        } else if (pct > 95) {
            lang_text_draw(61, 65, X_OFFSET, 146, FONT_NORMAL_GREEN);
        } else if (pct > 75) {
            lang_text_draw(61, 66, X_OFFSET, 146, FONT_NORMAL_RED);
        } else if (pct > 30) {
            lang_text_draw(61, 67, X_OFFSET, 146, FONT_NORMAL_RED);
        } else if (pct > 0) {
            lang_text_draw(61, 68, X_OFFSET, 146, FONT_NORMAL_RED);
        } else {
            lang_text_draw(61, 69, X_OFFSET, 146, FONT_NORMAL_RED);
        }
    }
    // military
    draw_title_advisors(166, 5);
    if (city_data.figure.imperial_soldiers) {
        lang_text_draw(61, 76, X_OFFSET, 166, FONT_NORMAL_RED);
    } else if (city_data.figure.enemies) {
        lang_text_draw(61, 75, X_OFFSET, 166, FONT_NORMAL_RED);
    } else if (scenario.invasion_upcoming) {
        lang_text_draw(61, 74, X_OFFSET, 166, FONT_NORMAL_RED);
    } else if (city_military_distant_battle_roman_army_is_traveling()) {
        lang_text_draw(61, 78, X_OFFSET, 166, FONT_NORMAL_GREEN);
    } else if (city_data.distant_battle.months_until_battle) {
        lang_text_draw(61, 77, X_OFFSET, 166, FONT_NORMAL_RED);
    } else if (city_data.figure.soldiers) {
        lang_text_draw(61, 73, X_OFFSET, 166, FONT_NORMAL_GREEN);
    } else {
        lang_text_draw(61, 72, X_OFFSET, 166, FONT_NORMAL_GREEN);
    }
    // crime
    draw_title_advisors(186, 6);
    if (city_data.figure.rioters) {
        lang_text_draw(61, 33, X_OFFSET, 186, FONT_NORMAL_RED);
    } else if (city_data.sentiment.criminals > 10) {
        lang_text_draw(61, 32, X_OFFSET, 186, FONT_NORMAL_RED);
    } else if (city_data.sentiment.criminals) {
        lang_text_draw(61, 31, X_OFFSET, 186, FONT_NORMAL_RED);
    } else if (city_data.sentiment.protesters) {
        lang_text_draw(61, 30, X_OFFSET, 186, FONT_NORMAL_RED);
    } else {
        lang_text_draw(61, 29, X_OFFSET, 186, FONT_NORMAL_GREEN);
    }
    // health
    draw_title_advisors(206, 7);
    if (city_data.health.value >= 40) {
        lang_text_draw(56, city_data.health.value / 10 + 27, X_OFFSET, 206, FONT_NORMAL_GREEN);
    } else {
        lang_text_draw(56, city_data.health.value / 10 + 27, X_OFFSET, 206, FONT_NORMAL_RED);
    }
    // education
    struct house_demands_t *demands = &city_data.houses;
    draw_title_advisors(226, 8);
    if (demands->education == 1) {
        lang_text_draw(61, 39, X_OFFSET, 226, FONT_NORMAL_RED);
    } else if (demands->education == 2) {
        lang_text_draw(61, 40, X_OFFSET, 226, FONT_NORMAL_RED);
    } else if (demands->education == 3) {
        lang_text_draw(61, 41, X_OFFSET, 226, FONT_NORMAL_RED);
    } else {
        lang_text_draw(61, 42, X_OFFSET, 226, FONT_NORMAL_GREEN);
    }
    // religion
    draw_title_advisors(246, 9);
    if (demands->religion == 1) {
        lang_text_draw(61, 46, X_OFFSET, 246, FONT_NORMAL_RED);
    } else if (demands->religion == 2) {
        lang_text_draw(61, 47, X_OFFSET, 246, FONT_NORMAL_RED);
    } else if (demands->religion == 3) {
        lang_text_draw(61, 48, X_OFFSET, 246, FONT_NORMAL_RED);
    } else {
        lang_text_draw(61, 49, X_OFFSET, 246, FONT_NORMAL_GREEN);
    }
    // entertainment
    draw_title_advisors(266, 10);
    if (demands->entertainment == 1) {
        lang_text_draw(61, 43, X_OFFSET, 266, FONT_NORMAL_RED);
    } else if (demands->entertainment == 2) {
        lang_text_draw(61, 44, X_OFFSET, 266, FONT_NORMAL_RED);
    } else {
        lang_text_draw(61, 45, X_OFFSET, 266, FONT_NORMAL_GREEN);
    }
    // sentiment
    draw_title_advisors(286, 11);
    int sentiment = city_data.sentiment.value;
    if (sentiment <= 0) {
        lang_text_draw(61, 50, X_OFFSET, 286, FONT_NORMAL_RED);
    } else if (sentiment >= 100) {
        lang_text_draw(61, 61, X_OFFSET, 286, FONT_NORMAL_GREEN);
    } else {
        lang_text_draw(61, sentiment / 10 + 51, X_OFFSET, 286, FONT_NORMAL_GREEN);
    }

    return CHIEF_ADVISOR_HEIGHT;
}

static struct advisor_window_type_t *window_advisor_chief(void)
{
    static struct advisor_window_type_t window = {
        draw_background_chief_advisor,
        0,
        0,
    };
    return &window;
}

static int draw_background_education_advisor(void)
{
    outer_panel_draw(0, 0, 40, EDUCATION_ADVISOR_HEIGHT);
    image_draw(image_data_s.group_image_ids[GROUP_ADVISOR_ICONS] + 7, 10, 10);
    lang_text_draw(57, 0, 60, 12, FONT_LARGE_BLACK);
    // x population, y school age, z academy age
    int width = text_draw_number(city_data.population.population, '@', " ", 60, 50, FONT_NORMAL_BLACK);
    width += lang_text_draw(57, 1, 60 + width, 50, FONT_NORMAL_BLACK);
    width += text_draw_number(city_data.population.school_age, '@', " ", 60 + width, 50, FONT_NORMAL_BLACK);
    width += lang_text_draw(57, 2, 60 + width, 50, FONT_NORMAL_BLACK);
    width += text_draw_number(city_data.population.academy_age, '@', " ", 60 + width, 50, FONT_NORMAL_BLACK);
    lang_text_draw(57, 3, 60 + width, 50, FONT_NORMAL_BLACK);
    // table headers
    lang_text_draw(57, 4, 180, 86, FONT_SMALL_PLAIN);
    lang_text_draw(57, 5, 290, 86, FONT_SMALL_PLAIN);
    lang_text_draw(57, 6, 478, 86, FONT_SMALL_PLAIN);
    inner_panel_draw(32, 100, 36, 4);
    // schools
    lang_text_draw_amount(8, 18, count_data.buildings[BUILDING_SCHOOL].total, 40, 105, FONT_NORMAL_WHITE);
    text_draw_number_centered(count_data.buildings[BUILDING_SCHOOL].active, 150, 105, 100, FONT_NORMAL_WHITE);
    width = text_draw_number(75 * count_data.buildings[BUILDING_SCHOOL].active, '@', " ", 280, 105, FONT_NORMAL_WHITE);
    lang_text_draw(57, 7, 280 + width, 105, FONT_NORMAL_WHITE);
    if (culture_coverage.school == 0) {
        lang_text_draw_centered(57, 10, 420, 105, 200, FONT_NORMAL_WHITE);
    } else if (culture_coverage.school < 100) {
        lang_text_draw_centered(57, culture_coverage.school / 10 + 11, 420, 105, 200, FONT_NORMAL_WHITE);
    } else {
        lang_text_draw_centered(57, 21, 420, 105, 200, FONT_NORMAL_WHITE);
    }
    // academies
    lang_text_draw_amount(8, 20, count_data.buildings[BUILDING_ACADEMY].total, 40, 125, FONT_NORMAL_WHITE);
    text_draw_number_centered(count_data.buildings[BUILDING_ACADEMY].active, 150, 125, 100, FONT_NORMAL_WHITE);
    width = text_draw_number(100 * count_data.buildings[BUILDING_ACADEMY].active, '@', " ", 280, 125, FONT_NORMAL_WHITE);
    lang_text_draw(57, 8, 280 + width, 125, FONT_NORMAL_WHITE);
    int pct_academy = culture_coverage.academy;
    if (pct_academy == 0) {
        lang_text_draw_centered(57, 10, 420, 125, 200, FONT_NORMAL_WHITE);
    } else if (pct_academy < 100) {
        lang_text_draw_centered(57, pct_academy / 10 + 11, 420, 125, 200, FONT_NORMAL_WHITE);
    } else {
        lang_text_draw_centered(57, 21, 420, 125, 200, FONT_NORMAL_WHITE);
    }
    // libraries
    lang_text_draw_amount(8, 22, count_data.buildings[BUILDING_LIBRARY].total, 40, 145, FONT_NORMAL_WHITE);
    text_draw_number_centered(count_data.buildings[BUILDING_LIBRARY].active, 150, 145, 100, FONT_NORMAL_WHITE);
    width = text_draw_number(800 * count_data.buildings[BUILDING_LIBRARY].active, '@', " ", 280, 145, FONT_NORMAL_WHITE);
    lang_text_draw(57, 9, 280 + width, 145, FONT_NORMAL_WHITE);
    if (culture_coverage.library == 0) {
        lang_text_draw_centered(57, 10, 420, 145, 200, FONT_NORMAL_WHITE);
    } else if (culture_coverage.library < 100) {
        lang_text_draw_centered(57, culture_coverage.library / 10 + 11, 420, 145, 200, FONT_NORMAL_WHITE);
    } else {
        lang_text_draw_centered(57, 21, 420, 145, 200, FONT_NORMAL_WHITE);
    }
    int education_advice;
    struct house_demands_t *demands = &city_data.houses;
    if (demands->education == 1) {
        education_advice = demands->requiring.school ? 1 : 0;
    } else if (demands->education == 2) {
        education_advice = demands->requiring.library ? 3 : 2;
    } else if (demands->education == 3) {
        education_advice = 4;
    } else {
        if (!demands->requiring.school) {
            education_advice = 5; // no demands yet
        } else if (!demands->requiring.library) {
            if (culture_coverage.school >= 100 && culture_coverage.academy >= 100) {
                education_advice = 6; // education is perfect
            } else if (culture_coverage.school <= culture_coverage.academy) {
                education_advice = 7; // build more schools
            } else {
                education_advice = 8; // build more academies
            }
        } else {
            // all education needed
            if (culture_coverage.school >= 100 && culture_coverage.academy >= 100 && culture_coverage.library >= 100) {
                education_advice = 6;
            } else if (culture_coverage.school <= culture_coverage.academy && culture_coverage.school <= culture_coverage.library) {
                education_advice = 7; // build more schools
            } else if (culture_coverage.academy <= culture_coverage.school && culture_coverage.academy <= culture_coverage.library) {
                education_advice = 8; // build more academies
            } else if (culture_coverage.library <= culture_coverage.school && culture_coverage.library <= culture_coverage.academy) {
                education_advice = 9; // build more libraries
            } else {
                education_advice = 6; // unlikely event that all coverages are equal
            }
        }
    }
    lang_text_draw_multiline(57, 22 + education_advice, 60, 180, 512, FONT_NORMAL_BLACK);
    return EDUCATION_ADVISOR_HEIGHT;
}

static struct advisor_window_type_t *window_advisor_education(void)
{
    static struct advisor_window_type_t window = {
        draw_background_education_advisor,
        0,
        0
    };
    return &window;
}

static void button_help_resource_settings_festival(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_message_dialog_show(MESSAGE_DIALOG_ADVISOR_ENTERTAINMENT, 0);
}

static struct image_button_t button_help_hold_festival[] = {
    {68, 257, 27, 27, IB_NORMAL, GROUP_CONTEXT_ICONS, 0, button_help_resource_settings_festival, button_none, 0, 0, 1, 0, 0, 0},
};

static void graphics_shade_rect(int x, int y, int width, int height, int darkness)
{
    struct clip_info_t *cur_clip = graphics_get_clip_info(x, y, width, height);
    if (!cur_clip->is_visible) {
        return;
    }
    for (int yy = y + cur_clip->clipped_pixels_top; yy < y + height - cur_clip->clipped_pixels_bottom; yy++) {
        for (int xx = x + cur_clip->clipped_pixels_left; xx < x + width - cur_clip->clipped_pixels_right; xx++) {
            color_t *pixel = graphics_get_pixel(xx, yy);
            int r = (*pixel & 0xff0000) >> 16;
            int g = (*pixel & 0xff00) >> 8;
            int b = (*pixel & 0xff);
            int grey = (r + g + b) / 3 >> darkness;
            color_t new_pixel = (color_t) (grey << 16 | grey << 8 | grey);
            *pixel = new_pixel;
        }
    }
}

static void draw_foreground_hold_festival(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    outer_panel_draw(52, 12, 34, 18);
    // Hold festival to [selected god]
    lang_text_draw_centered(58, 25 + city_data.festival.god, 52, 28, 544, FONT_LARGE_BLACK);
    for (int god = 0; god < MAX_GODS; god++) {
        if (god == city_data.festival.god) {
            image_draw(image_data_s.group_image_ids[GROUP_PANEL_WINDOWS] + god + 21, 91 * god + 101, 76);
        } else {
            image_draw(image_data_s.group_image_ids[GROUP_PANEL_WINDOWS] + god + 16, 91 * god + 101, 76);
        }
    }
    // Small festival
    button_border_draw(100, 183, 448, 26, focus_id_festival_size_button == 1);
    int width = lang_text_draw(58, 31, 116, 191, FONT_NORMAL_BLACK);
    lang_text_draw_amount(8, 0, city_data.population.population / 20 + 10, 116 + width, 191, FONT_NORMAL_BLACK);
    // Large festival
    button_border_draw(100, 213, 448, 26, focus_id_festival_size_button == 2);
    width = lang_text_draw(58, 32, 116, 221, FONT_NORMAL_BLACK);
    lang_text_draw_amount(8, 0, city_data.population.population / 10 + 20, 116 + width, 221, FONT_NORMAL_BLACK);
    // Grand festival
    button_border_draw(100, 243, 448, 26, focus_id_festival_size_button == 3);
    width = lang_text_draw(58, 33, 116, 251, FONT_NORMAL_BLACK);
    width += lang_text_draw_amount(8, 0, city_data.population.population / 5 + 40, 116 + width, 251, FONT_NORMAL_BLACK);
    width += lang_text_draw_amount(8, 10, city_data.population.population / 500 + 1, 126 + width, 251, FONT_NORMAL_BLACK);
    image_draw(resource_images[RESOURCE_WINE].icon_img_id, 126 + width, 246);
    // greying out of buttons
    if (!city_finance_can_afford(city_data.festival.cost)) {
        graphics_shade_rect(102, (city_data.festival.size * 30 - 30) + 185, 444, 22, 0);
    } else if (city_data.resource.stored_in_warehouses[RESOURCE_WINE] < city_data.population.population / 500 + 1) {
        graphics_shade_rect(102, 245, 444, 22, 0);
    }
    image_buttons_draw(0, 0, button_help_hold_festival, 1);
    set_translation(0, 0);
}

static void button_select_god(int god, __attribute__((unused)) int param2)
{
    city_data.festival.god = god;
    window_invalidate();
}

static struct generic_button_t buttons_select_god[] = {
    {101, 76, 81, 91, button_select_god, button_none, 0, 0},
    {192, 76, 81, 91, button_select_god, button_none, 1, 0},
    {283, 76, 81, 91, button_select_god, button_none, 2, 0},
    {374, 76, 81, 91, button_select_god, button_none, 3, 0},
    {465, 76, 81, 91, button_select_god, button_none, 4, 0},
};

static void city_finance_process_misc(int cost)
{
    city_data.finance.treasury -= cost;
    city_data.finance.this_year.expenses.sundries += cost;
}

static int building_warehouses_remove_resource(int resource, int amount)
{
    int amount_left = amount;
    int building_id = city_data.resource.last_used_warehouse;
    // first go for non-getting warehouses
    for (int i = 1; i < MAX_BUILDINGS && amount_left > 0; i++) {
        building_id++;
        if (building_id >= MAX_BUILDINGS) {
            building_id = 1;
        }
        struct building_t *b = &all_buildings[building_id];
        if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_WAREHOUSE) {
            if (storages[b->storage_id].storage.resource_state[resource] != BUILDING_STORAGE_STATE_GETTING) {
                city_data.resource.last_used_warehouse = building_id;
                amount_left = building_warehouse_remove_resource(b, resource, amount_left);
            }
        }
    }
    // if that doesn't work, take it anyway
    for (int i = 1; i < MAX_BUILDINGS && amount_left > 0; i++) {
        building_id++;
        if (building_id >= MAX_BUILDINGS) {
            building_id = 1;
        }
        struct building_t *b = &all_buildings[building_id];
        if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_WAREHOUSE) {
            city_data.resource.last_used_warehouse = building_id;
            amount_left = building_warehouse_remove_resource(b, resource, amount_left);
        }
    }
    return amount - amount_left;
}

static void button_throw_festival(int size, int cost)
{
    if (!city_finance_can_afford(cost) || (size == FESTIVAL_GRAND && city_data.resource.stored_in_warehouses[RESOURCE_WINE] < city_data.population.population / 500 + 1)) {
        city_data.festival.size = FESTIVAL_NONE;
        city_data.festival.cost = 0;
        return;
    } else {
        city_data.festival.size = size;
        city_data.festival.cost = cost;
        city_data.festival.months_to_go = city_data.festival.size + 1;
        city_finance_process_misc(city_data.festival.cost);
        if (city_data.festival.size == FESTIVAL_GRAND) {
            building_warehouses_remove_resource(RESOURCE_WINE, city_data.population.population / 500 + 1);
        }
        window_advisors_show(ADVISOR_ENTERTAINMENT);
    }
}

static struct generic_button_t buttons_festival_size[] = {
    {100, 183, 448, 26, button_throw_festival, button_none, 1, 0},
    {100, 213, 448, 26, button_throw_festival, button_none, 2, 0},
    {100, 243, 448, 26, button_throw_festival, button_none, 3, 0},
};

static void handle_input_hold_festival(struct mouse_t *m, struct hotkeys_t *h)
{
    if (m->right.went_up || h->escape_pressed) {
        window_advisors_show(ADVISOR_ENTERTAINMENT);
        return;
    }
    struct mouse_t *m_dialog = mouse_in_dialog(m);
    if (generic_buttons_handle_mouse(m_dialog, 0, 0, buttons_select_god, sizeof(buttons_select_god) / sizeof(struct generic_button_t), &focus_id_gods_button)) {
        return;
    }
    if (generic_buttons_handle_mouse(m_dialog, 0, 0, buttons_festival_size, sizeof(buttons_festival_size) / sizeof(struct generic_button_t), &focus_id_festival_size_button)) {
        return;
    }
    if (image_buttons_handle_mouse(m_dialog, 0, 0, button_help_hold_festival, 1, &focus_help_button_id)) {
        return;
    }
    // exit window on click outside of outer panel boundaries
    if (m_dialog->left.went_up && (m_dialog->x < 52 || m_dialog->y < 12 || m_dialog->x > 596 || m_dialog->y > 300)) {
        window_go_back();
        return;
    }
}

static int city_gods_calculate_least_happy(void)
{
    int max_god = 0;
    int max_wrath = 0;
    for (int i = 0; i < MAX_GODS; i++) {
        if (city_data.religion.gods[i].wrath_bolts > max_wrath) {
            max_god = i + 1;
            max_wrath = city_data.religion.gods[i].wrath_bolts;
        }
    }
    if (max_god > 0) {
        city_data.religion.least_happy_god = max_god;
        return 1;
    }
    int min_happiness = 40;
    for (int i = 0; i < MAX_GODS; i++) {
        if (city_data.religion.gods[i].happiness < min_happiness) {
            max_god = i + 1;
            min_happiness = city_data.religion.gods[i].happiness;
        }
    }
    city_data.religion.least_happy_god = max_god;
    return max_god > 0;
}

static int get_amount(struct building_t *granary, int resource)
{
    if (!resource_is_food(resource)) {
        return 0;
    }
    if (granary->type != BUILDING_GRANARY) {
        return 0;
    }
    return granary->data.granary.resource_stored[resource];
}

static void city_sentiment_change_happiness(int amount)
{
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_IN_USE && b->house_size) {
            b->sentiment.house_happiness = calc_bound(b->sentiment.house_happiness + amount, 0, 100);
        }
    }
}

static void building_curse_farms(int big_curse)
{
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_IN_USE && b->output_resource_id && building_is_farm(b->type)) {
            b->data.industry.progress = 0;
            b->data.industry.blessing_days_left = 0;
            b->data.industry.curse_days_left = big_curse ? 48 : 4;
            update_farm_image(b);
        }
    }
}

static void figure_sink_all_ships(void)
{
    for (int i = 1; i < MAX_FIGURES; i++) {
        struct figure_t *f = &figures[i];
        if (!figure_is_alive(f)) {
            continue;
        }
        if (f->type == FIGURE_TRADE_SHIP) {
            all_buildings[f->destination_building_id].data.dock.trade_ship_id = 0;
        } else if (f->type == FIGURE_FISHING_BOAT) {
            all_buildings[f->building_id].data.industry.fishing_boat_id = 0;
        } else {
            continue;
        }
        f->building_id = 0;
        f->type = FIGURE_SHIPWRECK;
        f->wait_ticks = 0;
    }
}

static void building_granary_warehouse_curse(int big)
{
    int max_stored = 0;
    struct building_t *max_building = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE) {
            continue;
        }
        int total_stored = 0;
        if (b->type == BUILDING_WAREHOUSE) {
            for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                total_stored += building_warehouse_get_amount(b, r);
            }
        } else if (b->type == BUILDING_GRANARY) {
            for (int r = RESOURCE_WHEAT; r < FOOD_TYPES_MAX; r++) {
                total_stored += get_amount(b, r);
            }
            total_stored /= UNITS_PER_LOAD;
        } else {
            continue;
        }
        if (total_stored > max_stored) {
            max_stored = total_stored;
            max_building = b;
        }
    }
    if (!max_building) {
        return;
    }
    if (big) {
        should_play_sound = 0;
        city_message_post(0, MESSAGE_FIRE, max_building->type, max_building->grid_offset);
        building_destroy_by_fire(max_building);
        play_sound_effect(SOUND_EFFECT_EXPLOSION);
        map_routing_update_land();
    } else {
        if (max_building->type == BUILDING_WAREHOUSE) {
            int amount = CURSE_LOADS;
            struct building_t *space = max_building;
            for (int i = 0; i < 8 && amount > 0; i++) {
                space = &all_buildings[space->next_part_building_id];
                if (space->id <= 0 || space->loads_stored <= 0) {
                    continue;
                }
                int resource = space->subtype.warehouse_resource_id;
                if (space->loads_stored > amount) {
                    city_resource_remove_from_warehouse(resource, amount);
                    space->loads_stored -= amount;
                    amount = 0;
                } else {
                    city_resource_remove_from_warehouse(resource, space->loads_stored);
                    amount -= space->loads_stored;
                    space->loads_stored = 0;
                    space->subtype.warehouse_resource_id = RESOURCE_NONE;
                }
                building_warehouse_space_set_image(space, resource);
            }
        } else if (max_building->type == BUILDING_GRANARY) {
            int amount = building_granary_remove_resource(max_building, RESOURCE_WHEAT, CURSE_LOADS * UNITS_PER_LOAD);
            amount = building_granary_remove_resource(max_building, RESOURCE_VEGETABLES, amount);
            amount = building_granary_remove_resource(max_building, RESOURCE_FRUIT, amount);
            building_granary_remove_resource(max_building, RESOURCE_MEAT, amount);
        }
    }
}

static void cause_invasion_mars(int enemy_amount)
{
    int grid_offset = start_invasion(ENEMY_TYPE_BARBARIAN, enemy_amount, MAX_INVASION_POINTS, FORMATION_ATTACK_FOOD_CHAIN);
    if (grid_offset > 0) {
        city_message_post(1, MESSAGE_LOCAL_UPRISING_MARS, 0, grid_offset);
    }
}

static void city_sentiment_set_max_happiness(int max)
{
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_IN_USE && b->house_size) {
            if (b->sentiment.house_happiness > max) {
                b->sentiment.house_happiness = max;
            }
            b->sentiment.house_happiness = calc_bound(b->sentiment.house_happiness, 0, 100);
        }
    }
}

static int calculate_people_per_house_type(void)
{
    city_data.population.people_in_tents_shacks = 0;
    city_data.population.people_in_villas_palaces = 0;
    city_data.population.people_in_tents = 0;
    city_data.population.people_in_large_insula_and_above = 0;
    int total = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_UNUSED ||
            b->state == BUILDING_STATE_UNDO ||
            b->state == BUILDING_STATE_DELETED_BY_GAME ||
            b->state == BUILDING_STATE_DELETED_BY_PLAYER) {
            continue;
        }
        if (b->house_size) {
            int pop = b->house_population;
            total += pop;
            if (b->subtype.house_level <= HOUSE_LARGE_TENT) {
                city_data.population.people_in_tents += pop;
            }
            if (b->subtype.house_level <= HOUSE_LARGE_SHACK) {
                city_data.population.people_in_tents_shacks += pop;
            }
            if (b->subtype.house_level >= HOUSE_LARGE_INSULA) {
                city_data.population.people_in_large_insula_and_above += pop;
            }
            if (b->subtype.house_level >= HOUSE_SMALL_VILLA) {
                city_data.population.people_in_villas_palaces += pop;
            }
        }
    }
    return total;
}

static void city_sentiment_update(void)
{
    unsigned int people_in_houses = calculate_people_per_house_type();
    if (people_in_houses < city_data.population.population) {
        remove_from_census(city_data.population.population - people_in_houses);
    }
    int sentiment_contribution_taxes = SENTIMENT_PER_TAX_RATE[city_data.finance.tax_percentage];
    int sentiment_contribution_wages = 0;
    int wage_diff = city_data.labor.wages - city_data.labor.wages_rome;
    if (wage_diff < 0) {
        sentiment_contribution_wages = wage_diff / 2;
        if (!sentiment_contribution_wages) {
            sentiment_contribution_wages = -1;
        }
    } else if (wage_diff > 7) {
        sentiment_contribution_wages = 4;
    } else if (wage_diff > 4) {
        sentiment_contribution_wages = 3;
    } else if (wage_diff > 1) {
        sentiment_contribution_wages = 2;
    } else if (wage_diff > 0) {
        sentiment_contribution_wages = 1;
    }
    int sentiment_contribution_employment = 1;
    if (city_data.labor.unemployment_percentage > 25) {
        sentiment_contribution_employment = -3;
    } else if (city_data.labor.unemployment_percentage > 17) {
        sentiment_contribution_employment = -2;
    } else if (city_data.labor.unemployment_percentage > 10) {
        sentiment_contribution_employment = -1;
    } else if (city_data.labor.unemployment_percentage > 4) {
        sentiment_contribution_employment = 0;
    }
    int sentiment_penalty_tents;
    int pct_tents = calc_percentage(city_data.population.people_in_tents, city_data.population.population);
    if (city_data.population.people_in_villas_palaces > 0) {
        if (pct_tents >= 57) {
            sentiment_penalty_tents = 0;
        } else if (pct_tents >= 40) {
            sentiment_penalty_tents = -3;
        } else if (pct_tents >= 26) {
            sentiment_penalty_tents = -4;
        } else if (pct_tents >= 10) {
            sentiment_penalty_tents = -5;
        } else {
            sentiment_penalty_tents = -6;
        }
    } else if (city_data.population.people_in_large_insula_and_above > 0) {
        if (pct_tents >= 57) {
            sentiment_penalty_tents = 0;
        } else if (pct_tents >= 40) {
            sentiment_penalty_tents = -2;
        } else if (pct_tents >= 26) {
            sentiment_penalty_tents = -3;
        } else if (pct_tents >= 10) {
            sentiment_penalty_tents = -4;
        } else {
            sentiment_penalty_tents = -5;
        }
    } else {
        if (pct_tents >= 40) {
            sentiment_penalty_tents = 0;
        } else if (pct_tents >= 26) {
            sentiment_penalty_tents = -1;
        } else if (pct_tents >= 10) {
            sentiment_penalty_tents = -2;
        } else {
            sentiment_penalty_tents = -3;
        }
    }
    int houses_calculated = 0;
    int houses_needing_food = 0;
    int total_sentiment_contribution_food = 0;
    int total_sentiment_penalty_tents = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE || !b->house_size) {
            continue;
        }
        if (!b->house_population) {
            b->sentiment.house_happiness = 50;
            continue;
        }
        if (city_data.population.population < 300) {
            // small town has no complaints
            sentiment_contribution_employment = 0;
            sentiment_contribution_taxes = 0;
            sentiment_contribution_wages = 0;

            b->sentiment.house_happiness = 50;
            if (city_data.population.population < 200) {
                b->sentiment.house_happiness += 10;
            }
            continue;
        }
        // population >= 300
        houses_calculated++;
        int sentiment_contribution_food = 0;
        int sentiment_contribution_tents = 0;
        if (!house_properties[b->subtype.house_level].food_types) {
            // tents
            b->house_days_without_food = 0;
            sentiment_contribution_tents = sentiment_penalty_tents;
            total_sentiment_penalty_tents += sentiment_penalty_tents;
        } else {
            // shack+
            houses_needing_food++;
            if (b->data.house.num_foods >= 2) {
                sentiment_contribution_food = 2;
                total_sentiment_contribution_food += 2;
                b->house_days_without_food = 0;
            } else if (b->data.house.num_foods >= 1) {
                sentiment_contribution_food = 1;
                total_sentiment_contribution_food += 1;
                b->house_days_without_food = 0;
            } else {
                // needs food but has no food
                if (b->house_days_without_food < 3) {
                    b->house_days_without_food++;
                }
                sentiment_contribution_food = -b->house_days_without_food;
                total_sentiment_contribution_food -= b->house_days_without_food;
            }
        }
        b->sentiment.house_happiness += sentiment_contribution_taxes;
        b->sentiment.house_happiness += sentiment_contribution_wages;
        b->sentiment.house_happiness += sentiment_contribution_employment;
        b->sentiment.house_happiness += sentiment_contribution_food;
        b->sentiment.house_happiness += sentiment_contribution_tents;
        b->sentiment.house_happiness = calc_bound(b->sentiment.house_happiness, 0, 100);
    }

    int sentiment_contribution_food = 0;
    int sentiment_contribution_tents = 0;
    if (houses_needing_food) {
        sentiment_contribution_food = total_sentiment_contribution_food / houses_needing_food;
    }
    if (houses_calculated) {
        sentiment_contribution_tents = total_sentiment_penalty_tents / houses_calculated;
    }

    int total_sentiment = 0;
    int total_houses = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_IN_USE && b->house_size && b->house_population) {
            total_houses++;
            total_sentiment += b->sentiment.house_happiness;
        }
    }
    if (total_houses) {
        city_data.sentiment.value = total_sentiment / total_houses;
    } else {
        city_data.sentiment.value = 60;
    }
    if (city_data.sentiment.message_delay) {
        city_data.sentiment.message_delay--;
    }
    if (city_data.sentiment.value < 48 && city_data.sentiment.value < city_data.sentiment.previous_value) {
        if (city_data.sentiment.message_delay <= 0) {
            city_data.sentiment.message_delay = 3;
            if (city_data.sentiment.value < 35) {
                city_message_post(0, MESSAGE_PEOPLE_ANGRY, 0, 0);
            } else if (city_data.sentiment.value < 40) {
                city_message_post(0, MESSAGE_PEOPLE_UNHAPPY, 0, 0);
            } else {
                city_message_post(0, MESSAGE_PEOPLE_DISGRUNTLED, 0, 0);
            }
        }
    }
    int worst_sentiment = 0;
    city_data.sentiment.low_mood_cause = LOW_MOOD_CAUSE_NONE;
    if (sentiment_contribution_food < worst_sentiment) {
        worst_sentiment = sentiment_contribution_food;
        city_data.sentiment.low_mood_cause = LOW_MOOD_CAUSE_NO_FOOD;
    }
    if (sentiment_contribution_employment < worst_sentiment) {
        worst_sentiment = sentiment_contribution_employment;
        city_data.sentiment.low_mood_cause = LOW_MOOD_CAUSE_NO_JOBS;
    }
    if (sentiment_contribution_taxes < worst_sentiment) {
        worst_sentiment = sentiment_contribution_taxes;
        city_data.sentiment.low_mood_cause = LOW_MOOD_CAUSE_HIGH_TAXES;
    }
    if (sentiment_contribution_wages < worst_sentiment) {
        worst_sentiment = sentiment_contribution_wages;
        city_data.sentiment.low_mood_cause = LOW_MOOD_CAUSE_LOW_WAGES;
    }
    if (sentiment_contribution_tents < worst_sentiment) {
        city_data.sentiment.low_mood_cause = LOW_MOOD_CAUSE_MANY_TENTS;
    }
    city_data.sentiment.previous_value = city_data.sentiment.value;
}

static void city_gods_calculate_moods(int update_moods)
{
    // base happiness: percentage of houses covered
    for (int i = 0; i < MAX_GODS; i++) {
        city_data.religion.gods[i].target_happiness = culture_coverage.religion[i];
    }

    int max_temples = 0;
    int max_god = TIE;
    int min_temples = 100000;
    int min_god = TIE;
    for (int i = 0; i < MAX_GODS; i++) {
        int num_temples = 0;
        switch (i) {
            case GOD_CERES:
                num_temples = count_data.buildings[BUILDING_SMALL_TEMPLE_CERES].total + count_data.buildings[BUILDING_LARGE_TEMPLE_CERES].total;
                break;
            case GOD_NEPTUNE:
                num_temples = count_data.buildings[BUILDING_SMALL_TEMPLE_NEPTUNE].total + count_data.buildings[BUILDING_LARGE_TEMPLE_NEPTUNE].total;
                break;
            case GOD_MERCURY:
                num_temples = count_data.buildings[BUILDING_SMALL_TEMPLE_MERCURY].total + count_data.buildings[BUILDING_LARGE_TEMPLE_MERCURY].total;
                break;
            case GOD_MARS:
                num_temples = count_data.buildings[BUILDING_SMALL_TEMPLE_MARS].total + count_data.buildings[BUILDING_LARGE_TEMPLE_MARS].total;
                break;
            case GOD_VENUS:
                num_temples = count_data.buildings[BUILDING_SMALL_TEMPLE_VENUS].total + count_data.buildings[BUILDING_LARGE_TEMPLE_VENUS].total;
                break;
        }
        if (num_temples == max_temples) {
            max_god = TIE;
        } else if (num_temples > max_temples) {
            max_temples = num_temples;
            max_god = i;
        }
        if (num_temples == min_temples) {
            min_god = TIE;
        } else if (num_temples < min_temples) {
            min_temples = num_temples;
            min_god = i;
        }
    }
    // happiness factor based on months since festival (max 40)
    for (int i = 0; i < MAX_GODS; i++) {
        int festival_penalty = city_data.religion.gods[i].months_since_festival;
        if (festival_penalty > 40) {
            festival_penalty = 40;
        }
        city_data.religion.gods[i].target_happiness += 12 - festival_penalty;
    }

    if (max_god < MAX_GODS) {
        if (city_data.religion.gods[max_god].target_happiness >= 50) {
            city_data.religion.gods[max_god].target_happiness = 100;
        } else {
            city_data.religion.gods[max_god].target_happiness += 50;
        }
    }
    if (min_god < MAX_GODS) {
        city_data.religion.gods[min_god].target_happiness -= 25;
    }
    int min_happiness;
    if (city_data.population.population < 100) {
        min_happiness = 50;
    } else if (city_data.population.population < 200) {
        min_happiness = 40;
    } else if (city_data.population.population < 300) {
        min_happiness = 30;
    } else if (city_data.population.population < 400) {
        min_happiness = 20;
    } else if (city_data.population.population < 500) {
        min_happiness = 10;
    } else {
        min_happiness = 0;
    }
    for (int i = 0; i < MAX_GODS; i++) {
        city_data.religion.gods[i].target_happiness =
            calc_bound(city_data.religion.gods[i].target_happiness, min_happiness, 100);
    }
    if (update_moods) {
        for (int i = 0; i < MAX_GODS; i++) {
            struct god_status_t *god = &city_data.religion.gods[i];
            if (god->happiness < god->target_happiness) {
                god->happiness++;
            } else if (god->happiness > god->target_happiness) {
                god->happiness--;
            }
            if (god->happiness > 50) {
                god->small_curse_done = 0;
            }
            if (god->happiness < 50) {
                god->blessing_done = 0;
            }
        }
        int god_id = random_data.random1_7bit & 7;
        if (god_id < MAX_GODS) {
            struct god_status_t *god = &city_data.religion.gods[god_id];
            if (god->happiness >= 50) {
                god->wrath_bolts = 0;
            } else if (god->happiness < 40) {
                if (god->happiness >= 20) {
                    god->wrath_bolts += 1;
                } else if (god->happiness >= 10) {
                    god->wrath_bolts += 2;
                } else {
                    god->wrath_bolts += 5;
                }
            }
            if (god->wrath_bolts > 50) {
                god->wrath_bolts = 50;
            }
        }
        if (time_data.day != 0) {
            return;
        }
        // handle blessings, curses, etc every month
        for (int i = 0; i < MAX_GODS; i++) {
            city_data.religion.gods[i].months_since_festival++;
        }
        if (god_id >= MAX_GODS) {
            if (city_gods_calculate_least_happy()) {
                god_id = city_data.religion.least_happy_god - 1;
            }
        }
        if (god_id < MAX_GODS) {
            struct god_status_t *god = &city_data.religion.gods[god_id];
            if (god->happiness >= 100 && !god->blessing_done) {
                god->blessing_done = 1;
                switch (god_id) {
                    case GOD_CERES:
                        city_message_post(1, MESSAGE_BLESSING_FROM_CERES, 0, 0);
                        for (int i = 1; i < MAX_BUILDINGS; i++) {
                            struct building_t *b = &all_buildings[i];
                            if (b->state == BUILDING_STATE_IN_USE && b->output_resource_id && building_is_farm(b->type)) {
                                b->data.industry.progress = MAX_PROGRESS_RAW;
                                b->data.industry.curse_days_left = 0;
                                b->data.industry.blessing_days_left = 16;
                                update_farm_image(b);
                            }
                        }
                        break;
                    case GOD_NEPTUNE:
                        city_message_post(1, MESSAGE_BLESSING_FROM_NEPTUNE, 0, 0);
                        city_data.religion.neptune_double_trade_active = 1;
                        break;
                    case GOD_MERCURY:
                        city_message_post(1, MESSAGE_BLESSING_FROM_MERCURY, 0, 0);
                        int min_stored = INFINITE;
                        struct building_t *min_building = 0;
                        for (int i = 1; i < MAX_BUILDINGS; i++) {
                            struct building_t *b = &all_buildings[i];
                            if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_GRANARY) {
                                continue;
                            }
                            int total_stored = 0;
                            for (int r = RESOURCE_WHEAT; r < FOOD_TYPES_MAX; r++) {
                                total_stored += get_amount(b, r);
                            }
                            if (total_stored < min_stored) {
                                min_stored = total_stored;
                                min_building = b;
                            }
                        }
                        if (min_building) {
                            for (int n = 0; n < 6; n++) {
                                building_granary_add_resource(min_building, RESOURCE_WHEAT, 0);
                            }
                            for (int n = 0; n < 6; n++) {
                                building_granary_add_resource(min_building, RESOURCE_VEGETABLES, 0);
                            }
                            for (int n = 0; n < 6; n++) {
                                building_granary_add_resource(min_building, RESOURCE_FRUIT, 0);
                            }
                            for (int n = 0; n < 6; n++) {
                                building_granary_add_resource(min_building, RESOURCE_MEAT, 0);
                            }
                        }
                        break;
                    case GOD_MARS:
                        city_message_post(1, MESSAGE_BLESSING_FROM_MARS, 0, 0);
                        city_data.religion.mars_spirit_power = 10;
                        break;
                    case GOD_VENUS:
                        city_message_post(1, MESSAGE_BLESSING_FROM_VENUS, 0, 0);
                        city_sentiment_change_happiness(25);
                        break;
                }
            } else if (god->wrath_bolts >= 20 && !god->small_curse_done && god->months_since_festival > 3) {
                god->small_curse_done = 1;
                god->wrath_bolts = 0;
                god->happiness += 12;
                switch (god_id) {
                    case GOD_CERES:
                        city_message_post(1, MESSAGE_CERES_IS_UPSET, 0, 0);
                        building_curse_farms(0);
                        break;
                    case GOD_NEPTUNE:
                        city_message_post(1, MESSAGE_NEPTUNE_IS_UPSET, 0, 0);
                        figure_sink_all_ships();
                        city_data.religion.neptune_sank_ships = 1;
                        break;
                    case GOD_MERCURY:
                        city_message_post(1, MESSAGE_MERCURY_IS_UPSET, 0, 0);
                        building_granary_warehouse_curse(0);
                        break;
                    case GOD_MARS:
                        city_message_post(1, MESSAGE_MARS_IS_UPSET, 0, 0);
                        cause_invasion_mars(MARS_INVASION_SMALL);
                        break;
                    case GOD_VENUS:
                        city_message_post(1, MESSAGE_VENUS_IS_UPSET, 0, 0);
                        city_sentiment_set_max_happiness(50);
                        city_sentiment_change_happiness(-5);
                        city_data.health.value = calc_bound(city_data.health.value - 10, 0, 100);
                        city_sentiment_update();
                        break;
                }
            } else if (god->wrath_bolts >= 50 && god->months_since_festival > 3) {
                god->wrath_bolts = 0;
                god->happiness += 30;
                switch (god_id) {
                    case GOD_CERES:
                        city_message_post(1, MESSAGE_WRATH_OF_CERES, 0, 0);
                        building_curse_farms(1);
                        break;
                    case GOD_NEPTUNE:
                        if (city_data.trade.num_sea_routes <= 0) {
                            city_message_post(1, MESSAGE_WRATH_OF_NEPTUNE_NO_SEA_TRADE, 0, 0);
                            return;
                        } else {
                            city_message_post(1, MESSAGE_WRATH_OF_NEPTUNE, 0, 0);
                            figure_sink_all_ships();
                            city_data.religion.neptune_sank_ships = 1;
                            city_data.trade.sea_trade_problem_duration = 80;
                        }
                        break;
                    case GOD_MERCURY:
                        city_message_post(1, MESSAGE_WRATH_OF_MERCURY, 0, 0);
                        building_granary_warehouse_curse(1);
                        break;
                    case GOD_MARS:
                    {
                        struct formation_t *best_legion = 0;
                        int best_legion_weight = 0;
                        for (int i = 0; i < MAX_LEGIONS; i++) {
                            if (legion_formations[i].in_use) {
                                int weight = legion_formations[i].num_figures;
                                if (legion_formations[i].figure_type == FIGURE_FORT_LEGIONARY) {
                                    weight *= 2;
                                }
                                if (weight > best_legion_weight) {
                                    best_legion_weight = weight;
                                    best_legion = &legion_formations[i];
                                }
                            }
                        }
                        if (best_legion) {
                            for (int i = 0; i < best_legion->max_figures; i++) {
                                if (best_legion->figures[i]) {
                                    struct figure_t *f = &figures[best_legion->figures[i]];
                                    struct map_point_t nearest_barracks_road_tile = { 0 };
                                    set_destination__closest_building_of_type(best_legion->building_id, BUILDING_BARRACKS, &nearest_barracks_road_tile);
                                    figure_route_remove(f);
                                    if (nearest_barracks_road_tile.x) {
                                        f->destination_x = nearest_barracks_road_tile.x;
                                        f->destination_y = nearest_barracks_road_tile.y;
                                    } else {
                                        f->destination_x = scenario.exit_point.x;
                                        f->destination_y = scenario.exit_point.y;
                                    }
                                    f->action_state = FIGURE_ACTION_SOLDIER_RETURNING_TO_BARRACKS;
                                }
                            }
                            best_legion->cursed_by_mars = 96;
                            city_message_post(1, MESSAGE_WRATH_OF_MARS, 0, 0);
                        } else {
                            city_message_post(1, MESSAGE_WRATH_OF_MARS_NO_MILITARY, 0, 0);
                        }
                        cause_invasion_mars(MARS_INVASION_LARGE);
                        break;
                    }
                    case GOD_VENUS:
                        city_message_post(1, MESSAGE_WRATH_OF_VENUS, 0, 0);
                        city_sentiment_set_max_happiness(40);
                        city_sentiment_change_happiness(-10);
                        if (city_data.health.value >= 80) {
                            city_data.health.value = calc_bound(city_data.health.value - 50, 0, 100);
                        } else if (city_data.health.value >= 60) {
                            city_data.health.value = calc_bound(city_data.health.value - 40, 0, 100);
                        } else {
                            city_data.health.value = calc_bound(city_data.health.value - 20, 0, 100);
                        }
                        city_data.religion.venus_curse_active = 1;
                        city_sentiment_update();
                        break;
                }
            }
        }
        min_happiness = 100;
        for (int i = 0; i < MAX_GODS; i++) {
            if (city_data.religion.gods[i].happiness < min_happiness) {
                min_happiness = city_data.religion.gods[i].happiness;
            }
        }
        if (city_data.religion.angry_message_delay) {
            city_data.religion.angry_message_delay--;
        } else if (min_happiness < 30) {
            city_data.religion.angry_message_delay = 20;
            if (min_happiness < 10) {
                city_message_post(0, MESSAGE_GODS_WRATHFUL, 0, 0);
            } else {
                city_message_post(0, MESSAGE_GODS_UNHAPPY, 0, 0);
            }
        }
    }
}

static void city_culture_calculate(void)
{
    city_data.culture.average_entertainment = 0;
    city_data.culture.average_religion = 0;
    city_data.culture.average_education = 0;
    city_data.culture.average_health = 0;

    int num_houses = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_IN_USE && b->house_size) {
            num_houses++;
            city_data.culture.average_entertainment += b->data.house.entertainment;
            city_data.culture.average_religion += b->data.house.num_gods;
            city_data.culture.average_education += b->data.house.education;
            city_data.culture.average_health += b->data.house.health;
        }
    }
    if (num_houses) {
        city_data.culture.average_entertainment /= num_houses;
        city_data.culture.average_religion /= num_houses;
        city_data.culture.average_education /= num_houses;
        city_data.culture.average_health /= num_houses;
    }
    // calculate entertainment shows
    city_data.entertainment.theater_shows = 0;
    city_data.entertainment.theater_no_shows_weighted = 0;
    city_data.entertainment.amphitheater_shows = 0;
    city_data.entertainment.amphitheater_no_shows_weighted = 0;
    city_data.entertainment.colosseum_shows = 0;
    city_data.entertainment.colosseum_no_shows_weighted = 0;
    city_data.entertainment.hippodrome_shows = 0;
    city_data.entertainment.hippodrome_no_shows_weighted = 0;
    city_data.entertainment.venue_needing_shows = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE) {
            continue;
        }
        switch (b->type) {
            case BUILDING_THEATER:
                if (b->data.entertainment.days1) {
                    city_data.entertainment.theater_shows++;
                } else {
                    city_data.entertainment.theater_no_shows_weighted++;
                }
                break;
            case BUILDING_AMPHITHEATER:
                if (b->data.entertainment.days1) {
                    city_data.entertainment.amphitheater_shows++;
                } else {
                    city_data.entertainment.amphitheater_no_shows_weighted += 2;
                }
                if (b->data.entertainment.days2) {
                    city_data.entertainment.amphitheater_shows++;
                } else {
                    city_data.entertainment.amphitheater_no_shows_weighted += 2;
                }
                break;
            case BUILDING_COLOSSEUM:
                if (b->data.entertainment.days1) {
                    city_data.entertainment.colosseum_shows++;
                } else {
                    city_data.entertainment.colosseum_no_shows_weighted += 3;
                }
                if (b->data.entertainment.days2) {
                    city_data.entertainment.colosseum_shows++;
                } else {
                    city_data.entertainment.colosseum_no_shows_weighted += 3;
                }
                break;
            case BUILDING_HIPPODROME:
                if (b->data.entertainment.days1) {
                    city_data.entertainment.hippodrome_shows++;
                } else {
                    city_data.entertainment.hippodrome_no_shows_weighted += 100;
                }
                break;
        }
    }
    int worst_shows = 0;
    if (city_data.entertainment.theater_no_shows_weighted > worst_shows) {
        worst_shows = city_data.entertainment.theater_no_shows_weighted;
        city_data.entertainment.venue_needing_shows = 1;
    }
    if (city_data.entertainment.amphitheater_no_shows_weighted > worst_shows) {
        worst_shows = city_data.entertainment.amphitheater_no_shows_weighted;
        city_data.entertainment.venue_needing_shows = 2;
    }
    if (city_data.entertainment.colosseum_no_shows_weighted > worst_shows) {
        worst_shows = city_data.entertainment.colosseum_no_shows_weighted;
        city_data.entertainment.venue_needing_shows = 3;
    }
    if (city_data.entertainment.hippodrome_no_shows_weighted > worst_shows) {
        city_data.entertainment.venue_needing_shows = 4;
    }
}

static int draw_background_entertainment_advisor(void)
{
    city_gods_calculate_moods(0);
    city_culture_calculate();
    outer_panel_draw(0, 0, 40, ENTERTAINMENT_ADVISOR_HEIGHT);
    image_draw(image_data_s.group_image_ids[GROUP_ADVISOR_ICONS] + 8, 10, 10);
    lang_text_draw(58, 0, 60, 12, FONT_LARGE_BLACK);
    lang_text_draw(58, 1, 180, 46, FONT_SMALL_PLAIN);
    lang_text_draw(58, 2, 260, 46, FONT_SMALL_PLAIN);
    lang_text_draw(58, 3, PEOPLE_OFFSET + 10, 46, FONT_SMALL_PLAIN);
    lang_text_draw_centered(58, 4, COVERAGE_OFFSET, 46, COVERAGE_WIDTH, FONT_SMALL_PLAIN);
    inner_panel_draw(32, 60, 36, 5);
    // theaters
    lang_text_draw_amount(8, 34, count_data.buildings[BUILDING_THEATER].total, 40, 64, FONT_NORMAL_WHITE);
    text_draw_number_centered(count_data.buildings[BUILDING_THEATER].active, 150, 64, 100, FONT_NORMAL_WHITE);
    text_draw_number_centered(city_data.entertainment.theater_shows, 230, 64, 100, FONT_NORMAL_WHITE);
    int width = text_draw_number(500 * count_data.buildings[BUILDING_THEATER].active, '_', " ",
        PEOPLE_OFFSET, 64, FONT_NORMAL_WHITE);
    lang_text_draw(58, 5, PEOPLE_OFFSET + width, 64, FONT_NORMAL_WHITE);
    if (culture_coverage.theater == 0) {
        lang_text_draw_centered(57, 10, COVERAGE_OFFSET, 64, COVERAGE_WIDTH, FONT_NORMAL_WHITE);
    } else if (culture_coverage.theater < 100) {
        lang_text_draw_centered(57, 11 + culture_coverage.theater / 10, COVERAGE_OFFSET, 64, COVERAGE_WIDTH, FONT_NORMAL_WHITE);
        //lang_text_draw_centered(57, 17, COVERAGE_OFFSET, 64, COVERAGE_WIDTH, FONT_NORMAL_WHITE);
    } else {
        lang_text_draw_centered(57, 21, COVERAGE_OFFSET, 64, COVERAGE_WIDTH, FONT_NORMAL_WHITE);
    }
    // amphitheaters
    lang_text_draw_amount(8, 36, count_data.buildings[BUILDING_AMPHITHEATER].total, 40, 84, FONT_NORMAL_WHITE);
    text_draw_number_centered(count_data.buildings[BUILDING_AMPHITHEATER].active, 150, 84, 100, FONT_NORMAL_WHITE);
    text_draw_number_centered(city_data.entertainment.amphitheater_shows, 230, 84, 100, FONT_NORMAL_WHITE);
    width = text_draw_number(800 * count_data.buildings[BUILDING_AMPHITHEATER].active, '@', " ",
        PEOPLE_OFFSET, 84, FONT_NORMAL_WHITE);
    lang_text_draw(58, 5, PEOPLE_OFFSET + width, 84, FONT_NORMAL_WHITE);
    if (culture_coverage.amphitheater == 0) {
        lang_text_draw_centered(57, 10, COVERAGE_OFFSET, 84, COVERAGE_WIDTH, FONT_NORMAL_WHITE);
    } else if (culture_coverage.amphitheater < 100) {
        lang_text_draw_centered(57, 11 + culture_coverage.amphitheater / 10,
            COVERAGE_OFFSET, 84, COVERAGE_WIDTH, FONT_NORMAL_WHITE);
    } else {
        lang_text_draw_centered(57, 21, COVERAGE_OFFSET, 84, COVERAGE_WIDTH, FONT_NORMAL_WHITE);
    }
    // colosseums
    lang_text_draw_amount(8, 38, count_data.buildings[BUILDING_COLOSSEUM].total, 40, 104, FONT_NORMAL_WHITE);
    text_draw_number_centered(count_data.buildings[BUILDING_COLOSSEUM].active, 150, 104, 100, FONT_NORMAL_WHITE);
    text_draw_number_centered(city_data.entertainment.colosseum_shows, 230, 104, 100, FONT_NORMAL_WHITE);
    width = text_draw_number(1500 * count_data.buildings[BUILDING_COLOSSEUM].active, '@', " ",
        PEOPLE_OFFSET, 104, FONT_NORMAL_WHITE);
    lang_text_draw(58, 5, PEOPLE_OFFSET + width, 104, FONT_NORMAL_WHITE);
    if (culture_coverage.colosseum == 0) {
        lang_text_draw_centered(57, 10, COVERAGE_OFFSET, 104, COVERAGE_WIDTH, FONT_NORMAL_WHITE);
    } else if (culture_coverage.colosseum < 100) {
        lang_text_draw_centered(57, 11 + culture_coverage.colosseum / 10, COVERAGE_OFFSET, 104, COVERAGE_WIDTH, FONT_NORMAL_WHITE);
    } else {
        lang_text_draw_centered(57, 21, COVERAGE_OFFSET, 104, COVERAGE_WIDTH, FONT_NORMAL_WHITE);
    }
    // hippodromes
    lang_text_draw_amount(8, 40, count_data.buildings[BUILDING_HIPPODROME].total, 40, 123, FONT_NORMAL_WHITE);
    text_draw_number_centered(count_data.buildings[BUILDING_HIPPODROME].active, 150, 123, 100, FONT_NORMAL_WHITE);
    text_draw_number_centered(city_data.entertainment.hippodrome_shows, 230, 123, 100, FONT_NORMAL_WHITE);
    lang_text_draw_centered(58, 6, PEOPLE_OFFSET + 10, 123, 100, FONT_NORMAL_WHITE);
    if (culture_coverage.hippodrome == 0) {
        lang_text_draw_centered(57, 10, COVERAGE_OFFSET, 123, COVERAGE_WIDTH, FONT_NORMAL_WHITE);
    } else {
        lang_text_draw_centered(57, 21, COVERAGE_OFFSET, 123, COVERAGE_WIDTH, FONT_NORMAL_WHITE);
    }
    int entertainment_advice = 1;
    struct house_demands_t *demands = &city_data.houses;
    if (demands->missing.entertainment > demands->missing.more_entertainment) {
        entertainment_advice = 3;
    } else if (!demands->missing.more_entertainment) {
        entertainment_advice = city_data.culture.average_entertainment ? 1 : 0;
    } else if (city_data.entertainment.venue_needing_shows) {
        entertainment_advice = 3 + city_data.entertainment.venue_needing_shows;
    }
    lang_text_draw_multiline(58, 7 + entertainment_advice, 60, 148, 512, FONT_NORMAL_BLACK);
    inner_panel_draw(48, 252, 34, 6);
    image_draw(image_data_s.group_image_ids[GROUP_PANEL_WINDOWS] + 15, 460, 255);
    lang_text_draw(58, 17, 52, 224, FONT_LARGE_BLACK);
    width = lang_text_draw_amount(8, 4, city_data.festival.months_since_festival, 112, 260, FONT_NORMAL_WHITE);
    lang_text_draw(58, 15, 112 + width, 260, FONT_NORMAL_WHITE);
    if (city_data.festival.size) {
        lang_text_draw_centered(58, 34, 102, 284, 300, FONT_NORMAL_WHITE);
    } else {
        lang_text_draw_centered(58, 16, 102, 284, 300, FONT_NORMAL_WHITE);
    }
    int festival_advice = 6;
    if (city_data.festival.months_since_festival <= 1) {
        festival_advice = 0;
    } else if (city_data.festival.months_since_festival <= 6) {
        festival_advice = 1;
    } else if (city_data.festival.months_since_festival <= 12) {
        festival_advice = 2;
    } else if (city_data.festival.months_since_festival <= 18) {
        festival_advice = 3;
    } else if (city_data.festival.months_since_festival <= 24) {
        festival_advice = 4;
    } else if (city_data.festival.months_since_festival <= 30) {
        festival_advice = 5;
    }
    lang_text_draw_multiline(58, 18 + festival_advice, 56, 305, 400, FONT_NORMAL_WHITE);
    return ENTERTAINMENT_ADVISOR_HEIGHT;
}

static void draw_foreground_entertainment_advisor(void)
{
    if (!city_data.festival.size) {
        button_border_draw(102, 280, 300, 20, focus_button_id_entertainment_advisor == 1);
    }
}

static void button_hold_festival(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    if (!city_data.festival.size) {
        struct window_type_t window = {
            WINDOW_HOLD_FESTIVAL,
            window_advisors_draw_dialog_background,
            draw_foreground_hold_festival,
            handle_input_hold_festival,
        };
        buttons_festival_size[0].parameter2 = city_data.population.population / 20 + 10;
        buttons_festival_size[1].parameter2 = city_data.population.population / 10 + 20;
        buttons_festival_size[2].parameter2 = city_data.population.population / 5 + 40;
        window_show(&window);
    }
}

static struct generic_button_t hold_festival_button[] = {
    {102, 280, 300, 20, button_hold_festival, button_none, 0, 0},
};

static int handle_mouse_entertainment_advisor(struct mouse_t *m)
{
    return generic_buttons_handle_mouse(m, 0, 0, hold_festival_button, 1, &focus_button_id_entertainment_advisor);
}

static struct advisor_window_type_t *window_advisor_entertainment(void)
{
    static struct advisor_window_type_t window = {
        draw_background_entertainment_advisor,
        draw_foreground_entertainment_advisor,
        handle_mouse_entertainment_advisor,
    };
    focus_button_id_entertainment_advisor = 0;
    return &window;
}

static void city_finance_estimate_taxes(void)
{
    city_data.taxes.monthly.collected_plebs = 0;
    city_data.taxes.monthly.collected_patricians = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_IN_USE && b->house_size && b->house_tax_coverage) {
            int is_patrician = b->subtype.house_level >= HOUSE_SMALL_VILLA;
            if (is_patrician) {
                city_data.taxes.monthly.collected_patricians += b->house_population * house_properties[b->subtype.house_level].tax_multiplier;
            } else {
                city_data.taxes.monthly.collected_plebs += b->house_population * house_properties[b->subtype.house_level].tax_multiplier;
            }
        }
    }
    int monthly_patricians = calc_adjust_with_percentage(
        city_data.taxes.monthly.collected_patricians / 2,
        city_data.finance.tax_percentage);
    int monthly_plebs = calc_adjust_with_percentage(
        city_data.taxes.monthly.collected_plebs / 2,
        city_data.finance.tax_percentage);
    int estimated_rest_of_year = (12 - time_data.month) * (monthly_patricians + monthly_plebs);

    city_data.finance.this_year.income.taxes =
        city_data.taxes.yearly.collected_plebs + city_data.taxes.yearly.collected_patricians;
    city_data.finance.estimated_tax_income = city_data.finance.this_year.income.taxes + estimated_rest_of_year;
}

static void city_finance_calculate_totals(void)
{
    struct finance_overview_t *this_year = &city_data.finance.this_year;
    this_year->income.total =
        this_year->income.donated +
        this_year->income.taxes +
        this_year->income.exports;

    this_year->expenses.total =
        this_year->expenses.sundries +
        this_year->expenses.salary +
        this_year->expenses.interest +
        this_year->expenses.construction +
        this_year->expenses.wages +
        this_year->expenses.imports;

    struct finance_overview_t *last_year = &city_data.finance.last_year;
    last_year->net_in_out = last_year->income.total - last_year->expenses.total;
    this_year->net_in_out = this_year->income.total - this_year->expenses.total;
    this_year->balance = last_year->balance + this_year->net_in_out;

    this_year->expenses.tribute = 0;
}

static void button_change_taxes(int value, __attribute__((unused)) int param2)
{
    city_data.finance.tax_percentage = calc_bound(city_data.finance.tax_percentage + value, 0, 25);
    city_finance_estimate_taxes();
    city_finance_calculate_totals();
    window_invalidate();
}

static struct arrow_button_t arrow_buttons_taxes[] = {
    {180, 75, 17, 24, button_change_taxes, -1, 0, 0, 0},
    {204, 75, 15, 24, button_change_taxes, 1, 0, 0, 0}
};

static void draw_row(int group, int number, int y, int value_last_year, int value_this_year)
{
    lang_text_draw(group, number, 80, y, FONT_NORMAL_BLACK);
    text_draw_number(value_last_year, '@', " ", 290, y, FONT_NORMAL_BLACK);
    text_draw_number(value_this_year, '@', " ", 430, y, FONT_NORMAL_BLACK);
}

static int draw_background_financial_advisor(void)
{
    outer_panel_draw(0, 0, 40, FINANCIAL_ADVISOR_HEIGHT);
    image_draw(image_data_s.group_image_ids[GROUP_ADVISOR_ICONS] + 10, 10, 10);
    lang_text_draw(60, 0, 60, 12, FONT_LARGE_BLACK);
    inner_panel_draw(64, 48, 34, 5);
    int width;
    if (city_data.finance.treasury < 0) {
        width = lang_text_draw(60, 3, 70, 58, FONT_NORMAL_RED);
        lang_text_draw_amount(8, 0, -city_data.finance.treasury, 72 + width, 58, FONT_NORMAL_RED);
    } else {
        width = lang_text_draw(60, 2, 70, 58, FONT_NORMAL_WHITE);
        lang_text_draw_amount(8, 0, city_data.finance.treasury, 72 + width, 58, FONT_NORMAL_WHITE);
    }
    // tax percentage and estimated income
    lang_text_draw(60, 1, 70, 81, FONT_NORMAL_WHITE);
    width = text_draw_percentage(city_data.finance.tax_percentage, 240, 81, FONT_NORMAL_WHITE);
    width += lang_text_draw(60, 4, 240 + width, 81, FONT_NORMAL_WHITE);
    lang_text_draw_amount(8, 0, city_data.finance.estimated_tax_income, 240 + width, 81, FONT_NORMAL_WHITE);
    // percentage taxpayers
    width = text_draw_percentage(city_data.taxes.percentage_taxed_people, 70, 103, FONT_NORMAL_WHITE);
    lang_text_draw(60, 5, 70 + width, 103, FONT_NORMAL_WHITE);
    // table headers
    lang_text_draw(60, 6, 270, 133, FONT_NORMAL_BLACK);
    lang_text_draw(60, 7, 400, 133, FONT_NORMAL_BLACK);
    // income
    draw_row(60, 8, 155, city_data.finance.last_year.income.taxes, city_data.finance.this_year.income.taxes);
    draw_row(60, 9, 170, city_data.finance.last_year.income.exports, city_data.finance.this_year.income.exports);
    draw_row(60, 20, 185, city_data.finance.last_year.income.donated, city_data.finance.this_year.income.donated);
    graphics_draw_horizontal_line(280, 350, 198, COLOR_BLACK);
    graphics_draw_horizontal_line(420, 490, 198, COLOR_BLACK);
    draw_row(60, 10, 203, city_data.finance.last_year.income.total, city_data.finance.this_year.income.total);
    // expenses
    draw_row(60, 11, 227, city_data.finance.last_year.expenses.imports, city_data.finance.this_year.expenses.imports);
    draw_row(60, 12, 242, city_data.finance.last_year.expenses.wages, city_data.finance.this_year.expenses.wages);
    draw_row(60, 13, 257, city_data.finance.last_year.expenses.construction, city_data.finance.this_year.expenses.construction);
    // interest (with percentage)
    width = lang_text_draw(60, 14, 80, 272, FONT_NORMAL_BLACK);
    text_draw_percentage(10, 80 + width, 272, FONT_NORMAL_BLACK);
    text_draw_number(city_data.finance.last_year.expenses.interest, '@', " ", 290, 272, FONT_NORMAL_BLACK);
    text_draw_number(city_data.finance.last_year.expenses.interest, '@', " ", 430, 272, FONT_NORMAL_BLACK);
    draw_row(60, 15, 287, city_data.finance.last_year.expenses.salary, city_data.finance.this_year.expenses.salary);
    draw_row(60, 16, 302, city_data.finance.last_year.expenses.sundries, city_data.finance.this_year.expenses.sundries);
    draw_row(60, 21, 317, city_data.finance.last_year.expenses.tribute, city_data.finance.this_year.expenses.tribute);
    graphics_draw_horizontal_line(280, 350, 330, COLOR_BLACK);
    graphics_draw_horizontal_line(420, 490, 330, COLOR_BLACK);
    draw_row(60, 17, 335, city_data.finance.last_year.expenses.total, city_data.finance.this_year.expenses.total);
    draw_row(60, 18, 358, city_data.finance.last_year.net_in_out, city_data.finance.this_year.net_in_out);
    draw_row(60, 19, 381, city_data.finance.last_year.balance, city_data.finance.this_year.balance);
    return FINANCIAL_ADVISOR_HEIGHT;
}

static void draw_foreground_financial_advisor(void)
{
    arrow_buttons_draw(0, 0, arrow_buttons_taxes, 2);
}

static int handle_mouse_financial_advisor(struct mouse_t *m)
{
    return arrow_buttons_handle_mouse(m, 0, 0, arrow_buttons_taxes, 2, &arrow_button_focus_financial_advisor);
}

static struct advisor_window_type_t *window_advisor_financial(void)
{
    static struct advisor_window_type_t window = {
        draw_background_financial_advisor,
        draw_foreground_financial_advisor,
        handle_mouse_financial_advisor,
    };
    return &window;
}

static int draw_background_health_advisor(void)
{
    outer_panel_draw(0, 0, 40, HEALTH_ADVISOR_HEIGHT);
    image_draw(image_data_s.group_image_ids[GROUP_ADVISOR_ICONS] + 6, 10, 10);
    lang_text_draw(56, 0, 60, 12, FONT_LARGE_BLACK);
    if (city_data.population.population >= 200) {
        lang_text_draw_multiline(56, city_data.health.value / 10 + 16, 60, 46, 512, FONT_NORMAL_BLACK);
    } else {
        lang_text_draw_multiline(56, 15, 60, 46, 512, FONT_NORMAL_BLACK);
    }
    lang_text_draw(56, 3, 180, 94, FONT_SMALL_PLAIN);
    lang_text_draw(56, 4, 290, 94, FONT_SMALL_PLAIN);
    lang_text_draw_centered(56, 5, 440, 94, 160, FONT_SMALL_PLAIN);
    inner_panel_draw(32, 108, 36, 5);
    // bathhouses
    lang_text_draw_amount(8, 24, count_data.buildings[BUILDING_BATHHOUSE].total, 40, 112, FONT_NORMAL_GREEN);
    text_draw_number_centered(count_data.buildings[BUILDING_BATHHOUSE].active, 150, 112, 100, FONT_NORMAL_GREEN);
    lang_text_draw_centered(56, 2, 290, 112, 120, FONT_NORMAL_GREEN);
    lang_text_draw_centered(56, 2, 440, 112, 160, FONT_NORMAL_GREEN);
    // barbers
    lang_text_draw_amount(8, 26, count_data.buildings[BUILDING_BARBER].total, 40, 132, FONT_NORMAL_GREEN);
    text_draw_number_centered(count_data.buildings[BUILDING_BARBER].active, 150, 132, 100, FONT_NORMAL_GREEN);
    lang_text_draw_centered(56, 2, 290, 132, 120, FONT_NORMAL_GREEN);
    lang_text_draw_centered(56, 2, 440, 132, 160, FONT_NORMAL_GREEN);
    // clinics
    lang_text_draw_amount(8, 28, count_data.buildings[BUILDING_DOCTOR].total, 40, 152, FONT_NORMAL_GREEN);
    text_draw_number_centered(count_data.buildings[BUILDING_DOCTOR].active, 150, 152, 100, FONT_NORMAL_GREEN);
    lang_text_draw_centered(56, 2, 290, 152, 120, FONT_NORMAL_GREEN);
    lang_text_draw_centered(56, 2, 440, 152, 160, FONT_NORMAL_GREEN);
    // hospitals
    lang_text_draw_amount(8, 30, count_data.buildings[BUILDING_HOSPITAL].total, 40, 172, FONT_NORMAL_GREEN);
    text_draw_number_centered(count_data.buildings[BUILDING_HOSPITAL].active, 150, 172, 100, FONT_NORMAL_GREEN);
    int width = text_draw_number(1000 * count_data.buildings[BUILDING_HOSPITAL].active, '@', " ", 280, 172, FONT_NORMAL_GREEN);
    lang_text_draw(56, 6, 280 + width, 172, FONT_NORMAL_GREEN);
    int pct_hospital = culture_coverage.hospital;
    if (pct_hospital == 0) {
        lang_text_draw_centered(57, 10, 440, 172, 160, FONT_NORMAL_GREEN);
    } else if (pct_hospital < 100) {
        lang_text_draw_centered(57, pct_hospital / 10 + 11, 440, 172, 160, FONT_NORMAL_GREEN);
    } else {
        lang_text_draw_centered(57, 21, 440, 172, 160, FONT_NORMAL_GREEN);
    }
    int health_advice = 7;
    struct house_demands_t *demands = &city_data.houses;
    switch (demands->health) {
        case 1:
            health_advice = demands->requiring.bathhouse ? 1 : 0;
            break;
        case 2:
            health_advice = demands->requiring.barber ? 3 : 2;
            break;
        case 3:
            health_advice = demands->requiring.clinic ? 5 : 4;
            break;
        case 4:
            health_advice = 6;
            break;
        default:
            break;
    }
    lang_text_draw_multiline(56, 7 + health_advice, 60, 194, 512, FONT_NORMAL_BLACK);
    return HEALTH_ADVISOR_HEIGHT;
}

static struct advisor_window_type_t *window_advisor_health(void)
{
    static struct advisor_window_type_t window = {
        draw_background_health_advisor,
        0,
        0,
    };
    return &window;
}

static void arrow_button_amount(int value, __attribute__((unused)) int param2)
{
    city_data.emperor.donate_amount = calc_bound(city_data.emperor.donate_amount + value, 0, city_data.emperor.personal_savings);
    window_invalidate();
}

static struct arrow_button_t arrow_buttons_donate_to_city[] = {
    {455, 230, 17, 24, arrow_button_amount, -10, 0, 0, 0},
    {479, 230, 15, 24, arrow_button_amount, 10, 0, 0, 0},
};

static void draw_foreground_donate_to_city(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    outer_panel_draw(108, 172, 27, 8);
    // Coin image
    image_draw(COIN_IMAGE_ID, 124, 188);
    // Give money to the city
    lang_text_draw_centered(52, 16, 108, 188, 432, FONT_LARGE_BLACK);
    inner_panel_draw(124, 220, 25, 4);
    // 0
    button_border_draw(144, 230, 64, 20, donate_to_city_data.focus_button_id == 1);
    text_draw_number_centered(0, 142, 235, 64, FONT_NORMAL_WHITE);
    // 500
    button_border_draw(144, 257, 64, 20, donate_to_city_data.focus_button_id == 2);
    text_draw_number_centered(500, 142, 262, 64, FONT_NORMAL_WHITE);
    // 2000
    button_border_draw(224, 230, 64, 20, donate_to_city_data.focus_button_id == 3);
    text_draw_number_centered(2000, 222, 235, 64, FONT_NORMAL_WHITE);
    // 5000
    button_border_draw(224, 257, 64, 20, donate_to_city_data.focus_button_id == 4);
    text_draw_number_centered(5000, 222, 262, 64, FONT_NORMAL_WHITE);
    // All
    button_border_draw(304, 257, 64, 20, donate_to_city_data.focus_button_id == 5);
    lang_text_draw_centered(52, 19, 304, 262, 64, FONT_NORMAL_WHITE);
    // Donation is
    lang_text_draw(52, 17, 304, 235, FONT_NORMAL_WHITE);
    text_draw_number(city_data.emperor.donate_amount, '@', " ", 394, 235, FONT_NORMAL_GREEN);
    arrow_buttons_draw(0, 0, arrow_buttons_donate_to_city, sizeof(arrow_buttons_donate_to_city) / sizeof(struct arrow_button_t));
    // Give money
    button_border_draw(384, 257, 120, 20, donate_to_city_data.focus_button_id == 6);
    lang_text_draw_centered(52, 18, 384, 262, 120, FONT_NORMAL_GREEN);
    set_translation(0, 0);
}

static void button_set_amount(int amount_id, __attribute__((unused)) int param2)
{
    int amount;
    switch (amount_id) {
        case 0: amount = 0; break;
        case 1: amount = 500; break;
        case 2: amount = 2000; break;
        case 3: amount = 5000; break;
        case 4: amount = 1000000; break;
        default: return;
    }
    city_data.emperor.donate_amount = calc_bound(amount, 0, city_data.emperor.personal_savings);
    window_invalidate();
}

static void city_finance_process_donation(int amount)
{
    city_data.finance.treasury += amount;
    city_data.finance.this_year.income.donated += amount;
}

static void button_donate(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    city_finance_process_donation(city_data.emperor.donate_amount);
    city_data.emperor.personal_savings -= city_data.emperor.donate_amount;
    city_finance_calculate_totals();
    window_advisors_show(ADVISOR_IMPERIAL);
}

static struct generic_button_t buttons_donate_to_city[] = {
    {144, 230, 64, 20, button_set_amount, button_none, 0, 0},
    {144, 257, 64, 20, button_set_amount, button_none, 1, 0},
    {224, 230, 64, 20, button_set_amount, button_none, 2, 0},
    {224, 257, 64, 20, button_set_amount, button_none, 3, 0},
    {304, 257, 64, 20, button_set_amount, button_none, 4, 0},
    {384, 257, 120, 20, button_donate, button_none, 0, 0},
};

static void handle_input_donate_to_city(struct mouse_t *m, struct hotkeys_t *h)
{
    if (m->right.went_up || h->escape_pressed) {
        window_advisors_show(ADVISOR_IMPERIAL);
        return;
    }
    donate_to_city_data.focus_arrow_button_id = 0;
    struct mouse_t *m_dialog = mouse_in_dialog(m);
    if (generic_buttons_handle_mouse(m_dialog, 0, 0, buttons_donate_to_city, sizeof(buttons_donate_to_city) / sizeof(struct generic_button_t), &donate_to_city_data.focus_button_id)) {
        return;
    }
    if (arrow_buttons_handle_mouse(m_dialog, 0, 0, arrow_buttons_donate_to_city, sizeof(arrow_buttons_donate_to_city) / sizeof(struct arrow_button_t), &donate_to_city_data.focus_arrow_button_id)) {
        return;
    }
    // exit window on click outside of outer panel boundaries
    if (m_dialog->left.went_up && (m_dialog->x < 108 || m_dialog->y < 172 || m_dialog->x > 540 || m_dialog->y > 300)) {
        window_advisors_show(ADVISOR_IMPERIAL);
        return;
    }
}

static void button_donate_to_city(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    struct window_type_t window = {
        WINDOW_DONATE_TO_CITY,
        window_advisors_draw_dialog_background,
        draw_foreground_donate_to_city,
        handle_input_donate_to_city,
    };
    city_data.emperor.donate_amount = 0;
    window_show(&window);
}

static void draw_foreground_set_salary(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    outer_panel_draw(164, 32, 20, 23);
    // Coin image
    image_draw(COIN_IMAGE_ID, 180, 48);
    // Set salary level
    lang_text_draw_centered(52, 15, 164, 48, 320, FONT_LARGE_BLACK);
    inner_panel_draw(180, 80, 18, 15);
    for (int rank = 0; rank < 11; rank++) {
        int font = focus_button_id_set_salary == rank + 1 ? FONT_NORMAL_RED : FONT_NORMAL_WHITE;
        lang_text_draw(52, rank + 4, 196, 96 + 20 * rank, font);
        text_draw_money(SALARY_FOR_RANK[rank], 385, 96 + 20 * rank, font);
    }
    if (!city_data.mission.has_won) {
        if (city_data.emperor.salary_rank <= city_data.emperor.player_rank) {
            lang_text_draw_multiline(52, 76, 185, 336, 288, FONT_NORMAL_BLACK);
        } else {
            lang_text_draw_multiline(52, 71, 185, 336, 288, FONT_NORMAL_BLACK);
        }
    } else {
        graphics_shade_rect(180, 80, 288, 240, 0);
        lang_text_draw_multiline(52, 77, 185, 336, 288, FONT_NORMAL_BLACK);
    }
    set_translation(0, 0);
}

static void city_ratings_update_favor_explanation(void)
{
    city_data.ratings.favor_salary_penalty = 0;
    int salary_delta = city_data.emperor.salary_rank - city_data.emperor.player_rank;
    if (city_data.emperor.player_rank != 0) {
        if (salary_delta > 0) {
            city_data.ratings.favor_salary_penalty = salary_delta + 1;
        }
    } else if (salary_delta > 0) {
        city_data.ratings.favor_salary_penalty = salary_delta;
    }

    if (city_data.ratings.favor_salary_penalty >= 8) {
        city_data.ratings.favor_explanation = 1;
    } else if (city_data.finance.tribute_not_paid_total_years >= 3) {
        city_data.ratings.favor_explanation = 2;
    } else if (city_data.ratings.favor_ignored_request_penalty >= 5) {
        city_data.ratings.favor_explanation = 3;
    } else if (city_data.ratings.favor_salary_penalty >= 5) {
        city_data.ratings.favor_explanation = 4;
    } else if (city_data.finance.tribute_not_paid_total_years >= 2) {
        city_data.ratings.favor_explanation = 5;
    } else if (city_data.ratings.favor_ignored_request_penalty >= 3) {
        city_data.ratings.favor_explanation = 6;
    } else if (city_data.ratings.favor_salary_penalty >= 3) {
        city_data.ratings.favor_explanation = 7;
    } else if (city_data.finance.tribute_not_paid_last_year) {
        city_data.ratings.favor_explanation = 8;
    } else if (city_data.ratings.favor_salary_penalty >= 2) {
        city_data.ratings.favor_explanation = 9;
    } else if (city_data.ratings.favor_salary_penalty) {
        city_data.ratings.favor_explanation = 11;
    } else if (city_data.ratings.favor_change == 2) { // rising
        city_data.ratings.favor_explanation = 12;
    } else if (city_data.ratings.favor_change == 1) { // the same
        city_data.ratings.favor_explanation = 13;
    } else {
        city_data.ratings.favor_explanation = 0;
    }
}

static void button_set_salary_set_salary(int rank, __attribute__((unused)) int param2)
{
    if (!city_data.mission.has_won) {
        city_emperor_set_salary_rank(rank);
        city_data.finance.this_year.expenses.salary = city_data.finance.salary_so_far;
        city_ratings_update_favor_explanation();
        window_advisors_show(ADVISOR_IMPERIAL);
    }
}

static struct generic_button_t buttons_set_salary[] = {
    {196, 96, 250, 15, button_set_salary_set_salary, button_none, 0, 0},
    {196, 116, 250, 15, button_set_salary_set_salary, button_none, 1, 0},
    {196, 136, 250, 15, button_set_salary_set_salary, button_none, 2, 0},
    {196, 156, 250, 15, button_set_salary_set_salary, button_none, 3, 0},
    {196, 176, 250, 15, button_set_salary_set_salary, button_none, 4, 0},
    {196, 196, 250, 15, button_set_salary_set_salary, button_none, 5, 0},
    {196, 216, 250, 15, button_set_salary_set_salary, button_none, 6, 0},
    {196, 236, 250, 15, button_set_salary_set_salary, button_none, 7, 0},
    {196, 256, 250, 15, button_set_salary_set_salary, button_none, 8, 0},
    {196, 276, 250, 15, button_set_salary_set_salary, button_none, 9, 0},
    {196, 296, 250, 15, button_set_salary_set_salary, button_none, 10, 0},
};

static void handle_input_set_salary(struct mouse_t *m, struct hotkeys_t *h)
{
    if (m->right.went_up || h->escape_pressed) {
        window_advisors_show(ADVISOR_IMPERIAL);
        return;
    }
    struct mouse_t *m_dialog = mouse_in_dialog(m);
    if (generic_buttons_handle_mouse(m_dialog, 0, 0, buttons_set_salary, sizeof(buttons_set_salary) / sizeof(struct generic_button_t), &focus_button_id_set_salary)) {
        return;
    }
    // exit window on click outside of outer panel boundaries
    if (m_dialog->left.went_up && (m_dialog->x < 164 || m_dialog->y < 32 || m_dialog->x > 484 || m_dialog->y > 400)) {
        window_advisors_show(ADVISOR_IMPERIAL);
        return;
    }
}

static void button_set_salary_imperial_advisor(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    struct window_type_t window = {
        WINDOW_SET_SALARY,
        window_advisors_draw_dialog_background,
        draw_foreground_set_salary,
        handle_input_set_salary,
    };
    window_show(&window);
}

static void draw_foreground_gift_to_emperor(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    outer_panel_draw(84, 108, 30, 12);
    // Coin image
    image_draw(COIN_IMAGE_ID, 100, 124);
    // Send the Emperor a gift
    lang_text_draw_centered(52, 69, 84, 124, 480, FONT_LARGE_BLACK);
    inner_panel_draw(100, 165, 28, 5);
    // Modest gift
    if (city_data.emperor.gifts[GIFT_MODEST].cost <= city_data.emperor.personal_savings) {
        lang_text_draw(52, 63, 120, 180, FONT_NORMAL_WHITE);
        int font = focus_button_id_gift_to_emperor == 1 ? FONT_NORMAL_RED : FONT_NORMAL_WHITE;
        lang_text_draw(52, 51 + city_data.emperor.gifts[GIFT_MODEST].id, 210, 180, font);
        text_draw_money(city_data.emperor.gifts[GIFT_MODEST].cost, 460, 180, font);
    } else {
        lang_text_draw_multiline(52, 70, 110, 180, 448, FONT_NORMAL_WHITE);
    }
    // Generous gift
    if (city_data.emperor.gifts[GIFT_GENEROUS].cost <= city_data.emperor.personal_savings) {
        lang_text_draw(52, 64, 120, 200, FONT_NORMAL_WHITE);
        int font = focus_button_id_gift_to_emperor == 2 ? FONT_NORMAL_RED : FONT_NORMAL_WHITE;
        lang_text_draw(52, 55 + city_data.emperor.gifts[GIFT_GENEROUS].id, 210, 200, font);
        text_draw_money(city_data.emperor.gifts[GIFT_GENEROUS].cost, 460, 200, font);
    }
    // Lavish gift
    if (city_data.emperor.gifts[GIFT_LAVISH].cost <= city_data.emperor.personal_savings) {
        lang_text_draw(52, 65, 120, 220, FONT_NORMAL_WHITE);
        int font = focus_button_id_gift_to_emperor == 3 ? FONT_NORMAL_RED : FONT_NORMAL_WHITE;
        lang_text_draw(52, 59 + city_data.emperor.gifts[GIFT_LAVISH].id, 210, 220, font);
        text_draw_money(city_data.emperor.gifts[GIFT_LAVISH].cost, 460, 220, font);
    }
    // Time since last gift
    int width = lang_text_draw(52, 50, 200, 260, FONT_NORMAL_BLACK);
    lang_text_draw_amount(8, 4, city_data.emperor.months_since_gift, width + 200, 260, FONT_NORMAL_BLACK);
    set_translation(0, 0);
}

static void button_send_gift(int gift_size, __attribute__((unused)) int param2)
{
    if (city_data.emperor.gifts[gift_size].cost <= city_data.emperor.personal_savings) {
        int cost = city_data.emperor.gifts[gift_size].cost;
        if (cost <= city_data.emperor.personal_savings) {
            if (city_data.emperor.gift_overdose_penalty <= 0) {
                city_data.emperor.gift_overdose_penalty = 1;
                if (gift_size == GIFT_MODEST) {
                    city_data.ratings.favor = calc_bound(city_data.ratings.favor + 3, 0, 100);
                } else if (gift_size == GIFT_GENEROUS) {
                    city_data.ratings.favor = calc_bound(city_data.ratings.favor + 5, 0, 100);
                } else if (gift_size == GIFT_LAVISH) {
                    city_data.ratings.favor = calc_bound(city_data.ratings.favor + 10, 0, 100);
                }
            } else if (city_data.emperor.gift_overdose_penalty == 1) {
                city_data.emperor.gift_overdose_penalty = 2;
                if (gift_size == GIFT_MODEST) {
                    city_data.ratings.favor = calc_bound(city_data.ratings.favor + 1, 0, 100);
                } else if (gift_size == GIFT_GENEROUS) {
                    city_data.ratings.favor = calc_bound(city_data.ratings.favor + 3, 0, 100);
                } else if (gift_size == GIFT_LAVISH) {
                    city_data.ratings.favor = calc_bound(city_data.ratings.favor + 5, 0, 100);
                }
            } else if (city_data.emperor.gift_overdose_penalty == 2) {
                city_data.emperor.gift_overdose_penalty = 3;
                if (gift_size == GIFT_MODEST) {
                    city_data.ratings.favor = calc_bound(city_data.ratings.favor + 0, 0, 100);
                } else if (gift_size == GIFT_GENEROUS) {
                    city_data.ratings.favor = calc_bound(city_data.ratings.favor + 0, 0, 100);
                } else if (gift_size == GIFT_LAVISH) {
                    city_data.ratings.favor = calc_bound(city_data.ratings.favor + 3, 0, 100);
                }
            } else if (city_data.emperor.gift_overdose_penalty == 3) {
                city_data.emperor.gift_overdose_penalty = 4;
                if (gift_size == GIFT_MODEST) {
                    city_data.ratings.favor = calc_bound(city_data.ratings.favor + 0, 0, 100);
                } else if (gift_size == GIFT_GENEROUS) {
                    city_data.ratings.favor = calc_bound(city_data.ratings.favor + 0, 0, 100);
                } else if (gift_size == GIFT_LAVISH) {
                    city_data.ratings.favor = calc_bound(city_data.ratings.favor + 1, 0, 100);
                }
            }
            city_data.emperor.months_since_gift = 0;
            // rotate gift type
            city_data.emperor.gifts[gift_size].id++;
            if (city_data.emperor.gifts[gift_size].id >= 4) {
                city_data.emperor.gifts[gift_size].id = 0;
            }
            city_data.emperor.personal_savings -= cost;
        }
        window_advisors_show(ADVISOR_IMPERIAL);
    }
}

static struct generic_button_t buttons_gift_to_emperor[] = {
    {210, 180, 325, 15, button_send_gift, button_none, 0, 0},
    {210, 200, 325, 15, button_send_gift, button_none, 1, 0},
    {210, 220, 325, 15, button_send_gift, button_none, 2, 0},
};

static void handle_input_gift_to_emperor(struct mouse_t *m, struct hotkeys_t *h)
{
    if (m->right.went_up || h->escape_pressed) {
        window_advisors_show(ADVISOR_IMPERIAL);
        return;
    }
    struct mouse_t *m_dialog = mouse_in_dialog(m);
    if (generic_buttons_handle_mouse(m_dialog, 0, 0, buttons_gift_to_emperor, sizeof(buttons_gift_to_emperor) / sizeof(struct generic_button_t), &focus_button_id_gift_to_emperor)) {
        return;
    }
    // exit window on click outside of outer panel boundaries
    if (m_dialog->left.went_up && (m_dialog->x < 84 || m_dialog->y < 108 || m_dialog->x > 564 || m_dialog->y > 300)) {
        window_advisors_show(ADVISOR_IMPERIAL);
        return;
    }
}

static void button_gift_to_emperor(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    struct window_type_t window = {
        WINDOW_GIFT_TO_EMPEROR,
        window_advisors_draw_dialog_background,
        draw_foreground_gift_to_emperor,
        handle_input_gift_to_emperor,
    };
    // calculate gift costs
    city_data.emperor.gifts[GIFT_MODEST].cost = city_data.emperor.personal_savings / 8 + 20;
    city_data.emperor.gifts[GIFT_GENEROUS].cost = city_data.emperor.personal_savings / 4 + 50;
    city_data.emperor.gifts[GIFT_LAVISH].cost = city_data.emperor.personal_savings / 2 + 100;
    window_show(&window);
}

static void confirm_nothing(void)
{}

static void button_advisor_trade_opened(int advisor, __attribute__((unused)) int param2)
{
    window_advisors_show(advisor);
}

static void button_close_trade_opened(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_empire_show();
}

static struct image_button_t image_buttons_trade_opened[] = {
    {92, 248, 28, 28, IB_NORMAL, GROUP_MESSAGE_ADVISOR_BUTTONS, 12, button_advisor_trade_opened, button_none, ADVISOR_TRADE, 0, 1, 0, 0, 0},
    {522, 252, 24, 24, IB_NORMAL, GROUP_CONTEXT_ICONS, 4, button_close_trade_opened, button_none, 0, 0, 1, 0, 0, 0},
};

static void draw_background_trade_opened(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    outer_panel_draw(80, 64, 30, 14);
    lang_text_draw_centered(142, 0, 80, 80, 480, FONT_LARGE_BLACK);
    if (empire_window_data.selected_object->is_sea_trade) {
        lang_text_draw_multiline(142, 1, 112, 120, 416, FONT_NORMAL_BLACK);
        lang_text_draw_multiline(142, 3, 112, 184, 416, FONT_NORMAL_BLACK);
    } else {
        lang_text_draw_multiline(142, 1, 112, 152, 416, FONT_NORMAL_BLACK);
    }
    lang_text_draw(142, 2, 128, 256, FONT_NORMAL_BLACK);
    set_translation(0, 0);
}

static void draw_foreground_trade_opened(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    image_buttons_draw(0, 0, image_buttons_trade_opened, 2);
    set_translation(0, 0);
}

static void handle_input_trade_opened(struct mouse_t *m, struct hotkeys_t *h)
{
    if (image_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, image_buttons_trade_opened, 2, 0)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        window_empire_show();
    }
}

static void confirmed_open_trade(void)
{
    city_finance_process_construction(empire_window_data.selected_object->trade_route_cost);
    empire_window_data.selected_object->trade_route_open = 1;
    struct window_type_t window = {
    WINDOW_TRADE_OPENED,
    draw_background_trade_opened,
    draw_foreground_trade_opened,
    handle_input_trade_opened,
    };
    window_show(&window);
}

static void button_help_empire(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_message_dialog_show(MESSAGE_DIALOG_EMPIRE_MAP, 0);
}

static struct image_button_t image_button_help_empire_window[] = {
    {0, 0, 27, 27, IB_NORMAL, GROUP_CONTEXT_ICONS, 0, button_help_empire, button_none, 0, 0, 1, 0, 0, 0}
};

static void button_return_to_city(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_city_show();
}

static struct image_button_t image_button_return_to_city[] = {
    {0, 0, 24, 24, IB_NORMAL, GROUP_CONTEXT_ICONS, 4, button_return_to_city, button_none, 0, 0, 1, 0, 0, 0}
};

static struct image_button_t image_button_advisor[] = {
    {-4, 0, 24, 24, IB_NORMAL, GROUP_MESSAGE_ADVISOR_BUTTONS, 12, button_advisor_trade_opened, button_none, ADVISOR_TRADE, 0, 1, 0, 0, 0}
};

static void window_resource_settings_show(int resource);
static void button_show_resource_window(int resource, __attribute__((unused)) int param2)
{
    window_resource_settings_show(resource);
}

static struct generic_button_t generic_button_trade_resource[] = {
    {0, 0, 101, 27, button_show_resource_window, button_none, RESOURCE_WHEAT, 0},
    {0, 0, 101, 27, button_show_resource_window, button_none, RESOURCE_VEGETABLES , 0},
    {0, 0, 101, 27, button_show_resource_window, button_none, RESOURCE_FRUIT , 0},
    {0, 0, 101, 27, button_show_resource_window, button_none, RESOURCE_OLIVES , 0},
    {0, 0, 101, 27, button_show_resource_window, button_none, RESOURCE_VINES , 0},
    {0, 0, 101, 27, button_show_resource_window, button_none, RESOURCE_MEAT, 0},
    {0, 0, 101, 27, button_show_resource_window, button_none, RESOURCE_WINE , 0},
    {0, 0, 101, 27, button_show_resource_window, button_none, RESOURCE_OIL , 0},
    {0, 0, 101, 27, button_show_resource_window, button_none, RESOURCE_IRON , 0},
    {0, 0, 101, 27, button_show_resource_window, button_none, RESOURCE_TIMBER, 0},
    {0, 0, 101, 27, button_show_resource_window, button_none, RESOURCE_CLAY, 0},
    {0, 0, 101, 27, button_show_resource_window, button_none, RESOURCE_MARBLE, 0},
    {0, 0, 101, 27, button_show_resource_window, button_none, RESOURCE_WEAPONS, 0},
    {0, 0, 101, 27, button_show_resource_window, button_none, RESOURCE_FURNITURE, 0},
    {0, 0, 101, 27, button_show_resource_window, button_none, RESOURCE_POTTERY, 0}
};

static void button_open_trade(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_popup_dialog_show(POPUP_DIALOG_OPEN_TRADE, confirmed_open_trade, 2);
}

static struct generic_button_t generic_button_open_trade[] = {
    {30, 56, 440, 26, button_open_trade, button_none, 0, 0}
};

static void draw_trade_resource(int resource, int trade_max, int x_offset, int y_offset)
{
    graphics_draw_inset_rect(x_offset, y_offset, 26, 26);
    int image_id = resource_images[resource].empire_icon_img_id + resource_image_offset(resource, RESOURCE_IMAGE_ICON);
    image_draw(image_id, x_offset + 1, y_offset + 1);
    if (empire_window_data.focus_resource == resource) {
        button_border_draw(x_offset - 2, y_offset - 2, 101 + 4, 30, 1);
    }
    switch (trade_max) {
        case 15:
            image_draw(image_data_s.group_image_ids[GROUP_TRADE_AMOUNT], x_offset + 21, y_offset - 1);
            break;
        case 25:
            image_draw(image_data_s.group_image_ids[GROUP_TRADE_AMOUNT] + 1, x_offset + 17, y_offset - 1);
            break;
        case 40:
            image_draw(image_data_s.group_image_ids[GROUP_TRADE_AMOUNT] + 2, x_offset + 13, y_offset - 1);
            break;
    }
}

static void draw_background_empire_window_data(void)
{
    int s_width = screen_data.width;
    int s_height = screen_data.height;
    empire_window_data.x_min = s_width <= MAX_WIDTH ? 0 : (s_width - MAX_WIDTH) / 2;
    empire_window_data.x_max = s_width <= MAX_WIDTH ? s_width : empire_window_data.x_min + MAX_WIDTH;
    empire_window_data.y_min = s_height <= MAX_HEIGHT ? 0 : (s_height - MAX_HEIGHT) / 2;
    empire_window_data.y_max = s_height <= MAX_HEIGHT ? s_height : empire_window_data.y_min + MAX_HEIGHT;

    if (empire_window_data.x_min || empire_window_data.y_min) {
        graphics_clear_screen();
    }
}

static void draw_foreground_empire_window_data(void)
{
    graphics_set_clip_rectangle(empire_window_data.x_min + 16, empire_window_data.y_min + 16,
        empire_window_data.x_max - empire_window_data.x_min - 32, empire_window_data.y_max - empire_window_data.y_min - 136);
    empire_set_viewport(empire_window_data.x_max - empire_window_data.x_min - 32, empire_window_data.y_max - empire_window_data.y_min - 136);
    empire_window_data.x_draw_offset = empire_window_data.x_min + 16;
    empire_window_data.y_draw_offset = empire_window_data.y_min + 16;
    empire_adjust_scroll(&empire_window_data.x_draw_offset, &empire_window_data.y_draw_offset);
    image_draw(image_data_s.group_image_ids[GROUP_EMPIRE_MAP], empire_window_data.x_draw_offset, empire_window_data.y_draw_offset);
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        if (empire_objects[i].in_use) {
            // don't draw trade routes that aren't open
            if (empire_objects[i].type == EMPIRE_OBJECT_LAND_TRADE_ROUTE || empire_objects[i].type == EMPIRE_OBJECT_SEA_TRADE_ROUTE) {
                struct empire_object_t *trade_city = get_trade_city_by_trade_route(empire_objects[i].trade_route_id);
                if (!trade_city->trade_route_open) {
                    continue;
                }
            }
            if (empire_objects[i].type == EMPIRE_OBJECT_BATTLE_ICON) {
                for (int j = 0; j < MAX_INVASIONS; j++) {
                    int battle_icon_year_abs = time_data.year + empire_objects[i].invasion_years;
                    int invasion_year_abs = scenario.start_year + scenario.invasions[j].year_offset;
                    // check that invasion is yet to come
                    if (scenario.invasions[j].type == INVASION_TYPE_ENEMY_ARMY
                    && (time_data.year < invasion_year_abs
                        || (time_data.year == invasion_year_abs && time_data.month < scenario.invasions[j].month))) {
                        // draw up to 3 battle icons per invasion, 1 per year
                        if (empire_objects[i].invasion_path_id == (j % 3) + 1
                        && (battle_icon_year_abs > invasion_year_abs
                            || (battle_icon_year_abs == invasion_year_abs && time_data.month >= scenario.invasions[j].month))
                        ) {
                            image_draw(empire_objects[i].image_id, empire_window_data.x_draw_offset + empire_objects[i].x, empire_window_data.y_draw_offset + empire_objects[i].y);
                        }
                    }

                }
                continue;
            }
            if (empire_objects[i].type == EMPIRE_OBJECT_ENEMY_ARMY) {
                if (!city_data.distant_battle.months_until_battle) {
                    continue;
                }
                if (city_data.distant_battle.enemy_months_traveled != empire_objects[i].distant_battle_travel_months) {
                    continue;
                }
            }
            if (empire_objects[i].type == EMPIRE_OBJECT_ROMAN_ARMY) {
                if (!city_military_distant_battle_roman_army_is_traveling()) {
                    continue;
                }
                if (city_data.distant_battle.roman_months_traveled != empire_objects[i].distant_battle_travel_months) {
                    continue;
                }
            }
            int x, y, image_id;
            if (scenario.empire.is_expanded) {
                x = empire_objects[i].expanded.x;
                y = empire_objects[i].expanded.y;
                image_id = empire_objects[i].expanded.image_id;
            } else {
                x = empire_objects[i].x;
                y = empire_objects[i].y;
                image_id = empire_objects[i].image_id;
            }
            if (empire_objects[i].city_type == EMPIRE_CITY_FUTURE_TRADE) {
                // Fix case where future trade city (as specified in the editor) is drawn as a trade city before expansion
                image_id = image_data_s.group_image_ids[GROUP_EMPIRE_CITY_DISTANT_ROMAN];
            }
            image_draw(image_id, empire_window_data.x_draw_offset + x, empire_window_data.y_draw_offset + y);
            struct image_t *img = image_get(image_id);
            if (img->animation_speed_id) {
                image_draw(image_id + empire_object_update_animation(&empire_objects[i], image_id),
                    empire_window_data.x_draw_offset + x + img->sprite_offset_x,
                    empire_window_data.y_draw_offset + y + img->sprite_offset_y);
            }
        }
    }
    graphics_reset_clip_rectangle();
    int image_base = image_data_s.group_image_ids[GROUP_EMPIRE_PANELS];
    // bottom panel background
    graphics_set_clip_rectangle(empire_window_data.x_min, empire_window_data.y_min, empire_window_data.x_max - empire_window_data.x_min, empire_window_data.y_max - empire_window_data.y_min);
    for (int x = empire_window_data.x_min; x < empire_window_data.x_max; x += 70) {
        image_draw(image_base + 3, x, empire_window_data.y_max - 120);
        image_draw(image_base + 3, x, empire_window_data.y_max - 80);
        image_draw(image_base + 3, x, empire_window_data.y_max - 40);
    }
    // horizontal bar borders
    for (int x = empire_window_data.x_min; x < empire_window_data.x_max; x += 86) {
        image_draw(image_base + 1, x, empire_window_data.y_min);
        image_draw(image_base + 1, x, empire_window_data.y_max - 120);
        image_draw(image_base + 1, x, empire_window_data.y_max - 16);
    }
    // vertical bar borders
    for (int y = empire_window_data.y_min + 16; y < empire_window_data.y_max; y += 86) {
        image_draw(image_base, empire_window_data.x_min, y);
        image_draw(image_base, empire_window_data.x_max - 16, y);
    }
    // crossbars
    image_draw(image_base + 2, empire_window_data.x_min, empire_window_data.y_min);
    image_draw(image_base + 2, empire_window_data.x_min, empire_window_data.y_max - 120);
    image_draw(image_base + 2, empire_window_data.x_min, empire_window_data.y_max - 16);
    image_draw(image_base + 2, empire_window_data.x_max - 16, empire_window_data.y_min);
    image_draw(image_base + 2, empire_window_data.x_max - 16, empire_window_data.y_max - 120);
    image_draw(image_base + 2, empire_window_data.x_max - 16, empire_window_data.y_max - 16);
    graphics_reset_clip_rectangle();
    image_buttons_draw(empire_window_data.x_min + 20, empire_window_data.y_max - 44, image_button_help_empire_window, 1);
    image_buttons_draw(empire_window_data.x_max - 44, empire_window_data.y_max - 44, image_button_return_to_city, 1);
    image_buttons_draw(empire_window_data.x_max - 44, empire_window_data.y_max - 100, image_button_advisor, 1);
    if (empire_window_data.selected_object) {
        if (empire_window_data.selected_object->city_type == EMPIRE_CITY_TRADE && !empire_window_data.selected_object->trade_route_open) {
            button_border_draw((empire_window_data.x_min + empire_window_data.x_max - 500) / 2 + 30, empire_window_data.y_max - 49, 440,
                26, empire_window_data.selected_button);
        }
    }
    if (empire_window_data.selected_object) {
        switch (empire_window_data.selected_object->type) {
            case EMPIRE_OBJECT_CITY:
                image_draw(image_base + 6, empire_window_data.x_min + 2, empire_window_data.y_max - 199);
                image_draw(image_base + 7, empire_window_data.x_max - 84, empire_window_data.y_max - 199);
                image_draw(image_base + 8, (empire_window_data.x_min + empire_window_data.x_max - 332) / 2, empire_window_data.y_max - 181);
                lang_text_draw_centered(21, empire_window_data.selected_object->city_name_id,
                    (empire_window_data.x_min + empire_window_data.x_max - 332) / 2 + 64, empire_window_data.y_max - 118, 268, FONT_LARGE_BLACK);
                int x_offset = (empire_window_data.x_min + empire_window_data.x_max - 240) / 2;
                int y_offset = empire_window_data.y_max - 66;
                switch (empire_window_data.selected_object->city_type) {
                    case EMPIRE_CITY_FUTURE_TRADE:
                    case EMPIRE_CITY_DISTANT_ROMAN:
                        lang_text_draw_centered(47, 12, x_offset, y_offset, 240, FONT_NORMAL_GREEN);
                        break;
                    case EMPIRE_CITY_VULNERABLE_ROMAN:
                        if (city_data.distant_battle.city_foreign_months_left <= 0) {
                            lang_text_draw_centered(47, 12, x_offset, y_offset, 240, FONT_NORMAL_GREEN);
                        } else {
                            lang_text_draw_centered(47, 13, x_offset, y_offset, 240, FONT_NORMAL_GREEN);
                        }
                        break;
                    case EMPIRE_CITY_DISTANT_FOREIGN:
                    case EMPIRE_CITY_FUTURE_ROMAN:
                        lang_text_draw_centered(47, 0, x_offset, y_offset, 240, FONT_NORMAL_GREEN);
                        break;
                    case EMPIRE_CITY_OURS:
                        lang_text_draw_centered(47, 1, x_offset, y_offset, 240, FONT_NORMAL_GREEN);
                        break;
                    case EMPIRE_CITY_TRADE:
                        x_offset = (empire_window_data.x_min + empire_window_data.x_max - 500) / 2;
                        y_offset = empire_window_data.y_max - 113;
                        if (empire_window_data.selected_object->trade_route_open) {
                            // city sells
                            lang_text_draw(47, 10, x_offset, y_offset + 40, FONT_NORMAL_GREEN);
                            int index = 0;
                            for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                if (!empire_window_data.selected_object->resource_sell_limit[r]) {
                                    continue;
                                }
                                int trade_max = empire_window_data.selected_object->resource_sell_limit[r];
                                draw_trade_resource(r, trade_max, x_offset + 104 * index + 76, y_offset + 31);
                                int trade_now = empire_window_data.selected_object->resource_sold[r];
                                if (trade_now > trade_max) {
                                    trade_max = trade_now;
                                }
                                int text_width = text_draw_number(trade_now, '@', "",
                                    x_offset + 104 * index + 106, y_offset + 40, FONT_NORMAL_GREEN);
                                text_width += lang_text_draw(47, 11,
                                    x_offset + 104 * index + 104 + text_width, y_offset + 40, FONT_NORMAL_GREEN);
                                text_draw_number(trade_max, '@', "",
                                    x_offset + 104 * index + 94 + text_width, y_offset + 40, FONT_NORMAL_GREEN);
                                index++;
                            }
                            // city buys
                            lang_text_draw(47, 9, x_offset, y_offset + 71, FONT_NORMAL_GREEN);
                            index = 0;
                            for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                if (!empire_window_data.selected_object->resource_buy_limit[r]) {
                                    continue;
                                }
                                int trade_max = empire_window_data.selected_object->resource_buy_limit[r];
                                draw_trade_resource(r, trade_max, x_offset + 104 * index + 76, y_offset + 62);
                                int trade_now = empire_window_data.selected_object->resource_bought[r];
                                if (trade_now > trade_max) {
                                    trade_max = trade_now;
                                }
                                int text_width = text_draw_number(trade_now, '@', "",
                                                                 x_offset + 104 * index + 106, y_offset + 71, FONT_NORMAL_GREEN);
                                text_width += lang_text_draw(47, 11,
                                                            x_offset + 104 * index + 104 + text_width, y_offset + 71, FONT_NORMAL_GREEN);
                                text_draw_number(trade_max, '@', "",
                                                 x_offset + 104 * index + 94 + text_width, y_offset + 71, FONT_NORMAL_GREEN);
                                index++;
                            }
                        } else { // trade is closed
                            int index = lang_text_draw(47, 5, x_offset + 35, y_offset + 42, FONT_NORMAL_GREEN);
                            for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                if (!empire_window_data.selected_object->resource_sell_limit[r]) {
                                    continue;
                                }
                                int trade_max = empire_window_data.selected_object->resource_sell_limit[r];
                                draw_trade_resource(r, trade_max, x_offset + index + 45, y_offset + 33);
                                index += 32;
                            }
                            index += lang_text_draw(47, 4, x_offset + index + 85, y_offset + 42, FONT_NORMAL_GREEN);
                            for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                if (!empire_window_data.selected_object->resource_buy_limit[r]) {
                                    continue;
                                }
                                int trade_max = empire_window_data.selected_object->resource_buy_limit[r];
                                draw_trade_resource(r, trade_max, x_offset + index + 95, y_offset + 33);
                                index += 32;
                            }
                            index = lang_text_draw_amount(8, 0, empire_window_data.selected_object->trade_route_cost,
                                x_offset + 40, y_offset + 73, FONT_NORMAL_GREEN);
                            lang_text_draw(47, 6, x_offset + index + 40, y_offset + 73, FONT_NORMAL_GREEN);
                            int image_id = image_data_s.group_image_ids[GROUP_EMPIRE_TRADE_ROUTE_TYPE] + 1 - empire_window_data.selected_object->is_sea_trade;
                            image_draw(image_id, x_offset + 430, y_offset + 65 + 2 * empire_window_data.selected_object->is_sea_trade);
                        }
                        break;
                }
                break;
            case EMPIRE_OBJECT_ROMAN_ARMY:
                if (city_military_distant_battle_roman_army_is_traveling()) {
                    if (city_data.distant_battle.roman_months_traveled == empire_window_data.selected_object->distant_battle_travel_months) {
                        x_offset = (empire_window_data.x_min + empire_window_data.x_max - 240) / 2;
                        y_offset = empire_window_data.y_max - 68;
                        int text_id;
                        if (city_data.distant_battle.roman_months_to_travel_forth) {
                            text_id = 15;
                        } else {
                            text_id = 16;
                        }
                        lang_text_draw_multiline(47, text_id, x_offset, y_offset, 240, FONT_NORMAL_GREEN);
                        break;
                    }
                }
                /* fall through */
            case EMPIRE_OBJECT_ENEMY_ARMY:
                if (city_data.distant_battle.months_until_battle) {
                    if (city_data.distant_battle.enemy_months_traveled == empire_window_data.selected_object->distant_battle_travel_months) {
                        lang_text_draw_multiline(47, 14, (empire_window_data.x_min + empire_window_data.x_max - 240) / 2, empire_window_data.y_max - 68, 240, FONT_NORMAL_GREEN);
                        break;
                    }
                }
                /* fall through */
            default:
                lang_text_draw_centered(47, 8, empire_window_data.x_min, empire_window_data.y_max - 65, empire_window_data.x_max - empire_window_data.x_min, FONT_NORMAL_GREEN);
        }
    } else {
        lang_text_draw_centered(47, 8, empire_window_data.x_min, empire_window_data.y_max - 65, empire_window_data.x_max - empire_window_data.x_min, FONT_NORMAL_GREEN);
    }
}

static void handle_input_empire_window_data(struct mouse_t *m, struct hotkeys_t *h)
{
    struct pixel_view_coordinates_t position;
    if (scroll_get_delta(m, &position, SCROLL_TYPE_EMPIRE)) {
        empire_scroll_map(position.x, position.y);
    }
    empire_window_data.focus_button_id = 0;
    empire_window_data.focus_resource = 0;
    int button_id;
    image_buttons_handle_mouse(m, empire_window_data.x_min + 20, empire_window_data.y_max - 44, image_button_help_empire_window, 1, &button_id);
    if (button_id) {
        empire_window_data.focus_button_id = 1;
    }
    image_buttons_handle_mouse(m, empire_window_data.x_max - 44, empire_window_data.y_max - 44, image_button_return_to_city, 1, &button_id);
    if (button_id) {
        empire_window_data.focus_button_id = 2;
    }
    image_buttons_handle_mouse(m, empire_window_data.x_max - 44, empire_window_data.y_max - 100, image_button_advisor, 1, &button_id);
    if (button_id) {
        empire_window_data.focus_button_id = 3;
    }
    button_id = 0;

    if (h->show_last_advisor) {
        window_advisors_show(settings_values[SETTINGS_LAST_ADVISOR]);
        return;
    }

    if (h->show_empire_map) {
        window_city_show();
        return;
    }

    if (m->left.went_up
    && !(m->x < empire_window_data.x_min + 16 || m->x >= empire_window_data.x_max - 16 || // is outside map
        m->y < empire_window_data.y_min + 16 || m->y >= empire_window_data.y_max - 120)) {
        empire_window_data.selected_object = empire_select_object(m->x - empire_window_data.x_min - 16, m->y - empire_window_data.y_min - 16);
    }
    if (empire_window_data.selected_object) {
        window_invalidate();
        if (empire_window_data.selected_object->city_type == EMPIRE_CITY_TRADE) {
            if (empire_window_data.selected_object->trade_route_open) {
                int x_offset = (empire_window_data.x_min + empire_window_data.x_max - 500) / 2;
                int y_offset = empire_window_data.y_max - 113;
                int index_sell = 0;
                int index_buy = 0;

                // we only want to handle resource buttons that the selected city trades
                for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                    if (empire_window_data.selected_object->resource_sell_limit[r]) {
                        generic_buttons_handle_mouse(m, x_offset + 75 + 104 * index_sell, y_offset + 31,
                            generic_button_trade_resource + r - 1, 1, &button_id);
                        index_sell++;
                    } else if (empire_window_data.selected_object->resource_buy_limit[r]) {
                        generic_buttons_handle_mouse(m, x_offset + 75 + 104 * index_buy, y_offset + 62,
                            generic_button_trade_resource + r - 1, 1, &button_id);
                        index_buy++;
                    }

                    if (button_id) {
                        empire_window_data.focus_resource = r;
                        // if we're focusing any button we can skip further checks
                        break;
                    }
                }
            } else {
                generic_buttons_handle_mouse(
                    m, (empire_window_data.x_min + empire_window_data.x_max - 500) / 2, empire_window_data.y_max - 105,
                    generic_button_open_trade, 1, &empire_window_data.selected_button);
            }
        }
        // allow de-selection only for objects that are currently selected/drawn
        if (m->right.went_up || h->escape_pressed) {
            switch (empire_window_data.selected_object->type) {
                case EMPIRE_OBJECT_CITY:
                    empire_window_data.selected_object = 0;
                    window_invalidate();
                    break;
                case EMPIRE_OBJECT_ROMAN_ARMY:
                    if (city_military_distant_battle_roman_army_is_traveling()) {
                        if (city_data.distant_battle.roman_months_traveled == empire_window_data.selected_object->distant_battle_travel_months) {
                            empire_window_data.selected_object = 0;
                            window_invalidate();
                            break;
                        }
                    }
                    /* fall through */
                case EMPIRE_OBJECT_ENEMY_ARMY:
                    if (city_data.distant_battle.months_until_battle) {
                        if (city_data.distant_battle.enemy_months_traveled == empire_window_data.selected_object->distant_battle_travel_months) {
                            empire_window_data.selected_object = 0;
                            window_invalidate();
                            break;
                        }
                    }
                    /* fall through */
                default:
                    window_go_back();
            }
        }
    } else if (m->right.went_up || h->escape_pressed) {
        window_go_back();
        if (window_data.current_window->id == WINDOW_TRADE_OPENED) {
            window_city_show();
        }
    }
}

static void window_empire_show(void)
{
    struct window_type_t window = {
        WINDOW_EMPIRE,
        draw_background_empire_window_data,
        draw_foreground_empire_window_data,
        handle_input_empire_window_data,
    };
    empire_window_data.selected_button = 0;
    empire_window_data.selected_object = 0;
    empire_window_data.focus_button_id = 0;
    window_show(&window);
}

static void confirm_send_troops(void)
{
    int legions_sent = 0;
    int roman_strength = 0;
    for (int i = 0; i < MAX_LEGIONS; i++) {
        if (legion_formations[i].in_use && legion_formations[i].empire_service && legion_formations[i].num_figures) {
            struct formation_t *m = &legion_formations[i];
            m->in_distant_battle = 1;
            for (int fig = 0; fig < m->num_figures; fig++) {
                if (m->figures[fig] > 0) {
                    struct figure_t *f = &figures[m->figures[fig]];
                    if (figure_is_alive(f)) {
                        f->action_state = FIGURE_ACTION_SOLDIER_GOING_TO_DISTANT_BATTLE;
                    }
                }
            }
            int strength_factor;
            if (m->has_military_training) {
                strength_factor = m->figure_type == FIGURE_FORT_LEGIONARY ? 3 : 2;
            } else {
                strength_factor = m->figure_type == FIGURE_FORT_LEGIONARY ? 2 : 1;
            }
            roman_strength += strength_factor * m->num_figures;
            legions_sent++;
        }
    }
    if (legions_sent > 0) {
        city_data.distant_battle.roman_months_to_travel_forth = scenario.empire.distant_battle_roman_travel_months;
        city_data.distant_battle.roman_strength = roman_strength;
    }
    window_empire_show();
}

static void on_scroll_imperial_advisor(void)
{
    window_invalidate();
}

static struct scrollbar_type_t scrollbar_imperial_advisor = { 591, 90, 222, on_scroll_imperial_advisor, 0, 0, 0, 0, 0, 0 };

static void scrollbar_update_max(struct scrollbar_type_t *scrollbar, int max_scroll_position)
{
    if (max_scroll_position < 0) {
        max_scroll_position = 0;
    }
    scrollbar->max_scroll_position = max_scroll_position;
    if (scrollbar->scroll_position > max_scroll_position) {
        scrollbar->scroll_position = max_scroll_position;
    }
}

static int house_population_remove_from_city(int num_people)
{
    int removed = 0;
    int building_id = city_data.population.last_used_house_remove;
    for (int i = 1; i < 4 * MAX_BUILDINGS && removed < num_people; i++) {
        if (++building_id >= MAX_BUILDINGS) {
            building_id = 1;
        }
        struct building_t *b = &all_buildings[building_id];
        if (b->state == BUILDING_STATE_IN_USE && b->house_size) {
            city_data.population.last_used_house_remove = building_id;
            if (b->house_population > 0) {
                ++removed;
                --b->house_population;
            }
        }
    }
    return removed;
}

static void confirm_send_goods(void)
{
    if (scenario.requests[selected_request_id].state == REQUEST_STATE_NORMAL) {
        scenario.requests[selected_request_id].state = REQUEST_STATE_DISPATCHED;
    } else {
        scenario.requests[selected_request_id].state = REQUEST_STATE_DISPATCHED_LATE;
    }
    random_generate_next();
    scenario.requests[selected_request_id].months_to_comply = (random_data.random1_7bit & 3) + 1;
    scenario.requests[selected_request_id].visible = 0;
    if (scenario.requests[selected_request_id].resource == RESOURCE_DENARII) {
        city_finance_process_misc(scenario.requests[selected_request_id].amount);
    } else if (scenario.requests[selected_request_id].resource == RESOURCE_TROOPS) {
        int removed = house_population_remove_from_city(scenario.requests[selected_request_id].amount);
        remove_from_census(removed);
        city_data.population.lost_troop_request += scenario.requests[selected_request_id].amount;
        recalculate_population();
        building_warehouses_remove_resource(RESOURCE_WEAPONS, scenario.requests[selected_request_id].amount);
    } else {
        building_warehouses_remove_resource(scenario.requests[selected_request_id].resource, scenario.requests[selected_request_id].amount);
    }
    goods_requests_to_draw--;
    scrollbar_update_max(&scrollbar_imperial_advisor, scrollbar_imperial_advisor.max_scroll_position - 1);
}

static int get_request_status(int index)
{
    int num_requests = 0;
    if (city_data.distant_battle.months_until_battle && !city_data.distant_battle.roman_months_to_travel_forth) {
        num_requests = 1;
        if (index == 0) {
            int legions_selected_emp_service = 0;
            for (int i = 0; i < MAX_LEGIONS; i++) {
                if (legion_formations[i].in_use && legion_formations[i].empire_service && legion_formations[i].num_figures) {
                    legions_selected_emp_service = 1;
                    break;
                }
            }
            if (!city_data.military.total_legions) {
                return STATUS_NO_LEGIONS_AVAILABLE;
            } else if (!legions_selected_emp_service) {
                return STATUS_NO_LEGIONS_SELECTED;
            } else {
                return STATUS_CONFIRM_SEND_LEGIONS;
            }
        }
    }
    int index_offset = index - num_requests;
    for (int i = 0; i < MAX_REQUESTS; i++) {
        if (scenario.requests[i].resource && scenario.requests[i].visible &&
            scenario.requests[i].state <= 1) {
            if (index_offset == 0) {
                if (scenario.requests[i].resource == RESOURCE_DENARII) {
                    if (city_data.finance.treasury <= scenario.requests[i].amount) {
                        return STATUS_NOT_ENOUGH_RESOURCES;
                    }
                } else {
                    if (city_data.resource.stored_in_warehouses[scenario.requests[i].resource] < scenario.requests[i].amount) {
                        return STATUS_NOT_ENOUGH_RESOURCES;
                    }
                }
                return i + 1;
            }
            index_offset--;
        }
    }
    return 0;
}

static void button_request(int index, __attribute__((unused)) int param2)
{
    int status = get_request_status(scrollbar_imperial_advisor.scroll_position + index);
    if (status) {
        switch (status) {
            case STATUS_NO_LEGIONS_AVAILABLE:
                window_popup_dialog_show(POPUP_DIALOG_NO_LEGIONS_AVAILABLE, confirm_nothing, 0);
                break;
            case STATUS_NO_LEGIONS_SELECTED:
                window_popup_dialog_show(POPUP_DIALOG_NO_LEGIONS_SELECTED, confirm_nothing, 0);
                break;
            case STATUS_CONFIRM_SEND_LEGIONS:
                window_popup_dialog_show(POPUP_DIALOG_SEND_TROOPS, confirm_send_troops, 2);
                break;
            case STATUS_NOT_ENOUGH_RESOURCES:
                window_popup_dialog_show(POPUP_DIALOG_NOT_ENOUGH_GOODS, confirm_nothing, 0);
                break;
            default:
                selected_request_id = status - 1;
                window_popup_dialog_show(POPUP_DIALOG_SEND_GOODS, confirm_send_goods, 2);
                break;
        }
    }
}

static struct generic_button_t imperial_buttons[] = {
    {38, 96, 550, 40, button_request, button_none, 0, 0},
    {38, 138, 550, 40, button_request, button_none, 1, 0},
    {38, 180, 550, 40, button_request, button_none, 2, 0},
    {38, 222, 550, 40, button_request, button_none, 3, 0},
    {38, 264, 550, 40, button_request, button_none, 4, 0},
    {312, 341, 250, 20, button_gift_to_emperor, button_none, 0, 0},
    {312, 367, 250, 20, button_donate_to_city, button_none, 0, 0},
    {62, 393, 500, 20, button_set_salary_imperial_advisor, button_none, 0, 0},
};

static int draw_background_imperial_advisor(void)
{
    outer_panel_draw(0, 0, 40, IMPERIAL_ADVISOR_HEIGHT);
    image_draw(image_data_s.group_image_ids[GROUP_ADVISOR_ICONS] + 2, 10, 10);
    text_draw(scenario_settings.player_name, 60, 12, FONT_LARGE_BLACK, 0);
    int width = lang_text_draw(52, 0, 60, 44, FONT_NORMAL_BLACK);
    text_draw_number(city_data.ratings.favor, '@', " ", 60 + width, 44, FONT_NORMAL_BLACK);
    lang_text_draw_multiline(52, city_data.ratings.favor / 5 + 22, 60, 60, 544, FONT_NORMAL_BLACK);
    inner_panel_draw(32, 90, 35, 14);


    int request_index = 0;
    // draw distant battle army request
    if (city_data.distant_battle.months_until_battle && !city_data.distant_battle.roman_months_to_travel_forth) {
        // can send to distant battle
        button_border_draw(38, 96, 550, 40, 0);
        image_draw(resource_images[RESOURCE_WEAPONS].icon_img_id, 50, 106);
        width = lang_text_draw(52, 72, 80, 102, FONT_NORMAL_WHITE);
        lang_text_draw(21, empire_objects[city_data.distant_battle.city].city_name_id, 80 + width, 102, FONT_NORMAL_WHITE);
        int strength_text_id;
        if (city_data.distant_battle.enemy_strength < 46) {
            strength_text_id = 73;
        } else if (city_data.distant_battle.enemy_strength < 89) {
            strength_text_id = 74;
        } else {
            strength_text_id = 75;
        }
        width = lang_text_draw(52, strength_text_id, 80, 120, FONT_NORMAL_WHITE);
        lang_text_draw_amount(8, 4, city_data.distant_battle.months_until_battle, 80 + width, 120, FONT_NORMAL_WHITE);
        request_index = 1;
    }

    if (goods_requests_to_draw) {
        // scroll max position depends on max goods drawn (MAX_REQUESTS_SHOWN, or MAX_REQUESTS_SHOWN - 1 when also drawing distant battle)
        scrollbar_update_max(&scrollbar_imperial_advisor, goods_requests_to_draw + request_index - MAX_REQUESTS_SHOWN);
        // "min" without imported libraries
        int scroll_adjusted_index;
        if (goods_requests_to_draw + request_index <= MAX_REQUESTS_SHOWN) {
            scroll_adjusted_index = 0;
        } else {
            scroll_adjusted_index = scrollbar_imperial_advisor.scroll_position < goods_requests_to_draw + request_index - MAX_REQUESTS_SHOWN ? scrollbar_imperial_advisor.scroll_position : goods_requests_to_draw + request_index - MAX_REQUESTS_SHOWN;
        }
        for (int i = 0; i < MAX_REQUESTS; i++) {
            if (request_index >= MAX_REQUESTS_SHOWN) {
                break;
            }
            if (scenario.requests[i].resource && scenario.requests[i].visible && i >= scroll_adjusted_index) {
                button_border_draw(38, 96 + 42 * request_index, 550, 40, 0);
                text_draw_number(scenario.requests[i].amount, '@', " ", 40, 102 + 42 * request_index, FONT_NORMAL_WHITE);
                image_draw(resource_images[scenario.requests[i].resource].icon_img_id + resource_image_offset(scenario.requests[i].resource, RESOURCE_IMAGE_ICON), 110, 100 + 42 * request_index);
                lang_text_draw(23, scenario.requests[i].resource, 150, 102 + 42 * request_index, FONT_NORMAL_WHITE);

                width = lang_text_draw_amount(8, 4, scenario.requests[i].months_to_comply, 310, 102 + 42 * request_index, FONT_NORMAL_WHITE);
                lang_text_draw(12, 2, 310 + width, 102 + 42 * request_index, FONT_NORMAL_WHITE);

                if (scenario.requests[i].resource == RESOURCE_DENARII) {
                    // request for money
                    width = text_draw_number(city_data.finance.treasury, '@', " ", 40, 120 + 42 * request_index, FONT_NORMAL_WHITE);
                    width += lang_text_draw(52, 44, 40 + width, 120 + 42 * request_index, FONT_NORMAL_WHITE);
                    if (city_data.finance.treasury < scenario.requests[i].amount) {
                        lang_text_draw(52, 48, 105 + width, 120 + 42 * request_index, FONT_NORMAL_WHITE);
                    } else {
                        lang_text_draw(52, 47, 80 + width, 120 + 42 * request_index, FONT_NORMAL_WHITE);
                    }
                } else {
                    // normal goods request
                    int amount_stored = city_data.resource.stored_in_warehouses[scenario.requests[i].resource];
                    width = text_draw_number(amount_stored, '@', " ", 40, 120 + 42 * request_index, FONT_NORMAL_WHITE);
                    width += lang_text_draw(52, 43, 40 + width, 120 + 42 * request_index, FONT_NORMAL_WHITE);
                    if (amount_stored < scenario.requests[i].amount) {
                        lang_text_draw(52, 48, 165 + width, 120 + 42 * request_index, FONT_NORMAL_WHITE);
                    } else {
                        lang_text_draw(52, 47, 127 + width, 120 + 42 * request_index, FONT_NORMAL_WHITE);
                    }
                }
                request_index++;
            }
        }
        if (!request_index) {
            lang_text_draw_multiline(52, 21, 64, 160, 512, FONT_NORMAL_WHITE);
        }
    }
    return IMPERIAL_ADVISOR_HEIGHT;
}

static void draw_foreground_imperial_advisor(void)
{
    inner_panel_draw(56, 324, 32, 6);
    // Request buttons
    if (get_request_status(0)) {
        button_border_draw(38, 96, 550, 40, focus_button_id_imperial_advisor == 1);
    }
    if (get_request_status(1)) {
        button_border_draw(38, 138, 550, 40, focus_button_id_imperial_advisor == 2);
    }
    if (get_request_status(2)) {
        button_border_draw(38, 180, 550, 40, focus_button_id_imperial_advisor == 3);
    }
    if (get_request_status(3)) {
        button_border_draw(38, 222, 550, 40, focus_button_id_imperial_advisor == 4);
    }
    if (get_request_status(4)) {
        button_border_draw(38, 264, 550, 40, focus_button_id_imperial_advisor == 5);
    }
    lang_text_draw(32, city_data.emperor.player_rank, 64, 338, FONT_LARGE_BROWN);
    int width = lang_text_draw(52, 1, 64, 372, FONT_NORMAL_WHITE);
    text_draw_money(city_data.emperor.personal_savings, 72 + width, 372, FONT_NORMAL_WHITE);
    // Send a gift
    button_border_draw(312, 341, 250, 20, focus_button_id_imperial_advisor == 6);
    lang_text_draw_centered(52, 49, 312, 346, 250, FONT_NORMAL_WHITE);
    // Give to city
    button_border_draw(312, 367, 250, 20, focus_button_id_imperial_advisor == 7);
    lang_text_draw_centered(52, 2, 312, 372, 250, FONT_NORMAL_WHITE);
    // Set salary
    button_border_draw(62, 393, 500, 20, focus_button_id_imperial_advisor == 8);
    width = lang_text_draw(52, city_data.emperor.salary_rank + 4, 112, 398, FONT_NORMAL_WHITE);
    width += text_draw_number(city_data.emperor.salary_amount, '@', " ", 112 + width, 398, FONT_NORMAL_WHITE);
    lang_text_draw(52, 3, 112 + width, 398, FONT_NORMAL_WHITE);
    scrollbar_draw(&scrollbar_imperial_advisor);
}

static int handle_mouse_imperial_advisor(struct mouse_t *m)
{
    if (scrollbar_handle_mouse(&scrollbar_imperial_advisor, m)) {
        return 1;
    }
    if (generic_buttons_handle_mouse(m, 0, 0, imperial_buttons, sizeof(imperial_buttons) / sizeof(struct generic_button_t), &focus_button_id_imperial_advisor)) {
        return 1;
    }
    return 0;
}

static struct advisor_window_type_t *window_advisor_imperial(void)
{
    static struct advisor_window_type_t window = {
        draw_background_imperial_advisor,
        draw_foreground_imperial_advisor,
        handle_mouse_imperial_advisor,
    };
    goods_requests_to_draw = 0;
    for (int i = 0; i < MAX_REQUESTS; i++) {
        if (scenario.requests[i].resource && scenario.requests[i].visible) {
            goods_requests_to_draw++;
        }
    }
    scrollbar_init(&scrollbar_imperial_advisor, 0, goods_requests_to_draw - MAX_REQUESTS_SHOWN);
    return &window;
}

static void allocate_workers_to_categories(void)
{
    int workers_needed = 0;
    for (int i = 0; i < LABOR_CATEGORIES_COUNT; i++) {
        city_data.labor.categories[i].workers_allocated = 0;
        workers_needed += city_data.labor.categories[i].workers_needed;
    }
    city_data.labor.workers_needed = 0;
    if (workers_needed <= city_data.labor.workers_available) {
        for (int i = 0; i < LABOR_CATEGORIES_COUNT; i++) {
            city_data.labor.categories[i].workers_allocated = city_data.labor.categories[i].workers_needed;
        }
        city_data.labor.workers_employed = workers_needed;
    } else {
        // not enough workers
        int available = city_data.labor.workers_available;
        // distribute by user-defined priority
        for (int p = 1; p <= 9 && available > 0; p++) {
            for (int c = 0; c < 9; c++) {
                if (p == city_data.labor.categories[c].priority) {
                    int to_allocate = city_data.labor.categories[c].workers_needed;
                    if (to_allocate > available) {
                        to_allocate = available;
                    }
                    city_data.labor.categories[c].workers_allocated = to_allocate;
                    available -= to_allocate;
                    break;
                }
            }
        }
        // (sort of) round-robin distribution over unprioritized categories:
        int guard = 0;
        do {
            guard++;
            if (guard >= city_data.labor.workers_available) {
                break;
            }
            for (int p = 0; p < 9; p++) {
                int cat = DEFAULT_PRIORITY[p].category;
                if (!city_data.labor.categories[cat].priority) {
                    int needed = city_data.labor.categories[cat].workers_needed
                        - city_data.labor.categories[cat].workers_allocated;
                    if (needed > 0) {
                        int to_allocate = DEFAULT_PRIORITY[p].workers;
                        if (to_allocate > available) {
                            to_allocate = available;
                        }
                        if (to_allocate > needed) {
                            to_allocate = needed;
                        }
                        city_data.labor.categories[cat].workers_allocated += to_allocate;
                        available -= to_allocate;
                        if (available <= 0) {
                            break;
                        }
                    }
                }
            }
        } while (available > 0);

        city_data.labor.workers_employed = city_data.labor.workers_available;
        for (int i = 0; i < 9; i++) {
            city_data.labor.workers_needed +=
                city_data.labor.categories[i].workers_needed - city_data.labor.categories[i].workers_allocated;
        }
    }
    city_data.labor.workers_unemployed = city_data.labor.workers_available - city_data.labor.workers_employed;
    city_data.labor.unemployment_percentage =
        calc_percentage(city_data.labor.workers_unemployed, city_data.labor.workers_available);
}

static int should_have_workers(struct building_t *b, int check_access)
{
    if (b->labor_category < 0) {
        return 0;
    }

    if (b->labor_category == LABOR_CATEGORY_ENTERTAINMENT) {
        if (b->type == BUILDING_HIPPODROME && b->prev_part_building_id) {
            return 0;
        }
    } else if (b->labor_category == LABOR_CATEGORY_FOOD_PRODUCTION || b->labor_category == LABOR_CATEGORY_INDUSTRY_COMMERCE) {
        if (b->type >= BUILDING_WHEAT_FARM && b->type <= BUILDING_WEAPONS_WORKSHOP && city_data.resource.mothballed[b->output_resource_id]) {
            return 0;
        }
    }
    // engineering and water are always covered
    if (b->labor_category == LABOR_CATEGORY_ENGINEERING || b->labor_category == LABOR_CATEGORY_WATER) {
        return 1;
    }
    if (check_access) {
        return b->houses_covered > 0 ? 1 : 0;
    }
    return 1;
}

static void allocate_workers_to_buildings(void)
{
    // set building worker weight
    int water_per_10k_per_building = calc_percentage(100, city_data.labor.categories[LABOR_CATEGORY_WATER].buildings);
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE) {
            continue;
        }
        int cat = building_properties[b->type].labor_category;
        if (cat == LABOR_CATEGORY_WATER) {
            b->percentage_houses_covered = water_per_10k_per_building;
        } else if (cat >= 0) {
            b->percentage_houses_covered = 0;
            if (b->houses_covered) {
                b->percentage_houses_covered =
                    calc_percentage(100 * b->houses_covered, city_data.labor.categories[cat].total_houses_covered);
            }
        }
    }
    // allocate workers to water
    static int start_building_id = 1;
    struct labor_category_data_t *water_cat = &city_data.labor.categories[LABOR_CATEGORY_WATER];

    int percentage_not_filled = 100 - calc_percentage(water_cat->workers_allocated, water_cat->workers_needed);

    int buildings_to_skip = calc_adjust_with_percentage(water_cat->buildings, percentage_not_filled);

    int workers_per_building;
    if (buildings_to_skip == water_cat->buildings) {
        workers_per_building = 1;
    } else {
        workers_per_building = water_cat->workers_allocated / (water_cat->buildings - buildings_to_skip);
    }
    int building_id = start_building_id;
    start_building_id = 0;
    for (int guard = 1; guard < MAX_BUILDINGS; guard++, building_id++) {
        if (building_id >= MAX_BUILDINGS) {
            building_id = 1;
        }
        struct building_t *b = &all_buildings[building_id];
        if (b->state != BUILDING_STATE_IN_USE || building_properties[b->type].labor_category != LABOR_CATEGORY_WATER) {
            continue;
        }
        b->num_workers = 0;
        if (b->percentage_houses_covered > 0) {
            if (percentage_not_filled > 0) {
                if (buildings_to_skip) {
                    --buildings_to_skip;
                } else if (start_building_id) {
                    b->num_workers = workers_per_building;
                } else {
                    start_building_id = building_id;
                    b->num_workers = workers_per_building;
                }
            } else {
                b->num_workers = building_properties[b->type].n_laborers;
            }
        }
    }
    if (!start_building_id) {
        // no buildings assigned or full employment
        start_building_id = 1;
    }
    // allocate workers to non-water buildings
    int category_workers_needed[LABOR_CATEGORIES_COUNT];
    int category_workers_allocated[LABOR_CATEGORIES_COUNT];
    for (int i = 0; i < LABOR_CATEGORIES_COUNT; i++) {
        category_workers_allocated[i] = 0;
        category_workers_needed[i] =
            city_data.labor.categories[i].workers_allocated < city_data.labor.categories[i].workers_needed
            ? 1 : 0;
    }
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE) {
            continue;
        }
        int cat = building_properties[b->type].labor_category;
        if (cat == LABOR_CATEGORY_WATER || cat < 0) {
            // water is handled by allocate workers to water(void)
            continue;
        }
        b->num_workers = 0;
        if (!should_have_workers(b, 0)) {
            continue;
        }
        if (b->percentage_houses_covered > 0) {
            if (category_workers_needed[cat]) {
                int num_workers = calc_adjust_with_percentage(
                    city_data.labor.categories[cat].workers_allocated,
                    b->percentage_houses_covered) / 100;
                if (num_workers > building_properties[b->type].n_laborers) {
                    num_workers = building_properties[b->type].n_laborers;
                }
                b->num_workers = num_workers;
                category_workers_allocated[cat] += num_workers;
            } else {
                b->num_workers = building_properties[b->type].n_laborers;
            }
        }
    }
    for (int i = 0; i < LABOR_CATEGORIES_COUNT; i++) {
        if (category_workers_needed[i]) {
            // watch out: category_workers_needed is now reset to 'unallocated workers available'
            if (category_workers_allocated[i] >= city_data.labor.categories[i].workers_allocated) {
                category_workers_needed[i] = 0;
                category_workers_allocated[i] = 0;
            } else {
                category_workers_needed[i] =
                    city_data.labor.categories[i].workers_allocated - category_workers_allocated[i];
            }
        }
    }
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE) {
            continue;
        }
        int cat = building_properties[b->type].labor_category;
        if (cat < 0 || cat == LABOR_CATEGORY_WATER || cat == LABOR_CATEGORY_MILITARY) {
            continue;
        }
        if (!should_have_workers(b, 0)) {
            continue;
        }
        if (b->percentage_houses_covered > 0 && category_workers_needed[cat]) {
            if (b->num_workers < building_properties[b->type].n_laborers) {
                int needed = building_properties[b->type].n_laborers - b->num_workers;
                if (needed > category_workers_needed[cat]) {
                    b->num_workers += category_workers_needed[cat];
                    category_workers_needed[cat] = 0;
                } else {
                    b->num_workers += needed;
                    category_workers_needed[cat] -= needed;
                }
            }
        }
    }
}

static void city_labor_allocate_workers(void)
{
    allocate_workers_to_categories();
    allocate_workers_to_buildings();
}

static void city_labor_set_priority(int category, int new_priority)
{
    int old_priority = city_data.labor.categories[category].priority;
    if (old_priority == new_priority) {
        return;
    }
    int shift;
    int from_prio;
    int to_prio;
    if (!old_priority && new_priority) {
        // shift all bigger than 'new_priority' by one down (+1)
        shift = 1;
        from_prio = new_priority;
        to_prio = 9;
    } else if (old_priority && !new_priority) {
        // shift all bigger than 'old_priority' by one up (-1)
        shift = -1;
        from_prio = old_priority;
        to_prio = 9;
    } else if (new_priority < old_priority) {
        // shift all between new and old by one down (+1)
        shift = 1;
        from_prio = new_priority;
        to_prio = old_priority;
    } else {
        // shift all between old and new by one up (-1)
        shift = -1;
        from_prio = old_priority;
        to_prio = new_priority;
    }
    city_data.labor.categories[category].priority = new_priority;
    for (int i = 0; i < 9; i++) {
        if (i == category) {
            continue;
        }
        int current_priority = city_data.labor.categories[i].priority;
        if (from_prio <= current_priority && current_priority <= to_prio) {
            city_data.labor.categories[i].priority += shift;
        }
    }
    city_labor_allocate_workers();
}

static void button_set_priority(int new_priority, __attribute__((unused)) int param2)
{
    city_labor_set_priority(labor_priority_data.category, new_priority);
    window_go_back();
}

static struct generic_button_t priority_buttons[] = {
    {176, 170, 27, 27, button_set_priority, button_none, 1, 0},
    {208, 170, 27, 27, button_set_priority, button_none, 2, 0},
    {240, 170, 27, 27, button_set_priority, button_none, 3, 0},
    {272, 170, 27, 27, button_set_priority, button_none, 4, 0},
    {304, 170, 27, 27, button_set_priority, button_none, 5, 0},
    {336, 170, 27, 27, button_set_priority, button_none, 6, 0},
    {368, 170, 27, 27, button_set_priority, button_none, 7, 0},
    {400, 170, 27, 27, button_set_priority, button_none, 8, 0},
    {432, 170, 27, 27, button_set_priority, button_none, 9, 0},
};

static void button_remove_priority(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    city_labor_set_priority(labor_priority_data.category, 0);
    window_go_back();
}

static struct generic_button_t remove_priority_button[] = {
    {220, 206, 200, 25, button_remove_priority, button_none, 0, 0}
};

static void draw_foreground_labor_priority(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    outer_panel_draw(160, 122, 20, 8);
    // Priority level
    lang_text_draw_centered(50, 25, 160, 138, 320, FONT_LARGE_BLACK);
    for (int i = 1; i < 10; i++) {
        button_border_draw(144 + 32 * i, 170, 27, 27, labor_priority_data.focus_id_button_set_priority == i);
        lang_text_draw_centered(50, 26 + i, 145 + 32 * i, 172, 27, FONT_LARGE_BLACK);
        if (i > labor_priority_data.max_items) {
            graphics_shade_rect(145 + 32 * i, 171, 25, 25, 1);
        }
    }
    // No priority
    button_border_draw(220, 206, 200, 25, labor_priority_data.focus_id_button_remove_priority);
    lang_text_draw_centered(50, 26, 220, 212, 200, FONT_NORMAL_BLACK);
    set_translation(0, 0);
}

static void handle_input_labor_priority(struct mouse_t *m, struct hotkeys_t *h)
{
    if (m->right.went_up || h->escape_pressed) {
        window_go_back();
        return;
    }
    struct mouse_t *m_dialog = mouse_in_dialog(m);
    if (generic_buttons_handle_mouse(m_dialog, 0, 0,
        priority_buttons, labor_priority_data.max_items, &labor_priority_data.focus_id_button_set_priority)) {
        return;
    }
    if (generic_buttons_handle_mouse(m_dialog, 0, 0, remove_priority_button, 1, &labor_priority_data.focus_id_button_remove_priority)) {
        return;
    }
    // exit window on click outside of outer panel boundaries
    if (m_dialog->left.went_up && (m_dialog->x < 160 || m_dialog->y < 122 || m_dialog->x > 480 || m_dialog->y > 250)) {
        window_go_back();
        return;
    }
}

static void button_priority(int category, __attribute__((unused)) int param2)
{
    struct window_type_t window = {
        WINDOW_LABOR_PRIORITY,
        window_draw_underlying_window,
        draw_foreground_labor_priority,
        handle_input_labor_priority,
    };
    labor_priority_data.category = category;
    labor_priority_data.max_items = 0;
    for (int i = 0; i < 9; i++) {
        if (city_data.labor.categories[i].priority > 0) {
            labor_priority_data.max_items++;
        }
    }
    if (labor_priority_data.max_items < 9 && !city_data.labor.categories[category].priority) {
        // allow space for new priority
        labor_priority_data.max_items++;
    }
    window_show(&window);
}

static struct generic_button_t category_buttons[] = {
    {40, 77, 560, 22, button_priority, button_none, 0, 0},
    {40, 102, 560, 22, button_priority, button_none, 1, 0},
    {40, 127, 560, 22, button_priority, button_none, 2, 0},
    {40, 152, 560, 22, button_priority, button_none, 3, 0},
    {40, 177, 560, 22, button_priority, button_none, 4, 0},
    {40, 202, 560, 22, button_priority, button_none, 5, 0},
    {40, 227, 560, 22, button_priority, button_none, 6, 0},
    {40, 252, 560, 22, button_priority, button_none, 7, 0},
    {40, 277, 560, 22, button_priority, button_none, 8, 0},
};

static void city_finance_estimate_wages(void)
{
    int monthly_wages = city_data.labor.wages * city_data.labor.workers_employed / 10 / 12;
    city_data.finance.this_year.expenses.wages = city_data.finance.wages_so_far;
    city_data.finance.estimated_wages = (12 - time_data.month) * monthly_wages + city_data.finance.wages_so_far;
}

static void arrow_button_wages(int value, __attribute__((unused)) int param2)
{
    city_data.labor.wages = calc_bound(city_data.labor.wages + value, 0, 100);
    city_finance_estimate_wages();
    city_finance_calculate_totals();
    window_invalidate();
}

static struct arrow_button_t wage_arrow_buttons[] = {
    {158, 354, 17, 24, arrow_button_wages, -1, 0, 0, 0},
    {182, 354, 15, 24, arrow_button_wages, 1, 0, 0, 0}
};

static int draw_background_labor_advisor(void)
{
    outer_panel_draw(0, 0, 40, 26);
    // Labor advisor icon
    image_draw(image_data_s.group_image_ids[GROUP_ADVISOR_ICONS], 10, 10);
    // Labor Allocation
    lang_text_draw(50, 0, 60, 12, FONT_LARGE_BLACK);
    // Priority/Sector/Need/Have
    lang_text_draw(50, 21, 60, 56, FONT_SMALL_PLAIN);
    lang_text_draw(50, 22, 170, 56, FONT_SMALL_PLAIN);
    lang_text_draw(50, 23, 400, 56, FONT_SMALL_PLAIN);
    lang_text_draw(50, 24, 500, 56, FONT_SMALL_PLAIN);
    inner_panel_draw(32, 70, 36, 15);
    // Employed workforce
    int width = text_draw_number(city_data.labor.workers_employed, 0, 0, 32, 320, FONT_NORMAL_BLACK);
    lang_text_draw(50, 12, 32 + width, 320, FONT_NORMAL_BLACK);
    // Unemployed workforce
    width = text_draw_number(city_data.labor.workers_unemployed, 0, 0, 320, 320, FONT_NORMAL_BLACK);
    width += lang_text_draw(50, 13, 320 + width, 320, FONT_NORMAL_BLACK);
    text_draw_number(city_data.labor.unemployment_percentage, 0, "%)", 314 + width, 320, FONT_NORMAL_BLACK);
    // Wages panel
    inner_panel_draw(64, 350, 32, 2);
    lang_text_draw(50, 14, 80, 359, FONT_NORMAL_WHITE);
    text_draw_number(city_data.labor.wages, 0, 0, 222, 359, FONT_NORMAL_WHITE);
    lang_text_draw(50, 15, 254, 359, FONT_NORMAL_WHITE);
    lang_text_draw(50, 18, 330, 359, FONT_NORMAL_WHITE);
    text_draw_number(city_data.labor.wages_rome, 0, ")", 430, 359, FONT_NORMAL_WHITE);
    // Estimated annual bill
    lang_text_draw(50, 19, 64, 388, FONT_NORMAL_BLACK);
    text_draw_money(city_data.finance.estimated_wages, 255, 388, FONT_NORMAL_BLACK);
    // outer panel draw height
    return 26;
}

static void draw_foreground_labor_advisor(void)
{
    // Industry stats
    for (int i = 0; i < 9; i++) {
        button_border_draw(40, 77 + 25 * i, 560, 22, i == focus_button_id_labor_advisor - 1);
        struct labor_category_data_t *labor_category = &city_data.labor.categories[i];
        if (labor_category->priority) {
            image_draw(image_data_s.group_image_ids[GROUP_LABOR_PRIORITY_LOCK], 70, 80 + 25 * i);
            text_draw_number(labor_category->priority, 0, 0, 90, 82 + 25 * i, FONT_NORMAL_WHITE);
        }
        lang_text_draw(50, i + 1, 170, 82 + 25 * i, FONT_NORMAL_WHITE);
        text_draw_number(labor_category->workers_needed, 0, 0, 410, 82 + 25 * i, FONT_NORMAL_WHITE);
        if (labor_category->workers_needed > labor_category->workers_allocated) {
            text_draw_number(labor_category->workers_allocated, 0, 0, 510, 82 + 25 * i, FONT_NORMAL_RED);
        } else {
            text_draw_number(labor_category->workers_allocated, 0, 0, 510, 82 + 25 * i, FONT_NORMAL_WHITE);
        }
    }

    arrow_buttons_draw(0, 0, wage_arrow_buttons, 2);
}

static int handle_mouse_labor_advisor(struct mouse_t *m)
{
    if (generic_buttons_handle_mouse(m, 0, 0, category_buttons, sizeof(category_buttons) / sizeof(struct generic_button_t), &focus_button_id_labor_advisor)) {
        return 1;
    }
    if (arrow_buttons_handle_mouse(m, 0, 0, wage_arrow_buttons, 2, &arrow_button_focus_labor_advisor)) {
        return 1;
    }
    return 0;
}

static struct advisor_window_type_t *window_advisor_labor(void)
{
    static struct advisor_window_type_t window = {
        draw_background_labor_advisor,
        draw_foreground_labor_advisor,
        handle_mouse_labor_advisor,
    };
    return &window;
}

static int get_legion_formation_by_index_rank(int legion_index)
{
    int index = 0;
    for (int i = 0; i < MAX_LEGIONS; i++) {
        if (legion_formations[i].in_use) {
            if (index == legion_index) {
                return i;
            }
            index++;
        }
    }
    return -1;
}

static void button_go_to_legion(int legion_id, __attribute__((unused)) int param2)
{
    struct formation_t *m = &legion_formations[get_legion_formation_by_index_rank(legion_id)];
    city_view_go_to_grid_offset(map_grid_offset(m->standard_x, m->standard_y));
    window_city_show();
}

static void button_return_to_fort(int legion_id, __attribute__((unused)) int param2)
{
    struct formation_t *m = &legion_formations[get_legion_formation_by_index_rank(legion_id)];
    if (!m->in_distant_battle && !m->is_at_rest) {
        return_legion_formation_home(m);
        window_invalidate();
    }
}

static void button_empire_service(int legion_id, __attribute__((unused)) int param2)
{
    struct formation_t *m = &legion_formations[get_legion_formation_by_index_rank(legion_id)];
    if (!m->in_distant_battle) {
        m->empire_service = m->empire_service ? 0 : 1;
        window_invalidate();
    }
}

static struct generic_button_t fort_buttons[] = {
    {400, 83, 30, 30, button_go_to_legion, button_none, 0, 0},
    {480, 83, 30, 30, button_return_to_fort, button_none, 0, 0},
    {560, 83, 30, 30, button_empire_service, button_none, 0, 0},
    {400, 127, 30, 30, button_go_to_legion, button_none, 1, 0},
    {480, 127, 30, 30, button_return_to_fort, button_none, 1, 0},
    {560, 127, 30, 30, button_empire_service, button_none, 1, 0},
    {400, 171, 30, 30, button_go_to_legion, button_none, 2, 0},
    {480, 171, 30, 30, button_return_to_fort, button_none, 2, 0},
    {560, 171, 30, 30, button_empire_service, button_none, 2, 0},
    {400, 215, 30, 30, button_go_to_legion, button_none, 3, 0},
    {480, 215, 30, 30, button_return_to_fort, button_none, 3, 0},
    {560, 215, 30, 30, button_empire_service, button_none, 3, 0},
    {400, 259, 30, 30, button_go_to_legion, button_none, 4, 0},
    {480, 259, 30, 30, button_return_to_fort, button_none, 4, 0},
    {560, 259, 30, 30, button_empire_service, button_none, 4, 0},
    {400, 303, 30, 30, button_go_to_legion, button_none, 5, 0},
    {480, 303, 30, 30, button_return_to_fort, button_none, 5, 0},
    {560, 303, 30, 30, button_empire_service, button_none, 5, 0},
};

static int draw_background_military_advisor(void)
{
    outer_panel_draw(0, 0, 40, MILITARY_ADVISOR_HEIGHT);
    // Military advisor icon
    image_draw(image_data_s.group_image_ids[GROUP_ADVISOR_ICONS] + 1, 10, 10);
    // Morale
    lang_text_draw(138, 36, 290, 58, FONT_SMALL_PLAIN);
    // Legion status
    lang_text_draw(51, 0, 60, 12, FONT_LARGE_BLACK);
    // Button headers
    lang_text_draw(51, 1, 390, 43, FONT_SMALL_PLAIN);
    lang_text_draw(51, 2, 390, 58, FONT_SMALL_PLAIN);
    lang_text_draw(51, 3, 470, 43, FONT_SMALL_PLAIN);
    lang_text_draw(51, 4, 470, 58, FONT_SMALL_PLAIN);
    lang_text_draw(51, 5, 550, 43, FONT_SMALL_PLAIN);
    lang_text_draw(51, 6, 550, 58, FONT_SMALL_PLAIN);

    int enemy_text_id;
    if (city_data.figure.enemies) {
        enemy_text_id = 10;
    } else if (city_data.figure.imperial_soldiers) {
        enemy_text_id = 11;
    } else if (scenario.invasion_upcoming) {
        enemy_text_id = 9;
    } else {
        enemy_text_id = 8;
    }
    int distant_battle_text_id;
    if (city_data.distant_battle.roman_months_to_travel_back) {
        distant_battle_text_id = 15;
    } else if (city_data.distant_battle.roman_months_to_travel_forth) {
        distant_battle_text_id = 14;
    } else if (city_data.distant_battle.months_until_battle) {
        distant_battle_text_id = 13;
    } else {
        distant_battle_text_id = 12;
    }

    inner_panel_draw(32, 70, 36, 17);
    if (city_data.military.total_legions) {
        int draw_index = 0;
        for (int i = 0; i < MAX_LEGIONS; i++) {
            struct formation_t *m = &legion_formations[i];
            if (m->in_use) {
                button_border_draw(38, 33 + 44 * (draw_index + 1), 560, 40, 0);
                image_draw(image_data_s.group_image_ids[GROUP_FIGURE_FORT_STANDARD_ICONS] + m->id, 48, 38 + 44 * (draw_index + 1));
                lang_text_draw(138, m->id, 100, 39 + 44 * (draw_index + 1), FONT_NORMAL_WHITE);
                int width = text_draw_number(m->num_figures, ' ', "", 100, 56 + 44 * (draw_index + 1), FONT_NORMAL_GREEN);
                switch (m->figure_type) {
                    case FIGURE_FORT_LEGIONARY:
                        lang_text_draw(138, 33, 100 + width, 56 + 44 * (draw_index + 1), FONT_NORMAL_GREEN);
                        break;
                    case FIGURE_FORT_MOUNTED:
                        lang_text_draw(138, 34, 100 + width, 56 + 44 * (draw_index + 1), FONT_NORMAL_GREEN);
                        break;
                    case FIGURE_FORT_JAVELIN:
                        lang_text_draw(138, 35, 100 + width, 56 + 44 * (draw_index + 1), FONT_NORMAL_GREEN);
                        break;
                }
                lang_text_draw_centered(138, 37 + m->morale / 5, 240, 47 + 44 * (draw_index + 1), 150, FONT_NORMAL_GREEN);

                int image_id = image_data_s.group_image_ids[GROUP_FORT_ICONS];
                button_border_draw(400, 39 + 44 * (draw_index + 1), 30, 30, 0);
                image_draw(image_id, 403, 42 + 44 * (draw_index + 1));

                button_border_draw(480, 39 + 44 * (draw_index + 1), 30, 30, 0);
                if (m->is_at_rest || m->in_distant_battle) {
                    image_draw(image_id + 2, 483, 42 + 44 * (draw_index + 1));
                } else {
                    image_draw(image_id + 1, 483, 42 + 44 * (draw_index + 1));
                }

                button_border_draw(560, 39 + 44 * (draw_index + 1), 30, 30, 0);
                if (m->empire_service) {
                    image_draw(image_id + 3, 563, 42 + 44 * (draw_index + 1));
                } else {
                    image_draw(image_id + 4, 563, 42 + 44 * (draw_index + 1));
                }
                draw_index++;
            }
        }
        // x soldiers in y legions
        image_draw(image_data_s.group_image_ids[GROUP_BULLET], 60, 349);
        int total_soldiers = 0;
        for (int i = 0; i < MAX_LEGIONS; i++) {
            if (legion_formations[i].in_use) {
                total_soldiers += legion_formations[i].num_figures;
            }
        }
        int width = lang_text_draw_amount(8, 46, total_soldiers, 80, 348, FONT_NORMAL_BLACK);
        width += lang_text_draw(51, 7, 80 + width, 348, FONT_NORMAL_BLACK);
        lang_text_draw_amount(8, 48, city_data.military.total_legions, 80 + width, 348, FONT_NORMAL_BLACK);
        // Enemy threat status
        image_draw(image_data_s.group_image_ids[GROUP_BULLET], 60, 369);
        lang_text_draw(51, enemy_text_id, 80, 368, FONT_NORMAL_BLACK);
        // Distant battle status
        image_draw(image_data_s.group_image_ids[GROUP_BULLET], 60, 389);
        lang_text_draw(51, distant_battle_text_id, 80, 388, FONT_NORMAL_BLACK);
    } else {
        // You have no legions to command
        lang_text_draw_multiline(51, 16, 64, 200, 496, FONT_NORMAL_GREEN);
        // Enemy threat status
        image_draw(image_data_s.group_image_ids[GROUP_BULLET], 60, 359);
        lang_text_draw(51, enemy_text_id, 80, 358, FONT_NORMAL_BLACK);
        // Distant battle status
        image_draw(image_data_s.group_image_ids[GROUP_BULLET], 60, 379);
        lang_text_draw(51, distant_battle_text_id, 80, 378, FONT_NORMAL_BLACK);
    }

    return MILITARY_ADVISOR_HEIGHT;
}

static void draw_foreground_military_advisor(void)
{
    for (int i = 0; i < city_data.military.total_legions; i++) {
        button_border_draw(400, 83 + 44 * i, 30, 30, focus_button_id_military_advisor == 3 * i + 1);
        button_border_draw(480, 83 + 44 * i, 30, 30, focus_button_id_military_advisor == 3 * i + 2);
        button_border_draw(560, 83 + 44 * i, 30, 30, focus_button_id_military_advisor == 3 * i + 3);
    }
}

static int handle_mouse_military_advisor(struct mouse_t *m)
{
    return generic_buttons_handle_mouse(m, 0, 0, fort_buttons, 3 * city_data.military.total_legions, &focus_button_id_military_advisor);
}

static struct advisor_window_type_t *window_advisor_military(void)
{
    static struct advisor_window_type_t window = {
        draw_background_military_advisor,
        draw_foreground_military_advisor,
        handle_mouse_military_advisor,
    };
    return &window;
}

static void button_rating(int rating, __attribute__((unused)) int param2)
{
    city_data.ratings.selected = rating;
    window_invalidate();
}

static struct generic_button_t rating_buttons[] = {
    { 80, 286, 110, 66, button_rating, button_none, SELECTED_RATING_CULTURE, 0},
    {200, 286, 110, 66, button_rating, button_none, SELECTED_RATING_PROSPERITY, 0},
    {320, 286, 110, 66, button_rating, button_none, SELECTED_RATING_PEACE, 0},
    {440, 286, 110, 66, button_rating, button_none, SELECTED_RATING_FAVOR, 0},
};

static void draw_rating_column(int x_offset, int y_offset, int value, int has_reached)
{
    int image_base = image_data_s.group_image_ids[GROUP_RATINGS_COLUMN];
    int y = y_offset - image_get(image_base)->height;
    image_draw(image_base, x_offset, y);
    for (int i = 0; i < 2 * value; i++) {
        image_draw(image_base + 1, x_offset + 11, --y);
    }
    if (value >= 30 && has_reached) {
        image_draw(image_base + 2, x_offset - 6, y);
    }
}

static int city_rating_selected_explanation(void)
{
    switch (city_data.ratings.selected) {
        case SELECTED_RATING_CULTURE:
            return city_data.ratings.culture_explanation;
        case SELECTED_RATING_PROSPERITY:
            return city_data.ratings.prosperity_explanation;
        case SELECTED_RATING_PEACE:
            return city_data.ratings.peace_explanation;
        case SELECTED_RATING_FAVOR:
            return city_data.ratings.favor_explanation;
        default:
            return 0;
    }
}

static int draw_background_ratings_advisor(void)
{
    outer_panel_draw(0, 0, 40, RATINGS_ADVISOR_HEIGHT);
    image_draw(image_data_s.group_image_ids[GROUP_ADVISOR_ICONS] + 3, 10, 10);
    int width = lang_text_draw(53, 0, 60, 12, FONT_LARGE_BLACK);
    if (scenario.population_win_criteria.enabled) {
        width += lang_text_draw(53, 6, 80 + width, 17, FONT_NORMAL_BLACK);
        text_draw_number(scenario.population_win_criteria.goal, '@', ")", 80 + width, 17, FONT_NORMAL_BLACK);
    } else {
        lang_text_draw(53, 7, 80 + width, 17, FONT_NORMAL_BLACK);
    }
    image_draw(image_data_s.group_image_ids[GROUP_RATINGS_BACKGROUND], 60, 48);
    // culture
    button_border_draw(80, 286, 110, 66, focus_button_id_ratings_advisor == SELECTED_RATING_CULTURE);
    lang_text_draw_centered(53, 1, 80, 294, 110, FONT_NORMAL_BLACK);
    text_draw_number_centered(city_data.ratings.culture, 80, 309, 100, FONT_LARGE_BLACK);
    width = text_draw_number(scenario.culture_win_criteria.enabled ? scenario.culture_win_criteria.goal : 0,
            '@', " ", 85, 334, FONT_NORMAL_BLACK);
    lang_text_draw(53, 5, 85 + width, 334, FONT_NORMAL_BLACK);
    int has_reached = !scenario.culture_win_criteria.enabled || city_data.ratings.culture >= scenario.culture_win_criteria.goal;
    draw_rating_column(110, 274, city_data.ratings.culture, has_reached);
    // prosperity
    button_border_draw(200, 286, 110, 66, focus_button_id_ratings_advisor == SELECTED_RATING_PROSPERITY);
    lang_text_draw_centered(53, 2, 200, 294, 110, FONT_NORMAL_BLACK);
    text_draw_number_centered(city_data.ratings.prosperity, 200, 309, 100, FONT_LARGE_BLACK);
    width = text_draw_number(scenario.prosperity_win_criteria.enabled ? scenario.prosperity_win_criteria.goal : 0,
            '@', " ", 205, 334, FONT_NORMAL_BLACK);
    lang_text_draw(53, 5, 205 + width, 334, FONT_NORMAL_BLACK);
    has_reached = !scenario.prosperity_win_criteria.enabled || city_data.ratings.prosperity >= scenario.prosperity_win_criteria.goal;
    draw_rating_column(230, 274, city_data.ratings.prosperity, has_reached);
    // peace
    button_border_draw(320, 286, 110, 66, focus_button_id_ratings_advisor == SELECTED_RATING_PEACE);
    lang_text_draw_centered(53, 3, 320, 294, 110, FONT_NORMAL_BLACK);
    text_draw_number_centered(city_data.ratings.peace, 320, 309, 100, FONT_LARGE_BLACK);
    width = text_draw_number(scenario.peace_win_criteria.enabled ? scenario.peace_win_criteria.goal : 0,
            '@', " ", 325, 334, FONT_NORMAL_BLACK);
    lang_text_draw(53, 5, 325 + width, 334, FONT_NORMAL_BLACK);
    has_reached = !scenario.peace_win_criteria.enabled || city_data.ratings.peace >= scenario.peace_win_criteria.goal;
    draw_rating_column(350, 274, city_data.ratings.peace, has_reached);
    // favor
    button_border_draw(440, 286, 110, 66, focus_button_id_ratings_advisor == SELECTED_RATING_FAVOR);
    lang_text_draw_centered(53, 4, 440, 294, 110, FONT_NORMAL_BLACK);
    text_draw_number_centered(city_data.ratings.favor, 440, 309, 100, FONT_LARGE_BLACK);
    width = text_draw_number(scenario.favor_win_criteria.enabled ? scenario.favor_win_criteria.goal : 0,
            '@', " ", 445, 334, FONT_NORMAL_BLACK);
    lang_text_draw(53, 5, 445 + width, 334, FONT_NORMAL_BLACK);
    has_reached = !scenario.favor_win_criteria.enabled || city_data.ratings.favor >= scenario.favor_win_criteria.goal;
    draw_rating_column(470, 274, city_data.ratings.favor, has_reached);
    // bottom info box
    inner_panel_draw(64, 356, 32, 4);
    switch (city_data.ratings.selected) {
        case SELECTED_RATING_CULTURE:
            lang_text_draw(53, 1, 72, 359, FONT_NORMAL_WHITE);
            if (city_data.ratings.culture <= 90) {
                lang_text_draw_multiline(53, 9 + city_rating_selected_explanation(),
                    72, 374, 496, FONT_NORMAL_WHITE);
            } else {
                lang_text_draw_multiline(53, 50, 72, 374, 496, FONT_NORMAL_WHITE);
            }
            break;
        case SELECTED_RATING_PROSPERITY:
            lang_text_draw(53, 2, 72, 359, FONT_NORMAL_WHITE);
            if (city_data.ratings.prosperity <= 90) {
                lang_text_draw_multiline(53, 16 + city_rating_selected_explanation(),
                    72, 374, 496, FONT_NORMAL_WHITE);
            } else {
                lang_text_draw_multiline(53, 51, 72, 374, 496, FONT_NORMAL_WHITE);
            }
            break;
        case SELECTED_RATING_PEACE:
            lang_text_draw(53, 3, 72, 359, FONT_NORMAL_WHITE);
            if (city_data.ratings.peace <= 90) {
                lang_text_draw_multiline(53, 41 + city_rating_selected_explanation(),
                    72, 374, 496, FONT_NORMAL_WHITE);
            } else {
                lang_text_draw_multiline(53, 52, 72, 374, 496, FONT_NORMAL_WHITE);
            }
            break;
        case SELECTED_RATING_FAVOR:
            lang_text_draw(53, 4, 72, 359, FONT_NORMAL_WHITE);
            if (city_data.ratings.favor <= 90) {
                lang_text_draw_multiline(53, 27 + city_rating_selected_explanation(),
                    72, 374, 496, FONT_NORMAL_WHITE);
            } else {
                lang_text_draw_multiline(53, 53, 72, 374, 496, FONT_NORMAL_WHITE);
            }
            break;
        default:
            lang_text_draw_centered(53, 8, 72, 380, 496, FONT_NORMAL_WHITE);
            break;
    }

    return RATINGS_ADVISOR_HEIGHT;
}

static void draw_foreground_ratings_advisor(void)
{
    button_border_draw(80, 286, 110, 66, focus_button_id_ratings_advisor == SELECTED_RATING_CULTURE);
    button_border_draw(200, 286, 110, 66, focus_button_id_ratings_advisor == SELECTED_RATING_PROSPERITY);
    button_border_draw(320, 286, 110, 66, focus_button_id_ratings_advisor == SELECTED_RATING_PEACE);
    button_border_draw(440, 286, 110, 66, focus_button_id_ratings_advisor == SELECTED_RATING_FAVOR);
}

static int handle_mouse_ratings_advisor(struct mouse_t *m)
{
    return generic_buttons_handle_mouse(m, 0, 0, rating_buttons, 4, &focus_button_id_ratings_advisor);
}

static struct advisor_window_type_t *window_advisor_ratings(void)
{
    static struct advisor_window_type_t window = {
        draw_background_ratings_advisor,
        draw_foreground_ratings_advisor,
        handle_mouse_ratings_advisor,
    };
    return &window;
}

static void draw_foreground_trade_prices(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    graphics_shade_rect(33, 53, 574, 334, 0);
    outer_panel_draw(16, 140, 38, 10);
    // Coin image
    image_draw(COIN_IMAGE_ID, 32, 156);
    // Prices set by Rome
    lang_text_draw_centered(54, 21, 26, 156, 608, FONT_LARGE_BLACK);
    // Buyers pay
    lang_text_draw(54, 22, 32, 233, FONT_NORMAL_BLACK);
    // Sellers receive
    lang_text_draw(54, 23, 32, 257, FONT_NORMAL_BLACK);
    for (int i = RESOURCE_WHEAT; i < RESOURCE_TYPES_MAX; i++) {
        image_draw(resource_images[i].icon_img_id + resource_image_offset(i, RESOURCE_IMAGE_ICON), 126 + 30 * i, 201);
        text_draw_number_centered(trade_prices[i].buy, 120 + 30 * i, 234, 30, FONT_SMALL_PLAIN);
        text_draw_number_centered(trade_prices[i].sell, 120 + 30 * i, 259, 30, FONT_SMALL_PLAIN);
    }
    set_translation(0, 0);
}

static void handle_input_trade_prices(struct mouse_t *m, struct hotkeys_t *h)
{
    if (m->right.went_up || h->escape_pressed) {
        window_go_back();
        return;
    }

    struct mouse_t *m_dialog = mouse_in_dialog(m);
    // exit window on click outside of outer panel boundaries
    if (m_dialog->left.went_up && (m_dialog->x < 16 || m_dialog->y < 144 || m_dialog->x > 624 || m_dialog->y > 300)) {
        window_go_back();
        return;
    }
}

static void button_prices(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    struct window_type_t window = {
        WINDOW_TRADE_PRICES,
        window_draw_underlying_window,
        draw_foreground_trade_prices,
        handle_input_trade_prices,
    };
    window_show(&window);
}

static void button_empire(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_empire_show();
}

static void button_resource_trade_advisor(int resource_index, __attribute__((unused)) int param2)
{
    window_resource_settings_show(available.resource_list.items[resource_index]);
}

static struct generic_button_t resource_buttons[] = {
    {400, 398, 200, 23, button_prices, button_none, 1, 0},
    {100, 398, 200, 23, button_empire, button_none, 1, 0},
    {80, 56, 480, 20, button_resource_trade_advisor, button_none, 0, 0},
    {80, 78, 480, 20, button_resource_trade_advisor, button_none, 1, 0},
    {80, 100, 480, 20, button_resource_trade_advisor, button_none, 2, 0},
    {80, 122, 480, 20, button_resource_trade_advisor, button_none, 3, 0},
    {80, 144, 480, 20, button_resource_trade_advisor, button_none, 4, 0},
    {80, 166, 480, 20, button_resource_trade_advisor, button_none, 5, 0},
    {80, 188, 480, 20, button_resource_trade_advisor, button_none, 6, 0},
    {80, 210, 480, 20, button_resource_trade_advisor, button_none, 7, 0},
    {80, 232, 480, 20, button_resource_trade_advisor, button_none, 8, 0},
    {80, 254, 480, 20, button_resource_trade_advisor, button_none, 9, 0},
    {80, 276, 480, 20, button_resource_trade_advisor, button_none, 10, 0},
    {80, 298, 480, 20, button_resource_trade_advisor, button_none, 11, 0},
    {80, 320, 480, 20, button_resource_trade_advisor, button_none, 12, 0},
    {80, 342, 480, 20, button_resource_trade_advisor, button_none, 13, 0},
    {80, 364, 480, 20, button_resource_trade_advisor, button_none, 14, 0}
};

static int our_city_can_produce_resource(int resource)
{
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        if (empire_objects[i].in_use && empire_objects[i].city_type == EMPIRE_CITY_OURS) {
            if (empire_objects[i].resource_sell_limit[resource]) {
                return 1;
            } else {
                // there's only one of our city per empire state, no need to search the rest of the list
                return 0;
            }
        }
    }
    // our city wasn't found or not in use (shouldn't happen)
    return 0;
}

static int resource_import_trade_route_open(int resource)
{
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        if (empire_objects[i].in_use
            && empire_objects[i].city_type == EMPIRE_CITY_TRADE
            && empire_objects[i].trade_route_open
            && empire_objects[i].resource_sell_limit[resource]) {
            return 1;
        }
    }
    return 0;
}

static int empire_can_produce_resource(int resource)
{
    int raw_resource;
    switch (resource) {
        case RESOURCE_POTTERY:
            raw_resource = RESOURCE_CLAY;
            break;
        case RESOURCE_FURNITURE:
            raw_resource = RESOURCE_TIMBER;
            break;
        case RESOURCE_OIL:
            raw_resource = RESOURCE_OLIVES;
            break;
        case RESOURCE_WINE:
            raw_resource = RESOURCE_VINES;
            break;
        case RESOURCE_WEAPONS:
            raw_resource = RESOURCE_IRON;
            break;
        default:
            raw_resource = resource;
            break;
    }
    // if raw resource, available if we can either produce or import it
    if (resource == raw_resource) {
        return (our_city_can_produce_resource(resource) || resource_import_trade_route_open(resource));
    }
    // if finished goods, available if we can either:
    // - produce the raw material or import it, and we can produce the finished material (workshop is allowed)
    // - import the finished goods
    else {
        return (
                resource_import_trade_route_open(resource)
            || ((our_city_can_produce_resource(raw_resource) || resource_import_trade_route_open(raw_resource)) && our_city_can_produce_resource(resource))
        );
    }
}

static void city_resource_determine_available(void)
{
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        available.resource_list.items[i] = 0;
        available.food_list.items[i] = 0;
    }
    available.resource_list.size = 0;
    available.food_list.size = 0;

    for (int i = RESOURCE_WHEAT; i < RESOURCE_TYPES_MAX; i++) {
        if (empire_can_produce_resource(i)) {
            available.resource_list.items[available.resource_list.size++] = i;
        }
    }
    for (int i = RESOURCE_WHEAT; i <= RESOURCE_MEAT; i++) {
        if (empire_can_produce_resource(i)) {
            available.food_list.items[available.food_list.size++] = i;
        }
    }
}

static int draw_background_trade_advisor(void)
{
    city_resource_determine_available();

    outer_panel_draw(0, 0, 40, TRADE_ADVISOR_HEIGHT);
    image_draw(image_data_s.group_image_ids[GROUP_ADVISOR_ICONS] + 4, 10, 10);

    lang_text_draw(54, 0, 60, 12, FONT_LARGE_BLACK);
    int width = lang_text_get_width(54, 1, FONT_NORMAL_BLACK);
    lang_text_draw(54, 1, 600 - width, 38, FONT_NORMAL_BLACK);

    return TRADE_ADVISOR_HEIGHT;
}

static void draw_foreground_trade_advisor(void)
{
    inner_panel_draw(32, 52, 36, 21);
    struct resource_list_t *list = &available.resource_list;
    for (int i = 0; i < list->size; i++) {
        int y_offset = 22 * i;
        int resource = list->items[i];
        image_draw(resource_images[resource].icon_img_id + resource_image_offset(resource, RESOURCE_IMAGE_ICON), 48, y_offset + 54);
        image_draw(resource_images[resource].icon_img_id + resource_image_offset(resource, RESOURCE_IMAGE_ICON), 568, y_offset + 54);

        if (focus_button_id_trade_advisor - 3 == i) {
            button_border_draw(80, y_offset + 54, 480, 24, 1);
        }
        text_draw(resource_strings[resource], 88, y_offset + 61, FONT_NORMAL_WHITE, COLOR_BLACK);
        text_draw_number_centered(city_data.resource.stored_in_warehouses[resource], 180, y_offset + 61, 60, FONT_NORMAL_WHITE);
        if (city_data.resource.mothballed[resource]) {
            lang_text_draw_centered(18, 5, 240, y_offset + 61, 100, FONT_NORMAL_WHITE);
        }
        if (city_data.resource.stockpiled[resource]) {
            lang_text_draw(54, 3, 340, y_offset + 61, FONT_NORMAL_WHITE);
        } else {
            int trade_status = city_data.resource.trade_status[resource];
            if (trade_status == TRADE_STATUS_IMPORT) {
                lang_text_draw(54, 5, 340, y_offset + 61, FONT_NORMAL_WHITE);
            } else if (trade_status == TRADE_STATUS_EXPORT) {
                int width = lang_text_draw(54, 6, 340, y_offset + 61, FONT_NORMAL_WHITE);
                text_draw_number(city_data.resource.export_over[resource], '@', " ",
                    340 + width, y_offset + 61, FONT_NORMAL_WHITE);
            }
        }
    }

    button_border_draw(398, 396, 200, 24, focus_button_id_trade_advisor == 1);
    lang_text_draw_centered(54, 2, 400, 402, 200, FONT_NORMAL_BLACK);

    button_border_draw(98, 396, 200, 24, focus_button_id_trade_advisor == 2);
    lang_text_draw_centered(54, 30, 100, 402, 200, FONT_NORMAL_BLACK);
}

static int handle_mouse_trade_advisor(struct mouse_t *m)
{
    int num_resources = available.resource_list.size;
    return generic_buttons_handle_mouse(m, 0, 0, resource_buttons, num_resources + 2, &focus_button_id_trade_advisor);
}

static struct advisor_window_type_t *window_advisor_trade(void)
{
    static struct advisor_window_type_t window = {
        draw_background_trade_advisor,
        draw_foreground_trade_advisor,
        handle_mouse_trade_advisor,
    };
    return &window;
}

static void button_graph(int param1, __attribute__((unused)) int param2)
{
    int new_order;
    switch (city_data.population.graph_order) {
        default:
        case 0:
            new_order = param1 ? 5 : 2;
            break;
        case 1:
            new_order = param1 ? 3 : 4;
            break;
        case 2:
            new_order = param1 ? 4 : 0;
            break;
        case 3:
            new_order = param1 ? 1 : 5;
            break;
        case 4:
            new_order = param1 ? 2 : 1;
            break;
        case 5:
            new_order = param1 ? 0 : 3;
            break;
    }
    city_data.population.graph_order = new_order;
    window_invalidate();
}

static struct generic_button_t graph_buttons[] = {
    {509,  61, 104, 55, button_graph, button_none, 0, 0},
    {509, 161, 104, 55, button_graph, button_none, 1, 0},
};

static void get_y_axis(int max_value, int *y_max, int *y_shift)
{
    int max = 1;
    int shift = -1;
    int value = max_value > 0 ? (max_value - 1) / 100 : 0;
    while (value) {
        max <<= 1;
        shift++;
        value >>= 1;
    }
    *y_max = max * 100;
    *y_shift = shift;
}

static int city_population_at_month(int max_months, int month)
{
    int start_offset = 0;
    if (city_data.population.monthly.count > max_months) {
        start_offset = city_data.population.monthly.count + 2400 - max_months;
    }
    int index = (start_offset + month) % 2400;
    return city_data.population.monthly.values[index];
}

static void draw_history_graph(int full_size, int x, int y)
{
    int max_months;
    if (city_data.population.monthly.count <= 20) {
        max_months = 20;
    } else if (city_data.population.monthly.count <= 40) {
        max_months = 40;
    } else if (city_data.population.monthly.count <= 100) {
        max_months = 100;
    } else if (city_data.population.monthly.count <= 200) {
        max_months = 200;
    } else {
        max_months = 400;
    }
    if (!full_size) {
        if (max_months <= 40) {
            max_months = 20;
        } else {
            max_months = 100;
        }
    }
    // determine max value
    int max_value = 0;
    for (int m = 0; m < max_months; m++) {
        int value = city_population_at_month(max_months, m);
        if (value > max_value) {
            max_value = value;
        }
    }
    int y_max, y_shift;
    get_y_axis(max_value, &y_max, &y_shift);
    if (full_size) {
        // y axis
        text_draw_number_centered(y_max, x - 66, y - 3, 60, FONT_SMALL_PLAIN);
        text_draw_number_centered(y_max / 2, x - 66, y + 96, 60, FONT_SMALL_PLAIN);
        text_draw_number_centered(0, x - 66, y + 196, 60, FONT_SMALL_PLAIN);
        // x axis
        int start_month, start_year, end_month, end_year;
        if (city_data.population.monthly.count > max_months) {
            end_month = time_data.month - 1;
            end_year = time_data.year;
            if (end_month < 0) {
                end_year -= 1;
            }
            start_month = 11 - (max_months % 12);
            start_year = end_year - max_months / 12;
        } else {
            start_month = 0;
            start_year = scenario.start_year;
            end_month = (max_months + start_month) % 12;
            end_year = (max_months + start_month) / 12 + start_year;
        }

        int width = lang_text_draw(25, start_month, x - 20, y + 210, FONT_SMALL_PLAIN);
        lang_text_draw_year(start_year, x + width - 20, y + 210, FONT_SMALL_PLAIN);

        width = lang_text_draw(25, end_month, x + 380, y + 210, FONT_SMALL_PLAIN);
        lang_text_draw_year(end_year, x + width + 380, y + 210, FONT_SMALL_PLAIN);
    }

    if (full_size) {
        graphics_set_clip_rectangle(0, 0, 640, y + 200);
        for (int m = 0; m < max_months; m++) {
            int pop = city_population_at_month(max_months, m);
            int val;
            if (y_shift == -1) {
                val = 2 * pop;
            } else {
                val = pop >> y_shift;
            }
            if (val > 0) {
                switch (max_months) {
                    case 20:
                        image_draw(image_data_s.group_image_ids[GROUP_POPULATION_GRAPH_BAR], x + 20 * m, y + 200 - val);
                        break;
                    case 40:
                        image_draw(image_data_s.group_image_ids[GROUP_POPULATION_GRAPH_BAR] + 1, x + 10 * m, y + 200 - val);
                        break;
                    case 100:
                        image_draw(image_data_s.group_image_ids[GROUP_POPULATION_GRAPH_BAR] + 2, x + 4 * m, y + 200 - val);
                        break;
                    case 200:
                        image_draw(image_data_s.group_image_ids[GROUP_POPULATION_GRAPH_BAR] + 3, x + 2 * m, y + 200 - val);
                        break;
                    default:
                        graphics_draw_vertical_line(x + m, y + 200 - val, y + 199, COLOR_RED);
                        break;
                }
            }
        }
        graphics_reset_clip_rectangle();
    } else {
        y_shift += 2;
        for (int m = 0; m < max_months; m++) {
            int val = city_population_at_month(max_months, m) >> y_shift;
            if (val > 0) {
                if (max_months == 20) {
                    graphics_fill_rect(x + m, y + 50 - val, 4, val + 1, COLOR_RED);
                } else {
                    graphics_draw_vertical_line(x + m, y + 50 - val, y + 50, COLOR_RED);
                }
            }
        }
    }
}

static void draw_census_graph(int full_size, int x, int y)
{
    int max_value = 0;
    for (int i = 0; i < 100; i++) {
        if (city_data.population.at_age[i] > max_value) {
            max_value = city_data.population.at_age[i];
        }
    }
    int y_max, y_shift;
    get_y_axis(max_value, &y_max, &y_shift);
    if (full_size) {
        // y axis
        text_draw_number_centered(y_max, x - 66, y - 3, 60, FONT_SMALL_PLAIN);
        text_draw_number_centered(y_max / 2, x - 66, y + 96, 60, FONT_SMALL_PLAIN);
        text_draw_number_centered(0, x - 66, y + 196, 60, FONT_SMALL_PLAIN);
        // x axis
        for (int i = 0; i <= 10; i++) {
            text_draw_number_centered(i * 10, x + 40 * i - 22, y + 210, 40, FONT_SMALL_PLAIN);
        }
    }

    if (full_size) {
        graphics_set_clip_rectangle(0, 0, 640, y + 200);
        for (int i = 0; i < 100; i++) {
            int val;
            if (y_shift == -1) {
                val = 2 * city_data.population.at_age[i];
            } else {
                val = city_data.population.at_age[i] >> y_shift;
            }
            if (val > 0) {
                image_draw(image_data_s.group_image_ids[GROUP_POPULATION_GRAPH_BAR] + 2, x + 4 * i, y + 200 - val);
            }
        }
        graphics_reset_clip_rectangle();
    } else {
        y_shift += 2;
        for (int i = 0; i < 100; i++) {
            int val = city_data.population.at_age[i] >> y_shift;
            if (val > 0) {
                graphics_draw_vertical_line(x + i, y + 50 - val, y + 50, COLOR_RED);
            }
        }
    }
}

static void draw_society_graph(int full_size, int x, int y)
{
    int max_value = 0;
    for (int i = 0; i < 20; i++) {
        if (city_data.population.at_level[i] > max_value) {
            max_value = city_data.population.at_level[i];
        }
    }
    int y_max, y_shift;
    get_y_axis(max_value, &y_max, &y_shift);
    if (full_size) {
        // y axis
        text_draw_number_centered(y_max, x - 66, y - 3, 60, FONT_SMALL_PLAIN);
        text_draw_number_centered(y_max / 2, x - 66, y + 96, 60, FONT_SMALL_PLAIN);
        text_draw_number_centered(0, x - 66, y + 196, 60, FONT_SMALL_PLAIN);
        // x axis
        lang_text_draw_centered(55, 9, x - 80, y + 210, 200, FONT_SMALL_PLAIN);
        lang_text_draw_centered(55, 10, x + 280, y + 210, 200, FONT_SMALL_PLAIN);
    }

    if (full_size) {
        graphics_set_clip_rectangle(0, 0, 640, y + 200);
        for (int i = 0; i < 20; i++) {
            int val;
            if (y_shift == -1) {
                val = 2 * city_data.population.at_level[i];
            } else {
                val = city_data.population.at_level[i] >> y_shift;
            }
            if (val > 0) {
                image_draw(image_data_s.group_image_ids[GROUP_POPULATION_GRAPH_BAR], x + 20 * i, y + 200 - val);
            }
        }
        graphics_reset_clip_rectangle();
    } else {
        y_shift += 2;
        for (int i = 0; i < 20; i++) {
            int val = city_data.population.at_level[i] >> y_shift;
            if (val > 0) {
                graphics_fill_rect(x + 5 * i, y + 50 - val, 4, val + 1, COLOR_RED);
            }
        }
    }
}

static int draw_background_population_advisor(void)
{
    outer_panel_draw(0, 0, 40, POPULATION_ADVISOR_HEIGHT);
    image_draw(image_data_s.group_image_ids[GROUP_ADVISOR_ICONS] + 5, 10, 10);

    // Title: depends on big graph shown
    if (city_data.population.graph_order < 2) {
        lang_text_draw(55, 0, 60, 12, FONT_LARGE_BLACK);
    } else if (city_data.population.graph_order < 4) {
        lang_text_draw(55, 1, 60, 12, FONT_LARGE_BLACK);
    } else {
        lang_text_draw(55, 2, 60, 12, FONT_LARGE_BLACK);
    }
    image_draw(image_data_s.group_image_ids[GROUP_PANEL_WINDOWS] + 14, 62, 60);
    int big_text, top_text, bot_text;
    void (*big_graph)(int, int, int);
    void (*top_graph)(int, int, int);
    void (*bot_graph)(int, int, int);
    switch (city_data.population.graph_order) {
        default:
        case 0:
            big_text = 6;
            top_text = 4;
            bot_text = 5;
            big_graph = draw_history_graph;
            top_graph = draw_census_graph;
            bot_graph = draw_society_graph;
            break;
        case 1:
            big_text = 6;
            top_text = 5;
            bot_text = 4;
            big_graph = draw_history_graph;
            top_graph = draw_society_graph;
            bot_graph = draw_census_graph;
            break;
        case 2:
            big_text = 7;
            top_text = 3;
            bot_text = 5;
            big_graph = draw_census_graph;
            top_graph = draw_history_graph;
            bot_graph = draw_society_graph;
            break;
        case 3:
            big_text = 7;
            top_text = 5;
            bot_text = 3;
            big_graph = draw_census_graph;
            top_graph = draw_society_graph;
            bot_graph = draw_history_graph;
            break;
        case 4:
            big_text = 8;
            top_text = 3;
            bot_text = 4;
            big_graph = draw_society_graph;
            top_graph = draw_history_graph;
            bot_graph = draw_census_graph;
            break;
        case 5:
            big_text = 8;
            top_text = 4;
            bot_text = 3;
            big_graph = draw_society_graph;
            top_graph = draw_census_graph;
            bot_graph = draw_history_graph;
            break;
    }
    lang_text_draw_centered(55, big_text, 60, 295, 400, FONT_NORMAL_BLACK);
    lang_text_draw_centered(55, top_text, 504, 120, 100, FONT_NORMAL_BLACK);
    lang_text_draw_centered(55, bot_text, 504, 220, 100, FONT_NORMAL_BLACK);
    big_graph(1, 70, 64);
    top_graph(0, 511, 63);
    bot_graph(0, 511, 163);
    // food/migration info panel
    inner_panel_draw(48, 336, 34, 5);
    int image_id = image_data_s.group_image_ids[GROUP_BULLET];
    int width;
    image_draw(image_id, 56, 344);
    image_draw(image_id, 56, 362);
    image_draw(image_id, 56, 380);
    image_draw(image_id, 56, 398);
    // food stores
    if (scenario.rome_supplies_wheat) {
        lang_text_draw(55, 11, 75, 342, FONT_NORMAL_WHITE);
    } else {
        width = lang_text_draw_amount(8, 6, city_data.resource.granaries.operating, 75, 342, FONT_NORMAL_WHITE);
        if (city_data.resource.food_supply_months > 0) {
            width += lang_text_draw(55, 12, 75 + width, 342, FONT_NORMAL_WHITE);
            lang_text_draw_amount(8, 4, city_data.resource.food_supply_months, 75 + width, 342, FONT_NORMAL_WHITE);
        } else if (city_data.resource.granary_total_stored > city_data.resource.food_needed_per_month / 2) {
            lang_text_draw(55, 13, 75 + width, 342, FONT_NORMAL_WHITE);
        } else if (city_data.resource.granary_total_stored > 0) {
            lang_text_draw(55, 15, 75 + width, 342, FONT_NORMAL_WHITE);
        } else {
            lang_text_draw(55, 14, 75 + width, 342, FONT_NORMAL_WHITE);
        }
    }
    // food types eaten
    width = lang_text_draw(55, 16, 75, 360, FONT_NORMAL_WHITE);
    text_draw_number(city_data.resource.food_types_available, '@', " ", 75 + width, 360, FONT_NORMAL_WHITE);
    // immigration
    if (city_data.migration.newcomers >= 5) {
        lang_text_draw(55, 24, 75, 378, FONT_NORMAL_WHITE);
        width = text_draw_number(city_data.migration.newcomers, '@', " ", 75, 396, FONT_NORMAL_WHITE);
        lang_text_draw(55, 17, 75 + width, 396, FONT_NORMAL_WHITE);
    } else if (city_migration_no_room_for_immigrants()) {
        lang_text_draw(55, 24, 75, 378, FONT_NORMAL_WHITE);
        lang_text_draw(55, 19, 75, 396, FONT_NORMAL_WHITE);
    } else if (city_data.migration.percentage < 80) {
        lang_text_draw(55, 25, 75, 378, FONT_NORMAL_WHITE);
        int text_id;
        switch (city_data.migration.no_immigration_cause) {
            case NO_IMMIGRATION_LOW_WAGES: text_id = 20; break;
            case NO_IMMIGRATION_NO_JOBS: text_id = 21; break;
            case NO_IMMIGRATION_NO_FOOD: text_id = 22; break;
            case NO_IMMIGRATION_HIGH_TAXES: text_id = 23; break;
            case NO_IMMIGRATION_MANY_TENTS: text_id = 31; break;
            case NO_IMMIGRATION_LOW_MOOD: text_id = 32; break;
            default: text_id = 0; break;
        }
        if (text_id) {
            lang_text_draw(55, text_id, 75, 396, FONT_NORMAL_WHITE);
        }
    } else {
        lang_text_draw(55, 24, 75, 378, FONT_NORMAL_WHITE);
        width = text_draw_number(city_data.migration.newcomers, '@', " ", 75, 396, FONT_NORMAL_WHITE);
        if (city_data.migration.newcomers == 1) {
            lang_text_draw(55, 18, 75 + width, 396, FONT_NORMAL_WHITE);
        } else {
            lang_text_draw(55, 17, 75 + width, 396, FONT_NORMAL_WHITE);
        }
    }
    return POPULATION_ADVISOR_HEIGHT;
}

static void draw_foreground_population_advisor(void)
{
    if (focus_button_id_population_advisor == 0) {
        button_border_draw(507, 60, 106, 57, 0);
        button_border_draw(507, 160, 106, 57, 0);
    } else if (focus_button_id_population_advisor == 1) {
        button_border_draw(507, 60, 106, 57, 1);
        button_border_draw(507, 160, 106, 57, 0);
    } else if (focus_button_id_population_advisor == 2) {
        button_border_draw(507, 60, 106, 57, 0);
        button_border_draw(507, 160, 106, 57, 1);
    }
}

static int handle_mouse_population_advisor(struct mouse_t *m)
{
    return generic_buttons_handle_mouse(m, 0, 0, graph_buttons, 2, &focus_button_id_population_advisor);
}

static struct advisor_window_type_t *window_advisor_population(void)
{
    static struct advisor_window_type_t window = {
        draw_background_population_advisor,
        draw_foreground_population_advisor,
        handle_mouse_population_advisor,
    };
    return &window;
}

static void draw_god_row(int god, int y_offset, int small_temple, int large_temple)
{
    lang_text_draw(59, 11 + god, 40, y_offset, FONT_NORMAL_WHITE);
    lang_text_draw(59, 16 + god, 120, y_offset + 1, FONT_SMALL_PLAIN);
    text_draw_number_centered(count_data.buildings[small_temple].total, 230, y_offset, 50, FONT_NORMAL_WHITE);
    text_draw_number_centered(count_data.buildings[large_temple].total, 290, y_offset, 50, FONT_NORMAL_WHITE);
    text_draw_number_centered(city_data.religion.gods[god].months_since_festival, 360, y_offset, 50, FONT_NORMAL_WHITE);
    int width = lang_text_draw(59, 32 + city_data.religion.gods[god].happiness / 10, 460, y_offset, FONT_NORMAL_WHITE);
    int bolts = city_data.religion.gods[god].wrath_bolts;
    for (int i = 0; i < bolts / 10; i++) {
        image_draw(image_data_s.group_image_ids[GROUP_GOD_BOLT], 10 * i + width + 460, y_offset - 4);
    }
}

static int draw_background_religion_advisor(void)
{
    int height_blocks;
    height_blocks = 17;
    outer_panel_draw(0, 0, 40, height_blocks);
    image_draw(image_data_s.group_image_ids[GROUP_ADVISOR_ICONS] + 9, 10, 10);
    lang_text_draw(59, 0, 60, 12, FONT_LARGE_BLACK);
    // table header
    lang_text_draw(59, 5, 270, 32, FONT_SMALL_PLAIN);
    lang_text_draw(59, 1, 240, 46, FONT_SMALL_PLAIN);
    lang_text_draw(59, 2, 300, 46, FONT_SMALL_PLAIN);
    lang_text_draw(59, 3, 450, 46, FONT_SMALL_PLAIN);
    lang_text_draw(59, 6, 370, 18, FONT_SMALL_PLAIN);
    lang_text_draw(59, 9, 370, 32, FONT_SMALL_PLAIN);
    lang_text_draw(59, 7, 370, 46, FONT_SMALL_PLAIN);
    inner_panel_draw(32, 60, 36, 8);
    // god rows
    draw_god_row(GOD_CERES, 66, BUILDING_SMALL_TEMPLE_CERES, BUILDING_LARGE_TEMPLE_CERES);
    draw_god_row(GOD_NEPTUNE, 86, BUILDING_SMALL_TEMPLE_NEPTUNE, BUILDING_LARGE_TEMPLE_NEPTUNE);
    draw_god_row(GOD_MERCURY, 106, BUILDING_SMALL_TEMPLE_MERCURY, BUILDING_LARGE_TEMPLE_MERCURY);
    draw_god_row(GOD_MARS, 126, BUILDING_SMALL_TEMPLE_MARS, BUILDING_LARGE_TEMPLE_MARS);
    draw_god_row(GOD_VENUS, 146, BUILDING_SMALL_TEMPLE_VENUS, BUILDING_LARGE_TEMPLE_VENUS);
    // oracles
    lang_text_draw(59, 8, 40, 166, FONT_NORMAL_WHITE);
    text_draw_number_centered(count_data.buildings[BUILDING_ORACLE].total, 230, 166, 50, FONT_NORMAL_WHITE);
    city_gods_calculate_least_happy();
    struct house_demands_t *demands = &city_data.houses;
    int religion_advice = 5;
    if (city_data.religion.least_happy_god - 1 >= 0 && city_data.religion.gods[city_data.religion.least_happy_god - 1].wrath_bolts > 4) {
        religion_advice = 6 + city_data.religion.least_happy_god - 1;
    } else if (demands->religion == 1) {
        religion_advice = demands->requiring.religion ? 1 : 0;
    } else if (demands->religion == 2) {
        religion_advice = 2;
    } else if (demands->religion == 3) {
        religion_advice = 3;
    } else if (!demands->requiring.religion) {
        religion_advice = 4;
    } else if (city_data.religion.least_happy_god - 1 >= 0) {
        religion_advice = 6 + city_data.religion.least_happy_god - 1;
    }
    lang_text_draw_multiline(59, 21 + religion_advice, 60, 196, 512, FONT_NORMAL_BLACK);
    return height_blocks;
}

static struct advisor_window_type_t *window_advisor_religion(void)
{
    static struct advisor_window_type_t window = {
        draw_background_religion_advisor,
        0,
        0,
    };
    return &window;
}

static struct advisor_window_type_t *(*sub_advisors[])(void) = {
    0,
    window_advisor_labor,
    window_advisor_military,
    window_advisor_imperial,
    window_advisor_ratings,
    window_advisor_trade,
    window_advisor_population,
    window_advisor_health,
    window_advisor_education,
    window_advisor_entertainment,
    window_advisor_religion,
    window_advisor_financial,
    window_advisor_chief
};

static void set_advisor(int advisor)
{
    current_advisor = advisor;
    settings_values[SETTINGS_LAST_ADVISOR] = advisor;
    if (sub_advisors[current_advisor]) {
        current_advisor_window = sub_advisors[current_advisor]();
    } else {
        current_advisor_window = 0;
    }
}

static int cap_input_at_100(int input)
{
    return input > 100 ? 100 : input;
}

static int get_people_aged_between(int min, int max)
{
    int pop = 0;
    for (int i = min; i < max; i++) {
        pop += city_data.population.at_age[i];
    }
    return pop;
}

static void city_culture_update_coverage(void)
{
    int population = city_data.population.population;
    // entertainment
    culture_coverage.theater = cap_input_at_100(calc_percentage(500 * count_data.buildings[BUILDING_THEATER].active, population));
    culture_coverage.amphitheater = cap_input_at_100(calc_percentage(800 * count_data.buildings[BUILDING_AMPHITHEATER].active, population));
    culture_coverage.colosseum = cap_input_at_100(calc_percentage(1500 * count_data.buildings[BUILDING_COLOSSEUM].active, population));
    if (!count_data.buildings[BUILDING_HIPPODROME].active) {
        culture_coverage.hippodrome = 0;
    } else {
        culture_coverage.hippodrome = 100;
    }
    // religion
    int oracles = count_data.buildings[BUILDING_ORACLE].total;
    culture_coverage.religion[GOD_CERES] = cap_input_at_100(calc_percentage(
        500 * oracles +
        750 * count_data.buildings[BUILDING_SMALL_TEMPLE_CERES].active +
        1500 * count_data.buildings[BUILDING_LARGE_TEMPLE_CERES].active,
        population));
    culture_coverage.religion[GOD_NEPTUNE] = cap_input_at_100(calc_percentage(
        500 * oracles +
        750 * count_data.buildings[BUILDING_SMALL_TEMPLE_NEPTUNE].active +
        1500 * count_data.buildings[BUILDING_LARGE_TEMPLE_NEPTUNE].active,
        population));
    culture_coverage.religion[GOD_MERCURY] = cap_input_at_100(calc_percentage(
        500 * oracles +
        750 * count_data.buildings[BUILDING_SMALL_TEMPLE_MERCURY].active +
        1500 * count_data.buildings[BUILDING_LARGE_TEMPLE_MERCURY].active,
        population));
    culture_coverage.religion[GOD_MARS] = cap_input_at_100(calc_percentage(
        500 * oracles +
        750 * count_data.buildings[BUILDING_SMALL_TEMPLE_MARS].active +
        1500 * count_data.buildings[BUILDING_LARGE_TEMPLE_MARS].active,
        population));
    culture_coverage.religion[GOD_VENUS] = cap_input_at_100(calc_percentage(
        500 * oracles +
        750 * count_data.buildings[BUILDING_SMALL_TEMPLE_VENUS].active +
        1500 * count_data.buildings[BUILDING_LARGE_TEMPLE_VENUS].active,
        population));
    culture_coverage.oracle = cap_input_at_100(calc_percentage(500 * oracles, population));
    city_data.culture.religion_coverage =
        culture_coverage.religion[GOD_CERES] +
        culture_coverage.religion[GOD_NEPTUNE] +
        culture_coverage.religion[GOD_MERCURY] +
        culture_coverage.religion[GOD_MARS] +
        culture_coverage.religion[GOD_VENUS];
    city_data.culture.religion_coverage /= 5;
    // education
    city_data.population.school_age = get_people_aged_between(0, 14);
    city_data.population.academy_age = get_people_aged_between(14, 21);
    culture_coverage.school = cap_input_at_100(calc_percentage(
        75 * count_data.buildings[BUILDING_SCHOOL].active, city_data.population.school_age));
    culture_coverage.library = cap_input_at_100(calc_percentage(
        800 * count_data.buildings[BUILDING_LIBRARY].active, population));
    culture_coverage.academy = cap_input_at_100(calc_percentage(
        100 * count_data.buildings[BUILDING_ACADEMY].active, city_data.population.academy_age));
    // health
    culture_coverage.hospital = cap_input_at_100(calc_percentage(
        1000 * count_data.buildings[BUILDING_HOSPITAL].active, population));
}

static void calculate_available_food(void)
{
    for (int i = 0; i < FOOD_TYPES_MAX; i++) {
        city_data.resource.granary_food_stored[i] = 0;
    }
    city_data.resource.granary_total_stored = 0;
    city_data.resource.food_types_available = 0;
    city_data.resource.food_supply_months = 0;
    city_data.resource.granaries.operating = 0;
    city_data.resource.granaries.understaffed = 0;
    city_data.resource.granaries.not_operating = 0;
    city_data.resource.granaries.not_operating_with_food = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_GRANARY) {
            continue;
        }
        b->has_road_access = 0;
        if (map_has_road_access_granary(b->x, b->y, 0)) {
            b->has_road_access = 1;
            int pct_workers = calc_percentage(
                b->num_workers, building_properties[b->type].n_laborers);
            if (pct_workers < 100) {
                city_data.resource.granaries.understaffed++;
            }
            int amount_stored = 0;
            for (int r = RESOURCE_WHEAT; r < FOOD_TYPES_MAX; r++) {
                amount_stored += b->data.granary.resource_stored[r];
            }
            if (pct_workers < 50) {
                city_data.resource.granaries.not_operating++;
                if (amount_stored > 0) {
                    city_data.resource.granaries.not_operating_with_food++;
                }
            } else {
                city_data.resource.granaries.operating++;
                for (int r = 0; r < FOOD_TYPES_MAX; r++) {
                    city_data.resource.granary_food_stored[r] += b->data.granary.resource_stored[r];
                }
            }
        }
    }
    for (int i = RESOURCE_WHEAT; i < FOOD_TYPES_MAX; i++) {
        if (city_data.resource.granary_food_stored[i]) {
            city_data.resource.granary_total_stored += city_data.resource.granary_food_stored[i];
            city_data.resource.food_types_available++;
        }
    }
    city_data.resource.food_needed_per_month =
        calc_adjust_with_percentage(city_data.population.population, 50);
    if (city_data.resource.food_needed_per_month > 0) {
        city_data.resource.food_supply_months =
            city_data.resource.granary_total_stored / city_data.resource.food_needed_per_month;
    } else {
        city_data.resource.food_supply_months =
            city_data.resource.granary_total_stored > 0 ? 1 : 0;
    }
    if (scenario.rome_supplies_wheat) {
        city_data.resource.food_types_available = 1;
        city_data.resource.food_supply_months = 12;
    }
}

static void city_resource_calculate_food_stocks_and_supply_wheat(void)
{
    calculate_available_food();
    if (scenario.rome_supplies_wheat) {
        for (int i = 1; i < MAX_BUILDINGS; i++) {
            struct building_t *b = &all_buildings[i];
            if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_MARKET) {
                b->data.market.inventory[INVENTORY_WHEAT] = 200;
            }
        }
    }
}

static void update_culture_explanation(void)
{
    int min_percentage = 100;
    int reason = 1;
    if (city_data.culture.religion_coverage < min_percentage) {
        min_percentage = city_data.culture.religion_coverage;
        reason = 4;
    }
    if (culture_coverage.theater < min_percentage) {
        min_percentage = culture_coverage.theater;
        reason = 5;
    }
    if (culture_coverage.library < min_percentage) {
        min_percentage = culture_coverage.library;
        reason = 2;
    }
    if (culture_coverage.school < min_percentage) {
        min_percentage = culture_coverage.school;
        reason = 1;
    }
    int pct_academy = culture_coverage.academy;
    if (pct_academy < min_percentage) {
        reason = 3;
    }
    city_data.ratings.culture_explanation = reason;
}

static int has_made_money(void)
{
    return city_data.finance.last_year.expenses.construction + city_data.finance.treasury >
        city_data.ratings.prosperity_treasury_last_year;
}

static void update_prosperity_explanation(void)
{
    int change = 0;
    int profit = 0;
    // unemployment: -1 for too high, +1 for low
    if (city_data.labor.unemployment_percentage < 5) {
        change += 1;
    } else if (city_data.labor.unemployment_percentage >= 15) {
        change -= 1;
    }
    // losing/earning money: -1 for losing, +5 for profit
    if (has_made_money()) {
        change += 5;
        profit = 1;
    } else {
        change -= 1;
    }
    // food types: +1 for multiple foods
    if (city_data.resource.food_types_eaten >= 2) {
        change += 1;
    }
    // wages: +1 for wages 2+ above Rome, -1 for wages below Rome
    int avg_wage = city_data.finance.wage_rate_paid_last_year / 12;
    if (avg_wage >= city_data.labor.wages_rome + 2) {
        change += 1;
    } else if (avg_wage < city_data.labor.wages_rome) {
        change -= 1;
    }
    // high percentage poor: -1, high percentage rich: +1
    int pct_tents = calc_percentage(city_data.population.people_in_tents_shacks, city_data.population.population);
    if (pct_tents > 30) {
        change -= 1;
    }
    if (calc_percentage(city_data.population.people_in_villas_palaces, city_data.population.population) > 10) {
        change += 1;
    }
    // tribute not paid: -1
    if (city_data.finance.tribute_not_paid_last_year) {
        change -= 1;
    }
    // working hippodrome: +1
    if (city_data.entertainment.hippodrome_shows > 0) {
        change += 1;
    }
    int reason;
    if (city_data.ratings.prosperity <= 0 && time_data.year == scenario.start_year) {
        reason = 0;
    } else if (city_data.ratings.prosperity >= city_data.ratings.prosperity_max) {
        reason = 1;
    } else if (change > 0) {
        reason = 2;
    } else if (!profit) {
        reason = 3;
    } else if (city_data.labor.unemployment_percentage >= 15) {
        reason = 4;
    } else if (avg_wage < city_data.labor.wages_rome) {
        reason = 5;
    } else if (pct_tents > 30) {
        reason = 6;
    } else if (city_data.finance.tribute_not_paid_last_year) {
        reason = 7;
    } else {
        reason = 9;
    }
    // 8 = for bailout
    city_data.ratings.prosperity_explanation = reason;
}

static void update_peace_explanation(void)
{
    int reason;
    if (city_data.figure.imperial_soldiers) {
        reason = 8; // FIXED: 7+8 interchanged
    } else if (city_data.figure.enemies) {
        reason = 7;
    } else if (city_data.figure.rioters) {
        reason = 6;
    } else {
        if (city_data.ratings.peace < 10) {
            reason = 0;
        } else if (city_data.ratings.peace < 30) {
            reason = 1;
        } else if (city_data.ratings.peace < 60) {
            reason = 2;
        } else if (city_data.ratings.peace < 90) {
            reason = 3;
        } else if (city_data.ratings.peace < 100) {
            reason = 4;
        } else { // >= 100
            reason = 5;
        }
    }
    city_data.ratings.peace_explanation = reason;
}

static void handle_input_advisors(struct mouse_t *m, struct hotkeys_t *h);
static void window_advisors_show(int advisor)
{
    struct window_type_t window = {
        WINDOW_ADVISORS,
        draw_background_advisors,
        draw_foreground_advisors,
        handle_input_advisors,
    };
    if (advisor) {
        set_advisor(advisor);
    } else {
        set_advisor(ADVISOR_CHIEF);
    }
    city_labor_allocate_workers();
    city_finance_estimate_taxes();
    city_finance_estimate_wages();
    city_data.finance.this_year.expenses.interest = city_data.finance.interest_so_far;
    city_data.finance.this_year.expenses.salary = city_data.finance.salary_so_far;
    city_finance_calculate_totals();
    switch (city_data.sentiment.low_mood_cause) {
        case LOW_MOOD_CAUSE_NO_FOOD:
            city_data.migration.no_immigration_cause = 2;
            break;
        case LOW_MOOD_CAUSE_NO_JOBS:
            city_data.migration.no_immigration_cause = 1;
            break;
        case LOW_MOOD_CAUSE_HIGH_TAXES:
            city_data.migration.no_immigration_cause = 3;
            break;
        case LOW_MOOD_CAUSE_LOW_WAGES:
            city_data.migration.no_immigration_cause = 0;
            break;
        case LOW_MOOD_CAUSE_MANY_TENTS:
            city_data.migration.no_immigration_cause = 4;
            break;
        default:
            city_data.migration.no_immigration_cause = 5;
            break;
    }
    // health
    city_data.houses.health = 0;
    int max = 0;
    if (city_data.houses.missing.bathhouse > max) {
        city_data.houses.health = 1;
        max = city_data.houses.missing.bathhouse;
    }
    if (city_data.houses.missing.barber > max) {
        city_data.houses.health = 2;
        max = city_data.houses.missing.barber;
    }
    if (city_data.houses.missing.clinic > max) {
        city_data.houses.health = 3;
        max = city_data.houses.missing.clinic;
    }
    if (city_data.houses.missing.hospital > max) {
        city_data.houses.health = 4;
    }
    // education
    city_data.houses.education = 0;
    if (city_data.houses.missing.more_education > city_data.houses.missing.education) {
        city_data.houses.education = 1; // schools(academies?)
    } else if (city_data.houses.missing.more_education < city_data.houses.missing.education) {
        city_data.houses.education = 2; // libraries
    } else if (city_data.houses.missing.more_education || city_data.houses.missing.education) {
        city_data.houses.education = 3; // more education
    }
    // entertainment
    city_data.houses.entertainment = 0;
    if (city_data.houses.missing.entertainment > city_data.houses.missing.more_entertainment) {
        city_data.houses.entertainment = 1;
    } else if (city_data.houses.missing.more_entertainment) {
        city_data.houses.entertainment = 2;
    }
    // religion
    city_data.houses.religion = 0;
    max = 0;
    if (city_data.houses.missing.religion > max) {
        city_data.houses.religion = 1;
        max = city_data.houses.missing.religion;
    }
    if (city_data.houses.missing.second_religion > max) {
        city_data.houses.religion = 2;
        max = city_data.houses.missing.second_religion;
    }
    if (city_data.houses.missing.third_religion > max) {
        city_data.houses.religion = 3;
    }
    city_culture_update_coverage();
    city_resource_calculate_food_stocks_and_supply_wheat();
    update_culture_explanation();
    update_prosperity_explanation();
    update_peace_explanation();
    city_ratings_update_favor_explanation();
    window_show(&window);
}

static void button_advisor_message_dialog(int advisor, __attribute__((unused)) int param2)
{
    cleanup_message_dialog();
    window_advisors_show(advisor);
}

static struct image_button_t image_button_labor = {
    0, 0, 27, 27, IB_NORMAL, GROUP_MESSAGE_ADVISOR_BUTTONS, 0, button_advisor_message_dialog, button_none, ADVISOR_LABOR, 0, 1, 0, 0, 0 };
static struct image_button_t image_button_trade = {
    0, 0, 27, 27, IB_NORMAL, GROUP_MESSAGE_ADVISOR_BUTTONS, 12, button_advisor_message_dialog, button_none, ADVISOR_TRADE, 0, 1, 0, 0, 0 };
static struct image_button_t image_button_population = {
    0, 0, 27, 27, IB_NORMAL, GROUP_MESSAGE_ADVISOR_BUTTONS, 15, button_advisor_message_dialog, button_none, ADVISOR_POPULATION, 0, 1, 0, 0, 0 };
static struct image_button_t image_button_imperial = {
    0, 0, 27, 27, IB_NORMAL, GROUP_MESSAGE_ADVISOR_BUTTONS, 6, button_advisor_message_dialog, button_none, ADVISOR_IMPERIAL, 0, 1, 0, 0, 0 };
static struct image_button_t image_button_military = {
    0, 0, 27, 27, IB_NORMAL, GROUP_MESSAGE_ADVISOR_BUTTONS, 3, button_advisor_message_dialog, button_none, ADVISOR_MILITARY, 0, 1, 0, 0, 0 };
static struct image_button_t image_button_health = {
    0, 0, 27, 27, IB_NORMAL, GROUP_MESSAGE_ADVISOR_BUTTONS, 18, button_advisor_message_dialog, button_none, ADVISOR_HEALTH, 0, 1, 0, 0, 0 };
static struct image_button_t image_button_religion = {
    0, 0, 27, 27, IB_NORMAL, GROUP_MESSAGE_ADVISOR_BUTTONS, 27, button_advisor_message_dialog, button_none, ADVISOR_RELIGION, 0, 1, 0, 0, 0 };

static void button_close_message_dialog(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    cleanup_message_dialog();
    window_go_back();
    window_invalidate();
}

static void button_help_message_dialog(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    button_close_message_dialog(0, 0);
    window_message_dialog_show(MESSAGE_DIALOG_HELP, message_dialog_data.background_callback);
}

static void button_go_to_problem_message_dialog(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    cleanup_message_dialog();
    int grid_offset = player_message.param2;
    if (grid_offset > 0 && grid_offset < 26244) {
        city_view_go_to_grid_offset(grid_offset);
    }
    window_city_show();
}

static void rich_text_reset(int scroll_position)
{
    scrollbar_reset(&scrollbar, scroll_position);
    rich_text_data.num_lines = 0;
    rich_text_clear_links();
}

static void button_back_message_dialog(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    if (message_dialog_data.num_history > 0) {
        message_dialog_data.num_history--;
        message_dialog_data.text_id = message_dialog_data.history[message_dialog_data.num_history].text_id;
        rich_text_reset(message_dialog_data.history[message_dialog_data.num_history].scroll_position);
        window_invalidate();
    }
}

static struct image_button_t image_button_back = {
    0, 0, 31, 20, IB_NORMAL, GROUP_ARROW_MESSAGE_PROBLEMS, 8, button_back_message_dialog, button_none, 0, 0, 1, 0, 0, 0
};
static struct image_button_t image_button_close_message_dialog = {
    0, 0, 24, 24, IB_NORMAL, GROUP_CONTEXT_ICONS, 4, button_close_message_dialog, button_none, 0, 0, 1, 0, 0, 0
};
static struct image_button_t image_button_go_to_problem = {
    0, 0, 27, 27, IB_NORMAL, GROUP_SIDEBAR_BUTTONS, 52, button_go_to_problem_message_dialog, button_none, 1, 0, 1, 0, 0, 0
};
static struct image_button_t image_button_help_message_dialog = {
    0, 0, 18, 27, IB_NORMAL, GROUP_CONTEXT_ICONS, 0, button_help_message_dialog, button_none, 1, 0, 1, 0, 0, 0
};

static struct image_button_t *get_advisor_button(void)
{
    switch (player_message.message_advisor) {
        case MESSAGE_ADVISOR_LABOR:
            return &image_button_labor;
        case MESSAGE_ADVISOR_TRADE:
            return &image_button_trade;
        case MESSAGE_ADVISOR_POPULATION:
            return &image_button_population;
        case MESSAGE_ADVISOR_IMPERIAL:
            return &image_button_imperial;
        case MESSAGE_ADVISOR_MILITARY:
            return &image_button_military;
        case MESSAGE_ADVISOR_HEALTH:
            return &image_button_health;
        case MESSAGE_ADVISOR_RELIGION:
            return &image_button_religion;
        default:
            return &image_button_help_message_dialog;
    }
}

static int is_problem_message(struct lang_message_t *msg)
{
    return msg->type == TYPE_MESSAGE && (msg->message_type == MESSAGE_TYPE_DISASTER || msg->message_type == MESSAGE_TYPE_INVASION);
}

static void draw_foreground_video(void)
{
    if (get_next_frame()) {
        struct clip_info_t *clip = graphics_get_clip_info(message_dialog_data.x + 8, message_dialog_data.y + 8, data_video.video.width, data_video.video.height);
        if (clip && clip->is_visible) {
            unsigned char *frame = data_video.s->frame_data.video;
            uint32_t *pal = data_video.s->frame_data.palette;
            if (frame && pal) {
                for (int y = clip->clipped_pixels_top; y < clip->visible_pixels_y; y++) {
                    color_t *pixel = graphics_get_pixel(
                        message_dialog_data.x + 8 + clip->clipped_pixels_left, y + message_dialog_data.y + 8 + clip->clipped_pixels_top);
                    int video_y = data_video.video.y_scale == SMACKER_Y_SCALE_NONE ? y : y / 2;
                    unsigned char *line = frame + (video_y * data_video.video.width);
                    for (int x = clip->clipped_pixels_left; x < clip->visible_pixels_x; x++) {
                        *pixel = pal[line[x]];
                        ++pixel;
                    }
                }
            }
        }
    }
    image_buttons_draw(message_dialog_data.x + 16, message_dialog_data.y + 408, get_advisor_button(), 1);
    image_buttons_draw(message_dialog_data.x + 372, message_dialog_data.y + 410, &image_button_close_message_dialog, 1);
    struct lang_message_t *msg = &lang_data.message_entries[message_dialog_data.text_id];
    if (is_problem_message(msg)) {
        image_buttons_draw(message_dialog_data.x + 48, message_dialog_data.y + 407, &image_button_go_to_problem, 1);
    }
}

static int rich_text_init(char *text, int x_text, int y_text, int width_blocks, int height_blocks, int adjust_width_on_no_scroll)
{
    rich_text_data.x_text = x_text;
    rich_text_data.y_text = y_text;
    if (!rich_text_data.num_lines) {
        rich_text_data.text_height_blocks = height_blocks;
        rich_text_data.text_height_lines = (height_blocks - 1) * BLOCK_SIZE / rich_text_data.line_height;
        rich_text_data.text_width_blocks = width_blocks;

        rich_text_data.num_lines = draw_text(text,
            rich_text_data.x_text + 8, rich_text_data.y_text + 6,
            BLOCK_SIZE * rich_text_data.text_width_blocks - BLOCK_SIZE, rich_text_data.text_height_lines, 0, 1);
        scrollbar.x = rich_text_data.x_text + BLOCK_SIZE * rich_text_data.text_width_blocks - 1;
        scrollbar.y = rich_text_data.y_text;
        scrollbar.height = BLOCK_SIZE * rich_text_data.text_height_blocks;
        scrollbar_init(&scrollbar, scrollbar.scroll_position, rich_text_data.num_lines - rich_text_data.text_height_lines);
        if (rich_text_data.num_lines <= rich_text_data.text_height_lines && adjust_width_on_no_scroll) {
            rich_text_data.text_width_blocks += 2;
        }
        window_invalidate();
    }
    return rich_text_data.text_width_blocks;
}

static int resource_image(int resource)
{
    return resource_images[resource].icon_img_id + resource_image_offset(resource, RESOURCE_IMAGE_ICON);
}

static void draw_background_message_dialog(void)
{
    if (message_dialog_data.background_callback) {
        message_dialog_data.background_callback();
    } else {
        window_draw_underlying_window();
    }
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    if (message_dialog_data.show_video) {
        struct lang_message_t *msg = &lang_data.message_entries[message_dialog_data.text_id];
        message_dialog_data.x = 32;
        message_dialog_data.y = 28;
        int small_font = 0;
        int lines_available = 4;
        if (msg->type == TYPE_MESSAGE && msg->message_type == MESSAGE_TYPE_IMPERIAL) {
            lines_available = 3;
        }
        rich_text_set_fonts(FONT_NORMAL_WHITE, FONT_NORMAL_RED, 5);
        rich_text_clear_links();
        int lines_required = draw_text(msg->content.text, 0, 0, 384, lines_available, 0, 1);
        if (lines_required > lines_available) {
            small_font = 1;
            rich_text_set_fonts(FONT_SMALL_PLAIN, FONT_SMALL_PLAIN, 7);
            lines_required = draw_text(msg->content.text, 0, 0, 384, lines_available, 0, 1);
        }
        outer_panel_draw(message_dialog_data.x, message_dialog_data.y, 26, 28);
        graphics_draw_rect(message_dialog_data.x + 7, message_dialog_data.y + 7, 402, 294, COLOR_BLACK);
        int y_base = message_dialog_data.y + 308;
        int inner_height_blocks = 6;
        if (lines_required > lines_available) {
            // create space to cram an extra line into the dialog
            y_base = y_base - 8;
            inner_height_blocks += 1;
        }
        inner_panel_draw(message_dialog_data.x + 8, y_base, 25, inner_height_blocks);
        text_draw_centered(msg->title.text, message_dialog_data.x + 8, message_dialog_data.y + 414, 400, FONT_NORMAL_BLACK, 0);
        int width = lang_text_draw(25, player_message.month, message_dialog_data.x + 16, y_base + 4, FONT_NORMAL_WHITE);
        width += lang_text_draw_year(player_message.year, message_dialog_data.x + 18 + width, y_base + 4, FONT_NORMAL_WHITE);
        if (msg->type == TYPE_MESSAGE && msg->message_type == MESSAGE_TYPE_DISASTER &&
            message_dialog_data.text_id == MESSAGE_DIALOG_THEFT) {
            lang_text_draw_amount(8, 0, player_message.param1, message_dialog_data.x + 90 + width, y_base + 4, FONT_NORMAL_WHITE);
        } else {
            width += lang_text_draw(63, 5, message_dialog_data.x + 70 + width, y_base + 4, FONT_NORMAL_WHITE);
            text_draw(scenario_settings.player_name, message_dialog_data.x + 70 + width, y_base + 4, FONT_NORMAL_WHITE, 0);
        }
        message_dialog_data.text_height_blocks = msg->height_blocks - 1 - (32 + message_dialog_data.y_text - message_dialog_data.y) / BLOCK_SIZE;
        message_dialog_data.text_width_blocks = msg->width_blocks - 4;
        if (small_font) {
            // Draw in black and then white to create shadow effect
            draw_text(msg->content.text, message_dialog_data.x + 16 + 1, y_base + 24 + 1, 384, message_dialog_data.text_height_blocks - 1, COLOR_BLACK, 0);
            draw_text(msg->content.text, message_dialog_data.x + 16, y_base + 24, 384, message_dialog_data.text_height_blocks - 1, COLOR_WHITE, 0);
        } else {
            draw_text(msg->content.text, message_dialog_data.x + 16, y_base + 24, 384, message_dialog_data.text_height_blocks - 1, 0, 0);
        }
        if (msg->type == TYPE_MESSAGE && msg->message_type == MESSAGE_TYPE_IMPERIAL) {
            int y_text = message_dialog_data.y + 384;
            if (lines_required > lines_available) {
                y_text += 8;
            }
            text_draw_number(scenario.requests[player_message.param1].amount, '@', " ", message_dialog_data.x + 8, y_text, FONT_NORMAL_WHITE);
            image_draw(
                resource_images[scenario.requests[player_message.param1].resource].icon_img_id
                + resource_image_offset(scenario.requests[player_message.param1].resource, RESOURCE_IMAGE_ICON),
                message_dialog_data.x + 70, y_text - 5);
            lang_text_draw(23, scenario.requests[player_message.param1].resource, message_dialog_data.x + 100, y_text, FONT_NORMAL_WHITE);
            if (scenario.requests[player_message.param1].state == REQUEST_STATE_NORMAL || scenario.requests[player_message.param1].state == REQUEST_STATE_OVERDUE) {
                width = lang_text_draw_amount(8, 4, scenario.requests[player_message.param1].months_to_comply, message_dialog_data.x + 200, y_text, FONT_NORMAL_WHITE);
                lang_text_draw(12, 2, message_dialog_data.x + 200 + width, y_text, FONT_NORMAL_WHITE);
            }
        }
        draw_foreground_video();
    } else {
        struct lang_message_t *msg = &lang_data.message_entries[message_dialog_data.text_id];
        message_dialog_data.x = msg->x;
        message_dialog_data.y = msg->y;
        message_dialog_data.x_text = message_dialog_data.x + 16;
        outer_panel_draw(message_dialog_data.x, message_dialog_data.y, msg->width_blocks, msg->height_blocks);
        if (msg->title.text) {
            int image_id;
            if (!msg->image.id) {
                image_id = 0;
            } else if (message_dialog_data.text_id == 0) {
                // message id = 0 ==> "about": fixed image position
                image_id = image_data_s.group_image_ids[GROUP_BIG_PEOPLE];
            } else {
                image_id = image_data_s.group_image_ids[GROUP_MESSAGE_IMAGES] + msg->image.id - 1;
            }
            struct image_t *img = image_id ? image_get(image_id) : 0;
            // title
            // Center title in the dialog but ensure it does not overlap with the
            // image: if the title is too long, it will start 8px from the image.
            int title_x_offset = img ? img->width + msg->image.x + 8 : 0;
            text_draw_centered(msg->title.text, message_dialog_data.x + title_x_offset, message_dialog_data.y + 14,
                BLOCK_SIZE * msg->width_blocks - 2 * title_x_offset, FONT_LARGE_BLACK, 0);

            message_dialog_data.y_text = message_dialog_data.y + 48;
            // picture
            if (img) {
                int image_x = msg->image.x;
                int image_y = msg->image.y;
                image_draw(image_id, message_dialog_data.x + image_x, message_dialog_data.y + image_y);
                if (message_dialog_data.y + image_y + img->height + 8 > message_dialog_data.y_text) {
                    message_dialog_data.y_text = message_dialog_data.y + image_y + img->height + 8;
                }
            }
        }
        if (msg->subtitle.x && msg->subtitle.text) {
            int width = BLOCK_SIZE * (msg->width_blocks - 1) - msg->subtitle.x;
            int height = text_draw_multiline(msg->subtitle.text,
                message_dialog_data.x + msg->subtitle.x, message_dialog_data.y + msg->subtitle.y, width, FONT_NORMAL_BLACK, 0);
            if (message_dialog_data.y + msg->subtitle.y + height > message_dialog_data.y_text) {
                message_dialog_data.y_text = message_dialog_data.y + msg->subtitle.y + height;
            }
        }
        if (msg->content.text) {
            rich_text_set_fonts(FONT_NORMAL_WHITE, FONT_NORMAL_RED, 5);
            int header_offset = msg->type == TYPE_MANUAL ? 48 : 32;
            message_dialog_data.text_height_blocks = msg->height_blocks - 1 - (header_offset + message_dialog_data.y_text - message_dialog_data.y) / BLOCK_SIZE;
            message_dialog_data.text_width_blocks = rich_text_init(msg->content.text,
                message_dialog_data.x_text, message_dialog_data.y_text, msg->width_blocks - 4, message_dialog_data.text_height_blocks, 1);

            // content!
            inner_panel_draw(message_dialog_data.x_text, message_dialog_data.y_text, message_dialog_data.text_width_blocks, message_dialog_data.text_height_blocks);
            graphics_set_clip_rectangle(message_dialog_data.x_text + 3, message_dialog_data.y_text + 3,
                BLOCK_SIZE * message_dialog_data.text_width_blocks - 6, BLOCK_SIZE * message_dialog_data.text_height_blocks - 6);
            rich_text_clear_links();

            if (msg->type == TYPE_MESSAGE) {
                int width = lang_text_draw(25, player_message.month, message_dialog_data.x_text + 10, message_dialog_data.y_text + 6, FONT_NORMAL_WHITE);
                width += lang_text_draw_year(player_message.year, message_dialog_data.x_text + 12 + width, message_dialog_data.y_text + 6, FONT_NORMAL_WHITE);
                if (msg->message_type == MESSAGE_TYPE_DISASTER && player_message.param1) {
                    if (message_dialog_data.text_id == MESSAGE_DIALOG_THEFT) {
                        // param1 = denarii
                        lang_text_draw_amount(8, 0, player_message.param1, message_dialog_data.x + 240, message_dialog_data.y_text + 6, FONT_NORMAL_WHITE);
                    } else {
                        // param1 = building type
                        lang_text_draw(41, player_message.param1, message_dialog_data.x + 240, message_dialog_data.y_text + 6, FONT_NORMAL_WHITE);
                    }
                } else {
                    width += lang_text_draw(63, 5, message_dialog_data.x_text + width + 60, message_dialog_data.y_text + 6, FONT_NORMAL_WHITE);
                    text_draw(scenario_settings.player_name, message_dialog_data.x_text + width + 60, message_dialog_data.y_text + 6, FONT_NORMAL_WHITE, 0);
                }
                switch (msg->message_type) {
                    case MESSAGE_TYPE_DISASTER:
                    case MESSAGE_TYPE_INVASION:
                        lang_text_draw(12, 1, message_dialog_data.x + 100, message_dialog_data.y_text + 44, FONT_NORMAL_WHITE);
                        draw_text(msg->content.text, message_dialog_data.x_text + 8, message_dialog_data.y_text + 86, BLOCK_SIZE * message_dialog_data.text_width_blocks,
                        message_dialog_data.text_height_blocks - 1, 0, 0);
                        break;
                    case MESSAGE_TYPE_EMIGRATION:
                    {
                        if (city_data.sentiment.low_mood_cause >= 1 && city_data.sentiment.low_mood_cause <= 5) {
                            int max_width = BLOCK_SIZE * (message_dialog_data.text_width_blocks - 1) - 64;
                            lang_text_draw_multiline(12, city_data.sentiment.low_mood_cause + 2, message_dialog_data.x + 64, message_dialog_data.y_text + 44, max_width, FONT_NORMAL_WHITE);
                        }
                        draw_text(msg->content.text, message_dialog_data.x_text + 8, message_dialog_data.y_text + 86, BLOCK_SIZE * (message_dialog_data.text_width_blocks - 1), message_dialog_data.text_height_blocks - 1, 0, 0);
                        break;
                    }
                    case MESSAGE_TYPE_TRADE_CHANGE:
                        image_draw(resource_image(player_message.param2), message_dialog_data.x + 64, message_dialog_data.y_text + 40);
                        lang_text_draw(21, empire_objects[player_message.param1].city_name_id, message_dialog_data.x + 100, message_dialog_data.y_text + 44, FONT_NORMAL_WHITE);
                        draw_text(msg->content.text, message_dialog_data.x_text + 8, message_dialog_data.y_text + 86, BLOCK_SIZE * (message_dialog_data.text_width_blocks - 1),
                        message_dialog_data.text_height_blocks - 1, 0, 0);
                        break;
                    case MESSAGE_TYPE_PRICE_CHANGE:
                        image_draw(resource_image(player_message.param2), message_dialog_data.x + 64, message_dialog_data.y_text + 40);
                        text_draw_money(player_message.param1, message_dialog_data.x + 100, message_dialog_data.y_text + 44, FONT_NORMAL_WHITE);
                        draw_text(msg->content.text,
                        message_dialog_data.x_text + 8, message_dialog_data.y_text + 86, BLOCK_SIZE * (message_dialog_data.text_width_blocks - 1),
                        message_dialog_data.text_height_blocks - 1, 0, 0);
                        break;
                    default:
                    {
                        int lines = draw_text(msg->content.text, message_dialog_data.x_text + 8, message_dialog_data.y_text + 56, BLOCK_SIZE * (message_dialog_data.text_width_blocks - 1),
                            message_dialog_data.text_height_blocks - 1, 0, 0);
                        if (msg->message_type == MESSAGE_TYPE_IMPERIAL) {
                            int y_offset = message_dialog_data.y_text + 86 + lines * 16;
                            text_draw_number(scenario.requests[player_message.param1].amount, '@', " ", message_dialog_data.x_text + 8, y_offset, FONT_NORMAL_WHITE);
                            image_draw(resource_image(scenario.requests[player_message.param1].resource), message_dialog_data.x_text + 70, y_offset - 5);
                            lang_text_draw(23, scenario.requests[player_message.param1].resource,
                                message_dialog_data.x_text + 100, y_offset, FONT_NORMAL_WHITE);
                            if (scenario.requests[player_message.param1].state == REQUEST_STATE_NORMAL || scenario.requests[player_message.param1].state == REQUEST_STATE_OVERDUE) {
                                int comply_time_width = lang_text_draw_amount(8, 4, scenario.requests[player_message.param1].months_to_comply,
                                    message_dialog_data.x_text + 200, y_offset, FONT_NORMAL_WHITE);
                                lang_text_draw(12, 2, message_dialog_data.x_text + 200 + comply_time_width, y_offset, FONT_NORMAL_WHITE);
                            }
                        }
                        break;
                    }
                }
            } else {
                draw_text(msg->content.text,
                    message_dialog_data.x_text + 8, message_dialog_data.y_text + 6, BLOCK_SIZE * (message_dialog_data.text_width_blocks - 1),
                    message_dialog_data.text_height_blocks - 1, 0, 0);
            }
            graphics_reset_clip_rectangle();
        }
        if (msg->type == TYPE_MANUAL && message_dialog_data.num_history > 0) {
            // Back button text
            lang_text_draw(12, 0,
                message_dialog_data.x + 52, message_dialog_data.y + BLOCK_SIZE * msg->height_blocks - 31, FONT_NORMAL_BLACK);
        }
    }
    set_translation(0, 0);
}

static void draw_foreground_message_dialog(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    if (message_dialog_data.show_video) {
        draw_foreground_video();
    } else {
        struct lang_message_t *msg = &lang_data.message_entries[message_dialog_data.text_id];
        if (msg->type == TYPE_MANUAL && message_dialog_data.num_history > 0) {
            image_buttons_draw(
                message_dialog_data.x + 16, message_dialog_data.y + BLOCK_SIZE * msg->height_blocks - 36,
                &image_button_back, 1);
        }
        if (msg->type == TYPE_MESSAGE) {
            image_buttons_draw(message_dialog_data.x + 16, message_dialog_data.y + BLOCK_SIZE * msg->height_blocks - 40, get_advisor_button(), 1);
            if (msg->message_type == MESSAGE_TYPE_DISASTER || msg->message_type == MESSAGE_TYPE_INVASION) {
                image_buttons_draw(message_dialog_data.x + 64, message_dialog_data.y_text + 36, &image_button_go_to_problem, 1);
            }
        }
        image_buttons_draw(message_dialog_data.x + BLOCK_SIZE * msg->width_blocks - 38, message_dialog_data.y + BLOCK_SIZE * msg->height_blocks - 36,
            &image_button_close_message_dialog, 1);
        scrollbar_draw(&scrollbar);
    }
    set_translation(0, 0);
}

static void handle_input_message_dialog(struct mouse_t *m, struct hotkeys_t *h)
{
    message_dialog_data.focus_button_id = 0;
    struct mouse_t *m_dialog = mouse_in_dialog(m);
    struct lang_message_t *msg = &lang_data.message_entries[message_dialog_data.text_id];
    int handled = 0;
    if (message_dialog_data.show_video) {
        if (image_buttons_handle_mouse(m_dialog, message_dialog_data.x + 16, message_dialog_data.y + 408, get_advisor_button(), 1, 0)) {
            handled = 1;
        } else if (image_buttons_handle_mouse(m_dialog, message_dialog_data.x + 372, message_dialog_data.y + 410, &image_button_close_message_dialog, 1, 0)) {
            handled = 1;
        } else if (is_problem_message(msg)) {
            if (image_buttons_handle_mouse(m_dialog, message_dialog_data.x + 48, message_dialog_data.y + 407,
                &image_button_go_to_problem, 1, &message_dialog_data.focus_button_id)) {
                handled = 1;
            }
        }
    } else {
        if (msg->type == TYPE_MANUAL && image_buttons_handle_mouse(
            m_dialog, message_dialog_data.x + 16, message_dialog_data.y + BLOCK_SIZE * msg->height_blocks - 36, &image_button_back, 1, 0)) {
            handled = 1;
        } else if (msg->type == TYPE_MESSAGE) {
            if (image_buttons_handle_mouse(m_dialog, message_dialog_data.x + 16, message_dialog_data.y + BLOCK_SIZE * msg->height_blocks - 40, get_advisor_button(), 1, 0)) {
                handled = 1;
            } else if (msg->message_type == MESSAGE_TYPE_DISASTER || msg->message_type == MESSAGE_TYPE_INVASION) {
                if (image_buttons_handle_mouse(m_dialog, message_dialog_data.x + 64, message_dialog_data.y_text + 36,
                    &image_button_go_to_problem, 1, 0)) {
                    handled = 1;
                }
            }
        } else if (image_buttons_handle_mouse(m_dialog,
            message_dialog_data.x + BLOCK_SIZE * msg->width_blocks - 38,
            message_dialog_data.y + BLOCK_SIZE * msg->height_blocks - 36,
            &image_button_close_message_dialog, 1, 0)) {
            handled = 1;
        } else {
            scrollbar_handle_mouse(&scrollbar, m_dialog);
            int text_id = -1;
            if (m_dialog->left.went_up) {
                for (int i = 0; i < rich_text_data.num_links; i++) {
                    if (m_dialog->x >= links[i].x_min && m_dialog->x <= links[i].x_max &&
                        m_dialog->y >= links[i].y_min && m_dialog->y <= links[i].y_max) {
                        text_id = links[i].message_id;
                    }
                }
            }
            if (text_id >= 0) {
                if (message_dialog_data.num_history < MAX_HISTORY - 1) {
                    message_dialog_data.history[message_dialog_data.num_history].text_id = message_dialog_data.text_id;
                    message_dialog_data.history[message_dialog_data.num_history].scroll_position = scrollbar.scroll_position;
                    message_dialog_data.num_history++;
                }
                message_dialog_data.text_id = text_id;
                rich_text_reset(0);
                window_invalidate();
                handled = 1;
            }
        }
    }
    if (!handled && (m->right.went_up || h->escape_pressed)) {
        button_close_message_dialog(0, 0);
    }
}

static void custom_music_callback(__attribute__((unused)) void *dummy, Uint8 *stream, int len)
{
    // Write silence
    memset(stream, 0, len);
    if (len <= 0 || custom_music.stream == 0) {
        return;
    }
    int bytes_copied = 0;
    // Mix audio to sound effect volume
    Uint8 *mix_buffer = (Uint8 *) malloc(len);
    if (!mix_buffer) {
        return;
    }
    memset(mix_buffer, 0, len);
    bytes_copied = SDL_AudioStreamGet(custom_music.stream, mix_buffer, len);
    if (bytes_copied <= 0) {
        return;
    }
    SDL_MixAudioFormat(stream, mix_buffer,
        custom_music.dst_format, bytes_copied,
        settings_values[SETTINGS_SOUND_EFFECTS_VOLUME] * SDL_MIX_MAXVOLUME / 100);
    free(mix_buffer);
}

static void video_init(int restart_music)
{
    data_video.video.start_render_millis = current_time;
    data_video.restart_music = restart_music;
    if (data_video.audio.has_audio) {
        int audio_len = data_video.s->frame_data.audio_len[0];
        if (audio_len > 0) {
            SDL_AudioFormat format;
            if (data_video.audio.bitdepth == 8) {
                format = AUDIO_U8;
            } else if (data_video.audio.bitdepth == 16) {
                format = AUDIO_S16SYS;
            } else {
                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Custom music bitdepth not supported:", 0, data_video.audio.bitdepth));
                return;
            }
            int device_rate;
            Uint16 device_format;
            int device_channels;
            Mix_QuerySpec(&device_rate, &device_format, &device_channels);
            free_custom_audio_stream();
            custom_music.dst_format = device_format;
            custom_music.stream = SDL_NewAudioStream(
                format, data_video.audio.channels, data_video.audio.rate,
                device_format, device_channels, device_rate
            );
            if (!custom_music.stream) {
                return;
            }
            write_custom_music_data(data_video.s->frame_data.audio[0], audio_len);
            Mix_HookMusic(custom_music_callback, 0);
        }
    }
}

static void smacker_get_audio_info(smacker s, int track, int *enabled, int *channels, int *bitdepth, int *audio_rate)
{
    int has_track = (s->audio_rate[track] & AUDIO_FLAG_HAS_TRACK) ? 1 : 0;
    if (enabled) {
        *enabled = has_track;
    }
    if (channels) {
        if (has_track) {
            *channels = (s->audio_rate[track] & AUDIO_FLAG_STEREO) ? 2 : 1;
        } else {
            *channels = 0;
        }
    }
    if (bitdepth) {
        if (has_track) {
            *bitdepth = (s->audio_rate[track] & AUDIO_FLAG_16BIT) ? 16 : 8;
        } else {
            *bitdepth = 0;
        }
    }
    if (audio_rate) {
        *audio_rate = s->audio_rate[track] & AUDIO_MASK_RATE;
    }
}

static void smacker_get_video_info(smacker s, int *width, int *height, int *y_scale_mode)
{
    if (width) {
        *width = s->width;
    }
    if (height) {
        *height = s->height;
    }
    if (y_scale_mode) {
        if (s->flags & FLAG_Y_INTERLACE) {
            *y_scale_mode = SMACKER_Y_SCALE_INTERLACE;
        } else if (s->flags & FLAG_Y_DOUBLE) {
            *y_scale_mode = SMACKER_Y_SCALE_DOUBLE;
        } else {
            *y_scale_mode = SMACKER_Y_SCALE_NONE;
        }
    }
}

static struct huffnode16_t *build_tree16_nodes(struct bitstream_t *bs, struct hufftree16_t *tree)
{
    struct huffnode16_t *node = (struct huffnode16_t *) clear_malloc(sizeof(struct huffnode16_t));
    if (!node) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: no memory for 16-bit tree node", 0, 0));
        return 0;
    }
    if (read_bit(bs)) {
        node->is_leaf = 0;
        node->b[0] = build_tree16_nodes(bs, tree);
        if (!node->b[0]) {
            free(node);
            return 0;
        }
        node->b[1] = build_tree16_nodes(bs, tree);
        if (!node->b[1]) {
            free_node16(node->b[0]);
            free(node);
            return 0;
        }
    } else {
        node->is_leaf = 1;
        uint8_t lo_val = lookup_tree8(bs, tree->low);
        uint8_t hi_val = lookup_tree8(bs, tree->high);
        uint16_t leaf_value = lo_val | (hi_val << 8);
        node->value = leaf_value;

        for (int i = 0; i < 3; i++) {
            if (leaf_value == tree->escape_codes[i]) {
                tree->escape_nodes[i] = node;
            }
        }
    }
    return node;
}

static struct hufftree16_t *create_tree16(struct bitstream_t *bs, struct hufftree8_t *low, struct hufftree8_t *high)
{
    struct hufftree16_t *tree = (struct hufftree16_t *) clear_malloc(sizeof(struct hufftree16_t));
    if (!tree) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: no memory for 16-bit tree", 0, 0));
        return 0;
    }
    tree->low = low;
    tree->high = high;
    for (int i = 0; i < 3; i++) {
        // Do not join the following two lines as it results in an optimization bug for MSVC. See PR #215
        tree->escape_codes[i] = read_byte(bs);
        tree->escape_codes[i] |= read_byte(bs) << 8;
    }
    tree->root = build_tree16_nodes(bs, tree);
    if (!tree->root) {
        free(tree);
        return 0;
    }
    if (read_bit(bs) != 0) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: 16-bit tree not closed", 0, 0));
        free_tree16(tree);
        return 0;
    }
    for (int i = 0; i < 3; i++) {
        if (!tree->escape_nodes[i]) {
            // Escape node is not in the tree: create a dummy node
            tree->escape_nodes[i] = (struct huffnode16_t *) clear_malloc(sizeof(struct huffnode16_t));
            tree->escape_nodes[i]->is_leaf = 0;
            tree->escape_nodes[i]->value = 0;
        }
    }
    return tree;
}

static struct hufftree16_t *read_header_tree(struct bitstream_t *bs)
{
    if (read_bit(bs)) {
        struct hufftree8_t *low = create_tree8(bs);
        struct hufftree8_t *high = create_tree8(bs);
        if (!low || !high) {
            free(low);
            free(high);
            return 0;
        }
        return create_tree16(bs, low, high);
    } else {
        return 0;
    }
}

static void read_header_trees(smacker s, uint8_t *data)
{
    struct bitstream_t bstream;
    struct bitstream_t *bs = bitstream_init(&bstream, data, s->trees_size);

    s->mmap_tree = read_header_tree(bs);
    s->mclr_tree = read_header_tree(bs);
    s->full_tree = read_header_tree(bs);
    s->type_tree = read_header_tree(bs);
}

static int read_header_smacker(smacker s)
{
    uint8_t header[HEADER_SIZE_SMACKER];
    if (fread(header, 1, HEADER_SIZE_SMACKER, s->fp) != HEADER_SIZE_SMACKER) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: unable to read header", 0, 0));
        return 0;
    }
    // check signature
    if (header[0] != 'S' || header[1] != 'M' || header[2] != 'K' || header[3] != '2') {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: file is not an SMK2 video", 0, 0));
        return 0;
    }
    s->width = read_i32(&header[4]);
    s->height = read_i32(&header[8]);
    s->frames = read_i32(&header[12]);
    int32_t frame_rate = read_i32(&header[16]);
    if (frame_rate > 0) {
        // frame rate is given in ms
        s->us_per_frame = frame_rate * 1000;
    } else if (frame_rate < 0) {
        // frame rate is given in 10us
        s->us_per_frame = -10 * frame_rate;
    } else {
        // 10 FPS = 0.1 sec per frame = 100,000 microseconds
        s->us_per_frame = 100000;
    }
    s->flags = read_i32(&header[20]);
    for (int i = 0; i < MAX_TRACKS; i++) {
        s->audio_size[i] = read_i32(&header[24 + 4 * i]);
    }
    s->trees_size = read_i32(&header[52]);
    // 56 - 72: skip mmap_size, mclr_size, full_size, type_size
    for (int i = 0; i < MAX_TRACKS; i++) {
        s->audio_rate[i] = read_i32(&header[72 + 4 * i]);
    }
    return 1;
}

static int read_frame_info(smacker s)
{
    int sizes_length = sizeof(int32_t) * s->frames;
    int types_length = sizeof(uint8_t) * s->frames;

    s->frame_sizes = (int32_t *) clear_malloc(sizes_length);
    s->frame_offsets = (long *) clear_malloc(sizeof(long) * s->frames);
    s->frame_types = (uint8_t *) clear_malloc(types_length);

    if (!s->frame_sizes || !s->frame_offsets || !s->frame_types) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: no memory for frame info", 0, 0));
        free(s->frame_sizes);
        free(s->frame_offsets);
        free(s->frame_types);
        return 0;
    }

    if (fread(s->frame_sizes, 1, sizes_length, s->fp) != (unsigned) sizes_length ||
        fread(s->frame_types, 1, types_length, s->fp) != (unsigned) types_length) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: unable to read frame info from file", 0, 0));
        free(s->frame_sizes);
        free(s->frame_offsets);
        free(s->frame_types);
        return 0;
    }

    uint8_t *data = (uint8_t *) s->frame_sizes;
    long offset = 0;
    for (int i = 0; i < s->frames; i++) {
        // Clear first two flag bits in-place (and flip endian-ness if necessary)
        s->frame_sizes[i] = read_i32(&data[4 * i]) & 0xfffffffc;
        s->frame_offsets[i] = offset;
        offset += s->frame_sizes[i];
    }
    return 1;
}

static int read_trees_data(smacker s)
{
    uint8_t *trees_data = (uint8_t *) clear_malloc(s->trees_size);
    if (!trees_data) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: no memory for tree input data", 0, 0));
        return 0;
    }
    if (fread(trees_data, 1, s->trees_size, s->fp) != (unsigned) s->trees_size) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: unable to read tree data from file", 0, 0));
        free(trees_data);
        return 0;
    }
    read_header_trees(s, trees_data);
    free(trees_data);
    return 1;
}

static int allocate_frame_memory(smacker s)
{
    s->frame_data.video = clear_malloc(sizeof(uint8_t) * s->width * s->height);
    if (!s->frame_data.video) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: no memory for video frame", 0, 0));
        return 0;
    }
    for (int i = 0; i < MAX_TRACKS; i++) {
        if (s->audio_rate[i] & AUDIO_FLAG_HAS_TRACK) {
            s->frame_data.audio[i] = clear_malloc(s->audio_size[i]);
            if (!s->frame_data.audio[i]) {
                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: no memory for audio track", 0, i));
                return 0;
            }
        }
    }
    return 1;
}

static smacker smacker_open(FILE *fp)
{
    if (!fp) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: file does not exist", 0, 0));
        return 0;
    }
    smacker s = (struct smacker_t *) clear_malloc(sizeof(struct smacker_t));
    memset(s, 0, sizeof(struct smacker_t));
    s->fp = fp;

    if (!read_header_smacker(s)) {
        smacker_close(s);
        return 0;
    }
    if (!read_frame_info(s)) {
        smacker_close(s);
        return 0;
    }
    if (!read_trees_data(s)) {
        smacker_close(s);
        return 0;
    }
    if (!allocate_frame_memory(s)) {
        smacker_close(s);
        return 0;
    }
    s->frame_data_offset_in_file = ftell(s->fp);
    return s;
}

static int video_start(char *filename)
{
    data_video.is_playing = 0;
    data_video.is_ended = 0;

    FILE *fp = fopen(filename, "rb");
    data_video.s = smacker_open(fp);
    if (!data_video.s) {
        // smacker_open() closes the stream on error: no need to close fp
        return 0;
    }
    int width, height, y_scale;
    int micros_per_frame = data_video.s->us_per_frame;
    smacker_get_video_info(data_video.s, &width, &height, &y_scale);
    data_video.video.width = width;
    data_video.video.height = y_scale == SMACKER_Y_SCALE_NONE ? height : height * 2;
    data_video.video.y_scale = y_scale;
    data_video.video.current_frame = 0;
    data_video.video.micros_per_frame = micros_per_frame;

    data_video.audio.has_audio = 0;
    if (settings_values[SETTINGS_SOUND_EFFECTS_ENABLED]) {
        int has_track, channels, bitdepth, rate;
        smacker_get_audio_info(data_video.s, 0, &has_track, &channels, &bitdepth, &rate);
        if (has_track) {
            data_video.audio.has_audio = 1;
            data_video.audio.bitdepth = bitdepth;
            data_video.audio.channels = channels;
            data_video.audio.rate = rate;
        }
    }
    data_video.s->current_frame = 0;
    if (decode_frame(data_video.s) != SMACKER_FRAME_OK) {
        close_smk();
        return 0;
    }
    stop_music();
    stop_sound_channel(SOUND_CHANNEL_SPEECH);
    data_video.is_playing = 1;
    return 1;
}

static void window_message_dialog_show(int text_id, void (*background_callback)(void))
{
    struct window_type_t window = {
        WINDOW_MESSAGE_DIALOG,
        draw_background_message_dialog,
        draw_foreground_message_dialog,
        handle_input_message_dialog,
    };
    scroll_drag_end();
    for (int i = 0; i < MAX_HISTORY; i++) {
        message_dialog_data.history[i].text_id = 0;
        message_dialog_data.history[i].scroll_position = 0;
    }
    message_dialog_data.num_history = 0;
    rich_text_reset(0);
    message_dialog_data.text_id = text_id;
    message_dialog_data.background_callback = background_callback;
    struct lang_message_t *msg = &lang_data.message_entries[text_id];
    if (player_message.use_popup != 1) {
        message_dialog_data.show_video = 0;
    } else if (msg->video.text && video_start(msg->video.text)) {
        message_dialog_data.show_video = 1;
    } else {
        message_dialog_data.show_video = 0;
    }
    if (message_dialog_data.show_video) {
        video_init(1);
    }
    window_show(&window);
}

static void window_city_draw_all(void)
{
    window_city_draw_background();
    draw_foreground_city();
}

static void window_message_dialog_show_city_message(int text_id, int year, int month, int param1, int param2, int message_advisor, int use_popup)
{
    player_message.year = year;
    player_message.month = month;
    player_message.param1 = param1;
    player_message.param2 = param2;
    player_message.message_advisor = message_advisor;
    player_message.use_popup = use_popup;
    window_message_dialog_show(text_id, window_city_draw_all);
}

static int city_message_get_advisor(int message_type)
{
    switch (message_type) {
        case MESSAGE_LOCAL_UPRISING:
        case MESSAGE_BARBARIAN_ATTACK:
        case MESSAGE_CAESAR_ARMY_ATTACK:
        case MESSAGE_CAESAR_ARMY_CONTINUE:
        case MESSAGE_CAESAR_ARMY_RETREAT:
        case MESSAGE_ENEMY_ARMY_ATTACK:
        case MESSAGE_DISTANT_BATTLE:
        case MESSAGE_ENEMIES_CLOSING:
        case MESSAGE_ENEMIES_AT_THE_DOOR:
        case MESSAGE_TROOPS_RETURN_VICTORIOUS:
        case MESSAGE_TROOPS_RETURN_FAILED:
        case MESSAGE_DISTANT_BATTLE_LOST_NO_TROOPS:
        case MESSAGE_DISTANT_BATTLE_LOST_TOO_LATE:
        case MESSAGE_DISTANT_BATTLE_LOST_TOO_WEAK:
        case MESSAGE_DISTANT_BATTLE_CITY_RETAKEN:
        case MESSAGE_SPIRIT_OF_MARS:
        case MESSAGE_GLADIATOR_REVOLT:
        case MESSAGE_GLADIATOR_REVOLT_FINISHED:
            return MESSAGE_ADVISOR_MILITARY;
        case MESSAGE_CAESAR_REQUESTS_GOODS:
        case MESSAGE_CAESAR_REQUESTS_MONEY:
        case MESSAGE_CAESAR_REQUESTS_ARMY:
        case MESSAGE_REQUEST_REMINDER:
        case MESSAGE_REQUEST_RECEIVED:
        case MESSAGE_REQUEST_REFUSED:
        case MESSAGE_REQUEST_REFUSED_OVERDUE:
        case MESSAGE_REQUEST_RECEIVED_LATE:
        case MESSAGE_REQUEST_CAN_COMPLY:
        case MESSAGE_CAESAR_WRATH:
        case MESSAGE_CAESAR_RESPECT_1:
        case MESSAGE_CAESAR_RESPECT_2:
        case MESSAGE_CAESAR_RESPECT_3:
            return MESSAGE_ADVISOR_IMPERIAL;
        case MESSAGE_UNEMPLOYMENT:
        case MESSAGE_WORKERS_NEEDED:
        case MESSAGE_ROME_LOWERS_WAGES:
        case MESSAGE_ROME_RAISES_WAGES:
            return MESSAGE_ADVISOR_LABOR;
        case MESSAGE_NOT_ENOUGH_FOOD:
        case MESSAGE_FOOD_NOT_DELIVERED:
        case MESSAGE_POPULATION_500:
        case MESSAGE_POPULATION_1000:
        case MESSAGE_POPULATION_2000:
        case MESSAGE_POPULATION_3000:
        case MESSAGE_POPULATION_5000:
        case MESSAGE_POPULATION_10000:
        case MESSAGE_POPULATION_15000:
        case MESSAGE_POPULATION_20000:
        case MESSAGE_POPULATION_25000:
            return MESSAGE_ADVISOR_POPULATION;
        case MESSAGE_HEALTH_ILLNESS:
        case MESSAGE_HEALTH_DISEASE:
        case MESSAGE_HEALTH_PESTILENCE:
        case MESSAGE_CONTAMINATED_WATER:
            return MESSAGE_ADVISOR_HEALTH;
        case MESSAGE_GODS_UNHAPPY:
        case MESSAGE_GODS_WRATHFUL:
        case MESSAGE_GRAND_FESTIVAL:
        case MESSAGE_LARGE_FESTIVAL:
        case MESSAGE_SMALL_FESTIVAL:
        case MESSAGE_BLESSING_FROM_CERES:
        case MESSAGE_BLESSING_FROM_MARS:
        case MESSAGE_BLESSING_FROM_MERCURY:
        case MESSAGE_BLESSING_FROM_NEPTUNE:
        case MESSAGE_BLESSING_FROM_VENUS:
        case MESSAGE_CERES_IS_UPSET:
        case MESSAGE_MARS_IS_UPSET:
        case MESSAGE_MERCURY_IS_UPSET:
        case MESSAGE_NEPTUNE_IS_UPSET:
        case MESSAGE_VENUS_IS_UPSET:
        case MESSAGE_WRATH_OF_CERES:
        case MESSAGE_WRATH_OF_MARS:
        case MESSAGE_WRATH_OF_MARS_NO_MILITARY:
        case MESSAGE_WRATH_OF_MERCURY:
        case MESSAGE_WRATH_OF_NEPTUNE:
        case MESSAGE_WRATH_OF_NEPTUNE_NO_SEA_TRADE:
        case MESSAGE_WRATH_OF_VENUS:
        case MESSAGE_LOCAL_UPRISING_MARS:
            return MESSAGE_ADVISOR_RELIGION;
        case MESSAGE_INCREASED_TRADING:
        case MESSAGE_DECREASED_TRADING:
        case MESSAGE_PRICE_DECREASED:
        case MESSAGE_PRICE_INCREASED:
        case MESSAGE_TRADE_STOPPED:
        case MESSAGE_LAND_TRADE_DISRUPTED_LANDSLIDES:
        case MESSAGE_LAND_TRADE_DISRUPTED_SANDSTORMS:
        case MESSAGE_SEA_TRADE_DISRUPTED:
            return MESSAGE_ADVISOR_TRADE;
        default:
            return MESSAGE_ADVISOR_NONE;
    }
}

static void show_message_popup(int message_id)
{
    message_data.consecutive_message_delay = 5;
    message_data.messages[message_id].is_read = 1;
    int text_id = city_message_get_text_id(message_data.messages[message_id].message_type);
    struct lang_message_t *msg = &lang_data.message_entries[text_id];
    if (!msg->video.text || !file_exists(0, msg->video.text)) { // does not have video
        play_sound(text_id);
    }
    window_message_dialog_show_city_message(text_id,
        message_data.messages[message_id].year, message_data.messages[message_id].month, message_data.messages[message_id].param1, message_data.messages[message_id].param2,
        city_message_get_advisor(message_data.messages[message_id].message_type), 1);
}

static void city_message_apply_sound_interval(int category)
{
    uint32_t now = current_time;
    if (now - message_data.last_sound_time[category] <= 15000) {
        should_play_sound = 0;
    } else {
        message_data.last_sound_time[category] = now;
    }
}

static int figure_service_provide_coverage(struct figure_t *f)
{
    int houses_serviced = 0;
    int x = f->x;
    int y = f->y;
    struct building_t *b;
    switch (f->type) {
        case FIGURE_PATRICIAN:
            return 0;
        case FIGURE_LABOR_SEEKER:
            houses_serviced = provide_culture(x, y, labor_seeker_coverage);
            break;
        case FIGURE_TAX_COLLECTOR:
        {
            int max_tax_rate = 0;
            houses_serviced = provide_service(x, y, &max_tax_rate, tax_collector_coverage);
            f->min_max_seen = max_tax_rate;
            break;
        }
        case FIGURE_MARKET_TRADER:
        case FIGURE_MARKET_BUYER:
        {
            int serviced = 0;
            struct building_t *market = &all_buildings[f->building_id];
            int x_min, y_min, x_max, y_max;
            map_grid_get_area(x, y, 1, 2, &x_min, &y_min, &x_max, &y_max);
            for (int yy = y_min; yy <= y_max; yy++) {
                for (int xx = x_min; xx <= x_max; xx++) {
                    int grid_offset = map_grid_offset(xx, yy);
                    int building_id = map_building_at(grid_offset);
                    if (building_id) {
                        b = &all_buildings[building_id];
                        if (b->house_size && b->house_population > 0) {
                            int level = b->subtype.house_level;
                            if (level < HOUSE_LUXURY_PALACE) {
                                level++;
                            }
                            int max_food_stocks = 4 * b->house_highest_population;
                            int food_types_stored_max = 0;
                            for (int i = INVENTORY_WHEAT; i <= INVENTORY_MEAT; i++) {
                                if (b->data.house.inventory[i] >= max_food_stocks) {
                                    food_types_stored_max++;
                                }
                            }
                            if (house_properties[level].food_types > food_types_stored_max) {
                                for (int i = INVENTORY_WHEAT; i <= INVENTORY_MEAT; i++) {
                                    if (b->data.house.inventory[i] >= max_food_stocks) {
                                        continue;
                                    }
                                    if (market->data.market.inventory[i] >= max_food_stocks) {
                                        b->data.house.inventory[i] += max_food_stocks;
                                        market->data.market.inventory[i] -= max_food_stocks;
                                        break;
                                    } else if (market->data.market.inventory[i]) {
                                        b->data.house.inventory[i] += market->data.market.inventory[i];
                                        market->data.market.inventory[i] = 0;
                                        break;
                                    }
                                }
                            }
                            if (house_properties[level].pottery) {
                                market->data.market.pottery_demand = 10;
                                distribute_good(b, market, 8 * house_properties[level].pottery, INVENTORY_POTTERY);
                            }
                            if (house_properties[level].furniture) {
                                market->data.market.furniture_demand = 10;
                                distribute_good(b, market, 4 * house_properties[level].furniture, INVENTORY_FURNITURE);
                            }
                            if (house_properties[level].oil) {
                                market->data.market.oil_demand = 10;
                                distribute_good(b, market, 4 * house_properties[level].oil, INVENTORY_OIL);
                            }
                            if (house_properties[level].wine) {
                                market->data.market.wine_demand = 10;
                                distribute_good(b, market, 4 * house_properties[level].wine, INVENTORY_WINE);
                            }
                            serviced++;
                        }
                    }
                }
            }
            houses_serviced = serviced;
            break;
        }
        case FIGURE_BATHHOUSE_WORKER:
            houses_serviced = provide_culture(x, y, bathhouse_coverage);
            break;
        case FIGURE_SCHOOL_CHILD:
            houses_serviced = provide_culture(x, y, school_coverage);
            break;
        case FIGURE_TEACHER:
            houses_serviced = provide_culture(x, y, academy_coverage);
            break;
        case FIGURE_LIBRARIAN:
            houses_serviced = provide_culture(x, y, library_coverage);
            break;
        case FIGURE_BARBER:
            houses_serviced = provide_culture(x, y, barber_coverage);
            break;
        case FIGURE_DOCTOR:
            houses_serviced = provide_culture(x, y, clinic_coverage);
            break;
        case FIGURE_SURGEON:
            houses_serviced = provide_culture(x, y, hospital_coverage);
            break;
        case FIGURE_MISSIONARY:
        {
            int x_min, y_min, x_max, y_max;
            map_grid_get_area(x, y, 1, 4, &x_min, &y_min, &x_max, &y_max);
            for (int yy = y_min; yy <= y_max; yy++) {
                for (int xx = x_min; xx <= x_max; xx++) {
                    int building_id = map_building_at(map_grid_offset(xx, yy));
                    if (building_id) {
                        b = &all_buildings[building_id];
                        if (b->type == BUILDING_NATIVE_HUT || b->type == BUILDING_NATIVE_MEETING) {
                            b->sentiment.native_anger = 0;
                        }
                    }
                }
            }
            houses_serviced = 1;
            break;
        }
        case FIGURE_PRIEST:
            switch (all_buildings[f->building_id].type) {
                case BUILDING_SMALL_TEMPLE_CERES:
                case BUILDING_LARGE_TEMPLE_CERES:
                    houses_serviced = provide_culture(x, y, religion_coverage_ceres);
                    break;
                case BUILDING_SMALL_TEMPLE_NEPTUNE:
                case BUILDING_LARGE_TEMPLE_NEPTUNE:
                    houses_serviced = provide_culture(x, y, religion_coverage_neptune);
                    break;
                case BUILDING_SMALL_TEMPLE_MERCURY:
                case BUILDING_LARGE_TEMPLE_MERCURY:
                    houses_serviced = provide_culture(x, y, religion_coverage_mercury);
                    break;
                case BUILDING_SMALL_TEMPLE_MARS:
                case BUILDING_LARGE_TEMPLE_MARS:
                    houses_serviced = provide_culture(x, y, religion_coverage_mars);
                    break;
                case BUILDING_SMALL_TEMPLE_VENUS:
                case BUILDING_LARGE_TEMPLE_VENUS:
                    houses_serviced = provide_culture(x, y, religion_coverage_venus);
                    break;
                default:
                    break;
            }
            break;
        case FIGURE_ACTOR:
            b = get_entertainment_building(f);
            if (b->type == BUILDING_THEATER) {
                houses_serviced = provide_culture(x, y, theater_coverage);
            } else if (b->type == BUILDING_AMPHITHEATER) {
                houses_serviced = provide_entertainment(x, y,
                    b->data.entertainment.days1 ? 2 : 1, amphitheater_coverage);
            }
            break;
        case FIGURE_GLADIATOR:
            b = get_entertainment_building(f);
            if (b->type == BUILDING_AMPHITHEATER) {
                houses_serviced = provide_entertainment(x, y,
                    b->data.entertainment.days2 ? 2 : 1, amphitheater_coverage);
            } else if (b->type == BUILDING_COLOSSEUM) {
                houses_serviced = provide_entertainment(x, y,
                    b->data.entertainment.days1 ? 2 : 1, colosseum_coverage);
            }
            break;
        case FIGURE_LION_TAMER:
            b = get_entertainment_building(f);
            houses_serviced = provide_entertainment(x, y,
                b->data.entertainment.days2 ? 2 : 1, colosseum_coverage);
            break;
        case FIGURE_CHARIOTEER:
            houses_serviced = provide_culture(x, y, hippodrome_coverage);
            break;
        case FIGURE_ENGINEER:
        {
            int max_damage = 0;
            houses_serviced = provide_service(x, y, &max_damage, engineer_coverage);
            if (max_damage > f->min_max_seen) {
                f->min_max_seen = max_damage;
            } else if (f->min_max_seen <= 10) {
                f->min_max_seen = 0;
            } else {
                f->min_max_seen -= 10;
            }
            break;
        }
        case FIGURE_PREFECT:
        {
            int min_happiness = 100;
            houses_serviced = provide_service(x, y, &min_happiness, prefect_coverage);
            f->min_max_seen = min_happiness;
            break;
        }
        case FIGURE_RIOTER:
        {
            for (int dir = 0; dir < 8; dir += 2) {
                int grid_offset = f->grid_offset + map_grid_direction_delta(dir);
                if (!map_building_at(grid_offset)) {
                    continue;
                }
                b = &all_buildings[map_building_at(grid_offset)];
                switch (b->type) {
                    case BUILDING_WAREHOUSE_SPACE:
                    case BUILDING_WAREHOUSE:
                    case BUILDING_FORT_GROUND:
                    case BUILDING_FORT_LEGIONARIES:
                    case BUILDING_FORT_JAVELIN:
                    case BUILDING_FORT_MOUNTED:
                    case BUILDING_BURNING_RUIN:
                        continue;
                }
                if (b->house_size && b->subtype.house_level < HOUSE_SMALL_CASA) {
                    continue;
                }
                city_message_apply_sound_interval(MESSAGE_CAT_RIOT_COLLAPSE);
                city_message_post(0, MESSAGE_DESTROYED_BUILDING, b->type, f->grid_offset);
                message_data.message_count[MESSAGE_CAT_RIOT_COLLAPSE]++;
                destroy_on_fire(b, 0);
                f->action_state = FIGURE_ACTION_RIOTER_CREATED;
                f->wait_ticks = 0;
                f->direction = dir;
                return 1;
            }
            break;
        }
    }
    if (f->building_id) {
        b = &all_buildings[f->building_id];
        b->houses_covered += houses_serviced;
        if (b->houses_covered > 300) {
            b->houses_covered = 300;
        }
    }
    return 0;
}

static void figure__remove_ranged_targeter_from_list(struct figure_t *f, struct figure_t *ranged_targeter)
{
    for (int i = 0; i < MAX_RANGED_TARGETERS_PER_UNIT; i++) {
        if (f->ranged_targeter_ids[i] == ranged_targeter->id) {
            f->ranged_targeter_ids[i] = 0;
        }
    }
}

static void engage_in_melee_combat(struct figure_t *attacker, struct figure_t *opponent)
{
    attacker->engaged_in_combat = 1;
    // if ranged unit engages in melee combat, remove it from its (previous) target's ranged targeter list
    if (figure_properties[attacker->type].max_range && attacker->target_figure_id) {
        struct figure_t *target_of_ranged_unit = &figures[attacker->target_figure_id];
        figure__remove_ranged_targeter_from_list(target_of_ranged_unit, attacker);
    }
    attacker->target_figure_id = opponent->id;
    attacker->melee_combatant_ids[0] = opponent->id;
    attacker->num_melee_combatants++;
    attacker->attack_image_offset = 12;
    if (opponent->x != opponent->destination_x || opponent->y != opponent->destination_y) {
        attacker->attack_direction = calc_general_direction(attacker->previous_tile_x, attacker->previous_tile_y,
            opponent->previous_tile_x, opponent->previous_tile_y);
    } else {
        attacker->attack_direction = calc_general_direction(attacker->previous_tile_x, attacker->previous_tile_y,
            opponent->x, opponent->y);
    }
    if (attacker->attack_direction >= 8) {
        attacker->attack_direction = 0;
    }
    if (!opponent->engaged_in_combat) {
        opponent->engaged_in_combat = 1;
        // if opponent ranged unit engaged in melee combat, remove it from its (previous) target's ranged targeter list
        if (figure_properties[opponent->type].max_range && opponent->target_figure_id) {
            struct figure_t *target_of_opponent_ranged_unit = &figures[opponent->target_figure_id];
            figure__remove_ranged_targeter_from_list(target_of_opponent_ranged_unit, opponent);
        }
        opponent->target_figure_id = attacker->id;
        opponent->attack_image_offset = 0;
        opponent->attack_direction = (attacker->attack_direction + 4) % 8;
    }
    // add attacker to opponent's melee combatants list
    for (int i = 0; i < MAX_MELEE_COMBATANTS_PER_UNIT; i++) {
        if (!opponent->melee_combatant_ids[i]) {
            opponent->melee_combatant_ids[i] = attacker->id;
            break;
        }
    }
    opponent->num_melee_combatants++;
}

static int can_see_target(struct figure_t *observer, struct figure_t *target)
{
    int observer_elevation = terrain_elevation.items[observer->grid_offset];
    if (map_terrain_is(observer->grid_offset, TERRAIN_WALL_OR_GATEHOUSE)) {
        observer_elevation += 6;
    }

    int x_delta = abs(observer->x - target->x);
    int y_delta = abs(observer->y - target->y);
    double slope;
    int x_check = 0;
    int y_check = 0;
    int delta;
    if (x_delta > y_delta) {
        slope = (double) (target->y - observer->y) / (double) (target->x - observer->x);
        x_check = observer->x;
        delta = x_delta;
    } else {
        slope = (double) (target->x - observer->x) / (double) (target->y - observer->y);
        y_check = observer->y;
        delta = y_delta;
    }
    while (delta > 1) {
        delta--;
        if (x_delta > y_delta) {
            if (observer->x < target->x) {
                x_check++;
            } else {
                x_check--;
            }
            y_check = slope * (x_check - observer->x) + observer->y;
        } else {
            if (observer->y < target->y) {
                y_check++;
            } else {
                y_check--;
            }
            x_check = slope * (y_check - observer->y) + observer->x;
        }
        if (observer_elevation > terrain_elevation.items[target->grid_offset]) {
            observer_elevation--;
            continue;
        }
        int grid_offset = map_grid_offset(x_check, y_check);
        int map_img_at_offset = images.items[grid_offset];
        // only higher elevation between targets obstructs
        if (terrain_elevation.items[grid_offset] > 1) {
            return 0;
        }
        // only taller shrubs obstruct
        if (terrain_grid.items[grid_offset] & TERRAIN_SHRUB) {
            int shrub_first_img_id = image_data_s.group_image_ids[GROUP_TERRAIN_SHRUB];
            if (((scenario.climate == CLIMATE_CENTRAL || scenario.climate == CLIMATE_NORTHERN) && map_img_at_offset >= shrub_first_img_id + 8)
            || (scenario.climate == CLIMATE_DESERT && map_img_at_offset >= shrub_first_img_id + 24)) {
                return 0;
            }
        }
        // only larger rocks obstruct
        if (terrain_grid.items[grid_offset] & TERRAIN_ROCK) {
            int rock_first_img_id = image_data_s.group_image_ids[GROUP_TERRAIN_ROCK];
            if (map_img_at_offset >= rock_first_img_id + 8) {
                return 0;
            }
        }
        if (terrain_grid.items[grid_offset] & (TERRAIN_TREE | TERRAIN_WALL | TERRAIN_GATEHOUSE)) { // "terrain contains any of"
            return 0;
        }
        if (terrain_grid.items[grid_offset] & TERRAIN_BUILDING) {
            struct building_t *b = &all_buildings[map_building_at(grid_offset)];
            // buildings with a low max height do not obstruct
            if (b->type != BUILDING_FORT_GROUND && b->type != BUILDING_CLAY_PIT && b->type != BUILDING_MARBLE_QUARRY) {
                return 0;
            }
        }
    }
    return 1;
}

static int is_valid_target_for_player_unit(struct figure_t *target)
{
    return figure_properties[target->type].is_criminal_unit
        || (figure_properties[target->type].is_native_unit && target->action_state == FIGURE_ACTION_NATIVE_ATTACKING)
        || target->type == FIGURE_WOLF
        || figure_properties[target->type].is_enemy_unit
        || figure_properties[target->type].is_caesar_legion_unit;
}

static int is_valid_target_for_enemy_unit(struct figure_t *target)
{
    return figure_properties[target->type].is_unarmed_civilian_unit
        || figure_properties[target->type].is_friendly_armed_unit
        || figure_properties[target->type].is_player_legion_unit
        || figure_properties[target->type].is_criminal_unit
        || figure_properties[target->type].is_empire_trader
        || (figure_properties[target->type].is_native_unit && target->action_state != FIGURE_ACTION_NATIVE_ATTACKING)
        || target->type == FIGURE_WOLF
        || figure_properties[target->type].is_caesar_legion_unit;
}

static int is_valid_target_for_caesar_unit(struct figure_t *target)
{
    return figure_properties[target->type].is_friendly_armed_unit
        || figure_properties[target->type].is_player_legion_unit
        || figure_properties[target->type].is_criminal_unit
        || (figure_properties[target->type].is_native_unit && target->action_state != FIGURE_ACTION_NATIVE_ATTACKING)
        || target->type == FIGURE_WOLF
        || figure_properties[target->type].is_enemy_unit;
}

static void melee_attack_figure_at_offset(struct figure_t *attacker, int grid_offset)
{
    if (attacker->engaged_in_combat) {
        return;
    }
    int figure_id = map_figures.items[grid_offset];
    while (figure_id) {
        struct figure_t *opponent = &figures[figure_id];
        if (opponent->id != attacker->id
        && figure_is_alive(opponent)
        && opponent->is_targetable
        && opponent->num_melee_combatants < MAX_MELEE_COMBATANTS_PER_UNIT) {
            if (figure_properties[attacker->type].is_friendly_armed_unit || figure_properties[attacker->type].is_player_legion_unit) {
                if (is_valid_target_for_player_unit(opponent) || (opponent->type == FIGURE_SHEEP || opponent->type == FIGURE_ZEBRA)) {
                    engage_in_melee_combat(attacker, opponent);
                    return;
                }
            } else if (attacker->type == FIGURE_WOLF) {
                if (opponent->type != FIGURE_WOLF) {
                    engage_in_melee_combat(attacker, opponent);
                    return;
                }
            } else if (figure_properties[attacker->type].is_enemy_unit) {
                if (is_valid_target_for_enemy_unit(opponent)) {
                    engage_in_melee_combat(attacker, opponent);
                    return;
                }
            } else if (figure_properties[attacker->type].is_caesar_legion_unit) {
                if (is_valid_target_for_caesar_unit(opponent)) {
                    engage_in_melee_combat(attacker, opponent);
                    return;
                }
            }
        }
        figure_id = opponent->next_figure_id_on_same_tile;
    }
}

static void move_to_next_tile(struct figure_t *f)
{
    int old_x = f->x;
    int old_y = f->y;
    map_figure_delete(f);
    switch (f->direction) {
        default:
            return;
        case DIR_0_TOP:
            f->y--;
            break;
        case DIR_1_TOP_RIGHT:
            f->x++; f->y--;
            break;
        case DIR_2_RIGHT:
            f->x++;
            break;
        case DIR_3_BOTTOM_RIGHT:
            f->x++; f->y++;
            break;
        case DIR_4_BOTTOM:
            f->y++;
            break;
        case DIR_5_BOTTOM_LEFT:
            f->x--; f->y++;
            break;
        case DIR_6_LEFT:
            f->x--;
            break;
        case DIR_7_TOP_LEFT:
            f->x--; f->y--;
            break;
    }
    f->grid_offset += map_grid_direction_delta(f->direction);
    map_figure_add(f);
    if (map_terrain_is(f->grid_offset, TERRAIN_ROAD)) {
        if (map_terrain_is(f->grid_offset, TERRAIN_WATER)) { // bridge
            f->height_adjusted_ticks = 18;
            if (sprite.items[f->grid_offset] <= 6) {
                // low bridge
                switch (sprite.items[f->grid_offset]) {
                    case 1:
                    case 4:
                        f->target_height = 10;
                        break;
                    case 2:
                    case 3:
                        f->target_height = 16;
                        break;
                    default:
                        f->target_height = 20;
                        break;
                }
            } else {
                // ship bridge
                switch (sprite.items[f->grid_offset]) {
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                        f->target_height = 14;
                        break;
                    case 13:
                        f->target_height = 30;
                        break;
                    default:
                        f->target_height = 36;
                        break;
                }
            }
        }
    }
    if (figure_properties[f->type].is_friendly_armed_unit || figure_properties[f->type].is_player_legion_unit
    || figure_properties[f->type].is_native_unit || f->type == FIGURE_WOLF || figure_properties[f->type].is_enemy_unit || figure_properties[f->type].is_caesar_legion_unit) {
        melee_attack_figure_at_offset(f, f->grid_offset);
    }
    f->previous_tile_x = old_x;
    f->previous_tile_y = old_y;
}

static void advance_tick_movement(struct figure_t *f)
{
    switch (f->direction) {
        case DIR_0_TOP:
            f->cross_country_y--;
            break;
        case DIR_1_TOP_RIGHT:
            f->cross_country_x++;
            f->cross_country_y--;
            break;
        case DIR_2_RIGHT:
            f->cross_country_x++;
            break;
        case DIR_3_BOTTOM_RIGHT:
            f->cross_country_x++;
            f->cross_country_y++;
            break;
        case DIR_4_BOTTOM:
            f->cross_country_y++;
            break;
        case DIR_5_BOTTOM_LEFT:
            f->cross_country_x--;
            f->cross_country_y++;
            break;
        case DIR_6_LEFT:
            f->cross_country_x--;
            break;
        case DIR_7_TOP_LEFT:
            f->cross_country_x--;
            f->cross_country_y--;
            break;
        default:
            break;
    }
    if (f->height_adjusted_ticks) {
        f->height_adjusted_ticks--;
        if (f->height_adjusted_ticks > 0) {
            f->is_invisible = 1;
            if (f->current_height < f->target_height) {
                f->current_height++;
            }
            if (f->current_height > f->target_height) {
                f->current_height--;
            }
        } else {
            f->is_invisible = 0;
        }
    } else {
        if (f->current_height) {
            f->current_height--;
        }
    }
}

static void map_routing_calculate_distances_water_boat(int x, int y)
{
    int grid_offset = map_grid_offset(x, y);
    if (terrain_water.items[grid_offset] == WATER_N1_BLOCKED) {
        memset(routing_distance.items, 0, GRID_SIZE * GRID_SIZE * sizeof(int16_t));
    } else {
        memset(routing_distance.items, 0, GRID_SIZE * GRID_SIZE * sizeof(int16_t));
        memset(water_drag.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
        routing_queue.head = routing_queue.tail = 0;
        enqueue(grid_offset, 1);
        int tiles = 0;
        while (routing_queue.head != routing_queue.tail) {
            int offset = routing_queue.items[routing_queue.head];
            if (++tiles > GUARD) {
                break;
            }
            int drag = terrain_water.items[offset] == WATER_N2_MAP_EDGE ? 4 : 0;
            if (drag && water_drag.items[offset]++ < drag) {
                routing_queue.items[routing_queue.tail++] = offset;
                if (routing_queue.tail >= MAX_QUEUE_ROUTING) {
                    routing_queue.tail = 0;
                }
            } else {
                int dist = 1 + routing_distance.items[offset];
                for (int i = 0; i < 4; i++) {
                    if (valid_offset(offset + ROUTE_OFFSETS[i])) {
                        if (terrain_water.items[offset + ROUTE_OFFSETS[i]] != WATER_N1_BLOCKED &&
    terrain_water.items[offset + ROUTE_OFFSETS[i]] != WATER_N3_LOW_BRIDGE) {
                            enqueue(offset + ROUTE_OFFSETS[i], dist);
                            if (terrain_water.items[offset + ROUTE_OFFSETS[i]] == WATER_N2_MAP_EDGE) {
                                routing_distance.items[offset + ROUTE_OFFSETS[i]] += 4;
                            }
                        }
                    }
                }
            }
            if (++routing_queue.head >= MAX_QUEUE_ROUTING) {
                routing_queue.head = 0;
            }
        }
    }
}

static void callback_travel_noncitizen_land_through_building(int next_offset, int dist)
{
    if (terrain_land_noncitizen.items[next_offset] == NONCITIZEN_0_PASSABLE ||
        terrain_land_noncitizen.items[next_offset] == NONCITIZEN_2_CLEARABLE ||
        (terrain_land_noncitizen.items[next_offset] == NONCITIZEN_1_BUILDING &&
            map_building_at(next_offset) == route_through_building_id)) {
        enqueue(next_offset, dist);
    }
}

static int map_routing_noncitizen_can_travel_over_land(int src_x, int src_y, int dst_x, int dst_y, int only_through_building_id, int max_tiles)
{
    int src_offset = map_grid_offset(src_x, src_y);
    int dst_offset = map_grid_offset(dst_x, dst_y);
    ++stats.total_routes_calculated;
    ++stats.enemy_routes_calculated;
    if (only_through_building_id) {
        route_through_building_id = only_through_building_id;
        route_queue(src_offset, dst_offset, callback_travel_noncitizen_land_through_building);
    } else {
        memset(routing_distance.items, 0, GRID_SIZE * GRID_SIZE * sizeof(int16_t));
        routing_queue.head = routing_queue.tail = 0;
        enqueue(src_offset, 1);
        int tiles = 0;
        while (routing_queue.head != routing_queue.tail) {
            int offset = routing_queue.items[routing_queue.head];
            if (offset == dst_offset) break;
            if (++tiles > max_tiles) break;
            int dist = 1 + routing_distance.items[offset];
            for (int i = 0; i < 4; i++) {
                if (valid_offset(offset + ROUTE_OFFSETS[i])) {
                    if (terrain_land_noncitizen.items[offset + ROUTE_OFFSETS[i]] >= NONCITIZEN_0_PASSABLE &&
    terrain_land_noncitizen.items[offset + ROUTE_OFFSETS[i]] <= NONCITIZEN_5_FORT) {
                        enqueue(offset + ROUTE_OFFSETS[i], dist);
                    }
                }
            }
            if (++routing_queue.head >= MAX_QUEUE_ROUTING) {
                routing_queue.head = 0;
            }
        }
    }
    return routing_distance.items[dst_offset] != 0;
}

static void callback_travel_noncitizen_through_everything(int next_offset, int dist)
{
    if (terrain_land_noncitizen.items[next_offset] >= NONCITIZEN_0_PASSABLE) {
        enqueue(next_offset, dist);
    }
}

static int map_routing_noncitizen_can_travel_through_everything(int src_x, int src_y, int dst_x, int dst_y)
{
    int src_offset = map_grid_offset(src_x, src_y);
    int dst_offset = map_grid_offset(dst_x, dst_y);
    ++stats.total_routes_calculated;
    route_queue(src_offset, dst_offset, callback_travel_noncitizen_through_everything);
    return routing_distance.items[dst_offset] != 0;
}

static void walk_ticks(struct figure_t *f, int num_ticks, int roaming_enabled)
{
    while (num_ticks > 0) {
        f->figure_is_halted = 0;
        num_ticks--;
        f->progress_on_tile++;
        if (f->progress_on_tile < 15) {
            advance_tick_movement(f);
        } else {
            figure_service_provide_coverage(f);
            f->progress_on_tile = 15;
            if (f->routing_path_id <= 0) {
                f->routing_path_id = 0;
                f->routing_path_current_tile = 0;
                f->routing_path_length = 0;
                int path_id = 0;
                for (int i = 1; i < MAX_ROUTES; i++) {
                    if (figure_route_data.figure_ids[i] == 0) {
                        path_id = i;
                        break;
                    }
                }
                int path_length;
                if (path_id) {
                    if (figure_properties[f->type].is_boat) {
                        if (figure_properties[f->type].is_boat == 2) { // flotsam
                            int grid_offset = map_grid_offset(f->x, f->y);
                            if (terrain_water.items[grid_offset] == WATER_N1_BLOCKED) {
                                memset(routing_distance.items, 0, GRID_SIZE * GRID_SIZE * sizeof(int16_t));
                            } else {
                                memset(routing_distance.items, 0, GRID_SIZE * GRID_SIZE * sizeof(int16_t));
                                routing_queue.head = routing_queue.tail = 0;
                                enqueue(grid_offset, 1);
                                int tiles = 0;
                                while (routing_queue.head != routing_queue.tail) {
                                    if (++tiles > GUARD) {
                                        break;
                                    }
                                    int offset = routing_queue.items[routing_queue.head];
                                    int dist = 1 + routing_distance.items[offset];
                                    for (int i = 0; i < 8; i++) {
                                        if (valid_offset(offset + ROUTE_OFFSETS[i])) {
                                            if (terrain_water.items[offset + ROUTE_OFFSETS[i]] != WATER_N1_BLOCKED) {
                                                enqueue(offset + ROUTE_OFFSETS[i], dist);
                                            }
                                        }
                                    }
                                    if (++routing_queue.head >= MAX_QUEUE_ROUTING) {
                                        routing_queue.head = 0;
                                    }
                                }
                            }
                            path_length = map_routing_get_path_on_water(figure_route_data.direction_paths[path_id],
                                f->destination_x, f->destination_y, 1);
                        } else {
                            map_routing_calculate_distances_water_boat(f->x, f->y);
                            path_length = map_routing_get_path_on_water(figure_route_data.direction_paths[path_id],
                                f->destination_x, f->destination_y, 0);
                        }
                    } else {
                        // land figure
                        int can_travel;
                        switch (f->terrain_usage) {
                            case TERRAIN_USAGE_ENEMY:
                                can_travel = map_routing_noncitizen_can_travel_over_land(f->x, f->y,
                                    f->destination_x, f->destination_y, f->destination_building_id, 5000);
                                if (!can_travel) {
                                    can_travel = map_routing_noncitizen_can_travel_over_land(f->x, f->y,
                                        f->destination_x, f->destination_y, 0, 25000);
                                    if (!can_travel) {
                                        can_travel = map_routing_noncitizen_can_travel_through_everything(
                                            f->x, f->y, f->destination_x, f->destination_y);
                                    }
                                }
                                break;
                            case TERRAIN_USAGE_WALLS:
                                int src_offset = map_grid_offset(f->x, f->y);
                                int dst_offset = map_grid_offset(f->destination_x, f->destination_y);
                                stats.total_routes_calculated++;
                                route_queue(src_offset, dst_offset, callback_travel_walls);
                                can_travel = routing_distance.items[dst_offset] != 0;
                                break;
                            case TERRAIN_USAGE_ANIMAL:
                                can_travel = map_routing_noncitizen_can_travel_over_land(f->x, f->y, f->destination_x, f->destination_y, -1, 5000);
                                break;
                            case TERRAIN_USAGE_PREFER_ROADS:
                                can_travel = map_routing_citizen_can_travel_over_road_garden(f->x, f->y, f->destination_x, f->destination_y);
                                if (!can_travel) {
                                    can_travel = map_routing_citizen_can_travel_over_land(f->x, f->y, f->destination_x, f->destination_y);
                                }
                                break;
                            case TERRAIN_USAGE_ROADS:
                                can_travel = map_routing_citizen_can_travel_over_road_garden(f->x, f->y, f->destination_x, f->destination_y);
                                break;
                            default:
                                can_travel = map_routing_citizen_can_travel_over_land(f->x, f->y, f->destination_x, f->destination_y);
                                break;
                        }
                        if (can_travel) {
                            if (f->terrain_usage == TERRAIN_USAGE_WALLS) {
                                path_length = map_routing_get_path(figure_route_data.direction_paths[path_id], f->x, f->y,
                                    f->destination_x, f->destination_y, 4);
                                if (path_length <= 0) {
                                    path_length = map_routing_get_path(figure_route_data.direction_paths[path_id], f->x, f->y,
                                        f->destination_x, f->destination_y, 8);
                                }
                            } else {
                                path_length = map_routing_get_path(figure_route_data.direction_paths[path_id], f->x, f->y,
                                    f->destination_x, f->destination_y, 8);
                            }
                        } else { // cannot travel
                            path_length = 0;
                        }
                    }
                }
                if (path_length) {
                    figure_route_data.figure_ids[path_id] = f->id;
                    f->routing_path_id = path_id;
                    f->routing_path_length = path_length;
                }
            }
            if (f->routing_path_id > 0) {
                if (f->routing_path_current_tile < f->routing_path_length) {
                    f->direction = figure_route_data.direction_paths[f->routing_path_id][f->routing_path_current_tile];
                } else {
                    figure_route_remove(f);
                    f->direction = DIR_FIGURE_AT_DESTINATION;
                    f->figure_is_halted = 1;
                }
            } else { // should be at destination
                f->direction = calc_general_direction(f->x, f->y, f->destination_x, f->destination_y);
                if (f->direction != DIR_FIGURE_AT_DESTINATION) {
                    f->direction = DIR_FIGURE_LOST;
                }
            }
            if (f->direction < 8) {
                int target_grid_offset = f->grid_offset + map_grid_direction_delta(f->direction);
                if (figure_properties[f->type].is_boat) {
                    if (!map_terrain_is(target_grid_offset, TERRAIN_WATER)) {
                        f->direction = DIR_FIGURE_REROUTE;
                    }
                } else if (f->terrain_usage == TERRAIN_USAGE_ENEMY) {
                    if (terrain_land_noncitizen.items[target_grid_offset] < NONCITIZEN_0_PASSABLE) {
                        f->direction = DIR_FIGURE_REROUTE;
                    } else if (terrain_land_noncitizen.items[target_grid_offset] > NONCITIZEN_0_PASSABLE && terrain_land_noncitizen.items[target_grid_offset] != NONCITIZEN_5_FORT) {
                        int cause_damage = 1;
                        int max_damage = 0;
                        int destructible = 0;
                        switch (terrain_land_noncitizen.items[target_grid_offset]) {
                            case NONCITIZEN_1_BUILDING:
                                destructible = DESTROYABLE_BUILDING;
                                break;
                            case NONCITIZEN_2_CLEARABLE:
                                destructible = DESTROYABLE_AQUEDUCT_GARDEN;
                                break;
                            case NONCITIZEN_3_WALL:
                                destructible = DESTROYABLE_WALL;
                                break;
                            case NONCITIZEN_4_GATEHOUSE:
                                destructible = DESTROYABLE_GATEHOUSE;
                                break;
                            default:
                                destructible = DESTROYABLE_NONE;
                                break;
                        }
                        switch (destructible) {
                            case DESTROYABLE_BUILDING:
                                max_damage = 10;
                                break;
                            case DESTROYABLE_AQUEDUCT_GARDEN:
                                if (map_terrain_is(target_grid_offset, TERRAIN_GARDEN | TERRAIN_ACCESS_RAMP | TERRAIN_RUBBLE)) {
                                    cause_damage = 0;
                                } else {
                                    max_damage = 10;
                                }
                                break;
                            case DESTROYABLE_WALL:
                                max_damage = 200;
                                break;
                            case DESTROYABLE_GATEHOUSE:
                                max_damage = 150;
                                break;
                        }
                        if (cause_damage) {
                            f->attack_direction = f->direction;
                            f->direction = DIR_FIGURE_ATTACK;
                            if (!(time_data.tick & 3)) {
                                damage_grid.items[target_grid_offset]++;
                                if (damage_grid.items[target_grid_offset] > max_damage) {
                                    building_destroy_by_enemy(map_grid_offset_to_x(target_grid_offset), map_grid_offset_to_y(target_grid_offset), target_grid_offset);
                                }
                            }
                        }
                    }
                } else if (f->terrain_usage == TERRAIN_USAGE_WALLS) {
                    if (terrain_walls.items[target_grid_offset] != WALL_0_PASSABLE) {
                        f->direction = DIR_FIGURE_REROUTE;
                    }
                } else if (map_terrain_is(target_grid_offset, TERRAIN_ROAD | TERRAIN_ACCESS_RAMP)) {
                    if (roaming_enabled && map_terrain_is(target_grid_offset, TERRAIN_BUILDING)) {
                        if (all_buildings[map_building_at(target_grid_offset)].type == BUILDING_GATEHOUSE) {
                            // do not allow roaming through gatehouse
                            f->direction = DIR_FIGURE_REROUTE;
                        }
                    }
                } else if (map_terrain_is(target_grid_offset, TERRAIN_BUILDING)) {
                    switch (all_buildings[map_building_at(target_grid_offset)].type) {
                        case BUILDING_WAREHOUSE:
                        case BUILDING_GRANARY:
                        case BUILDING_TRIUMPHAL_ARCH:
                        case BUILDING_FORT_GROUND:
                            break; // OK to walk
                        default:
                            f->direction = DIR_FIGURE_REROUTE;
                    }
                } else if (map_terrain_is(target_grid_offset, TERRAIN_IMPASSABLE)) {
                    f->direction = DIR_FIGURE_REROUTE;
                }
            }
            if (f->direction >= 8) {
                break;
            }
            f->routing_path_current_tile++;
            f->previous_tile_direction = f->direction;
            f->progress_on_tile = 0;
            move_to_next_tile(f);
            advance_tick_movement(f);
        }
    }
}

static void figure_movement_roam_ticks(struct figure_t *f, int num_ticks)
{
    if (f->roam_choose_destination == 0) {
        walk_ticks(f, num_ticks, 1);
        if (f->direction == DIR_FIGURE_AT_DESTINATION) {
            f->roam_choose_destination = 1;
            f->roam_length = 0;
        } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
            f->roam_choose_destination = 1;
        }
        if (f->roam_choose_destination) {
            f->roam_ticks_until_next_turn = 100;
            f->direction = f->previous_tile_direction;
        } else {
            return;
        }
    }
    // no destination: walk to end of tile and pick a direction
    while (num_ticks > 0) {
        num_ticks--;
        f->progress_on_tile++;
        if (f->progress_on_tile < 15) {
            advance_tick_movement(f);
        } else {
            f->progress_on_tile = 15;
            f->roam_random_counter++;
            int came_from_direction = (f->previous_tile_direction + 4) % 8;
            if (figure_service_provide_coverage(f)) {
                return;
            }
            int road_tiles[8];
            road_tiles[1] = road_tiles[3] = road_tiles[5] = road_tiles[7] = 0;
            road_tiles[0] = get_adjacent_road_tile_for_roaming(f->grid_offset + map_grid_delta(0, -1));
            road_tiles[2] = get_adjacent_road_tile_for_roaming(f->grid_offset + map_grid_delta(1, 0));
            road_tiles[4] = get_adjacent_road_tile_for_roaming(f->grid_offset + map_grid_delta(0, 1));
            road_tiles[6] = get_adjacent_road_tile_for_roaming(f->grid_offset + map_grid_delta(-1, 0));
            int adjacent_road_tiles = road_tiles[0] + road_tiles[2] + road_tiles[4] + road_tiles[6];
            if (adjacent_road_tiles == 3 && map_get_diagonal_road_tiles_for_roaming(f->grid_offset, road_tiles) >= 5) {
                // go in the straight direction of a double-wide road
                adjacent_road_tiles = 2;
                if (came_from_direction == DIR_0_TOP || came_from_direction == DIR_4_BOTTOM) {
                    if (road_tiles[0] && road_tiles[4]) {
                        road_tiles[2] = road_tiles[6] = 0;
                    } else {
                        road_tiles[0] = road_tiles[4] = 0;
                    }
                } else {
                    if (road_tiles[2] && road_tiles[6]) {
                        road_tiles[0] = road_tiles[4] = 0;
                    } else {
                        road_tiles[2] = road_tiles[6] = 0;
                    }
                }
            }
            if (adjacent_road_tiles == 4 && map_get_diagonal_road_tiles_for_roaming(f->grid_offset, road_tiles) >= 8) {
                // go straight on when all surrounding tiles are road
                adjacent_road_tiles = 2;
                if (came_from_direction == DIR_0_TOP || came_from_direction == DIR_4_BOTTOM) {
                    road_tiles[2] = road_tiles[6] = 0;
                } else {
                    road_tiles[0] = road_tiles[4] = 0;
                }
            }
            if (adjacent_road_tiles <= 0) {
                f->roam_length = figure_properties[f->type].max_roam_length; // end roaming walk
                return;
            }
            if (adjacent_road_tiles == 1) {
                int dir = 0;
                do {
                    f->direction = 2 * dir;
                } while (!road_tiles[f->direction] && dir++ < 4);
            } else if (adjacent_road_tiles == 2) {
                if (f->roam_ticks_until_next_turn == -1) {
                    roam_set_direction(f);
                    came_from_direction = -1;
                }
                // 1. continue in the same direction
                // 2. turn in the direction given by roam_turn_direction
                int dir = 0;
                do {
                    if (road_tiles[f->direction] && f->direction != came_from_direction) {
                        break;
                    }
                    f->direction += f->roam_turn_direction;
                    if (f->direction > 6) f->direction = 0;
                    if (f->direction < 0) f->direction = 6;
                } while (dir++ < 4);
            } else { // > 2 road tiles
                f->direction = (f->roam_random_counter + random.items[f->grid_offset]) & 6;
                if (!road_tiles[f->direction] || f->direction == came_from_direction) {
                    f->roam_ticks_until_next_turn--;
                    if (f->roam_ticks_until_next_turn <= 0) {
                        roam_set_direction(f);
                        came_from_direction = -1;
                    }
                    int dir = 0;
                    do {
                        if (road_tiles[f->direction] && f->direction != came_from_direction) {
                            break;
                        }
                        f->direction += f->roam_turn_direction;
                        if (f->direction > 6) f->direction = 0;
                        if (f->direction < 0) f->direction = 6;
                    } while (dir++ < 4);
                }
            }
            f->routing_path_current_tile++;
            f->previous_tile_direction = f->direction;
            f->progress_on_tile = 0;
            move_to_next_tile(f);
            advance_tick_movement(f);
        }
    }
}

static void roamer_action(struct figure_t *f, int num_ticks)
{
    switch (f->action_state) {
        case FIGURE_ACTION_ROAMING:
            f->is_invisible = 0;
            f->roam_length++;
            if (f->roam_length >= figure_properties[f->type].max_roam_length) {
                int x, y;
                struct building_t *b = &all_buildings[f->building_id];
                if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x, &y)) {
                    f->action_state = FIGURE_ACTION_ROAMER_RETURNING;
                    f->destination_x = x;
                    f->destination_y = y;
                    figure_route_remove(f);
                    f->roam_length = 0;
                } else {
                    figure_delete(f);
                    return;
                }
            }
            figure_movement_roam_ticks(f, num_ticks);
            break;
        case FIGURE_ACTION_ROAMER_RETURNING:
            walk_ticks(f, num_ticks, 0);
            if (f->direction == DIR_FIGURE_AT_DESTINATION ||
                f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                figure_delete(f);
                return;
            }
            break;
    }
}

static int figure_image_direction(struct figure_t *f)
{
    int dir = f->direction - view_data.orientation;
    if (dir < 0) {
        dir += 8;
    }
    return dir;
}

static void figure_image_increase_offset(struct figure_t *f, int max)
{
    f->image_offset++;
    if (f->image_offset >= max) {
        f->image_offset = 0;
    }
}

static void culture_action(struct figure_t *f, int group)
{
    struct building_t *b = &all_buildings[f->building_id];
    if (b->state != BUILDING_STATE_IN_USE || b->figure_id != f->id) {
        figure_delete(f);
        return;
    }
    figure_image_increase_offset(f, 12);
    roamer_action(f, 1);
    f->image_id = image_data_s.group_image_ids[group] + figure_image_direction(f) + 8 * f->image_offset;
}

static void figure_play_die_sound(struct figure_t *f)
{
    int is_combatant = 0;
    int is_citizen = 0;
    switch (f->type) {
        case FIGURE_WOLF:
            play_sound_effect(SOUND_EFFECT_WOLF_DIE);
            break;
        case FIGURE_SHEEP:
            play_sound_effect(SOUND_EFFECT_SHEEP_DIE);
            break;
        case FIGURE_ZEBRA:
            play_sound_effect(SOUND_EFFECT_ZEBRA_DIE);
            break;
        case FIGURE_LION_TAMER:
            play_sound_effect(SOUND_EFFECT_LION_DIE);
            break;
        case FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT:
            play_sound_effect(SOUND_EFFECT_ELEPHANT_DIE);
            break;
        case FIGURE_ENEMY_BRITON_CHARIOT:
        case FIGURE_ENEMY_CELT_CHARIOT:
        case FIGURE_ENEMY_PICT_CHARIOT:
        case FIGURE_ENEMY_HUN_MOUNTED_ARCHER:
        case FIGURE_ENEMY_GOTH_MOUNTED_ARCHER:
        case FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER:
            play_sound_effect(SOUND_EFFECT_HORSE2);
            break;
        case FIGURE_ENEMY_EGYPTIAN_CAMEL:
            play_sound_effect(SOUND_EFFECT_CAMEL);
            break;
        case FIGURE_NATIVE_TRADER:
        case FIGURE_TRADE_CARAVAN:
        case FIGURE_TRADE_CARAVAN_DONKEY:
            break;
        case FIGURE_PREFECT:
        case FIGURE_FORT_JAVELIN:
        case FIGURE_FORT_MOUNTED:
        case FIGURE_FORT_LEGIONARY:
        case FIGURE_GLADIATOR:
        case FIGURE_INDIGENOUS_NATIVE:
        case FIGURE_TOWER_SENTRY:
        case FIGURE_ENEMY_GLADIATOR:
        case FIGURE_ENEMY_BARBARIAN_SWORDSMAN:
        case FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN:
        case FIGURE_ENEMY_BRITON_SWORDSMAN:
        case FIGURE_ENEMY_CELT_SWORDSMAN:
        case FIGURE_ENEMY_PICT_SWORDSMAN:
        case FIGURE_ENEMY_EGYPTIAN_SWORDSMAN:
        case FIGURE_ENEMY_ETRUSCAN_SWORDSMAN:
        case FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER:
        case FIGURE_ENEMY_SAMNITE_SWORDSMAN:
        case FIGURE_ENEMY_SAMNITE_SPEAR_THROWER:
        case FIGURE_ENEMY_GAUL_SWORDSMAN:
        case FIGURE_ENEMY_GAUL_AXEMAN:
        case FIGURE_ENEMY_HELVETIUS_SWORDSMAN:
        case FIGURE_ENEMY_HELVETIUS_AXEMAN:
        case FIGURE_ENEMY_HUN_SWORDSMAN:
        case FIGURE_ENEMY_GOTH_SWORDSMAN:
        case FIGURE_ENEMY_VISIGOTH_SWORDSMAN:
        case FIGURE_ENEMY_GREEK_SWORDSMAN:
        case FIGURE_ENEMY_GREEK_SPEAR_THROWER:
        case FIGURE_ENEMY_MACEDONIAN_SWORDSMAN:
        case FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER:
        case FIGURE_ENEMY_NUMIDIAN_SWORDSMAN:
        case FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER:
        case FIGURE_ENEMY_PERGAMUM_SWORDSMAN:
        case FIGURE_ENEMY_PERGAMUM_ARCHER:
        case FIGURE_ENEMY_IBERIAN_SWORDSMAN:
        case FIGURE_ENEMY_IBERIAN_SPEAR_THROWER:
        case FIGURE_ENEMY_JUDEAN_SWORDSMAN:
        case FIGURE_ENEMY_JUDEAN_SPEAR_THROWER:
        case FIGURE_ENEMY_SELEUCID_SWORDSMAN:
        case FIGURE_ENEMY_SELEUCID_SPEAR_THROWER:
        case FIGURE_ENEMY_CAESAR_JAVELIN:
        case FIGURE_ENEMY_CAESAR_MOUNTED:
        case FIGURE_ENEMY_CAESAR_LEGIONARY:
            is_combatant = 1;
            break;
        default:
            is_citizen = 1;
            break;
    }
    city_data.sound.die_citizen++;
    if (is_combatant) {
        city_data.sound.die_soldier++;
        if (city_data.sound.die_soldier >= 4) {
            city_data.sound.die_soldier = 0;
        }
        play_sound_effect(SOUND_EFFECT_SOLDIER_DIE + city_data.sound.die_soldier);
    } else if (is_citizen) {
        if (city_data.sound.die_citizen >= 4) {
            city_data.sound.die_citizen = 0;
        }
        play_sound_effect(SOUND_EFFECT_CITIZEN_DIE + city_data.sound.die_citizen);
    }
}

static void update_formation_morale_after_death(struct formation_t *m)
{
    int pct_dead = calc_percentage(1, m->num_figures);
    int morale;
    if (pct_dead < 8) {
        morale = -5;
    } else if (pct_dead < 10) {
        morale = -7;
    } else if (pct_dead < 14) {
        morale = -10;
    } else if (pct_dead < 20) {
        morale = -12;
    } else if (pct_dead < 30) {
        morale = -15;
    } else {
        morale = -20;
    }
    m->morale = calc_bound(m->morale + morale, 0, m->max_morale);
}

static int figure__targeted_by_ranged_unit(struct figure_t *f, struct figure_t *ranged_targeter)
{
    for (int i = 0; i < MAX_RANGED_TARGETERS_PER_UNIT; i++) {
        if (f->ranged_targeter_ids[i] == ranged_targeter->id) {
            return 1;
        }
    }
    return 0;
}

static void figure__remove_melee_targeter_from_list(struct figure_t *f, struct figure_t *melee_targeter)
{
    for (int i = 0; i < MAX_MELEE_TARGETERS_PER_UNIT; i++) {
        if (f->melee_targeter_ids[i] == melee_targeter->id) {
            f->melee_targeter_ids[i] = 0;
        }
    }
}

static void clear_targeting_on_unit_death(struct figure_t *dead_unit)
{
    // remove unit from its target's targeter lists
    struct figure_t *target = &figures[dead_unit->target_figure_id];
    figure__remove_melee_targeter_from_list(target, dead_unit);
    figure__remove_ranged_targeter_from_list(target, dead_unit);

    // reset target of all opponents targeting the unit; remove unit from melee combatant list of all opponents fighting it
    for (int i = 0; i < MAX_FIGURES; i++) {
        struct figure_t *opponent = &figures[i];
        if (figure_is_alive(opponent)) {
            if (opponent->target_figure_id == dead_unit->id) {
                opponent->target_figure_id = 0;
            }
            for (int j = 0; j < MAX_MELEE_COMBATANTS_PER_UNIT; j++) {
                if (opponent->melee_combatant_ids[j] == dead_unit->id) {
                    opponent->melee_combatant_ids[j] = 0;
                    opponent->num_melee_combatants--;
                }
            }
        }
    }
}

static void missile_hit_target(struct figure_t *projectile, struct figure_t *target)
{
    struct figure_t *shooter = &figures[projectile->building_id];
    int damage_inflicted = (figure_properties[shooter->type].missile_attack_value + figure_properties[projectile->type].missile_attack_value) - figure_properties[target->type].missile_defense_value;
    if (damage_inflicted < 0) {
        damage_inflicted = 0;
    }
    if (projectile->type != FIGURE_BOLT
        && ((target->type == FIGURE_FORT_LEGIONARY && legion_formations[target->formation_id].layout == FORMATION_TORTOISE)
            || (target->type == FIGURE_ENEMY_CAESAR_LEGIONARY && enemy_formations[target->formation_id].layout == FORMATION_TORTOISE))
            && target->figure_is_halted) {
        damage_inflicted = 1;
    }
    int target_damage = damage_inflicted + target->damage;
    if (target_damage <= figure_properties[target->type].max_damage) {
        target->damage = target_damage;
    } else { // kill target
        target->damage = figure_properties[target->type].max_damage + 1;
        target->is_corpse = 1;
        target->is_targetable = 0;
        target->wait_ticks = 0;
        figure_play_die_sound(target);
        if (figure_properties[target->type].is_player_legion_unit) {
            update_formation_morale_after_death(&legion_formations[target->formation_id]);
        } else {
            update_formation_morale_after_death(&enemy_formations[target->formation_id]);
        }
        clear_targeting_on_unit_death(target);
    }
    if (figure_properties[target->type].is_player_legion_unit) {
        legion_formations[target->formation_id].missile_attack_timeout = 6;
    } else if (figure_properties[target->type].is_herd_animal) {
        herd_formations[target->formation_id].missile_attack_timeout = 6;
    } else if (figure_properties[target->type].is_enemy_unit || figure_properties[target->type].is_caesar_legion_unit) {
        enemy_formations[target->formation_id].missile_attack_timeout = 6;
    }
    // clear targeting
    shooter->target_figure_id = 0;
    figure__remove_ranged_targeter_from_list(target, shooter);
    figure_delete(projectile);
}

static int get_target_on_tile(struct figure_t *projectile)
{
    struct figure_t *shooter = &figures[projectile->building_id];
    if (map_figures.items[projectile->grid_offset] > 0) {
        int figure_id = map_figures.items[projectile->grid_offset];
        while (figure_id) {
            struct figure_t *target = &figures[figure_id];
            if (figure_is_alive(target) && target->is_targetable) {
                if (figure_properties[shooter->type].is_friendly_armed_unit || figure_properties[shooter->type].is_player_legion_unit) {
                    if (is_valid_target_for_player_unit(target)) {
                        return target->id;
                    }
                } else if (figure_properties[shooter->type].is_enemy_unit) {
                    if (is_valid_target_for_enemy_unit(target)) {
                        return target->id;
                    }
                }
            }
            figure_id = target->next_figure_id_on_same_tile;
        }
    }
    return 0;
}

static int closest_house_with_room(int x, int y)
{
    int min_dist = 1000;
    int min_building_id = 0;
    for (int i = 1; i <= extra.highest_id_in_use; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_IN_USE && b->house_size
            && b->house_population_room > 0) {
            if (!b->immigrant_figure_id) {
                int dist = calc_maximum_distance(x, y, b->x, b->y);
                if (dist < min_dist) {
                    min_dist = dist;
                    min_building_id = i;
                }
            }
        }
    }
    return min_building_id;
}

static void figure_image_set_cart_offset(struct figure_t *f, int direction)
{
    f->x_offset_cart = CART_OFFSETS_X[direction];
    f->y_offset_cart = CART_OFFSETS_Y[direction];
}

static void update_migrant_dir_and_image(struct figure_t *f)
{
    figure_image_increase_offset(f, 12);
    f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_MIGRANT] + figure_image_direction(f) + 8 * f->image_offset;
    if (f->action_state == FIGURE_ACTION_IMMIGRANT_ARRIVING || f->action_state == FIGURE_ACTION_EMIGRANT_LEAVING) {
        int dir = figure_image_direction(f);
        f->cart_image_id = image_data_s.group_image_ids[GROUP_FIGURE_MIGRANT_CART] + dir;
        figure_image_set_cart_offset(f, (dir + 4) % 8);
    }
}

static int create_delivery_boy(int leader_id, struct figure_t *f)
{
    struct figure_t *boy = figure_create(FIGURE_DELIVERY_BOY, f->x, f->y, 0);
    boy->is_targetable = 1;
    boy->terrain_usage = TERRAIN_USAGE_ROADS;
    boy->leading_figure_id = leader_id;
    boy->collecting_item_id = f->collecting_item_id;
    boy->building_id = f->building_id;
    return boy->id;
}

static int fight_fire(struct figure_t *f)
{
    if (!building_list_data.burning.size) {
        return 0;
    }
    switch (f->action_state) {
        case FIGURE_ACTION_PREFECT_CREATED:
        case FIGURE_ACTION_PREFECT_ENTERING_EXITING:
        case FIGURE_ACTION_PREFECT_GOING_TO_FIRE:
        case FIGURE_ACTION_PREFECT_AT_FIRE:
            return 0;
    }
    f->wait_ticks_missile++;
    if (f->wait_ticks_missile < 20) {
        return 0;
    }
    int distance;
    int ruin_id = 0;
    int min_occupied_building_id = 0;
    int min_occupied_dist = distance = 10000;
    int *burning = building_list_data.burning.items;
    for (int i = 0; i < building_list_data.burning.size; i++) {
        int building_id = burning[i];
        struct building_t *b = &all_buildings[building_id];
        if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_BURNING_RUIN && !b->ruin_has_plague) {
            int dist = calc_maximum_distance(f->x, f->y, b->x, b->y);
            if (b->figure_id4) {
                if (dist < min_occupied_dist) {
                    min_occupied_dist = dist;
                    min_occupied_building_id = building_id;
                }
            } else if (dist < distance) {
                distance = dist;
                ruin_id = building_id;
            }
        }
    }
    if (!ruin_id && min_occupied_dist <= 2) {
        ruin_id = min_occupied_building_id;
        distance = 2;
    }
    if (ruin_id > 0 && distance <= 25) {
        struct building_t *ruin = &all_buildings[ruin_id];
        f->wait_ticks_missile = 0;
        f->action_state = FIGURE_ACTION_PREFECT_GOING_TO_FIRE;
        f->destination_x = ruin->road_access_x;
        f->destination_y = ruin->road_access_y;
        f->destination_building_id = ruin_id;
        figure_route_remove(f);
        ruin->figure_id4 = f->id;
        return 1;
    }
    return 0;
}

static int determine_destination(int x, int y, int type1, int type2)
{
    int road_network = network.items[map_grid_offset(x, y)];
    building_list_data.small.size = 0;

    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE) {
            continue;
        }
        if (b->type != type1 && b->type != type2) {
            continue;
        }
        if (b->road_network_id == road_network) {
            if (b->type == BUILDING_HIPPODROME && b->prev_part_building_id) {
                continue;
            }
            building_list_small_add(i);
        }
    }
    if (building_list_data.small.size <= 0) {
        return 0;
    }
    int min_building_id = 0;
    int min_distance = 10000;
    for (int i = 0; i < building_list_data.small.size; i++) {
        struct building_t *b = &all_buildings[building_list_data.small.items[i]];
        int days_left;
        if (b->type == type1) {
            days_left = b->data.entertainment.days1;
        } else if (b->type == type2) {
            days_left = b->data.entertainment.days2;
        } else {
            days_left = 0;
        }
        int dist = days_left + calc_maximum_distance(x, y, b->x, b->y);
        if (dist < min_distance) {
            min_distance = dist;
            min_building_id = building_list_data.small.items[i];
        }
    }
    return min_building_id;
}

static void figure_create_missile(struct figure_t *shooter, struct map_point_t *target_tile, int type)
{
    struct figure_t *missile = figure_create(type, shooter->x, shooter->y, DIR_0_TOP);
    if (missile->id) {
        missile->missile_offset = type == FIGURE_BOLT ? 60 : 10;
        missile->building_id = shooter->id;
        missile->destination_x = target_tile->x;
        missile->destination_y = target_tile->y;
        figure_movement_set_cross_country_direction(missile, missile->cross_country_x, missile->cross_country_y, 15 * target_tile->x, 15 * target_tile->y, 1);
    }
}

static void shoot_enemy_missile(struct figure_t *f, struct map_point_t *tile)
{
    f->is_shooting = 1;
    f->attack_image_offset = 1;
    figure_create_missile(f, tile, figure_properties[f->type].missile_type);
    if (figure_properties[f->type].missile_type == FIGURE_ARROW) {
        play_sound_effect(SOUND_EFFECT_ARROW);
    }
    f->wait_ticks_missile = 0;
    // clear targeting
    figure__remove_ranged_targeter_from_list(&figures[f->target_figure_id], f);
    f->target_figure_id = 0;
}

static void spawn_enemy(struct figure_t *f, struct formation_t *m)
{
    if (f->wait_ticks) {
        f->wait_ticks--;
        if (!f->wait_ticks) {
            if (f->index_in_formation % 4 < 1) {
                if (m->layout == FORMATION_ENEMY_MOB) {
                    play_speech_file("wavs/drums.wav");
                } else {
                    play_speech_file("wavs/horn1.wav");
                }
            }
            f->is_invisible = 0;
            f->action_state = FIGURE_ACTION_ENEMY_ADVANCING;
        }
    }
}

static void map_figure_update(struct figure_t *f)
{
    if (!map_grid_is_valid_offset(f->grid_offset)) {
        return;
    }
    struct figure_t *next = &figures[map_figures.items[f->grid_offset]];
    while (next->id) {
        if (next->id == f->id) {
            return;
        }
        next = &figures[next->next_figure_id_on_same_tile];
    }
}

static int target_ranged_targeter_list_full(struct figure_t *target)
{
    for (int j = 0; j < MAX_RANGED_TARGETERS_PER_UNIT; j++) {
        if (!target->ranged_targeter_ids[j]) {
            return 0;
        }
    }
    return 1;
}

static void update_ranged_targeting(struct figure_t *shooter, struct figure_t *target, struct map_point_t *tile)
{
    if (shooter->target_figure_id && shooter->target_figure_id != target->id) {
        // if switching targets, remove targeter from previous target's ranged targeters list
        struct figure_t *previous_target = &figures[shooter->target_figure_id];
        figure__remove_ranged_targeter_from_list(previous_target, shooter);
    }
    shooter->target_figure_id = target->id;
    if (!figure__targeted_by_ranged_unit(target, shooter)) {
        // update new target's ranged targeters list
        for (int i = 0; i < MAX_RANGED_TARGETERS_PER_UNIT; i++) {
            if (!target->ranged_targeter_ids[i]) {
                target->ranged_targeter_ids[i] = shooter->id;
                break;
            }
        };
    }
    tile->x = target->x;
    tile->y = target->y;
}

static int set_missile_target(struct figure_t *shooter, struct map_point_t *tile)
{
    int closest_target_distance = figure_properties[shooter->type].max_range;
    struct figure_t *closest_eligible_target = 0;
    struct figure_t *closest_eligible_overhit_target = 0;
    for (int i = 1; i < MAX_FIGURES; i++) {
        struct figure_t *potential_target = &figures[i];
        if (!figure_is_alive(potential_target) || !potential_target->is_targetable) {
            continue;
        }
        int potential_target_distance = calc_maximum_distance(shooter->x, shooter->y, potential_target->x, potential_target->y);
        if ((potential_target_distance < closest_target_distance)) {
            // if potential target is the current target, it's eligible (could still end up being switched for a nearer one)
            if (figure__targeted_by_ranged_unit(potential_target, shooter)) {
                closest_target_distance = potential_target_distance;
                closest_eligible_target = potential_target;
                continue;
            }
            if (figure_properties[shooter->type].is_friendly_armed_unit || figure_properties[shooter->type].is_player_legion_unit) {
                if (is_valid_target_for_player_unit(potential_target) && can_see_target(shooter, potential_target)) {
                    if (shooter->is_military_trained && target_ranged_targeter_list_full(potential_target)) {
                        // prefer targets that aren't already aimed at to prevent overhit, but keep overhit targets as a second option
                        closest_eligible_overhit_target = potential_target;
                    } else {
                        closest_target_distance = potential_target_distance;
                        closest_eligible_target = potential_target;
                    }
                    continue;
                }
            } else if (figure_properties[shooter->type].is_enemy_unit) {
                // skip (closer) unarmed target if already targeting a dangerous foe
                if ((figure_properties[potential_target->type].is_unarmed_civilian_unit || figure_properties[potential_target->type].is_empire_trader || potential_target->type == FIGURE_NATIVE_TRADER)
                    && closest_eligible_target
                    && (figure_properties[closest_eligible_target->type].is_friendly_armed_unit || figure_properties[closest_eligible_target->type].is_player_legion_unit || closest_eligible_target->type == FIGURE_WOLF || figure_properties[closest_eligible_target->type].is_caesar_legion_unit)) {
                    continue;
                }
                if (is_valid_target_for_enemy_unit(potential_target) && can_see_target(shooter, potential_target)) {
                    if (target_ranged_targeter_list_full(potential_target)) {
                        // prefer targets that aren't already aimed at to prevent overhit, but keep overhit targets as a second option
                        closest_eligible_overhit_target = potential_target;
                    } else {
                        closest_target_distance = potential_target_distance;
                        closest_eligible_target = potential_target;
                    }
                    continue;
                }
            }
        }
    }
    if (closest_eligible_target) {
        update_ranged_targeting(shooter, closest_eligible_target, tile);
        return 1;
    } else if (closest_eligible_overhit_target) {
        update_ranged_targeting(shooter, closest_eligible_overhit_target, tile);
        return 1;
    }
    return 0;
}

static int calc_missile_shooter_direction(int x_from, int y_from, int x_to, int y_to)
{
    int dx = x_from > x_to ? x_from - x_to : x_to - x_from;
    int dy = y_from > y_to ? y_from - y_to : y_to - y_from;
    int percentage;
    if (dx > dy) {
        percentage = calc_percentage(dx, dy);
    } else if (dx == dy) {
        percentage = 100;
    } else {
        percentage = -calc_percentage(dy, dx);
    }
    if (x_from == x_to) {
        if (y_from < y_to) {
            return DIR_4_BOTTOM;
        } else {
            return DIR_0_TOP;
        }
    } else if (x_from > x_to) {
        if (y_from == y_to) {
            return DIR_6_LEFT;
        } else if (y_from > y_to) {
            if (percentage >= 400) {
                return DIR_6_LEFT;
            } else if (percentage > -400) {
                return DIR_7_TOP_LEFT;
            } else {
                return DIR_0_TOP;
            }
        } else {
            if (percentage >= 400) {
                return DIR_6_LEFT;
            } else if (percentage > -400) {
                return DIR_5_BOTTOM_LEFT;
            } else {
                return DIR_4_BOTTOM;
            }
        }
    } else { // x_from < x_to
        if (y_from == y_to) {
            return DIR_2_RIGHT;
        } else if (y_from > y_to) {
            if (percentage >= 400) {
                return DIR_2_RIGHT;
            } else if (percentage > -400) {
                return DIR_1_TOP_RIGHT;
            } else {
                return DIR_0_TOP;
            }
        } else {
            if (percentage >= 400) {
                return DIR_2_RIGHT;
            } else if (percentage > -400) {
                return DIR_3_BOTTOM_RIGHT;
            } else {
                return DIR_4_BOTTOM;
            }
        }
    }
}

static void ranged_enemy_action(struct figure_t *f)
{
    struct formation_t *m = &enemy_formations[f->formation_id];
    struct map_point_t tile = { -1, -1 };
    if (f->is_shooting) {
        f->attack_image_offset++;
        if (f->attack_image_offset > 100) {
            f->attack_image_offset = 0;
            f->is_shooting = 0;
        }
    } else {
        f->wait_ticks_missile++;
        if (f->wait_ticks_missile > 250) {
            f->wait_ticks_missile = 250;
        }
    }
    switch (f->action_state) {
        case FIGURE_ACTION_ENEMY_SPAWNING:
            spawn_enemy(f, m);
            break;
        case FIGURE_ACTION_ENEMY_REGROUPING:
            map_figure_update(f);
            f->image_offset = 0;
            if (f->wait_ticks_missile > figure_properties[f->type].missile_delay && set_missile_target(f, &tile)) {
                f->direction = calc_missile_shooter_direction(f->x, f->y, tile.x, tile.y);
                shoot_enemy_missile(f, &tile);
            }
            break;
        case FIGURE_ACTION_ENEMY_ADVANCING:
            f->destination_x = m->destination_x + FORMATION_LAYOUT_POSITION_X[m->layout][f->index_in_formation];
            f->destination_y = m->destination_y + FORMATION_LAYOUT_POSITION_Y[m->layout][f->index_in_formation];
            walk_ticks(f, f->speed_multiplier, 0);
            if ((f->type == FIGURE_ENEMY_HUN_MOUNTED_ARCHER || f->type == FIGURE_ENEMY_GOTH_MOUNTED_ARCHER || f->type == FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER)
            && f->wait_ticks_missile > figure_properties[f->type].missile_delay
            && set_missile_target(f, &tile)) {
                shoot_enemy_missile(f, &tile);
            }
            if (f->direction == DIR_FIGURE_AT_DESTINATION
                || f->direction == DIR_FIGURE_REROUTE
                || f->direction == DIR_FIGURE_LOST) {
                figure_route_remove(f);
                f->action_state = FIGURE_ACTION_ENEMY_REGROUPING;
            }
            break;
        case FIGURE_ACTION_ENEMY_ENGAGED:
            if (f->target_figure_id && calc_maximum_distance(f->x, f->y, f->destination_x, f->destination_y) < figure_properties[f->type].max_range) {
                figure_route_remove(f);
                f->destination_x = f->x;
                f->destination_y = f->y;
                f->image_offset = 0;
                if (f->wait_ticks_missile > figure_properties[f->type].missile_delay && set_missile_target(f, &tile)) {
                    f->direction = calc_missile_shooter_direction(f->x, f->y, tile.x, tile.y);
                    shoot_enemy_missile(f, &tile);
                    break;
                }
            } else {
                walk_ticks(f, f->speed_multiplier, 0);
                if (f->direction == DIR_FIGURE_AT_DESTINATION
                    || f->direction == DIR_FIGURE_REROUTE
                    || f->direction == DIR_FIGURE_LOST) {
                    figure_route_remove(f);
                    f->action_state = FIGURE_ACTION_ENEMY_REGROUPING;
                }
            }
            break;
    }
}

static int figure__targeted_by_melee_unit(struct figure_t *f, struct figure_t *melee_targeter)
{
    for (int i = 0; i < MAX_MELEE_TARGETERS_PER_UNIT; i++) {
        if (f->melee_targeter_ids[i] == melee_targeter->id) {
            return 1;
        }
    }
    return 0;
}

static struct figure_t *melee_unit__set_closest_target(struct figure_t *f)
{
    struct figure_t *closest_eligible_target = 0;
    int closest_target_distance;
    switch (f->type) {
        case FIGURE_PREFECT:
            closest_target_distance = PREFECT_TARGET_ACQUISITION_RANGE;
            break;
        case FIGURE_WOLF:
            closest_target_distance = 5;
            break;
        default:
            closest_target_distance = 20;
            break;
    }
    for (int i = 1; i < MAX_FIGURES; i++) {
        struct figure_t *potential_target = &figures[i];
        if (!figure_is_alive(potential_target) || !potential_target->is_targetable) {
            continue;
        }
        int potential_target_distance = calc_maximum_distance(f->x, f->y, potential_target->x, potential_target->y);
        if (potential_target_distance < closest_target_distance) {
            // skip potential enemy target if its targeter list is full, unless the current targeter is already in it
            int potential_target_melee_targeter_list_full = 1;
            for (int j = 0; j < MAX_MELEE_TARGETERS_PER_UNIT; j++) {
                if (!potential_target->melee_targeter_ids[j]) {
                    potential_target_melee_targeter_list_full = 0;
                    break;
                }
            }
            if (potential_target_melee_targeter_list_full) {
                if (figure__targeted_by_melee_unit(potential_target, f)) {
                    closest_target_distance = potential_target_distance;
                    closest_eligible_target = potential_target;
                    // the remaining criteria (friendly, enemy) have already been checked on previous targeting, continue to next potential target
                    continue;
                } else {
                    continue;
                }
            }
            if (figure_properties[f->type].is_friendly_armed_unit || figure_properties[f->type].is_player_legion_unit) {
                if (is_valid_target_for_player_unit(potential_target) && can_see_target(f, potential_target)) { // can_see_target is expensive, call it last (allows for short-circuiting)
                    closest_target_distance = potential_target_distance;
                    closest_eligible_target = potential_target;
                    continue;
                }
            } else if (f->type == FIGURE_WOLF) {
                if (potential_target->type != FIGURE_WOLF && can_see_target(f, potential_target)) {
                    closest_target_distance = potential_target_distance;
                    closest_eligible_target = potential_target;
                    continue;
                }
            } else if (figure_properties[f->type].is_enemy_unit) {
                if (is_valid_target_for_enemy_unit(potential_target) && can_see_target(f, potential_target)) {
                    closest_target_distance = potential_target_distance;
                    closest_eligible_target = potential_target;
                    continue;
                }
            } else if (figure_properties[f->type].is_caesar_legion_unit) {
                if (is_valid_target_for_caesar_unit(potential_target) && can_see_target(f, potential_target)) {
                    closest_target_distance = potential_target_distance;
                    closest_eligible_target = potential_target;
                    continue;
                }
            }
        }
    }
    if (closest_eligible_target) {
        // set target and destination for figure
        if (f->target_figure_id && f->target_figure_id != closest_eligible_target->id) {
            // if switching targets, remove targeter from previous target's melee targeters list
            struct figure_t *previous_target = &figures[f->target_figure_id];
            figure__remove_melee_targeter_from_list(previous_target, f);
        }
        f->target_figure_id = closest_eligible_target->id;
        f->destination_x = closest_eligible_target->x;
        f->destination_y = closest_eligible_target->y;
        figure_route_remove(f);
        if (!figure__targeted_by_melee_unit(closest_eligible_target, f)) {
            // update new target's melee targeter list
            for (int i = 0; i < MAX_MELEE_TARGETERS_PER_UNIT; i++) {
                if (!closest_eligible_target->melee_targeter_ids[i]) {
                    closest_eligible_target->melee_targeter_ids[i] = f->id;
                    break;
                }
            };
        }
    }
    return closest_eligible_target;
}

static void melee_enemy_action(struct figure_t *f)
{
    struct formation_t *m = &enemy_formations[f->formation_id];
    switch (f->action_state) {
        case FIGURE_ACTION_ENEMY_SPAWNING:
            spawn_enemy(f, m);
            break;
        case FIGURE_ACTION_ENEMY_REGROUPING:
            map_figure_update(f);
            f->image_offset = 0;
            break;
        case FIGURE_ACTION_ENEMY_ADVANCING:
            f->destination_x = m->destination_x + FORMATION_LAYOUT_POSITION_X[m->layout][f->index_in_formation];
            f->destination_y = m->destination_y + FORMATION_LAYOUT_POSITION_Y[m->layout][f->index_in_formation];
            walk_ticks(f, f->speed_multiplier, 0);
            if (f->direction == DIR_FIGURE_AT_DESTINATION
                || f->direction == DIR_FIGURE_REROUTE
                || f->direction == DIR_FIGURE_LOST) {
                figure_route_remove(f);
                f->action_state = FIGURE_ACTION_ENEMY_REGROUPING;
            }
            break;
        case FIGURE_ACTION_ENEMY_ENGAGED:
        {
            struct figure_t *target_unit = melee_unit__set_closest_target(f);
            if (target_unit) {
                f->destination_x = target_unit->x;
                f->destination_y = target_unit->y;
                walk_ticks(f, f->speed_multiplier, 0);
            } else {
                walk_ticks(f, f->speed_multiplier, 0);
            }
            if (f->direction == DIR_FIGURE_AT_DESTINATION
                || f->direction == DIR_FIGURE_REROUTE
                || f->direction == DIR_FIGURE_LOST) {
                figure_route_remove(f);
                f->action_state = FIGURE_ACTION_ENEMY_REGROUPING;
            }
            break;
        }
    }
}

static void figure_editor_flag_action(struct figure_t *f)
{
    figure_image_increase_offset(f, 16);
    f->image_id = MAP_FLAG_IMG_ID + f->image_offset / 2;
    map_figure_delete(f);

    struct map_point_t point = { 0, 0 };
    int image_base = image_data_s.group_image_ids[GROUP_FIGURE_MAP_FLAG_ICONS];
    if (f->resource_id == MAP_FLAG_ENTRY) {
        point.x = scenario.entry_point.x;
        point.y = scenario.entry_point.y;
        f->cart_image_id = image_base + 2;
    } else if (f->resource_id == MAP_FLAG_EXIT) {
        point.x = scenario.exit_point.x;
        point.y = scenario.exit_point.y;
        f->cart_image_id = image_base + 3;
    } else if (f->resource_id == MAP_FLAG_RIVER_ENTRY) {
        point.x = scenario.river_entry_point.x;
        point.y = scenario.river_entry_point.y;
        f->cart_image_id = image_base + 4;
    } else if (f->resource_id == MAP_FLAG_RIVER_EXIT) {
        point.x = scenario.river_exit_point.x;
        point.y = scenario.river_exit_point.y;
        f->cart_image_id = image_base + 5;
    } else if (f->resource_id >= MAP_FLAG_EARTHQUAKE_MIN && f->resource_id <= MAP_FLAG_EARTHQUAKE_MAX) {
        point = scenario.earthquake_points[f->resource_id - MAP_FLAG_EARTHQUAKE_MIN];
        f->cart_image_id = image_base;
    } else if (f->resource_id >= MAP_FLAG_INVASION_MIN && f->resource_id <= MAP_FLAG_INVASION_MAX) {
        point = scenario.invasion_points[f->resource_id - MAP_FLAG_INVASION_MIN];
        f->cart_image_id = image_base + 1;
    } else if (f->resource_id >= MAP_FLAG_FISHING_MIN && f->resource_id <= MAP_FLAG_FISHING_MAX) {
        point = scenario.fishing_points[f->resource_id - MAP_FLAG_FISHING_MIN];
        f->cart_image_id = image_data_s.group_image_ids[GROUP_FIGURE_FORT_STANDARD_ICONS] + 3;
    } else if (f->resource_id >= MAP_FLAG_HERD_MIN && f->resource_id <= MAP_FLAG_HERD_MAX) {
        point = scenario.herd_points[f->resource_id - MAP_FLAG_HERD_MIN];
        f->cart_image_id = image_data_s.group_image_ids[GROUP_FIGURE_FORT_STANDARD_ICONS] + 4;
    }
    f->x = point.x;
    f->y = point.y;

    f->grid_offset = map_grid_offset(f->x, f->y);
    f->cross_country_x = 15 * f->x + 7;
    f->cross_country_y = 15 * f->y + 7;
    map_figure_add(f);
}

static void get_trade_center_location(struct figure_t *f, int *x, int *y)
{
    if (city_data.building.trade_center_building_id) {
        struct building_t *trade_center = &all_buildings[city_data.building.trade_center_building_id];
        *x = trade_center->x;
        *y = trade_center->y;
    } else {
        *x = f->x;
        *y = f->y;
    }
}

static int city_trade_next_docker_export_resource(void)
{
    city_data.trade.docker_export_resource++;
    if (city_data.trade.docker_export_resource >= RESOURCE_TYPES_MAX) {
        city_data.trade.docker_export_resource = RESOURCE_WHEAT;
    }
    return city_data.trade.docker_export_resource;
}

static int fetch_export_resource(struct figure_t *f, struct building_t *dock)
{
    int ship_id = dock->data.dock.trade_ship_id;
    if (!ship_id) {
        return 0;
    }
    struct figure_t *ship = &figures[ship_id];
    if (ship->action_state != FIGURE_ACTION_TRADE_SHIP_MOORED || ship->trader_amount_bought >= 12) {
        return 0;
    }
    int x, y;
    get_trade_center_location(f, &x, &y);
    struct map_point_t tile;
    int exportable[RESOURCE_TYPES_MAX];
    exportable[RESOURCE_NONE] = 0;
    for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
        exportable[r] = can_export_resource_to_trade_city(ship->empire_city_id, r);
    }
    int resource = city_trade_next_docker_export_resource();
    for (int i = RESOURCE_WHEAT; i < RESOURCE_TYPES_MAX && !exportable[resource]; i++) {
        resource = city_trade_next_docker_export_resource();
    }
    int min_building_id = 0;
    if (exportable[resource]) {
        int min_distance = 10000;
        for (int i = 1; i < MAX_BUILDINGS; i++) {
            struct building_t *b = &all_buildings[i];
            if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_WAREHOUSE) {
                continue;
            }
            if (!b->has_road_access) {
                continue;
            }
            if (b->road_network_id != dock->road_network_id) {
                continue;
            }
            int distance_penalty = 32;
            struct building_t *space = b;
            for (int s = 0; s < 8; s++) {
                space = &all_buildings[space->next_part_building_id];
                if (space->id && space->subtype.warehouse_resource_id == resource && space->loads_stored > 0) {
                    distance_penalty--;
                }
            }
            if (distance_penalty < 32) {
                int distance = calc_maximum_distance(b->x, b->y, x, y);
                // prefer fuller warehouse
                distance += distance_penalty;
                if (distance < min_distance) {
                    min_distance = distance;
                    min_building_id = i;
                }
            }
        }
        if (min_building_id) {
            struct building_t *min = &all_buildings[min_building_id];
            if (map_has_road_access(min->x, min->y, 3, &tile) && min->has_road_access == 1) {
                tile.x = min->x;
                tile.y = min->y;
            }
        }
    }
    if (!min_building_id) {
        return 0;
    }
    ship->trader_amount_bought++;
    f->destination_building_id = min_building_id;
    f->action_state = FIGURE_ACTION_DOCKER_EXPORT_GOING_TO_WAREHOUSE;
    f->wait_ticks = 0;
    f->destination_x = tile.x;
    f->destination_y = tile.y;
    f->resource_id = resource;
    return 1;
}

static void generate_protestor(struct building_t *b)
{
    city_data.sentiment.protesters++;
    if (b->house_criminal_active < 1) {
        b->house_criminal_active = 1;
        int x_road, y_road;
        if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
            struct figure_t *f = figure_create(FIGURE_PROTESTER, x_road, y_road, DIR_4_BOTTOM);
            f->is_targetable = 1;
            f->terrain_usage = TERRAIN_USAGE_ROADS;
            f->wait_ticks = 10 + (b->house_figure_generation_delay & 0xf);
            city_data.ratings.peace_num_criminals++;
        }
    }
}

static void generate_mugger(struct building_t *b)
{
    city_data.sentiment.criminals++;
    if (b->house_criminal_active < 2) {
        b->house_criminal_active = 2;
        int x_road, y_road;
        if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
            struct figure_t *f = figure_create(FIGURE_CRIMINAL, x_road, y_road, DIR_4_BOTTOM);
            f->is_targetable = 1;
            f->terrain_usage = TERRAIN_USAGE_ROADS;
            f->wait_ticks = 10 + (b->house_figure_generation_delay & 0xf);
            city_data.ratings.peace_num_criminals++;
            if (city_data.finance.this_year.income.taxes > 20) {
                int money_stolen = city_data.finance.this_year.income.taxes / 4;
                if (money_stolen > 400) {
                    money_stolen = 400 - random_data.random1_7bit / 2;
                }
                city_message_post(1, MESSAGE_THEFT, money_stolen, f->grid_offset);
                city_data.finance.stolen_this_year += money_stolen;
                city_finance_process_misc(money_stolen);
            }
        }
    }
}

static void remove_resource_from_warehouse(struct figure_t *f)
{
    if (figure_is_alive(f)) {
        int err = building_warehouse_remove_resource(&all_buildings[f->building_id], f->resource_id, 1);
        if (err) {
            figure_delete(f);
        }
    }
}

static void building_workshop_add_raw_material(struct building_t *b)
{
    if (b->id > 0 && building_is_workshop(b->type)) {
        b->loads_stored++; // BUG: any raw material accepted
    }
}

static void reroute_cartpusher(struct figure_t *f)
{
    figure_route_remove(f);
    if (terrain_land_citizen.items[f->grid_offset] != CITIZEN_2_PASSABLE_TERRAIN) {
        f->action_state = FIGURE_ACTION_CARTPUSHER_INITIAL;
    }
    f->wait_ticks = 0;
}

static void update_image_cartpusher(struct figure_t *f)
{
    int dir = figure_image_normalize_direction(f->direction < 8 ? f->direction : f->previous_tile_direction);

    f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_CARTPUSHER] + dir + 8 * f->image_offset;
    if (f->cart_image_id) {
        f->cart_image_id += dir;
        figure_image_set_cart_offset(f, dir);
        if (f->loads_sold_or_carrying >= 8) {
            f->y_offset_cart -= 40;
        }
    }
}

static int building_granary_for_storing(int x, int y, int resource, int road_network_id, int force_on_stockpile, int *understaffed, struct map_point_t *dst)
{
    if (scenario.rome_supplies_wheat) {
        return 0;
    }
    if (!resource_is_food(resource)) {
        return 0;
    }
    if (city_data.resource.stockpiled[resource] && !force_on_stockpile) {
        return 0;
    }
    int min_dist = INFINITE;
    int min_building_id = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_GRANARY) {
            continue;
        }
        if (!b->has_road_access || b->road_network_id != road_network_id) {
            continue;
        }
        if (calc_percentage(b->num_workers, building_properties[b->type].n_laborers) < 100) {
            if (understaffed) {
                *understaffed += 1;
            }
            continue;
        }
        struct building_storage_t *s = &storages[b->storage_id].storage;
        if (s->resource_state[resource] == BUILDING_STORAGE_STATE_NOT_ACCEPTING || s->empty_all) {
            continue;
        }
        if (b->data.granary.resource_stored[RESOURCE_NONE] >= ONE_LOAD) {
            // there is room
            int dist = calc_maximum_distance(b->x + 1, b->y + 1, x, y);
            if (dist < min_dist) {
                min_dist = dist;
                min_building_id = i;
            }
        }
    }
    // deliver to center of granary
    struct building_t *min = &all_buildings[min_building_id];
    dst->x = min->x + 1;
    dst->y = min->y + 1;
    return min_building_id;
}

static int resource_to_workshop_type(int resource)
{
    switch (resource) {
        case RESOURCE_OLIVES:
            return WORKSHOP_OLIVES_TO_OIL;
        case RESOURCE_VINES:
            return WORKSHOP_VINES_TO_WINE;
        case RESOURCE_CLAY:
            return WORKSHOP_CLAY_TO_POTTERY;
        case RESOURCE_TIMBER:
            return WORKSHOP_TIMBER_TO_FURNITURE;
        case RESOURCE_IRON:
            return WORKSHOP_IRON_TO_WEAPONS;
        default:
            return WORKSHOP_NONE;
    }
}

static int building_get_workshop_for_raw_material_with_room(int x, int y, int resource, int road_network_id, struct map_point_t *dst)
{
    if (city_data.resource.stockpiled[resource]) {
        return 0;
    }
    int output_type = resource_to_workshop_type(resource);
    if (output_type == WORKSHOP_NONE) {
        return 0;
    }
    int min_dist = INFINITE;
    struct building_t *min_building = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE || !building_is_workshop(b->type)) {
            continue;
        }
        if (!b->has_road_access) {
            continue;
        }
        if (b->subtype.workshop_type == output_type && b->road_network_id == road_network_id && b->loads_stored < 2) {
            int dist = calc_maximum_distance(b->x, b->y, x, y);
            if (b->loads_stored > 0) {
                dist += 20;
            }
            if (dist < min_dist) {
                min_dist = dist;
                min_building = b;
            }
        }
    }
    if (min_building) {
        dst->x = min_building->road_access_x;
        dst->y = min_building->road_access_y;
        return min_building->id;
    }
    return 0;
}

static void set_destination(struct figure_t *f, int action, int building_id, int x_dst, int y_dst)
{
    f->destination_building_id = building_id;
    f->action_state = action;
    f->wait_ticks = 0;
    f->destination_x = x_dst;
    f->destination_y = y_dst;
}

static void set_cart_graphic(struct figure_t *f)
{
    f->cart_image_id = EMPTY_CART_IMG_ID + resource_images[f->resource_id].cart_img_id + resource_image_offset(f->resource_id, RESOURCE_IMAGE_CART);
}

static void map_terrain_add_with_radius(int x, int y, int size, int radius, int terrain)
{
    int x_min, y_min, x_max, y_max;
    map_grid_get_area(x, y, size, radius, &x_min, &y_min, &x_max, &y_max);

    for (int yy = y_min; yy <= y_max; yy++) {
        for (int xx = x_min; xx <= x_max; xx++) {
            terrain_grid.items[map_grid_offset(xx, yy)] |= terrain;
        }
    }
}

static int tower_sentry_shooting(struct figure_t *f)
{
    struct map_point_t tile = { -1, -1 };
    if (f->is_shooting) {
        f->attack_image_offset++;
        if (f->attack_image_offset > 100) {
            f->attack_image_offset = 0;
            f->is_shooting = 0;
        }
        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_TOWER_SENTRY] + figure_image_direction(f) + 96 + 8 * TOWER_SENTRY_FIRING_OFFSETS[f->attack_image_offset / 2];
        return 1;
    }
    if (!f->in_building_wait_ticks && f->wait_ticks_missile > figure_properties[f->type].missile_delay && set_missile_target(f, &tile)) {
        f->progress_on_tile = 15; // align to wall
        f->direction = calc_missile_shooter_direction(f->x, f->y, tile.x, tile.y);
        figure_create_missile(f, &tile, figure_properties[f->type].missile_type);
        f->wait_ticks_missile = 0;
        f->is_shooting = 1;
        return 1;
    }
    return 0;
}

static int figure_trade_caravan_can_sell(struct figure_t *trader, int warehouse_id, int city_id)
{
    struct building_t *warehouse = &all_buildings[warehouse_id];
    if (warehouse->type != BUILDING_WAREHOUSE) {
        return 0;
    }
    if (trader->loads_sold_or_carrying >= 8) {
        return 0;
    }
    struct building_storage_t *storage = &storages[warehouse->storage_id].storage;
    if (storage->empty_all) {
        return 0;
    }
    int num_importable = 0;
    for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
        if (storage->resource_state[r] != BUILDING_STORAGE_STATE_NOT_ACCEPTING) {
            if (can_import_resource_from_trade_city(city_id, r)) {
                num_importable++;
            }
        }
    }
    if (num_importable <= 0) {
        return 0;
    }
    int can_import = 0;
    int resource = city_data.trade.caravan_import_resource;
    if (storage->resource_state[resource] != BUILDING_STORAGE_STATE_NOT_ACCEPTING &&
        can_import_resource_from_trade_city(city_id, resource)) {
        can_import = 1;
    } else {
        for (int i = RESOURCE_WHEAT; i < RESOURCE_TYPES_MAX; i++) {
            resource = city_trade_next_caravan_import_resource();
            if (storage->resource_state[resource] != BUILDING_STORAGE_STATE_NOT_ACCEPTING &&
                    can_import_resource_from_trade_city(city_id, resource)) {
                can_import = 1;
                break;
            }
        }
    }
    if (can_import) {
        // at least one resource can be imported and accepted by this warehouse
        // check if warehouse can store any importable goods
        struct building_t *space = warehouse;
        for (int s = 0; s < 8; s++) {
            space = &all_buildings[space->next_part_building_id];
            if (space->id > 0 && space->loads_stored < 4) {
                if (!space->loads_stored) {
                    // empty space
                    return 1;
                }
                if (can_import_resource_from_trade_city(city_id, space->subtype.warehouse_resource_id)) {
                    return 1;
                }
            }
        }
    }
    return 0;
}

static int figure_trade_caravan_can_buy(struct figure_t *trader, int warehouse_id, int city_id)
{
    struct building_t *warehouse = &all_buildings[warehouse_id];
    if (warehouse->type != BUILDING_WAREHOUSE) {
        return 0;
    }
    if (trader->trader_amount_bought >= 8) {
        return 0;
    }
    struct building_t *space = warehouse;
    for (int i = 0; i < 8; i++) {
        space = &all_buildings[space->next_part_building_id];
        if (space->id > 0 && space->loads_stored > 0 &&
            can_export_resource_to_trade_city(city_id, space->subtype.warehouse_resource_id)) {
            return 1;
        }
    }
    return 0;
}

static void figure_create_homeless(int x, int y, int num_people)
{
    struct figure_t *f = figure_create(FIGURE_HOMELESS, x, y, DIR_0_TOP);
    f->action_state = FIGURE_ACTION_HOMELESS_CREATED;
    f->is_targetable = 1;
    f->terrain_usage = TERRAIN_USAGE_PREFER_ROADS;
    f->wait_ticks = 0;
    f->migrant_num_people = num_people;
    city_data.population.lost_homeless += num_people;
    remove_from_census(num_people);
    recalculate_population();
}

static void trader_record_sold_resource(int trader_id, int resource)
{
    figure_trader_data.traders[trader_id].sold_amount++;
    figure_trader_data.traders[trader_id].sold_resources[resource]++;
}

static void trader_record_bought_resource(int trader_id, int resource)
{
    figure_trader_data.traders[trader_id].bought_amount++;
    figure_trader_data.traders[trader_id].bought_resources[resource]++;
}

static void cross_country_advance_x(struct figure_t *f)
{
    if (f->cross_country_x < f->cc_destination_x) {
        f->cross_country_x++;
    } else if (f->cross_country_x > f->cc_destination_x) {
        f->cross_country_x--;
    }
}

static void cross_country_advance_y(struct figure_t *f)
{
    if (f->cross_country_y < f->cc_destination_y) {
        f->cross_country_y++;
    } else if (f->cross_country_y > f->cc_destination_y) {
        f->cross_country_y--;
    }
}

static int figure_movement_move_ticks_cross_country(struct figure_t *f, int num_ticks)
{
    map_figure_delete(f);
    int is_at_destination = 0;
    while (num_ticks > 0) {
        num_ticks--;
        if (f->missile_offset > 0) {
            f->missile_offset--;
        } else {
            f->missile_offset = 0;
        }
        if (f->cc_delta_x + f->cc_delta_y <= 0) {
            is_at_destination = 1;
            break;
        }
        if (f->cc_direction == 1) { // x
            if (f->cc_delta_xy >= 0) {
                f->cc_delta_xy += 2 * (f->cc_delta_y - f->cc_delta_x);
            } else {
                f->cc_delta_xy += 2 * f->cc_delta_y;
            }
            f->cc_delta_x--;
        } else { // y
            if (f->cc_delta_xy >= 0) {
                f->cc_delta_xy += 2 * (f->cc_delta_x - f->cc_delta_y);
            } else {
                f->cc_delta_xy += 2 * f->cc_delta_x;
            }
            f->cc_delta_y--;
        }
        if (f->cc_direction == 2) { // y
            cross_country_advance_y(f);
            if (f->cc_delta_xy >= 0) {
                f->cc_delta_x--;
                cross_country_advance_x(f);
            }
        } else {
            cross_country_advance_x(f);
            if (f->cc_delta_xy >= 0) {
                f->cc_delta_y--;
                cross_country_advance_y(f);
            }
        }
    }
    f->x = f->cross_country_x / 15;
    f->y = f->cross_country_y / 15;
    f->grid_offset = map_grid_offset(f->x, f->y);
    if (map_terrain_is(f->grid_offset, TERRAIN_BUILDING)) {
        f->in_building_wait_ticks = 8;
    } else if (f->in_building_wait_ticks) {
        f->in_building_wait_ticks--;
    }
    map_figure_add(f);
    return is_at_destination;
}

static void figure_movement_set_cross_country_destination(struct figure_t *f, int x_dst, int y_dst)
{
    f->destination_x = x_dst;
    f->destination_y = y_dst;
    figure_movement_set_cross_country_direction(f, f->cross_country_x, f->cross_country_y, 15 * x_dst, 15 * y_dst, 0);
}

static void figure_movement_follow_ticks(struct figure_t *f, int num_ticks)
{
    struct figure_t *leader = &figures[f->leading_figure_id];
    if (f->x == f->source_x && f->y == f->source_y) {
        f->is_invisible = 1;
    }
    while (num_ticks > 0) {
        num_ticks--;
        f->progress_on_tile++;
        if (f->progress_on_tile < 15) {
            advance_tick_movement(f);
        } else {
            f->progress_on_tile = 15;
            f->direction = calc_general_direction(f->x, f->y,
                leader->previous_tile_x, leader->previous_tile_y);
            if (f->direction >= 8) {
                break;
            }
            f->previous_tile_direction = f->direction;
            f->progress_on_tile = 0;
            move_to_next_tile(f);
            advance_tick_movement(f);
        }
    }
}

static void set_herd_animals_in_motion(struct formation_t *m)
{
    for (int j = 0; j < m->num_figures; j++) {
        struct figure_t *f = &figures[m->figures[j]];
        f->destination_x = m->destination_x + HERD_FORMATION_LAYOUT_POSITION_X_OFFSETS[f->index_in_formation];
        f->destination_y = m->destination_y + HERD_FORMATION_LAYOUT_POSITION_Y_OFFSETS[f->index_in_formation];
        f->action_state = FIGURE_ACTION_HERD_ANIMAL_MOVING;
    }
}

static void set_herd_formation_in_motion(struct formation_t *m, int roam_distance)
{
    if (m->figure_type == FIGURE_WOLF) {
        // wolves hunt nearby units
        for (int n = 0; n < m->num_figures; n++) {
            struct figure_t *f = &figures[m->figures[n]];
            struct figure_t *target_unit = melee_unit__set_closest_target(f);
            if (target_unit) {
                m->destination_x = target_unit->x;
                m->destination_y = target_unit->y;
                set_herd_animals_in_motion(m);
                return;
            }
        }
    }
    int target_tile_x, target_tile_y;
    switch (rand() % 8) {
        case DIR_0_TOP:
            target_tile_x = figures[m->figures[0]].x;
            target_tile_y = figures[m->figures[0]].y - roam_distance;
            break;
        case DIR_1_TOP_RIGHT:
            target_tile_x = figures[m->figures[0]].x + roam_distance;
            target_tile_y = figures[m->figures[0]].y - roam_distance;
            break;
        case DIR_2_RIGHT:
            target_tile_x = figures[m->figures[0]].x + roam_distance;
            target_tile_y = figures[m->figures[0]].y;
            break;
        case DIR_3_BOTTOM_RIGHT:
            target_tile_x = figures[m->figures[0]].x + roam_distance;
            target_tile_y = figures[m->figures[0]].y + roam_distance;
            break;
        case DIR_4_BOTTOM:
            target_tile_x = figures[m->figures[0]].x;
            target_tile_y = figures[m->figures[0]].y + roam_distance;
            break;
        case DIR_5_BOTTOM_LEFT:
            target_tile_x = figures[m->figures[0]].x - roam_distance;
            target_tile_y = figures[m->figures[0]].y + roam_distance;
            break;
        case DIR_6_LEFT:
            target_tile_x = figures[m->figures[0]].x - roam_distance;
            target_tile_y = figures[m->figures[0]].y;
            break;
        case DIR_7_TOP_LEFT:
            target_tile_x = figures[m->figures[0]].x - roam_distance;
            target_tile_y = figures[m->figures[0]].y - roam_distance;
            break;
        default:
            return;
    }
    if (target_tile_x <= 0 || target_tile_y <= 0) {
        return;
    } else if (target_tile_x >= map_data.width - 1) {
        target_tile_x = map_data.width - 2;
    } else if (target_tile_y >= map_data.height - 1) {
        target_tile_y = map_data.height - 2;
    }

    for (int fig = 0; fig < m->num_figures; fig++) {
        int fig_target_loc_grid_offset = map_grid_offset(target_tile_x + HERD_FORMATION_LAYOUT_POSITION_X_OFFSETS[fig], target_tile_y + HERD_FORMATION_LAYOUT_POSITION_Y_OFFSETS[fig]);
        if (!map_grid_is_valid_offset(fig_target_loc_grid_offset)) {
            return;
        }
        if (map_terrain_is(fig_target_loc_grid_offset, TERRAIN_IMPASSABLE)) {
            return;
        }
        if (map_grid_is_valid_offset(fig_target_loc_grid_offset) && map_figures.items[fig_target_loc_grid_offset] > 0) {
            return;
        }
    }
    m->destination_x = target_tile_x;
    m->destination_y = target_tile_y;
    for (int j = 0; j < m->num_figures; j++) {
        struct figure_t *f = &figures[m->figures[j]];
        if (f->type == FIGURE_SHEEP && figure_is_alive(f)) {
            f->wait_ticks = f->id & 0x1f;
        }
        set_herd_animals_in_motion(m);
    }
    m->wait_ticks_movement = 0;
}

static void clear_formation_combat_counters(struct formation_t *m)
{
    m->missile_attack_timeout = 0;
    m->recent_fight = 0;
}

static void decrease_formation_combat_counters(struct formation_t *m)
{
    if (m->missile_attack_timeout) {
        m->missile_attack_timeout--;
    }
    if (m->recent_fight) {
        m->recent_fight--;
    }
}

static int formation_rioter_get_target_building(int *x_tile, int *y_tile)
{
    int best_type_index = 100;
    struct building_t *best_building = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE) {
            continue;
        }
        for (int t = 0; t < 100 && t <= best_type_index && RIOTER_ATTACK_PRIORITY[t]; t++) {
            if (b->type == RIOTER_ATTACK_PRIORITY[t]) {
                if (t < best_type_index) {
                    best_type_index = t;
                    best_building = b;
                }
                break;
            }
        }
    }
    if (!best_building) {
        return 0;
    }
    if (best_building->type == BUILDING_WAREHOUSE) {
        *x_tile = best_building->x + 1;
        *y_tile = best_building->y;
        return best_building->id + 1;
    } else {
        *x_tile = best_building->x;
        *y_tile = best_building->y;
        return best_building->id;
    }
}

static int get_direction(struct figure_t *f)
{
    int dir;
    if (f->engaged_in_combat) {
        dir = f->attack_direction;
    } else if (f->direction < 8) {
        dir = f->direction;
    } else {
        dir = f->previous_tile_direction;
    }
    return figure_image_normalize_direction(dir);
}

static void rout_unit(struct figure_t *f)
{
    if (figure_properties[f->type].is_player_legion_unit) {
        struct formation_t *m = &legion_formations[f->formation_id];
        f->destination_x = all_buildings[m->building_id].x + 3 + FORMATION_LAYOUT_POSITION_X[FORMATION_AT_REST][f->index_in_formation];
        f->destination_y = all_buildings[m->building_id].y - 1 + FORMATION_LAYOUT_POSITION_Y[FORMATION_AT_REST][f->index_in_formation];
        f->destination_grid_offset = map_grid_offset(f->destination_x, f->destination_y);
        walk_ticks(f, f->speed_multiplier, 0);
        if (f->direction == DIR_FIGURE_AT_DESTINATION) {
            f->action_state = FIGURE_ACTION_SOLDIER_AT_REST;
            f->is_fleeing = 0;
        } else if (f->direction == DIR_FIGURE_REROUTE) {
            figure_route_remove(f);
        }
    } else if (figure_properties[f->type].is_enemy_unit || figure_properties[f->type].is_caesar_legion_unit) {
        f->destination_x = f->source_x;
        f->destination_y = f->source_y;
        walk_ticks(f, f->speed_multiplier, 0);
        if (f->direction == DIR_FIGURE_AT_DESTINATION ||
            f->direction == DIR_FIGURE_REROUTE ||
            f->direction == DIR_FIGURE_LOST) {
            figure_delete(f);
            return;
        }
    }
    figure_image_increase_offset(f, 12);
    int dir = get_direction(f);
    switch (f->type) {
        case FIGURE_FORT_JAVELIN:
            f->image_id = image_data_s.group_image_ids[GROUP_BUILDING_FORT_JAVELIN] + dir + 8 * f->image_offset;
            break;
        case FIGURE_FORT_MOUNTED:
            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_FORT_MOUNTED] + dir + 8 * f->image_offset;
            break;
        case FIGURE_FORT_LEGIONARY:
            f->image_id = image_data_s.group_image_ids[GROUP_BUILDING_FORT_LEGIONARY] + dir + 8 * f->image_offset;
            break;
        case FIGURE_ENEMY_BARBARIAN_SWORDSMAN:
            f->image_id = 297 + dir + 8 * f->image_offset;
            break;
        case FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN:
        case FIGURE_ENEMY_BRITON_SWORDSMAN:
        case FIGURE_ENEMY_CELT_SWORDSMAN:
        case FIGURE_ENEMY_PICT_SWORDSMAN:
        case FIGURE_ENEMY_EGYPTIAN_SWORDSMAN:
        case FIGURE_ENEMY_ETRUSCAN_SWORDSMAN:
        case FIGURE_ENEMY_SAMNITE_SWORDSMAN:
        case FIGURE_ENEMY_GAUL_SWORDSMAN:
        case FIGURE_ENEMY_HELVETIUS_SWORDSMAN:
        case FIGURE_ENEMY_HUN_SWORDSMAN:
        case FIGURE_ENEMY_GOTH_SWORDSMAN:
        case FIGURE_ENEMY_VISIGOTH_SWORDSMAN:
        case FIGURE_ENEMY_GREEK_SWORDSMAN:
        case FIGURE_ENEMY_MACEDONIAN_SWORDSMAN:
        case FIGURE_ENEMY_NUMIDIAN_SWORDSMAN:
        case FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER:
        case FIGURE_ENEMY_PERGAMUM_SWORDSMAN:
        case FIGURE_ENEMY_IBERIAN_SWORDSMAN:
        case FIGURE_ENEMY_JUDEAN_SWORDSMAN:
        case FIGURE_ENEMY_SELEUCID_SWORDSMAN:
            f->image_id = 449 + dir + 8 * f->image_offset;
            break;
        case FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT:
        case FIGURE_ENEMY_BRITON_CHARIOT:
        case FIGURE_ENEMY_CELT_CHARIOT:
        case FIGURE_ENEMY_PICT_CHARIOT:
        case FIGURE_ENEMY_EGYPTIAN_CAMEL:
        case FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER:
        case FIGURE_ENEMY_SAMNITE_SPEAR_THROWER:
        case FIGURE_ENEMY_GAUL_AXEMAN:
        case FIGURE_ENEMY_HELVETIUS_AXEMAN:
        case FIGURE_ENEMY_HUN_MOUNTED_ARCHER:
        case FIGURE_ENEMY_GOTH_MOUNTED_ARCHER:
        case FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER:
        case FIGURE_ENEMY_GREEK_SPEAR_THROWER:
        case FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER:
        case FIGURE_ENEMY_PERGAMUM_ARCHER:
        case FIGURE_ENEMY_IBERIAN_SPEAR_THROWER:
        case FIGURE_ENEMY_JUDEAN_SPEAR_THROWER:
        case FIGURE_ENEMY_SELEUCID_SPEAR_THROWER:
            f->image_id = 601 + dir + 8 * f->image_offset;
            break;
        case FIGURE_ENEMY_CAESAR_LEGIONARY:
            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_CAESAR_LEGIONARY] + 48 + dir + 8 * f->image_offset;
            break;
    }
}

static int unit_is_charging_opponent(struct figure_t *f, struct figure_t *opponent)
{
    return f->mounted_charge_ticks
        && !f->figure_is_halted
        && opponent->type != FIGURE_FORT_MOUNTED
        && opponent->type != FIGURE_ENEMY_EGYPTIAN_CAMEL
        && opponent->type != FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT
        && opponent->type != FIGURE_ENEMY_BRITON_CHARIOT && opponent->type != FIGURE_ENEMY_CELT_CHARIOT && opponent->type != FIGURE_ENEMY_PICT_CHARIOT
        && opponent->type != FIGURE_ENEMY_HUN_MOUNTED_ARCHER && opponent->type != FIGURE_ENEMY_GOTH_MOUNTED_ARCHER && opponent->type != FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER;
}

static int trade_price_change(int resource, int amount)
{
    if (amount < 0 && trade_prices[resource].sell <= 0) {
        // cannot lower the price to negative
        return 0;
    }
    if (amount < 0 && trade_prices[resource].sell <= -amount) {
        trade_prices[resource].buy = 2;
        trade_prices[resource].sell = 0;
    } else {
        trade_prices[resource].buy += amount;
        trade_prices[resource].sell += amount;
    }
    return 1;
}

static int city_trade_next_docker_import_resource(void)
{
    city_data.trade.docker_import_resource++;
    if (city_data.trade.docker_import_resource >= RESOURCE_TYPES_MAX) {
        city_data.trade.docker_import_resource = RESOURCE_WHEAT;
    }
    return city_data.trade.docker_import_resource;
}

static void city_ratings_update(int is_yearly_update)
{
    // update culture rating
    city_data.ratings.culture = 0;
    city_data.ratings.culture_explanation = 0;
    if (city_data.population.population) {
        if (culture_coverage.theater >= 100) {
            city_data.ratings.culture += 25;
        } else if (culture_coverage.theater > 85) {
            city_data.ratings.culture += 18;
        } else if (culture_coverage.theater > 70) {
            city_data.ratings.culture += 12;
        } else if (culture_coverage.theater > 50) {
            city_data.ratings.culture += 8;
        } else if (culture_coverage.theater > 30) {
            city_data.ratings.culture += 3;
        }
        int pct_religion = city_data.culture.religion_coverage;
        if (pct_religion >= 100) {
            city_data.ratings.culture += 30;
        } else if (pct_religion > 85) {
            city_data.ratings.culture += 22;
        } else if (pct_religion > 70) {
            city_data.ratings.culture += 14;
        } else if (pct_religion > 50) {
            city_data.ratings.culture += 9;
        } else if (pct_religion > 30) {
            city_data.ratings.culture += 3;
        }
        if (culture_coverage.school >= 100) {
            city_data.ratings.culture += 15;
        } else if (culture_coverage.school > 85) {
            city_data.ratings.culture += 10;
        } else if (culture_coverage.school > 70) {
            city_data.ratings.culture += 6;
        } else if (culture_coverage.school > 50) {
            city_data.ratings.culture += 4;
        } else if (culture_coverage.school > 30) {
            city_data.ratings.culture += 1;
        }
        if (culture_coverage.academy >= 100) {
            city_data.ratings.culture += 10;
        } else if (culture_coverage.academy > 85) {
            city_data.ratings.culture += 7;
        } else if (culture_coverage.academy > 70) {
            city_data.ratings.culture += 4;
        } else if (culture_coverage.academy > 50) {
            city_data.ratings.culture += 2;
        } else if (culture_coverage.academy > 30) {
            city_data.ratings.culture += 1;
        }
        if (culture_coverage.library >= 100) {
            city_data.ratings.culture += 20;
        } else if (culture_coverage.library > 85) {
            city_data.ratings.culture += 14;
        } else if (culture_coverage.library > 70) {
            city_data.ratings.culture += 8;
        } else if (culture_coverage.library > 50) {
            city_data.ratings.culture += 4;
        } else if (culture_coverage.library > 30) {
            city_data.ratings.culture += 2;
        }
        city_data.ratings.culture = calc_bound(city_data.ratings.culture, 0, 100);
        update_culture_explanation();
    }
    // update favor rating
    city_data.emperor.months_since_gift++;
    if (city_data.emperor.months_since_gift >= 12) {
        city_data.emperor.gift_overdose_penalty = 0;
    }
    // update prosperity
    int points = 0;
    int houses = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state && b->house_size) {
            points += house_properties[b->subtype.house_level].prosperity;
            houses++;
        }
    }
    if (houses > 0) {
        city_data.ratings.prosperity_max = points / houses;
    } else {
        city_data.ratings.prosperity_max = 0;
    }
    if (is_yearly_update) {
        // update favor
        city_data.ratings.favor_salary_penalty = 0;
        city_data.ratings.favor_ignored_request_penalty = 0;
        city_data.ratings.favor -= 2;
        // tribute penalty
        if (city_data.finance.tribute_not_paid_last_year) {
            if (city_data.finance.tribute_not_paid_total_years <= 1) {
                city_data.ratings.favor -= 3;
            } else if (city_data.finance.tribute_not_paid_total_years <= 2) {
                city_data.ratings.favor -= 5;
            } else {
                city_data.ratings.favor -= 8;
            }
        }
        // salary
        int salary_delta = city_data.emperor.salary_rank - city_data.emperor.player_rank;
        if (city_data.emperor.player_rank != 0) {
            if (salary_delta > 0) {
                // salary too high
                city_data.ratings.favor -= salary_delta;
                city_data.ratings.favor_salary_penalty = salary_delta + 1;
            } else if (salary_delta < 0) {
                // salary lower than rank
                city_data.ratings.favor += 1;
            }
        } else if (salary_delta > 0) {
            city_data.ratings.favor -= salary_delta;
            city_data.ratings.favor_salary_penalty = salary_delta;
        }

        if (city_data.ratings.favor < city_data.ratings.favor_last_year) {
            city_data.ratings.favor_change = 0;
        } else if (city_data.ratings.favor == city_data.ratings.favor_last_year) {
            city_data.ratings.favor_change = 1;
        } else {
            city_data.ratings.favor_change = 2;
        }
        city_data.ratings.favor_last_year = city_data.ratings.favor;
        // update prosperity rating
        int change = 0;
        // unemployment: -1 for too high, +1 for low
        if (city_data.labor.unemployment_percentage < 5) {
            change += 1;
        } else if (city_data.labor.unemployment_percentage >= 15) {
            change -= 1;
        }
        // losing/earning money: -1 for losing, +5 for profit
        if (has_made_money()) {
            change += 5;
        } else {
            change -= 1;
        }
        city_data.ratings.prosperity_treasury_last_year = city_data.finance.treasury;
        // food types: +1 for multiple foods
        if (city_data.resource.food_types_eaten >= 2) {
            change += 1;
        }
        // wages: +1 for wages 2+ above Rome, -1 for wages below Rome
        int avg_wage = city_data.finance.wage_rate_paid_last_year / 12;
        if (avg_wage >= city_data.labor.wages_rome + 2) {
            change += 1;
        } else if (avg_wage < city_data.labor.wages_rome) {
            change -= 1;
        }
        // high percentage poor: -1, high percentage rich: +1
        if (calc_percentage(city_data.population.people_in_tents_shacks, city_data.population.population) > 30) {
            change -= 1;
        }
        if (calc_percentage(city_data.population.people_in_villas_palaces, city_data.population.population) > 10) {
            change += 1;
        }
        // tribute not paid: -1
        if (city_data.finance.tribute_not_paid_last_year) {
            change -= 1;
        }
        // working hippodrome: +1
        if (city_data.entertainment.hippodrome_shows > 0) {
            change += 1;
        }
        city_data.ratings.prosperity += change;
        if (city_data.ratings.prosperity > city_data.ratings.prosperity_max) {
            city_data.ratings.prosperity = city_data.ratings.prosperity_max;
        }
        city_data.ratings.prosperity = calc_bound(city_data.ratings.prosperity, 0, 100);
        update_prosperity_explanation();
        // update peace rating
        change = 0;
        if (city_data.ratings.peace_years_of_peace < 2) {
            change += 2;
        } else {
            change += 5;
        }
        if (city_data.ratings.peace_num_criminals) {
            change -= 1;
        }
        if (city_data.ratings.peace_num_rioters) {
            change -= 5;
        }
        if (city_data.ratings.peace_destroyed_buildings) {
            change -= city_data.ratings.peace_destroyed_buildings;
        }
        if (city_data.ratings.peace_num_rioters || city_data.ratings.peace_destroyed_buildings) {
            city_data.ratings.peace_years_of_peace = 0;
        } else {
            city_data.ratings.peace_years_of_peace += 1;
        }
        city_data.ratings.peace_num_criminals = 0;
        city_data.ratings.peace_num_rioters = 0;
        city_data.ratings.peace_destroyed_buildings = 0;
        city_data.ratings.peace = calc_bound(city_data.ratings.peace + change, 0, 100);
        update_peace_explanation();
    }
    city_data.ratings.favor = calc_bound(city_data.ratings.favor, 0, 100);
    city_ratings_update_favor_explanation();
}

static int city_message_mark_population_shown(int population)
{
    int *field;
    switch (population) {
        case 500: field = &message_data.population_shown.pop500; break;
        case 1000: field = &message_data.population_shown.pop1000; break;
        case 2000: field = &message_data.population_shown.pop2000; break;
        case 3000: field = &message_data.population_shown.pop3000; break;
        case 5000: field = &message_data.population_shown.pop5000; break;
        case 10000: field = &message_data.population_shown.pop10000; break;
        case 15000: field = &message_data.population_shown.pop15000; break;
        case 20000: field = &message_data.population_shown.pop20000; break;
        case 25000: field = &message_data.population_shown.pop25000; break;
        default: return 0;
    }
    if (!*field) {
        *field = 1;
        return 1;
    }
    return 0;
}

static void city_message_post_with_message_delay(int category, int use_popup, int message_type, int delay)
{
    if (category == MESSAGE_CAT_FISHING_BLOCKED || category == MESSAGE_CAT_NO_WORKING_DOCK) {
        // bug in the original game: delays for 'fishing blocked' and 'no working dock'
        // are stored in message_count with manual countdown
        if (message_data.message_count[category] > 0) {
            message_data.message_count[category]--;
        } else {
            message_data.message_count[category] = delay;
            city_message_post(use_popup, message_type, 0, 0);
        }
    } else {
        if (message_data.message_delay[category] <= 0) {
            message_data.message_delay[category] = delay;
            city_message_post(use_popup, message_type, 0, 0);
        }
    }
}

static void city_message_post_with_popup_delay(int category, int message_type, int param1, short param2)
{
    int use_popup = 0;
    if (message_data.message_delay[category] <= 0) {
        use_popup = 1;
        message_data.message_delay[category] = 12;
    }
    city_message_post(use_popup, message_type, param1, param2);
    message_data.message_count[category]++;
}

static int building_warehouse_for_storing(int src_building_id, int x, int y, int resource,
                                   int road_network_id, int *understaffed,
                                   struct map_point_t *dst)
{
    int min_dist = 10000;
    int min_building_id = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_WAREHOUSE_SPACE) {
            continue;
        }
        if (!b->has_road_access || b->road_network_id != road_network_id) {
            continue;
        }
        struct building_t *building_dst = building_main(b);
        if (src_building_id == building_dst->id) {
            continue;
        }
        struct building_storage_t *s = &storages[building_dst->storage_id].storage;
        if (s->resource_state[resource] == BUILDING_STORAGE_STATE_NOT_ACCEPTING || s->empty_all) {
            continue;
        }
        if (calc_percentage(building_dst->num_workers, building_properties[building_dst->type].n_laborers) < 100) {
            if (understaffed) {
                *understaffed += 1;
            }
            continue;
        }
        int dist;
        if (b->subtype.warehouse_resource_id == RESOURCE_NONE) { // empty warehouse space
            dist = calc_maximum_distance(b->x, b->y, x, y);
        } else if (b->subtype.warehouse_resource_id == resource && b->loads_stored < 4) {
            dist = calc_maximum_distance(b->x, b->y, x, y);
        } else {
            dist = 0;
        }
        if (dist > 0 && dist < min_dist) {
            min_dist = dist;
            min_building_id = i;
        }
    }
    struct building_t *b = building_main(&all_buildings[min_building_id]);
    if (b->has_road_access == 1) {
        dst->x = b->x;
        dst->y = b->y;
    } else if (!map_has_road_access(b->x, b->y, 3, dst)) {
        return 0;
    }
    return min_building_id;
}

static void building_totals_add_corrupted_house(int unfixable)
{
    extra.incorrect_houses++;
    if (unfixable) {
        extra.unfixable_houses++;
    }
}

static void add_to_census(int num_people)
{
    int odd = 0;
    int index = 0;
    for (int i = 0; i < num_people; i++, odd = 1 - odd) {
        int age = random_data.pool[(random_data.pool_index + index) % MAX_RANDOM] & 0x3f; // 63
        index++;
        if (age > 50) {
            age -= 30;
        } else if (age < 10 && odd) {
            age += 20;
        }
        city_data.population.at_age[age]++;
    }
}

static void building_warehouse_space_add_import(struct building_t *space, int resource)
{
    city_resource_add_to_warehouse(resource, 1);
    space->loads_stored++;
    space->subtype.warehouse_resource_id = resource;
    city_data.finance.treasury -= trade_prices[resource].buy;
    city_data.finance.this_year.expenses.imports += trade_prices[resource].buy;
    building_warehouse_space_set_image(space, resource);
}

static int map_terrain_is_adjacent_to_open_water(int x, int y, int size)
{
    int base_offset = map_grid_offset(x, y);
    for (int *tile_delta = ADJACENT_OFFSETS_MAP_GRID[size]; *tile_delta; tile_delta++) {
        if (map_terrain_is(base_offset + *tile_delta, TERRAIN_WATER) &&
            routing_distance.items[base_offset + *tile_delta] > 0) {
            return 1;
        }
    }
    return 0;
}

static void figure_create_immigrant(struct building_t *house, int num_people)
{
    struct figure_t *f = figure_create(FIGURE_IMMIGRANT, scenario.entry_point.x, scenario.entry_point.y, DIR_0_TOP);
    f->action_state = FIGURE_ACTION_IMMIGRANT_CREATED;
    f->is_targetable = 1;
    f->terrain_usage = TERRAIN_USAGE_ANY;
    f->immigrant_building_id = house->id;
    f->wait_ticks = 10 + (house->house_figure_generation_delay & 0x7f);
    f->migrant_num_people = num_people;
    house->immigrant_figure_id = f->id;
}

static void create_immigrants(int num_people)
{
    int *houses = building_list_large_items();
    int to_immigrate = num_people;
    // clean up any dead immigrants
    for (int i = 0; i < building_list_data.large.size; i++) {
        struct building_t *b = &all_buildings[houses[i]];
        if (b->immigrant_figure_id && !figure_is_alive(&figures[b->immigrant_figure_id])) {
            b->immigrant_figure_id = 0;
        }
    }
    // houses with plenty of room
    for (int i = 0; i < building_list_data.large.size && to_immigrate > 0; i++) {
        struct building_t *b = &all_buildings[houses[i]];
        if (b->house_population_room >= 8 && !b->immigrant_figure_id) {
            if (to_immigrate <= 4) {
                figure_create_immigrant(b, to_immigrate);
                to_immigrate = 0;
            } else {
                figure_create_immigrant(b, 4);
                to_immigrate -= 4;
            }
        }
    }
    // houses with less room
    for (int i = 0; i < building_list_data.large.size && to_immigrate > 0; i++) {
        struct building_t *b = &all_buildings[houses[i]];
        if (b->house_population_room > 0 && !b->immigrant_figure_id) {
            if (to_immigrate <= b->house_population_room) {
                figure_create_immigrant(b, to_immigrate);
                to_immigrate = 0;
            } else {
                figure_create_immigrant(b, b->house_population_room);
                to_immigrate -= b->house_population_room;
            }
        }
    }
    int immigrated = num_people - to_immigrate;
    city_data.migration.immigrated_today += immigrated;
    city_data.migration.newcomers += city_data.migration.immigrated_today;
    if (immigrated == 0) {
        city_data.migration.refused_immigrants_today += num_people;
    }
}

static void create_vacant_lot(int x, int y, int image_id)
{
    struct building_t *b = building_create(BUILDING_HOUSE_VACANT_LOT, x, y);
    b->house_population = 0;
    map_building_tiles_add(b->id, b->x, b->y, 1, image_id, TERRAIN_BUILDING);
}

static void figure_create_emigrant(struct building_t *house, int num_people)
{
    city_data.population.last_change = -num_people;
    remove_from_census(num_people);
    recalculate_population();
    if (num_people < house->house_population) {
        house->house_population -= num_people;
    } else {
        house->house_population = 0;
        house->type = BUILDING_HOUSE_VACANT_LOT;
        house->subtype.house_level = house->type - BUILDING_HOUSE_SMALL_TENT;
        int image_id = image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_VACANT_LOT];
        if (house->house_is_merged) {
            map_building_tiles_remove(house->id, house->x, house->y);
            house->house_is_merged = 0;
            house->size = house->house_size = 1;
            map_building_tiles_add(house->id, house->x, house->y, 1, image_id, TERRAIN_BUILDING);
            create_vacant_lot(house->x + 1, house->y, image_id);
            create_vacant_lot(house->x, house->y + 1, image_id);
            create_vacant_lot(house->x + 1, house->y + 1, image_id);
        } else {
            images.items[house->grid_offset] = image_id;
        }
    }
    struct figure_t *f = figure_create(FIGURE_EMIGRANT, house->x, house->y, DIR_0_TOP);
    f->action_state = FIGURE_ACTION_EMIGRANT_CREATED;
    f->is_targetable = 1;
    f->terrain_usage = TERRAIN_USAGE_ANY;
    f->wait_ticks = 0;
    f->migrant_num_people = num_people;
}

static void create_emigrants(int num_people)
{
    int *houses = building_list_large_items();
    int to_emigrate = num_people;
    for (int level = HOUSE_SMALL_TENT; level < HOUSE_LARGE_INSULA && to_emigrate > 0; level++) {
        for (int i = 0; i < building_list_data.large.size && to_emigrate > 0; i++) {
            struct building_t *b = &all_buildings[houses[i]];
            if (b->house_population > 0 && b->subtype.house_level == level) {
                int current_people;
                if (b->house_population >= 4) {
                    current_people = 4;
                } else {
                    current_people = b->house_population;
                }
                if (to_emigrate <= current_people) {
                    figure_create_emigrant(b, to_emigrate);
                    to_emigrate = 0;
                } else {
                    figure_create_emigrant(b, current_people);
                    to_emigrate -= current_people;
                }
            }
        }
    }
    city_data.migration.emigrated_today += (num_people - to_emigrate);
}

static int get_people_in_age_decennium(int decennium)
{
    int pop = 0;
    for (int i = 0; i < 10; i++) {
        pop += city_data.population.at_age[10 * decennium + i];
    }
    return pop;
}

static int map_has_road_access_hippodrome(int x, int y, struct map_point_t *road)
{
    int min_value = 12;
    int min_grid_offset = map_grid_offset(x, y);
    find_minimum_road_tile(x, y, 5, &min_value, &min_grid_offset);
    find_minimum_road_tile(x + 5, y, 5, &min_value, &min_grid_offset);
    find_minimum_road_tile(x + 10, y, 5, &min_value, &min_grid_offset);
    if (min_value < 12) {
        if (road) {
            road->x = map_grid_offset_to_x(min_grid_offset);
            road->y = map_grid_offset_to_y(min_grid_offset);
        }
        return 1;
    }
    return 0;
}

static void set_city_foreign(void)
{
    if (city_data.distant_battle.city) {
        empire_objects[city_data.distant_battle.city].city_type = EMPIRE_CITY_DISTANT_FOREIGN;
    }
    city_data.distant_battle.city_foreign_months_left = 24;
}

static void draw_background_intermezzo(void)
{
    graphics_clear_screen();
    int x_offset = (screen_data.width - 1024) / 2;
    int y_offset = (screen_data.height - 768) / 2;

    int image_base = image_data_s.group_image_ids[GROUP_INTERMEZZO_BACKGROUND];
    if (intermezzo_data.type == INTERMEZZO_MISSION_BRIEFING) {
        image_draw(image_base + 1, x_offset, y_offset);
    } else if (intermezzo_data.type == INTERMEZZO_FIRED) {
        image_draw(image_base, x_offset, y_offset);
    } else if (intermezzo_data.type == INTERMEZZO_WON) {
        image_draw(image_base + 2, x_offset, y_offset);
    }
}

static void handle_input_intermezzo(struct mouse_t *m, __attribute__((unused))   struct hotkeys_t *h)
{
    if (m->right.went_up || current_time - intermezzo_data.start_time > (intermezzo_data.type ? DISPLAY_TIME_MILLIS : 300)) {
        intermezzo_data.callback();
    }
}

static void window_intermezzo_show(int type, void (*callback)(void))
{
    struct window_type_t window = {
        WINDOW_INTERMEZZO,
        draw_background_intermezzo,
        0,
        handle_input_intermezzo,
    };
    intermezzo_data.type = type;
    intermezzo_data.callback = callback;
    intermezzo_data.start_time = current_time;
    stop_sound_channel(SOUND_CHANNEL_SPEECH);
    if (intermezzo_data.type == INTERMEZZO_FIRED) {
        stop_music();
        play_speech_file(SOUND_FILE_LOSE);
    } else if (intermezzo_data.type == INTERMEZZO_WON) {
        stop_music();
        play_speech_file(SOUND_FILE_WIN);
    }
    window_show(&window);
}

static void draw_background_mission_end(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    if (victory_data.state == VICTORY_STATE_WON) {
        outer_panel_draw(48, 128, 34, 17);
        lang_text_draw_centered(62, 0, 48, 144, 544, FONT_LARGE_BLACK);
        inner_panel_draw(64, 184, 32, 7);
        lang_text_draw_multiline(147, 20, 80, 192, 488, FONT_NORMAL_WHITE);
        int left_offset = 68;
        int right_offset = 315;
        int width = lang_text_draw(148, 0, left_offset, 308, FONT_NORMAL_BLACK);
        text_draw_number(city_data.ratings.culture, '@', " ", left_offset + width, 308, FONT_NORMAL_BLACK);
        width = lang_text_draw(148, 1, right_offset, 308, FONT_NORMAL_BLACK);
        text_draw_number(city_data.ratings.prosperity, '@', " ", right_offset + width, 308, FONT_NORMAL_BLACK);
        width = lang_text_draw(148, 2, left_offset, 328, FONT_NORMAL_BLACK);
        text_draw_number(city_data.ratings.peace, '@', " ", left_offset + width, 328, FONT_NORMAL_BLACK);
        width = lang_text_draw(148, 3, right_offset, 328, FONT_NORMAL_BLACK);
        text_draw_number(city_data.ratings.favor, '@', " ", right_offset + width, 328, FONT_NORMAL_BLACK);
        width = lang_text_draw(148, 4, left_offset, 348, FONT_NORMAL_BLACK);
        text_draw_number(city_data.population.population, '@', " ", left_offset + width, 348, FONT_NORMAL_BLACK);
        width = lang_text_draw(148, 5, right_offset, 348, FONT_NORMAL_BLACK);
        text_draw_number(city_data.finance.treasury, '@', " ", right_offset + width, 348, FONT_NORMAL_BLACK);
    } else {
        outer_panel_draw(48, 16, 34, 13);
        lang_text_draw_centered(62, 1, 48, 32, 544, FONT_LARGE_BLACK);
        lang_text_draw_multiline(62, 16, 72, 75, 496, FONT_NORMAL_BLACK);
    }
    set_translation(0, 0);
}

static void handle_input_mission_end(struct mouse_t *m, struct hotkeys_t *h)
{
    if (m->right.went_up || h->escape_pressed) {
        stop_music();
        stop_sound_channel(SOUND_CHANNEL_SPEECH);
        city_data.mission.has_won = 0;
        city_data.mission.continue_months_left = 0;
        city_data.mission.continue_months_chosen = 0;
        undo_data.available = 0;
        game_state_reset_overlay();
        window_main_menu_show(1);
    }
}

static void show_end_dialog(void)
{
    struct window_type_t window = {
        WINDOW_MISSION_END,
        draw_background_mission_end,
        0,
        handle_input_mission_end,
    };
    window_show(&window);
}

static void video_draw_fullscreen(void)
{
    if (!get_next_frame()) {
        return;
    }
    int s_width = screen_data.width;
    int s_height = screen_data.height;
    unsigned char *frame = data_video.s->frame_data.video;
    uint32_t *pal = data_video.s->frame_data.palette;
    if (frame && pal) {
        double scale_w = s_width / (double) data_video.video.width;
        double scale_h = s_height / (double) data_video.video.height * (data_video.video.y_scale == SMACKER_Y_SCALE_NONE ? 1 : 2);
        double scale = scale_w < scale_h ? scale_w : scale_h;
        int video_width = (int) (scale * data_video.video.width);
        int video_height = (int) (scale * data_video.video.height);
        int x_offset = (s_width - video_width) / 2;
        int y_offset = (s_height - video_height) / 2;
        struct clip_info_t *clip = graphics_get_clip_info(x_offset, y_offset, video_width, video_height);
        if (!clip || !clip->is_visible) {
            return;
        }
        for (int y = clip->clipped_pixels_top; y < video_height - clip->clipped_pixels_bottom; y++) {
            color_t *pixel = graphics_get_pixel(x_offset + clip->clipped_pixels_left, y_offset + y);
            int x_max = video_width - clip->clipped_pixels_right;
            int video_y = (int) ((data_video.video.y_scale == SMACKER_Y_SCALE_NONE ? y : y / 2) / scale);
            unsigned char *line = frame + (video_y * data_video.video.width);
            for (int x = clip->clipped_pixels_left; x < x_max; x++) {
                *pixel = ALPHA_OPAQUE | pal[line[(int) (x / scale)]];
                ++pixel;
            }
        }
    }
}

static void handle_input_victory_video(struct mouse_t *m, __attribute__((unused))   struct hotkeys_t *h)
{
    if (m->left.went_up || m->right.went_up || data_video.is_ended) {
        video_stop();
        victory_video_data.callback();
    }
}

static void window_victory_video_show(char *filename, int width, int height, void (*callback)(void))
{
    if (video_start(filename)) {
        victory_video_data.width = width;
        victory_video_data.height = height;
        victory_video_data.callback = callback;
        video_init(0);
        struct window_type_t window = {
            WINDOW_VICTORY_VIDEO,
            graphics_clear_screen,
            video_draw_fullscreen,
            handle_input_victory_video,
        };
        window_show(&window);
    } else {
        callback();
    }
}

static void show_intermezzo(void)
{
    window_intermezzo_show(INTERMEZZO_WON, show_end_dialog);
}

static void draw_background_victory_dialog(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    outer_panel_draw(48, 128, 34, 15);
    lang_text_draw_centered(62, 0, 48, 144, 544, FONT_LARGE_BLACK);
    text_draw_centered(scenario_settings.player_name, 48, 194, 544, FONT_LARGE_BLACK, 0);
    set_translation(0, 0);
}

static void large_label_draw(int x, int y, int width_blocks, int type)
{
    int image_base = image_data_s.group_image_ids[GROUP_PANEL_BUTTON];
    for (int i = 0; i < width_blocks; i++) {
        int image_id;
        if (i == 0) {
            image_id = 3 * type;
        } else if (i < width_blocks - 1) {
            image_id = 3 * type + 1;
        } else {
            image_id = 3 * type + 2;
        }
        image_draw(image_base + image_id, x + BLOCK_SIZE * i, y);
    }
}

static void draw_foreground_victory_dialog(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    // Accept promotion
    large_label_draw(80, 240, 30, focus_button_id_victory_dialog == 1);
    lang_text_draw_centered(62, 3, 80, 246, 480, FONT_NORMAL_GREEN);
    // Continue for 2 years
    large_label_draw(80, 272, 30, focus_button_id_victory_dialog == 2);
    lang_text_draw_centered(62, 4, 80, 278, 480, FONT_NORMAL_GREEN);
    // Continue for 5 years
    large_label_draw(80, 304, 30, focus_button_id_victory_dialog == 3);
    lang_text_draw_centered(62, 5, 80, 310, 480, FONT_NORMAL_GREEN);
    set_translation(0, 0);
}

static void button_accept_victory_dialog(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_city_show();
}

static void button_continue_governing(int months, __attribute__((unused)) int param2)
{
    city_data.mission.has_won = 1;
    city_data.mission.continue_months_left += months;
    city_data.mission.continue_months_chosen = months;
    city_data.emperor.salary_rank = 0;
    city_data.emperor.salary_amount = 0;
    city_data.finance.this_year.expenses.salary = city_data.finance.salary_so_far;
    window_city_show();
    city_victory_reset();
    update_music(1);
}

static struct generic_button_t victory_buttons[] = {
    {32, 112, 480, 20, button_accept_victory_dialog, button_none, 0, 0},
    {32, 144, 480, 20, button_continue_governing, button_none, 24, 0},
    {32, 176, 480, 20, button_continue_governing, button_none, 60, 0},
};

static void handle_input_victory_dialog(struct mouse_t *m, __attribute__((unused))   struct hotkeys_t *h)
{
    generic_buttons_handle_mouse(mouse_in_dialog(m), 48, 128, victory_buttons, 3, &focus_button_id_victory_dialog);
}

static void game_run(void)
{
    uint32_t now_millis = current_time;
    for (int i = 0; i < MAX_ANIM_TIMERS; i++) {
        timers[i].should_update = 0;
    }
    unsigned int delay_millis = 0;
    for (int i = 0; i < MAX_ANIM_TIMERS; i++) {
        if (now_millis - timers[i].last_update >= delay_millis) {
            timers[i].should_update = 1;
            timers[i].last_update = now_millis;
        }
        delay_millis += 20;
    }
    int last_check_was_valid = speed_data.last_check_was_valid;
    speed_data.last_check_was_valid = 0;
    if (state_data.paused) {
        return;
    }
    int millis_per_tick = 1;
    switch (window_data.current_window->id) {
        default:
            return;
        case WINDOW_CITY:
        case WINDOW_CITY_MILITARY:
        case WINDOW_SLIDING_SIDEBAR:
        case WINDOW_OVERLAY_MENU:
        case WINDOW_MILITARY_MENU:
        case WINDOW_BUILD_MENU:
        {
            if (settings_values[SETTINGS_GAME_SPEED] < 10) {
                return;
            } else if (settings_values[SETTINGS_GAME_SPEED] <= 100) {
                millis_per_tick = MILLIS_PER_TICK_PER_SPEED[settings_values[SETTINGS_GAME_SPEED] / 10];
            } else {
                if (settings_values[SETTINGS_GAME_SPEED] > 500) {
                    settings_values[SETTINGS_GAME_SPEED] = 500;
                }
                millis_per_tick = MILLIS_PER_HYPER_SPEED[settings_values[SETTINGS_GAME_SPEED] / 100];
            }
            break;
        }
        case WINDOW_EDITOR_MAP:
            millis_per_tick = MILLIS_PER_TICK_PER_SPEED[7]; // 70%, nice speed for flag animations
            break;
    }
    uint32_t now = current_time;
    uint32_t diff = now - speed_data.last_update;
    speed_data.last_check_was_valid = 1;
    int num_ticks;
    if (last_check_was_valid) {
        int ticks = diff / millis_per_tick;
        if (!ticks) {
            return;
        } else if (ticks <= MAX_TICKS_PER_FRAME) {
            speed_data.last_update = now - (diff % millis_per_tick); // account for left-over millis in this frame
            num_ticks = ticks;
        } else {
            speed_data.last_update = now;
            num_ticks = MAX_TICKS_PER_FRAME;
        }
    } else {
        // returning to map from another window or pause: always force a tick
        speed_data.last_update = now;
        num_ticks = 1;
    }
    for (int i = 0; i < num_ticks; i++) {
        if (editor_active) {
            random_generate_next(); // update random to randomize native huts
            for (int j = 1; j < MAX_FIGURES; j++) {
                struct figure_t *f = &figures[j];
                if (f->in_use && f->type == FIGURE_MAP_FLAG) {
                    figure_editor_flag_action(f);
                }
            }
            return;
        }
        random_generate_next();
        if (undo_data.ready && undo_data.available) {
            int earthquake_in_progress = 0;
            for (int j = 0; j < MAX_EARTHQUAKES; j++) {
                if (scenario.earthquakes[j].state == EVENT_IN_PROGRESS) {
                    earthquake_in_progress = 1;
                    break;
                }
            }
            if (undo_data.timeout_ticks <= 0 || earthquake_in_progress) {
                undo_data.available = 0;
                clear_buildings();
                window_invalidate();
            } else {
                undo_data.timeout_ticks--;
                if (undo_data.type != BUILDING_CLEAR_LAND
                && undo_data.type != BUILDING_AQUEDUCT
                && undo_data.type != BUILDING_ROAD
                && undo_data.type != BUILDING_WALL
                && undo_data.type != BUILDING_LOW_BRIDGE
                && undo_data.type != BUILDING_SHIP_BRIDGE
                && undo_data.type != BUILDING_PLAZA
                && undo_data.type != BUILDING_GARDENS) {
                    if (undo_data.num_buildings <= 0) {
                        undo_data.available = 0;
                        window_invalidate();
                    } else {
                        int cont = 1;
                        if (undo_data.type == BUILDING_HOUSE_VACANT_LOT) {
                            for (int j = 0; j < undo_data.num_buildings; j++) {
                                if (undo_data.buildings[j].id && all_buildings[undo_data.buildings[j].id].house_population) {
                                    // no undo on a new house where people moved in
                                    undo_data.available = 0;
                                    window_invalidate();
                                    cont = 0;
                                    break;
                                }
                            }
                        }
                        if (cont) {
                            for (int j = 0; j < undo_data.num_buildings; j++) {
                                if (undo_data.buildings[j].id) {
                                    struct building_t *b = &all_buildings[undo_data.buildings[j].id];
                                    if (b->state == BUILDING_STATE_UNDO ||
                                        b->state == BUILDING_STATE_RUBBLE ||
                                        b->state == BUILDING_STATE_DELETED_BY_GAME) {
                                        undo_data.available = 0;
                                        window_invalidate();
                                        break;
                                    } else {
                                        if (b->type != undo_data.buildings[j].type || b->grid_offset != undo_data.buildings[j].grid_offset) {
                                            undo_data.available = 0;
                                            window_invalidate();
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        // NB: these ticks are noop:
        // 0, 9, 11, 13, 14, 15, 26, 29, 41, 42, 47
        int *houses;
        int recalculate_terrain = 0;
        switch (time_data.tick) {
            case 1: city_gods_calculate_moods(1); break;
            case 2: update_music(0); break;
            case 3:
                minimap_data.refresh_requested = 1;
                break;
            case 4:
                // update debt state
                if (city_data.finance.treasury >= 0) {
                    city_data.emperor.months_in_debt = -1;
                } else {
                    if (city_data.emperor.debt_state == 0) {
                        // provide bailout
                        int rescue_loan = scenario.rescue_loan;
                        city_finance_process_donation(rescue_loan);
                        city_finance_calculate_totals();
                        city_data.emperor.debt_state = 1;
                        city_data.emperor.months_in_debt = 0;
                        city_message_post(1, MESSAGE_CITY_IN_DEBT, 0, 0);
                        if (city_data.ratings.prosperity >= 3) {
                            city_data.ratings.prosperity -= 3;
                        }
                        city_data.ratings.prosperity_explanation = 8;
                    } else if (city_data.emperor.debt_state == 1) {
                        city_data.emperor.debt_state = 2;
                        city_data.emperor.months_in_debt = 0;
                        city_message_post(1, MESSAGE_CITY_IN_DEBT_AGAIN, 0, 0);
                        city_data.ratings.favor = calc_bound(city_data.ratings.favor - 5, 0, 100);
                    } else if (city_data.emperor.debt_state == 2) {
                        if (city_data.emperor.months_in_debt == -1) {
                            city_message_post(1, MESSAGE_CITY_IN_DEBT_AGAIN, 0, 0);
                            city_data.emperor.months_in_debt = 0;
                        }
                        if (time_data.day == 0) {
                            city_data.emperor.months_in_debt++;
                        }
                        if (city_data.emperor.months_in_debt >= 12) {
                            city_data.emperor.debt_state = 3;
                            city_data.emperor.months_in_debt = 0;
                            if (!city_data.figure.imperial_soldiers) {
                                city_message_post(1, MESSAGE_CITY_STILL_IN_DEBT, 0, 0);
                                city_data.ratings.favor = calc_bound(city_data.ratings.favor - 10, 0, 100);
                            }
                        }
                    } else if (city_data.emperor.debt_state == 3) {
                        if (city_data.emperor.months_in_debt == -1) {
                            city_message_post(1, MESSAGE_CITY_STILL_IN_DEBT, 0, 0);
                            city_data.emperor.months_in_debt = 0;
                        }
                        if (time_data.day == 0) {
                            city_data.emperor.months_in_debt++;
                        }
                        if (city_data.emperor.months_in_debt >= 12) {
                            city_data.emperor.debt_state = 4;
                            city_data.emperor.months_in_debt = 0;
                            if (!city_data.figure.imperial_soldiers) {
                                if (city_data.ratings.favor > 10) {
                                    city_data.ratings.favor = 10;
                                }
                            }
                        }
                    }
                }
                // process caesar invasion
                if (city_data.figure.imperial_soldiers && !city_data.emperor.invasion.from_editor) {
                    // caesar invasion in progress
                    city_data.emperor.invasion.duration_day_countdown--;
                    if (city_data.ratings.favor >= 35 && city_data.emperor.invasion.duration_day_countdown < 176) {
                        // pause legions
                        for (int j = 0; j < MAX_ENEMY_FORMATIONS; j++) {
                            if (enemy_formations[j].in_use == 1 && enemy_formations[j].figure_type == FIGURE_ENEMY_CAESAR_LEGIONARY) {
                                enemy_formations[j].wait_ticks_movement = 0;
                            }
                        }
                    } else if (city_data.ratings.favor >= 22) {
                        if (city_data.emperor.invasion.duration_day_countdown > 0) {
                            // retreat
                            for (int j = 0; j < MAX_ENEMY_FORMATIONS; j++) {
                                if (enemy_formations[j].in_use && enemy_formations[j].figure_type == FIGURE_ENEMY_CAESAR_LEGIONARY) {
                                    enemy_formations[j].morale = 0;
                                }
                            }
                            if (!city_data.emperor.invasion.retreat_message_shown) {
                                city_data.emperor.invasion.retreat_message_shown = 1;
                                city_message_post(1, MESSAGE_CAESAR_ARMY_RETREAT, 0, 0);
                            }
                        } else if (city_data.emperor.invasion.duration_day_countdown == 0) {
                            // a year has passed (11 months), siege goes on
                            city_message_post(1, MESSAGE_CAESAR_ARMY_CONTINUE, 0, 0);
                        }
                    }
                } else if (city_data.emperor.invasion.soldiers_killed && city_data.emperor.invasion.soldiers_killed >= city_data.emperor.invasion.size) {
                    // player defeated caesar army
                    city_data.emperor.invasion.size = 0;
                    city_data.emperor.invasion.soldiers_killed = 0;
                    if (!city_data.emperor.invasion.from_editor) {
                        if (city_data.ratings.favor < 35) {
                            city_data.ratings.favor = calc_bound(city_data.ratings.favor + 10, 0, 100);
                            if (city_data.emperor.invasion.count < 2) {
                                city_message_post(1, MESSAGE_CAESAR_RESPECT_1, 0, 0);
                            } else if (city_data.emperor.invasion.count < 3) {
                                city_message_post(1, MESSAGE_CAESAR_RESPECT_2, 0, 0);
                            } else {
                                city_message_post(1, MESSAGE_CAESAR_RESPECT_3, 0, 0);
                            }
                        }
                    }
                    if (city_data.emperor.invasion.from_editor) {
                        city_data.emperor.invasion.from_editor = 0;
                    }
                } else if (city_data.emperor.invasion.days_until_invasion <= 0) {
                    if (city_data.ratings.favor <= 10) {
                        // warn player that caesar is angry and will invade in a year
                        city_data.emperor.invasion.warnings_given++;
                        city_data.emperor.invasion.days_until_invasion = 192;
                        if (city_data.emperor.invasion.warnings_given <= 1) {
                            city_message_post(1, MESSAGE_CAESAR_WRATH, 0, 0);
                        }
                    }
                } else {
                    city_data.emperor.invasion.days_until_invasion--;
                    if (city_data.emperor.invasion.days_until_invasion == 0) {
                        // invade!
                        int size;
                        if (city_data.emperor.invasion.count == 0) {
                            size = 32;
                        } else if (city_data.emperor.invasion.count == 1) {
                            size = 64;
                        } else if (city_data.emperor.invasion.count == 2) {
                            size = 96;
                        } else {
                            size = 160;
                        }
                        int grid_offset = start_invasion(ENEMY_TYPE_CAESAR, size, 0, FORMATION_ATTACK_BEST_BUILDINGS);
                        if (grid_offset > 0) {
                            city_message_post(1, MESSAGE_CAESAR_ARMY_ATTACK, 0, grid_offset);
                            city_data.emperor.invasion.count++;
                            city_data.emperor.invasion.duration_day_countdown = 192;
                            city_data.emperor.invasion.retreat_message_shown = 0;
                            city_data.emperor.invasion.size = size;
                            city_data.emperor.invasion.soldiers_killed = 0;
                        }
                    }
                }
                break;
            case 5: // update all formations
            {
                for (int j = 0; j < MAX_LEGIONS; j++) {
                    if (legion_formations[j].in_use) {
                        struct formation_t *m = &legion_formations[j];
                        decrease_formation_combat_counters(m);
                        if (m->cursed_by_mars) {
                            m->cursed_by_mars--;
                        }
                        if (m->figure_type == FIGURE_FORT_MOUNTED && m->is_at_rest) {
                            for (int k = 0; k < m->num_figures; k++) {
                                struct figure_t *f = &figures[m->figures[k]];
                                if (f->mounted_charge_ticks < f->mounted_charge_ticks_max) {
                                    f->mounted_charge_ticks += 2;
                                }
                            }
                        }
                        if (!city_data.figure.enemies) {
                            clear_formation_combat_counters(m);
                        }
                        // check formation military training status, send untrained units to train
                        int formation_military_trained = 1;
                        for (int n = 0; n < m->num_figures; n++) {
                            struct figure_t *f = &figures[m->figures[n]];
                            if (!f->is_military_trained) {
                                formation_military_trained = 0;
                                m->has_military_training = 0;
                                if (m->figure_type == FIGURE_FORT_LEGIONARY) {
                                    m->max_morale = 80;
                                } else {
                                    m->max_morale = 60;
                                }
                                if (scenario.allowed_buildings[BUILDING_MILITARY_ACADEMY] && f->action_state == FIGURE_ACTION_SOLDIER_AT_REST) {
                                    struct map_point_t mil_acad_road = { 0 };
                                    set_destination__closest_building_of_type(f->building_id, BUILDING_MILITARY_ACADEMY, &mil_acad_road);
                                    if (mil_acad_road.x) {
                                        f->destination_x = mil_acad_road.x;
                                        f->destination_y = mil_acad_road.y;
                                        f->action_state = FIGURE_ACTION_SOLDIER_GOING_TO_MILITARY_ACADEMY;
                                        break; // causes a delay between sending units
                                    }
                                }
                            }
                        }
                        if (formation_military_trained) {
                            m->has_military_training = 1;
                            if (m->figure_type == FIGURE_FORT_LEGIONARY) {
                                m->max_morale = 100;
                            } else {
                                m->max_morale = 80;
                            }
                        }
                        // check if all units of a formation are at rest (not deployed)
                        int formation_at_rest = 1;
                        for (int n = 0; n < m->num_figures; n++) {
                            struct figure_t *f = &figures[m->figures[n]];
                            if (f->engaged_in_combat
                            || f->action_state == FIGURE_ACTION_SOLDIER_GOING_TO_STANDARD
                            || f->action_state == FIGURE_ACTION_SOLDIER_AT_STANDARD
                            || f->action_state == FIGURE_ACTION_SOLDIER_MOPPING_UP
                            || f->action_state == FIGURE_ACTION_SOLDIER_GOING_TO_DISTANT_BATTLE) {
                                formation_at_rest = 0;
                                m->is_at_rest = 0;
                                break;
                            }
                        }
                        if (formation_at_rest) {
                            m->is_at_rest = 1;
                        }
                        // decrease damage
                        for (int n = 0; n < m->num_figures; n++) {
                            struct figure_t *f = &figures[m->figures[n]];
                            if (figure_is_alive(f) && f->action_state == FIGURE_ACTION_SOLDIER_AT_REST) {
                                if (f->damage) {
                                    f->damage--;
                                }
                            }
                        }
                        if (m->morale > ROUT_MORALE_THRESHOLD) {
                            m->routed = 0;
                        } else {
                            m->standard_x = all_buildings[m->building_id].x + 3;
                            m->standard_y = all_buildings[m->building_id].y - 1;
                            update_legion_standard_map_location(m);
                            // flee back to fort
                            for (int n = 0; n < m->num_figures; n++) {
                                struct figure_t *f = &figures[m->figures[n]];
                                if (f->action_state != FIGURE_ACTION_SOLDIER_AT_REST) {
                                    f->is_fleeing = 1;
                                    figure_route_remove(f);
                                }
                            }
                            // on formation rout, reduce morale of all legions, improve morale of all enemy formations
                            if (!m->routed) {
                                for (int k = 0; k < MAX_LEGIONS; k++) {
                                    legion_formations[k].morale = calc_bound(legion_formations[k].morale - 5, 0, legion_formations[k].max_morale);
                                }
                                for (int k = 0; k < MAX_ENEMY_FORMATIONS; k++) {
                                    if (enemy_formations[k].in_use) {
                                        enemy_formations[k].morale = calc_bound(enemy_formations[k].morale + 5, 0, enemy_formations[k].max_morale);
                                    }
                                }
                                m->routed = 1;
                                if (city_data.figure.enemies) {
                                    play_speech_file("wavs/barbarian_war_cry.wav");
                                }
                            }
                        }
                    }
                }
                for (int j = 0; j < MAX_ENEMY_FORMATIONS; j++) {
                    if (enemy_formations[j].in_use) {
                        struct formation_t *m = &enemy_formations[j];
                        decrease_formation_combat_counters(m);
                        if (!city_data.figure.soldiers) {
                            clear_formation_combat_counters(m);
                        }
                        if (city_data.religion.mars_spirit_power && m->wait_ticks_movement > 16) {
                            int grid_offset = 0;
                            for (int k = 1; k < MAX_FIGURES && city_data.religion.mars_spirit_power > 0; k++) {
                                struct figure_t *f = &figures[k];
                                if (figure_is_alive(f)) {
                                    if ((figure_properties[f->type].is_enemy_unit && f->type != FIGURE_ENEMY_GLADIATOR) || figure_properties[f->type].is_caesar_legion_unit) {
                                        f->is_corpse = 1;
                                        f->is_targetable = 0;
                                        clear_targeting_on_unit_death(f);
                                        city_data.religion.mars_spirit_power--;
                                        if (!grid_offset) {
                                            grid_offset = f->grid_offset;
                                        }
                                    }
                                }
                            }
                            city_data.religion.mars_spirit_power = 0;
                            city_message_post(1, MESSAGE_SPIRIT_OF_MARS, 0, grid_offset);
                        }
                        int formation_spawning = 0;
                        for (int n = 0; n < m->num_figures; n++) {
                            if (figures[m->figures[n]].is_invisible) {
                                formation_spawning = 1;
                                break;
                            }
                        }
                        if (formation_spawning) {
                            // delay all other (already spawned, but not engaged) formations so they move together after
                            for (int k = 0; k < MAX_ENEMY_FORMATIONS; k++) {
                                if (enemy_formations[k].in_use && !(enemy_formations[k].recent_fight || enemy_formations[k].missile_attack_timeout)) {
                                    enemy_formations[k].wait_ticks_movement = 0;
                                }
                            }
                            continue;
                        }
                        if (m->morale <= ROUT_MORALE_THRESHOLD) {
                            for (int n = 0; n < MAX_FORMATION_FIGURES; n++) {
                                struct figure_t *f = &figures[m->figures[n]];
                                f->is_fleeing = 1;
                                figure_route_remove(f);
                            }
                            // on formation rout, reduce morale of all enemy formations, improve morale of all legions
                            if (!m->routed) {
                                for (int k = 0; k < MAX_ENEMY_FORMATIONS; k++) {
                                    if (enemy_formations[k].in_use) {
                                        enemy_formations[k].morale = calc_bound(enemy_formations[k].morale - 5, 0, enemy_formations[k].max_morale);
                                    }
                                }
                                for (int k = 0; k < MAX_LEGIONS; k++) {
                                    legion_formations[k].morale = calc_bound(legion_formations[k].morale + 5, 0, legion_formations[k].max_morale);
                                }
                                m->routed = 1;
                                play_sound_effect(SOUND_EFFECT_HORN3);
                                play_speech_file("wavs/army_war_cry.wav");
                            }
                            continue;
                        }

                        if (m->recent_fight || m->missile_attack_timeout) {
                            for (int k = 0; k < MAX_ENEMY_FORMATIONS; k++) {
                                if (enemy_formations[k].in_use) {
                                    enemy_formations[k].wait_ticks_movement += 2;
                                }
                            }
                        } else {
                            m->wait_ticks_movement++;
                        }
                        struct figure_t *target_unit = 0;
                        for (int n = 0; n < m->num_figures; n++) {
                            struct figure_t *f = &figures[m->figures[n]];
                            if (!figure_properties[f->type].max_range) {
                                target_unit = melee_unit__set_closest_target(f);
                                if (target_unit) {
                                    if (m->layout == FORMATION_ENEMY_MOB  // melee units in a mob break rank to chase enemies
                                    || (target_unit->type == FIGURE_FORT_JAVELIN && f->speed_multiplier >= target_unit->speed_multiplier)) { // melee units in other formations chase javelins only, and only if they are at least as fast as them
                                        f->destination_x = target_unit->x;
                                        f->destination_y = target_unit->y;
                                        f->action_state = FIGURE_ACTION_ENEMY_ENGAGED;
                                    }
                                }
                            }
                        }

                        if (m->wait_ticks_movement > LAYOUT_REGROUP_DURATION[m->layout]) {
                            if (target_unit) {
                                int reinforcements_sent = 0;
                                for (int k = 0; k < MAX_ENEMY_FORMATIONS; k++) {
                                    if (enemy_formations[k].in_use) {
                                        for (int n = 0; n < enemy_formations[k].num_figures; n++) {
                                            struct figure_t *f = &figures[enemy_formations[k].figures[n]];
                                            if (!f->is_invisible) {
                                                f->destination_x = target_unit->x;
                                                f->destination_y = target_unit->y;
                                                f->target_figure_id = target_unit->id;
                                                f->action_state = FIGURE_ACTION_ENEMY_ENGAGED;
                                                reinforcements_sent++;
                                            }
                                        }
                                        if (reinforcements_sent >= city_data.figure.soldiers
                                        || (m->figure_type == FIGURE_ENEMY_CAESAR_LEGIONARY && reinforcements_sent >= city_data.figure.imperial_soldiers)
                                        || (m->figure_type != FIGURE_ENEMY_CAESAR_LEGIONARY && reinforcements_sent >= city_data.figure.enemies)) {
                                            break;
                                        }
                                    }
                                }
                            }
                            struct building_t *target_building = 0;
                            int attack = m->attack_priority;
                            if (attack == FORMATION_ATTACK_RANDOM) {
                                attack = rand() % 4;
                            }
                            int best_type_index = 100;
                            struct building_t *best_building = 0;
                            int min_distance = 10000;
                            for (int k = 1; k < MAX_BUILDINGS; k++) {
                                struct building_t *b = &all_buildings[k];
                                if (b->state != BUILDING_STATE_IN_USE) {
                                    continue;
                                }
                                for (int n = 0; n < 100 && n <= best_type_index && ENEMY_ATTACK_PRIORITY[attack][n]; n++) {
                                    if (b->type == ENEMY_ATTACK_PRIORITY[attack][n]) {
                                        int distance = calc_maximum_distance(figures[m->figures[0]].x, figures[m->figures[0]].y, b->x, b->y);
                                        if (n < best_type_index) {
                                            best_type_index = n;
                                            best_building = b;
                                            min_distance = distance;
                                        } else if (distance < min_distance) {
                                            best_building = b;
                                            min_distance = distance;
                                        }
                                        break;
                                    }
                                }
                            }
                            if (best_building) {
                                target_building = best_building;
                            } else {
                                // no priority buildings left: target population
                                for (int k = 1; k < MAX_BUILDINGS; k++) {
                                    struct building_t *b = &all_buildings[k];
                                    if (b->state != BUILDING_STATE_IN_USE) {
                                        continue;
                                    }
                                    if (building_is_house(b->type)) {
                                        target_building = b;
                                    }
                                }
                            }
                            if (target_building) {
                                if (map_routing_noncitizen_can_travel_over_land(m->destination_x, m->destination_y, target_building->x, target_building->y, 0, 400)
                                || map_routing_noncitizen_can_travel_through_everything(m->destination_x, m->destination_y, target_building->x, target_building->y)) {
                                    int x_tile, y_tile;
                                    int dst_grid_offset = map_grid_offset(target_building->x, target_building->y);
                                    int distance = routing_distance.items[dst_grid_offset];
                                    if (distance > 0 && distance < 998) {
                                        int num_tiles = 0;
                                        int last_direction = -1;
                                        int x = target_building->x;
                                        int y = target_building->y;
                                        int grid_offset = dst_grid_offset;
                                        while (distance > 1) {
                                            distance = routing_distance.items[grid_offset];
                                            x_tile = x;
                                            y_tile = y;
                                            if (distance <= 20) {
                                                m->destination_x = x_tile;
                                                m->destination_y = y_tile;
                                                for (int n = 0; n < m->num_figures; n++) {
                                                    struct figure_t *f = &figures[m->figures[n]];
                                                    if (!f->is_invisible && (f->action_state == FIGURE_ACTION_ENEMY_SPAWNING || f->action_state == FIGURE_ACTION_ENEMY_REGROUPING)) {
                                                        f->action_state = FIGURE_ACTION_ENEMY_ADVANCING;
                                                    }
                                                }
                                                m->wait_ticks_movement = 0;
                                                break;
                                            }
                                            int direction = -1;
                                            int general_direction = calc_general_direction(x, y, m->destination_x, m->destination_y);
                                            for (int d = 0; d < 8; d++) {
                                                if (d != last_direction) {
                                                    int next_offset = grid_offset + map_grid_direction_delta(d);
                                                    int next_distance = routing_distance.items[next_offset];
                                                    if (next_distance) {
                                                        if (next_distance < 20) {
                                                            distance = next_distance;
                                                            direction = d;
                                                        } else if (next_distance == distance && (d == general_direction || direction == -1)) {
                                                            distance = next_distance;
                                                            direction = d;
                                                        }
                                                    }
                                                }
                                            }
                                            if (direction != -1) {
                                                adjust_tile_in_direction(direction, &x, &y, &grid_offset);
                                                int forward_direction = (direction + 4) % 8;
                                                direction_path[num_tiles++] = forward_direction;
                                                last_direction = forward_direction;
                                                if (num_tiles >= MAX_PATH) {
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (city_data.figure.animals) {
                    for (int k = 0; k < MAX_HERD_POINTS; k++) {
                        if (herd_formations[k].in_use && herd_formations[k].num_figures) {
                            struct formation_t *m = &herd_formations[k];
                            int random_factor = rand();
                            int roam_distance;
                            int roam_delay;
                            switch (m->figure_type) {
                                case FIGURE_WOLF:
                                    roam_distance = (random_factor % MAX_WOLF_ROAM_DISTANCE) >= MAX_WOLF_ROAM_DISTANCE / 2 ? (random_factor % MAX_WOLF_ROAM_DISTANCE) : MAX_WOLF_ROAM_DISTANCE;
                                    roam_delay = WOLF_PACK_ROAM_DELAY;
                                    break;
                                case FIGURE_SHEEP:
                                    roam_distance = (random_factor % MAX_SHEEP_ROAM_DISTANCE) >= MAX_SHEEP_ROAM_DISTANCE / 2 ? (random_factor % MAX_SHEEP_ROAM_DISTANCE) : MAX_SHEEP_ROAM_DISTANCE;
                                    roam_delay = SHEEP_HERD_ROAM_DELAY;
                                    break;
                                case FIGURE_ZEBRA:
                                    roam_distance = (random_factor % MAX_ZEBRA_ROAM_DISTANCE) >= MAX_ZEBRA_ROAM_DISTANCE / 2 ? (random_factor % MAX_ZEBRA_ROAM_DISTANCE) : MAX_ZEBRA_ROAM_DISTANCE;
                                    roam_delay = ZEBRA_HERD_ROAM_DELAY;
                                    break;
                                default:
                                    break;
                            }
                            decrease_formation_combat_counters(m);
                            // being shot at or attacked prompts an immediate response
                            if (m->missile_attack_timeout) {
                                set_herd_formation_in_motion(m, roam_distance);
                            } else {
                                for (int l = 0; l < m->num_figures; l++) {
                                    struct figure_t *f = &figures[m->figures[l]];
                                    if (f->engaged_in_combat) {
                                        m->wait_ticks_movement = roam_delay;
                                        break;
                                    }
                                }
                                m->wait_ticks_movement++;
                                if (m->wait_ticks_movement > roam_delay) {
                                    set_herd_formation_in_motion(m, roam_distance);
                                }
                            }
                        }
                    }
                }
                break;
            }
            case 6:
            {
                for (int j = 0; j < GRID_SIZE * GRID_SIZE; j++) {
                    edge_grid.items[j] &= EDGE_NO_NATIVE_LAND;
                }
                if (city_data.military.native_attack_duration) {
                    city_data.military.native_attack_duration--;
                }

                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE) {
                        continue;
                    }
                    int size, radius;
                    if (b->type == BUILDING_NATIVE_HUT) {
                        size = 1;
                        radius = 3;
                    } else if (b->type == BUILDING_NATIVE_MEETING) {
                        size = 2;
                        radius = 6;
                    } else {
                        continue;
                    }
                    if (b->sentiment.native_anger >= 100) {
                        mark_native_land(b->x, b->y, size, radius);
                        int x_min, y_min, x_max, y_max;
                        map_grid_get_area(b->x, b->y, size, radius, &x_min, &y_min, &x_max, &y_max);
                        for (int yy = y_min; yy <= y_max; yy++) {
                            for (int xx = x_min; xx <= x_max; xx++) {
                                int building_id = map_building_at(map_grid_offset(xx, yy));
                                if (building_id > 0) {
                                    int type = all_buildings[building_id].type;
                                    if (type != BUILDING_MISSION_POST &&
                                        type != BUILDING_NATIVE_HUT &&
                                        type != BUILDING_NATIVE_MEETING &&
                                        type != BUILDING_NATIVE_CROPS) {
                                        city_data.military.native_attack_duration = 1;
                                        break;
                                    }
                                }
                            }
                        }
                    } else {
                        b->sentiment.native_anger++;
                    }
                }
            }
            break;
            case 7: map_road_network_update(); break;
            case 8: building_granaries_calculate_stocks(); break;
            case 10: // update building highest id
            {
                extra.highest_id_in_use = 0;
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    if (all_buildings[i].state != BUILDING_STATE_UNUSED) {
                        extra.highest_id_in_use = j;
                    }
                }
                if (extra.highest_id_in_use > extra.highest_id_ever) {
                    extra.highest_id_ever = extra.highest_id_in_use;
                }
            }
            break;
            case 12: // decay houses services coverage
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_UNUSED && b->type != BUILDING_TOWER) {
                        if (b->houses_covered <= 1) {
                            b->houses_covered = 0;
                        } else {
                            b->houses_covered--;
                        }
                    }
                }
                break;
            case 16: // calculate warehouse stocks
            {
                for (int j = 0; j < RESOURCE_TYPES_MAX; j++) {
                    city_data.resource.space_in_warehouses[i] = 0;
                    city_data.resource.stored_in_warehouses[i] = 0;
                }
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_WAREHOUSE) {
                        b->has_road_access = 0;
                        if (map_has_road_access(b->x, b->y, b->size, 0)) {
                            b->has_road_access = 1;
                        } else if (map_has_road_access(b->x, b->y, 3, 0)) {
                            b->has_road_access = 2;
                        }
                    }
                }
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_WAREHOUSE_SPACE) {
                        continue;
                    }
                    struct building_t *warehouse = building_main(b);
                    if (warehouse->has_road_access) {
                        b->has_road_access = warehouse->has_road_access;
                        if (b->subtype.warehouse_resource_id) {
                            int loads = b->loads_stored;
                            int resource = b->subtype.warehouse_resource_id;
                            city_data.resource.stored_in_warehouses[resource] += loads;
                            city_data.resource.space_in_warehouses[resource] += 4 - loads;
                        } else {
                            city_data.resource.space_in_warehouses[RESOURCE_NONE] += 4;
                        }
                    }
                }
            }
            break;
            case 17: city_resource_calculate_food_stocks_and_supply_wheat(); break;
            case 18: // calculate workshop stocks
            {
                for (int j = 0; j < 6; j++) {
                    city_data.resource.stored_in_workshops[j] = 0;
                    city_data.resource.space_in_workshops[j] = 0;
                }
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE || !building_is_workshop(b->type)) {
                        continue;
                    }
                    b->has_road_access = 0;
                    if (map_has_road_access(b->x, b->y, b->size, 0)) {
                        b->has_road_access = 1;
                        int room = 2 - b->loads_stored;
                        if (room < 0) {
                            room = 0;
                        }
                        int workshop_resource = b->subtype.workshop_type;
                        city_data.resource.space_in_workshops[workshop_resource] += room;
                        city_data.resource.stored_in_workshops[workshop_resource] += b->loads_stored;
                    }
                }
            }
            break;
            case 19: // update dock open water access
                map_routing_calculate_distances_water_boat(scenario.river_entry_point.x, scenario.river_entry_point.y);
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state == BUILDING_STATE_IN_USE && !b->house_size && b->type == BUILDING_DOCK) {
                        if (map_terrain_is_adjacent_to_open_water(b->x, b->y, 3)) {
                            b->has_water_access = 1;
                        } else {
                            b->has_water_access = 0;
                        }
                    }
                }
                break;
            case 20: // update industry production
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE || !b->output_resource_id) {
                        continue;
                    }
                    b->data.industry.has_raw_materials = 0;
                    if (b->houses_covered <= 0 || b->num_workers <= 0) {
                        continue;
                    }
                    if (b->subtype.workshop_type && !b->loads_stored) {
                        continue;
                    }
                    if (b->data.industry.curse_days_left) {
                        b->data.industry.curse_days_left--;
                    } else {
                        if (b->data.industry.blessing_days_left) {
                            b->data.industry.blessing_days_left--;
                        }
                        if (b->type == BUILDING_MARBLE_QUARRY) {
                            b->data.industry.progress += b->num_workers / 2;
                        } else {
                            b->data.industry.progress += b->num_workers;
                        }
                        if (b->data.industry.blessing_days_left && building_is_farm(b->type)) {
                            b->data.industry.progress += b->num_workers;
                        }
                        int max = b->subtype.workshop_type ? MAX_PROGRESS_WORKSHOP : MAX_PROGRESS_RAW;
                        if (b->data.industry.progress > max) {
                            b->data.industry.progress = max;
                        }
                        if (building_is_farm(b->type)) {
                            update_farm_image(b);
                        }
                    }
                }
                break;
            case 22: // update house room
                city_data.population.total_capacity = 0;
                city_data.population.room_in_houses = 0;

                building_list_large_clear(0);
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state == BUILDING_STATE_IN_USE && b->house_size) {
                        building_list_large_add(j);
                    }
                }
                houses = building_list_large_items();
                for (int j = 0; j < building_list_data.large.size; j++) {
                    struct building_t *b = &all_buildings[houses[j]];
                    b->house_population_room = 0;
                    int max_pop = house_properties[b->subtype.house_level].max_people;
                    if (b->house_is_merged) {
                        max_pop *= 4;
                    }
                    city_data.population.total_capacity += max_pop;
                    city_data.population.room_in_houses += max_pop - b->house_population;
                    b->house_population_room = max_pop - b->house_population;
                    if (b->house_population > b->house_highest_population) {
                        b->house_highest_population = b->house_population;
                    }
                }
                break;
            case 23: // update migration
                if (city_data.sentiment.value > 70) {
                    city_data.migration.percentage = 100;
                } else if (city_data.sentiment.value > 60) {
                    city_data.migration.percentage = 75;
                } else if (city_data.sentiment.value >= 50) {
                    city_data.migration.percentage = 50;
                } else if (city_data.sentiment.value > 40) {
                    city_data.migration.percentage = 0;
                } else if (city_data.sentiment.value > 30) {
                    city_data.migration.percentage = -10;
                } else if (city_data.sentiment.value > 20) {
                    city_data.migration.percentage = -25;
                } else {
                    city_data.migration.percentage = -50;
                }
                city_data.migration.immigration_amount_per_batch = 0;
                city_data.migration.emigration_amount_per_batch = 0;
                unsigned int population_cap = 200000;
                if (city_data.population.population >= population_cap) {
                    city_data.migration.percentage = 0;
                } else if (city_figures_total_invading_enemies() > 3 && city_data.migration.percentage > 0) { // war scares immigrants away
                    city_data.migration.percentage = 0;
                } else {
                    if (city_data.migration.percentage > 0) {
                        // immigration
                        if (city_data.migration.emigration_duration) {
                            city_data.migration.emigration_duration--;
                        } else {
                            city_data.migration.immigration_amount_per_batch = calc_adjust_with_percentage(12, city_data.migration.percentage);
                            city_data.migration.immigration_duration = 2;
                        }
                    } else if (city_data.migration.percentage < 0) {
                        // emigration
                        if (city_data.migration.immigration_duration) {
                            city_data.migration.immigration_duration--;
                        } else if (city_data.population.population > 100) {
                            city_data.migration.emigration_amount_per_batch = calc_adjust_with_percentage(12, -city_data.migration.percentage);
                            city_data.migration.emigration_duration = 2;
                        }
                    }
                }
                city_data.migration.immigrated_today = 0;
                city_data.migration.emigrated_today = 0;
                city_data.migration.refused_immigrants_today = 0;
                if (city_data.migration.immigration_amount_per_batch > 0) {
                    if (city_data.migration.immigration_amount_per_batch >= 4) {
                        create_immigrants(city_data.migration.immigration_amount_per_batch);
                    } else if (city_data.migration.immigration_amount_per_batch
                        + city_data.migration.immigration_queue_size >= 4) {
                        create_immigrants(city_data.migration.immigration_amount_per_batch
                            + city_data.migration.immigration_queue_size);
                        city_data.migration.immigration_queue_size = 0;
                    } else {
                        // queue them for next round
                        city_data.migration.immigration_queue_size += city_data.migration.immigration_amount_per_batch;
                    }
                }
                if (city_data.migration.emigration_amount_per_batch > 0) {
                    if (city_data.migration.emigration_amount_per_batch >= 4) {
                        create_emigrants(city_data.migration.emigration_amount_per_batch);
                    } else if (city_data.migration.emigration_amount_per_batch + city_data.migration.emigration_queue_size >= 4) {
                        create_emigrants(city_data.migration.emigration_amount_per_batch
                            + city_data.migration.emigration_queue_size);
                        city_data.migration.emigration_queue_size = 0;
                        if (!city_data.migration.emigration_message_shown) {
                            city_data.migration.emigration_message_shown = 1;
                            city_message_post(1, MESSAGE_EMIGRATION, 0, 0);
                        }
                    } else {
                        // queue them for next round
                        city_data.migration.emigration_queue_size += city_data.migration.emigration_amount_per_batch;
                    }
                }
                city_data.migration.immigration_amount_per_batch = 0;
                city_data.migration.emigration_amount_per_batch = 0;
                if (city_data.population.yearly_update_requested) {
                    int aged100 = city_data.population.at_age[99];
                    for (int age = 99; age > 0; age--) {
                        city_data.population.at_age[age] = city_data.population.at_age[age - 1];
                    }
                    city_data.population.at_age[0] = 0;
                    city_data.population.yearly_deaths = 0;
                    for (int decennium = 9; decennium >= 0; decennium--) {
                        int people = get_people_in_age_decennium(decennium);
                        int death_percentage = DEATHS_PER_HEALTH_PER_AGE_DECENNIUM[city_data.health.value / 10][decennium];
                        int deaths = calc_adjust_with_percentage(people, death_percentage);
                        int removed = house_population_remove_from_city(deaths + aged100);
                        int empty_buckets = 0;
                        int age = 0;
                        while (deaths > 0 && empty_buckets < 10) {
                            if (city_data.population.at_age[10 * decennium + age] <= 0) {
                                empty_buckets++;
                            } else {
                                city_data.population.at_age[10 * decennium + age]--;
                                deaths--;
                                empty_buckets = 0;
                            }
                            age++;
                            if (age >= 10) {
                                age = 0;
                            }
                        }
                        city_data.population.yearly_deaths += removed;
                        aged100 = 0;
                    }
                    city_data.population.yearly_births = 0;
                    for (int decennium = 9; decennium >= 0; decennium--) {
                        int people = get_people_in_age_decennium(decennium);
                        int births = calc_adjust_with_percentage(people, BIRTHS_PER_AGE_DECENNIUM[decennium]);
                        int added = 0;
                        int building_id = city_data.population.last_used_house_add;
                        for (int k = 1; k < MAX_BUILDINGS && added < births; k++) {
                            if (++building_id >= MAX_BUILDINGS) {
                                building_id = 1;
                            }
                            struct building_t *b = &all_buildings[building_id];
                            if (b->state == BUILDING_STATE_IN_USE && b->house_size && b->house_population > 0) {
                                city_data.population.last_used_house_add = building_id;
                                int max_people = house_properties[b->subtype.house_level].max_people;
                                if (b->house_is_merged) {
                                    max_people *= 4;
                                }
                                if (b->house_population < max_people) {
                                    ++added;
                                    ++b->house_population;
                                    b->house_population_room = max_people - b->house_population;
                                }
                            }
                        }
                        city_data.population.at_age[0] += added;
                        city_data.population.yearly_births += added;
                    }
                    city_data.population.yearly_update_requested = 0;
                    city_data.population.population_last_year = city_data.population.population;
                    recalculate_population();
                    city_data.population.lost_removal = 0;
                    city_data.population.total_all_years += city_data.population.population;
                    city_data.population.total_years++;
                    city_data.population.average_per_year = city_data.population.total_all_years / city_data.population.total_years;
                }
                int num_plebs = 0;
                int num_patricians = 0;
                houses = building_list_large_items();
                for (int j = 0; j < building_list_data.large.size; j++) {
                    struct building_t *b = &all_buildings[houses[j]];
                    if (b->house_population > 0) {
                        if (b->subtype.house_level >= HOUSE_SMALL_VILLA) {
                            num_patricians += b->house_population;
                        } else {
                            num_plebs += b->house_population;
                        }
                    }
                }
                city_data.population.percentage_plebs = calc_percentage(num_plebs, num_plebs + num_patricians);
                city_data.population.working_age = calc_adjust_with_percentage(get_people_in_age_decennium(2) + get_people_in_age_decennium(3) + get_people_in_age_decennium(4), 60);
                city_data.labor.workers_available = calc_adjust_with_percentage(city_data.population.working_age, city_data.population.percentage_plebs);
                // population messages
                if (city_data.population.population >= 500 && city_message_mark_population_shown(500)) {
                    city_message_post(1, MESSAGE_POPULATION_500, 0, 0);
                }
                if (city_data.population.population >= 1000 && city_message_mark_population_shown(1000)) {
                    city_message_post(1, MESSAGE_POPULATION_1000, 0, 0);
                }
                if (city_data.population.population >= 2000 && city_message_mark_population_shown(2000)) {
                    city_message_post(1, MESSAGE_POPULATION_2000, 0, 0);
                }
                if (city_data.population.population >= 3000 && city_message_mark_population_shown(3000)) {
                    city_message_post(1, MESSAGE_POPULATION_3000, 0, 0);
                }
                if (city_data.population.population >= 5000 && city_message_mark_population_shown(5000)) {
                    city_message_post(1, MESSAGE_POPULATION_5000, 0, 0);
                }
                if (city_data.population.population >= 10000 && city_message_mark_population_shown(10000)) {
                    city_message_post(1, MESSAGE_POPULATION_10000, 0, 0);
                }
                if (city_data.population.population >= 15000 && city_message_mark_population_shown(15000)) {
                    city_message_post(1, MESSAGE_POPULATION_15000, 0, 0);
                }
                if (city_data.population.population >= 20000 && city_message_mark_population_shown(20000)) {
                    city_message_post(1, MESSAGE_POPULATION_20000, 0, 0);
                }
                if (city_data.population.population >= 25000 && city_message_mark_population_shown(25000)) {
                    city_message_post(1, MESSAGE_POPULATION_25000, 0, 0);
                }
                break;
            case 24: // evict overcrowded
            {
                int *items = building_list_large_items();
                for (int j = 0; j < building_list_data.large.size; j++) {
                    struct building_t *b = &all_buildings[items[j]];
                    if (b->house_population_room < 0) {
                        int num_people_to_evict = -b->house_population_room;
                        figure_create_homeless(b->x, b->y, num_people_to_evict);
                        if (num_people_to_evict < b->house_population) {
                            b->house_population -= num_people_to_evict;
                        } else {
                            // house has been removed
                            b->state = BUILDING_STATE_UNDO;
                        }
                    }
                }
                break;
            }
            case 25: // update labor
            {    // calculate workers needed per category
                for (int cat = 0; cat < LABOR_CATEGORIES_COUNT; cat++) {
                    city_data.labor.categories[cat].buildings = 0;
                    city_data.labor.categories[cat].total_houses_covered = 0;
                    city_data.labor.categories[cat].workers_allocated = 0;
                    city_data.labor.categories[cat].workers_needed = 0;
                }
                for (int k = 1; k < MAX_BUILDINGS; k++) {
                    struct building_t *b = &all_buildings[k];
                    if (b->state != BUILDING_STATE_IN_USE) {
                        continue;
                    }
                    b->labor_category = building_properties[b->type].labor_category;
                    if (!should_have_workers(b, 1)) {
                        continue;
                    }
                    city_data.labor.categories[b->labor_category].workers_needed += building_properties[b->type].n_laborers;
                    city_data.labor.categories[b->labor_category].total_houses_covered += b->houses_covered;
                    city_data.labor.categories[b->labor_category].buildings++;
                }
                // check employment
                int orig_needed = city_data.labor.workers_needed;
                allocate_workers_to_categories();
                // senate unemployment display is delayed when unemployment is rising
                if (city_data.labor.unemployment_percentage < city_data.labor.unemployment_percentage_for_senate) {
                    city_data.labor.unemployment_percentage_for_senate = city_data.labor.unemployment_percentage;
                } else if (city_data.labor.unemployment_percentage < city_data.labor.unemployment_percentage_for_senate + 5) {
                    city_data.labor.unemployment_percentage_for_senate = city_data.labor.unemployment_percentage;
                } else {
                    city_data.labor.unemployment_percentage_for_senate += 5;
                }
                if (city_data.labor.unemployment_percentage_for_senate > 100) {
                    city_data.labor.unemployment_percentage_for_senate = 100;
                }
                // workers needed message
                if (!orig_needed && city_data.labor.workers_needed > 0) {
                    if (time_data.year >= scenario.start_year) {
                        city_message_post_with_message_delay(MESSAGE_CAT_WORKERS_NEEDED, 0, MESSAGE_WORKERS_NEEDED, 6);
                    }
                }
                allocate_workers_to_buildings();
            }
            break;
            case 27: // update water supply
            {
                for (int k = 0; k < GRID_SIZE * GRID_SIZE; k++) {
                    terrain_grid.items[k] &= ~(TERRAIN_FOUNTAIN_RANGE | TERRAIN_RESERVOIR_RANGE);
                }
                // reservoirs
                int image_without_water = image_data_s.group_image_ids[GROUP_BUILDING_AQUEDUCT_NO_WATER];
                int grid_offset = map_data.start_offset;
                for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
                    for (int x = 0; x < map_data.width; x++, grid_offset++) {
                        if (map_terrain_is(grid_offset, TERRAIN_AQUEDUCT)) {
                            aqueduct.items[grid_offset] = 0;
                            if (images.items[grid_offset] < image_without_water) {
                                images.items[grid_offset] = images.items[grid_offset] + 15;
                            }
                        }
                    }
                }
                building_list_large_clear(1);
                // mark reservoirs next to water
                for (int k = 1; k < MAX_BUILDINGS; k++) {
                    struct building_t *b = &all_buildings[i];
                    if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_RESERVOIR) {
                        building_list_large_add(k);
                        if (map_terrain_exists_tile_in_area_with_type(b->x - 1, b->y - 1, 5, TERRAIN_WATER)) {
                            b->has_water_access = 2;
                        } else {
                            b->has_water_access = 0;
                        }
                    }
                }
                int *reservoirs = building_list_large_items();
                // fill reservoirs from full ones
                int changed = 1;
                static   int CONNECTOR_OFFSETS[] = { OFFSET(1,-1), OFFSET(3,1), OFFSET(1,3), OFFSET(-1,1) };
                while (changed == 1) {
                    changed = 0;
                    for (int l = 0; l < building_list_data.large.size; l++) {
                        struct building_t *b = &all_buildings[reservoirs[l]];
                        if (b->has_water_access == 2) {
                            b->has_water_access = 1;
                            changed = 1;
                            for (int d = 0; d < 4; d++) {
                                int grid_offset2 = b->grid_offset + CONNECTOR_OFFSETS[d];
                                if (map_terrain_is(grid_offset2, TERRAIN_AQUEDUCT)) {
                                    memset(&water_supply_queue, 0, sizeof(water_supply_queue));
                                    int guard = 0;
                                    int next_offset;
                                    do {
                                        if (++guard >= GRID_SIZE * GRID_SIZE) {
                                            break;
                                        }
                                        aqueduct.items[grid_offset2] = 1;
                                        int image_id = images.items[grid_offset2];
                                        if (image_id >= image_without_water) {
                                            images.items[grid_offset2] = image_id - 15;
                                        }
                                        next_offset = -1;
                                        for (int j = 0; j < 4; j++) {
                                            int new_offset = grid_offset2 + ADJACENT_OFFSETS_ROUTING[j];
                                            struct building_t *bb = &all_buildings[map_building_at(new_offset)];
                                            if (bb->id && bb->type == BUILDING_RESERVOIR) {
                                                // check if aqueduct connects to reservoir --> doesn't connect to corner
                                                int xy = edge_grid.items[new_offset] & EDGE_MASK_XY;
                                                if (xy != EDGE_X0Y0 && xy != EDGE_X2Y0 && xy != EDGE_X0Y2 && xy != EDGE_X2Y2) {
                                                    if (!bb->has_water_access) {
                                                        bb->has_water_access = 2;
                                                    }
                                                }
                                            } else if (map_terrain_is(new_offset, TERRAIN_AQUEDUCT)) {
                                                if (!aqueduct.items[new_offset]) {
                                                    if (next_offset == -1) {
                                                        next_offset = new_offset;
                                                    } else {
                                                        water_supply_queue.items[water_supply_queue.tail++] = new_offset;
                                                        if (water_supply_queue.tail >= MAX_QUEUE) {
                                                            water_supply_queue.tail = 0;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        if (next_offset == -1) {
                                            if (water_supply_queue.head != water_supply_queue.tail) {
                                                next_offset = water_supply_queue.items[water_supply_queue.head++];
                                                if (water_supply_queue.head >= MAX_QUEUE) {
                                                    water_supply_queue.head = 0;
                                                }
                                            }
                                        }
                                        grid_offset2 = next_offset;
                                    } while (next_offset > -1);
                                }
                            }
                        }
                    }
                }
                // mark reservoir ranges
                for (int k = 0; k < building_list_data.large.size; k++) {
                    struct building_t *b = &all_buildings[reservoirs[k]];
                    if (b->has_water_access) {
                        map_terrain_add_with_radius(b->x, b->y, 3, 10, TERRAIN_RESERVOIR_RANGE);
                    }
                }
                // fountains
                for (int k = 1; k < MAX_BUILDINGS; k++) {
                    struct building_t *b = &all_buildings[k];
                    if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_FOUNTAIN) {
                        continue;
                    }
                    int image_id;
                    if (desirability_grid.items[b->grid_offset] > 60) {
                        image_id = image_data_s.group_image_ids[GROUP_BUILDING_FOUNTAIN_4];
                    } else if (desirability_grid.items[b->grid_offset] > 40) {
                        image_id = image_data_s.group_image_ids[GROUP_BUILDING_FOUNTAIN_3];
                    } else if (desirability_grid.items[b->grid_offset] > 20) {
                        image_id = image_data_s.group_image_ids[GROUP_BUILDING_FOUNTAIN_2];
                    } else {
                        image_id = image_data_s.group_image_ids[GROUP_BUILDING_FOUNTAIN_1];
                    }
                    map_building_tiles_add(i, b->x, b->y, 1, image_id, TERRAIN_BUILDING);
                    if (map_terrain_is(b->grid_offset, TERRAIN_RESERVOIR_RANGE) && b->num_workers) {
                        b->has_water_access = 1;
                        map_terrain_add_with_radius(b->x, b->y, 1,
                            scenario.climate == CLIMATE_DESERT ? 3 : 4,
                            TERRAIN_FOUNTAIN_RANGE);
                    } else {
                        b->has_water_access = 0;
                    }
                }
                // wells (to show range in water overlay)
                for (int k = 1; k < MAX_BUILDINGS; k++) {
                    struct building_t *b = &all_buildings[k];
                    if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_WELL) {
                        continue;
                    }
                    map_terrain_add_with_radius(b->x, b->y, 1, 2, TERRAIN_FOUNTAIN_RANGE);
                }
            }
            break;
            case 28: // update houses water supply
                building_list_data.small.size = 0;
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE) {
                        continue;
                    }
                    if (b->type == BUILDING_WELL) {
                        building_list_small_add(j);
                    } else if (b->house_size) {
                        b->has_water_access = 0;
                        b->has_well_access = 0;
                        if (map_terrain_exists_tile_in_area_with_type(
                            b->x, b->y, b->size, TERRAIN_FOUNTAIN_RANGE)) {
                            b->has_water_access = 1;
                        }
                    }
                }
                for (int j = 0; j < building_list_data.small.size; j++) {
                    struct building_t *well = &all_buildings[building_list_data.small.items[j]];
                    int x_min, y_min, x_max, y_max;
                    map_grid_get_area(well->x, well->y, 1, 2, &x_min, &y_min, &x_max, &y_max);

                    for (int yy = y_min; yy <= y_max; yy++) {
                        for (int xx = x_min; xx <= x_max; xx++) {
                            int building_id = map_building_at(map_grid_offset(xx, yy));
                            if (building_id) {
                                all_buildings[building_id].has_well_access = 1;
                            }
                        }
                    }
                }
                break;
            case 30:
                minimap_data.refresh_requested = 1;
                break;
            case 31: // generate building figures
            {
                if (tower_sentry_request > 0) {
                    tower_sentry_request--;
                }
                for (int k = 1; k <= extra.highest_id_in_use; k++) {
                    struct building_t *b = &all_buildings[k];
                    if (b->state != BUILDING_STATE_IN_USE) {
                        continue;
                    }
                    if (b->type == BUILDING_WAREHOUSE_SPACE || (b->type == BUILDING_HIPPODROME && b->prev_part_building_id)) {
                        continue;
                    }
                    b->show_on_problem_overlay = 0;
                    // range of building types
                    if (b->type >= BUILDING_HOUSE_SMALL_VILLA && b->type <= BUILDING_HOUSE_LUXURY_PALACE) {
                        struct map_point_t road;
                        if (map_has_road_access(b->x, b->y, b->size, &road)) {
                            b->figure_spawn_delay++;
                            if (b->figure_spawn_delay > 40) {
                                b->figure_spawn_delay = 0;
                                struct figure_t *f = figure_create(FIGURE_PATRICIAN, road.x, road.y, DIR_4_BOTTOM);
                                f->action_state = FIGURE_ACTION_ROAMING;
                                f->is_targetable = 1;
                                f->terrain_usage = TERRAIN_USAGE_ROADS;
                                f->building_id = b->id;
                                figure_movement_init_roaming(f);
                            }
                        }
                    } else if (b->type >= BUILDING_WHEAT_FARM && b->type <= BUILDING_WEAPONS_WORKSHOP) {
                        check_labor_problem(b);
                        struct map_point_t road;
                        if (map_has_road_access(b->x, b->y, b->size, &road)) {
                            spawn_labor_seeker(b, road.x, road.y, 50);
                            if (!has_figure_of_types(b, FIGURE_CART_PUSHER, 0)) {
                                if (b->data.industry.progress >= (b->subtype.workshop_type ? MAX_PROGRESS_WORKSHOP : MAX_PROGRESS_RAW)) {
                                    b->data.industry.progress = 0;
                                    if (b->subtype.workshop_type) {
                                        if (b->loads_stored) {
                                            if (b->loads_stored > 1) {
                                                b->data.industry.has_raw_materials = 1;
                                            }
                                            b->loads_stored--;
                                        }
                                    }
                                    if (building_is_farm(b->type)) {
                                        update_farm_image(b);
                                    }
                                    struct figure_t *f = figure_create(FIGURE_CART_PUSHER, road.x, road.y, DIR_4_BOTTOM);
                                    f->action_state = FIGURE_ACTION_CARTPUSHER_INITIAL;
                                    f->is_targetable = 1;
                                    f->terrain_usage = TERRAIN_USAGE_ROADS;
                                    f->resource_id = b->output_resource_id;
                                    f->building_id = b->id;
                                    b->figure_id = f->id;
                                    f->wait_ticks = 30;
                                }
                            }
                        }
                    } else if (b->type == BUILDING_SENATE || b->type == BUILDING_FORUM) {
                        if (b->type == BUILDING_SENATE && b->state == BUILDING_STATE_IN_USE) {
                            if (desirability_grid.items[b->grid_offset] <= 30) {
                                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_SENATE], TERRAIN_BUILDING);
                            } else {
                                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_SENATE_FANCY], TERRAIN_BUILDING);
                            }
                        }
                        check_labor_problem(b);
                        if (!has_figure_of_types(b, FIGURE_TAX_COLLECTOR, 0)) {
                            struct map_point_t road;
                            if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                spawn_labor_seeker(b, road.x, road.y, 50);
                                int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                int spawn_delay;
                                if (pct_workers >= 100) {
                                    spawn_delay = 0;
                                } else if (pct_workers >= 75) {
                                    spawn_delay = 1;
                                } else if (pct_workers >= 50) {
                                    spawn_delay = 3;
                                } else if (pct_workers >= 25) {
                                    spawn_delay = 7;
                                } else if (pct_workers >= 1) {
                                    spawn_delay = 15;
                                } else {
                                    spawn_delay = INFINITE;
                                }
                                b->figure_spawn_delay++;
                                if (b->figure_spawn_delay > spawn_delay) {
                                    b->figure_spawn_delay = 0;
                                    struct figure_t *f = figure_create(FIGURE_TAX_COLLECTOR, road.x, road.y, DIR_0_TOP);
                                    f->action_state = FIGURE_ACTION_TAX_COLLECTOR_CREATED;
                                    f->is_targetable = 1;
                                    f->terrain_usage = TERRAIN_USAGE_ROADS;
                                    f->building_id = b->id;
                                    b->figure_id = f->id;
                                }
                            }
                        }
                    } else if (b->type >= BUILDING_SMALL_TEMPLE_CERES && b->type <= BUILDING_LARGE_TEMPLE_VENUS) {
                        check_labor_problem(b);
                        if (!has_figure_of_types(b, FIGURE_PRIEST, 0)) {
                            struct map_point_t road;
                            if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                spawn_labor_seeker(b, road.x, road.y, 50);
                                int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                int spawn_delay;
                                if (building_properties[b->type].n_laborers <= 0) {
                                    spawn_delay = 7;
                                } else if (pct_workers >= 100) {
                                    spawn_delay = 3;
                                } else if (pct_workers >= 75) {
                                    spawn_delay = 7;
                                } else if (pct_workers >= 50) {
                                    spawn_delay = 10;
                                } else if (pct_workers >= 25) {
                                    spawn_delay = 15;
                                } else if (pct_workers >= 1) {
                                    spawn_delay = 20;
                                } else {
                                    spawn_delay = INFINITE;
                                }
                                b->figure_spawn_delay++;
                                if (b->figure_spawn_delay > spawn_delay) {
                                    b->figure_spawn_delay = 0;
                                    create_roaming_figure(b, road.x, road.y, FIGURE_PRIEST);
                                }
                            }
                        }
                    } else {
                        int x_out, y_out;
                        struct map_point_t road;
                        // single building type
                        switch (b->type) {
                            case BUILDING_WAREHOUSE:
                                check_labor_problem(b);
                                struct building_t *space = b;
                                for (int ii = 0; ii < 8; ii++) {
                                    space = &all_buildings[space->next_part_building_id];
                                    if (space->id) {
                                        space->show_on_problem_overlay = b->show_on_problem_overlay;
                                    }
                                }
                                if (map_has_road_access(b->x, b->y, b->size, &road) ||
                                    map_has_road_access(b->x, b->y, 3, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 100);
                                    if (!has_figure_of_types(b, FIGURE_WAREHOUSEMAN, 0)) {
                                        int resource;
                                        int task = WAREHOUSE_TASK_NONE;
                                        if (calc_percentage(b->num_workers, building_properties[b->type].n_laborers) < 50) {
                                            task = WAREHOUSE_TASK_NONE;
                                        } else {
                                            struct building_storage_t *s = &storages[b->storage_id].storage;
                                            // get resources
                                            for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                                if (s->resource_state[r] != BUILDING_STORAGE_STATE_GETTING || city_data.resource.stockpiled[r]) {
                                                    continue;
                                                }
                                                int loads_stored = 0;
                                                space = b;
                                                for (int ii = 0; ii < 8; ii++) {
                                                    space = &all_buildings[space->next_part_building_id];
                                                    if (space->id > 0 && space->loads_stored > 0) {
                                                        if (space->subtype.warehouse_resource_id == r) {
                                                            loads_stored += space->loads_stored;
                                                        }
                                                    }
                                                }
                                                int room = 0;
                                                space = b;
                                                for (int ii = 0; ii < 8; ii++) {
                                                    space = &all_buildings[space->next_part_building_id];
                                                    if (space->id > 0) {
                                                        if (space->loads_stored <= 0) {
                                                            room += 4;
                                                        }
                                                        if (space->subtype.warehouse_resource_id == r) {
                                                            room += 4 - space->loads_stored;
                                                        }
                                                    }
                                                }
                                                if (room >= 8 && loads_stored <= 4 && city_data.resource.stored_in_warehouses[r] - loads_stored > 4) {
                                                    resource = r;
                                                    task = WAREHOUSE_TASK_GETTING;
                                                }
                                            }
                                            if (task == WAREHOUSE_TASK_NONE) {
                                                // deliver weapons to barracks
                                                if (count_data.buildings[BUILDING_BARRACKS].active > 0 && city_data.military.legionary_legions && !city_data.resource.stockpiled[RESOURCE_WEAPONS]) {
                                                    struct building_t *barracks = &all_buildings[city_data.building.barracks_building_id];
                                                    if (barracks->loads_stored < 4 && b->road_network_id == barracks->road_network_id) {
                                                        space = b;
                                                        for (int ii = 0; ii < 8; ii++) {
                                                            space = &all_buildings[space->next_part_building_id];
                                                            if (space->id > 0 && space->loads_stored > 0 && space->subtype.warehouse_resource_id == RESOURCE_WEAPONS) {
                                                                resource = RESOURCE_WEAPONS;
                                                                task = WAREHOUSE_TASK_DELIVERING;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            if (task == WAREHOUSE_TASK_NONE) {
                                                // deliver raw materials to workshops
                                                space = b;
                                                for (int ii = 0; ii < 8; ii++) {
                                                    space = &all_buildings[space->next_part_building_id];
                                                    if (space->id > 0 && space->loads_stored > 0) {
                                                        if (!city_data.resource.stockpiled[space->subtype.warehouse_resource_id]) {
                                                            int workshop_type = resource_to_workshop_type(space->subtype.warehouse_resource_id);
                                                            if (workshop_type != WORKSHOP_NONE && city_data.resource.space_in_workshops[workshop_type]) {
                                                                resource = space->subtype.warehouse_resource_id;
                                                                task = WAREHOUSE_TASK_DELIVERING;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            if (!scenario.rome_supplies_wheat && task == WAREHOUSE_TASK_NONE) {
                                                // deliver food to getting granary
                                                int granary_resources[FOOD_TYPES_MAX];
                                                int can_deliver_to_granary = 0;
                                                for (int ii = 0; ii < FOOD_TYPES_MAX; ii++) {
                                                    granary_resources[ii] = 0;
                                                }
                                                for (int ii = 1; ii < MAX_BUILDINGS; ii++) {
                                                    struct building_t *bb = &all_buildings[ii];
                                                    if (bb->state != BUILDING_STATE_IN_USE || bb->type != BUILDING_GRANARY || !bb->has_road_access) {
                                                        continue;
                                                    }
                                                    if (calc_percentage(bb->num_workers, building_properties[bb->type].n_laborers) >= 100 && bb->data.granary.resource_stored[RESOURCE_NONE] > 100) {
                                                        struct building_storage_t *st = &storages[b->storage_id].storage;
                                                        if (!st->empty_all) {
                                                            for (int r = 0; r < FOOD_TYPES_MAX; r++) {
                                                                if (st->resource_state[r] == BUILDING_STORAGE_STATE_GETTING) {
                                                                    granary_resources[r]++;
                                                                    can_deliver_to_granary = 1;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                if (can_deliver_to_granary) {
                                                    space = b;
                                                    for (int ii = 0; ii < 8; ii++) {
                                                        space = &all_buildings[space->next_part_building_id];
                                                        if (contains_non_stockpiled_food(space, granary_resources)) {
                                                            resource = space->subtype.warehouse_resource_id;
                                                            task = WAREHOUSE_TASK_DELIVERING;
                                                        }
                                                    }
                                                }
                                                // deliver food to accepting granary
                                                if (task == WAREHOUSE_TASK_NONE) {
                                                    int granary_can_accept = 0;
                                                    for (int ii = 0; ii < FOOD_TYPES_MAX; ii++) {
                                                        granary_resources[ii] = 0;
                                                    }
                                                    for (int ii = 1; ii < MAX_BUILDINGS; ii++) {
                                                        struct building_t *bb = &all_buildings[ii];
                                                        if (bb->state != BUILDING_STATE_IN_USE || bb->type != BUILDING_GRANARY || !bb->has_road_access) {
                                                            continue;
                                                        }
                                                        if (calc_percentage(bb->num_workers, building_properties[bb->type].n_laborers) >= 100 && bb->data.granary.resource_stored[RESOURCE_NONE] >= 1200) {
                                                            struct building_storage_t *st = &storages[bb->storage_id].storage;
                                                            if (!st->empty_all) {
                                                                for (int r = 0; r < FOOD_TYPES_MAX; r++) {
                                                                    if (st->resource_state[r] != BUILDING_STORAGE_STATE_NOT_ACCEPTING) {
                                                                        granary_resources[r]++;
                                                                        granary_can_accept = 1;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    if (granary_can_accept) {
                                                        space = b;
                                                        for (int ii = 0; ii < 8; ii++) {
                                                            space = &all_buildings[space->next_part_building_id];
                                                            if (contains_non_stockpiled_food(space, granary_resources)) {
                                                                resource = space->subtype.warehouse_resource_id;
                                                                task = WAREHOUSE_TASK_DELIVERING;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            // move goods to other warehouses
                                            if (s->empty_all) {
                                                space = b;
                                                for (int ii = 0; ii < 8; ii++) {
                                                    space = &all_buildings[space->next_part_building_id];
                                                    if (space->id > 0 && space->loads_stored > 0) {
                                                        resource = space->subtype.warehouse_resource_id;
                                                        task = WAREHOUSE_TASK_DELIVERING;
                                                    }
                                                }
                                            }
                                        }
                                        if (task != WAREHOUSE_TASK_NONE) {
                                            struct figure_t *f = figure_create(FIGURE_WAREHOUSEMAN, road.x, road.y, DIR_4_BOTTOM);
                                            f->is_targetable = 1;
                                            f->action_state = FIGURE_ACTION_WAREHOUSEMAN_CREATED;
                                            if (task == WAREHOUSE_TASK_GETTING) {
                                                f->resource_id = RESOURCE_NONE;
                                                f->collecting_item_id = resource;
                                            } else {
                                                f->resource_id = resource;
                                            }
                                            b->figure_id = f->id;
                                            f->building_id = b->id;
                                        }
                                    }
                                }
                                break;
                            case BUILDING_GRANARY:
                                check_labor_problem(b);
                                if (map_has_road_access_granary(b->x, b->y, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 100);
                                    if (!has_figure_of_types(b, FIGURE_WAREHOUSEMAN, 0)) {
                                        struct building_storage_t *s = &storages[b->storage_id].storage;
                                        int task = GRANARY_TASK_NONE;
                                        if (calc_percentage(b->num_workers, building_properties[b->type].n_laborers) < 50
                                        || b->data.granary.resource_stored[RESOURCE_NONE] <= 0) { // granary full, nothing to get
                                            task = GRANARY_TASK_NONE;
                                        } else if (s->empty_all) {
                                            // bring food to another granary
                                            for (int ii = RESOURCE_WHEAT; ii < FOOD_TYPES_MAX; ii++) {
                                                if (b->data.granary.resource_stored[k]) {
                                                    task = GRANARY_TASK_GETTING;
                                                    break;
                                                }
                                            }
                                        } else if ((s->resource_state[RESOURCE_WHEAT] == BUILDING_STORAGE_STATE_GETTING && non_getting_granaries.total_storage_wheat > ONE_LOAD)
                                        || (s->resource_state[RESOURCE_VEGETABLES] == BUILDING_STORAGE_STATE_GETTING && non_getting_granaries.total_storage_vegetables > ONE_LOAD)
                                        || (s->resource_state[RESOURCE_FRUIT] == BUILDING_STORAGE_STATE_GETTING && non_getting_granaries.total_storage_fruit > ONE_LOAD)
                                        || (s->resource_state[RESOURCE_MEAT] == BUILDING_STORAGE_STATE_GETTING && non_getting_granaries.total_storage_meat > ONE_LOAD)) {
                                            task = GRANARY_TASK_GETTING;
                                        }
                                        if (task != GRANARY_TASK_NONE) {
                                            struct figure_t *f = figure_create(FIGURE_WAREHOUSEMAN, road.x, road.y, DIR_4_BOTTOM);
                                            f->is_targetable = 1;
                                            f->action_state = FIGURE_ACTION_WAREHOUSEMAN_CREATED;
                                            f->resource_id = task;
                                            b->figure_id = f->id;
                                            f->building_id = b->id;
                                        }
                                    }
                                }
                                break;
                            case BUILDING_TOWER:
                                check_labor_problem(b);
                                if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 50);
                                    if (b->num_workers) {
                                        if (!b->figure_id4 && b->figure_id) { // has sentry but no ballista -> create
                                            struct figure_t *f = figure_create(FIGURE_BALLISTA, b->x, b->y, DIR_0_TOP);
                                            b->figure_id4 = f->id;
                                            f->building_id = b->id;
                                            f->action_state = FIGURE_ACTION_BALLISTA_READY;
                                            f->terrain_usage = TERRAIN_USAGE_WALLS;
                                        }
                                        has_figure_of_types(b, FIGURE_TOWER_SENTRY, 0);
                                        if (b->figure_id <= 0) {
                                            tower_sentry_request = 2;
                                        }
                                    }
                                }
                                break;
                            case BUILDING_ENGINEERS_POST:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_ENGINEER, 0)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        spawn_labor_seeker(b, road.x, road.y, 100);
                                        int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                        int spawn_delay;
                                        if (pct_workers >= 100) {
                                            spawn_delay = 0;
                                        } else if (pct_workers >= 75) {
                                            spawn_delay = 1;
                                        } else if (pct_workers >= 50) {
                                            spawn_delay = 3;
                                        } else if (pct_workers >= 25) {
                                            spawn_delay = 7;
                                        } else if (pct_workers >= 1) {
                                            spawn_delay = 15;
                                        } else {
                                            spawn_delay = INFINITE;
                                        }
                                        b->figure_spawn_delay++;
                                        if (b->figure_spawn_delay > spawn_delay) {
                                            b->figure_spawn_delay = 0;
                                            struct figure_t *f = figure_create(FIGURE_ENGINEER, road.x, road.y, DIR_0_TOP);
                                            f->action_state = FIGURE_ACTION_ENGINEER_CREATED;
                                            f->is_targetable = 1;
                                            f->terrain_usage = TERRAIN_USAGE_ROADS;
                                            f->building_id = b->id;
                                            b->figure_id = f->id;
                                        }
                                    }
                                }
                                break;
                            case BUILDING_PREFECTURE:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_PREFECT, 0)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        spawn_labor_seeker(b, road.x, road.y, 100);
                                        int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                        int spawn_delay;
                                        if (pct_workers >= 100) {
                                            spawn_delay = 0;
                                        } else if (pct_workers >= 75) {
                                            spawn_delay = 1;
                                        } else if (pct_workers >= 50) {
                                            spawn_delay = 3;
                                        } else if (pct_workers >= 25) {
                                            spawn_delay = 7;
                                        } else if (pct_workers >= 1) {
                                            spawn_delay = 15;
                                        } else {
                                            spawn_delay = INFINITE;;
                                        }
                                        b->figure_spawn_delay++;
                                        if (b->figure_spawn_delay > spawn_delay) {
                                            b->figure_spawn_delay = 0;
                                            struct figure_t *f = figure_create(FIGURE_PREFECT, road.x, road.y, DIR_0_TOP);
                                            f->action_state = FIGURE_ACTION_PREFECT_CREATED;
                                            f->is_targetable = 1;
                                            f->building_id = b->id;
                                            b->figure_id = f->id;
                                        }
                                    }
                                }
                                break;
                            case BUILDING_ACTOR_COLONY:
                                check_labor_problem(b);
                                if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 50);
                                    int spawn_delay = default_spawn_delay(b);
                                    if (spawn_delay) {
                                        b->figure_spawn_delay++;
                                        if (b->figure_spawn_delay > spawn_delay) {
                                            b->figure_spawn_delay = 0;
                                            struct figure_t *f = figure_create(FIGURE_ACTOR, road.x, road.y, DIR_0_TOP);
                                            f->action_state = FIGURE_ACTION_ENTERTAINER_AT_SCHOOL_CREATED;
                                            f->is_targetable = 1;
                                            f->terrain_usage = TERRAIN_USAGE_ROADS;
                                            f->building_id = b->id;
                                            b->figure_id = f->id;
                                        }
                                    }
                                }
                                break;
                            case BUILDING_GLADIATOR_SCHOOL:
                                check_labor_problem(b);
                                if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 50);
                                    int spawn_delay = default_spawn_delay(b);
                                    if (spawn_delay) {
                                        b->figure_spawn_delay++;
                                        if (b->figure_spawn_delay > spawn_delay) {
                                            b->figure_spawn_delay = 0;
                                            if (scenario.gladiator_revolt.state != EVENT_IN_PROGRESS) {
                                                struct figure_t *f = figure_create(FIGURE_GLADIATOR, road.x, road.y, DIR_0_TOP);
                                                f->action_state = FIGURE_ACTION_ENTERTAINER_AT_SCHOOL_CREATED;
                                                f->is_targetable = 1;
                                                f->terrain_usage = TERRAIN_USAGE_ROADS;
                                                f->building_id = b->id;
                                                b->figure_id = f->id;
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_LION_HOUSE:
                                check_labor_problem(b);
                                if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 50);
                                    int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                    int spawn_delay;
                                    if (pct_workers >= 100) {
                                        spawn_delay = 5;
                                    } else if (pct_workers >= 75) {
                                        spawn_delay = 10;
                                    } else if (pct_workers >= 50) {
                                        spawn_delay = 20;
                                    } else if (pct_workers >= 25) {
                                        spawn_delay = 35;
                                    } else if (pct_workers >= 1) {
                                        spawn_delay = 60;
                                    } else {
                                        spawn_delay = INFINITE;;
                                    }
                                    b->figure_spawn_delay++;
                                    if (b->figure_spawn_delay > spawn_delay) {
                                        b->figure_spawn_delay = 0;
                                        struct figure_t *f = figure_create(FIGURE_LION_TAMER, road.x, road.y, DIR_0_TOP);
                                        f->action_state = FIGURE_ACTION_ENTERTAINER_AT_SCHOOL_CREATED;
                                        f->is_targetable = 1;
                                        f->terrain_usage = TERRAIN_USAGE_ROADS;
                                        f->building_id = b->id;
                                        b->figure_id = f->id;
                                    }
                                }
                                break;
                            case BUILDING_CHARIOT_MAKER:
                                check_labor_problem(b);
                                if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 50);
                                    int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                    int spawn_delay;
                                    if (pct_workers >= 100) {
                                        spawn_delay = 7;
                                    } else if (pct_workers >= 75) {
                                        spawn_delay = 15;
                                    } else if (pct_workers >= 50) {
                                        spawn_delay = 30;
                                    } else if (pct_workers >= 25) {
                                        spawn_delay = 60;
                                    } else if (pct_workers >= 1) {
                                        spawn_delay = 90;
                                    } else {
                                        spawn_delay = INFINITE;;
                                    }
                                    b->figure_spawn_delay++;
                                    if (b->figure_spawn_delay > spawn_delay) {
                                        b->figure_spawn_delay = 0;
                                        struct figure_t *f = figure_create(FIGURE_CHARIOTEER, road.x, road.y, DIR_0_TOP);
                                        f->action_state = FIGURE_ACTION_ENTERTAINER_AT_SCHOOL_CREATED;
                                        f->is_targetable = 1;
                                        f->terrain_usage = TERRAIN_USAGE_ROADS;
                                        f->building_id = b->id;
                                        b->figure_id = f->id;
                                    }
                                }
                                break;
                            case BUILDING_AMPHITHEATER:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_ACTOR, FIGURE_GLADIATOR)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        if (b->houses_covered <= 50 ||
                                            (b->data.entertainment.days1 <= 0 && b->data.entertainment.days2 <= 0)) {
                                            generate_labor_seeker(b, road.x, road.y);
                                        }
                                        int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                        int spawn_delay;
                                        if (pct_workers >= 100) {
                                            spawn_delay = 3;
                                        } else if (pct_workers >= 75) {
                                            spawn_delay = 7;
                                        } else if (pct_workers >= 50) {
                                            spawn_delay = 15;
                                        } else if (pct_workers >= 25) {
                                            spawn_delay = 29;
                                        } else if (pct_workers >= 1) {
                                            spawn_delay = 44;
                                        } else {
                                            spawn_delay = INFINITE;;
                                        }
                                        b->figure_spawn_delay++;
                                        if (b->figure_spawn_delay > spawn_delay) {
                                            b->figure_spawn_delay = 0;
                                            if (b->data.entertainment.days1 > 0) {
                                                if (scenario.gladiator_revolt.state != EVENT_IN_PROGRESS) {
                                                    struct figure_t *f = figure_create(FIGURE_GLADIATOR, road.x, road.y, DIR_0_TOP);
                                                    f->action_state = FIGURE_ACTION_ENTERTAINER_ROAMING;
                                                    f->is_targetable = 1;
                                                    f->terrain_usage = TERRAIN_USAGE_ROADS;
                                                    f->building_id = b->id;
                                                    b->figure_id = f->id;
                                                    figure_movement_init_roaming(f);
                                                }
                                            } else {
                                                struct figure_t *f = figure_create(FIGURE_ACTOR, road.x, road.y, DIR_0_TOP);
                                                f->action_state = FIGURE_ACTION_ENTERTAINER_ROAMING;
                                                f->is_targetable = 1;
                                                f->terrain_usage = TERRAIN_USAGE_ROADS;
                                                f->building_id = b->id;
                                                b->figure_id = f->id;
                                                figure_movement_init_roaming(f);
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_THEATER:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_ACTOR, 0)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        if (b->houses_covered <= 50 || b->data.entertainment.days1 <= 0) {
                                            generate_labor_seeker(b, road.x, road.y);
                                        }
                                        int spawn_delay = default_spawn_delay(b);
                                        if (spawn_delay) {
                                            b->figure_spawn_delay++;
                                            if (b->figure_spawn_delay > spawn_delay) {
                                                b->figure_spawn_delay = 0;
                                                struct figure_t *f = figure_create(FIGURE_ACTOR, road.x, road.y, DIR_0_TOP);
                                                f->action_state = FIGURE_ACTION_ENTERTAINER_ROAMING;
                                                f->is_targetable = 1;
                                                f->terrain_usage = TERRAIN_USAGE_ROADS;
                                                f->building_id = b->id;
                                                b->figure_id = f->id;
                                                figure_movement_init_roaming(f);
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_HIPPODROME:
                                check_labor_problem(b);
                                if (!b->prev_part_building_id) {
                                    struct building_t *part = b;
                                    for (int ii = 0; ii < 2; ii++) {
                                        part = &all_buildings[part->next_part_building_id];
                                        if (part->id) {
                                            part->show_on_problem_overlay = b->show_on_problem_overlay;
                                        }
                                    }
                                    if (!has_figure_of_types(b, FIGURE_CHARIOTEER, 0)) {
                                        if (map_has_road_access_hippodrome(b->x, b->y, &road)) {
                                            if (b->houses_covered <= 50 || b->data.entertainment.days1 <= 0) {
                                                generate_labor_seeker(b, road.x, road.y);
                                            }
                                            int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                            int spawn_delay;
                                            if (pct_workers >= 100) {
                                                spawn_delay = 7;
                                            } else if (pct_workers >= 75) {
                                                spawn_delay = 15;
                                            } else if (pct_workers >= 50) {
                                                spawn_delay = 30;
                                            } else if (pct_workers >= 25) {
                                                spawn_delay = 50;
                                            } else if (pct_workers >= 1) {
                                                spawn_delay = 80;
                                            } else {
                                                spawn_delay = INFINITE;;
                                            }
                                            b->figure_spawn_delay++;
                                            if (b->figure_spawn_delay > spawn_delay) {
                                                b->figure_spawn_delay = 0;
                                                struct figure_t *f = figure_create(FIGURE_CHARIOTEER, road.x, road.y, DIR_0_TOP);
                                                f->action_state = FIGURE_ACTION_ENTERTAINER_ROAMING;
                                                f->is_targetable = 1;
                                                f->terrain_usage = TERRAIN_USAGE_ROADS;
                                                f->building_id = b->id;
                                                b->figure_id = f->id;
                                                figure_movement_init_roaming(f);

                                                if (!city_data.entertainment.hippodrome_has_race) {
                                                    // create mini-horses
                                                    struct figure_t *horse1 = figure_create(FIGURE_HIPPODROME_HORSES, b->x + 2, b->y + 1, DIR_2_RIGHT);
                                                    horse1->action_state = FIGURE_ACTION_HIPPODROME_HORSE_CREATED;
                                                    horse1->use_cross_country = 1;
                                                    horse1->building_id = b->id;
                                                    horse1->resource_id = 0;
                                                    horse1->speed_multiplier = 3;

                                                    struct figure_t *horse2 = figure_create(FIGURE_HIPPODROME_HORSES, b->x + 2, b->y + 2, DIR_2_RIGHT);
                                                    horse2->action_state = FIGURE_ACTION_HIPPODROME_HORSE_CREATED;
                                                    horse2->use_cross_country = 1;
                                                    horse2->building_id = b->id;
                                                    horse2->resource_id = 1;
                                                    horse2->speed_multiplier = 2;

                                                    if (b->data.entertainment.days1 > 0) {
                                                        if (!city_data.entertainment.hippodrome_message_shown) {
                                                            city_data.entertainment.hippodrome_message_shown = 1;
                                                            city_message_post(1, MESSAGE_WORKING_HIPPODROME, 0, 0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_COLOSSEUM:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_GLADIATOR, FIGURE_LION_TAMER)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        if (b->houses_covered <= 50 ||
                                            (b->data.entertainment.days1 <= 0 && b->data.entertainment.days2 <= 0)) {
                                            generate_labor_seeker(b, road.x, road.y);
                                        }
                                        int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                        int spawn_delay;
                                        if (pct_workers >= 100) {
                                            spawn_delay = 6;
                                        } else if (pct_workers >= 75) {
                                            spawn_delay = 12;
                                        } else if (pct_workers >= 50) {
                                            spawn_delay = 20;
                                        } else if (pct_workers >= 25) {
                                            spawn_delay = 40;
                                        } else if (pct_workers >= 1) {
                                            spawn_delay = 70;
                                        } else {
                                            spawn_delay = INFINITE;;
                                        }
                                        b->figure_spawn_delay++;
                                        if (b->figure_spawn_delay > spawn_delay) {
                                            b->figure_spawn_delay = 0;
                                            if (b->data.entertainment.days1 > 0) {
                                                if (scenario.gladiator_revolt.state != EVENT_IN_PROGRESS) {
                                                    struct figure_t *f = figure_create(FIGURE_LION_TAMER, road.x, road.y, DIR_0_TOP);
                                                    f->action_state = FIGURE_ACTION_ENTERTAINER_ROAMING;
                                                    f->is_targetable = 1;
                                                    f->terrain_usage = TERRAIN_USAGE_ROADS;
                                                    f->building_id = b->id;
                                                    b->figure_id = f->id;
                                                    figure_movement_init_roaming(f);
                                                }
                                            } else {
                                                struct figure_t *f = figure_create(FIGURE_GLADIATOR, road.x, road.y, DIR_0_TOP);
                                                f->action_state = FIGURE_ACTION_ENTERTAINER_ROAMING;
                                                f->is_targetable = 1;
                                                f->terrain_usage = TERRAIN_USAGE_ROADS;
                                                f->building_id = b->id;
                                                b->figure_id = f->id;
                                                figure_movement_init_roaming(f);
                                            }

                                            if (b->data.entertainment.days1 > 0 || b->data.entertainment.days2 > 0) {
                                                if (!city_data.entertainment.colosseum_message_shown) {
                                                    city_data.entertainment.colosseum_message_shown = 1;
                                                    city_message_post(1, MESSAGE_WORKING_COLOSSEUM, 0, 0);
                                                }
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_MARKET:
                                if (b->state == BUILDING_STATE_IN_USE) {
                                    if (desirability_grid.items[b->grid_offset] <= 30) {
                                        map_building_tiles_add(b->id, b->x, b->y, b->size,
                                            image_data_s.group_image_ids[GROUP_BUILDING_MARKET], TERRAIN_BUILDING);
                                    } else {
                                        map_building_tiles_add(b->id, b->x, b->y, b->size,
                                            image_data_s.group_image_ids[GROUP_BUILDING_MARKET_FANCY], TERRAIN_BUILDING);
                                    }
                                    check_labor_problem(b);
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        spawn_labor_seeker(b, road.x, road.y, 50);
                                        int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                        int spawn_delay;
                                        if (pct_workers >= 100) {
                                            spawn_delay = 2;
                                        } else if (pct_workers >= 75) {
                                            spawn_delay = 5;
                                        } else if (pct_workers >= 50) {
                                            spawn_delay = 10;
                                        } else if (pct_workers >= 25) {
                                            spawn_delay = 20;
                                        } else if (pct_workers >= 1) {
                                            spawn_delay = 30;
                                        } else {
                                            spawn_delay = INFINITE;;
                                        }
                                        // market trader
                                        if (!has_figure_of_types(b, FIGURE_MARKET_TRADER, 0)) {
                                            b->figure_spawn_delay++;
                                            if (b->figure_spawn_delay > spawn_delay) {
                                                b->figure_spawn_delay = 0;
                                                create_roaming_figure(b, road.x, road.y, FIGURE_MARKET_TRADER);
                                            }
                                        }
                                        // market buyer or labor seeker
                                        if (b->figure_id2) {
                                            struct figure_t *f = &figures[b->figure_id2];
                                            if (!figure_is_alive(f) || (f->type != FIGURE_MARKET_BUYER && f->type != FIGURE_LABOR_SEEKER)) {
                                                b->figure_id2 = 0;
                                            }
                                        } else {
                                            map_has_road_access(b->x, b->y, b->size, &road);
                                            struct resource_data resources[INVENTORY_MAX];
                                            for (int ii = 0; ii < INVENTORY_MAX; ii++) {
                                                resources[ii].building_id = 0;
                                                resources[ii].num_buildings = 0;
                                                resources[ii].distance = 40;
                                            }
                                            for (int ii = 1; ii < MAX_BUILDINGS; ii++) {
                                                struct building_t *bb = &all_buildings[ii];
                                                if (bb->state != BUILDING_STATE_IN_USE) {
                                                    continue;
                                                }
                                                if (bb->type != BUILDING_GRANARY && bb->type != BUILDING_WAREHOUSE) {
                                                    continue;
                                                }
                                                if (!bb->has_road_access || bb->road_network_id != b->road_network_id) {
                                                    continue;
                                                }
                                                int distance = calc_maximum_distance(b->x, b->y, bb->x, bb->y);
                                                if (distance >= 40) {
                                                    continue;
                                                }
                                                if (bb->type == BUILDING_GRANARY) {
                                                    if (scenario.rome_supplies_wheat) {
                                                        continue;
                                                    }
                                                    update_food_resource(&resources[INVENTORY_WHEAT], RESOURCE_WHEAT, bb, distance);
                                                    update_food_resource(&resources[INVENTORY_VEGETABLES], RESOURCE_VEGETABLES, bb, distance);
                                                    update_food_resource(&resources[INVENTORY_FRUIT], RESOURCE_FRUIT, bb, distance);
                                                    update_food_resource(&resources[INVENTORY_MEAT], RESOURCE_MEAT, bb, distance);
                                                } else if (bb->type == BUILDING_WAREHOUSE) {
                                                    // goods
                                                    update_good_resource(&resources[INVENTORY_WINE], RESOURCE_WINE, bb, distance);
                                                    update_good_resource(&resources[INVENTORY_OIL], RESOURCE_OIL, bb, distance);
                                                    update_good_resource(&resources[INVENTORY_POTTERY], RESOURCE_POTTERY, bb, distance);
                                                    update_good_resource(&resources[INVENTORY_FURNITURE], RESOURCE_FURNITURE, bb, distance);
                                                }
                                            }
                                            // update demands
                                            if (b->data.market.pottery_demand) {
                                                b->data.market.pottery_demand--;
                                            } else {
                                                resources[INVENTORY_POTTERY].num_buildings = 0;
                                            }
                                            if (b->data.market.furniture_demand) {
                                                b->data.market.furniture_demand--;
                                            } else {
                                                resources[INVENTORY_FURNITURE].num_buildings = 0;
                                            }
                                            if (b->data.market.oil_demand) {
                                                b->data.market.oil_demand--;
                                            } else {
                                                resources[INVENTORY_OIL].num_buildings = 0;
                                            }
                                            if (b->data.market.wine_demand) {
                                                b->data.market.wine_demand--;
                                            } else {
                                                resources[INVENTORY_WINE].num_buildings = 0;
                                            }
                                            int can_go = 0;
                                            for (int ii = 0; ii < INVENTORY_MAX; ii++) {
                                                if (resources[ii].num_buildings) {
                                                    can_go = 1;
                                                    break;
                                                }
                                            }
                                            if (can_go) {
                                                int dst_building_id = 0;
                                                int min_stock = 50;
                                                int fetch_inventory = -1;
                                                if (!b->data.market.inventory[INVENTORY_WHEAT] && resources[INVENTORY_WHEAT].num_buildings) { // prefer food if we don't have it
                                                    b->data.market.fetch_inventory_id = INVENTORY_WHEAT;
                                                    dst_building_id = resources[INVENTORY_WHEAT].building_id;
                                                } else if (!b->data.market.inventory[INVENTORY_VEGETABLES] && resources[INVENTORY_VEGETABLES].num_buildings) {
                                                    b->data.market.fetch_inventory_id = INVENTORY_VEGETABLES;
                                                    dst_building_id = resources[INVENTORY_VEGETABLES].building_id;
                                                } else if (!b->data.market.inventory[INVENTORY_FRUIT] && resources[INVENTORY_FRUIT].num_buildings) {
                                                    b->data.market.fetch_inventory_id = INVENTORY_FRUIT;
                                                    dst_building_id = resources[INVENTORY_FRUIT].building_id;
                                                } else if (!b->data.market.inventory[INVENTORY_MEAT] && resources[INVENTORY_MEAT].num_buildings) {
                                                    b->data.market.fetch_inventory_id = INVENTORY_MEAT;
                                                    dst_building_id = resources[INVENTORY_MEAT].building_id;
                                                } else if (!b->data.market.inventory[INVENTORY_POTTERY] && resources[INVENTORY_POTTERY].num_buildings) { // then prefer resource if we don't have it
                                                    b->data.market.fetch_inventory_id = INVENTORY_POTTERY;
                                                    dst_building_id = resources[INVENTORY_POTTERY].building_id;
                                                } else if (!b->data.market.inventory[INVENTORY_FURNITURE] && resources[INVENTORY_FURNITURE].num_buildings) {
                                                    b->data.market.fetch_inventory_id = INVENTORY_FURNITURE;
                                                    dst_building_id = resources[INVENTORY_FURNITURE].building_id;
                                                } else if (!b->data.market.inventory[INVENTORY_OIL] && resources[INVENTORY_OIL].num_buildings) {
                                                    b->data.market.fetch_inventory_id = INVENTORY_OIL;
                                                    dst_building_id = resources[INVENTORY_OIL].building_id;
                                                } else if (!b->data.market.inventory[INVENTORY_WINE] && resources[INVENTORY_WINE].num_buildings) {
                                                    b->data.market.fetch_inventory_id = INVENTORY_WINE;
                                                    dst_building_id = resources[INVENTORY_WINE].building_id;
                                                } else { // then prefer smallest stock below 50
                                                    if (resources[INVENTORY_WHEAT].num_buildings && b->data.market.inventory[INVENTORY_WHEAT] < min_stock) {
                                                        min_stock = b->data.market.inventory[INVENTORY_WHEAT];
                                                        fetch_inventory = INVENTORY_WHEAT;
                                                    }
                                                    if (resources[INVENTORY_VEGETABLES].num_buildings && b->data.market.inventory[INVENTORY_VEGETABLES] < min_stock) {
                                                        min_stock = b->data.market.inventory[INVENTORY_VEGETABLES];
                                                        fetch_inventory = INVENTORY_VEGETABLES;
                                                    }
                                                    if (resources[INVENTORY_FRUIT].num_buildings && b->data.market.inventory[INVENTORY_FRUIT] < min_stock) {
                                                        min_stock = b->data.market.inventory[INVENTORY_FRUIT];
                                                        fetch_inventory = INVENTORY_FRUIT;
                                                    }
                                                    if (resources[INVENTORY_MEAT].num_buildings && b->data.market.inventory[INVENTORY_MEAT] < min_stock) {
                                                        min_stock = b->data.market.inventory[INVENTORY_MEAT];
                                                        fetch_inventory = INVENTORY_MEAT;
                                                    }
                                                    if (resources[INVENTORY_POTTERY].num_buildings && b->data.market.inventory[INVENTORY_POTTERY] < min_stock) {
                                                        min_stock = b->data.market.inventory[INVENTORY_POTTERY];
                                                        fetch_inventory = INVENTORY_POTTERY;
                                                    }
                                                    if (resources[INVENTORY_FURNITURE].num_buildings && b->data.market.inventory[INVENTORY_FURNITURE] < min_stock) {
                                                        min_stock = b->data.market.inventory[INVENTORY_FURNITURE];
                                                        fetch_inventory = INVENTORY_FURNITURE;
                                                    }
                                                    if (resources[INVENTORY_OIL].num_buildings && b->data.market.inventory[INVENTORY_OIL] < min_stock) {
                                                        min_stock = b->data.market.inventory[INVENTORY_OIL];
                                                        fetch_inventory = INVENTORY_OIL;
                                                    }
                                                    if (resources[INVENTORY_WINE].num_buildings && b->data.market.inventory[INVENTORY_WINE] < min_stock) {
                                                        fetch_inventory = INVENTORY_WINE;
                                                    }
                                                    if (fetch_inventory == -1) { // all items well stocked: pick food below threshold
                                                        if (resources[INVENTORY_WHEAT].num_buildings && b->data.market.inventory[INVENTORY_WHEAT] < 600) {
                                                            fetch_inventory = INVENTORY_WHEAT;
                                                        }
                                                        if (resources[INVENTORY_VEGETABLES].num_buildings && b->data.market.inventory[INVENTORY_VEGETABLES] < 400) {
                                                            fetch_inventory = INVENTORY_VEGETABLES;
                                                        }
                                                        if (resources[INVENTORY_FRUIT].num_buildings && b->data.market.inventory[INVENTORY_FRUIT] < 400) {
                                                            fetch_inventory = INVENTORY_FRUIT;
                                                        }
                                                        if (resources[INVENTORY_MEAT].num_buildings && b->data.market.inventory[INVENTORY_MEAT] < 400) {
                                                            fetch_inventory = INVENTORY_MEAT;
                                                        }
                                                    }
                                                    if (fetch_inventory > 0) {
                                                        b->data.market.fetch_inventory_id = fetch_inventory;
                                                        dst_building_id = resources[fetch_inventory].building_id;
                                                    }
                                                }
                                                if (dst_building_id > 0) {
                                                    struct figure_t *f = figure_create(FIGURE_MARKET_BUYER, road.x, road.y, DIR_0_TOP);
                                                    f->action_state = FIGURE_ACTION_MARKET_BUYER_GOING_TO_STORAGE;
                                                    f->is_targetable = 1;
                                                    f->terrain_usage = TERRAIN_USAGE_ROADS;
                                                    f->building_id = b->id;
                                                    b->figure_id2 = f->id;
                                                    f->destination_building_id = dst_building_id;
                                                    f->collecting_item_id = b->data.market.fetch_inventory_id;
                                                    struct building_t *b_dst = &all_buildings[dst_building_id];
                                                    if (map_has_road_access(b_dst->x, b_dst->y, b_dst->size, &road) ||
                                                        map_has_road_access(b_dst->x, b_dst->y, 3, &road)) {
                                                        f->destination_x = road.x;
                                                        f->destination_y = road.y;
                                                    } else {
                                                        f->action_state = FIGURE_ACTION_MARKET_BUYER_RETURNING;
                                                        f->destination_x = f->x;
                                                        f->destination_y = f->y;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_BATHHOUSE:
                                if (b->state == BUILDING_STATE_IN_USE) {
                                    if (map_terrain_exists_tile_in_area_with_type(b->x, b->y, b->size, TERRAIN_RESERVOIR_RANGE)) {
                                        b->has_water_access = 1;
                                    } else {
                                        b->has_water_access = 0;
                                    }
                                    if (b->has_water_access && b->num_workers) {
                                        if (desirability_grid.items[b->grid_offset] <= 30) {
                                            map_building_tiles_add(b->id, b->x, b->y, b->size,
                                                image_data_s.group_image_ids[GROUP_BUILDING_BATHHOUSE_WATER], TERRAIN_BUILDING);
                                        } else {
                                            map_building_tiles_add(b->id, b->x, b->y, b->size,
                                                image_data_s.group_image_ids[GROUP_BUILDING_BATHHOUSE_FANCY_WATER], TERRAIN_BUILDING);
                                        }
                                    } else {
                                        if (desirability_grid.items[b->grid_offset] <= 30) {
                                            map_building_tiles_add(b->id, b->x, b->y, b->size,
                                                image_data_s.group_image_ids[GROUP_BUILDING_BATHHOUSE_NO_WATER], TERRAIN_BUILDING);
                                        } else {
                                            map_building_tiles_add(b->id, b->x, b->y, b->size,
                                                image_data_s.group_image_ids[GROUP_BUILDING_BATHHOUSE_FANCY_NO_WATER], TERRAIN_BUILDING);
                                        }
                                    }
                                    check_labor_problem(b);
                                    if (!b->has_water_access) {
                                        b->show_on_problem_overlay = 2;
                                    }
                                    if (!has_figure_of_types(b, FIGURE_BATHHOUSE_WORKER, 0)) {
                                        if (map_has_road_access(b->x, b->y, b->size, &road) && b->has_water_access) {
                                            spawn_labor_seeker(b, road.x, road.y, 50);
                                            int spawn_delay = default_spawn_delay(b);
                                            if (spawn_delay) {
                                                b->figure_spawn_delay++;
                                                if (b->figure_spawn_delay > spawn_delay) {
                                                    b->figure_spawn_delay = 0;
                                                    create_roaming_figure(b, road.x, road.y, FIGURE_BATHHOUSE_WORKER);
                                                }
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_SCHOOL:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_SCHOOL_CHILD, 0)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        spawn_labor_seeker(b, road.x, road.y, 50);
                                        int spawn_delay = default_spawn_delay(b);
                                        if (spawn_delay) {
                                            b->figure_spawn_delay++;
                                            if (b->figure_spawn_delay > spawn_delay) {
                                                b->figure_spawn_delay = 0;
                                                struct figure_t *child1 = figure_create(FIGURE_SCHOOL_CHILD, road.x, road.y, DIR_0_TOP);
                                                child1->action_state = FIGURE_ACTION_ROAMING;
                                                child1->is_targetable = 1;
                                                child1->terrain_usage = TERRAIN_USAGE_ROADS;
                                                child1->building_id = b->id;
                                                b->figure_id = child1->id;
                                                figure_movement_init_roaming(child1);
                                                struct figure_t *child2 = figure_create(FIGURE_SCHOOL_CHILD, road.x, road.y, DIR_0_TOP);
                                                child2->action_state = FIGURE_ACTION_ROAMING;
                                                child2->is_targetable = 1;
                                                child2->terrain_usage = TERRAIN_USAGE_ROADS;
                                                child2->building_id = b->id;
                                                figure_movement_init_roaming(child2);
                                                struct figure_t *child3 = figure_create(FIGURE_SCHOOL_CHILD, road.x, road.y, DIR_0_TOP);
                                                child3->action_state = FIGURE_ACTION_ROAMING;
                                                child3->is_targetable = 1;
                                                child3->terrain_usage = TERRAIN_USAGE_ROADS;
                                                child3->building_id = b->id;
                                                figure_movement_init_roaming(child3);
                                                struct figure_t *child4 = figure_create(FIGURE_SCHOOL_CHILD, road.x, road.y, DIR_0_TOP);
                                                child4->action_state = FIGURE_ACTION_ROAMING;
                                                child4->is_targetable = 1;
                                                child4->terrain_usage = TERRAIN_USAGE_ROADS;
                                                child4->building_id = b->id;
                                                figure_movement_init_roaming(child4);
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_LIBRARY:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_LIBRARIAN, 0)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        spawn_labor_seeker(b, road.x, road.y, 50);
                                        int spawn_delay = default_spawn_delay(b);
                                        if (spawn_delay) {
                                            b->figure_spawn_delay++;
                                            if (b->figure_spawn_delay > spawn_delay) {
                                                b->figure_spawn_delay = 0;
                                                create_roaming_figure(b, road.x, road.y, FIGURE_LIBRARIAN);
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_ACADEMY:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_TEACHER, 0)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        spawn_labor_seeker(b, road.x, road.y, 50);
                                        int spawn_delay = default_spawn_delay(b);
                                        if (spawn_delay) {
                                            b->figure_spawn_delay++;
                                            if (b->figure_spawn_delay > spawn_delay) {
                                                b->figure_spawn_delay = 0;
                                                create_roaming_figure(b, road.x, road.y, FIGURE_TEACHER);
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_BARBER:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_BARBER, 0)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        spawn_labor_seeker(b, road.x, road.y, 50);
                                        int spawn_delay = default_spawn_delay(b);
                                        if (spawn_delay) {
                                            b->figure_spawn_delay++;
                                            if (b->figure_spawn_delay > spawn_delay) {
                                                b->figure_spawn_delay = 0;
                                                create_roaming_figure(b, road.x, road.y, FIGURE_BARBER);
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_DOCTOR:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_DOCTOR, 0)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        spawn_labor_seeker(b, road.x, road.y, 50);
                                        int spawn_delay = default_spawn_delay(b);
                                        if (spawn_delay) {
                                            b->figure_spawn_delay++;
                                            if (b->figure_spawn_delay > spawn_delay) {
                                                b->figure_spawn_delay = 0;
                                                create_roaming_figure(b, road.x, road.y, FIGURE_DOCTOR);
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_HOSPITAL:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_SURGEON, 0)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        spawn_labor_seeker(b, road.x, road.y, 50);
                                        int spawn_delay = default_spawn_delay(b);
                                        if (spawn_delay) {
                                            b->figure_spawn_delay++;
                                            if (b->figure_spawn_delay > spawn_delay) {
                                                b->figure_spawn_delay = 0;
                                                create_roaming_figure(b, road.x, road.y, FIGURE_SURGEON);
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_MISSION_POST:
                                if (!has_figure_of_types(b, FIGURE_MISSIONARY, 0)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        if (city_data.population.population > 0) {
                                            city_data.building.mission_post_operational = 1;
                                            b->figure_spawn_delay++;
                                            if (b->figure_spawn_delay > 1) {
                                                b->figure_spawn_delay = 0;
                                                create_roaming_figure(b, road.x, road.y, FIGURE_MISSIONARY);
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_DOCK:
                                check_labor_problem(b);
                                if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 50);
                                    int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                    int max_dockers;
                                    if (pct_workers >= 75) {
                                        max_dockers = 3;
                                    } else if (pct_workers >= 50) {
                                        max_dockers = 2;
                                    } else if (pct_workers > 0) {
                                        max_dockers = 1;
                                    } else {
                                        max_dockers = 0;
                                    }
                                    // count existing dockers
                                    int existing_dockers = 0;
                                    for (int ii = 0; ii < 3; ii++) {
                                        if (b->data.dock.docker_ids[ii]) {
                                            if (figures[b->data.dock.docker_ids[ii]].type == FIGURE_DOCKER) {
                                                existing_dockers++;
                                            } else {
                                                b->data.dock.docker_ids[ii] = 0;
                                            }
                                        }
                                    }
                                    if (existing_dockers > max_dockers) {
                                        // too many dockers, kill one of them
                                        for (int ii = 2; ii >= 0; ii--) {
                                            if (b->data.dock.docker_ids[ii]) {
                                                figure_delete(&figures[b->data.dock.docker_ids[ii]]);
                                                break;
                                            }
                                        }
                                    } else if (existing_dockers < max_dockers) {
                                        struct figure_t *f = figure_create(FIGURE_DOCKER, road.x, road.y, DIR_4_BOTTOM);
                                        f->action_state = FIGURE_ACTION_DOCKER_IDLING;
                                        f->is_targetable = 1;
                                        f->terrain_usage = TERRAIN_USAGE_ROADS;
                                        f->building_id = b->id;
                                        for (int ii = 0; ii < 3; ii++) {
                                            if (!b->data.dock.docker_ids[ii]) {
                                                b->data.dock.docker_ids[ii] = f->id;
                                                break;
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_WHARF:
                                check_labor_problem(b);
                                if (b->data.industry.fishing_boat_id) {
                                    struct figure_t *f = &figures[b->data.industry.fishing_boat_id];
                                    if (!figure_is_alive(f) || f->type != FIGURE_FISHING_BOAT) {
                                        b->data.industry.fishing_boat_id = 0;
                                    }
                                }
                                if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 50);
                                    if (!has_figure_of_types(b, FIGURE_CART_PUSHER, 0)) {
                                        if (b->figure_spawn_delay) {
                                            b->figure_spawn_delay = 0;
                                            b->data.industry.has_fish = 0;
                                            b->output_resource_id = RESOURCE_MEAT;
                                            struct figure_t *f = figure_create(FIGURE_CART_PUSHER, road.x, road.y, DIR_4_BOTTOM);
                                            f->action_state = FIGURE_ACTION_CARTPUSHER_INITIAL;
                                            f->is_targetable = 1;
                                            f->terrain_usage = TERRAIN_USAGE_ROADS;
                                            f->resource_id = RESOURCE_MEAT;
                                            f->building_id = b->id;
                                            b->figure_id = f->id;
                                            f->wait_ticks = 30;
                                        }
                                    }
                                }
                                break;
                            case BUILDING_SHIPYARD:
                                check_labor_problem(b);
                                if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 50);
                                    if (!has_figure_of_types(b, FIGURE_FISHING_BOAT, 0)) {
                                        int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                        if (pct_workers >= 100) {
                                            b->data.industry.progress += 10;
                                        } else if (pct_workers >= 75) {
                                            b->data.industry.progress += 8;
                                        } else if (pct_workers >= 50) {
                                            b->data.industry.progress += 6;
                                        } else if (pct_workers >= 25) {
                                            b->data.industry.progress += 4;
                                        } else if (pct_workers >= 1) {
                                            b->data.industry.progress += 2;
                                        }
                                        if (b->data.industry.progress >= 160) {
                                            b->data.industry.progress = 0;
                                            struct map_point_t boat;
                                            int base_offset = map_grid_offset(b->x, b->y);
                                            for (int *tile_delta = ADJACENT_OFFSETS_MAP_GRID[b->size]; *tile_delta; tile_delta++) {
                                                int grid_offset = base_offset + *tile_delta;
                                                if (map_terrain_is(grid_offset, TERRAIN_WATER)) {
                                                    if (!map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
                                                        int surrounding_water_tiles = 0;
                                                        for (int j = 0; j < DIR_8_NONE; j++) {
                                                            if (map_terrain_is(grid_offset + map_grid_direction_delta(j), TERRAIN_WATER)) {
                                                                surrounding_water_tiles++;
                                                            }
                                                        }
                                                        if (surrounding_water_tiles >= 8) {
                                                            boat.x = map_grid_offset_to_x(grid_offset);
                                                            boat.y = map_grid_offset_to_y(grid_offset);
                                                            struct figure_t *f = figure_create(FIGURE_FISHING_BOAT, boat.x, boat.y, DIR_0_TOP);
                                                            f->action_state = FIGURE_ACTION_FISHING_BOAT_CREATED;
                                                            f->building_id = b->id;
                                                            b->figure_id = f->id;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_NATIVE_HUT:
                                images.items[b->grid_offset] = image_data_s.group_image_ids[GROUP_BUILDING_NATIVE] + (random.items[b->grid_offset] & 1);
                                if (!has_figure_of_types(b, FIGURE_INDIGENOUS_NATIVE, 0)) {
                                    if (b->subtype.native_meeting_center_id > 0
                                        && map_terrain_get_adjacent_road_or_clear_land(b->x, b->y, b->size, &x_out, &y_out)) {
                                        b->figure_spawn_delay++;
                                        if (b->figure_spawn_delay > 4) {
                                            b->figure_spawn_delay = 0;
                                            struct figure_t *f = figure_create(FIGURE_INDIGENOUS_NATIVE, x_out, y_out, DIR_0_TOP);
                                            f->is_targetable = 1;
                                            f->action_state = FIGURE_ACTION_NATIVE_CREATED;
                                            f->terrain_usage = TERRAIN_USAGE_ANY;
                                            f->building_id = b->id;
                                            b->figure_id = f->id;
                                        }
                                    }
                                }
                                break;
                            case BUILDING_NATIVE_MEETING:
                                map_building_tiles_add(b->id, b->x, b->y, 2, image_data_s.group_image_ids[GROUP_BUILDING_NATIVE] + 2, TERRAIN_BUILDING);
                                if (city_data.building.mission_post_operational > 0 && !has_figure_of_types(b, FIGURE_NATIVE_TRADER, 0)) {
                                    if (map_terrain_get_adjacent_road_or_clear_land(b->x, b->y, b->size, &x_out, &y_out)) {
                                        b->figure_spawn_delay++;
                                        if (b->figure_spawn_delay > 8) {
                                            b->figure_spawn_delay = 0;
                                            struct figure_t *f = figure_create(FIGURE_NATIVE_TRADER, x_out, y_out, DIR_0_TOP);
                                            f->is_targetable = 1;
                                            f->action_state = FIGURE_ACTION_NATIVE_TRADER_CREATED;
                                            f->terrain_usage = TERRAIN_USAGE_ANY;
                                            f->building_id = b->id;
                                            b->figure_id = f->id;
                                        }
                                    }
                                }
                                break;
                            case BUILDING_NATIVE_CROPS:
                                b->data.industry.progress++;
                                if (b->data.industry.progress >= 5) {
                                    b->data.industry.progress = 0;
                                }
                                images.items[b->grid_offset] = image_data_s.group_image_ids[GROUP_BUILDING_FARM_CROPS] + b->data.industry.progress;
                                break;
                            case BUILDING_BARRACKS:
                                check_labor_problem(b);
                                if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 100);
                                    int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                    int spawn_delay;
                                    if (pct_workers >= 100) {
                                        spawn_delay = 8;
                                    } else if (pct_workers >= 75) {
                                        spawn_delay = 12;
                                    } else if (pct_workers >= 50) {
                                        spawn_delay = 16;
                                    } else if (pct_workers >= 25) {
                                        spawn_delay = 32;
                                    } else if (pct_workers >= 1) {
                                        spawn_delay = 48;
                                    } else {
                                        spawn_delay = INFINITE;
                                    }
                                    b->figure_spawn_delay++;
                                    if (b->figure_spawn_delay > spawn_delay) {
                                        b->figure_spawn_delay = 0;
                                        map_has_road_access(b->x, b->y, b->size, &road);
                                        int create_tower_sentry = 0;
                                        if (tower_sentry_request) {
                                            struct building_t *tower = 0;
                                            for (int ii = 1; ii < MAX_BUILDINGS; ii++) {
                                                struct building_t *bb = &all_buildings[ii];
                                                if (bb->state == BUILDING_STATE_IN_USE && bb->type == BUILDING_TOWER && bb->num_workers > 0 &&
                                                    !bb->figure_id && b->road_network_id == bb->road_network_id) {
                                                    tower = bb;
                                                    break;
                                                }
                                            }
                                            if (tower) {
                                                struct map_point_t tower_road;
                                                if (map_has_road_access(tower->x, tower->y, tower->size, &tower_road)) {
                                                    struct figure_t *f = figure_create(FIGURE_TOWER_SENTRY, road.x, road.y, DIR_0_TOP);
                                                    tower->figure_id = f->id;
                                                    f->building_id = tower->id;
                                                    struct map_point_t mil_acad_road = { 0 };
                                                    set_destination__closest_building_of_type(tower->id, BUILDING_MILITARY_ACADEMY, &mil_acad_road);
                                                    if (mil_acad_road.x) {
                                                        f->action_state = FIGURE_ACTION_SOLDIER_GOING_TO_MILITARY_ACADEMY;
                                                        f->destination_x = mil_acad_road.x;
                                                        f->destination_y = mil_acad_road.y;
                                                        f->destination_grid_offset = map_grid_offset(f->destination_x, f->destination_y);
                                                    } else {
                                                        f->action_state = FIGURE_ACTION_TOWER_SENTRY_GOING_TO_TOWER;
                                                    }
                                                    create_tower_sentry = 1;
                                                }
                                            }
                                        }
                                        if (!create_tower_sentry) {
                                            struct formation_t *closest_formation = 0;
                                            int closest_formation_distance = 10000;
                                            for (int j = 0; j < MAX_LEGIONS; j++) {
                                                struct formation_t *m = &legion_formations[j];
                                                if (m->in_use && !m->in_distant_battle && !m->cursed_by_mars && m->num_figures < m->max_figures) {
                                                    if (m->figure_type == FIGURE_FORT_LEGIONARY && !b->loads_stored) {
                                                        continue;
                                                    }
                                                    struct building_t *fort = &all_buildings[m->building_id];
                                                    int dist = calc_maximum_distance(b->x, b->y, fort->x, fort->y);
                                                    if (dist < closest_formation_distance) {
                                                        // prefer legionaries
                                                        if (closest_formation && closest_formation->figure_type == FIGURE_FORT_LEGIONARY && m->figure_type != FIGURE_FORT_LEGIONARY) {
                                                            continue;
                                                        }
                                                        closest_formation = &legion_formations[j];
                                                        closest_formation_distance = dist;
                                                    }
                                                }
                                            }
                                            if (closest_formation) {
                                                struct figure_t *f = figure_create(closest_formation->figure_type, road.x, road.y, DIR_0_TOP);
                                                f->is_targetable = 1;
                                                f->terrain_usage = TERRAIN_USAGE_ANY;
                                                f->formation_id = closest_formation->id;
                                                switch (f->type) {
                                                    case FIGURE_FORT_JAVELIN:
                                                        f->speed_multiplier = 2;
                                                        break;
                                                    case FIGURE_FORT_MOUNTED:
                                                        f->mounted_charge_ticks = 10;
                                                        f->mounted_charge_ticks_max = 10;
                                                        f->speed_multiplier = 3;
                                                        break;
                                                    case FIGURE_FORT_LEGIONARY:
                                                        if (b->loads_stored) {
                                                            b->loads_stored--;
                                                        }
                                                        break;
                                                }
                                                f->building_id = closest_formation->building_id;
                                                add_figure_to_formation(f, closest_formation);
                                                struct map_point_t mil_acad_road = { 0 };
                                                set_destination__closest_building_of_type(closest_formation->building_id, BUILDING_MILITARY_ACADEMY, &mil_acad_road);
                                                if (mil_acad_road.x) {
                                                    f->action_state = FIGURE_ACTION_SOLDIER_GOING_TO_MILITARY_ACADEMY;
                                                    f->destination_x = mil_acad_road.x;
                                                    f->destination_y = mil_acad_road.y;
                                                    f->destination_grid_offset = map_grid_offset(f->destination_x, f->destination_y);
                                                } else {
                                                    if (closest_formation->is_at_rest) {
                                                        f->action_state = FIGURE_ACTION_SOLDIER_GOING_TO_FORT;
                                                    } else {
                                                        deploy_legion_unit_to_formation_location(f, closest_formation);
                                                    }
                                                }
                                                city_data.figure.soldiers++;
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_MILITARY_ACADEMY:
                                check_labor_problem(b);
                                if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 100);
                                }
                                break;
                        }
                    }
                }
            }
            break;
            case 32: // update trade
            {
                city_data.trade.num_sea_routes = 0;
                city_data.trade.num_land_routes = 0;
                // Wine types
                city_data.resource.wine_types_available = count_data.industry[RESOURCE_WINE].total > 0 ? 1 : 0;
                if (city_data.resource.trade_status[RESOURCE_WINE] == TRADE_STATUS_IMPORT) {
                    for (int k = 0; k < MAX_EMPIRE_OBJECTS; k++) {
                        if (empire_objects[k].in_use
                            && empire_objects[k].trade_route_open
                            && empire_objects[k].resource_sell_limit[RESOURCE_WINE]) {
                            city_data.resource.wine_types_available++;
                        }
                    }
                }
                // Update trade problems
                if (city_data.trade.land_trade_problem_duration > 0) {
                    city_data.trade.land_trade_problem_duration--;
                } else {
                    city_data.trade.land_trade_problem_duration = 0;
                }
                if (city_data.trade.sea_trade_problem_duration > 0) {
                    city_data.trade.sea_trade_problem_duration--;
                } else {
                    city_data.trade.sea_trade_problem_duration = 0;
                }

                for (int k = 1; k < MAX_EMPIRE_OBJECTS; k++) {
                    if (!empire_objects[k].in_use || !empire_objects[k].trade_route_open) {
                        continue;
                    }
                    if (empire_objects[k].is_sea_trade) {
                        if (!city_data.building.working_docks) {
                            // delay of 384 = 1 year
                            city_message_post_with_message_delay(MESSAGE_CAT_NO_WORKING_DOCK, 1, MESSAGE_NO_WORKING_DOCK, 384);
                            continue;
                        }
                        if (scenario.river_entry_point.x == -1 || scenario.river_entry_point.y == -1) {
                            continue;
                        }
                        city_data.trade.num_sea_routes++;
                    } else {
                        city_data.trade.num_land_routes++;
                    }
                    // generate trader
                    struct empire_object_t *city = &empire_objects[i];
                    int max_traders = 0;
                    int num_resources = 0;
                    for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                        if (city->resource_buy_limit[r]) {
                            ++num_resources;
                            switch (city->resource_buy_limit[r]) {
                                case 15: max_traders += 1; break;
                                case 25: max_traders += 2; break;
                                case 40: max_traders += 3; break;
                            }
                        } else if (city->resource_sell_limit[r]) {
                            ++num_resources;
                            switch (city->resource_sell_limit[r]) {
                                case 15: max_traders += 1; break;
                                case 25: max_traders += 2; break;
                                case 40: max_traders += 3; break;
                            }
                        }
                    }
                    if (num_resources > 1) {
                        if (max_traders % num_resources) {
                            max_traders = max_traders / num_resources + 1;
                        } else {
                            max_traders = max_traders / num_resources;
                        }
                    }
                    if (max_traders <= 0) {
                        continue;
                    }
                    int index;
                    if (max_traders == 1) {
                        if (!city->trader_figure_ids[0]) {
                            index = 0;
                        } else {
                            continue;
                        }
                    } else if (max_traders == 2) {
                        if (!city->trader_figure_ids[0]) {
                            index = 0;
                        } else if (!city->trader_figure_ids[1]) {
                            index = 1;
                        } else {
                            continue;
                        }
                    } else { // 3
                        if (!city->trader_figure_ids[0]) {
                            index = 0;
                        } else if (!city->trader_figure_ids[1]) {
                            index = 1;
                        } else if (!city->trader_figure_ids[2]) {
                            index = 2;
                        } else {
                            continue;
                        }
                    }
                    if (city->trader_entry_delay > 0) {
                        city->trader_entry_delay--;
                        continue;
                    }
                    city->trader_entry_delay = city->is_sea_trade ? 30 : 4;
                    if (city->is_sea_trade) {
                        // generate ship
                        if (city_data.building.working_docks && (scenario.river_entry_point.x != -1 && scenario.river_entry_point.y != -1) && !city_data.trade.sea_trade_problem_duration) {
                            struct figure_t *ship = figure_create(FIGURE_TRADE_SHIP, scenario.river_entry_point.x, scenario.river_entry_point.y, DIR_0_TOP);
                            ship->empire_city_id = city->id;
                            ship->action_state = FIGURE_ACTION_TRADE_SHIP_CREATED;
                            ship->wait_ticks = 10;
                            city->trader_figure_ids[index] = ship->id;
                            break;
                        }
                    } else {
                        // generate caravan and donkeys
                        if (!city_data.trade.land_trade_problem_duration) {
                            // caravan head
                            struct figure_t *caravan = figure_create(FIGURE_TRADE_CARAVAN, scenario.entry_point.x, scenario.entry_point.y, DIR_0_TOP);
                            caravan->is_targetable = 1;
                            caravan->empire_city_id = city->id;
                            caravan->action_state = FIGURE_ACTION_TRADE_CARAVAN_CREATED;
                            caravan->terrain_usage = TERRAIN_USAGE_PREFER_ROADS;
                            caravan->wait_ticks = 10;
                            // donkey 1
                            struct figure_t *donkey1 = figure_create(FIGURE_TRADE_CARAVAN_DONKEY, scenario.entry_point.x, scenario.entry_point.y, DIR_0_TOP);
                            donkey1->is_targetable = 1;
                            donkey1->action_state = FIGURE_ACTION_TRADE_CARAVAN_CREATED;
                            donkey1->terrain_usage = TERRAIN_USAGE_PREFER_ROADS;
                            donkey1->leading_figure_id = caravan->id;
                            // donkey 2
                            struct figure_t *donkey2 = figure_create(FIGURE_TRADE_CARAVAN_DONKEY, scenario.entry_point.x, scenario.entry_point.y, DIR_0_TOP);
                            donkey2->is_targetable = 1;
                            donkey2->action_state = FIGURE_ACTION_TRADE_CARAVAN_CREATED;
                            donkey2->terrain_usage = TERRAIN_USAGE_PREFER_ROADS;
                            donkey2->leading_figure_id = donkey1->id;
                            city->trader_figure_ids[index] = caravan->id;
                            break;
                        }
                    }
                }
            }
            break;
            case 33: // building cont update, culture coverage update
            {
                memset(&count_data, 0, sizeof(count_data));
                city_data.building.working_wharfs = 0;
                city_data.building.shipyard_boats_requested = 0;
                for (int k = 0; k < 8; k++) {
                    city_data.building.working_dock_ids[k] = 0;
                }
                city_data.building.working_docks = 0;
                city_data.health.num_hospital_workers = 0;
                for (int k = 1; k < MAX_BUILDINGS; k++) {
                    struct building_t *b = &all_buildings[k];
                    if (b->state != BUILDING_STATE_IN_USE || b->house_size) {
                        continue;
                    }
                    int is_entertainment_venue = 0;
                    int type = b->type;
                    switch (type) {
                        // SPECIAL TREATMENT
                        // entertainment venues
                        case BUILDING_THEATER:
                        case BUILDING_AMPHITHEATER:
                        case BUILDING_COLOSSEUM:
                        case BUILDING_HIPPODROME:
                            is_entertainment_venue = 1;
                            increase_count(type, b->num_workers > 0);
                            break;
                        case BUILDING_BARRACKS:
                            city_data.building.barracks_building_id = k;
                            increase_count(type, b->num_workers > 0);
                            break;
                        case BUILDING_HOSPITAL:
                            increase_count(type, b->num_workers > 0);
                            city_data.health.num_hospital_workers += b->num_workers;
                            break;
                            // water
                        case BUILDING_RESERVOIR:
                        case BUILDING_FOUNTAIN:
                            increase_count(type, b->has_water_access);
                            break;
                            // DEFAULT TREATMENT
                            // education
                        case BUILDING_SCHOOL:
                        case BUILDING_LIBRARY:
                        case BUILDING_ACADEMY:
                            // health
                        case BUILDING_BARBER:
                        case BUILDING_BATHHOUSE:
                        case BUILDING_DOCTOR:
                            // government
                        case BUILDING_FORUM:
                        case BUILDING_SENATE:
                            // entertainment schools
                        case BUILDING_ACTOR_COLONY:
                        case BUILDING_GLADIATOR_SCHOOL:
                        case BUILDING_LION_HOUSE:
                        case BUILDING_CHARIOT_MAKER:
                            // distribution
                        case BUILDING_MARKET:
                            // military
                        case BUILDING_MILITARY_ACADEMY:
                            // religion
                        case BUILDING_SMALL_TEMPLE_CERES:
                        case BUILDING_SMALL_TEMPLE_NEPTUNE:
                        case BUILDING_SMALL_TEMPLE_MERCURY:
                        case BUILDING_SMALL_TEMPLE_MARS:
                        case BUILDING_SMALL_TEMPLE_VENUS:
                        case BUILDING_LARGE_TEMPLE_CERES:
                        case BUILDING_LARGE_TEMPLE_NEPTUNE:
                        case BUILDING_LARGE_TEMPLE_MERCURY:
                        case BUILDING_LARGE_TEMPLE_MARS:
                        case BUILDING_LARGE_TEMPLE_VENUS:
                        case BUILDING_ORACLE:
                            increase_count(type, b->num_workers > 0);
                            break;
                            // industry
                        case BUILDING_WHEAT_FARM:
                            increase_industry_count(RESOURCE_WHEAT, b->num_workers > 0);
                            break;
                        case BUILDING_VEGETABLE_FARM:
                            increase_industry_count(RESOURCE_VEGETABLES, b->num_workers > 0);
                            break;
                        case BUILDING_FRUIT_FARM:
                            increase_industry_count(RESOURCE_FRUIT, b->num_workers > 0);
                            break;
                        case BUILDING_OLIVE_FARM:
                            increase_industry_count(RESOURCE_OLIVES, b->num_workers > 0);
                            break;
                        case BUILDING_VINES_FARM:
                            increase_industry_count(RESOURCE_VINES, b->num_workers > 0);
                            break;
                        case BUILDING_PIG_FARM:
                            increase_industry_count(RESOURCE_MEAT, b->num_workers > 0);
                            break;
                        case BUILDING_MARBLE_QUARRY:
                            increase_industry_count(RESOURCE_MARBLE, b->num_workers > 0);
                            break;
                        case BUILDING_IRON_MINE:
                            increase_industry_count(RESOURCE_IRON, b->num_workers > 0);
                            break;
                        case BUILDING_TIMBER_YARD:
                            increase_industry_count(RESOURCE_TIMBER, b->num_workers > 0);
                            break;
                        case BUILDING_CLAY_PIT:
                            increase_industry_count(RESOURCE_CLAY, b->num_workers > 0);
                            break;
                        case BUILDING_WINE_WORKSHOP:
                            increase_industry_count(RESOURCE_WINE, b->num_workers > 0);
                            break;
                        case BUILDING_OIL_WORKSHOP:
                            increase_industry_count(RESOURCE_OIL, b->num_workers > 0);
                            break;
                        case BUILDING_WEAPONS_WORKSHOP:
                            increase_industry_count(RESOURCE_WEAPONS, b->num_workers > 0);
                            break;
                        case BUILDING_FURNITURE_WORKSHOP:
                            increase_industry_count(RESOURCE_FURNITURE, b->num_workers > 0);
                            break;
                        case BUILDING_POTTERY_WORKSHOP:
                            increase_industry_count(RESOURCE_POTTERY, b->num_workers > 0);
                            break;
                            // water-side
                        case BUILDING_WHARF:
                            if (b->num_workers > 0) {
                                city_data.building.working_wharfs++;
                                if (!b->data.industry.fishing_boat_id) {
                                    city_data.building.shipyard_boats_requested++;
                                }
                            }
                            break;
                        case BUILDING_DOCK:
                            if (b->num_workers > 0 && b->has_water_access) {
                                city_data.building.working_dock_ids[city_data.building.working_docks] = k;
                                city_data.building.working_docks++;
                            }
                            break;
                        default:
                            continue;
                    }
                    if (b->immigrant_figure_id) {
                        struct figure_t *f = &figures[b->immigrant_figure_id];
                        if (!figure_is_alive(f) || f->destination_building_id != k) {
                            b->immigrant_figure_id = 0;
                        }
                    }
                    if (is_entertainment_venue) {
                        // update number of shows
                        int shows = 0;
                        if (b->data.entertainment.days1 > 0) {
                            --b->data.entertainment.days1;
                            ++shows;
                        }
                        if (b->data.entertainment.days2 > 0) {
                            --b->data.entertainment.days2;
                            ++shows;
                        }
                        b->data.entertainment.num_shows = shows;
                    }
                }
                limit_hippodrome();
                city_culture_update_coverage();
            }
            break;
            case 34: // distribute treasury
                int units = 5 * count_data.buildings[BUILDING_SENATE].active + count_data.buildings[BUILDING_FORUM].active;
                int amount_per_unit;
                int remainder;
                if (city_data.finance.treasury > 0 && units > 0) {
                    amount_per_unit = city_data.finance.treasury / units;
                    remainder = city_data.finance.treasury - units * amount_per_unit;
                } else {
                    amount_per_unit = 0;
                    remainder = 0;
                }

                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE || b->house_size) {
                        continue;
                    }
                    b->tax_income_or_storage = 0;
                    if (b->num_workers <= 0) {
                        continue;
                    }
                    switch (b->type) {
                        // ordered based on importance: most important gets the remainder
                        case BUILDING_SENATE:
                            b->tax_income_or_storage = 5 * amount_per_unit + remainder;
                            remainder = 0;
                            break;
                        case BUILDING_FORUM:
                            if (remainder && !count_data.buildings[BUILDING_SENATE].active) {
                                b->tax_income_or_storage = amount_per_unit + remainder;
                                remainder = 0;
                            } else {
                                b->tax_income_or_storage = amount_per_unit;
                            }
                            break;
                    }
                }
                break;
            case 35: // decay culture 
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE || !b->house_size) {
                        continue;
                    }
                    decay(&b->data.house.theater);
                    decay(&b->data.house.amphitheater_actor);
                    decay(&b->data.house.amphitheater_gladiator);
                    decay(&b->data.house.colosseum_gladiator);
                    decay(&b->data.house.colosseum_lion);
                    decay(&b->data.house.hippodrome);
                    decay(&b->data.house.school);
                    decay(&b->data.house.library);
                    decay(&b->data.house.academy);
                    decay(&b->data.house.barber);
                    decay(&b->data.house.clinic);
                    decay(&b->data.house.bathhouse);
                    decay(&b->data.house.hospital);
                    decay(&b->data.house.temple_ceres);
                    decay(&b->data.house.temple_neptune);
                    decay(&b->data.house.temple_mercury);
                    decay(&b->data.house.temple_mars);
                    decay(&b->data.house.temple_venus);
                }
                break;
            case 36: // calculate culture aggregates
            {
                int base_entertainment = (culture_coverage.hippodrome + culture_coverage.colosseum + culture_coverage.amphitheater + culture_coverage.theater) / 4 / 5;
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE || !b->house_size) {
                        continue;
                    }
                    // entertainment
                    b->data.house.entertainment = base_entertainment;
                    if (b->data.house.theater) {
                        b->data.house.entertainment += 10;
                    }
                    if (b->data.house.amphitheater_actor) {
                        if (b->data.house.amphitheater_gladiator) {
                            b->data.house.entertainment += 15;
                        } else {
                            b->data.house.entertainment += 10;
                        }
                    }
                    if (b->data.house.colosseum_gladiator) {
                        if (b->data.house.colosseum_lion) {
                            b->data.house.entertainment += 25;
                        } else {
                            b->data.house.entertainment += 15;
                        }
                    }
                    if (b->data.house.hippodrome) {
                        b->data.house.entertainment += 30;
                    }
                    // education
                    b->data.house.education = 0;
                    // release build mingw doesn't like school || library for some reason
                    if (b->data.house.school) {
                        b->data.house.education = 1;
                    }
                    if (b->data.house.library) {
                        b->data.house.education = 1;
                    }
                    if (b->data.house.school && b->data.house.library) {
                        b->data.house.education = 2;
                        if (b->data.house.academy) {
                            b->data.house.education = 3;
                        }
                    }
                    // religion
                    b->data.house.num_gods = 0;
                    if (b->data.house.temple_ceres) {
                        ++b->data.house.num_gods;
                    }
                    if (b->data.house.temple_neptune) {
                        ++b->data.house.num_gods;
                    }
                    if (b->data.house.temple_mercury) {
                        ++b->data.house.num_gods;
                    }
                    if (b->data.house.temple_mars) {
                        ++b->data.house.num_gods;
                    }
                    if (b->data.house.temple_venus) {
                        ++b->data.house.num_gods;
                    }
                    // health
                    b->data.house.health = 0;
                    if (b->data.house.clinic) {
                        ++b->data.house.health;
                    }
                    if (b->data.house.hospital) {
                        ++b->data.house.health;
                    }
                }
                break;
            }
            case 37: // update map desirability
            {
                memset(desirability_grid.items, 0, GRID_SIZE * GRID_SIZE * sizeof(int8_t));
                for (int k = 1; k <= extra.highest_id_in_use; k++) {
                    struct building_t *b = &all_buildings[k];
                    if (b->state == BUILDING_STATE_IN_USE) {
                        add_to_terrain(
                            b->x, b->y, b->size,
                            building_properties[b->type].desirability_value,
                            building_properties[b->type].desirability_step,
                            building_properties[b->type].desirability_step_size,
                            building_properties[b->type].desirability_range);
                    }
                }
                int grid_offset = map_data.start_offset;
                for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
                    for (int x = 0; x < map_data.width; x++, grid_offset++) {
                        if (bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
                            int type;
                            if (terrain_grid.items[grid_offset] & TERRAIN_ROAD) {
                                type = BUILDING_PLAZA;
                            } else if (terrain_grid.items[grid_offset] & TERRAIN_ROCK) {
                                // earthquake fault line: slight negative
                                type = BUILDING_HOUSE_VACANT_LOT;
                            } else {
                                // invalid plaza/earthquake flag
                                bitfields_grid.items[grid_offset] &= BIT_NO_PLAZA;
                                continue;
                            }
                            add_to_terrain(x, y, 1,
                                building_properties[type].desirability_value,
                                building_properties[type].desirability_step,
                                building_properties[type].desirability_step_size,
                                building_properties[type].desirability_range);
                        } else if (terrain_grid.items[grid_offset] & TERRAIN_GARDEN) {
                            add_to_terrain(x, y, 1,
                                building_properties[BUILDING_GARDENS].desirability_value,
                                building_properties[BUILDING_GARDENS].desirability_step,
                                building_properties[BUILDING_GARDENS].desirability_step_size,
                                building_properties[BUILDING_GARDENS].desirability_range);
                        } else if (terrain_grid.items[grid_offset] & TERRAIN_RUBBLE) {
                            add_to_terrain(x, y, 1, -2, 1, 1, 2);
                        } else if (terrain_grid.items[grid_offset] & TERRAIN_WATER) {
                            add_to_terrain(x, y, 1, 1, 1, 0, 3);
                        } else if (terrain_grid.items[grid_offset] & TERRAIN_SHRUB) {
                            add_to_terrain(x, y, 1, 1, 1, 0, 1);
                        } else if (terrain_grid.items[grid_offset] & TERRAIN_TREE) {
                            add_to_terrain(x, y, 1, 1, 1, 0, 3);
                        }
                    }
                }
                int index = 0;
                int x, y;
                for (int size = 1; size <= 5; size++) {
                    for (int dist = 1; dist <= 6; dist++) {
                        desirability_data.index[size][dist] = index;
                        // top row, from x=0
                        for (y = -dist, x = 0; x < size + dist; x++, index++) {
                            desirability_data.tiles[index].x = x;
                            desirability_data.tiles[index].y = y;
                        }
                        // right row down
                        for (x = size + dist - 1, y = -dist + 1; y < size + dist; y++, index++) {
                            desirability_data.tiles[index].x = x;
                            desirability_data.tiles[index].y = y;
                        }
                        // bottom row to the left
                        for (y = size + dist - 1, x = size + dist - 2; x >= -dist; x--, index++) {
                            desirability_data.tiles[index].x = x;
                            desirability_data.tiles[index].y = y;
                        }
                        // left row up
                        for (x = -dist, y = size + dist - 2; y >= -dist; y--, index++) {
                            desirability_data.tiles[index].x = x;
                            desirability_data.tiles[index].y = y;
                        }
                        // top row up to x=0
                        for (y = -dist, x = -dist + 1; x < 0; x++, index++) {
                            desirability_data.tiles[index].x = x;
                            desirability_data.tiles[index].y = y;
                        }
                    }
                }
                for (int k = 0; k < index; k++) {
                    desirability_data.tiles[k].grid_offset = map_grid_delta(desirability_data.tiles[k].x, desirability_data.tiles[k].y);
                }
            }
            break;
            case 38: // update building desirability
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE) {
                        continue;
                    }
                    if (b->size == 1) {
                        b->desirability = desirability_grid.items[map_grid_offset(b->x, b->y)];
                    } else {
                        int max = -9999;
                        for (int dy = 0; dy < b->size; dy++) {
                            for (int dx = 0; dx < b->size; dx++) {
                                int grid_offset = map_grid_offset(b->x + dx, b->y + dy);
                                if (desirability_grid.items[grid_offset] > max) {
                                    max = desirability_grid.items[grid_offset];
                                }
                            }
                        }
                        b->desirability = max;
                    }
                }
                break;
            case 39: // evolve/devolve houses, consume goods
                city_data.houses.missing.fountain = 0;
                city_data.houses.missing.well = 0;
                city_data.houses.missing.entertainment = 0;
                city_data.houses.missing.more_entertainment = 0;
                city_data.houses.missing.education = 0;
                city_data.houses.missing.more_education = 0;
                city_data.houses.missing.religion = 0;
                city_data.houses.missing.second_religion = 0;
                city_data.houses.missing.third_religion = 0;
                city_data.houses.missing.barber = 0;
                city_data.houses.missing.bathhouse = 0;
                city_data.houses.missing.clinic = 0;
                city_data.houses.missing.hospital = 0;
                city_data.houses.missing.food = 0;
                // NB: second_wine purposely not cleared
                city_data.houses.requiring.school = 0;
                city_data.houses.requiring.library = 0;
                city_data.houses.requiring.barber = 0;
                city_data.houses.requiring.bathhouse = 0;
                city_data.houses.requiring.clinic = 0;
                city_data.houses.requiring.religion = 0;
                int has_expanded = 0;
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state == BUILDING_STATE_IN_USE && building_is_house(b->type) && b->type != BUILDING_HOUSE_VACANT_LOT) {
                        int calc_grid_offset = map_grid_offset(b->x, b->y);
                        b->data.house.no_space_to_expand = 0;
                        if (b->grid_offset != calc_grid_offset || map_building_at(b->grid_offset) != b->id) {
                            for (int y = 0; y < map_data.height; y++) {
                                for (int x = 0; x < map_data.width; x++) {
                                    int grid_offset = map_grid_offset(x, y);
                                    if (map_building_at(grid_offset) == b->id) {
                                        b->grid_offset = grid_offset;
                                        b->x = map_grid_offset_to_x(grid_offset);
                                        b->y = map_grid_offset_to_y(grid_offset);
                                        building_totals_add_corrupted_house(0);
                                        return;
                                    }
                                }
                            }
                            building_totals_add_corrupted_house(1);
                            b->state = BUILDING_STATE_RUBBLE;
                        }
                        has_expanded |= evolve_callback[b->type - BUILDING_HOUSE_SMALL_TENT](b, &city_data.houses);
                        if (time_data.day == 0 || time_data.day == 7) {
                            consume_resource(b, INVENTORY_POTTERY, house_properties[b->subtype.house_level].pottery);
                            consume_resource(b, INVENTORY_FURNITURE, house_properties[b->subtype.house_level].furniture);
                            consume_resource(b, INVENTORY_OIL, house_properties[b->subtype.house_level].oil);
                            consume_resource(b, INVENTORY_WINE, house_properties[b->subtype.house_level].wine);
                        }
                    }
                }
                if (has_expanded) {
                    map_routing_update_land();
                }
                break;
            case 40: building_update_state(); break;
            case 43: // update burning ruins
                building_list_data.burning.size = 0;
                building_list_data.burning.total = 0;
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_BURNING_RUIN) {
                        continue;
                    }
                    if (b->fire_duration < 0) {
                        b->fire_duration = 0;
                    }
                    b->fire_duration++;
                    if (b->fire_duration > 32) {
                        undo_data.available = 0;
                        b->state = BUILDING_STATE_RUBBLE;
                        map_building_tiles_set_rubble(j, b->x, b->y, b->size);
                        recalculate_terrain = 1;
                        continue;
                    }
                    if (b->ruin_has_plague) {
                        continue;
                    }
                    building_list_data.burning.total++;
                    building_list_data.burning.items[building_list_data.burning.size++] = j;
                    if (building_list_data.burning.size >= MAX_BURNING) {
                        building_list_data.burning.size = MAX_BURNING - 1;
                    }
                    if (scenario.climate == CLIMATE_DESERT) {
                        if (b->fire_duration & 3) { // check spread every 4 ticks
                            continue;
                        }
                    } else {
                        if (b->fire_duration & 7) { // check spread every 8 ticks
                            continue;
                        }
                    }
                    if ((b->house_figure_generation_delay & 3) != (random_data.random1_7bit & 3)) {
                        continue;
                    }
                    int dir1 = fire_spread_direction - 1;
                    if (dir1 < 0) dir1 = 7;
                    int dir2 = fire_spread_direction + 1;
                    if (dir2 > 7) dir2 = 0;

                    int grid_offset = b->grid_offset;
                    int next_building_id = map_building_at(grid_offset + map_grid_direction_delta(fire_spread_direction));
                    if (next_building_id && !all_buildings[next_building_id].fire_proof) {
                        building_destroy_by_fire(&all_buildings[next_building_id]);
                        play_sound_effect(SOUND_EFFECT_EXPLOSION);
                        recalculate_terrain = 1;
                    } else {
                        next_building_id = map_building_at(grid_offset + map_grid_direction_delta(dir1));
                        if (next_building_id && !all_buildings[next_building_id].fire_proof) {
                            building_destroy_by_fire(&all_buildings[next_building_id]);
                            play_sound_effect(SOUND_EFFECT_EXPLOSION);
                            recalculate_terrain = 1;
                        } else {
                            next_building_id = map_building_at(grid_offset + map_grid_direction_delta(dir2));
                            if (next_building_id && !all_buildings[next_building_id].fire_proof) {
                                building_destroy_by_fire(&all_buildings[next_building_id]);
                                play_sound_effect(SOUND_EFFECT_EXPLOSION);
                                recalculate_terrain = 1;
                            }
                        }
                    }
                }
                if (recalculate_terrain) {
                    map_routing_update_land();
                }
                break;
            case 44: // check fire/collapse
                city_data.sentiment.protesters = 0;
                city_data.sentiment.criminals = 0;
                int random_global = random_data.random1_7bit & 7;
                for (int j = 1; j <= extra.highest_id_in_use; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE || b->fire_proof) {
                        continue;
                    }
                    if (b->type == BUILDING_HIPPODROME && b->prev_part_building_id) {
                        continue;
                    }
                    int random_building = (j + random.items[b->grid_offset]) & 7;
                    // damage
                    b->damage_risk += random_building == random_global ? 3 : 1;
                    if (b->house_size && b->subtype.house_level <= HOUSE_LARGE_TENT) {
                        b->damage_risk = 0;
                    }
                    if (b->damage_risk > 200) {
                        city_message_apply_sound_interval(MESSAGE_CAT_COLLAPSE);
                        city_message_post_with_popup_delay(MESSAGE_CAT_COLLAPSE, MESSAGE_COLLAPSED_BUILDING, b->type, b->grid_offset);
                        undo_data.available = 0;
                        building_destroy_by_collapse(b);
                        recalculate_terrain = 1;
                        continue;
                    }
                    // fire
                    if (random_building == random_global) {
                        if (!b->house_size) {
                            b->fire_risk += 5;
                        } else if (b->house_population <= 0) {
                            b->fire_risk = 0;
                        } else if (b->subtype.house_level <= HOUSE_LARGE_SHACK) {
                            b->fire_risk += 10;
                        } else if (b->subtype.house_level <= HOUSE_GRAND_INSULA) {
                            b->fire_risk += 5;
                        } else {
                            b->fire_risk += 2;
                        }
                        if (scenario.climate == CLIMATE_NORTHERN) {
                            b->fire_risk = 0;
                        } else if (scenario.climate == CLIMATE_DESERT) {
                            b->fire_risk += 3;
                        }
                    }
                    if (b->fire_risk > 100) {
                        city_message_apply_sound_interval(MESSAGE_CAT_FIRE);
                        city_message_post_with_popup_delay(MESSAGE_CAT_FIRE, MESSAGE_FIRE, b->type, b->grid_offset);
                        building_destroy_by_fire(b);
                        play_sound_effect(SOUND_EFFECT_EXPLOSION);
                        recalculate_terrain = 1;
                    }
                }
                if (recalculate_terrain) {
                    map_routing_update_land();
                }
                break;
            case 45:
            {
                struct building_t *min_building = 0;
                int min_happiness = 50;
                for (int k = 1; k <= extra.highest_id_in_use; k++) {
                    struct building_t *b = &all_buildings[k];
                    if (b->state == BUILDING_STATE_IN_USE && b->house_size) {
                        if (b->sentiment.house_happiness >= 50) {
                            b->house_criminal_active = 0;
                        } else if (b->sentiment.house_happiness < min_happiness) {
                            min_happiness = b->sentiment.house_happiness;
                            min_building = b;
                        }
                    }
                }
                if (min_building) {
                    int sentiment = city_data.sentiment.value;
                    if (sentiment < 30) {
                        if (random_data.random1_7bit >= sentiment + 50) {
                            if (min_happiness <= 10) {
                                int x_road, y_road;
                                if (map_closest_road_within_radius(min_building->x, min_building->y, min_building->size, 4, &x_road, &y_road)) {
                                    city_data.sentiment.criminals++;
                                    int people_in_mob;
                                    if (city_data.population.population <= 150) {
                                        people_in_mob = 1;
                                    } else if (city_data.population.population <= 300) {
                                        people_in_mob = 2;
                                    } else if (city_data.population.population <= 800) {
                                        people_in_mob = 3;
                                    } else if (city_data.population.population <= 1200) {
                                        people_in_mob = 4;
                                    } else if (city_data.population.population <= 2000) {
                                        people_in_mob = 5;
                                    } else {
                                        people_in_mob = 6;
                                    }
                                    int x_target, y_target;
                                    int target_building_id = formation_rioter_get_target_building(&x_target, &y_target);
                                    for (int k = 0; k < people_in_mob; k++) {
                                        struct figure_t *f = figure_create(FIGURE_RIOTER, x_road, y_road, DIR_4_BOTTOM);
                                        f->is_targetable = 1;
                                        f->action_state = FIGURE_ACTION_RIOTER_CREATED;
                                        f->terrain_usage = TERRAIN_USAGE_ENEMY;
                                        f->roam_length = 0;
                                        f->wait_ticks = 10 + 4 * k;
                                        if (target_building_id) {
                                            f->destination_x = x_target;
                                            f->destination_y = y_target;
                                            f->destination_building_id = target_building_id;
                                        }
                                        city_data.figure.rioters++;
                                    }
                                    destroy_on_fire(min_building, 0);
                                    city_data.ratings.peace_num_rioters++;
                                    city_data.ratings.peace_riot_cause = city_data.sentiment.low_mood_cause;
                                    city_sentiment_change_happiness(20);
                                    city_message_apply_sound_interval(MESSAGE_CAT_RIOT);
                                    city_message_post_with_popup_delay(MESSAGE_CAT_RIOT, MESSAGE_RIOT, min_building->type, map_grid_offset(x_road, y_road));
                                }
                            } else if (min_happiness < 30) {
                                generate_mugger(min_building);
                            } else if (min_happiness < 50) {
                                generate_protestor(min_building);
                            }
                        }
                    } else if (sentiment < 60) {
                        if (random_data.random1_7bit >= sentiment + 40) {
                            if (min_happiness < 30) {
                                generate_mugger(min_building);
                            } else if (min_happiness < 50) {
                                generate_protestor(min_building);
                            }
                        }
                    } else {
                        if (random_data.random1_7bit >= sentiment + 20) {
                            if (min_happiness < 50) {
                                generate_protestor(min_building);
                            }
                        }
                    }
                }
            }
            break;
            case 46: // update wheat production
                if (scenario.climate != CLIMATE_NORTHERN) {
                    for (int j = 1; j < MAX_BUILDINGS; j++) {
                        struct building_t *b = &all_buildings[j];
                        if (b->state != BUILDING_STATE_IN_USE || !b->output_resource_id) {
                            continue;
                        }
                        if (b->houses_covered <= 0 || b->num_workers <= 0) {
                            continue;
                        }
                        if (b->type == BUILDING_WHEAT_FARM && !b->data.industry.curse_days_left) {
                            b->data.industry.progress += b->num_workers;
                            if (b->data.industry.blessing_days_left) {
                                b->data.industry.progress += b->num_workers;
                            }
                            if (b->data.industry.progress > MAX_PROGRESS_RAW) {
                                b->data.industry.progress = MAX_PROGRESS_RAW;
                            }
                            update_farm_image(b);
                        }
                    }
                }
                break;
            case 48: // decay tax collector
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state == BUILDING_STATE_IN_USE && b->house_tax_coverage) {
                        b->house_tax_coverage--;
                    }
                }
                break;
            case 49: city_culture_calculate(); break;
        }
        time_data.tick++;
        if (time_data.tick >= 50) {
            time_data.tick = 0;
            time_data.total_days++;
            time_data.day++;
            if (time_data.day >= 16) { // advance month
                time_data.day = 0;
                city_data.migration.newcomers = 0;
                if (city_data.population.population < 200) {
                    city_data.health.value = 50;
                    city_data.health.target_value = 50;
                } else {
                    int total_population = 0;
                    int healthy_population = 0;
                    for (int k = 1; k < MAX_BUILDINGS; k++) {
                        struct building_t *b = &all_buildings[k];
                        if (b->state != BUILDING_STATE_IN_USE || !b->house_size || !b->house_population) {
                            continue;
                        }
                        total_population += b->house_population;
                        if (b->subtype.house_level <= HOUSE_LARGE_TENT) {
                            if (b->data.house.clinic) {
                                healthy_population += b->house_population;
                            } else {
                                healthy_population += b->house_population / 4;
                            }
                        } else if (b->data.house.clinic) {
                            if (b->house_days_without_food == 0) {
                                healthy_population += b->house_population;
                            } else {
                                healthy_population += b->house_population / 4;
                            }
                        } else if (b->house_days_without_food == 0) {
                            healthy_population += b->house_population / 4;
                        }
                    }
                    city_data.health.target_value = calc_percentage(healthy_population, total_population);
                    if (city_data.health.value < city_data.health.target_value) {
                        city_data.health.value += 2;
                        if (city_data.health.value > city_data.health.target_value) {
                            city_data.health.value = city_data.health.target_value;
                        }
                    } else if (city_data.health.value > city_data.health.target_value) {
                        city_data.health.value -= 2;
                        if (city_data.health.value < city_data.health.target_value) {
                            city_data.health.value = city_data.health.target_value;
                        }
                    }
                    city_data.health.value = calc_bound(city_data.health.value, 0, 100);
                    int chance_value = random_data.random1_7bit & 0x3f;
                    if (city_data.health.value < 40) {
                        if (city_data.religion.venus_curse_active) {
                            // force plague
                            chance_value = 0;
                            city_data.religion.venus_curse_active = 0;
                        }
                        if (chance_value <= 40 - city_data.health.value) {
                            int sick_people = calc_adjust_with_percentage(total_population, 7 + (random_data.random1_7bit & 3));
                            if (sick_people) {
                                city_data.health.value = calc_bound(city_data.health.value + 10, 0, 100);
                                int people_to_kill = sick_people - city_data.health.num_hospital_workers;
                                if (!people_to_kill) {
                                    city_message_post(1, MESSAGE_HEALTH_ILLNESS, 0, 0);
                                } else {
                                    if (city_data.health.num_hospital_workers > 0) {
                                        city_message_post(1, MESSAGE_HEALTH_DISEASE, 0, 0);
                                    } else {
                                        city_message_post(1, MESSAGE_HEALTH_PESTILENCE, 0, 0);
                                    }
                                    int cont = 1;
                                    // kill people who don't have access to a doctor
                                    for (int l = 1; l < MAX_BUILDINGS; l++) {
                                        struct building_t *b = &all_buildings[l];
                                        if (b->state == BUILDING_STATE_IN_USE && b->house_size && b->house_population) {
                                            if (!b->data.house.clinic) {
                                                people_to_kill -= b->house_population;
                                                destroy_on_fire(b, 1);
                                                if (people_to_kill <= 0) {
                                                    cont = 0;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (cont) {
                                        // kill people in tents
                                        for (int l = 1; l < MAX_BUILDINGS; l++) {
                                            struct building_t *b = &all_buildings[l];
                                            if (b->state == BUILDING_STATE_IN_USE && b->house_size && b->house_population) {
                                                if (b->subtype.house_level <= HOUSE_LARGE_TENT) {
                                                    people_to_kill -= b->house_population;
                                                    destroy_on_fire(b, 1);
                                                    if (people_to_kill <= 0) {
                                                        cont = 0;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if (cont) {
                                            // kill anyone
                                            for (int l = 1; l < MAX_BUILDINGS; l++) {
                                                struct building_t *b = &all_buildings[l];
                                                if (b->state == BUILDING_STATE_IN_USE && b->house_size && b->house_population) {
                                                    people_to_kill -= b->house_population;
                                                    destroy_on_fire(b, 1);
                                                    if (people_to_kill <= 0) {
                                                        return;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                int event = RANDOM_EVENT_PROBABILITY[random_data.random1_7bit];
                switch (event) {
                    case EVENT_ROME_RAISES_WAGES:
                        if (scenario.random_events.raise_wages) {
                            if (city_data.labor.wages_rome < 45) {
                                city_data.labor.wages_rome += 1 + (random_data.random2_7bit & 3);
                                if (city_data.labor.wages_rome > 45) {
                                    city_data.labor.wages_rome = 45;
                                }
                                city_message_post(1, MESSAGE_ROME_RAISES_WAGES, 0, 0);
                            }
                        }
                        break;
                    case EVENT_ROME_LOWERS_WAGES:
                        if (scenario.random_events.lower_wages) {
                            if (city_data.labor.wages_rome > 5) {
                                city_data.labor.wages_rome -= 1 + (random_data.random2_7bit & 3);
                                city_message_post(1, MESSAGE_ROME_LOWERS_WAGES, 0, 0);
                            }
                        }
                        break;
                    case EVENT_LAND_TRADE_DISRUPTED:
                        if (scenario.random_events.land_trade_problem) {
                            if (city_data.trade.num_land_routes) {
                                city_data.trade.land_trade_problem_duration = 48;
                                if (scenario.climate == CLIMATE_DESERT) {
                                    city_message_post(1, MESSAGE_LAND_TRADE_DISRUPTED_SANDSTORMS, 0, 0);
                                } else {
                                    city_message_post(1, MESSAGE_LAND_TRADE_DISRUPTED_LANDSLIDES, 0, 0);
                                }
                            }
                        }
                        break;
                    case EVENT_LAND_SEA_DISRUPTED:
                        if (scenario.random_events.sea_trade_problem) {
                            if (city_data.trade.num_sea_routes) {
                                city_data.trade.sea_trade_problem_duration = 48;
                                city_message_post(1, MESSAGE_SEA_TRADE_DISRUPTED, 0, 0);
                            }
                        }
                        break;
                    case EVENT_CONTAMINATED_WATER:
                        if (scenario.random_events.contaminated_water) {
                            if (city_data.population.population > 200) {
                                int change;
                                if (city_data.health.value > 80) {
                                    change = -50;
                                } else if (city_data.health.value > 60) {
                                    change = -40;
                                } else {
                                    change = -25;
                                }
                                city_data.health.value = calc_bound(city_data.health.value + change, 0, 100);
                                city_message_post(1, MESSAGE_CONTAMINATED_WATER, 0, 0);
                            }
                        }
                        break;
                }
                // collect monthly taxes
                city_data.taxes.taxed_plebs = 0;
                city_data.taxes.taxed_patricians = 0;
                city_data.taxes.untaxed_plebs = 0;
                city_data.taxes.untaxed_patricians = 0;
                city_data.taxes.monthly.uncollected_plebs = 0;
                city_data.taxes.monthly.collected_plebs = 0;
                city_data.taxes.monthly.uncollected_patricians = 0;
                city_data.taxes.monthly.collected_patricians = 0;
                for (int j = 0; j < MAX_HOUSE_LEVELS; j++) {
                    city_data.population.at_level[j] = 0;
                }
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE || !b->house_size) {
                        continue;
                    }
                    int is_patrician = b->subtype.house_level >= HOUSE_SMALL_VILLA;
                    int population = b->house_population;
                    city_data.population.at_level[b->subtype.house_level] += population;
                    int tax = population * house_properties[b->subtype.house_level].tax_multiplier;
                    if (b->house_tax_coverage) {
                        if (is_patrician) {
                            city_data.taxes.taxed_patricians += population;
                            city_data.taxes.monthly.collected_patricians += tax;
                        } else {
                            city_data.taxes.taxed_plebs += population;
                            city_data.taxes.monthly.collected_plebs += tax;
                        }
                        b->tax_income_or_storage += tax;
                    } else {
                        if (is_patrician) {
                            city_data.taxes.untaxed_patricians += population;
                            city_data.taxes.monthly.uncollected_patricians += tax;
                        } else {
                            city_data.taxes.untaxed_plebs += population;
                            city_data.taxes.monthly.uncollected_plebs += tax;
                        }
                    }
                }
                int collected_patricians = calc_adjust_with_percentage(
                    city_data.taxes.monthly.collected_patricians / 2,
                    city_data.finance.tax_percentage);
                int collected_plebs = calc_adjust_with_percentage(
                    city_data.taxes.monthly.collected_plebs / 2,
                    city_data.finance.tax_percentage);
                int collected_total = collected_patricians + collected_plebs;
                city_data.taxes.yearly.collected_patricians += collected_patricians;
                city_data.taxes.yearly.collected_plebs += collected_plebs;
                city_data.taxes.yearly.uncollected_patricians += calc_adjust_with_percentage(
                    city_data.taxes.monthly.uncollected_patricians / 2,
                    city_data.finance.tax_percentage);
                city_data.taxes.yearly.uncollected_plebs += calc_adjust_with_percentage(
                    city_data.taxes.monthly.uncollected_plebs / 2,
                    city_data.finance.tax_percentage);

                city_data.finance.treasury += collected_total;
                int total_patricians = city_data.taxes.taxed_patricians + city_data.taxes.untaxed_patricians;
                int total_plebs = city_data.taxes.taxed_plebs + city_data.taxes.untaxed_plebs;
                city_data.taxes.percentage_taxed_patricians = calc_percentage(city_data.taxes.taxed_patricians, total_patricians);
                city_data.taxes.percentage_taxed_plebs = calc_percentage(city_data.taxes.taxed_plebs, total_plebs);
                city_data.taxes.percentage_taxed_people = calc_percentage(
                    city_data.taxes.taxed_patricians + city_data.taxes.taxed_plebs,
                    total_patricians + total_plebs);
                // pay monthly wages
                int wages = city_data.labor.wages * city_data.labor.workers_employed / 10 / 12;
                city_data.finance.treasury -= wages;
                city_data.finance.wages_so_far += wages;
                city_data.finance.wage_rate_paid_this_year += city_data.labor.wages;
                // pay monthly interest
                if (city_data.finance.treasury < 0) {
                    int interest = calc_adjust_with_percentage(-city_data.finance.treasury, 10) / 12;
                    city_data.finance.treasury -= interest;
                    city_data.finance.interest_so_far += interest;
                }
                // pay monthly salary
                if (city_finance_can_afford(city_data.emperor.salary_amount)) {
                    city_data.finance.salary_so_far += city_data.emperor.salary_amount;
                    city_data.emperor.personal_savings += city_data.emperor.salary_amount;
                    city_data.finance.treasury -= city_data.emperor.salary_amount;
                }
                calculate_available_food();
                city_data.resource.food_types_eaten = 0;
                int total_consumed = 0;
                for (int k = 1; k < MAX_BUILDINGS; k++) {
                    struct building_t *b = &all_buildings[k];
                    if (b->state == BUILDING_STATE_IN_USE && b->house_size) {
                        int amount_per_type = calc_adjust_with_percentage(b->house_population, 50);
                        if (house_properties[b->subtype.house_level].food_types > 1) {
                            amount_per_type /= house_properties[b->subtype.house_level].food_types;
                        }
                        b->data.house.num_foods = 0;
                        if (scenario.rome_supplies_wheat) {
                            city_data.resource.food_types_eaten = 1;
                            city_data.resource.food_types_available = 1;
                            b->data.house.inventory[INVENTORY_WHEAT] = amount_per_type;
                            b->data.house.num_foods = 1;
                        } else if (house_properties[b->subtype.house_level].food_types > 0) {
                            for (int t = INVENTORY_WHEAT; t <= INVENTORY_MEAT && b->data.house.num_foods < house_properties[b->subtype.house_level].food_types; t++) {
                                if (b->data.house.inventory[t] >= amount_per_type) {
                                    b->data.house.inventory[t] -= amount_per_type;
                                    b->data.house.num_foods++;
                                    total_consumed += amount_per_type;
                                } else if (b->data.house.inventory[t]) {
                                    // has food but not enough
                                    b->data.house.inventory[t] = 0;
                                    b->data.house.num_foods++;
                                    total_consumed += amount_per_type;
                                }
                                if (b->data.house.num_foods > city_data.resource.food_types_eaten) {
                                    city_data.resource.food_types_eaten = b->data.house.num_foods;
                                }
                            }
                        }
                    }
                }
                city_data.resource.food_consumed_last_month = total_consumed;
                city_data.resource.food_produced_last_month = city_data.resource.food_produced_this_month;
                city_data.resource.food_produced_this_month = 0;
                if (city_data.mission.has_won) {
                    city_data.mission.continue_months_left--;
                }
                for (int k = 0; k < MAX_LEGIONS; k++) {
                    if (legion_formations[k].in_use && !legion_formations[k].in_distant_battle) {
                        struct formation_t *m = &legion_formations[k];
                        if (m->is_at_rest) {
                            m->deployed_duration_months = 0;
                            m->morale = calc_bound(m->morale + 5, 0, m->max_morale);
                        } else if (!m->recent_fight) {
                            m->deployed_duration_months++;
                            if (m->deployed_duration_months > 3) {
                                m->morale = calc_bound(m->morale - 5, 0, m->max_morale);
                            }
                        }
                    }
                }
                for (int k = 0; k < MAX_MESSAGE_CATEGORIES; k++) {
                    if (message_data.message_delay[k] > 0) {
                        message_data.message_delay[k]--;
                    }
                }
                map_tiles_update_all_roads();
                map_tiles_update_all_water();
                map_routing_update_land_citizen();
                city_message_sort_and_compact();
                time_data.month++;
                if (time_data.month >= 12) { // advance year
                    time_data.month = 0;
                    undo_data.available = 0;
                    time_data.year++;
                    if (!scenario.empire.is_expanded && scenario.empire.expansion_year && time_data.year >= scenario.empire.expansion_year + scenario.start_year) {
                        for (int k = 0; k < MAX_EMPIRE_OBJECTS; k++) {
                            if (!empire_objects[k].in_use || empire_objects[k].type != EMPIRE_OBJECT_CITY) {
                                continue;
                            }
                            if (empire_objects[k].city_type == EMPIRE_CITY_FUTURE_TRADE) {
                                empire_objects[k].city_type = EMPIRE_CITY_TRADE;
                                empire_objects[k].expanded.image_id = image_data_s.group_image_ids[GROUP_EMPIRE_CITY_TRADE];
                            } else if (empire_objects[k].city_type == EMPIRE_CITY_FUTURE_ROMAN) {
                                empire_objects[k].city_type = EMPIRE_CITY_DISTANT_ROMAN;
                                empire_objects[k].expanded.image_id = image_data_s.group_image_ids[GROUP_EMPIRE_CITY_DISTANT_ROMAN];
                            } else {
                                continue;
                            }
                        }
                        scenario.empire.is_expanded = 1;
                        city_message_post(1, MESSAGE_EMPIRE_HAS_EXPANDED, 0, 0);
                    }
                    city_data.population.yearly_update_requested = 1;
                    calculate_people_per_house_type();
                    // reset taxes
                    city_data.finance.last_year.income.taxes = city_data.taxes.yearly.collected_plebs + city_data.taxes.yearly.collected_patricians;
                    city_data.taxes.yearly.collected_plebs = 0;
                    city_data.taxes.yearly.collected_patricians = 0;
                    city_data.taxes.yearly.uncollected_plebs = 0;
                    city_data.taxes.yearly.uncollected_patricians = 0;
                    // reset tax income in building list
                    for (int j = 1; j < MAX_BUILDINGS; j++) {
                        struct building_t *b = &all_buildings[j];
                        if (b->state == BUILDING_STATE_IN_USE && b->house_size) {
                            b->tax_income_or_storage = 0;
                        }
                    }
                    // copy amounts to last year
                    struct finance_overview_t *last_year = &city_data.finance.last_year;
                    struct finance_overview_t *this_year = &city_data.finance.this_year;
                    // wages
                    last_year->expenses.wages = city_data.finance.wages_so_far;
                    city_data.finance.wages_so_far = 0;
                    city_data.finance.wage_rate_paid_last_year = city_data.finance.wage_rate_paid_this_year;
                    city_data.finance.wage_rate_paid_this_year = 0;
                    // import/export
                    last_year->income.exports = this_year->income.exports;
                    this_year->income.exports = 0;
                    last_year->expenses.imports = this_year->expenses.imports;
                    this_year->expenses.imports = 0;
                    // construction
                    last_year->expenses.construction = this_year->expenses.construction;
                    this_year->expenses.construction = 0;
                    // interest
                    last_year->expenses.interest = city_data.finance.interest_so_far;
                    city_data.finance.interest_so_far = 0;
                    // salary
                    city_data.finance.last_year.expenses.salary = city_data.finance.salary_so_far;
                    city_data.finance.salary_so_far = 0;
                    // sundries
                    last_year->expenses.sundries = this_year->expenses.sundries;
                    this_year->expenses.sundries = 0;
                    city_data.finance.stolen_last_year = city_data.finance.stolen_this_year;
                    city_data.finance.stolen_this_year = 0;
                    // donations
                    last_year->income.donated = this_year->income.donated;
                    this_year->income.donated = 0;
                    // pay tribute
                    int income =
                        last_year->income.donated +
                        last_year->income.taxes +
                        last_year->income.exports;
                    int expenses =
                        last_year->expenses.sundries +
                        last_year->expenses.salary +
                        last_year->expenses.interest +
                        last_year->expenses.construction +
                        last_year->expenses.wages +
                        last_year->expenses.imports;
                    city_data.finance.tribute_not_paid_last_year = 0;
                    if (city_data.finance.treasury <= 0) {
                        // city is in debt
                        city_data.finance.tribute_not_paid_last_year = 1;
                        city_data.finance.tribute_not_paid_total_years++;
                        last_year->expenses.tribute = 0;
                    } else if (income <= expenses) {
                        // city made a loss: fixed tribute based on population
                        city_data.finance.tribute_not_paid_total_years = 0;
                        if (city_data.population.population > 2000) {
                            last_year->expenses.tribute = 200;
                        } else if (city_data.population.population > 1000) {
                            last_year->expenses.tribute = 100;
                        } else {
                            last_year->expenses.tribute = 0;
                        }
                    } else {
                        // city made a profit: tribute is max of: 25% of profit, fixed tribute based on population
                        city_data.finance.tribute_not_paid_total_years = 0;
                        if (city_data.population.population > 5000) {
                            last_year->expenses.tribute = 500;
                        } else if (city_data.population.population > 3000) {
                            last_year->expenses.tribute = 400;
                        } else if (city_data.population.population > 2000) {
                            last_year->expenses.tribute = 300;
                        } else if (city_data.population.population > 1000) {
                            last_year->expenses.tribute = 225;
                        } else if (city_data.population.population > 500) {
                            last_year->expenses.tribute = 150;
                        } else {
                            last_year->expenses.tribute = 50;
                        }
                        int pct_profit = calc_adjust_with_percentage(income - expenses, 25);
                        if (pct_profit > last_year->expenses.tribute) {
                            last_year->expenses.tribute = pct_profit;
                        }
                    }
                    city_data.finance.treasury -= last_year->expenses.tribute;
                    city_data.finance.this_year.expenses.tribute = 0;
                    last_year->balance = city_data.finance.treasury;
                    last_year->income.total = income;
                    last_year->expenses.total = last_year->expenses.tribute + expenses;
                    // reset yearly trade amounts
                    for (int j = 0; j < MAX_EMPIRE_OBJECTS; j++) {
                        if (empire_objects[j].in_use && empire_objects[j].trade_route_open) {
                            for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                empire_objects[j].resource_bought[r] = 0;
                                empire_objects[j].resource_sold[r] = 0;
                            }
                        }
                    }
                    fire_spread_direction = random_data.random1_7bit & 7;
                    city_ratings_update(1);
                    city_data.religion.neptune_double_trade_active = 0;
                } else {
                    city_ratings_update(0);
                }
                for (int k = 0; k < MAX_EDITOR_CUSTOM_MESSAGES; k++) {
                    if (!scenario.editor_custom_messages[k].enabled) {
                        continue;
                    }
                    if (time_data.year == scenario.editor_custom_messages[k].year + scenario.start_year
                        && time_data.month == scenario.editor_custom_messages[k].month) {
                        city_message_post(1, MESSAGE_EDITOR_1 + k, 0, 0);
                    }
                }
                if (scenario.gladiator_revolt.state) {
                    if (scenario.gladiator_revolt.state == EVENT_NOT_STARTED) {
                        if (time_data.year == scenario.start_year + scenario.gladiator_revolt.year && time_data.month == scenario.gladiator_revolt.month) {
                            if (count_data.buildings[BUILDING_GLADIATOR_SCHOOL].active > 0) {
                                scenario.gladiator_revolt.state = EVENT_IN_PROGRESS;
                                city_message_post(1, MESSAGE_GLADIATOR_REVOLT, 0, 0);
                            } else {
                                scenario.gladiator_revolt.state = EVENT_FINISHED;
                            }
                        }
                    } else if (scenario.gladiator_revolt.state == EVENT_IN_PROGRESS) {
                        if (scenario.gladiator_revolt.month + 3 == time_data.month) {
                            scenario.gladiator_revolt.state = EVENT_FINISHED;
                            city_message_post(1, MESSAGE_GLADIATOR_REVOLT_FINISHED, 0, 0);
                        }
                    }
                }
                for (int k = 0; k < MAX_REQUESTS; k++) {
                    if (!scenario.requests[k].resource || scenario.requests[k].state > REQUEST_STATE_DISPATCHED_LATE) {
                        continue;
                    }
                    if (scenario.requests[k].state == REQUEST_STATE_DISPATCHED || scenario.requests[k].state == REQUEST_STATE_DISPATCHED_LATE) {
                        --scenario.requests[k].months_to_comply;
                        if (scenario.requests[k].months_to_comply <= 0) {
                            if (scenario.requests[k].state == REQUEST_STATE_DISPATCHED) {
                                city_message_post(1, MESSAGE_REQUEST_RECEIVED, k, 0);
                                city_data.ratings.favor = calc_bound(city_data.ratings.favor + scenario.requests[k].favor, 0, 100);
                            } else {
                                city_message_post(1, MESSAGE_REQUEST_RECEIVED_LATE, k, 0);
                                city_data.ratings.favor = calc_bound(city_data.ratings.favor + scenario.requests[k].favor / 2, 0, 100);
                            }
                            scenario.requests[k].state = REQUEST_STATE_RECEIVED;
                            scenario.requests[k].visible = 0;
                        }
                    } else {
                        // normal or overdue
                        if (scenario.requests[k].visible) {
                            --scenario.requests[k].months_to_comply;
                            if (scenario.requests[k].state == REQUEST_STATE_NORMAL) {
                                if (scenario.requests[k].months_to_comply == 12) {
                                    // reminder
                                    city_message_post(1, MESSAGE_REQUEST_REMINDER, k, 0);
                                } else if (scenario.requests[k].months_to_comply <= 0) {
                                    city_message_post(1, MESSAGE_REQUEST_REFUSED, k, 0);
                                    scenario.requests[k].state = REQUEST_STATE_OVERDUE;
                                    scenario.requests[k].months_to_comply = 24;
                                    city_data.ratings.favor = calc_bound(city_data.ratings.favor - 3, 0, 100);
                                    city_data.ratings.favor_ignored_request_penalty = 3;
                                }
                            } else if (scenario.requests[k].state == REQUEST_STATE_OVERDUE) {
                                if (scenario.requests[k].months_to_comply <= 0) {
                                    city_message_post(1, MESSAGE_REQUEST_REFUSED_OVERDUE, k, 0);
                                    scenario.requests[k].state = REQUEST_STATE_IGNORED;
                                    scenario.requests[k].visible = 0;
                                    city_data.ratings.favor = calc_bound(city_data.ratings.favor - 5, 0, 100);
                                    city_data.ratings.favor_ignored_request_penalty = 5;
                                }
                            }
                            if (!scenario.requests[k].can_comply_dialog_shown &&
                                city_data.resource.stored_in_warehouses[scenario.requests[k].resource] >= scenario.requests[k].amount) {
                                scenario.requests[k].can_comply_dialog_shown = 1;
                                city_message_post(1, MESSAGE_REQUEST_CAN_COMPLY, k, 0);
                            }
                        } else {
                            // request is not visible
                            int year = scenario.start_year;
                            if (time_data.year == year + scenario.requests[k].year &&
                                time_data.month == scenario.requests[k].month) {
                                scenario.requests[k].visible = 1;
                                if (city_data.resource.stored_in_warehouses[scenario.requests[k].resource] >= scenario.requests[k].amount) {
                                    scenario.requests[k].can_comply_dialog_shown = 1;
                                }
                                if (scenario.requests[k].resource == RESOURCE_DENARII) {
                                    city_message_post(1, MESSAGE_CAESAR_REQUESTS_MONEY, k, 0);
                                } else if (scenario.requests[k].resource == RESOURCE_TROOPS) {
                                    city_message_post(1, MESSAGE_CAESAR_REQUESTS_ARMY, k, 0);
                                } else {
                                    city_message_post(1, MESSAGE_CAESAR_REQUESTS_GOODS, k, 0);
                                }
                            }
                        }
                    }
                }
                for (int k = 0; k < MAX_PRICE_CHANGES; k++) {
                    if (!scenario.price_changes[k].resource) {
                        continue;
                    }
                    if (time_data.year != scenario.price_changes[k].year + scenario.start_year ||
                        time_data.month != scenario.price_changes[k].month) {
                        continue;
                    }
                    if (scenario.price_changes[k].is_rise) {
                        if (trade_price_change(scenario.price_changes[k].resource, scenario.price_changes[k].amount)) {
                            city_message_post(1, MESSAGE_PRICE_INCREASED, scenario.price_changes[k].amount, scenario.price_changes[k].resource);
                        }
                    } else {
                        if (trade_price_change(scenario.price_changes[k].resource, -scenario.price_changes[k].amount)) {
                            city_message_post(1, MESSAGE_PRICE_DECREASED, scenario.price_changes[k].amount, scenario.price_changes[k].resource);
                        }
                    }
                }
                for (int k = 0; k < MAX_DEMAND_CHANGES; k++) {
                    if (scenario.demand_changes[k].resource && scenario.demand_changes[k].trade_city_id
                        && time_data.year == scenario.demand_changes[k].year + scenario.start_year
                        && time_data.month == scenario.demand_changes[k].month) {
                        struct empire_object_t *trade_city = &empire_objects[scenario.demand_changes[k].trade_city_id];
                        if (trade_city->trade_route_open) {
                            if (scenario.demand_changes[k].is_rise) {
                                if (trade_city->resource_buy_limit[scenario.demand_changes[k].resource]) {
                                    switch (trade_city->resource_buy_limit[scenario.demand_changes[k].resource]) {
                                        case 0:
                                            trade_city->resource_buy_limit[scenario.demand_changes[k].resource] = 15;
                                            city_message_post(1, MESSAGE_INCREASED_TRADING, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        case 15:
                                            trade_city->resource_buy_limit[scenario.demand_changes[k].resource] = 25;
                                            city_message_post(1, MESSAGE_INCREASED_TRADING, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        case 25:
                                            trade_city->resource_buy_limit[scenario.demand_changes[k].resource] = 40;
                                            city_message_post(1, MESSAGE_INCREASED_TRADING, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        default:
                                            break;
                                    }
                                } else if (trade_city->resource_sell_limit[scenario.demand_changes[k].resource]) {
                                    switch (trade_city->resource_sell_limit[scenario.demand_changes[k].resource]) {
                                        case 0:
                                            trade_city->resource_sell_limit[scenario.demand_changes[k].resource] = 15;
                                            city_message_post(1, MESSAGE_INCREASED_TRADING, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        case 15:
                                            trade_city->resource_sell_limit[scenario.demand_changes[k].resource] = 25;
                                            city_message_post(1, MESSAGE_INCREASED_TRADING, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        case 25:
                                            trade_city->resource_sell_limit[scenario.demand_changes[k].resource] = 40;
                                            city_message_post(1, MESSAGE_INCREASED_TRADING, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        default:
                                            break;
                                    }
                                }
                            } else {
                                if (trade_city->resource_buy_limit[scenario.demand_changes[k].resource]) {
                                    switch (trade_city->resource_buy_limit[scenario.demand_changes[k].resource]) {
                                        case 40:
                                            trade_city->resource_buy_limit[scenario.demand_changes[k].resource] = 25;
                                            city_message_post(1, MESSAGE_DECREASED_TRADING, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        case 25:
                                            trade_city->resource_buy_limit[scenario.demand_changes[k].resource] = 15;
                                            city_message_post(1, MESSAGE_DECREASED_TRADING, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        case 15:
                                            trade_city->resource_buy_limit[scenario.demand_changes[k].resource] = 0;
                                            city_message_post(1, MESSAGE_TRADE_STOPPED, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        default:
                                            break;
                                    }
                                }
                                if (trade_city->resource_sell_limit[scenario.demand_changes[k].resource]) {
                                    switch (trade_city->resource_sell_limit[scenario.demand_changes[k].resource]) {
                                        case 40:
                                            trade_city->resource_sell_limit[scenario.demand_changes[k].resource] = 25;
                                            city_message_post(1, MESSAGE_DECREASED_TRADING, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        case 25:
                                            trade_city->resource_sell_limit[scenario.demand_changes[k].resource] = 15;
                                            city_message_post(1, MESSAGE_DECREASED_TRADING, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        case 15:
                                            trade_city->resource_sell_limit[scenario.demand_changes[k].resource] = 0;
                                            city_message_post(1, MESSAGE_TRADE_STOPPED, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        default:
                                            break;
                                    }
                                }
                            }
                        }
                    }
                }
                // handle warnings
                for (int k = 0; k < MAX_INVASIONS; k++) {
                    for (int l = 3; l > 0; l--) {
                        if (scenario.invasions[k].type == INVASION_TYPE_ENEMY_ARMY
                        && (time_data.year == scenario.start_year + scenario.invasions[k].year_offset - l && time_data.month == scenario.invasions[k].month)) {
                            scenario.invasion_upcoming = 1;
                            city_message_post(0, MESSAGE_ENEMIES_AT_THE_DOOR + 1 - l, 0, 0);
                        }
                    }

                }
                // trigger invasions
                for (int k = 0; k < MAX_INVASIONS; k++) {
                    if (time_data.year == scenario.start_year + scenario.invasions[k].year_offset && time_data.month == scenario.invasions[k].month) {
                        // enemy army
                        if (scenario.invasions[k].type == INVASION_TYPE_ENEMY_ARMY) {
                            int grid_offset = start_invasion(
                                scenario.invasions[k].enemy_type,
                                scenario.invasions[k].amount,
                                scenario.invasions[k].from,
                                scenario.invasions[k].target_type);
                            if (grid_offset > 0) {
                                if (scenario.invasions[k].enemy_type) {
                                    city_message_post(1, MESSAGE_ENEMY_ARMY_ATTACK, 0, grid_offset);
                                } else {
                                    city_message_post(1, MESSAGE_BARBARIAN_ATTACK, 0, grid_offset);
                                }
                            }
                        }
                        // editor scheduled invasion by Caesar
                        if (scenario.invasions[k].type == INVASION_TYPE_CAESAR) {
                            int grid_offset = start_invasion(
                                ENEMY_TYPE_CAESAR,
                                scenario.invasions[k].amount,
                                scenario.invasions[k].from,
                                scenario.invasions[k].target_type);
                            if (grid_offset > 0) {
                                city_data.emperor.invasion.from_editor = 1;
                                city_message_post(1, MESSAGE_CAESAR_ARMY_ATTACK, 0, grid_offset);
                            }
                        }
                        // local uprisings
                        if (scenario.invasions[k].type == INVASION_TYPE_LOCAL_UPRISING) {
                            int grid_offset = start_invasion(
                                ENEMY_TYPE_BARBARIAN,
                                scenario.invasions[k].amount,
                                scenario.invasions[k].from,
                                scenario.invasions[k].target_type);
                            if (grid_offset > 0) {
                                city_message_post(1, MESSAGE_LOCAL_UPRISING, 0, grid_offset);
                            }
                        }
                        scenario.invasion_upcoming = 0;
                    }
                }
                for (int k = 0; k < MAX_INVASIONS; k++) {
                    if (scenario.invasions[k].type == INVASION_TYPE_DISTANT_BATTLE &&
                        time_data.year == scenario.invasions[k].year_offset + scenario.start_year &&
                        time_data.month == scenario.invasions[k].month &&
                        scenario.empire.distant_battle_enemy_travel_months > 4 &&
                        scenario.empire.distant_battle_roman_travel_months > 4 &&
                        !(city_data.distant_battle.months_until_battle > 0 ||
                            city_data.distant_battle.roman_months_to_travel_back > 0 ||
                            city_data.distant_battle.roman_months_to_travel_forth > 0 ||
                            city_data.distant_battle.city_foreign_months_left > 0)) {
                        city_message_post(1, MESSAGE_CAESAR_REQUESTS_ARMY, 0, 0);
                        // init distant battle
                        city_data.distant_battle.enemy_months_traveled = 1;
                        city_data.distant_battle.roman_months_traveled = 1;
                        city_data.distant_battle.months_until_battle = 24;
                        city_data.distant_battle.enemy_strength = scenario.invasions[k].amount;
                        city_data.distant_battle.total_count++;
                        city_data.distant_battle.roman_months_to_travel_back = 0;
                        city_data.distant_battle.roman_months_to_travel_forth = 0;
                    }
                }
                if (city_data.distant_battle.months_until_battle > 0) {
                    --city_data.distant_battle.months_until_battle;
                    if (city_data.distant_battle.months_until_battle > 0) {
                        if (city_data.distant_battle.months_until_battle < scenario.empire.distant_battle_enemy_travel_months) {
                            city_data.distant_battle.enemy_months_traveled =
                                scenario.empire.distant_battle_enemy_travel_months - city_data.distant_battle.months_until_battle + 1;
                        } else {
                            city_data.distant_battle.enemy_months_traveled = 1;
                        }
                        if (city_data.distant_battle.roman_months_to_travel_forth >= 1) {
                            if (scenario.empire.distant_battle_roman_travel_months - city_data.distant_battle.roman_months_traveled >
                                scenario.empire.distant_battle_enemy_travel_months - city_data.distant_battle.enemy_months_traveled) {
                                city_data.distant_battle.roman_months_to_travel_forth -= 2;
                            } else {
                                city_data.distant_battle.roman_months_to_travel_forth--;
                            }
                            if (city_data.distant_battle.roman_months_to_travel_forth <= 1) {
                                city_data.distant_battle.roman_months_to_travel_forth = 1;
                            }
                            city_data.distant_battle.roman_months_traveled =
                                scenario.empire.distant_battle_roman_travel_months - city_data.distant_battle.roman_months_to_travel_forth + 1;
                            if (city_data.distant_battle.roman_months_traveled < 1) {
                                city_data.distant_battle.roman_months_traveled = 1;
                            }
                            if (city_data.distant_battle.roman_months_traveled > scenario.empire.distant_battle_roman_travel_months) {
                                city_data.distant_battle.roman_months_traveled = scenario.empire.distant_battle_roman_travel_months;
                            }
                        }
                    } else {
                        if (city_data.distant_battle.roman_months_to_travel_forth <= 0) {
                            city_message_post(1, MESSAGE_DISTANT_BATTLE_LOST_NO_TROOPS, 0, 0);
                            city_data.ratings.favor = calc_bound(city_data.ratings.favor - 50, 0, 100);
                            set_city_foreign();
                        } else if (city_data.distant_battle.roman_months_to_travel_forth > 2) {
                            city_message_post(1, MESSAGE_DISTANT_BATTLE_LOST_TOO_LATE, 0, 0);
                            city_data.ratings.favor = calc_bound(city_data.ratings.favor - 25, 0, 100);
                            set_city_foreign();
                            city_data.distant_battle.roman_months_to_travel_back = city_data.distant_battle.roman_months_traveled;
                        } else {
                            int player_won;
                            int pct_loss;
                            if (city_data.distant_battle.roman_strength < city_data.distant_battle.enemy_strength) {
                                player_won = 0;
                                pct_loss = 100;
                            } else {
                                player_won = 1;
                                int pct_advantage = calc_percentage(
                                    city_data.distant_battle.roman_strength - city_data.distant_battle.enemy_strength,
                                    city_data.distant_battle.roman_strength);
                                if (pct_advantage < 10) {
                                    pct_loss = 70;
                                } else if (pct_advantage < 25) {
                                    pct_loss = 50;
                                } else if (pct_advantage < 50) {
                                    pct_loss = 25;
                                } else if (pct_advantage < 75) {
                                    pct_loss = 15;
                                } else if (pct_advantage < 100) {
                                    pct_loss = 10;
                                } else if (pct_advantage < 150) {
                                    pct_loss = 5;
                                } else {
                                    pct_loss = 0;
                                }
                            }
                            // apply legion losses
                            for (int k = 0; k < MAX_LEGIONS; k++) {
                                if (legion_formations[k].in_use && legion_formations[k].in_distant_battle) {
                                    struct formation_t *m = &legion_formations[k];
                                    m->morale = calc_bound(m->morale - 75, 0, m->max_morale);
                                    int soldiers_total = 0;
                                    for (int fig = 0; fig < m->num_figures; fig++) {
                                        if (m->figures[fig] > 0) {
                                            struct figure_t *f = &figures[m->figures[fig]];
                                            if (figure_is_alive(f)) {
                                                soldiers_total++;
                                            }
                                        }
                                    }
                                    int soldiers_to_kill = calc_adjust_with_percentage(soldiers_total, pct_loss);
                                    if (soldiers_to_kill >= soldiers_total) {
                                        m->in_distant_battle = 0;
                                    }
                                    for (int fig = 0; fig < m->num_figures; fig++) {
                                        if (m->figures[fig] > 0) {
                                            struct figure_t *f = &figures[m->figures[fig]];
                                            if (figure_is_alive(f)) {
                                                if (soldiers_to_kill) {
                                                    soldiers_to_kill--;
                                                    figure_delete(f);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (player_won) {
                                if (scenario.allowed_buildings[BUILDING_TRIUMPHAL_ARCH]) {
                                    city_message_post(1, MESSAGE_DISTANT_BATTLE_WON, 0, 0);
                                    city_data.building.triumphal_arches_available++;
                                    build_menus[MENU_ADMINISTRATION].is_enabled = 1; // in case every other item in the menu was disabled
                                    build_menus[MENU_ADMINISTRATION].menu_items[10].building_id = BUILDING_TRIUMPHAL_ARCH;
                                } else {
                                    city_message_post(1, MESSAGE_DISTANT_BATTLE_WON_TRIUMPHAL_ARCH_DISABLED, 0, 0);
                                }
                                city_data.ratings.favor = calc_bound(city_data.ratings.favor + 25, 0, 100);
                                city_data.distant_battle.won_count++;
                                city_data.distant_battle.city_foreign_months_left = 0;
                                city_data.distant_battle.roman_months_to_travel_back = city_data.distant_battle.roman_months_traveled;
                            } else {
                                city_message_post(1, MESSAGE_DISTANT_BATTLE_LOST_TOO_WEAK, 0, 0);
                                city_data.ratings.favor = calc_bound(city_data.ratings.favor - 10, 0, 100);
                                set_city_foreign();
                                city_data.distant_battle.roman_months_traveled = 0;
                            }
                        }
                        city_data.distant_battle.months_until_battle = 0;
                        city_data.distant_battle.enemy_months_traveled = 0;
                        city_data.distant_battle.roman_months_to_travel_forth = 0;
                    }
                } else {
                    if (city_data.distant_battle.roman_months_to_travel_back > 0) {
                        city_data.distant_battle.roman_months_to_travel_back--;
                        city_data.distant_battle.roman_months_traveled = city_data.distant_battle.roman_months_to_travel_back;
                        if (city_data.distant_battle.roman_months_to_travel_back <= 0) {
                            if (city_data.distant_battle.city_foreign_months_left) {
                                // soldiers return - not in time
                                city_message_post(1, MESSAGE_TROOPS_RETURN_FAILED, 0, map_grid_offset(scenario.exit_point.x, scenario.exit_point.y));
                            } else {
                                // victorious
                                city_message_post(1, MESSAGE_TROOPS_RETURN_VICTORIOUS, 0, map_grid_offset(scenario.exit_point.x, scenario.exit_point.y));
                            }
                            city_data.distant_battle.roman_months_traveled = 0;
                            // return soldiers
                            for (int l = 0; l < MAX_LEGIONS; l++) {
                                if (legion_formations[l].in_use && legion_formations[l].in_distant_battle) {
                                    legion_formations[l].in_distant_battle = 0;
                                    for (int fig = 0; fig < legion_formations[l].num_figures; fig++) {
                                        if (legion_formations[l].figures[fig] > 0) {
                                            struct figure_t *f = &figures[legion_formations[l].figures[fig]];
                                            if (figure_is_alive(f)) {
                                                f->action_state = FIGURE_ACTION_SOLDIER_RETURNING_FROM_DISTANT_BATTLE;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else if (city_data.distant_battle.city_foreign_months_left > 0) {
                        city_data.distant_battle.city_foreign_months_left--;
                        if (city_data.distant_battle.city_foreign_months_left <= 0) {
                            city_message_post(1, MESSAGE_DISTANT_BATTLE_CITY_RETAKEN, 0, 0);
                            if (city_data.distant_battle.city) {
                                empire_objects[city_data.distant_battle.city].city_type = EMPIRE_CITY_VULNERABLE_ROMAN;
                            }
                        }
                    }
                }
                // record monthly population
                city_data.population.monthly.values[city_data.population.monthly.next_index++] = city_data.population.population;
                if (city_data.population.monthly.next_index >= 2400) {
                    city_data.population.monthly.next_index = 0;
                }
                ++city_data.population.monthly.count;
                city_data.festival.months_since_festival++;
                if (city_data.festival.first_festival_effect_months) {
                    --city_data.festival.first_festival_effect_months;
                }
                if (city_data.festival.second_festival_effect_months) {
                    --city_data.festival.second_festival_effect_months;
                }
                if (city_data.festival.size) {
                    city_data.festival.months_to_go--;
                    if (city_data.festival.months_to_go <= 0) {
                        if (city_data.festival.first_festival_effect_months <= 0) {
                            city_data.festival.first_festival_effect_months = 12;
                            switch (city_data.festival.size) {
                                case FESTIVAL_SMALL: city_sentiment_change_happiness(7); break;
                                case FESTIVAL_LARGE: city_sentiment_change_happiness(9); break;
                                case FESTIVAL_GRAND: city_sentiment_change_happiness(12); break;
                            }
                        } else if (city_data.festival.second_festival_effect_months <= 0) {
                            city_data.festival.second_festival_effect_months = 12;
                            switch (city_data.festival.size) {
                                case FESTIVAL_SMALL: city_sentiment_change_happiness(2); break;
                                case FESTIVAL_LARGE: city_sentiment_change_happiness(3); break;
                                case FESTIVAL_GRAND: city_sentiment_change_happiness(5); break;
                            }
                        }
                        city_data.festival.months_since_festival = 1;
                        city_data.religion.gods[city_data.festival.god].months_since_festival = 0;
                        switch (city_data.festival.size) {
                            case FESTIVAL_SMALL: city_message_post(1, MESSAGE_SMALL_FESTIVAL, 0, 0); break;
                            case FESTIVAL_LARGE: city_message_post(1, MESSAGE_LARGE_FESTIVAL, 0, 0); break;
                            case FESTIVAL_GRAND: city_message_post(1, MESSAGE_GRAND_FESTIVAL, 0, 0); break;
                        }
                        city_data.festival.size = FESTIVAL_NONE;
                        city_data.festival.months_to_go = 0;
                    }
                }
                if (settings_values[SETTINGS_MONTHLY_AUTOSAVE_ENABLED]) {
                    game_file_io_write_saved_game(SAVES_DIR_PATH, "autosave.sav");
                }
            }
            if (time_data.day == 0 || time_data.day == 8) {
                city_sentiment_update();
            }
        }
        for (int k = 0; k < MAX_EARTHQUAKES; k++) {
            if (scenario.earthquakes[k].state && scenario.earthquakes[k].branch_coordinates[0].x > -1 && scenario.earthquakes[k].branch_coordinates[0].y > -1) {
                if (scenario.earthquakes[k].state == EVENT_NOT_STARTED) {
                    if (scenario.start_year + scenario.earthquakes[k].year == time_data.year && scenario.earthquakes[k].month == time_data.month) {
                        scenario.earthquakes[k].state = EVENT_IN_PROGRESS;
                        city_message_post(1, MESSAGE_EARTHQUAKE, 0, map_grid_offset(scenario.earthquakes[k].branch_coordinates[0].x, scenario.earthquakes[k].branch_coordinates[1].y));
                    }
                } else if (scenario.earthquakes[k].state == EVENT_IN_PROGRESS) {
                    scenario.earthquakes[k].delay++;
                    if (scenario.earthquakes[k].delay >= scenario.earthquakes[k].max_delay) {
                        scenario.earthquakes[k].delay = 0;
                        scenario.earthquakes[k].duration++;
                        if (scenario.earthquakes[k].duration >= scenario.earthquakes[k].max_duration) {
                            scenario.earthquakes[k].state = EVENT_FINISHED;
                        }
                        int index = rand() % 4;
                        int dx = 0;
                        int dy = 0;
                        switch (index) {
                            case 0:
                                // ~north
                                dx = rand() % 3 - 1;
                                dy = dx ? 0 : -1;
                                break;
                            case 1:
                                // ~east
                                dy = rand() % 3 - 1;
                                dx = dy ? 0 : 1;
                                break;
                            case 2:
                                // ~south
                                dx = rand() % 3 - 1;
                                dy = dx ? 0 : 1;
                                break;
                            case 3:
                                // ~west
                                dy = rand() % 3 - 1;
                                dx = dy ? 0 : -1;
                                break;
                            default:
                                break;
                        }
                        int x = calc_bound(scenario.earthquakes[k].branch_coordinates[index].x + dx, 0, scenario.map.width - 1);
                        int y = calc_bound(scenario.earthquakes[k].branch_coordinates[index].y + dy, 0, scenario.map.height - 1);
                        if (!map_terrain_is(map_grid_offset(x, y), TERRAIN_ELEVATION | TERRAIN_ROCK | TERRAIN_WATER)) {
                            scenario.earthquakes[k].branch_coordinates[index].x = x;
                            scenario.earthquakes[k].branch_coordinates[index].y = y;
                            // advance_earthquake_to_tile(x, y);
                            // advance earthquake to tile
                            int grid_offset = map_grid_offset(x, y);
                            int building_id = map_building_at(grid_offset);
                            if (building_id) {
                                building_destroy_by_collapse(&all_buildings[building_id]);
                                int ruin_id = map_building_at(grid_offset);
                                if (ruin_id) {
                                    all_buildings[ruin_id].state = BUILDING_STATE_DELETED_BY_GAME;
                                    buildings_grid.items[grid_offset] = 0;
                                }
                            }
                            terrain_grid.items[grid_offset] = 0;
                            // earthquake: terrain = rock && bitfields = plaza
                            terrain_grid.items[grid_offset] |= TERRAIN_ROCK;
                            bitfields_grid.items[grid_offset] |= BIT_PLAZA_OR_EARTHQUAKE;

                            foreach_region_tile(x - 1, y - 1, x + 1, y + 1, set_earthquake_image);
                            map_tiles_update_all_gardens();
                            map_tiles_update_all_roads();
                            map_tiles_update_all_plazas();
                            map_routing_update_land();
                            map_routing_update_walls();
                            play_sound_effect(SOUND_EFFECT_EXPLOSION);
                            figure_create_explosion_cloud(x, y, 1);
                        }
                    }
                }
            }
        }
        victory_data.state = VICTORY_STATE_NONE;
        if ((scenario.time_limit_win_criteria.enabled && (time_data.year >= scenario.start_year + scenario.time_limit_win_criteria.years))
        || (city_figures_total_invading_enemies() > 2 + city_data.figure.soldiers && city_data.population.population < city_data.population.highest_ever / 4)
        || (city_figures_total_invading_enemies() > 0 && !city_data.population.population)
        ) {
            victory_data.state = VICTORY_STATE_LOST;
        } else if (scenario.survival_time_win_criteria.enabled && (time_data.year >= scenario.start_year + scenario.survival_time_win_criteria.years)) {
            victory_data.state = VICTORY_STATE_WON;
        } else {
            if (scenario.culture_win_criteria.enabled || scenario.prosperity_win_criteria.enabled
            || scenario.peace_win_criteria.enabled || scenario.favor_win_criteria.enabled || scenario.population_win_criteria.enabled) {
                int all_criteria_fulfilled = 1;
                if ((scenario.culture_win_criteria.enabled && city_data.ratings.culture < scenario.culture_win_criteria.goal)
                || (scenario.prosperity_win_criteria.enabled && city_data.ratings.prosperity < scenario.prosperity_win_criteria.goal)
                || (scenario.peace_win_criteria.enabled && city_data.ratings.peace < scenario.peace_win_criteria.goal)
                || (scenario.favor_win_criteria.enabled && city_data.ratings.favor < scenario.favor_win_criteria.goal)
                || (scenario.population_win_criteria.enabled && city_data.population.population < scenario.population_win_criteria.goal)
                ) {
                    all_criteria_fulfilled = 0;
                }
                if (all_criteria_fulfilled) {
                    victory_data.state = VICTORY_STATE_WON;
                }
            }
        }
        if (city_data.mission.has_won) {
            victory_data.state = city_data.mission.continue_months_left <= 0 ? VICTORY_STATE_WON : VICTORY_STATE_NONE;
        }
        if (victory_data.force_win) {
            victory_data.state = VICTORY_STATE_WON;
        }
        if (victory_data.state != VICTORY_STATE_NONE) {
            building_construction_clear_type();
            if (victory_data.state == VICTORY_STATE_LOST) {
                if (city_data.mission.fired_message_shown) {
                    window_intermezzo_show(INTERMEZZO_FIRED, show_end_dialog);
                } else {
                    city_data.mission.fired_message_shown = 1;
                    city_message_post(1, MESSAGE_FIRED, 0, 0);
                }
                victory_data.force_win = 0;
            } else if (victory_data.state == VICTORY_STATE_WON) {
                stop_music();
                if (city_data.mission.victory_message_shown) {
                    mouse_data.left.went_up = 0;
                    mouse_data.right.went_up = 0;
                    settings_values[SETTINGS_VICTORY_VIDEO] = settings_values[SETTINGS_VICTORY_VIDEO] ? 0 : 1;
                    if (settings_values[SETTINGS_VICTORY_VIDEO]) {
                        window_victory_video_show("smk/victory_balcony.smk", 400, 292, show_intermezzo);
                    } else {
                        window_victory_video_show("smk/victory_senate.smk", 400, 292, show_intermezzo);
                    }
                    victory_data.force_win = 0;
                } else {
                    city_data.mission.victory_message_shown = 1;
                    struct window_type_t window = {
                        WINDOW_VICTORY_DIALOG,
                        draw_background_victory_dialog,
                        draw_foreground_victory_dialog,
                        handle_input_victory_dialog,
                    };
                    window_show(&window);
                }
            }
        }
        city_data.entertainment.hippodrome_has_race = 0;
        for (int j = 1; j < MAX_FIGURES; j++) {
            struct figure_t *f = &figures[j];
            if (f->is_corpse) {
                if (f->wait_ticks < 0) {
                    f->wait_ticks = 0;
                }
                f->wait_ticks++;
                if (f->wait_ticks >= 128) {
                    f->wait_ticks = 127;
                    figure_delete(f);
                    break;
                }
                switch (f->type) {
                    case FIGURE_IMMIGRANT:
                    case FIGURE_EMIGRANT:
                    case FIGURE_CHARIOTEER: // corpse images missing for charioteer, assign migrant ones
                    case FIGURE_TRADE_CARAVAN:
                    case FIGURE_TRADE_CARAVAN_DONKEY:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_MIGRANT] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;  // corpse images missing for trade caravan, assign migrant ones
                        break;
                    case FIGURE_HOMELESS:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_HOMELESS] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_PATRICIAN:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_PATRICIAN] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_CART_PUSHER:
                    case FIGURE_DOCKER:
                    case FIGURE_WAREHOUSEMAN:
                    case FIGURE_NATIVE_TRADER:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_CARTPUSHER] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        f->cart_image_id = 0;
                        break;
                    case FIGURE_LABOR_SEEKER:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_LABOR_SEEKER] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_BARBER:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_BARBER] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_BATHHOUSE_WORKER:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_BATHHOUSE_WORKER] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_DOCTOR:
                    case FIGURE_SURGEON:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_DOCTOR_SURGEON] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_PRIEST:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_PRIEST] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_SCHOOL_CHILD:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_SCHOOL_CHILD] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_TEACHER:
                    case FIGURE_LIBRARIAN:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_TEACHER_LIBRARIAN] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_MISSIONARY:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_MISSIONARY] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_ACTOR:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_ACTOR] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_GLADIATOR:
                    case FIGURE_ENEMY_GLADIATOR:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_GLADIATOR] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_LION_TAMER:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_LION_TAMER] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        f->cart_image_id = 0;
                        break;
                    case FIGURE_TAX_COLLECTOR:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_TAX_COLLECTOR] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_ENGINEER:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_ENGINEER] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_TOWER_SENTRY:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_TOWER_SENTRY] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 136;
                        break;
                    case FIGURE_PREFECT:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_PREFECT] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_FORT_JAVELIN:
                        f->image_id = image_data_s.group_image_ids[GROUP_BUILDING_FORT_JAVELIN] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 144;
                        break;
                    case FIGURE_FORT_MOUNTED:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_FORT_MOUNTED] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 144;
                        break;
                    case FIGURE_FORT_LEGIONARY:
                        f->image_id = image_data_s.group_image_ids[GROUP_BUILDING_FORT_LEGIONARY] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 152;
                        break;
                    case FIGURE_MARKET_BUYER:
                    case FIGURE_MARKET_TRADER:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_MARKET_LADY] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_DELIVERY_BOY:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_DELIVERY_BOY] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_PROTESTER:
                    case FIGURE_CRIMINAL:
                    case FIGURE_RIOTER:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_CRIMINAL] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_INDIGENOUS_NATIVE:
                    case FIGURE_ENEMY_BARBARIAN_SWORDSMAN:
                        f->image_id = 441 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2];
                        break;
                    case FIGURE_WOLF:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_WOLF] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_SHEEP:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_SHEEP] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 104;
                        break;
                    case FIGURE_ZEBRA:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_ZEBRA] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN:
                    case FIGURE_ENEMY_BRITON_SWORDSMAN:
                    case FIGURE_ENEMY_CELT_SWORDSMAN:
                    case FIGURE_ENEMY_PICT_SWORDSMAN:
                    case FIGURE_ENEMY_EGYPTIAN_SWORDSMAN:
                    case FIGURE_ENEMY_ETRUSCAN_SWORDSMAN:
                    case FIGURE_ENEMY_SAMNITE_SWORDSMAN:
                    case FIGURE_ENEMY_GAUL_SWORDSMAN:
                    case FIGURE_ENEMY_HELVETIUS_SWORDSMAN:
                    case FIGURE_ENEMY_HUN_SWORDSMAN:
                    case FIGURE_ENEMY_GOTH_SWORDSMAN:
                    case FIGURE_ENEMY_VISIGOTH_SWORDSMAN:
                    case FIGURE_ENEMY_GREEK_SWORDSMAN:
                    case FIGURE_ENEMY_MACEDONIAN_SWORDSMAN:
                    case FIGURE_ENEMY_IBERIAN_SWORDSMAN:
                    case FIGURE_ENEMY_PERGAMUM_SWORDSMAN:
                    case FIGURE_ENEMY_JUDEAN_SWORDSMAN:
                    case FIGURE_ENEMY_SELEUCID_SWORDSMAN:
                        f->image_id = 593 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2];
                        break;
                    case FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT:
                        f->image_id = 705 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2];
                        break;
                    case FIGURE_ENEMY_BRITON_CHARIOT:
                    case FIGURE_ENEMY_CELT_CHARIOT:
                    case FIGURE_ENEMY_PICT_CHARIOT:
                    case FIGURE_ENEMY_EGYPTIAN_CAMEL:
                    case FIGURE_ENEMY_GAUL_AXEMAN:
                    case FIGURE_ENEMY_HELVETIUS_AXEMAN:
                    case FIGURE_ENEMY_HUN_MOUNTED_ARCHER:
                    case FIGURE_ENEMY_GOTH_MOUNTED_ARCHER:
                    case FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER:
                        f->image_id = 745 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2];
                        break;
                    case FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_SAMNITE_SPEAR_THROWER:
                    case FIGURE_ENEMY_GREEK_SPEAR_THROWER:
                    case FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_PERGAMUM_ARCHER:
                    case FIGURE_ENEMY_IBERIAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_JUDEAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_SELEUCID_SPEAR_THROWER:
                        f->image_id = 793 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2];
                        break;
                    case FIGURE_ENEMY_NUMIDIAN_SWORDSMAN:
                    case FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER:
                        f->image_id = 641 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2];
                        break;
                    case FIGURE_ENEMY_CAESAR_JAVELIN:
                    case FIGURE_ENEMY_CAESAR_MOUNTED:
                    case FIGURE_ENEMY_CAESAR_LEGIONARY:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_CAESAR_LEGIONARY] + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 152;
                        break;
                }
                continue;
            } else if (f->engaged_in_combat) {
                if (f->progress_on_tile <= 5) {
                    f->progress_on_tile++;
                    advance_tick_movement(f);
                }
                f->attack_image_offset++;
                if (f->target_figure_id) {
                    struct figure_t *opponent = &figures[f->target_figure_id];
                    if (f->attack_image_offset >= 24 || unit_is_charging_opponent(f, opponent)) {
                        if (figure_properties[opponent->type].is_unarmed_civilian_unit || figure_properties[opponent->type].is_criminal_unit) {
                            f->attack_image_offset = 12;
                        } else {
                            f->attack_image_offset = 0;
                        }
                        int attacker_attack_value = figure_properties[f->type].melee_attack_value;
                        int opponent_defense_value = figure_properties[opponent->type].melee_defense_value;
                        int deg_abs_delta = abs(f->attack_direction * 45 - opponent->attack_direction * 45);
                        switch (deg_abs_delta) {
                            case 0:
                            case 45:
                            case 315:
                                attacker_attack_value *= 2;
                                opponent_defense_value = 0;
                                play_sound_effect(SOUND_EFFECT_SWORD_SWING);
                                break;
                            case 90:
                            case 270:
                                attacker_attack_value += 2;
                                opponent_defense_value /= 2;
                                break;
                            default:
                                break;
                        }
                        int net_attack = attacker_attack_value - opponent_defense_value;
                        if (net_attack < 0) {
                            net_attack = 0;
                        }
                        opponent->damage += net_attack;
                        if (opponent->damage <= figure_properties[opponent->type].max_damage) {
                            switch (f->type) {
                                case FIGURE_LION_TAMER:
                                    play_sound_effect(SOUND_EFFECT_LION_ATTACK);
                                    break;
                                case FIGURE_WOLF:
                                    play_sound_effect(SOUND_EFFECT_WOLF_ATTACK);
                                    break;
                                case FIGURE_FORT_LEGIONARY:
                                case FIGURE_ENEMY_CAESAR_LEGIONARY:
                                    play_sound_effect(SOUND_EFFECT_SWORD);
                                    break;
                                case FIGURE_FORT_JAVELIN:
                                case FIGURE_FORT_MOUNTED:
                                case FIGURE_ENEMY_GLADIATOR:
                                case FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN:
                                case FIGURE_ENEMY_ETRUSCAN_SWORDSMAN:
                                case FIGURE_ENEMY_SAMNITE_SWORDSMAN:
                                case FIGURE_ENEMY_GREEK_SWORDSMAN:
                                case FIGURE_ENEMY_MACEDONIAN_SWORDSMAN:
                                case FIGURE_ENEMY_BRITON_CHARIOT:
                                case FIGURE_ENEMY_CELT_CHARIOT:
                                case FIGURE_ENEMY_PICT_CHARIOT:
                                case FIGURE_ENEMY_BRITON_SWORDSMAN:
                                case FIGURE_ENEMY_CELT_SWORDSMAN:
                                case FIGURE_ENEMY_PICT_SWORDSMAN:
                                case FIGURE_ENEMY_GAUL_SWORDSMAN:
                                case FIGURE_ENEMY_HELVETIUS_SWORDSMAN:
                                case FIGURE_ENEMY_HUN_MOUNTED_ARCHER:
                                case FIGURE_ENEMY_GOTH_MOUNTED_ARCHER:
                                case FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER:
                                    play_sound_effect(SOUND_EFFECT_LIGHT_SWORD);
                                    break;
                                case FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER:
                                case FIGURE_ENEMY_SAMNITE_SPEAR_THROWER:
                                case FIGURE_ENEMY_GREEK_SPEAR_THROWER:
                                case FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER:
                                case FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER:
                                case FIGURE_ENEMY_IBERIAN_SPEAR_THROWER:
                                case FIGURE_ENEMY_JUDEAN_SPEAR_THROWER:
                                case FIGURE_ENEMY_SELEUCID_SPEAR_THROWER:
                                    play_sound_effect(SOUND_EFFECT_SPEAR);
                                    break;
                                case FIGURE_ENEMY_EGYPTIAN_SWORDSMAN:
                                case FIGURE_ENEMY_PERGAMUM_SWORDSMAN:
                                case FIGURE_ENEMY_IBERIAN_SWORDSMAN:
                                case FIGURE_ENEMY_JUDEAN_SWORDSMAN:
                                case FIGURE_ENEMY_SELEUCID_SWORDSMAN:
                                case FIGURE_ENEMY_BARBARIAN_SWORDSMAN:
                                case FIGURE_ENEMY_HUN_SWORDSMAN:
                                case FIGURE_ENEMY_GOTH_SWORDSMAN:
                                case FIGURE_ENEMY_VISIGOTH_SWORDSMAN:
                                case FIGURE_ENEMY_NUMIDIAN_SWORDSMAN:
                                    play_sound_effect(SOUND_EFFECT_CLUB);
                                    break;
                                case FIGURE_ENEMY_GAUL_AXEMAN:
                                case FIGURE_ENEMY_HELVETIUS_AXEMAN:
                                    play_sound_effect(SOUND_EFFECT_AXE);
                                    break;
                                case FIGURE_ENEMY_EGYPTIAN_CAMEL:
                                    play_sound_effect(SOUND_EFFECT_CAMEL);
                                    break;
                                case FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT:
                                    city_data.sound.hit_elephant = !city_data.sound.hit_elephant;
                                    if (city_data.sound.hit_elephant) {
                                        play_sound_effect(SOUND_EFFECT_ELEPHANT);
                                    } else {
                                        play_sound_effect(SOUND_EFFECT_ELEPHANT_HIT);
                                    }
                                    break;
                                default:
                                    break;
                            }
                        } else {
                            opponent->is_corpse = 1;
                            opponent->is_targetable = 0;
                            opponent->wait_ticks = 0;
                            figure_play_die_sound(opponent);
                            if (figure_properties[opponent->type].is_player_legion_unit) {
                                update_formation_morale_after_death(&legion_formations[opponent->formation_id]);
                            } else {
                                update_formation_morale_after_death(&enemy_formations[opponent->formation_id]);
                            }
                            clear_targeting_on_unit_death(opponent);
                        }
                        if (unit_is_charging_opponent(f, opponent)) {
                            play_sound_effect(SOUND_EFFECT_HORSE_MOVING);
                            f->mounted_charge_ticks--;
                        }
                        if (figure_properties[opponent->type].is_player_legion_unit) {
                            legion_formations[opponent->formation_id].recent_fight = 6;
                        } else if (figure_properties[opponent->type].is_enemy_unit || figure_properties[opponent->type].is_caesar_legion_unit) {
                            enemy_formations[opponent->formation_id].recent_fight = 6;
                        }
                    }
                } else {
                    f->engaged_in_combat = 0;
                    figure_route_remove(f);
                }
                figure_image_increase_offset(f, 12);
                int dir = get_direction(f);
                switch (f->type) {
                    case FIGURE_GLADIATOR:
                    case FIGURE_ENEMY_GLADIATOR:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_GLADIATOR] + dir + 104 + 8 * (f->image_offset / 2);
                        break;
                    case FIGURE_LION_TAMER:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_LION_TAMER] + dir + 8 * f->image_offset;
                        break;
                    case FIGURE_TOWER_SENTRY:
                        if (f->attack_image_offset < 12) {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_TOWER_SENTRY] + 96 + figure_image_direction(f);
                        } else {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_TOWER_SENTRY] + 96 + figure_image_direction(f) + 8 * ((f->attack_image_offset - 12) / 2);
                            // some buffer images missing, img ids 6841+ are for corpse
                            if (f->image_id >= 6841) {
                                f->image_id = f->image_id - 8;
                            }
                        }
                        break;
                    case FIGURE_PREFECT:
                        if (f->attack_image_offset >= 12) {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_PREFECT] + 104 + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        } else {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_PREFECT] + 104 + dir;
                        }
                        break;
                    case FIGURE_FORT_JAVELIN:
                        if (f->attack_image_offset < 12) {
                            f->image_id = image_data_s.group_image_ids[GROUP_BUILDING_FORT_JAVELIN] + 96 + dir;
                        } else {
                            f->image_id = image_data_s.group_image_ids[GROUP_BUILDING_FORT_JAVELIN] + 96 + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        }
                        break;
                    case FIGURE_FORT_MOUNTED:
                        if (f->attack_image_offset < 12) {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_FORT_MOUNTED] + 96 + dir;
                        } else {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_FORT_MOUNTED] + 96 + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        }
                        break;
                    case FIGURE_FORT_LEGIONARY:
                        if (f->attack_image_offset < 12) {
                            f->image_id = image_data_s.group_image_ids[GROUP_BUILDING_FORT_LEGIONARY] + 96 + f->attack_direction;
                        } else {
                            f->image_id = image_data_s.group_image_ids[GROUP_BUILDING_FORT_LEGIONARY] + 96 + f->attack_direction + 8 * ((f->attack_image_offset - 12) / 2);
                        }
                        break;
                    case FIGURE_INDIGENOUS_NATIVE:
                    case FIGURE_ENEMY_BARBARIAN_SWORDSMAN:
                        if (f->attack_image_offset >= 12) {
                            f->image_id = 393 + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        } else {
                            f->image_id = 393 + dir;
                        }
                        break;
                    case FIGURE_WOLF:
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_WOLF] + 104 + dir + 8 * (f->attack_image_offset / 4);
                        break;
                    case FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN:
                    case FIGURE_ENEMY_BRITON_SWORDSMAN:
                    case FIGURE_ENEMY_CELT_SWORDSMAN:
                    case FIGURE_ENEMY_PICT_SWORDSMAN:
                    case FIGURE_ENEMY_EGYPTIAN_SWORDSMAN:
                    case FIGURE_ENEMY_ETRUSCAN_SWORDSMAN:
                    case FIGURE_ENEMY_SAMNITE_SWORDSMAN:
                    case FIGURE_ENEMY_GAUL_SWORDSMAN:
                    case FIGURE_ENEMY_HELVETIUS_SWORDSMAN:
                    case FIGURE_ENEMY_GREEK_SWORDSMAN:
                    case FIGURE_ENEMY_MACEDONIAN_SWORDSMAN:
                    case FIGURE_ENEMY_PERGAMUM_SWORDSMAN:
                    case FIGURE_ENEMY_IBERIAN_SWORDSMAN:
                    case FIGURE_ENEMY_JUDEAN_SWORDSMAN:
                    case FIGURE_ENEMY_SELEUCID_SWORDSMAN:
                        if (f->attack_image_offset >= 12) {
                            f->image_id = 545 + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        } else {
                            f->image_id = 545 + dir;
                        }
                        break;
                    case FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT:
                    case FIGURE_ENEMY_EGYPTIAN_CAMEL:
                    case FIGURE_ENEMY_HUN_MOUNTED_ARCHER:
                    case FIGURE_ENEMY_GOTH_MOUNTED_ARCHER:
                    case FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER:
                        f->image_id = 601 + dir + 8 * f->image_offset;
                        break;
                    case FIGURE_ENEMY_BRITON_CHARIOT:
                    case FIGURE_ENEMY_CELT_CHARIOT:
                    case FIGURE_ENEMY_PICT_CHARIOT:
                        f->image_id = 697 + dir + 8 * (f->image_offset / 2);
                        break;
                    case FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_SAMNITE_SPEAR_THROWER:
                    case FIGURE_ENEMY_GREEK_SPEAR_THROWER:
                    case FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_PERGAMUM_ARCHER:
                    case FIGURE_ENEMY_IBERIAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_JUDEAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_SELEUCID_SPEAR_THROWER:
                        if (f->attack_image_offset >= 12) {
                            f->image_id = 745 + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        } else {
                            f->image_id = 745 + dir;
                        }
                        break;
                    case FIGURE_ENEMY_GAUL_AXEMAN:
                    case FIGURE_ENEMY_HELVETIUS_AXEMAN:
                        if (f->attack_image_offset >= 12) {
                            f->image_id = 697 + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        } else {
                            f->image_id = 697 + dir;
                        }
                        break;
                    case FIGURE_ENEMY_HUN_SWORDSMAN:
                    case FIGURE_ENEMY_GOTH_SWORDSMAN:
                    case FIGURE_ENEMY_VISIGOTH_SWORDSMAN:
                        if (f->attack_image_offset >= 12) {
                            f->image_id = 545 + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        } else {
                            f->image_id = 545 + dir;
                        }
                        break;
                    case FIGURE_ENEMY_NUMIDIAN_SWORDSMAN:
                    case FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER:
                        if (f->attack_image_offset >= 12) {
                            f->image_id = 593 + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        } else {
                            f->image_id = 593 + dir;
                        }
                        break;
                    case FIGURE_ENEMY_CAESAR_LEGIONARY:
                        if (f->attack_image_offset >= 12) {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_CAESAR_LEGIONARY] + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        } else {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_CAESAR_LEGIONARY] + dir;
                        }
                        break;
                }
                continue;
            } else if (f->is_fleeing) {
                rout_unit(f);
                continue;
            }
            if (f->in_use) {
                switch (f->type) {
                    case FIGURE_IMMIGRANT:
                    {
                        struct building_t *b = &all_buildings[f->immigrant_building_id];
                        f->cart_image_id = 0;
                        if (b->state != BUILDING_STATE_IN_USE || b->immigrant_figure_id != f->id || !b->house_size) {
                            figure_delete(f);
                            return;
                        }
                        switch (f->action_state) {
                            case FIGURE_ACTION_IMMIGRANT_CREATED:
                                f->is_invisible = 1;
                                f->wait_ticks--;
                                if (f->wait_ticks <= 0) {
                                    int x_road, y_road;
                                    if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                        f->action_state = FIGURE_ACTION_IMMIGRANT_ARRIVING;
                                        f->destination_x = x_road;
                                        f->destination_y = y_road;
                                        f->roam_length = 0;
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_IMMIGRANT_ARRIVING:
                                f->is_invisible = 0;
                                walk_ticks(f, 1, 0);
                                switch (f->direction) {
                                    case DIR_FIGURE_AT_DESTINATION:
                                        f->action_state = FIGURE_ACTION_IMMIGRANT_ENTERING_HOUSE;
                                        figure_movement_set_cross_country_destination(f, b->x, b->y);
                                        f->roam_length = 0;
                                        break;
                                    case DIR_FIGURE_REROUTE:
                                        figure_route_remove(f);
                                        break;
                                    case DIR_FIGURE_LOST:
                                        b->immigrant_figure_id = 0;
                                        figure_delete(f);
                                        return;
                                }
                                break;
                            case FIGURE_ACTION_IMMIGRANT_ENTERING_HOUSE:
                                f->use_cross_country = 1;
                                f->is_invisible = 1;
                                if (figure_movement_move_ticks_cross_country(f, 1) == 1) {
                                    int max_people = house_properties[b->subtype.house_level].max_people;
                                    if (b->house_is_merged) {
                                        max_people *= 4;
                                    }
                                    int room = max_people - b->house_population;
                                    if (room < 0) {
                                        room = 0;
                                    }
                                    if (room < f->migrant_num_people) {
                                        f->migrant_num_people = room;
                                    }
                                    if (!b->house_population) {
                                        building_house_change_to(b, BUILDING_HOUSE_SMALL_TENT);
                                    }
                                    b->house_population += f->migrant_num_people;
                                    b->house_population_room = max_people - b->house_population;
                                    city_data.population.last_change = f->migrant_num_people;
                                    add_to_census(f->migrant_num_people);
                                    recalculate_population();
                                    b->immigrant_figure_id = 0;
                                    figure_delete(f);
                                    return;
                                }
                                f->is_invisible = f->in_building_wait_ticks ? 1 : 0;
                                break;
                        }
                        update_migrant_dir_and_image(f);
                    }
                    break;
                    case FIGURE_EMIGRANT:
                        f->cart_image_id = 0;
                        switch (f->action_state) {
                            case FIGURE_ACTION_EMIGRANT_CREATED:
                                f->is_invisible = 1;
                                f->wait_ticks++;
                                if (f->wait_ticks >= 5) {
                                    int x_road, y_road;
                                    if (!map_closest_road_within_radius(f->x, f->y, 1, 5, &x_road, &y_road)) {
                                        figure_delete(f);
                                        return;
                                    }
                                    f->action_state = FIGURE_ACTION_EMIGRANT_EXITING_HOUSE;
                                    figure_movement_set_cross_country_destination(f, x_road, y_road);
                                    f->roam_length = 0;
                                }
                                break;
                            case FIGURE_ACTION_EMIGRANT_EXITING_HOUSE:
                                f->use_cross_country = 1;
                                f->is_invisible = 1;
                                if (figure_movement_move_ticks_cross_country(f, 1) == 1) {
                                    f->action_state = FIGURE_ACTION_EMIGRANT_LEAVING;
                                    f->destination_x = scenario.entry_point.x;
                                    f->destination_y = scenario.entry_point.y;
                                    f->roam_length = 0;
                                    f->progress_on_tile = 15;
                                }
                                f->is_invisible = f->in_building_wait_ticks ? 1 : 0;
                                break;
                            case FIGURE_ACTION_EMIGRANT_LEAVING:
                                f->use_cross_country = 0;
                                f->is_invisible = 0;
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION ||
                                    f->direction == DIR_FIGURE_REROUTE ||
                                    f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                        }
                        update_migrant_dir_and_image(f);
                        break;
                    case FIGURE_HOMELESS:
                        switch (f->action_state) {
                            case FIGURE_ACTION_HOMELESS_CREATED:
                                f->image_offset = 0;
                                f->wait_ticks++;
                                if (f->wait_ticks > 51) {
                                    int building_id = closest_house_with_room(f->x, f->y);
                                    if (building_id) {
                                        struct building_t *b = &all_buildings[building_id];
                                        int x_road, y_road;
                                        if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                            b->immigrant_figure_id = f->id;
                                            f->immigrant_building_id = building_id;
                                            f->action_state = FIGURE_ACTION_HOMELESS_GOING_TO_HOUSE;
                                            f->destination_x = x_road;
                                            f->destination_y = y_road;
                                            f->roam_length = 0;
                                        } else {
                                            figure_delete(f);
                                            return;
                                        }
                                    } else {
                                        f->action_state = FIGURE_ACTION_HOMELESS_LEAVING;
                                        f->destination_x = scenario.exit_point.x;
                                        f->destination_y = scenario.exit_point.y;
                                        f->roam_length = 0;
                                        f->wait_ticks = 0;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_HOMELESS_GOING_TO_HOUSE:
                                f->is_invisible = 0;
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                    all_buildings[f->immigrant_building_id].immigrant_figure_id = 0;
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    struct building_t *b = &all_buildings[f->immigrant_building_id];
                                    f->action_state = FIGURE_ACTION_HOMELESS_ENTERING_HOUSE;
                                    figure_movement_set_cross_country_destination(f, b->x, b->y);
                                    f->roam_length = 0;
                                }
                                break;
                            case FIGURE_ACTION_HOMELESS_ENTERING_HOUSE:
                                f->use_cross_country = 1;
                                f->is_invisible = 1;
                                if (figure_movement_move_ticks_cross_country(f, 1) == 1) {
                                    struct building_t *b = &all_buildings[f->immigrant_building_id];
                                    if (f->immigrant_building_id && building_is_house(b->type)) {
                                        int max_people = house_properties[b->subtype.house_level].max_people;
                                        if (b->house_is_merged) {
                                            max_people *= 4;
                                        }
                                        int room = max_people - b->house_population;
                                        if (room < 0) {
                                            room = 0;
                                        }
                                        if (room < f->migrant_num_people) {
                                            f->migrant_num_people = room;
                                        }
                                        if (!b->house_population) {
                                            building_house_change_to(b, BUILDING_HOUSE_SMALL_TENT);
                                        }
                                        b->house_population += f->migrant_num_people;
                                        b->house_population_room = max_people - b->house_population;
                                        city_data.population.lost_homeless -= f->migrant_num_people;
                                        add_to_census(f->migrant_num_people);
                                        recalculate_population();
                                        b->immigrant_figure_id = 0;
                                    }
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_HOMELESS_LEAVING:
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                }
                                f->wait_ticks++;
                                if (f->wait_ticks > 30) {
                                    f->wait_ticks = 0;
                                    int building_id = closest_house_with_room(f->x, f->y);
                                    if (building_id > 0) {
                                        struct building_t *b = &all_buildings[building_id];
                                        int x_road, y_road;
                                        if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                            b->immigrant_figure_id = f->id;
                                            f->immigrant_building_id = building_id;
                                            f->action_state = FIGURE_ACTION_HOMELESS_GOING_TO_HOUSE;
                                            f->destination_x = x_road;
                                            f->destination_y = y_road;
                                            f->roam_length = 0;
                                            figure_route_remove(f);
                                        }
                                    }
                                }
                                break;
                        }
                        figure_image_increase_offset(f, 12);
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_HOMELESS] + figure_image_direction(f) + 8 * f->image_offset;
                        break;
                    case FIGURE_PATRICIAN:
                        if (all_buildings[f->building_id].state != BUILDING_STATE_IN_USE) {
                            figure_delete(f);
                            return;
                        }
                        roamer_action(f, 1);
                        figure_image_increase_offset(f, 12);
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_PATRICIAN] + figure_image_direction(f) + 8 * f->image_offset;
                        break;
                    case FIGURE_CART_PUSHER:
                    {
                        f->cart_image_id = 0;
                        int road_network_id = network.items[f->grid_offset];
                        struct building_t *b = &all_buildings[f->building_id];

                        switch (f->action_state) {
                            case FIGURE_ACTION_CARTPUSHER_INITIAL:
                                set_cart_graphic(f);
                                if (!map_routing_citizen_is_passable(f->grid_offset)) {
                                    figure_delete(f);
                                    return;
                                }
                                if (b->state != BUILDING_STATE_IN_USE || b->figure_id != f->id) {
                                    figure_delete(f);
                                    return;
                                }
                                f->wait_ticks++;
                                if (f->wait_ticks > 30) {
                                    struct map_point_t dst;
                                    int understaffed_storages = 0;
                                    // priority 1: warehouse if resource is on stockpile
                                    int dst_building_id = building_warehouse_for_storing(0, f->x, f->y,
                                        b->output_resource_id, road_network_id,
                                        &understaffed_storages, &dst);
                                    if (!city_data.resource.stockpiled[b->output_resource_id]) {
                                        dst_building_id = 0;
                                    }
                                    if (dst_building_id) {
                                        set_destination(f, FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_WAREHOUSE, dst_building_id, dst.x, dst.y);
                                    } else {
                                        // priority 2: accepting granary for food
                                        dst_building_id = building_granary_for_storing(f->x, f->y,
                                            b->output_resource_id, road_network_id, 0,
                                            &understaffed_storages, &dst);
                                        if (dst_building_id) {
                                            set_destination(f, FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_GRANARY, dst_building_id, dst.x, dst.y);
                                        } else {
                                            // priority 3: workshop for raw material
                                            dst_building_id = building_get_workshop_for_raw_material_with_room(f->x, f->y, b->output_resource_id, road_network_id, &dst);
                                            if (dst_building_id) {
                                                set_destination(f, FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_WORKSHOP, dst_building_id, dst.x, dst.y);
                                            } else {
                                                // priority 4: warehouse
                                                dst_building_id = building_warehouse_for_storing(0, f->x, f->y,
                                                    b->output_resource_id, road_network_id,
                                                    &understaffed_storages, &dst);
                                                if (dst_building_id) {
                                                    set_destination(f, FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_WAREHOUSE, dst_building_id, dst.x, dst.y);
                                                } else {
                                                    // priority 5: granary forced when on stockpile
                                                    dst_building_id = building_granary_for_storing(f->x, f->y,
                                                        b->output_resource_id, road_network_id, 1,
                                                        &understaffed_storages, &dst);
                                                    if (dst_building_id) {
                                                        set_destination(f, FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_GRANARY, dst_building_id, dst.x, dst.y);
                                                    } else {
                                                        // no one will accept
                                                        f->wait_ticks = 0;
                                                        // set cartpusher text
                                                        f->min_max_seen = understaffed_storages ? 2 : 1;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_WAREHOUSE:
                                set_cart_graphic(f);
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_CARTPUSHER_AT_WAREHOUSE;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    reroute_cartpusher(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                if (all_buildings[f->destination_building_id].state != BUILDING_STATE_IN_USE) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_GRANARY:
                                set_cart_graphic(f);
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_CARTPUSHER_AT_GRANARY;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    reroute_cartpusher(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    f->action_state = FIGURE_ACTION_CARTPUSHER_INITIAL;
                                    f->wait_ticks = 0;
                                }
                                if (all_buildings[f->destination_building_id].state != BUILDING_STATE_IN_USE) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_WORKSHOP:
                                set_cart_graphic(f);
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_CARTPUSHER_AT_WORKSHOP;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    reroute_cartpusher(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_CARTPUSHER_AT_WAREHOUSE:
                                f->wait_ticks++;
                                if (f->wait_ticks > 10) {
                                    if (building_warehouse_add_resource(&all_buildings[f->destination_building_id], f->resource_id)) {
                                        f->action_state = FIGURE_ACTION_CARTPUSHER_RETURNING;
                                        f->wait_ticks = 0;
                                        f->destination_x = f->source_x;
                                        f->destination_y = f->source_y;
                                    } else {
                                        figure_route_remove(f);
                                        f->action_state = FIGURE_ACTION_CARTPUSHER_INITIAL;
                                        f->wait_ticks = 0;
                                    }
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_CARTPUSHER_AT_GRANARY:
                                f->wait_ticks++;
                                if (f->wait_ticks > 5) {
                                    if (building_granary_add_resource(&all_buildings[f->destination_building_id], f->resource_id, 1)) {
                                        f->action_state = FIGURE_ACTION_CARTPUSHER_RETURNING;
                                        f->wait_ticks = 0;
                                        f->destination_x = f->source_x;
                                        f->destination_y = f->source_y;
                                    } else {
                                        b = &all_buildings[f->building_id];
                                        struct map_point_t dst;
                                        // priority 1: accepting granary for food
                                        int dst_building_id = building_granary_for_storing(f->x, f->y,
                                            b->output_resource_id, road_network_id, 0,
                                            0, &dst);
                                        if (dst_building_id) {
                                            set_destination(f, FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_GRANARY, dst_building_id, dst.x, dst.y);
                                        } else {
                                            // priority 2: warehouse
                                            dst_building_id = building_warehouse_for_storing(0, f->x, f->y,
                                                b->output_resource_id, road_network_id,
                                                0, &dst);
                                            if (dst_building_id) {
                                                set_destination(f, FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_WAREHOUSE, dst_building_id, dst.x, dst.y);
                                            } else {
                                                // priority 3: granary
                                                dst_building_id = building_granary_for_storing(f->x, f->y,
                                                    b->output_resource_id, road_network_id, 1,
                                                    0, &dst);
                                                if (dst_building_id) {
                                                    set_destination(f, FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_GRANARY, dst_building_id, dst.x, dst.y);
                                                } else {
                                                    // no one will accept, stand idle
                                                    f->wait_ticks = 0;
                                                }
                                            }
                                        }
                                    }
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_CARTPUSHER_AT_WORKSHOP:
                                f->wait_ticks++;
                                if (f->wait_ticks > 5) {
                                    building_workshop_add_raw_material(&all_buildings[f->destination_building_id]);
                                    f->action_state = FIGURE_ACTION_CARTPUSHER_RETURNING;
                                    f->wait_ticks = 0;
                                    f->destination_x = f->source_x;
                                    f->destination_y = f->source_y;
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_CARTPUSHER_RETURNING:
                                f->cart_image_id = EMPTY_CART_IMG_ID;
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                        }
                        figure_image_increase_offset(f, 12);
                        update_image_cartpusher(f);
                    }
                    break;
                    case FIGURE_LABOR_SEEKER:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        if (b->state != BUILDING_STATE_IN_USE || b->figure_id2 != f->id) {
                            figure_delete(f);
                            return;
                        }
                        roamer_action(f, 1);
                        figure_image_increase_offset(f, 12);
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_LABOR_SEEKER] + figure_image_direction(f) + 8 * f->image_offset;
                    }
                    break;
                    case FIGURE_BARBER:
                        culture_action(f, GROUP_FIGURE_BARBER);
                        break;
                    case FIGURE_BATHHOUSE_WORKER:
                        culture_action(f, GROUP_FIGURE_BATHHOUSE_WORKER);
                        break;
                    case FIGURE_DOCTOR:
                    case FIGURE_SURGEON:
                        culture_action(f, GROUP_FIGURE_DOCTOR_SURGEON);
                        break;
                    case FIGURE_PRIEST:
                        culture_action(f, GROUP_FIGURE_PRIEST);
                        break;
                    case FIGURE_SCHOOL_CHILD:\
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_SCHOOL) {
                            figure_delete(f);
                            return;
                        }
                        figure_image_increase_offset(f, 12);
                        switch (f->action_state) {
                            case FIGURE_ACTION_ROAMING:
                                f->is_invisible = 0;
                                f->roam_length++;
                                if (f->roam_length >= figure_properties[f->type].max_roam_length) {
                                    figure_delete(f);
                                    return;
                                }
                                figure_movement_roam_ticks(f, 2);
                                break;
                        }
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_SCHOOL_CHILD] + figure_image_direction(f) + 8 * f->image_offset;
                        break;
                    }
                    case FIGURE_TEACHER:
                        culture_action(f, GROUP_FIGURE_TEACHER_LIBRARIAN);
                        break;
                    case FIGURE_LIBRARIAN:
                        culture_action(f, GROUP_FIGURE_TEACHER_LIBRARIAN);
                        break;
                    case FIGURE_MISSIONARY:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        if (b->state != BUILDING_STATE_IN_USE || b->figure_id != f->id) {
                            figure_delete(f);
                            return;
                        }
                        roamer_action(f, 1);
                        figure_image_increase_offset(f, 12);
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_MISSIONARY] + figure_image_direction(f) + 8 * f->image_offset;
                        break;
                    }
                    case FIGURE_ACTOR:
                    case FIGURE_GLADIATOR:
                    case FIGURE_LION_TAMER:
                    case FIGURE_CHARIOTEER:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        f->cart_image_id = EMPTY_CART_IMG_ID;
                        f->use_cross_country = 0;
                        figure_image_increase_offset(f, 12);
                        f->wait_ticks_missile++;
                        if (f->wait_ticks_missile >= 120) {
                            f->wait_ticks_missile = 0;
                        }
                        if (scenario.gladiator_revolt.state == EVENT_IN_PROGRESS && f->type == FIGURE_GLADIATOR) {
                            if (f->action_state == FIGURE_ACTION_ENTERTAINER_GOING_TO_VENUE ||
                                f->action_state == FIGURE_ACTION_ENTERTAINER_ROAMING ||
                                f->action_state == FIGURE_ACTION_ENTERTAINER_RETURNING) {
                                f->type = FIGURE_ENEMY_GLADIATOR;
                                figure_route_remove(f);
                                f->roam_length = 0;
                                f->action_state = FIGURE_ACTION_NATIVE_CREATED;
                                f->is_targetable = 1;
                                f->terrain_usage = TERRAIN_USAGE_ANY;
                                return;
                            }
                        }
                        int speed_factor = f->type == FIGURE_CHARIOTEER ? 2 : 1;
                        switch (f->action_state) {
                            case FIGURE_ACTION_ENTERTAINER_AT_SCHOOL_CREATED:
                                f->is_invisible = 1;
                                f->image_offset = 0;
                                f->wait_ticks_missile = 0;
                                f->wait_ticks--;
                                if (f->wait_ticks <= 0) {
                                    int x_road, y_road;
                                    if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                        f->action_state = FIGURE_ACTION_ENTERTAINER_EXITING_SCHOOL;
                                        figure_movement_set_cross_country_destination(f, x_road, y_road);
                                        f->roam_length = 0;
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_ENTERTAINER_EXITING_SCHOOL:
                                f->use_cross_country = 1;
                                f->is_invisible = 1;
                                if (figure_movement_move_ticks_cross_country(f, 1) == 1) {
                                    int dst_building_id = 0;
                                    switch (f->type) {
                                        case FIGURE_ACTOR:
                                            dst_building_id = determine_destination(f->x, f->y, BUILDING_THEATER, BUILDING_AMPHITHEATER);
                                            break;
                                        case FIGURE_GLADIATOR:
                                            dst_building_id = determine_destination(f->x, f->y, BUILDING_AMPHITHEATER, BUILDING_COLOSSEUM);
                                            break;
                                        case FIGURE_LION_TAMER:
                                            dst_building_id = determine_destination(f->x, f->y, BUILDING_COLOSSEUM, 0);
                                            break;
                                        case FIGURE_CHARIOTEER:
                                            dst_building_id = determine_destination(f->x, f->y, BUILDING_HIPPODROME, 0);
                                            break;
                                    }
                                    if (dst_building_id) {
                                        struct building_t *b_dst = &all_buildings[dst_building_id];
                                        int x_road, y_road;
                                        if (map_closest_road_within_radius(b_dst->x, b_dst->y, b_dst->size, 2, &x_road, &y_road)) {
                                            f->destination_building_id = dst_building_id;
                                            f->action_state = FIGURE_ACTION_ENTERTAINER_GOING_TO_VENUE;
                                            f->destination_x = x_road;
                                            f->destination_y = y_road;
                                            f->roam_length = 0;
                                        } else {
                                            figure_delete(f);
                                            return;
                                        }
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                f->is_invisible = 1;
                                break;
                            case FIGURE_ACTION_ENTERTAINER_GOING_TO_VENUE:
                            {
                                f->is_invisible = 0;
                                f->roam_length++;
                                if (f->roam_length >= 3200) {
                                    figure_delete(f);
                                    return;
                                }
                                walk_ticks(f, speed_factor, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    b = &all_buildings[f->destination_building_id];
                                    if (b->type >= BUILDING_AMPHITHEATER && b->type <= BUILDING_COLOSSEUM) {
                                        switch (f->type) {
                                            case FIGURE_ACTOR:
                                                b->data.entertainment.play++;
                                                if (b->data.entertainment.play >= 5) {
                                                    b->data.entertainment.play = 0;
                                                }
                                                if (b->type == BUILDING_THEATER) {
                                                    b->data.entertainment.days1 = 32;
                                                } else {
                                                    b->data.entertainment.days2 = 32;
                                                }
                                                break;
                                            case FIGURE_GLADIATOR:
                                                if (b->type == BUILDING_AMPHITHEATER) {
                                                    b->data.entertainment.days1 = 32;
                                                } else {
                                                    b->data.entertainment.days2 = 32;
                                                }
                                                break;
                                            case FIGURE_LION_TAMER:
                                            case FIGURE_CHARIOTEER:
                                                b->data.entertainment.days1 = 32;
                                                break;
                                        }
                                    }
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            }
                            case FIGURE_ACTION_ENTERTAINER_ROAMING:
                                f->is_invisible = 0;
                                f->roam_length++;
                                if (f->roam_length >= figure_properties[f->type].max_roam_length) {
                                    int x_road, y_road;
                                    if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                        f->action_state = FIGURE_ACTION_ENTERTAINER_RETURNING;
                                        f->destination_x = x_road;
                                        f->destination_y = y_road;
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                figure_movement_roam_ticks(f, speed_factor);
                                break;
                            case FIGURE_ACTION_ENTERTAINER_RETURNING:
                                walk_ticks(f, speed_factor, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION ||
                                    f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                        }
                        int dir = figure_image_normalize_direction(f->direction < 8 ? f->direction : f->previous_tile_direction);
                        if (f->type == FIGURE_CHARIOTEER) {
                            f->cart_image_id = 0;
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_CHARIOTEER] + dir + 8 * f->image_offset;
                            return;
                        }
                        int image_id;
                        if (f->type == FIGURE_ACTOR) {
                            image_id = image_data_s.group_image_ids[GROUP_FIGURE_ACTOR];
                        } else if (f->type == FIGURE_GLADIATOR) {
                            image_id = image_data_s.group_image_ids[GROUP_FIGURE_GLADIATOR];
                        } else if (f->type == FIGURE_LION_TAMER) {
                            image_id = image_data_s.group_image_ids[GROUP_FIGURE_LION_TAMER];
                            if (f->wait_ticks_missile >= 96) {
                                image_id = image_data_s.group_image_ids[GROUP_FIGURE_LION_TAMER_WHIP];
                            }
                            f->cart_image_id = image_data_s.group_image_ids[GROUP_FIGURE_LION];
                        } else {
                            return;
                        }
                        f->image_id = image_id + dir + 8 * f->image_offset;
                        if (f->cart_image_id) {
                            f->cart_image_id += dir + 8 * f->image_offset;
                            figure_image_set_cart_offset(f, dir);
                        }
                        break;
                    }
                    case FIGURE_HIPPODROME_HORSES:
                    {
                        city_data.entertainment.hippodrome_has_race = 1;
                        f->use_cross_country = 1;
                        figure_image_increase_offset(f, 8);
                        switch (f->action_state) {
                            case FIGURE_ACTION_HIPPODROME_HORSE_CREATED:
                                f->image_offset = 0;
                                f->wait_ticks_missile = 0;
                                set_horse_destination(f, HORSE_CREATED);
                                f->wait_ticks++;
                                if (f->wait_ticks > 60 && f->resource_id == 0) {
                                    f->action_state = FIGURE_ACTION_HIPPODROME_HORSE_RACING;
                                    f->wait_ticks = 0;
                                }
                                f->wait_ticks++;
                                if (f->wait_ticks > 20 && f->resource_id == 1) {
                                    f->action_state = FIGURE_ACTION_HIPPODROME_HORSE_RACING;
                                    f->wait_ticks = 0;
                                }
                                break;
                            case FIGURE_ACTION_HIPPODROME_HORSE_RACING:
                                f->direction = calc_general_direction(f->x, f->y, f->destination_x, f->destination_y);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->wait_ticks_missile++;
                                    if (f->wait_ticks_missile >= 22) {
                                        f->wait_ticks_missile = 0;
                                        f->leading_figure_id++;
                                        if (f->leading_figure_id >= 6) {
                                            f->wait_ticks = 0;
                                            f->action_state = FIGURE_ACTION_HIPPODROME_HORSE_DONE;
                                        }
                                        if ((f->id + random_data.random1_7bit) & 1) {
                                            f->speed_multiplier = 3;
                                        } else {
                                            f->speed_multiplier = 4;
                                        }
                                    } else if (f->wait_ticks_missile == 11) {
                                        if ((f->id + random_data.random1_7bit) & 1) {
                                            f->speed_multiplier = 3;
                                        } else {
                                            f->speed_multiplier = 4;
                                        }
                                    }
                                    set_horse_destination(f, HORSE_RACING);
                                    f->direction = calc_general_direction(f->x, f->y, f->destination_x, f->destination_y);
                                    figure_movement_set_cross_country_direction(f,
                                        f->cross_country_x, f->cross_country_y, 15 * f->destination_x, 15 * f->destination_y, 0);
                                }
                                if (f->action_state != FIGURE_ACTION_HIPPODROME_HORSE_DONE) {
                                    figure_movement_move_ticks_cross_country(f, f->speed_multiplier);
                                }
                                break;
                            case FIGURE_ACTION_HIPPODROME_HORSE_DONE:
                                if (!f->wait_ticks) {
                                    set_horse_destination(f, HORSE_FINISHED);
                                    f->direction = calc_general_direction(f->x, f->y, f->destination_x, f->destination_y);
                                    figure_movement_set_cross_country_direction(f,
                                        f->cross_country_x, f->cross_country_y, 15 * f->destination_x, 15 * f->destination_y, 0);
                                }
                                if (f->direction != DIR_FIGURE_AT_DESTINATION) {
                                    figure_movement_move_ticks_cross_country(f, 1);
                                }
                                f->wait_ticks++;
                                if (f->wait_ticks > 30) {
                                    f->image_offset = 0;
                                }
                                f->wait_ticks++;
                                if (f->wait_ticks > 150) {
                                    figure_delete(f);
                                    break;
                                }
                                break;
                        }
                        int dir = figure_image_direction(f);
                        if (f->resource_id == 0) {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_HIPPODROME_HORSE_1] + dir + 8 * f->image_offset;
                            f->cart_image_id = image_data_s.group_image_ids[GROUP_FIGURE_HIPPODROME_CART_1] + dir;
                        } else {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_HIPPODROME_HORSE_2] + dir + 8 * f->image_offset;
                            f->cart_image_id = image_data_s.group_image_ids[GROUP_FIGURE_HIPPODROME_CART_2] + dir;
                        }
                        int cart_dir = (dir + 4) % 8;
                        figure_image_set_cart_offset(f, cart_dir);
                    }
                    break;
                    case FIGURE_TAX_COLLECTOR:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        f->use_cross_country = 0;
                        if (b->state != BUILDING_STATE_IN_USE || b->figure_id != f->id) {
                            figure_delete(f);
                            return;
                        }
                        switch (f->action_state) {
                            case FIGURE_ACTION_TAX_COLLECTOR_CREATED:
                                f->is_invisible = 1;
                                f->image_offset = 0;
                                f->wait_ticks--;
                                if (f->wait_ticks <= 0) {
                                    int x_road, y_road;
                                    if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                        f->action_state = FIGURE_ACTION_TAX_COLLECTOR_ENTERING_EXITING;
                                        figure_movement_set_cross_country_destination(f, x_road, y_road);
                                        f->roam_length = 0;
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_TAX_COLLECTOR_ENTERING_EXITING:
                                f->use_cross_country = 1;
                                f->is_invisible = 1;
                                if (figure_movement_move_ticks_cross_country(f, 1) == 1) {
                                    if (map_building_at(f->grid_offset) == f->building_id) {
                                        // returned to own building
                                        figure_delete(f);
                                        return;
                                    } else {
                                        f->action_state = FIGURE_ACTION_TAX_COLLECTOR_ROAMING;
                                        figure_movement_init_roaming(f);
                                        f->roam_length = 0;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_TAX_COLLECTOR_ROAMING:
                                f->is_invisible = 0;
                                f->roam_length++;
                                if (f->roam_length >= figure_properties[f->type].max_roam_length) {
                                    int x_road, y_road;
                                    if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                        f->action_state = FIGURE_ACTION_TAX_COLLECTOR_RETURNING;
                                        f->destination_x = x_road;
                                        f->destination_y = y_road;
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                figure_movement_roam_ticks(f, 1);
                                break;
                            case FIGURE_ACTION_TAX_COLLECTOR_RETURNING:
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_TAX_COLLECTOR_ENTERING_EXITING;
                                    figure_movement_set_cross_country_destination(f, b->x, b->y);
                                    f->roam_length = 0;
                                } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                        }
                        figure_image_increase_offset(f, 12);
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_TAX_COLLECTOR] + figure_image_direction(f) + 8 * f->image_offset;
                        break;
                    }
                    case FIGURE_ENGINEER:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        f->use_cross_country = 0;
                        if (b->state != BUILDING_STATE_IN_USE || b->figure_id != f->id) {
                            figure_delete(f);
                            return;
                        }
                        figure_image_increase_offset(f, 12);
                        switch (f->action_state) {
                            case FIGURE_ACTION_ENGINEER_CREATED:
                                f->is_invisible = 1;
                                f->image_offset = 0;
                                f->wait_ticks--;
                                if (f->wait_ticks <= 0) {
                                    int x_road, y_road;
                                    if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                        f->action_state = FIGURE_ACTION_ENGINEER_ENTERING_EXITING;
                                        figure_movement_set_cross_country_destination(f, x_road, y_road);
                                        f->roam_length = 0;
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_ENGINEER_ENTERING_EXITING:
                                f->use_cross_country = 1;
                                f->is_invisible = 1;
                                if (figure_movement_move_ticks_cross_country(f, 1) == 1) {
                                    if (map_building_at(f->grid_offset) == f->building_id) {
                                        // returned to own building
                                        figure_delete(f);
                                        return;
                                    } else {
                                        f->action_state = FIGURE_ACTION_ENGINEER_ROAMING;
                                        figure_movement_init_roaming(f);
                                        f->roam_length = 0;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_ENGINEER_ROAMING:
                                f->is_invisible = 0;
                                f->roam_length++;
                                if (f->roam_length >= figure_properties[f->type].max_roam_length) {
                                    int x_road, y_road;
                                    if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                        f->action_state = FIGURE_ACTION_ENGINEER_RETURNING;
                                        f->destination_x = x_road;
                                        f->destination_y = y_road;
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                figure_movement_roam_ticks(f, 1);
                                break;
                            case FIGURE_ACTION_ENGINEER_RETURNING:
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_ENGINEER_ENTERING_EXITING;
                                    figure_movement_set_cross_country_destination(f, b->x, b->y);
                                    f->roam_length = 0;
                                } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                        }
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_ENGINEER] + figure_image_direction(f) + 8 * f->image_offset;
                    }
                    break;
                    case FIGURE_FISHING_BOAT:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        if (b->state != BUILDING_STATE_IN_USE) {
                            figure_delete(f);
                            return;
                        }
                        if (f->action_state != FIGURE_ACTION_FISHING_BOAT_CREATED && b->data.industry.fishing_boat_id != f->id) {
                            struct map_point_t tile;
                            b = &all_buildings[map_water_get_wharf_for_new_fishing_boat(f, &tile)];
                            if (b->id) {
                                f->building_id = b->id;
                                b->data.industry.fishing_boat_id = f->id;
                                f->action_state = FIGURE_ACTION_FISHING_BOAT_GOING_TO_WHARF;
                                f->destination_x = tile.x;
                                f->destination_y = tile.y;
                                f->source_x = tile.x;
                                f->source_y = tile.y;
                                figure_route_remove(f);
                            } else {
                                figure_delete(f);
                                return;
                            }
                        }
                        figure_image_increase_offset(f, 12);
                        f->cart_image_id = 0;
                        switch (f->action_state) {
                            case FIGURE_ACTION_FISHING_BOAT_CREATED:
                                f->wait_ticks++;
                                if (f->wait_ticks >= 50) {
                                    f->wait_ticks = 0;
                                    struct map_point_t tile;
                                    int wharf_id = map_water_get_wharf_for_new_fishing_boat(f, &tile);
                                    if (wharf_id) {
                                        b->figure_id = 0; // remove from original building
                                        f->building_id = wharf_id;
                                        all_buildings[wharf_id].data.industry.fishing_boat_id = f->id;
                                        f->action_state = FIGURE_ACTION_FISHING_BOAT_GOING_TO_WHARF;
                                        f->destination_x = tile.x;
                                        f->destination_y = tile.y;
                                        f->source_x = tile.x;
                                        f->source_y = tile.y;
                                        figure_route_remove(f);
                                    }
                                }
                                break;
                            case FIGURE_ACTION_FISHING_BOAT_GOING_TO_FISH:
                                walk_ticks(f, 1, 0);
                                f->height_adjusted_ticks = 0;
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    struct map_point_t tile = { 0 };

                                    if (map_grid_is_valid_offset(f->grid_offset) ? map_figures.items[f->grid_offset] : 0 != f->id) {
                                        for (int radius = 1; radius <= 5; radius++) {
                                            int x_min, y_min, x_max, y_max;
                                            map_grid_get_area(f->x, f->y, 1, radius, &x_min, &y_min, &x_max, &y_max);
                                            for (int yy = y_min; yy <= y_max; yy++) {
                                                for (int xx = x_min; xx <= x_max; xx++) {
                                                    int grid_offset = map_grid_offset(xx, yy);
                                                    if (!(map_grid_is_valid_offset(grid_offset) && map_figures.items[grid_offset] > 0) && map_terrain_is(grid_offset, TERRAIN_WATER)) {
                                                        tile.x = xx;
                                                        tile.y = yy;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if (tile.x) {
                                        figure_route_remove(f);
                                        f->destination_x = tile.x;
                                        f->destination_y = tile.y;
                                        f->direction = f->previous_tile_direction;
                                    } else {
                                        f->action_state = FIGURE_ACTION_FISHING_BOAT_FISHING;
                                        f->wait_ticks = 0;
                                    }
                                } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                    f->action_state = FIGURE_ACTION_FISHING_BOAT_AT_WHARF;
                                    f->destination_x = f->source_x;
                                    f->destination_y = f->source_y;
                                }
                                break;
                            case FIGURE_ACTION_FISHING_BOAT_FISHING:
                                f->wait_ticks++;
                                if (f->wait_ticks >= 200) {
                                    f->wait_ticks = 0;
                                    f->action_state = FIGURE_ACTION_FISHING_BOAT_RETURNING_WITH_FISH;
                                    f->destination_x = f->source_x;
                                    f->destination_y = f->source_y;
                                    figure_route_remove(f);
                                }
                                break;
                            case FIGURE_ACTION_FISHING_BOAT_GOING_TO_WHARF:
                                walk_ticks(f, 1, 0);
                                f->height_adjusted_ticks = 0;
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_FISHING_BOAT_AT_WHARF;
                                    f->wait_ticks = 0;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    // cannot reach grounds
                                    city_message_post_with_message_delay(MESSAGE_CAT_FISHING_BLOCKED, 1, MESSAGE_FISHING_BOAT_BLOCKED, 12);
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_FISHING_BOAT_AT_WHARF:
                            {
                                int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                int max_wait_ticks = 5 * (102 - pct_workers);
                                if (b->data.industry.has_fish > 0) {
                                    pct_workers = 0;
                                }
                                if (pct_workers > 0) {
                                    f->wait_ticks++;
                                    if (f->wait_ticks >= max_wait_ticks) {
                                        f->wait_ticks = 0;
                                        struct map_point_t tile;
                                        int num_fishing_spots = 0;
                                        for (int k = 0; k < MAX_FISH_POINTS; k++) {
                                            if (scenario.fishing_points[k].x > 0) {
                                                num_fishing_spots++;
                                            }
                                        }
                                        if (num_fishing_spots) {
                                            int min_dist = 10000;
                                            int min_fish_id = 0;
                                            for (int k = 0; k < MAX_FISH_POINTS; k++) {
                                                if (scenario.fishing_points[k].x > 0) {
                                                    int dist = calc_maximum_distance(f->x, f->y, scenario.fishing_points[k].x, scenario.fishing_points[k].y);
                                                    if (dist < min_dist) {
                                                        min_dist = dist;
                                                        min_fish_id = k;
                                                    }
                                                }
                                            }
                                            if (min_dist < 10000) {
                                                tile.x = scenario.fishing_points[min_fish_id].x;
                                                tile.y = scenario.fishing_points[min_fish_id].y;
                                                f->action_state = FIGURE_ACTION_FISHING_BOAT_GOING_TO_FISH;
                                                f->destination_x = tile.x;
                                                f->destination_y = tile.y;
                                                figure_route_remove(f);
                                            }
                                        }
                                    }
                                }
                            }
                            break;
                            case FIGURE_ACTION_FISHING_BOAT_RETURNING_WITH_FISH:
                                walk_ticks(f, 1, 0);
                                f->height_adjusted_ticks = 0;
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_FISHING_BOAT_AT_WHARF;
                                    f->wait_ticks = 0;
                                    b->figure_spawn_delay = 1;
                                    b->data.industry.has_fish++;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                        }
                        int dir = figure_image_normalize_direction(f->direction < 8 ? f->direction : f->previous_tile_direction);
                        if (f->action_state == FIGURE_ACTION_FISHING_BOAT_FISHING) {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_SHIP] + dir + 16;
                        } else {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_SHIP] + dir + 8;
                        }
                        break;
                    }
                    case FIGURE_FISH_GULLS:
                    {
                        f->use_cross_country = 1;
                        if (!(f->image_offset & 3) && figure_movement_move_ticks_cross_country(f, 1)) {
                            f->progress_on_tile++;
                            if (f->progress_on_tile > 8) {
                                f->progress_on_tile = 0;
                            }
                            figure_movement_set_cross_country_destination(f,
                                f->source_x + SEAGULL_OFFSETS[f->progress_on_tile].x,
                                f->source_y + SEAGULL_OFFSETS[f->progress_on_tile].y);
                        }
                        if (f->id & 1) {
                            figure_image_increase_offset(f, 54);
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_SEAGULLS] + f->image_offset / 3;
                        } else {
                            figure_image_increase_offset(f, 72);
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_SEAGULLS] + 18 + f->image_offset / 3;
                        }
                    }
                    break;
                    case FIGURE_SHIPWRECK:
                        figure_image_increase_offset(f, 128);
                        if (f->wait_ticks < 1000) {
                            map_figure_delete(f);
                            struct map_point_t tile = { 0 };
                            if (!(map_terrain_is(f->grid_offset, TERRAIN_WATER) && map_grid_is_valid_offset(f->grid_offset) ? map_figures.items[f->grid_offset] : 0 == f->id)) {
                                for (int radius = 1; radius <= 5; radius++) {
                                    int x_min, y_min, x_max, y_max;
                                    map_grid_get_area(f->x, f->y, 1, radius, &x_min, &y_min, &x_max, &y_max);

                                    for (int yy = y_min; yy <= y_max; yy++) {
                                        for (int xx = x_min; xx <= x_max; xx++) {
                                            int grid_offset = map_grid_offset(xx, yy);
                                            if (!(map_grid_is_valid_offset(grid_offset) && map_figures.items[grid_offset] > 0) || map_grid_is_valid_offset(grid_offset) ? map_figures.items[grid_offset] : 0 == f->id) {
                                                if (map_terrain_is(grid_offset, TERRAIN_WATER) &&
                                                    map_terrain_is(map_grid_offset(xx, yy - 2), TERRAIN_WATER) &&
                                                    map_terrain_is(map_grid_offset(xx, yy + 2), TERRAIN_WATER) &&
                                                    map_terrain_is(map_grid_offset(xx - 2, yy), TERRAIN_WATER) &&
                                                    map_terrain_is(map_grid_offset(xx + 2, yy), TERRAIN_WATER)) {
                                                    f->x = tile.x;
                                                    f->y = tile.y;
                                                    f->grid_offset = map_grid_offset(f->x, f->y);
                                                    f->cross_country_x = 15 * f->x + 7;
                                                    f->cross_country_y = 15 * f->y + 7;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            map_figure_add(f);
                            f->wait_ticks = 1000;
                        }
                        f->wait_ticks++;
                        if (f->wait_ticks > 2000) {
                            figure_delete(f);
                            return;
                        }
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_SHIPWRECK] + f->image_offset / 16;
                        break;
                    case FIGURE_DOCKER:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        figure_image_increase_offset(f, 12);
                        f->cart_image_id = 0;
                        if (b->state != BUILDING_STATE_IN_USE) {
                            figure_delete(f);
                            return;
                        }
                        if (b->type != BUILDING_DOCK && b->type != BUILDING_WHARF) {
                            figure_delete(f);
                            return;
                        }
                        if (b->data.dock.num_ships) {
                            b->data.dock.num_ships--;
                        }
                        if (b->data.dock.trade_ship_id) {
                            struct figure_t *ship = &figures[b->data.dock.trade_ship_id];
                            if (!figure_is_alive(ship) || ship->type != FIGURE_TRADE_SHIP) {
                                b->data.dock.trade_ship_id = 0;
                            } else if (figure_trader_data.traders[ship->trader_id].bought_amount >= 12 || figure_trader_data.traders[ship->trader_id].sold_amount >= 12) {
                                b->data.dock.trade_ship_id = 0;
                            } else if (ship->action_state == FIGURE_ACTION_TRADE_SHIP_LEAVING) {
                                b->data.dock.trade_ship_id = 0;
                            }
                        }
                        switch (f->action_state) {
                            case FIGURE_ACTION_DOCKER_IDLING:
                                f->resource_id = 0;
                                f->cart_image_id = 0;
                                int ship_id = b->data.dock.trade_ship_id;
                                struct figure_t *ship = &figures[ship_id];
                                int x, y;
                                get_trade_center_location(f, &x, &y);
                                struct map_point_t tile;
                                int importable[16];
                                importable[RESOURCE_NONE] = 0;
                                for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                    importable[r] = can_import_resource_from_trade_city(ship->empire_city_id, r);
                                }
                                int resource = city_trade_next_docker_import_resource();
                                for (int k = RESOURCE_WHEAT; k < RESOURCE_TYPES_MAX && !importable[resource]; k++) {
                                    resource = city_trade_next_docker_import_resource();
                                }
                                int min_building_id = 0;
                                if (importable[resource]) {
                                    int min_distance = 10000;
                                    for (int l = 1; l < MAX_BUILDINGS; l++) {
                                        b = &all_buildings[l];
                                        if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_WAREHOUSE) {
                                            continue;
                                        }
                                        if (!b->has_road_access) {
                                            continue;
                                        }
                                        struct building_storage_t *storage = &storages[b->storage_id].storage;
                                        if (storage->resource_state[resource] != BUILDING_STORAGE_STATE_NOT_ACCEPTING && !storage->empty_all) {
                                            int distance_penalty = 32;
                                            struct building_t *space = b;
                                            for (int s = 0; s < 8; s++) {
                                                space = &all_buildings[space->next_part_building_id];
                                                if (space->id && space->subtype.warehouse_resource_id == RESOURCE_NONE) {
                                                    distance_penalty -= 8;
                                                }
                                                if (space->id && space->subtype.warehouse_resource_id == resource && space->loads_stored < 4) {
                                                    distance_penalty -= 4;
                                                }
                                            }
                                            if (distance_penalty < 32) {
                                                int distance = calc_maximum_distance(
                                                    b->x, b->y, x, y);
                                                // prefer emptier warehouse
                                                distance += distance_penalty;
                                                if (distance < min_distance) {
                                                    min_distance = distance;
                                                    min_building_id = l;
                                                }
                                            }
                                        }
                                    }
                                    if (min_building_id) {
                                        struct building_t *min = &all_buildings[min_building_id];
                                        if (map_has_road_access(min->x, min->y, 3, &tile) && min->has_road_access == 1) {
                                            tile.x = min->x;
                                            tile.y = min->y;
                                        }
                                    }
                                }

                                if (!ship_id || ship->action_state != FIGURE_ACTION_TRADE_SHIP_MOORED || !ship->loads_sold_or_carrying || !min_building_id) {
                                    fetch_export_resource(f, b);
                                } else {
                                    ship->loads_sold_or_carrying--;
                                    f->destination_building_id = min_building_id;
                                    f->wait_ticks = 0;
                                    f->action_state = FIGURE_ACTION_DOCKER_IMPORT_QUEUE;
                                    f->destination_x = tile.x;
                                    f->destination_y = tile.y;
                                    f->resource_id = resource;
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_DOCKER_IMPORT_QUEUE:
                                f->cart_image_id = 0;
                                f->image_offset = 0;
                                if (b->data.dock.queued_docker_id <= 0) {
                                    b->data.dock.queued_docker_id = f->id;
                                    f->wait_ticks = 0;
                                }
                                if (b->data.dock.queued_docker_id == f->id) {
                                    b->data.dock.num_ships = 120;
                                    f->wait_ticks++;
                                    if (f->wait_ticks >= 80) {
                                        f->action_state = FIGURE_ACTION_DOCKER_IMPORT_GOING_TO_WAREHOUSE;
                                        f->wait_ticks = 0;
                                        set_cart_graphic(f);
                                        b->data.dock.queued_docker_id = 0;
                                    }
                                } else {
                                    int has_queued_docker = 0;
                                    for (int k = 0; k < 3; k++) {
                                        if (b->data.dock.docker_ids[k]) {
                                            struct figure_t *docker = &figures[b->data.dock.docker_ids[k]];
                                            if (docker->id == b->data.dock.queued_docker_id && figure_is_alive(docker)) {
                                                if (docker->action_state == FIGURE_ACTION_DOCKER_IMPORT_QUEUE ||
                                                    docker->action_state == FIGURE_ACTION_DOCKER_EXPORT_QUEUE) {
                                                    has_queued_docker = 1;
                                                }
                                            }
                                        }
                                    }
                                    if (!has_queued_docker) {
                                        b->data.dock.queued_docker_id = 0;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_DOCKER_EXPORT_QUEUE:
                                set_cart_graphic(f);
                                if (b->data.dock.queued_docker_id <= 0) {
                                    b->data.dock.queued_docker_id = f->id;
                                    f->wait_ticks = 0;
                                }
                                if (b->data.dock.queued_docker_id == f->id) {
                                    b->data.dock.num_ships = 120;
                                    f->wait_ticks++;
                                    if (f->wait_ticks >= 80) {
                                        f->action_state = FIGURE_ACTION_DOCKER_IDLING;
                                        f->wait_ticks = 0;
                                        f->image_id = 0;
                                        f->cart_image_id = 0;
                                        b->data.dock.queued_docker_id = 0;
                                    }
                                }
                                f->wait_ticks++;
                                if (f->wait_ticks >= 20) {
                                    f->action_state = FIGURE_ACTION_DOCKER_IDLING;
                                    f->wait_ticks = 0;
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_DOCKER_IMPORT_GOING_TO_WAREHOUSE:
                                set_cart_graphic(f);
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_DOCKER_IMPORT_AT_WAREHOUSE;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                if (all_buildings[f->destination_building_id].state != BUILDING_STATE_IN_USE) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_DOCKER_EXPORT_GOING_TO_WAREHOUSE:
                                f->cart_image_id = EMPTY_CART_IMG_ID;
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_DOCKER_EXPORT_AT_WAREHOUSE;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                if (all_buildings[f->destination_building_id].state != BUILDING_STATE_IN_USE) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_DOCKER_EXPORT_RETURNING:
                                set_cart_graphic(f);
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_DOCKER_EXPORT_QUEUE;
                                    f->wait_ticks = 0;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                if (all_buildings[f->destination_building_id].state != BUILDING_STATE_IN_USE) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_DOCKER_IMPORT_RETURNING:
                                set_cart_graphic(f);
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_DOCKER_IDLING;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_DOCKER_IMPORT_AT_WAREHOUSE:
                                set_cart_graphic(f);
                                f->wait_ticks++;
                                if (f->wait_ticks > 10) {
                                    int trade_city_id;
                                    if (b->data.dock.trade_ship_id) {
                                        trade_city_id = figures[b->data.dock.trade_ship_id].empire_city_id;
                                    } else {
                                        trade_city_id = 0;
                                    }

                                    int try_import_resource = 0;
                                    struct building_t *warehouse = &all_buildings[f->destination_building_id];
                                    if (warehouse->type == BUILDING_WAREHOUSE) {
                                        // try existing storage bay with the same resource
                                        struct building_t *space = warehouse;
                                        for (int k = 0; k < 8; k++) {
                                            space = &all_buildings[space->next_part_building_id];
                                            if (space->id > 0) {
                                                if (space->loads_stored && space->loads_stored < 4 && space->subtype.warehouse_resource_id == f->resource_id) {
                                                    empire_objects[trade_city_id].resource_sold[f->resource_id]++;
                                                    building_warehouse_space_add_import(space, f->resource_id);
                                                    try_import_resource = 1;
                                                    break;
                                                }
                                            }
                                        }
                                        if (!try_import_resource) {
                                            // try unused storage bay
                                            space = warehouse;
                                            for (int k = 0; k < 8; k++) {
                                                space = &all_buildings[space->next_part_building_id];
                                                if (space->id > 0) {
                                                    if (space->subtype.warehouse_resource_id == RESOURCE_NONE) {
                                                        empire_objects[trade_city_id].resource_sold[f->resource_id]++;
                                                        building_warehouse_space_add_import(space, f->resource_id);
                                                        try_import_resource = 1;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if (try_import_resource) {
                                        int trader_id = figures[b->data.dock.trade_ship_id].trader_id;
                                        trader_record_sold_resource(trader_id, f->resource_id);
                                        f->action_state = FIGURE_ACTION_DOCKER_IMPORT_RETURNING;
                                        f->wait_ticks = 0;
                                        f->destination_x = f->source_x;
                                        f->destination_y = f->source_y;
                                        f->resource_id = 0;
                                        fetch_export_resource(f, b);
                                    } else {
                                        f->action_state = FIGURE_ACTION_DOCKER_IMPORT_RETURNING;
                                        f->destination_x = f->source_x;
                                        f->destination_y = f->source_y;
                                    }
                                    f->wait_ticks = 0;
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_DOCKER_EXPORT_AT_WAREHOUSE:
                                f->cart_image_id = EMPTY_CART_IMG_ID;
                                f->wait_ticks++;
                                if (f->wait_ticks > 10) {
                                    int trade_city_id;
                                    if (b->data.dock.trade_ship_id) {
                                        trade_city_id = figures[b->data.dock.trade_ship_id].empire_city_id;
                                    } else {
                                        trade_city_id = 0;
                                    }
                                    f->action_state = FIGURE_ACTION_DOCKER_IMPORT_RETURNING;
                                    f->destination_x = f->source_x;
                                    f->destination_y = f->source_y;
                                    f->wait_ticks = 0;
                                    struct building_t *warehouse = &all_buildings[f->destination_building_id];
                                    int try_export_resource = 0;
                                    if (warehouse->type == BUILDING_WAREHOUSE) {
                                        struct building_t *space = warehouse;
                                        for (int k = 0; k < 8; k++) {
                                            space = &all_buildings[space->next_part_building_id];
                                            if (space->id > 0) {
                                                if (space->loads_stored && space->subtype.warehouse_resource_id == f->resource_id) {
                                                    empire_objects[trade_city_id].resource_bought[f->resource_id]++;
                                                    city_resource_remove_from_warehouse(f->resource_id, 1);
                                                    space->loads_stored--;
                                                    if (space->loads_stored <= 0) {
                                                        space->subtype.warehouse_resource_id = RESOURCE_NONE;
                                                    }
                                                    city_finance_process_export(trade_prices[f->resource_id].sell);
                                                    building_warehouse_space_set_image(space, f->resource_id);
                                                    try_export_resource = 1;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (try_export_resource) {
                                        int trader_id = figures[b->data.dock.trade_ship_id].trader_id;
                                        trader_record_bought_resource(trader_id, f->resource_id);
                                        f->action_state = FIGURE_ACTION_DOCKER_EXPORT_RETURNING;
                                    } else {
                                        fetch_export_resource(f, b);
                                    }
                                }
                                f->image_offset = 0;
                                break;
                        }
                        int dir = figure_image_normalize_direction(f->direction < 8 ? f->direction : f->previous_tile_direction);
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_CARTPUSHER] + dir + 8 * f->image_offset;
                        if (f->cart_image_id) {
                            f->cart_image_id += dir;
                            figure_image_set_cart_offset(f, dir);
                        } else {
                            f->image_id = 0;
                        }
                        break;
                    }
                    case FIGURE_FLOTSAM:
                        if (scenario.river_exit_point.x != -1 && scenario.river_exit_point.y != -1) {
                            f->is_invisible = 0;
                            switch (f->action_state) {
                                case FIGURE_ACTION_FLOTSAM_CREATED:
                                    f->is_invisible = 1;
                                    f->wait_ticks--;
                                    if (f->wait_ticks <= 0) {
                                        f->action_state = FIGURE_ACTION_FLOTSAM_FLOATING;
                                        f->wait_ticks = 0;
                                        int shipwreck_flotsam_created = 0;
                                        if (city_data.religion.neptune_sank_ships) {
                                            city_data.religion.neptune_sank_ships = 0;
                                            shipwreck_flotsam_created = 1;
                                        }
                                        if (!f->resource_id && shipwreck_flotsam_created) {
                                            f->min_max_seen = 1;
                                        }
                                        f->destination_x = scenario.river_exit_point.x;
                                        f->destination_y = scenario.river_exit_point.y;
                                    }
                                    break;
                                case FIGURE_ACTION_FLOTSAM_FLOATING:
                                    if (f->flotsam_visible) {
                                        f->flotsam_visible = 0;
                                    } else {
                                        f->flotsam_visible = 1;
                                        f->wait_ticks++;
                                        walk_ticks(f, 1, 0);
                                        f->is_invisible = 0;
                                        f->height_adjusted_ticks = 0;
                                        if (f->direction == DIR_FIGURE_AT_DESTINATION ||
                                            f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                            f->action_state = FIGURE_ACTION_FLOTSAM_OFF_MAP;
                                        }
                                    }
                                    break;
                                case FIGURE_ACTION_FLOTSAM_OFF_MAP:
                                    f->is_invisible = 1;
                                    f->min_max_seen = 0;
                                    f->action_state = FIGURE_ACTION_FLOTSAM_CREATED;
                                    if (f->wait_ticks >= 400) {
                                        f->wait_ticks = random_data.random1_7bit & 7;
                                    } else if (f->wait_ticks >= 200) {
                                        f->wait_ticks = 50 + (random_data.random1_7bit & 0xf);
                                    } else if (f->wait_ticks >= 100) {
                                        f->wait_ticks = 100 + (random_data.random1_7bit & 0x1f);
                                    } else if (f->wait_ticks >= 50) {
                                        f->wait_ticks = 200 + (random_data.random1_7bit & 0x3f);
                                    } else {
                                        f->wait_ticks = 300 + random_data.random1_7bit;
                                    }
                                    map_figure_delete(f);
                                    f->x = scenario.river_entry_point.x;
                                    f->y = scenario.river_entry_point.y;
                                    f->grid_offset = map_grid_offset(f->x, f->y);
                                    f->cross_country_x = 15 * f->x;
                                    f->cross_country_y = 15 * f->y;
                                    break;
                            }
                            if (f->resource_id == 0) {
                                figure_image_increase_offset(f, 12);
                                if (f->min_max_seen) {
                                    f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_FLOTSAM_SHEEP] + FLOTSAM_TYPE_0[f->image_offset];
                                } else {
                                    f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_FLOTSAM_0] + FLOTSAM_TYPE_0[f->image_offset];
                                }
                            } else if (f->resource_id == 1) {
                                figure_image_increase_offset(f, 24);
                                f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_FLOTSAM_1] + FLOTSAM_TYPE_12[f->image_offset];
                            } else if (f->resource_id == 2) {
                                figure_image_increase_offset(f, 24);
                                f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_FLOTSAM_2] + FLOTSAM_TYPE_12[f->image_offset];
                            } else if (f->resource_id == 3) {
                                figure_image_increase_offset(f, 24);
                                if (FLOTSAM_TYPE_3[f->image_offset] == -1) {
                                    f->image_id = 0;
                                } else {
                                    f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_FLOTSAM_3] + FLOTSAM_TYPE_3[f->image_offset];
                                }
                            }
                        }
                        break;
                    case FIGURE_BALLISTA:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        f->is_invisible = 1;
                        f->height_adjusted_ticks = 10;
                        f->current_height = 45;
                        if (b->state != BUILDING_STATE_IN_USE || b->figure_id4 != f->id) {
                            figure_delete(f);
                            return;
                        }
                        if (b->num_workers <= 0 || b->figure_id <= 0) {
                            figure_delete(f);
                            return;
                        }
                        map_figure_delete(f);
                        switch (view_data.orientation) {
                            case DIR_0_TOP: f->x = b->x; f->y = b->y; break;
                            case DIR_2_RIGHT: f->x = b->x + 1; f->y = b->y; break;
                            case DIR_4_BOTTOM: f->x = b->x + 1; f->y = b->y + 1; break;
                            case DIR_6_LEFT: f->x = b->x; f->y = b->y + 1; break;
                        }
                        f->grid_offset = map_grid_offset(f->x, f->y);
                        map_figure_add(f);
                        switch (f->action_state) {
                            case FIGURE_ACTION_BALLISTA_READY:
                            {
                                struct map_point_t tile = { -1, -1 };
                                if (f->is_shooting) {
                                    f->attack_image_offset++;
                                    if (f->attack_image_offset > 100) {
                                        f->attack_image_offset = 0;
                                        f->is_shooting = 0;
                                    }
                                } else {
                                    f->wait_ticks_missile++;
                                    if (f->wait_ticks_missile > 250) {
                                        f->wait_ticks_missile = 250;
                                    }
                                }
                                if (f->wait_ticks_missile > figure_properties[f->type].missile_delay && set_missile_target(f, &tile)) {
                                    f->direction = calc_missile_shooter_direction(f->x, f->y, tile.x, tile.y);
                                    figure_create_missile(f, &tile, figure_properties[f->type].missile_type);
                                    play_sound_effect(SOUND_EFFECT_BALLISTA_SHOOT);
                                    f->wait_ticks_missile = 0;
                                    f->is_shooting = 1;
                                }
                                break;
                            }
                        }
                        int dir = figure_image_direction(f);
                        if (f->action_state == FIGURE_ACTION_BALLISTA_READY) {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_BALLISTA] + dir + 8 * BALLISTA_FIRING_OFFSETS[f->attack_image_offset / 4];
                        } else {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_BALLISTA] + dir;
                        }
                        break;
                    }
                    case FIGURE_BOLT:
                    {
                        f->use_cross_country = 1;
                        f->progress_on_tile++;
                        int should_die = figure_movement_move_ticks_cross_country(f, 10);
                        int target_id = get_target_on_tile(f);
                        if (target_id) {
                            struct figure_t *target = &figures[target_id];
                            missile_hit_target(f, target);
                            play_sound_effect(SOUND_EFFECT_BALLISTA_HIT_PERSON);
                        }
                        int dir = (16 + f->direction - 2 * view_data.orientation) % 16;
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_MISSILE] + 32 + dir;
                        if (f->progress_on_tile > 120) {
                            figure_delete(f);
                        }
                        if (should_die || target_id) {
                            play_sound_effect(SOUND_EFFECT_BALLISTA_HIT_GROUND);
                            figure_delete(f);
                        }
                        break;
                    }
                    case FIGURE_TOWER_SENTRY:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        f->height_adjusted_ticks = 10;
                        if (b->state != BUILDING_STATE_IN_USE || b->figure_id != f->id) {
                            figure_delete(f);
                            break;
                        }
                        figure_image_increase_offset(f, 12);
                        switch (f->action_state) {
                            case FIGURE_ACTION_TOWER_SENTRY_AT_REST:
                                f->is_targetable = 0;
                                if (!f->is_military_trained) {
                                    struct map_point_t mil_acad_road = { 0 };
                                    set_destination__closest_building_of_type(f->building_id, BUILDING_MILITARY_ACADEMY, &mil_acad_road);
                                    if (mil_acad_road.x) {
                                        struct map_point_t tower_road;
                                        if (map_has_road_access(b->x, b->y, b->size, &tower_road)) {
                                            f->terrain_usage = TERRAIN_USAGE_ROADS;
                                            f->destination_x = tower_road.x;
                                            f->destination_y = tower_road.y;
                                            walk_ticks(f, 1, 0);
                                            if (f->x == tower_road.x && f->y == tower_road.y) {
                                                f->destination_x = mil_acad_road.x;
                                                f->destination_y = mil_acad_road.y;
                                                f->action_state = FIGURE_ACTION_SOLDIER_GOING_TO_MILITARY_ACADEMY;
                                            }
                                            break;
                                        }
                                    }
                                }
                                f->terrain_usage = TERRAIN_USAGE_WALLS;
                                f->image_offset = 0;
                                f->wait_ticks++;
                                if (f->wait_ticks > 40) {
                                    f->wait_ticks = 0;
                                    int x_tile, y_tile;
                                    int dir = b->figure_roam_direction;
                                    int x = b->x;
                                    int y = b->y;
                                    switch (dir) {
                                        case DIR_0_TOP: y -= 8; break;
                                        case DIR_2_RIGHT: x += 8; break;
                                        case DIR_4_BOTTOM: y += 8; break;
                                        case DIR_6_LEFT: x -= 8; break;
                                    }
                                    map_grid_bound(&x, &y);
                                    if (map_routing_wall_tile_in_radius(x, y, 6, &x_tile, &y_tile)) {
                                        b->figure_roam_direction += 2;
                                        if (b->figure_roam_direction > 6) b->figure_roam_direction = 0;
                                        f->action_state = FIGURE_ACTION_TOWER_SENTRY_PATROLLING;
                                        f->destination_x = x_tile;
                                        f->destination_y = y_tile;
                                        figure_route_remove(f);
                                    }
                                    for (int l = 0; l < 4; l++) {
                                        dir = b->figure_roam_direction;
                                        b->figure_roam_direction += 2;
                                        if (b->figure_roam_direction > 6) b->figure_roam_direction = 0;
                                        x = b->x;
                                        y = b->y;
                                        switch (dir) {
                                            case DIR_0_TOP: y -= 3; break;
                                            case DIR_2_RIGHT: x += 3; break;
                                            case DIR_4_BOTTOM: y += 3; break;
                                            case DIR_6_LEFT: x -= 3; break;
                                        }
                                        map_grid_bound(&x, &y);
                                        if (map_routing_wall_tile_in_radius(x, y, 6, &x_tile, &y_tile)) {
                                            f->action_state = FIGURE_ACTION_TOWER_SENTRY_PATROLLING;
                                            f->destination_x = x_tile;
                                            f->destination_y = y_tile;
                                            figure_route_remove(f);
                                        }
                                    }
                                }
                                break;
                            case FIGURE_ACTION_TOWER_SENTRY_PATROLLING:
                                f->terrain_usage = TERRAIN_USAGE_WALLS;
                                f->wait_ticks_missile++;
                                if (f->wait_ticks_missile > 250) {
                                    f->wait_ticks_missile = 250;
                                }
                                if (tower_sentry_shooting(f)) {
                                    break;
                                } else {
                                    walk_ticks(f, 1, 0);
                                    if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                        f->action_state = FIGURE_ACTION_TOWER_SENTRY_RETURNING;
                                        f->destination_x = f->source_x;
                                        f->destination_y = f->source_y;
                                        figure_route_remove(f);
                                    } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                        f->action_state = FIGURE_ACTION_TOWER_SENTRY_AT_REST;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_TOWER_SENTRY_RETURNING:
                                f->terrain_usage = TERRAIN_USAGE_WALLS;
                                f->wait_ticks_missile++;
                                if (f->wait_ticks_missile > 250) {
                                    f->wait_ticks_missile = 250;
                                }
                                if (tower_sentry_shooting(f)) {
                                    break;
                                } else {
                                    walk_ticks(f, 1, 0);
                                    if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                        f->action_state = FIGURE_ACTION_TOWER_SENTRY_AT_REST;
                                    } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                        figure_delete(f);
                                        break;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_SOLDIER_GOING_TO_MILITARY_ACADEMY:
                                f->is_targetable = 1;
                                f->wait_ticks_missile++;
                                if (f->wait_ticks_missile > 250) {
                                    f->wait_ticks_missile = 250;
                                }
                                if (tower_sentry_shooting(f)) {
                                    break;
                                } else {
                                    figure_route_remove(f);
                                    f->terrain_usage = TERRAIN_USAGE_ROADS;
                                    f->is_military_trained = 1;
                                    f->height_adjusted_ticks = 0;
                                    walk_ticks(f, f->speed_multiplier, 0);
                                    if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                        f->action_state = FIGURE_ACTION_TOWER_SENTRY_GOING_TO_TOWER;
                                    } else if (f->direction == DIR_FIGURE_REROUTE) {
                                        figure_route_remove(f);
                                    } else if (f->direction == DIR_FIGURE_LOST) {
                                        figure_delete(f);
                                        break;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_TOWER_SENTRY_GOING_TO_TOWER:
                                f->is_targetable = 1;
                                f->wait_ticks_missile++;
                                if (f->wait_ticks_missile > 250) {
                                    f->wait_ticks_missile = 250;
                                }
                                if (tower_sentry_shooting(f)) {
                                    break;
                                } else {
                                    f->terrain_usage = TERRAIN_USAGE_ROADS;
                                    f->height_adjusted_ticks = 0;
                                    struct map_point_t road;
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        f->destination_x = road.x;
                                        f->destination_y = road.y;
                                    } else {
                                        figure_delete(f);
                                        break;
                                    }
                                    walk_ticks(f, 1, 0);
                                    if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                        map_figure_delete(f);
                                        f->source_x = f->x = b->x;
                                        f->source_y = f->y = b->y;
                                        f->grid_offset = map_grid_offset(f->x, f->y);
                                        map_figure_add(f);
                                        f->action_state = FIGURE_ACTION_TOWER_SENTRY_AT_REST;
                                        figure_route_remove(f);
                                    } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                        figure_delete(f);
                                        break;
                                    }
                                }
                                break;
                        }
                        if (map_terrain_is(f->grid_offset, TERRAIN_WALL)) {
                            f->current_height = 18;
                        } else if (map_terrain_is(f->grid_offset, TERRAIN_GATEHOUSE)) { // in tower
                            f->in_building_wait_ticks = 24;
                        }
                        if (f->in_building_wait_ticks) {
                            f->in_building_wait_ticks--;
                            f->height_adjusted_ticks = 0;
                        }
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_TOWER_SENTRY] + figure_image_direction(f) + 8 * f->image_offset;
                    }
                    break;
                    case FIGURE_JAVELIN:
                    {
                        f->use_cross_country = 1;
                        f->progress_on_tile++;
                        int should_die = figure_movement_move_ticks_cross_country(f, 4);
                        int target_id = get_target_on_tile(f);
                        if (target_id) {
                            struct figure_t *target = &figures[target_id];
                            missile_hit_target(f, target);
                            play_sound_effect(SOUND_EFFECT_JAVELIN);
                        }
                        int dir = (16 + f->direction - 2 * view_data.orientation) % 16;
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_MISSILE] + dir;
                        if (should_die || target_id) {
                            figure_delete(f);
                        }
                        if (f->progress_on_tile > 120) {
                            figure_delete(f);
                        }
                        break;
                    }
                    case FIGURE_PREFECT:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        if (b->state != BUILDING_STATE_IN_USE || b->figure_id != f->id) {
                            figure_delete(f);
                            return;
                        }
                        f->terrain_usage = TERRAIN_USAGE_ROADS;
                        f->use_cross_country = 0;
                        figure_image_increase_offset(f, 12);
                        switch (f->action_state) {
                            case FIGURE_ACTION_PREFECT_CREATED:
                                f->is_invisible = 1;
                                f->image_offset = 0;
                                f->wait_ticks--;
                                if (f->wait_ticks <= 0) {
                                    int x_road, y_road;
                                    if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                        f->action_state = FIGURE_ACTION_PREFECT_ENTERING_EXITING;
                                        figure_movement_set_cross_country_destination(f, x_road, y_road);
                                        f->roam_length = 0;
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_PREFECT_ENTERING_EXITING:
                                f->use_cross_country = 1;
                                f->is_invisible = 1;
                                if (figure_movement_move_ticks_cross_country(f, f->speed_multiplier) == 1) {
                                    if (map_building_at(f->grid_offset) == f->building_id) {
                                        // returned to own building
                                        figure_delete(f);
                                        return;
                                    } else {
                                        f->action_state = FIGURE_ACTION_PREFECT_ROAMING;
                                        figure_movement_init_roaming(f);
                                        f->roam_length = 0;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_PREFECT_ROAMING:
                                f->is_invisible = 0;
                                struct figure_t *target = melee_unit__set_closest_target(f);
                                if (target && calc_maximum_distance(f->x, f->y, b->x, b->y) < PREFECT_LEASH_RANGE) {
                                    f->terrain_usage = TERRAIN_USAGE_ANY;
                                    f->roam_length = figure_properties[f->type].max_roam_length;
                                    f->prefect_recent_guard_duty = 1;
                                    walk_ticks(f, f->speed_multiplier, 0);
                                    if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                        f->action_state = FIGURE_ACTION_PREFECT_RETURNING;
                                    }
                                    break;
                                }
                                if (fight_fire(f)) {
                                    break;
                                }
                                f->roam_length++;
                                if (f->roam_length >= figure_properties[f->type].max_roam_length) {
                                    f->action_state = FIGURE_ACTION_PREFECT_RETURNING;
                                }
                                figure_movement_roam_ticks(f, f->speed_multiplier);
                                break;
                            case FIGURE_ACTION_PREFECT_RETURNING:
                                if (f->prefect_recent_guard_duty) {
                                    f->terrain_usage = TERRAIN_USAGE_ANY;
                                }
                                int x_road, y_road;
                                if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                    f->destination_x = x_road;
                                    f->destination_y = y_road;
                                    figure_route_remove(f);
                                }
                                walk_ticks(f, f->speed_multiplier, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_PREFECT_ENTERING_EXITING;
                                    figure_movement_set_cross_country_destination(f, b->x, b->y);
                                    f->roam_length = 0;
                                    f->prefect_recent_guard_duty = 0;
                                    f->target_figure_id = 0;
                                } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_PREFECT_GOING_TO_FIRE:
                                f->terrain_usage = TERRAIN_USAGE_ANY;
                                walk_ticks(f, f->speed_multiplier, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_PREFECT_AT_FIRE;
                                    figure_route_remove(f);
                                    f->roam_length = 0;
                                    f->wait_ticks = 50;
                                } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_PREFECT_AT_FIRE:
                                struct building_t *burn = &all_buildings[f->destination_building_id];
                                int distance = calc_maximum_distance(f->x, f->y, burn->x, burn->y);
                                if (burn->state == BUILDING_STATE_IN_USE && burn->type == BUILDING_BURNING_RUIN && distance < 2) {
                                    burn->fire_duration = 32;
                                    play_sound_effect(SOUND_EFFECT_FIRE_SPLASH);
                                } else {
                                    f->wait_ticks = 1;
                                }
                                f->attack_direction = calc_general_direction(f->x, f->y, burn->x, burn->y);
                                if (f->attack_direction >= 8) {
                                    f->attack_direction = 0;
                                }
                                f->wait_ticks--;
                                if (f->wait_ticks <= 0) {
                                    f->wait_ticks_missile = 20;
                                    if (!fight_fire(f)) {
                                        if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                            f->action_state = FIGURE_ACTION_PREFECT_RETURNING;
                                            f->destination_x = x_road;
                                            f->destination_y = y_road;
                                            figure_route_remove(f);
                                        } else {
                                            figure_delete(f);
                                            return;
                                        }
                                    }
                                }
                                break;
                        }
                        // graphic id
                        int dir;
                        if (f->action_state == FIGURE_ACTION_PREFECT_AT_FIRE) {
                            dir = f->attack_direction;
                        } else if (f->direction < 8) {
                            dir = f->direction;
                        } else {
                            dir = f->previous_tile_direction;
                        }
                        dir = figure_image_normalize_direction(dir);
                        switch (f->action_state) {
                            case FIGURE_ACTION_PREFECT_GOING_TO_FIRE:
                                f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_PREFECT_WITH_BUCKET] + dir + 8 * f->image_offset;
                                break;
                            case FIGURE_ACTION_PREFECT_AT_FIRE:
                                f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_PREFECT_WITH_BUCKET] + dir + 96 + 8 * (f->image_offset / 2);
                                break;
                            default:
                                f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_PREFECT] + dir + 8 * f->image_offset;
                                break;
                        }
                    }
                    break;
                    case FIGURE_FORT_STANDARD:
                        figure_image_increase_offset(f, 16);
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_FORT_STANDARD_POLE] + 20 - legion_formations[f->formation_id].morale / 5;
                        if (legion_formations[f->formation_id].figure_type == FIGURE_FORT_LEGIONARY) {
                            f->cart_image_id = image_data_s.group_image_ids[GROUP_FIGURE_FORT_FLAGS] + f->image_offset / 2;
                        } else if (legion_formations[f->formation_id].figure_type == FIGURE_FORT_MOUNTED) {
                            f->cart_image_id = image_data_s.group_image_ids[GROUP_FIGURE_FORT_FLAGS] + 18 + f->image_offset / 2;
                        } else {
                            f->cart_image_id = image_data_s.group_image_ids[GROUP_FIGURE_FORT_FLAGS] + 9 + f->image_offset / 2;
                        }
                        break;
                    case FIGURE_FORT_JAVELIN:
                    case FIGURE_FORT_MOUNTED:
                    case FIGURE_FORT_LEGIONARY:
                    {
                        figure_image_increase_offset(f, 12);
                        struct formation_t *m = &legion_formations[f->formation_id];
                        if (f->is_shooting) {
                            f->attack_image_offset++;
                            if (f->attack_image_offset > 100) {
                                f->attack_image_offset = 0;
                                f->is_shooting = 0;
                            }
                        } else {
                            f->wait_ticks_missile++;
                            if (f->wait_ticks_missile > 250) {
                                f->wait_ticks_missile = 250;
                            }
                        }
                        switch (f->action_state) {
                            case FIGURE_ACTION_SOLDIER_AT_REST:
                                map_figure_update(f);
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_SOLDIER_GOING_TO_FORT:
                                rout_unit(f);
                                break;
                            case FIGURE_ACTION_SOLDIER_RETURNING_TO_BARRACKS:
                                walk_ticks(f, f->speed_multiplier, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                }
                                break;
                            case FIGURE_ACTION_SOLDIER_GOING_TO_STANDARD:
                                walk_ticks(f, f->speed_multiplier, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION || f->direction == DIR_FIGURE_LOST) {
                                    f->action_state = FIGURE_ACTION_SOLDIER_AT_STANDARD;
                                    if (f->type == FIGURE_FORT_LEGIONARY && rand() % 100 == 1) {
                                        play_sound_effect(SOUND_EFFECT_FORMATION_SHIELD);
                                    }
                                    if (m->layout == FORMATION_DOUBLE_LINE_1 || m->layout == FORMATION_SINGLE_LINE_1) {
                                        if (m->standard_y < m->prev_standard_y) {
                                            m->direction = DIR_0_TOP;
                                        } else if (m->standard_y > m->prev_standard_y) {
                                            m->direction = DIR_4_BOTTOM;
                                        }
                                    } else if (m->layout == FORMATION_DOUBLE_LINE_2 || m->layout == FORMATION_SINGLE_LINE_2) {
                                        if (m->standard_x < m->prev_standard_x) {
                                            m->direction = DIR_6_LEFT;
                                        } else if (m->standard_x > m->prev_standard_x) {
                                            m->direction = DIR_2_RIGHT;
                                        }
                                    } else if (m->layout == FORMATION_TORTOISE) {
                                        int dx = (m->standard_x < m->prev_standard_x) ? (m->prev_standard_x - m->standard_x) : (m->standard_x - m->prev_standard_x);
                                        int dy = (m->standard_y < m->prev_standard_y) ? (m->prev_standard_y - m->standard_y) : (m->standard_y - m->prev_standard_y);
                                        if (dx > dy) {
                                            if (m->standard_x < m->prev_standard_x) {
                                                m->direction = DIR_6_LEFT;
                                            } else if (m->standard_x > m->prev_standard_x) {
                                                m->direction = DIR_2_RIGHT;
                                            }
                                        } else {
                                            if (m->standard_y < m->prev_standard_y) {
                                                m->direction = DIR_0_TOP;
                                            } else if (m->standard_y > m->prev_standard_y) {
                                                m->direction = DIR_4_BOTTOM;
                                            }
                                        }
                                    }
                                    m->prev_standard_x = m->standard_x;
                                    m->prev_standard_y = m->standard_y;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                }
                                break;
                            case FIGURE_ACTION_SOLDIER_AT_STANDARD:
                                f->image_offset = 0;
                                map_figure_update(f);
                                if (f->type == FIGURE_FORT_JAVELIN) {
                                    struct map_point_t tile = { -1, -1 };
                                    if (f->wait_ticks_missile > figure_properties[f->type].missile_delay && set_missile_target(f, &tile)) {
                                        f->is_shooting = 1;
                                        f->wait_ticks_missile = 0;
                                        f->attack_image_offset = 1;
                                        f->direction = calc_missile_shooter_direction(f->x, f->y, tile.x, tile.y);
                                        figure_create_missile(f, &tile, figure_properties[f->type].missile_type);
                                    } else {
                                        if (!f->is_shooting) {
                                            f->attack_image_offset = 0;
                                        }
                                    }
                                } else if (f->type == FIGURE_FORT_LEGIONARY) {
                                    // attack adjacent enemy
                                    for (int k = 0; k < 8; k++) {
                                        melee_attack_figure_at_offset(f, f->grid_offset + map_grid_direction_delta(k));
                                    }
                                }
                                break;
                            case FIGURE_ACTION_SOLDIER_GOING_TO_MILITARY_ACADEMY:
                                f->is_military_trained = 1;
                                if (f->type == FIGURE_FORT_MOUNTED) {
                                    f->mounted_charge_ticks = 20;
                                    f->mounted_charge_ticks_max = 20;
                                }
                                walk_ticks(f, f->speed_multiplier, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    if (m->is_at_rest) {
                                        f->action_state = FIGURE_ACTION_SOLDIER_GOING_TO_FORT;
                                    } else {
                                        deploy_legion_unit_to_formation_location(f, m);
                                    }
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_SOLDIER_MOPPING_UP:
                            {
                                struct figure_t *target = melee_unit__set_closest_target(f);
                                if (target) {
                                    walk_ticks(f, f->speed_multiplier, 0);
                                    if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                        figure_route_remove(f);
                                        f->action_state = FIGURE_ACTION_SOLDIER_AT_STANDARD;
                                        f->target_figure_id = 0;
                                    }
                                } else {
                                    f->image_offset = 0;
                                    deploy_legion_unit_to_formation_location(f, m);
                                }
                                break;
                            }
                            case FIGURE_ACTION_SOLDIER_GOING_TO_DISTANT_BATTLE:
                            {
                                f->destination_x = scenario.exit_point.x;
                                f->destination_y = scenario.exit_point.y;
                                walk_ticks(f, f->speed_multiplier, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->is_invisible = 1;
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            }
                            case FIGURE_ACTION_SOLDIER_RETURNING_FROM_DISTANT_BATTLE:
                                f->is_invisible = 0;
                                f->destination_x = m->standard_x + FORMATION_LAYOUT_POSITION_X[FORMATION_AT_REST][f->index_in_formation];
                                f->destination_y = m->standard_y + FORMATION_LAYOUT_POSITION_Y[FORMATION_AT_REST][f->index_in_formation];
                                f->destination_grid_offset = map_grid_offset(f->destination_x, f->destination_y);
                                walk_ticks(f, f->speed_multiplier, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_SOLDIER_AT_REST;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                        }
                        int dir;
                        if (f->is_shooting) {
                            dir = f->direction;
                            m->direction = f->direction;
                        } else if (f->action_state == FIGURE_ACTION_SOLDIER_AT_STANDARD) {
                            dir = m->direction;
                        } else if (f->direction < 8) {
                            dir = f->direction;
                        } else {
                            dir = f->previous_tile_direction;
                        }
                        dir = figure_image_normalize_direction(dir);
                        if (f->type == FIGURE_FORT_JAVELIN) {
                            int image_id = image_data_s.group_image_ids[GROUP_BUILDING_FORT_JAVELIN];
                            if (f->action_state == FIGURE_ACTION_SOLDIER_AT_STANDARD) {
                                f->image_id = image_id + 96 + dir + 8 * MISSILE_LAUNCHER_OFFSETS[f->attack_image_offset / 2];
                            } else {
                                f->image_id = image_id + dir + 8 * f->image_offset;
                            }
                        } else if (f->type == FIGURE_FORT_MOUNTED) {
                            int image_id = image_data_s.group_image_ids[GROUP_FIGURE_FORT_MOUNTED];
                            f->image_id = image_id + dir + 8 * f->image_offset;
                        } else if (f->type == FIGURE_FORT_LEGIONARY) {
                            int image_id = image_data_s.group_image_ids[GROUP_BUILDING_FORT_LEGIONARY];
                            if (f->action_state == FIGURE_ACTION_SOLDIER_AT_STANDARD) {
                                if (f->figure_is_halted && m->layout == FORMATION_TORTOISE && m->missile_attack_timeout) {
                                    f->image_id = image_id + dir + 144;
                                } else {
                                    f->image_id = image_id + dir;
                                }
                            } else {
                                f->image_id = image_id + dir + 8 * f->image_offset;
                            }
                        }
                        break;
                    }
                    case FIGURE_MARKET_BUYER:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        if (b->state != BUILDING_STATE_IN_USE || b->figure_id2 != f->id) {
                            figure_delete(f);
                            return;
                        }
                        figure_image_increase_offset(f, 12);
                        switch (f->action_state) {
                            case FIGURE_ACTION_MARKET_BUYER_GOING_TO_STORAGE:
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    if (f->collecting_item_id > 3) {
                                        int resource;
                                        switch (f->collecting_item_id) {
                                            case INVENTORY_POTTERY: resource = RESOURCE_POTTERY; break;
                                            case INVENTORY_FURNITURE: resource = RESOURCE_FURNITURE; break;
                                            case INVENTORY_OIL: resource = RESOURCE_OIL; break;
                                            case INVENTORY_WINE: resource = RESOURCE_WINE; break;
                                            default:
                                                figure_delete(f);
                                                return;
                                        }
                                        struct building_t *warehouse = &all_buildings[f->destination_building_id];
                                        int num_loads;
                                        int stored = building_warehouse_get_amount(warehouse, resource);
                                        if (stored < 2) {
                                            num_loads = stored;
                                        } else {
                                            num_loads = 2;
                                        }
                                        if (num_loads <= 0) {
                                            figure_delete(f);
                                            return;
                                        }
                                        building_warehouse_remove_resource(warehouse, resource, num_loads);
                                        // create delivery boys
                                        int boy1 = create_delivery_boy(f->id, f);
                                        if (num_loads > 1) {
                                            create_delivery_boy(boy1, f);
                                        }
                                    } else {
                                        int resource;
                                        switch (f->collecting_item_id) {
                                            case INVENTORY_WHEAT: resource = RESOURCE_WHEAT; break;
                                            case INVENTORY_VEGETABLES: resource = RESOURCE_VEGETABLES; break;
                                            case INVENTORY_FRUIT: resource = RESOURCE_FRUIT; break;
                                            case INVENTORY_MEAT: resource = RESOURCE_MEAT; break;
                                            default:
                                                figure_delete(f);
                                                return;
                                        }
                                        struct building_t *granary = &all_buildings[f->destination_building_id];
                                        int max_units = (f->collecting_item_id == INVENTORY_WHEAT ? 800 : 600) - all_buildings[f->building_id].data.market.inventory[f->collecting_item_id];
                                        int granary_units = granary->data.granary.resource_stored[resource];
                                        int num_loads;
                                        if (granary_units >= 800) {
                                            num_loads = 8;
                                        } else if (granary_units >= 700) {
                                            num_loads = 7;
                                        } else if (granary_units >= 600) {
                                            num_loads = 6;
                                        } else if (granary_units >= 500) {
                                            num_loads = 5;
                                        } else if (granary_units >= 400) {
                                            num_loads = 4;
                                        } else if (granary_units >= 300) {
                                            num_loads = 3;
                                        } else if (granary_units >= 200) {
                                            num_loads = 2;
                                        } else if (granary_units >= 100) {
                                            num_loads = 1;
                                        } else {
                                            num_loads = 0;
                                        }
                                        if (num_loads > max_units / 100) {
                                            num_loads = max_units / 100;
                                        }
                                        if (num_loads <= 0) {
                                            figure_delete(f);
                                            return;
                                        }
                                        building_granary_remove_resource(granary, resource, 100 * num_loads);
                                        // create delivery boys
                                        int previous_boy = f->id;
                                        for (int k = 0; k < num_loads; k++) {
                                            previous_boy = create_delivery_boy(previous_boy, f);
                                        }
                                    }
                                    f->action_state = FIGURE_ACTION_MARKET_BUYER_RETURNING;
                                    f->destination_x = f->source_x;
                                    f->destination_y = f->source_y;
                                } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                    f->action_state = FIGURE_ACTION_MARKET_BUYER_RETURNING;
                                    f->destination_x = f->source_x;
                                    f->destination_y = f->source_y;
                                    figure_route_remove(f);
                                }
                                break;
                            case FIGURE_ACTION_MARKET_BUYER_RETURNING:
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                }
                                break;
                        }
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_MARKET_LADY] + figure_image_direction(f) + 8 * f->image_offset;
                        break;
                    }
                    case FIGURE_MARKET_TRADER:
                        struct building_t *market = &all_buildings[f->building_id];
                        if (market->state != BUILDING_STATE_IN_USE || market->figure_id != f->id) {
                            figure_delete(f);
                            return;
                        }
                        if (f->action_state == FIGURE_ACTION_ROAMING) {
                            // force return on out of stock
                            int max_stock = 0;
                            if (market->id > 0 && market->type == BUILDING_MARKET) {
                                for (int k = INVENTORY_OIL; k <= INVENTORY_FURNITURE; k++) {
                                    int stock = market->data.market.inventory[k];
                                    if (stock > max_stock) {
                                        max_stock = stock;
                                    }
                                }
                            }
                            int stock = building_market_get_max_food_stock(market) + max_stock;
                            if (f->roam_length >= 96 && stock <= 0) {
                                f->roam_length = figure_properties[f->type].max_roam_length;
                            }
                        }
                        roamer_action(f, 1);
                        figure_image_increase_offset(f, 12);
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_MARKET_LADY] + figure_image_direction(f) + 8 * f->image_offset;
                        break;
                    case FIGURE_DELIVERY_BOY:
                    {
                        f->is_invisible = 0;
                        figure_image_increase_offset(f, 12);
                        struct figure_t *leader = &figures[f->leading_figure_id];
                        if (f->leading_figure_id <= 0) {
                            figure_delete(f);
                            return;
                        } else {
                            if (figure_is_alive(leader)) {
                                if (leader->type == FIGURE_MARKET_BUYER || leader->type == FIGURE_DELIVERY_BOY) {
                                    figure_movement_follow_ticks(f, 1);
                                } else {
                                    figure_delete(f);
                                    return;
                                }
                            } else { // leader arrived at market, drop resource at market
                                all_buildings[f->building_id].data.market.inventory[f->collecting_item_id] += 100;
                                figure_delete(f);
                                return;
                            }
                        }
                        if (leader->is_invisible) {
                            f->is_invisible = 1;
                        }
                        int dir = figure_image_normalize_direction(f->direction < 8 ? f->direction : f->previous_tile_direction);
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_DELIVERY_BOY] + dir + 8 * f->image_offset;
                        break;
                    }
                    case FIGURE_WAREHOUSEMAN:
                    {
                        f->terrain_usage = TERRAIN_USAGE_ROADS;
                        figure_image_increase_offset(f, 12);
                        f->cart_image_id = 0;
                        int road_network_id = network.items[f->grid_offset];
                        switch (f->action_state) {
                            case FIGURE_ACTION_WAREHOUSEMAN_CREATED:
                            {
                                struct building_t *b = &all_buildings[f->building_id];
                                if (b->state != BUILDING_STATE_IN_USE || b->figure_id != f->id) {
                                    figure_delete(f);
                                    return;
                                }
                                f->wait_ticks++;
                                if (f->wait_ticks > 2) {
                                    if (all_buildings[f->building_id].type == BUILDING_GRANARY) {
                                        struct map_point_t dst;
                                        int dst_building_id;
                                        struct building_t *granary = &all_buildings[f->building_id];
                                        int min_building_id = 0;
                                        if (!f->resource_id) {
                                            // getting granaryman
                                            struct building_storage_t *s_src = &storages[granary->storage_id].storage;
                                            if (!s_src->empty_all && !scenario.rome_supplies_wheat) {
                                                int is_getting = 0;
                                                if (s_src->resource_state[RESOURCE_WHEAT] == BUILDING_STORAGE_STATE_GETTING ||
                                                        s_src->resource_state[RESOURCE_VEGETABLES] == BUILDING_STORAGE_STATE_GETTING ||
                                                        s_src->resource_state[RESOURCE_FRUIT] == BUILDING_STORAGE_STATE_GETTING ||
                                                        s_src->resource_state[RESOURCE_MEAT] == BUILDING_STORAGE_STATE_GETTING) {
                                                    is_getting = 1;
                                                }
                                                if (is_getting) {
                                                    int min_dist = INFINITE;
                                                    for (int l = 0; l < non_getting_granaries.num_items; l++) {
                                                        b = &all_buildings[non_getting_granaries.building_ids[l]];
                                                        if (b->road_network_id != granary->road_network_id) {
                                                            continue;
                                                        }
                                                        struct building_storage_t *s = &storages[b->storage_id].storage;
                                                        int amount_gettable = 0;
                                                        if (s_src->resource_state[RESOURCE_WHEAT] == BUILDING_STORAGE_STATE_GETTING &&
                                                            s->resource_state[RESOURCE_WHEAT] != BUILDING_STORAGE_STATE_GETTING) {
                                                            amount_gettable += b->data.granary.resource_stored[RESOURCE_WHEAT];
                                                        }
                                                        if (s_src->resource_state[RESOURCE_VEGETABLES] == BUILDING_STORAGE_STATE_GETTING &&
                                                            s->resource_state[RESOURCE_VEGETABLES] != BUILDING_STORAGE_STATE_GETTING) {
                                                            amount_gettable += b->data.granary.resource_stored[RESOURCE_VEGETABLES];
                                                        }
                                                        if (s_src->resource_state[RESOURCE_FRUIT] == BUILDING_STORAGE_STATE_GETTING &&
                                                            s->resource_state[RESOURCE_FRUIT] != BUILDING_STORAGE_STATE_GETTING) {
                                                            amount_gettable += b->data.granary.resource_stored[RESOURCE_FRUIT];
                                                        }
                                                        if (s_src->resource_state[RESOURCE_MEAT] == BUILDING_STORAGE_STATE_GETTING &&
                                                            s->resource_state[RESOURCE_MEAT] != BUILDING_STORAGE_STATE_GETTING) {
                                                            amount_gettable += b->data.granary.resource_stored[RESOURCE_MEAT];
                                                        }
                                                        if (amount_gettable > 0) {
                                                            int dist = calc_maximum_distance(
                                                                b->x + 1, b->y + 1,
                                                                granary->x + 1, granary->y + 1);
                                                            if (amount_gettable <= 400) {
                                                                dist *= 2; // penalty for less food
                                                            }
                                                            if (dist < min_dist) {
                                                                min_dist = dist;
                                                                min_building_id = b->id;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            struct building_t *min = &all_buildings[min_building_id];
                                            dst.x = min->x + 1;
                                            dst.y = min->y + 1;
                                            dst_building_id = min_building_id;
                                            if (dst_building_id) {
                                                f->loads_sold_or_carrying = 0;
                                                set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_GETTING_FOOD, dst_building_id, dst.x, dst.y);
                                            } else {
                                                figure_delete(f);
                                            }
                                            return;
                                        }
                                        // delivering resource
                                        // priority 1: another granary
                                        dst_building_id = building_granary_for_storing(f->x, f->y, f->resource_id, road_network_id, 0,
                                            0, &dst);
                                        if (dst_building_id) {
                                            set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE, dst_building_id, dst.x, dst.y);
                                            building_granary_remove_resource(granary, f->resource_id, 100);
                                            return;
                                        }
                                        // priority 2: warehouse
                                        dst_building_id = building_warehouse_for_storing(0, f->x, f->y,
                                            f->resource_id, road_network_id, 0, &dst);
                                        if (dst_building_id) {
                                            set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE, dst_building_id, dst.x, dst.y);
                                            building_granary_remove_resource(granary, f->resource_id, 100);
                                            return;
                                        }
                                        // priority 3: granary even though resource is on stockpile
                                        dst_building_id = building_granary_for_storing(f->x, f->y,
                                            f->resource_id, road_network_id, 1, 0, &dst);
                                        if (dst_building_id) {
                                            set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE, dst_building_id, dst.x, dst.y);
                                            building_granary_remove_resource(granary, f->resource_id, 100);
                                            return;
                                        }
                                        // nowhere to go to: kill figure
                                        figure_delete(f);
                                    } else {
                                        struct map_point_t dst;
                                        int dst_building_id = 0;
                                        if (!f->resource_id) {
                                            // getting warehouseman
                                            int min_dist = 10000;
                                            struct building_t *min_building = 0;
                                            for (int l = 1; l < MAX_BUILDINGS; l++) {
                                                struct building_t *bb = &all_buildings[l];
                                                if (bb->state != BUILDING_STATE_IN_USE || bb->type != BUILDING_WAREHOUSE) {
                                                    continue;
                                                }
                                                if (l == b->id) {
                                                    continue;
                                                }
                                                int loads_stored = 0;
                                                struct building_t *space = bb;
                                                struct building_storage_t *s = &storages[bb->storage_id].storage;
                                                for (int t = 0; t < 8; t++) {
                                                    space = &all_buildings[space->next_part_building_id];
                                                    if (space->id > 0 && space->loads_stored > 0) {
                                                        if (space->subtype.warehouse_resource_id == f->collecting_item_id) {
                                                            loads_stored += space->loads_stored;
                                                        }
                                                    }
                                                }
                                                if (loads_stored > 0 && s->resource_state[f->collecting_item_id] != BUILDING_STORAGE_STATE_GETTING) {
                                                    int dist = calc_maximum_distance(bb->x, bb->y, b->x, b->y);
                                                    dist -= 4 * loads_stored;
                                                    if (dist < min_dist) {
                                                        min_dist = dist;
                                                        min_building = bb;
                                                    }
                                                }
                                            }
                                            if (min_building) {
                                                dst.x = min_building->road_access_x;
                                                dst.y = min_building->road_access_y;
                                            }
                                            if (min_building->id) {
                                                f->loads_sold_or_carrying = 0;
                                                set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_GETTING_RESOURCE, min_building->id, dst.x, dst.y);
                                                f->terrain_usage = TERRAIN_USAGE_PREFER_ROADS;
                                            } else {
                                                figure_delete(f);
                                            }
                                            return;
                                        }
                                        // delivering resource
                                        // priority 1: weapons to barracks
                                        if (f->resource_id == RESOURCE_WEAPONS && !city_data.resource.stockpiled[RESOURCE_WEAPONS] && count_data.buildings[BUILDING_BARRACKS].active) {
                                            b = &all_buildings[city_data.building.barracks_building_id];
                                            if (b->loads_stored < 5 && city_data.military.legionary_legions) {
                                                if (map_has_road_access(b->x, b->y, b->size, &dst) && b->road_network_id == road_network_id) {
                                                    dst_building_id = b->id;
                                                }
                                            }
                                        }
                                        if (dst_building_id) {
                                            set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE, dst_building_id, dst.x, dst.y);
                                            remove_resource_from_warehouse(f);
                                            return;
                                        }
                                        // priority 2: raw materials to workshop
                                        dst_building_id = building_get_workshop_for_raw_material_with_room(f->x, f->y, f->resource_id, road_network_id, &dst);
                                        if (dst_building_id) {
                                            set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE, dst_building_id, dst.x, dst.y);
                                            remove_resource_from_warehouse(f);
                                            return;
                                        }
                                        // priority 3: food to granary
                                        dst_building_id = building_granary_for_storing(f->x, f->y, f->resource_id, road_network_id, 0, 0, &dst);
                                        if (dst_building_id) {
                                            set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE, dst_building_id, dst.x, dst.y);
                                            remove_resource_from_warehouse(f);
                                            return;
                                        }
                                        // priority 4: food to getting granary
                                        if (!scenario.rome_supplies_wheat && resource_is_food(f->resource_id) && !city_data.resource.stockpiled[f->resource_id]) {
                                            int min_dist = INFINITE;
                                            int min_building_id = 0;
                                            for (int k = 1; k < MAX_BUILDINGS; k++) {
                                                b = &all_buildings[k];
                                                if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_GRANARY) {
                                                    continue;
                                                }
                                                if (!b->has_road_access || b->road_network_id != road_network_id) {
                                                    continue;
                                                }
                                                if (calc_percentage(b->num_workers, building_properties[b->type].n_laborers) < 100) {
                                                    continue;
                                                }
                                                struct building_storage_t *s = &storages[b->storage_id].storage;
                                                if (s->resource_state[f->resource_id] != BUILDING_STORAGE_STATE_GETTING || s->empty_all) {
                                                    continue;
                                                }
                                                if (b->data.granary.resource_stored[RESOURCE_NONE] > ONE_LOAD) {
                                                    // there is room
                                                    int dist = calc_maximum_distance(b->x + 1, b->y + 1, f->x, f->y);
                                                    if (dist < min_dist) {
                                                        min_dist = dist;
                                                        min_building_id = k;
                                                    }
                                                }
                                            }
                                            struct building_t *min = &all_buildings[min_building_id];
                                            dst.x = min->x + 1;
                                            dst.y = min->y + 1;
                                            dst_building_id = min_building_id;
                                            if (dst_building_id) {
                                                set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE, dst_building_id, dst.x, dst.y);
                                                remove_resource_from_warehouse(f);
                                                return;
                                            }
                                        }
                                        // priority 5: resource to other warehouse
                                        dst_building_id = building_warehouse_for_storing(f->building_id, f->x, f->y, f->resource_id, road_network_id, 0, &dst);
                                        if (dst_building_id) {
                                            if (dst_building_id == f->building_id) {
                                                figure_delete(f);
                                            } else {
                                                set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE, dst_building_id, dst.x, dst.y);
                                                remove_resource_from_warehouse(f);
                                            }
                                            return;
                                        }
                                        // priority 6: raw material to well-stocked workshop
                                        struct building_t *min_building = 0;
                                        if (!city_data.resource.stockpiled[f->resource_id]) {
                                            int output_type = resource_to_workshop_type(f->resource_id);
                                            if (output_type != WORKSHOP_NONE) {
                                                int min_dist = INFINITE;
                                                for (int k = 1; k < MAX_BUILDINGS; k++) {
                                                    b = &all_buildings[k];
                                                    if (b->state != BUILDING_STATE_IN_USE || !building_is_workshop(b->type)) {
                                                        continue;
                                                    }
                                                    if (!b->has_road_access) {
                                                        continue;
                                                    }
                                                    if (b->subtype.workshop_type == output_type && b->road_network_id == road_network_id) {
                                                        int dist = 10 * b->loads_stored +
                                                            calc_maximum_distance(b->x, b->y, f->x, f->y);
                                                        if (dist < min_dist) {
                                                            min_dist = dist;
                                                            min_building = b;
                                                        }
                                                    }
                                                }
                                                if (min_building) {
                                                    dst.x = min_building->road_access_x;
                                                    dst.y = min_building->road_access_y;
                                                }
                                            }
                                        }
                                        if (min_building->id) {
                                            set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE, min_building->id, dst.x, dst.y);
                                            remove_resource_from_warehouse(f);
                                            return;
                                        }
                                        // no destination: kill figure
                                        figure_delete(f);
                                    }
                                }
                                f->image_offset = 0;
                                break;
                            }
                            case FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE:
                                if (f->loads_sold_or_carrying == 1) {
                                    f->cart_image_id = image_data_s.group_image_ids[GROUP_FIGURE_CARTPUSHER_CART_MULTIPLE_FOOD] +
                                        8 * f->resource_id - 8 + resource_image_offset(f->resource_id, RESOURCE_IMAGE_FOOD_CART);
                                } else {
                                    set_cart_graphic(f);
                                }
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_WAREHOUSEMAN_AT_DELIVERY_BUILDING;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_WAREHOUSEMAN_AT_DELIVERY_BUILDING:
                                f->wait_ticks++;
                                if (f->wait_ticks > 4) {
                                    struct building_t *b = &all_buildings[f->destination_building_id];
                                    switch (b->type) {
                                        case BUILDING_GRANARY:
                                            building_granary_add_resource(b, f->resource_id, 0);
                                            break;
                                        case BUILDING_BARRACKS:
                                            b->loads_stored++;
                                            break;
                                        case BUILDING_WAREHOUSE:
                                        case BUILDING_WAREHOUSE_SPACE:
                                            building_warehouse_add_resource(b, f->resource_id);
                                            break;
                                        default: // workshop
                                            building_workshop_add_raw_material(b);
                                            break;
                                    }
                                    // BUG: what if warehouse/granary is full and returns false?
                                    f->action_state = FIGURE_ACTION_WAREHOUSEMAN_RETURNING_EMPTY;
                                    f->wait_ticks = 0;
                                    f->destination_x = f->source_x;
                                    f->destination_y = f->source_y;
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_WAREHOUSEMAN_RETURNING_EMPTY:
                                f->cart_image_id = EMPTY_CART_IMG_ID;
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                }
                                break;
                            case FIGURE_ACTION_WAREHOUSEMAN_GETTING_FOOD:
                                f->cart_image_id = EMPTY_CART_IMG_ID;
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_WAREHOUSEMAN_AT_GRANARY;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_WAREHOUSEMAN_AT_GRANARY:
                                f->wait_ticks++;
                                if (f->wait_ticks > 4) {
                                    struct building_t *src = &all_buildings[f->destination_building_id];
                                    struct building_t *dst = &all_buildings[f->building_id];
                                    struct building_storage_t *s_src = &storages[src->storage_id].storage;
                                    struct building_storage_t *s_dst = &storages[dst->storage_id].storage;
                                    int max_amount = 0;
                                    int max_resource = 0;
                                    if (s_dst->resource_state[RESOURCE_WHEAT] == BUILDING_STORAGE_STATE_GETTING &&
                                            s_src->resource_state[RESOURCE_WHEAT] != BUILDING_STORAGE_STATE_GETTING) {
                                        if (src->data.granary.resource_stored[RESOURCE_WHEAT] > max_amount) {
                                            max_amount = src->data.granary.resource_stored[RESOURCE_WHEAT];
                                            max_resource = RESOURCE_WHEAT;
                                        }
                                    }
                                    if (s_dst->resource_state[RESOURCE_VEGETABLES] == BUILDING_STORAGE_STATE_GETTING &&
                                            s_src->resource_state[RESOURCE_VEGETABLES] != BUILDING_STORAGE_STATE_GETTING) {
                                        if (src->data.granary.resource_stored[RESOURCE_VEGETABLES] > max_amount) {
                                            max_amount = src->data.granary.resource_stored[RESOURCE_VEGETABLES];
                                            max_resource = RESOURCE_VEGETABLES;
                                        }
                                    }
                                    if (s_dst->resource_state[RESOURCE_FRUIT] == BUILDING_STORAGE_STATE_GETTING &&
                                            s_src->resource_state[RESOURCE_FRUIT] != BUILDING_STORAGE_STATE_GETTING) {
                                        if (src->data.granary.resource_stored[RESOURCE_FRUIT] > max_amount) {
                                            max_amount = src->data.granary.resource_stored[RESOURCE_FRUIT];
                                            max_resource = RESOURCE_FRUIT;
                                        }
                                    }
                                    if (s_dst->resource_state[RESOURCE_MEAT] == BUILDING_STORAGE_STATE_GETTING &&
                                            s_src->resource_state[RESOURCE_MEAT] != BUILDING_STORAGE_STATE_GETTING) {
                                        if (src->data.granary.resource_stored[RESOURCE_MEAT] > max_amount) {
                                            max_amount = src->data.granary.resource_stored[RESOURCE_MEAT];
                                            max_resource = RESOURCE_MEAT;
                                        }
                                    }
                                    if (max_amount > 800) {
                                        max_amount = 800;
                                    }
                                    if (max_amount > dst->data.granary.resource_stored[RESOURCE_NONE]) {
                                        max_amount = dst->data.granary.resource_stored[RESOURCE_NONE];
                                    }
                                    building_granary_remove_resource(src, max_resource, max_amount);
                                    f->loads_sold_or_carrying = max_amount / UNITS_PER_LOAD;
                                    f->resource_id = max_resource;
                                    f->action_state = FIGURE_ACTION_WAREHOUSEMAN_RETURNING_WITH_FOOD;
                                    f->wait_ticks = 0;
                                    f->destination_x = f->source_x;
                                    f->destination_y = f->source_y;
                                    figure_route_remove(f);
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_WAREHOUSEMAN_RETURNING_WITH_FOOD:
                                // update graphic
                                if (f->loads_sold_or_carrying <= 0) {
                                    f->cart_image_id = EMPTY_CART_IMG_ID;
                                } else if (f->loads_sold_or_carrying == 1) {
                                    set_cart_graphic(f);
                                } else {
                                    if (f->loads_sold_or_carrying >= 8) {
                                        f->cart_image_id = image_data_s.group_image_ids[GROUP_FIGURE_CARTPUSHER_CART_MULTIPLE_FOOD] +
                                            CART_OFFSET_8_LOADS_FOOD[f->resource_id];
                                    } else {
                                        f->cart_image_id = image_data_s.group_image_ids[GROUP_FIGURE_CARTPUSHER_CART_MULTIPLE_FOOD] +
                                            CART_OFFSET_MULTIPLE_LOADS_FOOD[f->resource_id];
                                    }
                                    f->cart_image_id += resource_image_offset(f->resource_id, RESOURCE_IMAGE_FOOD_CART);
                                }
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    for (int k = 0; k < f->loads_sold_or_carrying; k++) {
                                        building_granary_add_resource(&all_buildings[f->building_id], f->resource_id, 0);
                                    }
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_WAREHOUSEMAN_GETTING_RESOURCE:
                                f->terrain_usage = TERRAIN_USAGE_PREFER_ROADS;
                                f->cart_image_id = EMPTY_CART_IMG_ID;
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_WAREHOUSEMAN_AT_WAREHOUSE;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_WAREHOUSEMAN_AT_WAREHOUSE:
                                f->terrain_usage = TERRAIN_USAGE_PREFER_ROADS;
                                f->wait_ticks++;
                                if (f->wait_ticks > 4) {
                                    f->loads_sold_or_carrying = 0;
                                    while (f->loads_sold_or_carrying < 4 && 0 == building_warehouse_remove_resource(
                                        &all_buildings[f->destination_building_id], f->collecting_item_id, 1)) {
                                        f->loads_sold_or_carrying++;
                                    }
                                    f->resource_id = f->collecting_item_id;
                                    f->action_state = FIGURE_ACTION_WAREHOUSEMAN_RETURNING_WITH_RESOURCE;
                                    f->wait_ticks = 0;
                                    f->destination_x = f->source_x;
                                    f->destination_y = f->source_y;
                                    figure_route_remove(f);
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_WAREHOUSEMAN_RETURNING_WITH_RESOURCE:
                                f->terrain_usage = TERRAIN_USAGE_PREFER_ROADS;
                                // update graphic
                                if (f->loads_sold_or_carrying <= 0) {
                                    f->cart_image_id = EMPTY_CART_IMG_ID;
                                } else if (f->loads_sold_or_carrying == 1) {
                                    set_cart_graphic(f);
                                } else {
                                    if (f->resource_id == RESOURCE_WHEAT || f->resource_id == RESOURCE_VEGETABLES ||
                                        f->resource_id == RESOURCE_FRUIT || f->resource_id == RESOURCE_MEAT) {
                                        f->cart_image_id = image_data_s.group_image_ids[GROUP_FIGURE_CARTPUSHER_CART_MULTIPLE_FOOD] +
                                            CART_OFFSET_MULTIPLE_LOADS_FOOD[f->resource_id];
                                    } else {
                                        f->cart_image_id = image_data_s.group_image_ids[GROUP_FIGURE_CARTPUSHER_CART_MULTIPLE_RESOURCE] +
                                            CART_OFFSET_MULTIPLE_LOADS_NON_FOOD[f->resource_id];
                                    }
                                    f->cart_image_id += resource_image_offset(f->resource_id, RESOURCE_IMAGE_FOOD_CART);
                                }
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    for (int k = 0; k < f->loads_sold_or_carrying; k++) {
                                        building_warehouse_add_resource(&all_buildings[f->building_id], f->resource_id);
                                    }
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                        }
                        update_image_cartpusher(f);
                    }
                    break;
                    case FIGURE_PROTESTER:
                    {
                        figure_image_increase_offset(f, 64);
                        f->wait_ticks++;
                        if (f->wait_ticks > 200) {
                            figure_delete(f);
                            return;
                        }
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_CRIMINAL] + CRIMINAL_OFFSETS[f->image_offset / 4] + 104;
                    }
                    break;
                    case FIGURE_CRIMINAL:
                    {
                        figure_image_increase_offset(f, 32);
                        f->wait_ticks++;
                        if (f->wait_ticks > 200) {
                            figure_delete(f);
                            return;
                        }
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_CRIMINAL] + CRIMINAL_OFFSETS[f->image_offset / 2] + 104;
                    }
                    break;
                    case FIGURE_RIOTER:
                    {
                        switch (f->action_state) {
                            case FIGURE_ACTION_RIOTER_CREATED:
                                figure_image_increase_offset(f, 32);
                                f->wait_ticks++;
                                if (f->wait_ticks >= 160) {
                                    f->action_state = FIGURE_ACTION_RIOTER_MOVING;
                                    int x_tile, y_tile;
                                    int building_id = formation_rioter_get_target_building(&x_tile, &y_tile);
                                    if (building_id) {
                                        f->destination_x = x_tile;
                                        f->destination_y = y_tile;
                                        f->destination_building_id = building_id;
                                        figure_route_remove(f);
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_RIOTER_MOVING:
                                figure_image_increase_offset(f, 12);
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    int x_tile, y_tile;
                                    int building_id = formation_rioter_get_target_building(&x_tile, &y_tile);
                                    if (building_id) {
                                        f->destination_x = x_tile;
                                        f->destination_y = y_tile;
                                        f->destination_building_id = building_id;
                                        figure_route_remove(f);
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                    f->action_state = FIGURE_ACTION_RIOTER_CREATED;
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_ATTACK) {
                                    if (f->image_offset > 12) {
                                        f->image_offset = 0;
                                    }
                                }
                                break;
                        }
                        int dir;
                        if (f->direction == DIR_FIGURE_ATTACK) {
                            dir = f->attack_direction;
                        } else if (f->direction < 8) {
                            dir = f->direction;
                        } else {
                            dir = f->previous_tile_direction;
                        }
                        dir = figure_image_normalize_direction(dir);

                        if (f->direction == DIR_FIGURE_ATTACK) {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_CRIMINAL] + 104 + CRIMINAL_OFFSETS[f->image_offset % 16];
                        } else if (f->action_state == FIGURE_ACTION_RIOTER_MOVING) {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_CRIMINAL] + dir + 8 * f->image_offset;
                        } else {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_CRIMINAL] + 104 + CRIMINAL_OFFSETS[f->image_offset / 2];
                        }
                    }
                    break;
                    case FIGURE_TRADE_CARAVAN:
                        f->is_invisible = 0;
                        figure_image_increase_offset(f, 12);
                        switch (f->action_state) {
                            case FIGURE_ACTION_TRADE_CARAVAN_CREATED:
                                f->is_invisible = 1;
                                f->wait_ticks++;
                                if (f->wait_ticks > 20) {
                                    f->wait_ticks = 0;
                                    int x_base, y_base;
                                    if (city_data.building.trade_center_building_id) {
                                        struct building_t *trade_center = &all_buildings[city_data.building.trade_center_building_id];
                                        x_base = trade_center->x;
                                        y_base = trade_center->y;
                                    } else {
                                        x_base = f->x;
                                        y_base = f->y;
                                    }
                                    go_to_next_warehouse(f, x_base, y_base);
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_TRADE_CARAVAN_ARRIVING:
                                walk_ticks(f, 1, 0);
                                switch (f->direction) {
                                    case DIR_FIGURE_AT_DESTINATION:
                                        f->action_state = FIGURE_ACTION_TRADE_CARAVAN_TRADING;
                                        break;
                                    case DIR_FIGURE_REROUTE:
                                        figure_route_remove(f);
                                        break;
                                    case DIR_FIGURE_LOST:
                                        figure_delete(f);
                                        return;
                                }
                                if (all_buildings[f->destination_building_id].state != BUILDING_STATE_IN_USE) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_TRADE_CARAVAN_TRADING:
                                f->wait_ticks++;
                                if (f->wait_ticks > 10) {
                                    f->wait_ticks = 0;
                                    int move_on = 0;
                                    if (figure_trade_caravan_can_buy(f, f->destination_building_id, f->empire_city_id)) {
                                        int resource = trader_get_buy_resource(f->destination_building_id, f->empire_city_id);
                                        if (resource) {
                                            empire_objects[f->empire_city_id].resource_bought[resource]++;
                                            trader_record_bought_resource(f->trader_id, resource);
                                            f->trader_amount_bought++;
                                        } else {
                                            move_on++;
                                        }
                                    } else {
                                        move_on++;
                                    }
                                    if (figure_trade_caravan_can_sell(f, f->destination_building_id, f->empire_city_id)) {
                                        int resource = RESOURCE_NONE;
                                        struct building_t *warehouse = &all_buildings[f->destination_building_id];
                                        if (warehouse->type == BUILDING_WAREHOUSE) {
                                            int resource_to_import = city_data.trade.caravan_import_resource;
                                            int imp = RESOURCE_WHEAT;
                                            while (imp < RESOURCE_TYPES_MAX && !can_import_resource_from_trade_city(f->empire_city_id, resource_to_import)) {
                                                imp++;
                                                resource_to_import = city_trade_next_caravan_import_resource();
                                            }
                                            if (imp < RESOURCE_TYPES_MAX) {
                                                // add to existing bay with room
                                                struct building_t *space = warehouse;
                                                for (int k = 0; k < 8; k++) {
                                                    space = &all_buildings[space->next_part_building_id];
                                                    if (space->id > 0 && space->loads_stored > 0 && space->loads_stored < 4 &&
                                                        space->subtype.warehouse_resource_id == resource_to_import) {
                                                        building_warehouse_space_add_import(space, resource_to_import);
                                                        city_trade_next_caravan_import_resource();
                                                        resource = resource_to_import;
                                                        break;
                                                    }
                                                }
                                                if (!resource) {
                                                    // add to empty bay
                                                    space = warehouse;
                                                    for (int k = 0; k < 8; k++) {
                                                        space = &all_buildings[space->next_part_building_id];
                                                        if (space->id > 0 && !space->loads_stored) {
                                                            building_warehouse_space_add_import(space, resource_to_import);
                                                            city_trade_next_caravan_import_resource();
                                                            resource = resource_to_import;
                                                        }
                                                    }
                                                    if (!resource) {
                                                        // find another importable resource that can be added to this warehouse
                                                        for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                                            city_data.trade.caravan_backup_import_resource++;
                                                            if (city_data.trade.caravan_backup_import_resource >= RESOURCE_TYPES_MAX) {
                                                                city_data.trade.caravan_backup_import_resource = RESOURCE_WHEAT;
                                                            }
                                                            resource_to_import = city_data.trade.caravan_backup_import_resource;
                                                            if (can_import_resource_from_trade_city(f->empire_city_id, resource_to_import)) {
                                                                space = warehouse;
                                                                for (int k = 0; k < 8; k++) {
                                                                    space = &all_buildings[space->next_part_building_id];
                                                                    if (space->id > 0 && space->loads_stored < 4
                                                                        && space->subtype.warehouse_resource_id == resource_to_import) {
                                                                        building_warehouse_space_add_import(space, resource_to_import);
                                                                        resource = resource_to_import;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        if (resource) {
                                            empire_objects[f->empire_city_id].resource_sold[resource]++;
                                            trader_record_sold_resource(f->trader_id, resource);
                                            f->loads_sold_or_carrying++;
                                        } else {
                                            move_on++;
                                        }
                                    } else {
                                        move_on++;
                                    }
                                    if (move_on == 2) {
                                        go_to_next_warehouse(f, f->x, f->y);
                                    }
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_TRADE_CARAVAN_LEAVING:
                                walk_ticks(f, 1, 0);
                                switch (f->direction) {
                                    case DIR_FIGURE_AT_DESTINATION:
                                        f->action_state = FIGURE_ACTION_TRADE_CARAVAN_CREATED;
                                        figure_delete(f);
                                        return;
                                    case DIR_FIGURE_REROUTE:
                                        figure_route_remove(f);
                                        break;
                                    case DIR_FIGURE_LOST:
                                        figure_delete(f);
                                        return;
                                }
                                break;
                        }
                        int dir = figure_image_normalize_direction(f->direction < 8 ? f->direction : f->previous_tile_direction);
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_TRADE_CARAVAN] + dir + 8 * f->image_offset;
                        break;
                    case FIGURE_TRADE_CARAVAN_DONKEY:
                    {
                        f->is_invisible = 0;
                        figure_image_increase_offset(f, 12);
                        struct figure_t *leader = &figures[f->leading_figure_id];
                        if (f->leading_figure_id <= 0) {
                            figure_delete(f);
                            return;
                        } else {
                            if (leader->type != FIGURE_TRADE_CARAVAN && leader->type != FIGURE_TRADE_CARAVAN_DONKEY) {
                                figure_delete(f);
                                return;
                            } else {
                                figure_movement_follow_ticks(f, 1);
                            }
                        }
                        if (leader->is_invisible) {
                            f->is_invisible = 1;
                        }
                        dir = figure_image_normalize_direction(f->direction < 8 ? f->direction : f->previous_tile_direction);
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_TRADE_CARAVAN] + dir + 8 * f->image_offset;
                        break;
                    }
                    case FIGURE_TRADE_SHIP:
                        f->is_invisible = 0;
                        figure_image_increase_offset(f, 12);
                        switch (f->action_state) {
                            case FIGURE_ACTION_TRADE_SHIP_CREATED:
                                f->loads_sold_or_carrying = 12;
                                f->trader_amount_bought = 0;
                                f->is_invisible = 1;
                                f->wait_ticks++;
                                if (f->wait_ticks > 20) {
                                    f->wait_ticks = 0;
                                    struct map_point_t tile;
                                    int dock_id = building_dock_get_free_destination(f->id, &tile);
                                    if (dock_id) {
                                        f->destination_building_id = dock_id;
                                        f->action_state = FIGURE_ACTION_TRADE_SHIP_GOING_TO_DOCK;
                                        f->destination_x = tile.x;
                                        f->destination_y = tile.y;
                                    } else if (building_dock_get_queue_destination(&tile)) {
                                        f->action_state = FIGURE_ACTION_TRADE_SHIP_GOING_TO_DOCK_QUEUE;
                                        f->destination_x = tile.x;
                                        f->destination_y = tile.y;
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_TRADE_SHIP_GOING_TO_DOCK:
                                walk_ticks(f, 1, 0);
                                f->height_adjusted_ticks = 0;
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_TRADE_SHIP_MOORED;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    if (!message_data.message_count[MESSAGE_CAT_BLOCKED_DOCK]) {
                                        city_message_post(1, MESSAGE_NAVIGATION_IMPOSSIBLE, 0, 0);
                                        message_data.message_count[MESSAGE_CAT_BLOCKED_DOCK]++;
                                    }
                                    return;
                                }
                                if (all_buildings[f->destination_building_id].state != BUILDING_STATE_IN_USE) {
                                    f->action_state = FIGURE_ACTION_TRADE_SHIP_LEAVING;
                                    f->wait_ticks = 0;
                                    f->destination_x = scenario.river_exit_point.x;
                                    f->destination_y = scenario.river_exit_point.y;
                                }
                                break;
                            case FIGURE_ACTION_TRADE_SHIP_MOORED:
                            {
                                int trade_ship_done_trading = 1;
                                struct building_t *b = &all_buildings[f->destination_building_id];
                                if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_DOCK && b->num_workers > 0) {
                                    for (int k = 0; k < 3; k++) {
                                        if (b->data.dock.docker_ids[k]) {
                                            struct figure_t *docker = &figures[b->data.dock.docker_ids[k]];
                                            if (figure_is_alive(docker) && docker->action_state != FIGURE_ACTION_DOCKER_IDLING) {
                                                trade_ship_done_trading = 0;
                                                break;
                                            }
                                        }
                                    }
                                }
                                int trade_ship_lost_queue = 1;
                                if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_DOCK && b->num_workers > 0 && b->data.dock.trade_ship_id == f->id) {
                                    trade_ship_lost_queue = 0;
                                }
                                if (trade_ship_lost_queue) {
                                    f->trade_ship_failed_dock_attempts = 0;
                                    f->action_state = FIGURE_ACTION_TRADE_SHIP_LEAVING;
                                    f->wait_ticks = 0;
                                    f->destination_x = scenario.river_entry_point.x;
                                    f->destination_y = scenario.river_entry_point.y;
                                } else if (trade_ship_done_trading) {
                                    f->trade_ship_failed_dock_attempts = 0;
                                    f->action_state = FIGURE_ACTION_TRADE_SHIP_LEAVING;
                                    f->wait_ticks = 0;
                                    f->destination_x = scenario.river_entry_point.x;
                                    f->destination_y = scenario.river_entry_point.y;
                                    struct building_t *dst = &all_buildings[f->destination_building_id];
                                    dst->data.dock.queued_docker_id = 0;
                                    dst->data.dock.num_ships = 0;
                                }
                                switch (all_buildings[f->destination_building_id].data.dock.orientation) {
                                    case 0: f->direction = DIR_2_RIGHT; break;
                                    case 1: f->direction = DIR_4_BOTTOM; break;
                                    case 2: f->direction = DIR_6_LEFT; break;
                                    default:f->direction = DIR_0_TOP; break;
                                }
                                f->image_offset = 0;
                                message_data.message_count[MESSAGE_CAT_BLOCKED_DOCK] = 0;
                                break;
                            }
                            case FIGURE_ACTION_TRADE_SHIP_GOING_TO_DOCK_QUEUE:
                                walk_ticks(f, 1, 0);
                                f->height_adjusted_ticks = 0;
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_TRADE_SHIP_ANCHORED;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_TRADE_SHIP_ANCHORED:
                                f->wait_ticks++;
                                if (f->wait_ticks > 40) {
                                    struct map_point_t tile;
                                    int dock_id = building_dock_get_free_destination(f->id, &tile);
                                    if (dock_id) {
                                        f->destination_building_id = dock_id;
                                        f->action_state = FIGURE_ACTION_TRADE_SHIP_GOING_TO_DOCK;
                                        f->destination_x = tile.x;
                                        f->destination_y = tile.y;
                                    } else if (map_grid_is_valid_offset(f->grid_offset) ? map_figures.items[f->grid_offset] : 0 != f->id &&
                                        building_dock_get_queue_destination(&tile)) {
                                        f->action_state = FIGURE_ACTION_TRADE_SHIP_GOING_TO_DOCK_QUEUE;
                                        f->destination_x = tile.x;
                                        f->destination_y = tile.y;
                                    }
                                    f->wait_ticks = 0;
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_TRADE_SHIP_LEAVING:
                                walk_ticks(f, 1, 0);
                                f->height_adjusted_ticks = 0;
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_TRADE_SHIP_CREATED;
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                        }
                        dir = figure_image_normalize_direction(f->direction < 8 ? f->direction : f->previous_tile_direction);
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_SHIP] + dir;
                        break;
                    case FIGURE_INDIGENOUS_NATIVE:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        if (b->state != BUILDING_STATE_IN_USE || b->figure_id != f->id) {
                            figure_delete(f);
                            return;
                        }
                        figure_image_increase_offset(f, 12);
                        switch (f->action_state) {
                            case FIGURE_ACTION_NATIVE_GOING_TO_MEETING_CENTER:
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_NATIVE_RETURNING_FROM_MEETING;
                                    f->destination_x = f->source_x;
                                    f->destination_y = f->source_y;
                                } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_NATIVE_RETURNING_FROM_MEETING:
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION ||
                                    f->direction == DIR_FIGURE_REROUTE ||
                                    f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_NATIVE_CREATED:
                            {
                                f->image_offset = 0;
                                f->wait_ticks++;
                                if (f->wait_ticks > 10 + (f->id & 3)) {
                                    f->wait_ticks = 0;
                                    if (city_data.military.native_attack_duration) {
                                        f->action_state = FIGURE_ACTION_NATIVE_ATTACKING;
                                        struct building_t *min_building = 0;
                                        int min_distance = 10000;
                                        for (int k = 1; k < MAX_BUILDINGS; k++) {
                                            b = &all_buildings[k];
                                            if (b->state != BUILDING_STATE_IN_USE) {
                                                continue;
                                            }
                                            switch (b->type) {
                                                case BUILDING_MISSION_POST:
                                                case BUILDING_FORT_LEGIONARIES:
                                                case BUILDING_FORT_JAVELIN:
                                                case BUILDING_FORT_MOUNTED:
                                                case BUILDING_FORT_GROUND:
                                                case BUILDING_NATIVE_HUT:
                                                case BUILDING_NATIVE_CROPS:
                                                case BUILDING_NATIVE_MEETING:
                                                case BUILDING_WAREHOUSE:
                                                    break;
                                                default:
                                                {
                                                    int distance = calc_maximum_distance(city_data.building.main_native_meeting.x, city_data.building.main_native_meeting.y, b->x, b->y);
                                                    if (distance < min_distance) {
                                                        min_building = b;
                                                        min_distance = distance;
                                                    }
                                                }
                                            }
                                        }
                                        if (min_building) {
                                            f->destination_x = min_building->x;
                                            f->destination_y = min_building->y;
                                        }
                                    } else {
                                        int x_tile, y_tile;
                                        struct building_t *meeting = &all_buildings[b->subtype.native_meeting_center_id];
                                        if (map_terrain_get_adjacent_road_or_clear_land(
                                            meeting->x, meeting->y, meeting->size, &x_tile, &y_tile)) {
                                            f->action_state = FIGURE_ACTION_NATIVE_GOING_TO_MEETING_CENTER;
                                            f->destination_x = x_tile;
                                            f->destination_y = y_tile;
                                        }
                                    }
                                    figure_route_remove(f);
                                }
                                break;
                            }
                            case FIGURE_ACTION_NATIVE_ATTACKING:
                                f->terrain_usage = TERRAIN_USAGE_ENEMY;
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION ||
                                    f->direction == DIR_FIGURE_REROUTE ||
                                    f->direction == DIR_FIGURE_LOST) {
                                    f->action_state = FIGURE_ACTION_NATIVE_CREATED;
                                }
                                break;
                        }
                        dir = get_direction(f);
                        if (f->action_state == FIGURE_ACTION_NATIVE_ATTACKING) {
                            f->image_id = 297 + dir + 8 * f->image_offset;
                        } else {
                            f->image_id = 201 + dir + 8 * f->image_offset;
                        }
                    }
                    break;
                    case FIGURE_NATIVE_TRADER:
                        f->is_invisible = 0;
                        figure_image_increase_offset(f, 12);
                        f->cart_image_id = 0;
                        switch (f->action_state) {
                            case FIGURE_ACTION_NATIVE_TRADER_GOING_TO_WAREHOUSE:
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_NATIVE_TRADER_AT_WAREHOUSE;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                if (all_buildings[f->destination_building_id].state != BUILDING_STATE_IN_USE) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_NATIVE_TRADER_RETURNING:
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                }
                                break;
                            case FIGURE_ACTION_NATIVE_TRADER_CREATED:
                                f->is_invisible = 1;
                                f->wait_ticks++;
                                if (f->wait_ticks > 10) {
                                    f->wait_ticks = 0;
                                    struct map_point_t tile;
                                    int building_id = get_closest_warehouse(f, f->x, f->y, 0, &tile);
                                    if (building_id) {
                                        f->action_state = FIGURE_ACTION_NATIVE_TRADER_GOING_TO_WAREHOUSE;
                                        f->destination_building_id = building_id;
                                        f->destination_x = tile.x;
                                        f->destination_y = tile.y;
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_NATIVE_TRADER_AT_WAREHOUSE:
                                f->wait_ticks++;
                                if (f->wait_ticks > 10) {
                                    f->wait_ticks = 0;
                                    if (figure_trade_caravan_can_buy(f, f->destination_building_id, 0)) {
                                        int resource = trader_get_buy_resource(f->destination_building_id, 0);
                                        trader_record_bought_resource(f->trader_id, resource);
                                        f->trader_amount_bought += 3;
                                    } else {
                                        struct map_point_t tile;
                                        int building_id = get_closest_warehouse(f, f->x, f->y, 0, &tile);
                                        if (building_id) {
                                            f->action_state = FIGURE_ACTION_NATIVE_TRADER_GOING_TO_WAREHOUSE;
                                            f->destination_building_id = building_id;
                                            f->destination_x = tile.x;
                                            f->destination_y = tile.y;
                                        } else {
                                            f->action_state = FIGURE_ACTION_NATIVE_TRADER_RETURNING;
                                            f->destination_x = f->source_x;
                                            f->destination_y = f->source_y;
                                        }
                                    }
                                }
                                f->image_offset = 0;
                                break;
                        }
                        dir = figure_image_normalize_direction(f->direction < 8 ? f->direction : f->previous_tile_direction);
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_CARTPUSHER] + dir + 8 * f->image_offset;
                        f->cart_image_id = image_data_s.group_image_ids[GROUP_FIGURE_MIGRANT_CART] + 8 + 8 * f->resource_id;
                        if (f->cart_image_id) {
                            f->cart_image_id += dir;
                            figure_image_set_cart_offset(f, dir);
                        }
                        break;
                    case FIGURE_WOLF:
                    {
                        struct formation_t *m = &herd_formations[f->formation_id];
                        figure_image_increase_offset(f, 12);
                        switch (f->action_state) {
                            case FIGURE_ACTION_HERD_ANIMAL_AT_REST:
                                // replenish wolf pack
                                if (m->num_figures < m->max_figures) {
                                    m->wolf_spawn_delay++;
                                    if (m->wolf_spawn_delay > 1500) {
                                        int spawn_location_x = m->destination_x + HERD_FORMATION_LAYOUT_POSITION_X_OFFSETS[WOLF_PACK_SIZE - 1];
                                        int spawn_location_y = m->destination_y + HERD_FORMATION_LAYOUT_POSITION_Y_OFFSETS[WOLF_PACK_SIZE - 1];
                                        if (!map_terrain_is(map_grid_offset(spawn_location_x, spawn_location_y), TERRAIN_IMPASSABLE)) {
                                            struct figure_t *wolf = figure_create(m->figure_type, spawn_location_x, spawn_location_y, f->direction);
                                            wolf->action_state = FIGURE_ACTION_HERD_ANIMAL_AT_REST;
                                            wolf->formation_id = m->id;
                                            m->wolf_spawn_delay = 0;
                                        }
                                    }
                                }
                                break;
                            case FIGURE_ACTION_HERD_ANIMAL_MOVING:
                            {
                                struct figure_t *target = melee_unit__set_closest_target(f);
                                if (target) {
                                    walk_ticks(f, 2, 0);
                                    random_generate_next();
                                    if (random_data.random1_7bit < 3) {
                                        play_sound_effect(SOUND_EFFECT_WOLF_HOWL);
                                    }
                                    break;
                                } else {
                                    walk_ticks(f, 2, 0);
                                    if (f->direction == DIR_FIGURE_AT_DESTINATION || f->direction == DIR_FIGURE_LOST) {
                                        f->direction = f->previous_tile_direction;
                                        f->action_state = FIGURE_ACTION_HERD_ANIMAL_AT_REST;
                                        break;
                                    } else if (f->direction == DIR_FIGURE_REROUTE) {
                                        figure_route_remove(f);
                                        break;
                                    } else if (f->routing_path_current_tile > MAX_WOLF_ROAM_DISTANCE * 2) {
                                        figure_route_remove(f);
                                        m->destination_x = f->x;
                                        m->destination_y = f->y;
                                    }
                                }
                                break;
                            }
                        }
                        dir = figure_image_direction(f);
                        if (f->action_state == FIGURE_ACTION_HERD_ANIMAL_AT_REST) {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_WOLF] + 152 + dir;
                        } else {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_WOLF] + dir + 8 * f->image_offset;
                        }
                    }
                    break;
                    case FIGURE_SHEEP:
                    {
                        figure_image_increase_offset(f, 6);
                        struct formation_t *m = &herd_formations[f->formation_id];
                        switch (f->action_state) {
                            case FIGURE_ACTION_HERD_ANIMAL_AT_REST:
                                f->wait_ticks++;
                                break;
                            case FIGURE_ACTION_HERD_ANIMAL_MOVING:
                                walk_ticks(f, 2, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION || f->direction == DIR_FIGURE_LOST) {
                                    f->direction = f->previous_tile_direction;
                                    f->action_state = FIGURE_ACTION_HERD_ANIMAL_AT_REST;
                                    f->wait_ticks = f->id & 0x1f;
                                    break;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                    break;
                                } else if (f->routing_path_current_tile > MAX_SHEEP_ROAM_DISTANCE * 2) {
                                    figure_route_remove(f);
                                    m->destination_x = f->x;
                                    m->destination_y = f->y;
                                }
                                break;
                        }
                        dir = figure_image_direction(f);
                        if (f->action_state == FIGURE_ACTION_HERD_ANIMAL_AT_REST) {
                            if (f->id & 3) {
                                f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_SHEEP] + 48 + dir + 8 * SHEEP_IMAGE_OFFSETS[f->wait_ticks & 0x3f];
                            } else {
                                f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_SHEEP] + 96 + dir;
                            }
                        } else {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_SHEEP] + dir + 8 * f->image_offset;
                        }
                    }
                    break;
                    case FIGURE_ZEBRA:
                    {
                        figure_image_increase_offset(f, 12);
                        struct formation_t *m = &herd_formations[f->formation_id];
                        switch (f->action_state) {
                            case FIGURE_ACTION_HERD_ANIMAL_AT_REST:
                                break;
                            case FIGURE_ACTION_HERD_ANIMAL_MOVING:
                                walk_ticks(f, 2, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION || f->direction == DIR_FIGURE_LOST) {
                                    f->direction = f->previous_tile_direction;
                                    f->action_state = FIGURE_ACTION_HERD_ANIMAL_AT_REST;
                                    break;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                    break;
                                } else if (f->routing_path_current_tile > MAX_SHEEP_ROAM_DISTANCE * 2) {
                                    figure_route_remove(f);
                                    m->destination_x = f->x;
                                    m->destination_y = f->y;
                                }
                                break;
                        }
                        dir = figure_image_direction(f);
                        if (f->action_state == FIGURE_ACTION_HERD_ANIMAL_AT_REST) {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_ZEBRA] + dir;
                        } else {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_ZEBRA] + dir + 8 * f->image_offset;
                        }
                    }
                    break;
                    case FIGURE_ENEMY_GLADIATOR:
                    {
                        figure_image_increase_offset(f, 12);
                        if (scenario.gladiator_revolt.state == EVENT_FINISHED) {
                            // end of gladiator revolt: kill gladiators
                            f->is_corpse = 1;
                            f->is_targetable = 0;
                            f->wait_ticks = 0;
                            f->direction = 0;
                            clear_targeting_on_unit_death(f);
                        }
                        switch (f->action_state) {
                            case FIGURE_ACTION_NATIVE_CREATED:
                                f->image_offset = 0;
                                f->wait_ticks++;
                                if (f->wait_ticks > 10 + (f->id & 3)) {
                                    f->wait_ticks = 0;
                                    f->action_state = FIGURE_ACTION_NATIVE_ATTACKING;
                                    int x_tile, y_tile;
                                    int building_id = formation_rioter_get_target_building(&x_tile, &y_tile);
                                    if (building_id) {
                                        f->destination_x = x_tile;
                                        f->destination_y = y_tile;
                                        f->destination_building_id = building_id;
                                        figure_route_remove(f);
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_NATIVE_ATTACKING:
                                f->terrain_usage = TERRAIN_USAGE_ENEMY;
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION ||
                                    f->direction == DIR_FIGURE_REROUTE ||
                                    f->direction == DIR_FIGURE_LOST) {
                                    f->action_state = FIGURE_ACTION_NATIVE_CREATED;
                                }
                                break;
                        }
                        dir = get_direction(f);
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_GLADIATOR] + dir + 8 * f->image_offset;
                    }
                    break;
                    case FIGURE_ENEMY_BARBARIAN_SWORDSMAN:
                    case FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN:
                    case FIGURE_ENEMY_BRITON_SWORDSMAN:
                    case FIGURE_ENEMY_CELT_SWORDSMAN:
                    case FIGURE_ENEMY_PICT_SWORDSMAN:
                    case FIGURE_ENEMY_EGYPTIAN_SWORDSMAN:
                    case FIGURE_ENEMY_ETRUSCAN_SWORDSMAN:
                    case FIGURE_ENEMY_SAMNITE_SWORDSMAN:
                    case FIGURE_ENEMY_GAUL_SWORDSMAN:
                    case FIGURE_ENEMY_HELVETIUS_SWORDSMAN:
                    case FIGURE_ENEMY_HUN_SWORDSMAN:
                    case FIGURE_ENEMY_GOTH_SWORDSMAN:
                    case FIGURE_ENEMY_VISIGOTH_SWORDSMAN:
                    case FIGURE_ENEMY_NUMIDIAN_SWORDSMAN:
                    case FIGURE_ENEMY_GREEK_SWORDSMAN:
                    case FIGURE_ENEMY_MACEDONIAN_SWORDSMAN:
                    case FIGURE_ENEMY_PERGAMUM_SWORDSMAN:
                    case FIGURE_ENEMY_IBERIAN_SWORDSMAN:
                    case FIGURE_ENEMY_JUDEAN_SWORDSMAN:
                    case FIGURE_ENEMY_SELEUCID_SWORDSMAN:
                    {
                        figure_image_increase_offset(f, 12);
                        melee_enemy_action(f);
                        dir = get_direction(f);
                        int image_id;
                        if (f->enemy_image_group == ENEMY_IMG_TYPE_BARBARIAN) {
                            image_id = 297;
                        } else {
                            image_id = 449;
                        }
                        f->image_id = image_id + dir + 8 * f->image_offset;
                    }
                    break;
                    case FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT:
                    {
                        figure_image_increase_offset(f, 12);
                        ranged_enemy_action(f);
                        f->image_id = 601 + get_direction(f) + 8 * f->image_offset;
                    }
                    break;
                    case FIGURE_ENEMY_BRITON_CHARIOT:
                    case FIGURE_ENEMY_CELT_CHARIOT:
                    case FIGURE_ENEMY_PICT_CHARIOT:
                    {
                        figure_image_increase_offset(f, 12);
                        melee_enemy_action(f);
                        dir = get_direction(f);
                        f->image_id = 601 + dir + 8 * f->image_offset;
                    }
                    break;
                    case FIGURE_ENEMY_EGYPTIAN_CAMEL:
                    case FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_SAMNITE_SPEAR_THROWER:
                    case FIGURE_ENEMY_GREEK_SPEAR_THROWER:
                    case FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_PERGAMUM_ARCHER:
                    case FIGURE_ENEMY_IBERIAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_JUDEAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_SELEUCID_SPEAR_THROWER:
                    {
                        figure_image_increase_offset(f, 12);
                        ranged_enemy_action(f);
                        dir = get_direction(f);
                        if (f->action_state == FIGURE_ACTION_ENEMY_REGROUPING) {
                            f->image_id = 697 + dir + 8 * MISSILE_LAUNCHER_OFFSETS[f->attack_image_offset / 2];
                        } else {
                            f->image_id = 601 + dir + 8 * f->image_offset;
                        }
                    }
                    break;
                    case FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER:
                    {
                        figure_image_increase_offset(f, 12);
                        ranged_enemy_action(f);
                        dir = get_direction(f);
                        if (f->action_state == FIGURE_ACTION_ENEMY_REGROUPING) {
                            f->image_id = 545 + dir + 8 * MISSILE_LAUNCHER_OFFSETS[f->attack_image_offset / 2];
                        } else {
                            f->image_id = 449 + dir + 8 * f->image_offset;
                        }
                    }
                    break;
                    case FIGURE_ENEMY_GAUL_AXEMAN:
                    case FIGURE_ENEMY_HELVETIUS_AXEMAN:
                    {
                        figure_image_increase_offset(f, 12);
                        melee_enemy_action(f);
                        dir = get_direction(f);
                        f->image_id = 601 + dir + 8 * f->image_offset;
                    }
                    break;
                    case FIGURE_ENEMY_HUN_MOUNTED_ARCHER:
                    case FIGURE_ENEMY_GOTH_MOUNTED_ARCHER:
                    case FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER:
                    {
                        figure_image_increase_offset(f, 12);
                        ranged_enemy_action(f);
                        dir = get_direction(f);
                        if (f->action_state == FIGURE_ACTION_ENEMY_REGROUPING) {
                            f->image_id = 697 + dir + 8 * MISSILE_LAUNCHER_OFFSETS[f->attack_image_offset / 2];
                        } else {
                            f->image_id = 601 + dir + 8 * f->image_offset;
                        }
                    }
                    break;
                    case FIGURE_ENEMY_CAESAR_JAVELIN:
                    case FIGURE_ENEMY_CAESAR_MOUNTED:
                    case FIGURE_ENEMY_CAESAR_LEGIONARY:
                        figure_image_increase_offset(f, 12);
                        melee_enemy_action(f);
                        dir = get_direction(f);
                        int img_group_base_id = image_data_s.group_image_ids[GROUP_FIGURE_CAESAR_LEGIONARY];

                        if (f->direction == DIR_FIGURE_ATTACK) {
                            f->image_id = img_group_base_id + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        }
                        if (f->figure_is_halted && enemy_formations[f->formation_id].missile_attack_timeout) {
                            f->image_id = img_group_base_id + 144 + dir + 8 * f->image_offset;
                        } else {
                            f->image_id = img_group_base_id + 48 + dir + 8 * f->image_offset;
                        }
                        break;
                    case FIGURE_ARROW:
                        f->use_cross_country = 1;
                        f->progress_on_tile++;
                        int should_die = figure_movement_move_ticks_cross_country(f, 8);
                        int target_id = get_target_on_tile(f);
                        if (target_id) {
                            struct figure_t *target = &figures[target_id];
                            missile_hit_target(f, target);
                            play_sound_effect(SOUND_EFFECT_ARROW_HIT);
                        }
                        dir = (16 + f->direction - 2 * view_data.orientation) % 16;
                        f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_MISSILE] + 16 + dir;
                        if (f->progress_on_tile > 120) {
                            figure_delete(f);
                        }
                        if (should_die || target_id) {
                            figure_delete(f);
                        }
                        break;
                    case FIGURE_MAP_FLAG:
                        figure_editor_flag_action(f);
                        break;
                    case FIGURE_EXPLOSION:
                        f->use_cross_country = 1;
                        f->progress_on_tile++;
                        if (f->progress_on_tile > 44) {
                            figure_delete(f);
                            return;
                        }
                        figure_movement_move_ticks_cross_country(f, f->speed_multiplier);
                        if (f->progress_on_tile < 48) {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_EXPLOSION] + CLOUD_IMAGE_OFFSETS[f->progress_on_tile / 2];
                        } else {
                            f->image_id = image_data_s.group_image_ids[GROUP_FIGURE_EXPLOSION] + 7;
                        }
                        break;
                    default:
                        break;
                }
            }
        }
        if (window_data.refresh_immediate) {
            break;
        }
    }
}

static void update_screen(void)
{
    SDL_RenderClear(SDL.renderer);
    SDL_UpdateTexture(SDL.texture, 0, canvas.pixels, screen_data.width * 4);
    SDL_RenderCopy(SDL.renderer, SDL.texture, 0, 0);
}

// #ifdef DRAW_FPS
// static struct {
//     int frame_count;
//     int last_fps;
//     Uint32 last_update_time;
// } fps;
// static void run_and_draw(void)
// {
//     uint32_t time_before_run = SDL_GetTicks();
//     current_time = time_before_run;

//     game_run();
//     Uint32 time_between_run_and_draw = SDL_GetTicks();
//     game_draw();
//     Uint32 time_after_draw = SDL_GetTicks();

//     fps.frame_count++;
//     if (time_after_draw - fps.last_update_time > 1000) {
//         fps.last_fps = fps.frame_count;
//         fps.last_update_time = time_after_draw;
//         fps.frame_count = 0;
//     }
//     if (window_data.current_window->id == WINDOW_CITY || window_data.current_window->id WINDOW_CITY_MILITARY || window_data.current_window->id == WINDOW_SLIDING_SIDEBAR) {
//         int y_offset = 24;
//         int y_offset_text = y_offset + 5;
//         graphics_fill_rect(0, y_offset, 100, 20, COLOR_WHITE);
//         text_draw_number_colored(fps.last_fps,
//             'f', "", 5, y_offset_text, FONT_NORMAL_PLAIN, COLOR_FONT_RED);
//         text_draw_number_colored(time_between_run_and_draw - time_before_run,
//             'g', "", 40, y_offset_text, FONT_NORMAL_PLAIN, COLOR_FONT_RED);
//         text_draw_number_colored(time_after_draw - time_between_run_and_draw,
//             'd', "", 70, y_offset_text, FONT_NORMAL_PLAIN, COLOR_FONT_RED);
//     }
//     update_screen();
//     SDL_RenderPresent(SDL.renderer);
// }
// #else
static void run_and_draw(void)
{
    current_time = SDL_GetTicks();
    game_run();
    game_draw();
    update_screen();
    SDL_RenderPresent(SDL.renderer);
}
// #endif

static void handle_mouse_button(SDL_MouseButtonEvent *event, int is_down)
{
    if (!SDL_GetRelativeMouseMode()) {
        mouse_set_position(event->x, event->y);
    }
    if (event->button == SDL_BUTTON_LEFT) {
        mouse_data.left.system_change |= is_down ? SYSTEM_DOWN : SYSTEM_UP;
        mouse_data.is_inside_window = 1;
        if (!is_down) {
            uint32_t now = current_time;
            int is_double_click = (last_click < now) && ((now - last_click) <= DOUBLE_CLICK_TIME);
            mouse_data.left.system_change |= is_double_click ? SYSTEM_DOUBLE_CLICK : SYSTEM_NONE;
            last_click = now;
        }
    } else if (event->button == SDL_BUTTON_RIGHT) {
        mouse_data.right.system_change |= is_down ? SYSTEM_DOWN : SYSTEM_UP;
        mouse_data.is_inside_window = 1;
        last_click = 0;
    }
}

static int scale_pixels_to_logical(int pixel_value)
{
    return pixel_value * 100 / scale_percentage;
}

static void destroy_screen_texture(void)
{
    SDL_DestroyTexture(SDL.texture);
    SDL.texture = 0;
}

static void setting_set_display(int fullscreen, int width, int height)
{
    settings_values[SETTINGS_FULLSCREEN] = fullscreen;
    if (!fullscreen) {
        settings_values[SETTINGS_WINDOW_WIDTH] = width;
        settings_values[SETTINGS_WINDOW_HEIGHT] = height;
    }
}

static int resize_screen(int pixel_width, int pixel_height)
{
    int logical_width = scale_pixels_to_logical(pixel_width);
    int logical_height = scale_pixels_to_logical(pixel_height);

    if (SDL.texture) {
        if (logical_width == screen_data.width && logical_height == screen_data.height) {
            return 1;
        }
        destroy_screen_texture();
    }

    SDL_RenderSetLogicalSize(SDL.renderer, logical_width, logical_height);

    setting_set_display(settings_values[SETTINGS_FULLSCREEN], logical_width, logical_height);
    SDL.texture = SDL_CreateTexture(SDL.renderer,
        SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STREAMING,
        logical_width, logical_height);

    if (SDL.texture) {
        SDL_Log("Texture created: %d x %d", logical_width, logical_height);
        screen_set_resolution(logical_width, logical_height);
        return 1;
    } else {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unable to create texture: %s", SDL_GetError());
        return 0;
    }
}

static void handle_window_event(SDL_WindowEvent *event, int *window_active)
{
    switch (event->event) {
        case SDL_WINDOWEVENT_ENTER:
            mouse_data.is_inside_window = 1;
            break;
        case SDL_WINDOWEVENT_LEAVE:
            mouse_data.is_inside_window = 0;
            break;
        case SDL_WINDOWEVENT_SIZE_CHANGED:
            SDL_Log("Window resized to %d x %d", (int) event->data1, (int) event->data2);
            resize_screen(event->data1, event->data2);
            break;
        case SDL_WINDOWEVENT_RESIZED:
            SDL_Log("System resize to %d x %d", (int) event->data1, (int) event->data2);
            break;
        case SDL_WINDOWEVENT_MOVED:
            SDL_Log("Window move to coordinates x: %d y: %d\n", (int) event->data1, (int) event->data2);
            if (!settings_values[SETTINGS_FULLSCREEN]) {
                window_pos.x = event->data1;
                window_pos.y = event->data2;
                window_pos.centered = 0;
            }
            break;
        case SDL_WINDOWEVENT_SHOWN:
            SDL_Log("Window %u shown", event->windowID);
            *window_active = 1;
            break;
        case SDL_WINDOWEVENT_HIDDEN:
            SDL_Log("Window %u hidden", event->windowID);
            *window_active = 0;
            break;
    }
}

static int get_key_from_scancode(SDL_Scancode scancode)
{
    switch (scancode) {
        case SDL_SCANCODE_A: return KEY_TYPE_A;
        case SDL_SCANCODE_B: return KEY_TYPE_B;
        case SDL_SCANCODE_C: return KEY_TYPE_C;
        case SDL_SCANCODE_D: return KEY_TYPE_D;
        case SDL_SCANCODE_E: return KEY_TYPE_E;
        case SDL_SCANCODE_F: return KEY_TYPE_F;
        case SDL_SCANCODE_G: return KEY_TYPE_G;
        case SDL_SCANCODE_H: return KEY_TYPE_H;
        case SDL_SCANCODE_I: return KEY_TYPE_I;
        case SDL_SCANCODE_J: return KEY_TYPE_J;
        case SDL_SCANCODE_K: return KEY_TYPE_K;
        case SDL_SCANCODE_L: return KEY_TYPE_L;
        case SDL_SCANCODE_M: return KEY_TYPE_M;
        case SDL_SCANCODE_N: return KEY_TYPE_N;
        case SDL_SCANCODE_O: return KEY_TYPE_O;
        case SDL_SCANCODE_P: return KEY_TYPE_P;
        case SDL_SCANCODE_Q: return KEY_TYPE_Q;
        case SDL_SCANCODE_R: return KEY_TYPE_R;
        case SDL_SCANCODE_S: return KEY_TYPE_S;
        case SDL_SCANCODE_T: return KEY_TYPE_T;
        case SDL_SCANCODE_U: return KEY_TYPE_U;
        case SDL_SCANCODE_V: return KEY_TYPE_V;
        case SDL_SCANCODE_W: return KEY_TYPE_W;
        case SDL_SCANCODE_X: return KEY_TYPE_X;
        case SDL_SCANCODE_Y: return KEY_TYPE_Y;
        case SDL_SCANCODE_Z: return KEY_TYPE_Z;
        case SDL_SCANCODE_1: return KEY_TYPE_1;
        case SDL_SCANCODE_2: return KEY_TYPE_2;
        case SDL_SCANCODE_3: return KEY_TYPE_3;
        case SDL_SCANCODE_4: return KEY_TYPE_4;
        case SDL_SCANCODE_5: return KEY_TYPE_5;
        case SDL_SCANCODE_6: return KEY_TYPE_6;
        case SDL_SCANCODE_7: return KEY_TYPE_7;
        case SDL_SCANCODE_8: return KEY_TYPE_8;
        case SDL_SCANCODE_9: return KEY_TYPE_9;
        case SDL_SCANCODE_0: return KEY_TYPE_0;
        case SDL_SCANCODE_RETURN: return KEY_TYPE_ENTER;
        case SDL_SCANCODE_ESCAPE: return KEY_TYPE_ESCAPE;
        case SDL_SCANCODE_BACKSPACE: return KEY_TYPE_BACKSPACE;
        case SDL_SCANCODE_TAB: return KEY_TYPE_TAB;
        case SDL_SCANCODE_SPACE: return KEY_TYPE_SPACE;
        case SDL_SCANCODE_MINUS: return KEY_TYPE_MINUS;
        case SDL_SCANCODE_EQUALS: return KEY_TYPE_EQUALS;
        case SDL_SCANCODE_LEFTBRACKET: return KEY_TYPE_LEFTBRACKET;
        case SDL_SCANCODE_RIGHTBRACKET: return KEY_TYPE_RIGHTBRACKET;
        case SDL_SCANCODE_BACKSLASH: return KEY_TYPE_BACKSLASH;
        case SDL_SCANCODE_SEMICOLON: return KEY_TYPE_SEMICOLON;
        case SDL_SCANCODE_APOSTROPHE: return KEY_TYPE_APOSTROPHE;
        case SDL_SCANCODE_GRAVE: return KEY_TYPE_GRAVE;
        case SDL_SCANCODE_COMMA: return KEY_TYPE_COMMA;
        case SDL_SCANCODE_PERIOD: return KEY_TYPE_PERIOD;
        case SDL_SCANCODE_SLASH: return KEY_TYPE_SLASH;
        case SDL_SCANCODE_CAPSLOCK: return KEY_TYPE_CAPSLOCK;
        case SDL_SCANCODE_F1: return KEY_TYPE_F1;
        case SDL_SCANCODE_F2: return KEY_TYPE_F2;
        case SDL_SCANCODE_F3: return KEY_TYPE_F3;
        case SDL_SCANCODE_F4: return KEY_TYPE_F4;
        case SDL_SCANCODE_F5: return KEY_TYPE_F5;
        case SDL_SCANCODE_F6: return KEY_TYPE_F6;
        case SDL_SCANCODE_F7: return KEY_TYPE_F7;
        case SDL_SCANCODE_F8: return KEY_TYPE_F8;
        case SDL_SCANCODE_F9: return KEY_TYPE_F9;
        case SDL_SCANCODE_F10: return KEY_TYPE_F10;
        case SDL_SCANCODE_F11: return KEY_TYPE_F11;
        case SDL_SCANCODE_F12: return KEY_TYPE_F12;
        case SDL_SCANCODE_INSERT: return KEY_TYPE_INSERT;
        case SDL_SCANCODE_HOME: return KEY_TYPE_HOME;
        case SDL_SCANCODE_PAGEUP: return KEY_TYPE_PAGEUP;
        case SDL_SCANCODE_DELETE: return KEY_TYPE_DELETE;
        case SDL_SCANCODE_END: return KEY_TYPE_END;
        case SDL_SCANCODE_PAGEDOWN: return KEY_TYPE_PAGEDOWN;
        case SDL_SCANCODE_RIGHT: return KEY_TYPE_RIGHT;
        case SDL_SCANCODE_LEFT: return KEY_TYPE_LEFT;
        case SDL_SCANCODE_DOWN: return KEY_TYPE_DOWN;
        case SDL_SCANCODE_UP: return KEY_TYPE_UP;
        case SDL_SCANCODE_KP_ENTER: return KEY_TYPE_ENTER;
        case SDL_SCANCODE_KP_1: return KEY_TYPE_KP_1;
        case SDL_SCANCODE_KP_2: return KEY_TYPE_KP_2;
        case SDL_SCANCODE_KP_3: return KEY_TYPE_KP_3;
        case SDL_SCANCODE_KP_4: return KEY_TYPE_KP_4;
        case SDL_SCANCODE_KP_5: return KEY_TYPE_KP_5;
        case SDL_SCANCODE_KP_6: return KEY_TYPE_KP_6;
        case SDL_SCANCODE_KP_7: return KEY_TYPE_KP_7;
        case SDL_SCANCODE_KP_8: return KEY_TYPE_KP_8;
        case SDL_SCANCODE_KP_9: return KEY_TYPE_KP_9;
        case SDL_SCANCODE_KP_0: return KEY_TYPE_KP_0;
        case SDL_SCANCODE_KP_PERIOD: return KEY_TYPE_KP_PERIOD;
        case SDL_SCANCODE_KP_PLUS: return KEY_TYPE_KP_PLUS;
        case SDL_SCANCODE_KP_MINUS: return KEY_TYPE_KP_MINUS;
        case SDL_SCANCODE_KP_MULTIPLY: return KEY_TYPE_KP_MULTIPLY;
        case SDL_SCANCODE_KP_DIVIDE: return KEY_TYPE_KP_DIVIDE;
        case SDL_SCANCODE_NONUSBACKSLASH: return KEY_TYPE_NON_US;
        default: return KEY_TYPE_NONE;
    }
}

static int get_modifier(int mod)
{
    int key_mod = KEY_MOD_NONE;
    if (mod & KMOD_SHIFT) {
        key_mod |= KEY_MOD_SHIFT;
    }
    if (mod & KMOD_CTRL) {
        key_mod |= KEY_MOD_CTRL;
    }
    if (mod & KMOD_ALT) {
        key_mod |= KEY_MOD_ALT;
    }
    if (mod & KMOD_GUI) {
        key_mod |= KEY_MOD_GUI;
    }
    return key_mod;
}

static void center_window(void)
{
    int display = SDL_GetWindowDisplayIndex(SDL.window);
    SDL_SetWindowPosition(SDL.window,
        SDL_WINDOWPOS_CENTERED_DISPLAY(display), SDL_WINDOWPOS_CENTERED_DISPLAY(display));
    window_pos.centered = 1;
}

static void keyboard_right(void)
{
    if (keyboard_data.capture) {
        if (keyboard_data.cursor_position < keyboard_data.length) {
            keyboard_data.cursor_position += 1;
            update_viewport(0);
        }
    }
}

static void keyboard_left(void)
{
    if (keyboard_data.capture) {
        if (keyboard_data.cursor_position > 0) {
            keyboard_data.cursor_position--;
            update_viewport(0);
        }
    }
}

static void remove_current_char(void)
{
    while (keyboard_data.text[keyboard_data.cursor_position] < keyboard_data.text[keyboard_data.length]) {
        keyboard_data.text[0] = keyboard_data.text[1];
        keyboard_data.text[keyboard_data.cursor_position]++;
    }
    keyboard_data.text[keyboard_data.cursor_position] = 0;
    keyboard_data.length -= 1;
}

static void setting_window(int *width, int *height)
{
    *width = settings_values[SETTINGS_WINDOW_WIDTH];
    *height = settings_values[SETTINGS_WINDOW_HEIGHT];
}

static void button_close_hotkey_editor_window(int ok, __attribute__((unused)) int param2)
{
    // destroy window before callback call, because there may appear another popup window
    // by design new popup window can't be showed over another popup window
    window_go_back();
    if (ok) {
        hotkey_editor_window_data.callback(hotkey_editor_window_data.action, hotkey_editor_window_data.index, hotkey_editor_window_data.key, hotkey_editor_window_data.modifiers);
    }
}

static void handle_event(SDL_Event *event)
{
    switch (event->type) {
        case SDL_WINDOWEVENT:
            handle_window_event(&event->window, &data.active);
            break;
        case SDL_KEYDOWN:
            // handle keyboard input keys
            switch (event->key.keysym.sym) {
                case SDLK_RETURN:
                case SDLK_KP_ENTER:
                    // only send enter if no modifier is also down
                    if ((event->key.keysym.mod & (KMOD_CTRL | KMOD_ALT | KMOD_GUI)) == 0) {
                        keyboard_data.accepted = 1;
                    }
                    break;
                case SDLK_BACKSPACE:
                    if (keyboard_data.capture && keyboard_data.cursor_position > 0) {
                        keyboard_data.cursor_position--;
                        remove_current_char();
                        update_viewport(1);
                    }
                    break;
                case SDLK_DELETE:
                    if (keyboard_data.capture && keyboard_data.cursor_position < keyboard_data.length) {
                        remove_current_char();
                        update_viewport(1);
                    }
                    break;
                case SDLK_LEFT:
                    keyboard_left();
                    break;
                case SDLK_RIGHT:
                    keyboard_right();
                    break;
                case SDLK_UP:
                    keyboard_left();
                    break;
                case SDLK_DOWN:
                    keyboard_right();
                    break;
                case SDLK_HOME:
                    if (keyboard_data.capture) {
                        keyboard_data.cursor_position = 0;
                        update_viewport(0);
                    }
                    break;
                case SDLK_END:
                    if (keyboard_data.capture) {
                        keyboard_data.cursor_position = keyboard_data.length;
                        update_viewport(0);
                    }
                    break;
                case SDLK_AC_BACK:
                    event->key.keysym.scancode = SDL_SCANCODE_ESCAPE;
                    break;
            }
            // handle struct hotkeys_t
            int key = get_key_from_scancode(event->key.keysym.scancode);
            int modifiers = get_modifier(event->key.keysym.mod);
            if (window_data.current_window->id == WINDOW_HOTKEY_EDITOR) {
                if (key == KEY_TYPE_ENTER && modifiers == KEY_MOD_NONE) {
                    button_close_hotkey_editor_window(1, 0);
                } else if (key == KEY_TYPE_ESCAPE && modifiers == KEY_MOD_NONE) {
                    button_close_hotkey_editor_window(0, 0);
                } else {
                    if (key != KEY_TYPE_NONE) {
                        hotkey_editor_window_data.key = key;
                    }
                    hotkey_editor_window_data.modifiers = modifiers;
                }
            } else if (key != KEY_TYPE_NONE) {
                int found_action = 0;
                for (int i = 0; i < hotkey_data.num_definitions; i++) {
                    struct hotkey_definition_t *def = &hotkey_data.definitions[i];
                    if (def->key == key && def->modifiers == modifiers && (!event->key.repeat || def->repeatable)) {
                        *(def->action) = def->value;
                        found_action = 1;
                    }
                }
                if (!found_action) {
                    for (int i = 0; i < hotkey_data.num_arrows; i++) {
                        struct arrow_definition_t *arrow = &hotkey_data.arrows[i];
                        if (arrow->key == key) {
                            arrow->action(1);
                        }
                    }
                }
            }
            break;
        case SDL_KEYUP:
            if (window_data.current_window->id == WINDOW_HOTKEY_EDITOR) {
                // update modifiers as long as we don't have a proper keypress
                if (hotkey_editor_window_data.key == KEY_TYPE_NONE && get_key_from_scancode(event->key.keysym.scancode) == KEY_TYPE_NONE) {
                    hotkey_editor_window_data.modifiers = get_modifier(event->key.keysym.mod);
                }
            } else if (get_key_from_scancode(event->key.keysym.scancode) != KEY_TYPE_NONE) {
                for (int i = 0; i < hotkey_data.num_arrows; i++) {
                    struct arrow_definition_t *arrow = &hotkey_data.arrows[i];
                    if (arrow->key == get_key_from_scancode(event->key.keysym.scancode)) {
                        arrow->action(0);
                    }
                }
            }
            break;
        case SDL_TEXTINPUT:
            if (keyboard_data.capture_numeric) {
                char c = event->text.text[0];
                if (c >= '0' && c <= '9') {
                    keyboard_data.capture_numeric_callback(c - '0');
                }
            } else {
                if (keyboard_data.capture) {
                    int index = 0;
                    while (event->text.text[index]) {
                        char c = event->text.text[0];
                        int add = 0;
                        if (c == ' ' || c == '-') {
                            add = 1;
                        } else if (c >= '0' && c <= '9') {
                            add = 1;
                        } else if (c >= 'a' && c <= 'z') {
                            add = 1;
                        } else if (c >= 'A' && c <= 'Z') {
                            add = 1;
                        } else if (c == ',' || c == '.' || c == '?' || c == '!' || c == '@' || c == '%' || c == '\'' || c == '/' || c == '_') {
                            add = keyboard_data.allow_punctuation;
                        }
                        if (add) {
                            if (keyboard_data.length + 1 < keyboard_data.max_length) {
                                keyboard_data.text[keyboard_data.length] = 0;
                                while (keyboard_data.text[keyboard_data.length] > keyboard_data.text[keyboard_data.cursor_position]) {
                                    keyboard_data.text[keyboard_data.length]--;
                                    keyboard_data.text[keyboard_data.length] = keyboard_data.text[keyboard_data.length];
                                }
                                keyboard_data.text[keyboard_data.cursor_position] = event->text.text[0];
                                keyboard_data.cursor_position++;
                                keyboard_data.length += 1;
                                update_viewport(1);
                            }
                        }
                        index++;
                    }
                }
            }
            break;
        case SDL_MOUSEMOTION:
            if (event->motion.which != SDL_TOUCH_MOUSEID && !SDL_GetRelativeMouseMode()) {
                mouse_set_position(event->motion.x, event->motion.y);
            }
            break;
        case SDL_MOUSEBUTTONDOWN:
            if (event->button.which != SDL_TOUCH_MOUSEID) {
                handle_mouse_button(&event->button, 1);
            }
            break;
        case SDL_MOUSEBUTTONUP:
            if (event->button.which != SDL_TOUCH_MOUSEID) {
                handle_mouse_button(&event->button, 0);
            }
            break;
        case SDL_MOUSEWHEEL:
            if (event->wheel.which != SDL_TOUCH_MOUSEID) {
                mouse_data.scrolled = event->wheel.y > 0 ? SCROLL_UP : event->wheel.y < 0 ? SCROLL_DOWN : SCROLL_NONE;
                mouse_data.is_inside_window = 1;
            }
            break;
        case SDL_QUIT:
            data.quit = 1;
            break;
        case SDL_USEREVENT:
            if (event->user.code == USER_EVENT_QUIT) {
                data.quit = 1;
            } else if (event->user.code == USER_EVENT_RESIZE) {
                int pixel_width = scale_logical_to_pixels(INTPTR(event->user.data1));
                int pixel_height = scale_logical_to_pixels(INTPTR(event->user.data2));
                int display = SDL_GetWindowDisplayIndex(SDL.window);
                if (settings_values[SETTINGS_FULLSCREEN]) {
                    SDL_SetWindowFullscreen(SDL.window, 0);
                } else {
                    SDL_GetWindowPosition(SDL.window, &window_pos.x, &window_pos.y);
                }
                if (SDL_GetWindowFlags(SDL.window) & SDL_WINDOW_MAXIMIZED) {
                    SDL_RestoreWindow(SDL.window);
                }
                SDL_SetWindowSize(SDL.window, pixel_width, pixel_height);
                if (window_pos.centered) {
                    center_window();
                }
                SDL_Log("User resize to %d x %d on display %d", pixel_width, pixel_height, display);
                if (SDL_GetWindowGrab(SDL.window) == SDL_TRUE) {
                    SDL_SetWindowGrab(SDL.window, SDL_FALSE);
                }
                setting_set_display(0, pixel_width, pixel_height);
            } else if (event->user.code == USER_EVENT_FULLSCREEN) {
                SDL_GetWindowPosition(SDL.window, &window_pos.x, &window_pos.y);
                int display = SDL_GetWindowDisplayIndex(SDL.window);
                SDL_DisplayMode mode;
                SDL_GetDesktopDisplayMode(display, &mode);
                SDL_Log("User to fullscreen %d x %d on display %d", mode.w, mode.h, display);
                if (0 != SDL_SetWindowFullscreen(SDL.window, SDL_WINDOW_FULLSCREEN_DESKTOP)) {
                    SDL_Log("Unable to enter fullscreen: %s", SDL_GetError());
                    return;
                }
                SDL_SetWindowDisplayMode(SDL.window, &mode);

                if (SDL_GetNumVideoDisplays() > 1) {
                    SDL_SetWindowGrab(SDL.window, SDL_TRUE);
                }
                setting_set_display(1, mode.w, mode.h);
            } else if (event->user.code == USER_EVENT_WINDOWED) {
                int logical_width, logical_height;
                setting_window(&logical_width, &logical_height);
                int pixel_width = scale_logical_to_pixels(logical_width);
                int pixel_height = scale_logical_to_pixels(logical_height);
                int display = SDL_GetWindowDisplayIndex(SDL.window);
                SDL_Log("User to windowed %d x %d on display %d", pixel_width, pixel_height, display);
                SDL_SetWindowFullscreen(SDL.window, 0);
                SDL_SetWindowSize(SDL.window, pixel_width, pixel_height);
                if (window_pos.centered) {
                    center_window();
                }
                if (SDL_GetWindowGrab(SDL.window) == SDL_TRUE) {
                    SDL_SetWindowGrab(SDL.window, SDL_FALSE);
                }
                setting_set_display(0, pixel_width, pixel_height);
            } else if (event->user.code == USER_EVENT_CENTER_WINDOW) {
                center_window();
            }
            break;

        default:
            break;
    }
}

static void destroy_screen(void)
{
    if (SDL.texture) {
        destroy_screen_texture();
    }
    if (SDL.renderer) {
        SDL_DestroyRenderer(SDL.renderer);
        SDL.renderer = 0;
    }
    if (SDL.window) {
        SDL_DestroyWindow(SDL.window);
        SDL.window = 0;
    }
}

static void config_save(void)
{
    FILE *fp = fopen(CONFIGS_FILE_PATH, "wt");
    if (!fp) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to write configuration file", CONFIGS_FILE_PATH, 0));
        return;
    }
    for (int i = 0; i < CONFIG_MAX_ENTRIES; i++) {
        fprintf(fp, "%s=%d\n", ini_keys_config[i], values[i]);
    }
    for (int i = 0; i < CONFIG_STRING_MAX_ENTRIES; i++) {
        fprintf(fp, "%s=%s\n", ini_string_keys[i], string_values[i]);
    }
    fclose(fp);
}

static void main_loop(void)
{
    SDL_Event event;
    // On Windows, if ctrl + alt + del is pressed during fullscreen, the rendering context may be lost for a few frames
    // after restoring the window, preventing the texture from being recreated. This forces an attempt to recreate the
    // texture every frame to bypass that issue.
    if (!SDL.texture && SDL.renderer && settings_values[SETTINGS_FULLSCREEN]) {
        SDL_DisplayMode mode;
        SDL_GetWindowDisplayMode(SDL.window, &mode);
        screen_set_resolution(scale_pixels_to_logical(mode.w), scale_pixels_to_logical(mode.h));
        SDL.texture = SDL_CreateTexture(SDL.renderer,
            SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STREAMING,
            screen_data.width, screen_data.height);
    }
    /* Process event queue */
    while (SDL_PollEvent(&event)) {
        handle_event(&event);
    }
    if (data.quit) {
        SDL_Log("Exiting game");
        if (data_video.is_playing) {
            close_smk();
            data_video.is_playing = 0;
        }
        // save settings
        FILE *fp_settings = fopen(SETTINGS_FILE_PATH, "wt");
        if (fp_settings) {
            for (int i = 0; i < SETTINGS_MAX_ENTRIES; i++) {
                fprintf(fp_settings, "%s=%d\n", settings_file_strings[i], settings_values[i]);
            }
            fclose(fp_settings);
        } else {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to write settings file", SETTINGS_FILE_PATH, 0));
        }
        config_save();
        if (data_channels.initialized) {
            for (int i = 0; i < MAX_DEVICE_CHANNELS; i++) {
                stop_sound_channel(i);
            }
            Mix_CloseAudio();
            data_channels.initialized = 0;
        }
        destroy_screen();
        SDL_Quit();
        if (log_file) {
            fclose(log_file);
        }
        return;
    }
    if (data.active) {
        run_and_draw();
    } else {
        SDL_WaitEvent(0);
    }
}

static int image_y_offset_default(uint8_t c, int image_height, int line_height)
{
    int offset = image_height - line_height;
    if (offset < 0) {
        offset = 0;
    }
    if (c < 0x80 || c == 0xE7) {
        offset = 0;
    }
    return offset;
}

static   struct font_definition_t DEFINITIONS_DEFAULT[] = {
    {FONT_NORMAL_PLAIN, 0, 6, 1, 11, image_y_offset_default},
    {FONT_NORMAL_BLACK, 134, 6, 0, 11, image_y_offset_default},
    {FONT_NORMAL_WHITE, 268, 6, 0, 11, image_y_offset_default},
    {FONT_NORMAL_RED, 402, 6, 0, 11, image_y_offset_default},
    {FONT_LARGE_PLAIN, 536, 8, 1, 23, image_y_offset_default},
    {FONT_LARGE_BLACK, 670, 8, 0, 23, image_y_offset_default},
    {FONT_LARGE_BROWN, 804, 8, 0, 24, image_y_offset_default},
    {FONT_SMALL_PLAIN, 938, 4, 1, 9, image_y_offset_default},
    {FONT_NORMAL_GREEN, 1072, 6, 0, 11, image_y_offset_default},
    {FONT_NORMAL_BROWN, 1206, 6, 0, 11, image_y_offset_default}
};

static void hotkey_config_add_mapping(struct hotkey_mapping_t *mapping)
{
    if (hotkey_config_data.num_mappings < MAX_MAPPINGS) {
        hotkey_config_data.mappings[hotkey_config_data.num_mappings] = *mapping;
        hotkey_config_data.num_mappings++;
    }
}

static char *get_first_char_occurrence_in_string(char *str, char c)
{
    while (*str) {
        if (*str == c) {
            return str;
        }
        str++;
    }
    return 0;
}

static void load_file(void)
{
    hotkey_config_data.num_mappings = 0;
    FILE *fp = fopen(HOTKEY_CONFIGS_FILE_PATH, "rt");
    if (!fp) {
        return;
    }
    char line_buffer[MAX_LINE];
    char *line;
    while ((line = fgets(line_buffer, MAX_LINE, fp))) {
        // Remove newline from string
        size_t size = string_length(line);
        while (size > 0 && (line[size - 1] == '\n' || line[size - 1] == '\r')) {
            line[--size] = 0;
        }
        char *equals = get_first_char_occurrence_in_string(line, '=');
        if (!equals) {
            continue;
        }
        *equals = 0;
        char *value = &equals[1];
        for (int i = 0; i < HOTKEY_MAX_ITEMS; i++) {
            if (string_equals(ini_keys_hotkey_config[i], line)) {
                struct hotkey_mapping_t mapping;
                int key_combination_from_name = 1;
                char editable_name[100] = { 0 };
                string_copy(value, editable_name, 99);
                mapping.key = KEY_TYPE_NONE;
                mapping.modifiers = KEY_MOD_NONE;
                char *token = strtok(editable_name, " ");
                while (token) {
                    if (token[0]) {
                        int mod = KEY_MOD_NONE;
                        for (struct modifier_name_t *modname = modifier_names; modname->modifier; modname++) {
                            if (string_equals(modname->name, token)) {
                                mod = modname->modifier;
                            }
                        }
                        if (mod != KEY_MOD_NONE) {
                            mapping.modifiers |= mod;
                        } else {
                            mapping.key = KEY_TYPE_NONE;
                            for (int l = 1; l < KEY_TYPE_MAX_ITEMS; l++) {
                                if (string_equals(key_names[l], token)) {
                                    mapping.key = l;
                                    break;
                                }
                            }
                            if (mapping.key == KEY_TYPE_NONE) {
                                key_combination_from_name = 0;
                                break;
                            }
                        }
                    }
                    token = strtok(0, " ");
                }
                if (mapping.key == KEY_TYPE_NONE) {
                    key_combination_from_name = 0;
                }
                if (key_combination_from_name) {
                    mapping.action = i;
                    hotkey_config_add_mapping(&mapping);
                }
                break;
            }
        }
    }
    fclose(fp);
}

static void set_arrow_key(struct key_t *arrow, int value)
{
    int state = KEY_STATE_AXIS;
    if (!value) {
        state = KEY_STATE_UNPRESSED;
    }
    if (value == SCROLL_KEY_PRESSED) {
        state = KEY_STATE_PRESSED;
    }
    if (state != KEY_STATE_AXIS && state != KEY_STATE_UNPRESSED &&
        arrow->state != KEY_STATE_AXIS && arrow->state != KEY_STATE_UNPRESSED) {
        return;
    }
    // Key should retain axis state even if its value is zero
    if (arrow->state != KEY_STATE_AXIS || state != KEY_STATE_UNPRESSED) {
        arrow->state = state;
    }
    arrow->value = value;
    arrow->last_change = current_time;
}

static void scroll_arrow_up(int value)
{
    set_arrow_key(&scroll_data.arrow_key.up, value);
}

static void scroll_arrow_down(int value)
{
    set_arrow_key(&scroll_data.arrow_key.down, value);
}

static void scroll_arrow_left(int value)
{
    set_arrow_key(&scroll_data.arrow_key.left, value);
}

static void scroll_arrow_right(int value)
{
    set_arrow_key(&scroll_data.arrow_key.right, value);
}

static void hotkey_install_mapping(struct hotkey_mapping_t *mappings, int num_mappings)
{
    int total_definitions = 2; // Enter and ESC are fixed hotkeys
    int total_arrows = 0;
    for (int i = 0; i < num_mappings; i++) {
        int action = mappings[i].action;
        if (action == HOTKEY_ARROW_UP || action == HOTKEY_ARROW_DOWN ||
            action == HOTKEY_ARROW_LEFT || action == HOTKEY_ARROW_RIGHT) {
            total_arrows++;
        } else {
            total_definitions++;
        }
    }
    if (!total_arrows) {
        return;
    }
    free(hotkey_data.definitions);
    free(hotkey_data.arrows);
    hotkey_data.num_definitions = 0;
    hotkey_data.num_arrows = 0;
    hotkey_data.definitions = malloc(sizeof(struct hotkey_definition_t) * total_definitions);
    hotkey_data.arrows = malloc(sizeof(struct arrow_definition_t) * total_arrows);
    if (!hotkey_data.definitions || !hotkey_data.arrows) {
        free(hotkey_data.definitions);
        free(hotkey_data.arrows);
        return;
    }
    // Fixed keys: Escape and Enter
    hotkey_data.definitions[0].action = &hotkey_data.hotkey_state.enter_pressed;
    hotkey_data.definitions[0].key = KEY_TYPE_ENTER;
    hotkey_data.definitions[0].modifiers = 0;
    hotkey_data.definitions[0].repeatable = 0;
    hotkey_data.definitions[0].value = 1;
    hotkey_data.definitions[1].action = &hotkey_data.hotkey_state.escape_pressed;
    hotkey_data.definitions[1].key = KEY_TYPE_ESCAPE;
    hotkey_data.definitions[1].modifiers = 0;
    hotkey_data.definitions[1].repeatable = 0;
    hotkey_data.definitions[1].value = 1;
    hotkey_data.num_definitions = 2;
    for (int i = 0; i < num_mappings; i++) {
        int action = mappings[i].action;
        if (action == HOTKEY_ARROW_UP || action == HOTKEY_ARROW_DOWN ||
            action == HOTKEY_ARROW_LEFT || action == HOTKEY_ARROW_RIGHT) {
            struct arrow_definition_t *arrow = &hotkey_data.arrows[hotkey_data.num_arrows];
            arrow->key = mappings[i].key;
            switch (mappings[i].action) {
                case HOTKEY_ARROW_UP:
                    arrow->action = scroll_arrow_up;
                    break;
                case HOTKEY_ARROW_DOWN:
                    arrow->action = scroll_arrow_down;
                    break;
                case HOTKEY_ARROW_LEFT:
                    arrow->action = scroll_arrow_left;
                    break;
                case HOTKEY_ARROW_RIGHT:
                    arrow->action = scroll_arrow_right;
                    break;
                default:
                    arrow->action = 0;
                    break;
            }
            if (arrow->action) {
                hotkey_data.num_arrows++;
            }
        } else {
            struct hotkey_definition_t *def = &hotkey_data.definitions[hotkey_data.num_definitions];
            def->key = mappings[i].key;
            def->modifiers = mappings[i].modifiers;
            def->value = 1;
            def->repeatable = 0;
            switch (mappings[i].action) {
                case HOTKEY_TOGGLE_FULLSCREEN:
                    def->action = &hotkey_data.global_hotkey_state.toggle_fullscreen;
                    break;
                case HOTKEY_RESET_WINDOW:
                    def->action = &hotkey_data.global_hotkey_state.reset_window;
                    break;
                case HOTKEY_SAVE_SCREENSHOT:
                    def->action = &hotkey_data.global_hotkey_state.save_screenshot;
                    break;
                case HOTKEY_SAVE_CITY_SCREENSHOT:
                    def->action = &hotkey_data.global_hotkey_state.save_city_screenshot;
                    break;
                case HOTKEY_LOAD_FILE:
                    def->action = &hotkey_data.hotkey_state.load_file;
                    break;
                case HOTKEY_SAVE_FILE:
                    def->action = &hotkey_data.hotkey_state.save_file;
                    break;
                case HOTKEY_DECREASE_GAME_SPEED:
                    def->action = &hotkey_data.hotkey_state.decrease_game_speed;
                    def->repeatable = 1;
                    break;
                case HOTKEY_INCREASE_GAME_SPEED:
                    def->action = &hotkey_data.hotkey_state.increase_game_speed;
                    def->repeatable = 1;
                    break;
                case HOTKEY_TOGGLE_PAUSE:
                    def->action = &hotkey_data.hotkey_state.toggle_pause;
                    break;
                case HOTKEY_ROTATE_MAP_LEFT:
                    def->action = &hotkey_data.hotkey_state.rotate_map_left;
                    break;
                case HOTKEY_ROTATE_MAP_RIGHT:
                    def->action = &hotkey_data.hotkey_state.rotate_map_right;
                    break;
                case HOTKEY_REPLAY_MAP:
                    def->action = &hotkey_data.hotkey_state.replay_map;
                    break;
                case HOTKEY_CYCLE_LEGION:
                    def->action = &hotkey_data.hotkey_state.cycle_legion;
                    break;
                case HOTKEY_RETURN_LEGIONS_TO_FORT:
                    def->action = &hotkey_data.hotkey_state.return_legions_to_fort;
                    break;
                case HOTKEY_SHOW_LAST_ADVISOR:
                    def->action = &hotkey_data.hotkey_state.show_last_advisor;
                    break;
                case HOTKEY_SHOW_EMPIRE_MAP:
                    def->action = &hotkey_data.hotkey_state.show_empire_map;
                    break;
                case HOTKEY_SHOW_MESSAGES:
                    def->action = &hotkey_data.hotkey_state.show_messages;
                    break;
                case HOTKEY_GO_TO_PROBLEM:
                    def->action = &hotkey_data.hotkey_state.go_to_problem;
                    break;
                case HOTKEY_SHOW_OVERLAY_WATER:
                    def->action = &hotkey_data.hotkey_state.show_overlay;
                    def->value = OVERLAY_WATER;
                    break;
                case HOTKEY_SHOW_OVERLAY_FIRE:
                    def->action = &hotkey_data.hotkey_state.show_overlay;
                    def->value = OVERLAY_FIRE;
                    break;
                case HOTKEY_SHOW_OVERLAY_DAMAGE:
                    def->action = &hotkey_data.hotkey_state.show_overlay;
                    def->value = OVERLAY_DAMAGE;
                    break;
                case HOTKEY_SHOW_OVERLAY_CRIME:
                    def->action = &hotkey_data.hotkey_state.show_overlay;
                    def->value = OVERLAY_CRIME;
                    break;
                case HOTKEY_SHOW_OVERLAY_PROBLEMS:
                    def->action = &hotkey_data.hotkey_state.show_overlay;
                    def->value = OVERLAY_PROBLEMS;
                    break;
                case HOTKEY_GO_TO_BOOKMARK_1:
                    def->action = &hotkey_data.hotkey_state.go_to_bookmark;
                    def->value = 1;
                    break;
                case HOTKEY_GO_TO_BOOKMARK_2:
                    def->action = &hotkey_data.hotkey_state.go_to_bookmark;
                    def->value = 2;
                    break;
                case HOTKEY_GO_TO_BOOKMARK_3:
                    def->action = &hotkey_data.hotkey_state.go_to_bookmark;
                    def->value = 3;
                    break;
                case HOTKEY_GO_TO_BOOKMARK_4:
                    def->action = &hotkey_data.hotkey_state.go_to_bookmark;
                    def->value = 4;
                    break;
                case HOTKEY_SET_BOOKMARK_1:
                    def->action = &hotkey_data.hotkey_state.set_bookmark;
                    def->value = 1;
                    break;
                case HOTKEY_SET_BOOKMARK_2:
                    def->action = &hotkey_data.hotkey_state.set_bookmark;
                    def->value = 2;
                    break;
                case HOTKEY_SET_BOOKMARK_3:
                    def->action = &hotkey_data.hotkey_state.set_bookmark;
                    def->value = 3;
                    break;
                case HOTKEY_SET_BOOKMARK_4:
                    def->action = &hotkey_data.hotkey_state.set_bookmark;
                    def->value = 4;
                    break;
                case HOTKEY_EDITOR_TOGGLE_BATTLE_INFO:
                    def->action = &hotkey_data.hotkey_state.toggle_editor_battle_info;
                    break;
                case HOTKEY_CHEAT_MONEY:
                    def->action = &hotkey_data.hotkey_state.cheat_money;
                    def->repeatable = 1;
                    break;
                case HOTKEY_CHEAT_INVASION:
                    def->action = &hotkey_data.hotkey_state.cheat_invasion;
                    break;
                case HOTKEY_CHEAT_VICTORY:
                    def->action = &hotkey_data.hotkey_state.cheat_victory;
                    break;
                case HOTKEY_BUILD_CLONE:
                    def->action = &hotkey_data.hotkey_state.clone_building;
                    break;
                case HOTKEY_CYCLE_BUILDINGS:
                    def->action = &hotkey_data.hotkey_state.cycle_buildings;
                    def->repeatable = 1;
                    break;
                case HOTKEY_CYCLE_BUILDINGS_REVERSE:
                    def->action = &hotkey_data.hotkey_state.cycle_buildings_reverse;
                    def->repeatable = 1;
                    break;
                case HOTKEY_UNDO:
                    def->action = &hotkey_data.hotkey_state.undo;
                    break;
                case HOTKEY_BUILD_VACANT_HOUSE:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_HOUSE_VACANT_LOT;
                    break;
                case HOTKEY_BUILD_CLEAR_LAND:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_CLEAR_LAND;
                    break;
                case HOTKEY_BUILD_ROAD:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_ROAD;
                    break;
                case HOTKEY_BUILD_RESERVOIR:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_RESERVOIR;
                    break;
                case HOTKEY_BUILD_AQUEDUCT:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_AQUEDUCT;
                    break;
                case HOTKEY_BUILD_FOUNTAIN:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_FOUNTAIN;
                    break;
                case HOTKEY_BUILD_WELL:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_WELL;
                    break;
                case HOTKEY_BUILD_BARBER:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_BARBER;
                    break;
                case HOTKEY_BUILD_BATHHOUSE:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_BATHHOUSE;
                    break;
                case HOTKEY_BUILD_DOCTOR:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_DOCTOR;
                    break;
                case HOTKEY_BUILD_HOSPITAL:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_HOSPITAL;
                    break;
                case HOTKEY_BUILD_SMALL_TEMPLE_CERES:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_SMALL_TEMPLE_CERES;
                    break;
                case HOTKEY_BUILD_LARGE_TEMPLE_CERES:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_LARGE_TEMPLE_CERES;
                    break;
                case HOTKEY_BUILD_ORACLE:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_ORACLE;
                    break;
                case HOTKEY_BUILD_SCHOOL:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_SCHOOL;
                    break;
                case HOTKEY_BUILD_ACADEMY:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_ACADEMY;
                    break;
                case HOTKEY_BUILD_LIBRARY:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_LIBRARY;
                    break;
                case HOTKEY_BUILD_MISSION_POST:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_MISSION_POST;
                    break;
                case HOTKEY_BUILD_THEATER:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_THEATER;
                    break;
                case HOTKEY_BUILD_AMPHITHEATER:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_AMPHITHEATER;
                    break;
                case HOTKEY_BUILD_COLOSSEUM:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_COLOSSEUM;
                    break;
                case HOTKEY_BUILD_HIPPODROME:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_HIPPODROME;
                    break;
                case HOTKEY_BUILD_GLADIATOR_SCHOOL:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_GLADIATOR_SCHOOL;
                    break;
                case HOTKEY_BUILD_LION_HOUSE:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_LION_HOUSE;
                    break;
                case HOTKEY_BUILD_ACTOR_COLONY:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_ACTOR_COLONY;
                    break;
                case HOTKEY_BUILD_CHARIOT_MAKER:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_CHARIOT_MAKER;
                    break;
                case HOTKEY_BUILD_FORUM:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_FORUM;
                    break;
                case HOTKEY_BUILD_SENATE:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_SENATE;
                    break;
                case HOTKEY_BUILD_GOVERNORS_HOUSE:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_GOVERNORS_HOUSE;
                    break;
                case HOTKEY_BUILD_GOVERNORS_VILLA:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_GOVERNORS_VILLA;
                    break;
                case HOTKEY_BUILD_GOVERNORS_PALACE:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_GOVERNORS_PALACE;
                    break;
                case HOTKEY_BUILD_SMALL_STATUE:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_SMALL_STATUE;
                    break;
                case HOTKEY_BUILD_MEDIUM_STATUE:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_MEDIUM_STATUE;
                    break;
                case HOTKEY_BUILD_LARGE_STATUE:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_LARGE_STATUE;
                    break;
                case HOTKEY_BUILD_GARDENS:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_GARDENS;
                    break;
                case HOTKEY_BUILD_PLAZA:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_PLAZA;
                    break;
                case HOTKEY_BUILD_ENGINEERS_POST:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_ENGINEERS_POST;
                    break;
                case HOTKEY_BUILD_LOW_BRIDGE:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_LOW_BRIDGE;
                    break;
                case HOTKEY_BUILD_SHIP_BRIDGE:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_SHIP_BRIDGE;
                    break;
                case HOTKEY_BUILD_SHIPYARD:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_SHIPYARD;
                    break;
                case HOTKEY_BUILD_DOCK:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_DOCK;
                    break;
                case HOTKEY_BUILD_WHARF:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_WHARF;
                    break;
                case HOTKEY_BUILD_WALL:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_WALL;
                    break;
                case HOTKEY_BUILD_TOWER:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_TOWER;
                    break;
                case HOTKEY_BUILD_GATEHOUSE:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_GATEHOUSE;
                    break;
                case HOTKEY_BUILD_PREFECTURE:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_PREFECTURE;
                    break;
                case HOTKEY_BUILD_FORT_LEGIONARIES:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_FORT_LEGIONARIES;
                    break;
                case HOTKEY_BUILD_FORT_JAVELIN:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_FORT_JAVELIN;
                    break;
                case HOTKEY_BUILD_FORT_MOUNTED:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_FORT_MOUNTED;
                    break;
                case HOTKEY_BUILD_MILITARY_ACADEMY:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_MILITARY_ACADEMY;
                    break;
                case HOTKEY_BUILD_BARRACKS:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_BARRACKS;
                    break;
                case HOTKEY_BUILD_WHEAT_FARM:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_WHEAT_FARM;
                    break;
                case HOTKEY_BUILD_VEGETABLE_FARM:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_VEGETABLE_FARM;
                    break;
                case HOTKEY_BUILD_FRUIT_FARM:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_FRUIT_FARM;
                    break;
                case HOTKEY_BUILD_OLIVE_FARM:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_OLIVE_FARM;
                    break;
                case HOTKEY_BUILD_VINES_FARM:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_VINES_FARM;
                    break;
                case HOTKEY_BUILD_PIG_FARM:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_PIG_FARM;
                    break;
                case HOTKEY_BUILD_CLAY_PIT:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_CLAY_PIT;
                    break;
                case HOTKEY_BUILD_MARBLE_QUARRY:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_MARBLE_QUARRY;
                    break;
                case HOTKEY_BUILD_IRON_MINE:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_IRON_MINE;
                    break;
                case HOTKEY_BUILD_TIMBER_YARD:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_TIMBER_YARD;
                    break;
                case HOTKEY_BUILD_WINE_WORKSHOP:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_WINE_WORKSHOP;
                    break;
                case HOTKEY_BUILD_OIL_WORKSHOP:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_OIL_WORKSHOP;
                    break;
                case HOTKEY_BUILD_WEAPONS_WORKSHOP:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_WEAPONS_WORKSHOP;
                    break;
                case HOTKEY_BUILD_FURNITURE_WORKSHOP:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_FURNITURE_WORKSHOP;
                    break;
                case HOTKEY_BUILD_POTTERY_WORKSHOP:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_POTTERY_WORKSHOP;
                    break;
                case HOTKEY_BUILD_MARKET:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_MARKET;
                    break;
                case HOTKEY_BUILD_GRANARY:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_GRANARY;
                    break;
                case HOTKEY_BUILD_WAREHOUSE:
                    def->action = &hotkey_data.hotkey_state.building;
                    def->value = BUILDING_WAREHOUSE;
                    break;
                default:
                    def->action = 0;
            }
            if (def->action) {
                hotkey_data.num_definitions++;
            }
        }
    }
}

static void set_mapping(int key, int modifiers, int action)
{
    struct hotkey_mapping_t *mapping = &hotkey_config_data.default_mappings[action][0];
    if (mapping->key) {
        mapping = &hotkey_config_data.default_mappings[action][1];
    }
    if (mapping->key) {
        return;
    }
    mapping->key = key;
    mapping->modifiers = modifiers;
    mapping->action = action;
}

static int get_max_scale_percentage(int pixel_width, int pixel_height)
{
    int width_scale_pct = pixel_width * 100 / MINIMUM.WIDTH;
    int height_scale_pct = pixel_height * 100 / MINIMUM.HEIGHT;
    return SDL_min(width_scale_pct, height_scale_pct);
}

static void set_scale_percentage(int new_scale, int pixel_width, int pixel_height)
{
    scale_percentage = calc_bound(new_scale, 50, 500);

    if (!pixel_width || !pixel_height) {
        return;
    }

    int max_scale_pct = get_max_scale_percentage(pixel_width, pixel_height);
    if (max_scale_pct < scale_percentage) {
        scale_percentage = max_scale_pct;
        SDL_Log("Maximum scale of %i applied", scale_percentage);
    }

    SDL_SetWindowMinimumSize(SDL.window,
        scale_logical_to_pixels(MINIMUM.WIDTH), scale_logical_to_pixels(MINIMUM.HEIGHT));

    char *scale_quality = "linear";
    // Scale using nearest neighbour when we scale a multiple of 100%: makes it look sharper.
    if (scale_percentage % 100 == 0) {
        scale_quality = "nearest";
    }
    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, scale_quality);
}

static int create_screen(char *title, int display_scale_percentage)
{
    set_scale_percentage(display_scale_percentage, 0, 0);

    int width, height;
    int fullscreen = settings_values[SETTINGS_FULLSCREEN];
    if (fullscreen) {
        SDL_DisplayMode mode;
        SDL_GetDesktopDisplayMode(0, &mode);
        width = mode.w;
        height = mode.h;
    } else {
        setting_window(&width, &height);
        width = scale_logical_to_pixels(width);
        height = scale_logical_to_pixels(height);
    }

    destroy_screen();

    SDL_Log("Creating screen %d x %d, %s, driver: %s", width, height,
        fullscreen ? "fullscreen" : "windowed", SDL_GetCurrentVideoDriver());
    Uint32 flags = SDL_WINDOW_RESIZABLE;

    flags |= SDL_WINDOW_ALLOW_HIGHDPI;

    if (fullscreen) {
        flags |= SDL_WINDOW_FULLSCREEN_DESKTOP;
    }
    SDL.window = SDL_CreateWindow(title,
        SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
        width, height, flags);

    if (!SDL.window) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unable to create window: %s", SDL_GetError());
        return 0;
    }

    SDL_Log("Creating renderer");
    SDL.renderer = SDL_CreateRenderer(SDL.window, -1, SDL_RENDERER_PRESENTVSYNC);
    if (!SDL.renderer) {
        SDL_Log("Unable to create renderer, trying software renderer: %s", SDL_GetError());
        SDL.renderer = SDL_CreateRenderer(SDL.window, -1, SDL_RENDERER_SOFTWARE);
        if (!SDL.renderer) {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unable to create renderer: %s", SDL_GetError());
            return 0;
        }
    }

    if (fullscreen && SDL_GetNumVideoDisplays() > 1) {
        SDL_SetWindowGrab(SDL.window, SDL_TRUE);
    }

    set_scale_percentage(display_scale_percentage, width, height);
    return resize_screen(width, height);
}

static void init_channels(void)
{
    data_channels.initialized = 1;
    for (int i = 0; i < MAX_DEVICE_CHANNELS; i++) {
        data_channels.channels[i].chunk = 0;
    }
}

static void draw_background_logo(void)
{
    graphics_clear_screen();
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    image_draw(image_data_s.group_image_ids[GROUP_LOGO], 0, 0);
    lang_text_draw_centered_colored(13, 7, 160, 462, 320, FONT_NORMAL_PLAIN, COLOR_WHITE);
    set_translation(0, 0);
}

static void handle_input_logo(struct mouse_t *m, struct hotkeys_t *h)
{
    if (m->left.went_up || m->right.went_up) {
        window_main_menu_show(0);
        return;
    }
    if (h->escape_pressed) {
        post_event(USER_EVENT_QUIT);
    }
}

static void draw_background_plain_message_dialog(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    outer_panel_draw(80, 80, 30, 12);
    text_draw_centered(plain_message_dialog_data.title, 80, 100, 480, FONT_LARGE_BLACK, 0);
    text_draw_multiline(plain_message_dialog_data.message, 100, 140, 450, FONT_NORMAL_BLACK, 0);
    set_translation(0, 0);
}

static void close_plain_message_dialog(void)
{
    window_go_back();
}

static void button_ok_plain_message_dialog(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    close_plain_message_dialog();
}

static struct image_button_t buttons_plain_message_dialog[] = {
    {223, 140, 39, 26, IB_NORMAL, GROUP_OK_CANCEL_SCROLL_BUTTONS, 0, button_ok_plain_message_dialog, button_none, 1, 0, 1, 0, 0, 0},
};

static void draw_foreground_plain_message_dialog(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    image_buttons_draw(80, 80, buttons_plain_message_dialog, 1);
    set_translation(0, 0);
}

static void handle_input_plain_message_dialog(struct mouse_t *m, struct hotkeys_t *h)
{
    if (image_buttons_handle_mouse(mouse_in_dialog(m), 80, 80, buttons_plain_message_dialog, 1, 0)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed || h->enter_pressed) {
        close_plain_message_dialog();
    }
}

static void window_plain_message_dialog_show(char *title, char *message)
{
    if (window_data.current_window->id != WINDOW_PLAIN_MESSAGE_DIALOG) { // don't show popup over popup
        plain_message_dialog_data.title = title;
        plain_message_dialog_data.message = message;
        struct window_type_t window = {
        WINDOW_PLAIN_MESSAGE_DIALOG,
        draw_background_plain_message_dialog,
        draw_foreground_plain_message_dialog,
        handle_input_plain_message_dialog,
        };
        window_show(&window);
    }
}

static void play_intro_music(void)
{
    if (settings_values[SETTINGS_MUSIC_ENABLED]) {
        play_track(TRACK_INTRO);
    }
}

static void handle_input_intro_video(struct mouse_t *m, struct hotkeys_t *h)
{
    if (!started || m->left.went_up || m->right.went_up || data_video.is_ended || h->enter_pressed) {
        video_stop();
        graphics_clear_screen();
        while (current_video < NUM_INTRO_VIDEOS) {
            if (video_start(intro_videos[current_video++])) {
                video_init(0);
                started = 1;
                return;
            }
        }
        play_intro_music();
        window_go_back();
    }
}

static void window_logo_show(int show_patch_message)
{
    struct window_type_t window = {
        WINDOW_LOGO,
        draw_background_logo,
        0,
        handle_input_logo,
    };
    play_intro_music();
    window_show(&window);
    if (show_patch_message == MESSAGE_MISSING_PATCH) {
        window_plain_message_dialog_show("Patch 1.0.1.0 not installed", "Your Caesar 3 installation does not have the 1.0.1.0 patch installed.\n\
        You can download the patch from : https://github.com/bvschaik/julius/wiki/Patches.\nContinue at your own risk.");
    }
    if (values[CONFIG_UI_SHOW_INTRO_VIDEO]) {
        current_video = 0;
        started = 0;
        window.id = WINDOW_INTRO_VIDEO;
        window.draw_background = graphics_clear_screen;
        window.draw_foreground = video_draw_fullscreen;
        window.handle_input = handle_input_intro_video;
        window_show(&window);
    }
}

static void init_cursors(int scale_percentage)
{
    if (scale_percentage <= 100) {
        cursor_data.current_scale = CURSOR_SCALE_1;
    } else if (scale_percentage <= 150) {
        cursor_data.current_scale = CURSOR_SCALE_1_5;
    } else {
        cursor_data.current_scale = CURSOR_SCALE_2;
    }
    for (int i = 0; i < CURSOR_MAX; i++) {
        struct cursor_t *c;
        switch (i) {
            case CURSOR_ARROW:
                c = &ARROW[cursor_data.current_scale];
                break;
            case CURSOR_SHOVEL:
                c = &SHOVEL[cursor_data.current_scale];
                break;
            case CURSOR_SWORD:
                c = &SWORD[cursor_data.current_scale];
                break;
            default:
                c = 0;
                break;
        }
        if (cursor_data.surfaces[i]) {
            SDL_FreeSurface(cursor_data.surfaces[i]);
        }
        if (cursor_data.cursors[i]) {
            SDL_FreeCursor(cursor_data.cursors[i]);
        }
        int size = 32;
        while (size <= c->width || size <= c->height) {
            size *= 2;
        }
        SDL_Surface *cursor_surface = SDL_CreateRGBSurface(0, size, size, 32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000);
        color_t *pixels = cursor_surface->pixels;
        SDL_memset(pixels, 0, sizeof(color_t) * size * size);
        for (int y = 0; y < c->height; y++) {
            for (int x = 0; x < c->width; x++) {
                pixels[y * size + x] = mouse_colors[c->data[y * c->width + x] - 32];
            }
        }
        cursor_data.surfaces[i] = cursor_surface;
        cursor_data.cursors[i] = SDL_CreateColorCursor(cursor_data.surfaces[i], c->hotspot_x, c->hotspot_y);
    }
    set_cursor(cursor_data.current_shape);
}

int main(__attribute__((unused)) int argc, __attribute__((unused)) char **argv) // actually SDL_main
{
    signal(SIGSEGV, handler);
    log_file = fopen("brutus-log.txt", "wt");
    SDL_LogSetOutputFunction(write_log, 0);
    if (SDL_Init(SDL_INIT_AUDIO | SDL_INIT_VIDEO) != 0) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());
        SDL_Log("Exiting: SDL init failed");
        exit(-1);
    }
    SDL_Log("SDL initialized");
    char *executable_path = SDL_GetBasePath();
    char data_text_file_path[DIR_PATH_MAX] = { 0 }; // the path to "data_dir.txt" within the Brutus directory
    if (executable_path) {
        if (string_length(executable_path) < DIR_PATH_MAX - string_length("brutus.hconfigs")) {
            string_copy(executable_path, data_text_file_path, DIR_PATH_MAX - 1);
            strcat(data_text_file_path, "data_dir.txt");
            string_copy(executable_path, SETTINGS_FILE_PATH, DIR_PATH_MAX - 1);
            strcat(SETTINGS_FILE_PATH, "brutus_settings.txt");
            string_copy(executable_path, CONFIGS_FILE_PATH, DIR_PATH_MAX - 1);
            strcat(CONFIGS_FILE_PATH, "brutus_configs.txt");
            string_copy(executable_path, HOTKEY_CONFIGS_FILE_PATH, DIR_PATH_MAX - 1);
            strcat(HOTKEY_CONFIGS_FILE_PATH, "brutus.hconfigs");
            string_copy(executable_path, MAPS_DIR_PATH, DIR_PATH_MAX - 1);
            strcat(MAPS_DIR_PATH, "maps");
            string_copy(executable_path, SAVES_DIR_PATH, DIR_PATH_MAX - 1);
            strcat(SAVES_DIR_PATH, "saves");
        } else {
            SDL_Log("Brutus directory path too long, exiting");
            exit(1);
        }
    } else {
        SDL_Log("Brutus directory not found, exiting");
        exit(1);
    }
    char game_data_path[DIR_PATH_MAX] = { 0 }; // the path to the folder where c3.exe is located
    FILE *fp_data = fopen(data_text_file_path, "r");
    if (fp_data) {
        size_t length = fread(game_data_path, 1, 1000, fp_data);
        fclose(fp_data);
        if (!length) {
            SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_INFORMATION,
                "Game path not specified",
                "Brutus requires Caesar 3 to run. Provide the path to the game in data_dir.txt.",
                0);
            exit(1);
        }
    } else {
        fp_data = fopen(data_text_file_path, "w");
        fclose(fp_data);
        SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_INFORMATION,
            "Game path not specified",
            "Brutus requires Caesar 3 to run. Provide the path to the game in data_dir.txt.",
            0);
        exit(1);
    }
    if (chdir(game_data_path) != 0) {
        SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR,
            "Ya dun goofed",
            "Incorrect game path specified in data_dir.txt",
            0);
        exit(1);
    }
    _mkdir(MAPS_DIR_PATH);
    _mkdir(SAVES_DIR_PATH);
    SDL_Log("Loading game from %s", game_data_path);
    // load settings defaults
    settings_values[SETTINGS_FULLSCREEN] = 0;
    settings_values[SETTINGS_WINDOW_WIDTH] = 1280;
    settings_values[SETTINGS_WINDOW_HEIGHT] = 800;
    settings_values[SETTINGS_SOUND_EFFECTS_ENABLED] = 1;
    settings_values[SETTINGS_SOUND_EFFECTS_VOLUME] = 50;
    settings_values[SETTINGS_MUSIC_ENABLED] = 1;
    settings_values[SETTINGS_MUSIC_VOLUME] = 50;
    settings_values[SETTINGS_SPEECH_ENABLED] = 1;
    settings_values[SETTINGS_SPEECH_VOLUME] = 50;
    settings_values[SETTINGS_CITY_SOUNDS_ENABLED] = 1;
    settings_values[SETTINGS_CITY_SOUNDS_VOLUME] = 50;
    settings_values[SETTINGS_GAME_SPEED] = 80;
    settings_values[SETTINGS_SCROLL_SPEED] = 90;
    settings_values[SETTINGS_MONTHLY_AUTOSAVE_ENABLED] = 0;
    settings_values[SETTINGS_WARNINGS_ENABLED] = 1;
    settings_values[SETTINGS_VICTORY_VIDEO] = 0;
    settings_values[SETTINGS_LAST_ADVISOR] = ADVISOR_CHIEF;
    // load saved settings
    FILE *fp_settings = fopen(SETTINGS_FILE_PATH, "rt");
    if (fp_settings) {
        char line_buffer[MAX_LINE];
        char *line;
        int line_counter = 0;
        while ((line = fgets(line_buffer, MAX_LINE, fp_settings))) {
            // Remove newline from string
            size_t size = string_length(line);
            while (size > 0 && (line[size - 1] == '\n' || line[size - 1] == '\r')) {
                line[--size] = 0;
            }
            char *equals = get_first_char_occurrence_in_string(line, '=');
            if (equals) {
                *equals = 0;
                if (string_equals(settings_file_strings[line_counter], line)) {
                    settings_values[line_counter] = atoi(&equals[1]);
                }
            }
            line_counter++;
        }
        fclose(fp_settings);
    }
    // load saved configs
    for (int i = 0; i < CONFIG_MAX_ENTRIES; ++i) {
        values[i] = default_values[i];
    }
    string_copy("BRUTUS", string_values[CONFIG_STRING_PLAYER_NAME], CONFIG_STRING_VALUE_MAX - 1);
    string_copy(string_values[CONFIG_STRING_PLAYER_NAME], scenario_settings.player_name, MAX_PLAYER_NAME);
    FILE *fp_configs = fopen(CONFIGS_FILE_PATH, "rt");
    if (fp_configs) {
        char line_buffer[MAX_LINE];
        char *line;
        while ((line = fgets(line_buffer, MAX_LINE, fp_configs))) {
            // Remove newline from string
            size_t size = string_length(line);
            while (size > 0 && (line[size - 1] == '\n' || line[size - 1] == '\r')) {
                line[--size] = 0;
            }
            char *equals = get_first_char_occurrence_in_string(line, '=');
            if (equals) {
                *equals = 0;
                for (int i = 0; i < CONFIG_MAX_ENTRIES; i++) {
                    if (string_equals(ini_keys_config[i], line)) {
                        int value = atoi(&equals[1]);
                        SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Config key", ini_keys_config[i], value));
                        values[i] = value;
                        break;
                    }
                }
                for (int i = 0; i < CONFIG_STRING_MAX_ENTRIES; i++) {
                    if (string_equals(ini_string_keys[i], line)) {
                        char *value = &equals[1];
                        SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Config key", ini_string_keys[i], 0));
                        SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Config value", value, 0));
                        string_copy(value, string_values[i], CONFIG_STRING_VALUE_MAX - 1);
                        break;
                    }
                }
            }
        }
        fclose(fp_configs);
        string_copy(string_values[CONFIG_STRING_PLAYER_NAME], scenario_settings.player_name, MAX_PLAYER_NAME);
    }
    memset(hotkey_config_data.default_mappings, 0, sizeof(hotkey_config_data.default_mappings));
    // Arrow keys
    set_mapping(KEY_TYPE_UP, KEY_MOD_NONE, HOTKEY_ARROW_UP);
    set_mapping(KEY_TYPE_DOWN, KEY_MOD_NONE, HOTKEY_ARROW_DOWN);
    set_mapping(KEY_TYPE_LEFT, KEY_MOD_NONE, HOTKEY_ARROW_LEFT);
    set_mapping(KEY_TYPE_RIGHT, KEY_MOD_NONE, HOTKEY_ARROW_RIGHT);
    set_mapping(KEY_TYPE_KP_8, KEY_MOD_NONE, HOTKEY_ARROW_UP);
    set_mapping(KEY_TYPE_KP_2, KEY_MOD_NONE, HOTKEY_ARROW_DOWN);
    set_mapping(KEY_TYPE_KP_4, KEY_MOD_NONE, HOTKEY_ARROW_LEFT);
    set_mapping(KEY_TYPE_KP_6, KEY_MOD_NONE, HOTKEY_ARROW_RIGHT);
    // Global hotkeys
    set_mapping(KEY_TYPE_ENTER, KEY_MOD_ALT, HOTKEY_TOGGLE_FULLSCREEN);
    set_mapping(KEY_TYPE_ENTER, KEY_MOD_CTRL, HOTKEY_RESET_WINDOW);
    set_mapping(KEY_TYPE_LEFTBRACKET, KEY_MOD_CTRL, HOTKEY_SAVE_SCREENSHOT);
    set_mapping(KEY_TYPE_RIGHTBRACKET, KEY_MOD_CTRL, HOTKEY_SAVE_CITY_SCREENSHOT);
    set_mapping(KEY_TYPE_L, KEY_MOD_CTRL, HOTKEY_LOAD_FILE);
    set_mapping(KEY_TYPE_S, KEY_MOD_CTRL, HOTKEY_SAVE_FILE);
    // City hotkeys
    set_mapping(KEY_TYPE_1, KEY_MOD_ALT, HOTKEY_DECREASE_GAME_SPEED);
    set_mapping(KEY_TYPE_2, KEY_MOD_ALT, HOTKEY_INCREASE_GAME_SPEED);
    set_mapping(KEY_TYPE_KP_MINUS, KEY_MOD_NONE, HOTKEY_DECREASE_GAME_SPEED);
    set_mapping(KEY_TYPE_KP_PLUS, KEY_MOD_NONE, HOTKEY_INCREASE_GAME_SPEED);
    set_mapping(KEY_TYPE_P, KEY_MOD_NONE, HOTKEY_TOGGLE_PAUSE);
    set_mapping(KEY_TYPE_CAPSLOCK, KEY_MOD_NONE, HOTKEY_TOGGLE_PAUSE);
    set_mapping(KEY_TYPE_HOME, KEY_MOD_NONE, HOTKEY_ROTATE_MAP_LEFT);
    set_mapping(KEY_TYPE_END, KEY_MOD_NONE, HOTKEY_ROTATE_MAP_RIGHT);
    set_mapping(KEY_TYPE_R, KEY_MOD_CTRL, HOTKEY_REPLAY_MAP);
    set_mapping(KEY_TYPE_SPACE, KEY_MOD_NONE, HOTKEY_CYCLE_LEGION);
    set_mapping(KEY_TYPE_B, KEY_MOD_NONE, HOTKEY_RETURN_LEGIONS_TO_FORT);
    set_mapping(KEY_TYPE_1, KEY_MOD_NONE, HOTKEY_SHOW_LAST_ADVISOR);
    set_mapping(KEY_TYPE_2, KEY_MOD_NONE, HOTKEY_SHOW_EMPIRE_MAP);
    set_mapping(KEY_TYPE_GRAVE, KEY_MOD_NONE, HOTKEY_SHOW_MESSAGES);
    set_mapping(KEY_TYPE_GRAVE, KEY_MOD_ALT, HOTKEY_GO_TO_PROBLEM);
    // Overlays
    set_mapping(KEY_TYPE_W, KEY_MOD_SHIFT, HOTKEY_SHOW_OVERLAY_WATER);
    set_mapping(KEY_TYPE_F, KEY_MOD_SHIFT, HOTKEY_SHOW_OVERLAY_FIRE);
    set_mapping(KEY_TYPE_D, KEY_MOD_SHIFT, HOTKEY_SHOW_OVERLAY_DAMAGE);
    set_mapping(KEY_TYPE_C, KEY_MOD_SHIFT, HOTKEY_SHOW_OVERLAY_CRIME);
    set_mapping(KEY_TYPE_R, KEY_MOD_SHIFT, HOTKEY_SHOW_OVERLAY_PROBLEMS);
    // City map bookmarks
    set_mapping(KEY_TYPE_F1, KEY_MOD_NONE, HOTKEY_GO_TO_BOOKMARK_1);
    set_mapping(KEY_TYPE_F2, KEY_MOD_NONE, HOTKEY_GO_TO_BOOKMARK_2);
    set_mapping(KEY_TYPE_F3, KEY_MOD_NONE, HOTKEY_GO_TO_BOOKMARK_3);
    set_mapping(KEY_TYPE_F4, KEY_MOD_NONE, HOTKEY_GO_TO_BOOKMARK_4);
    set_mapping(KEY_TYPE_F1, KEY_MOD_CTRL, HOTKEY_SET_BOOKMARK_1);
    set_mapping(KEY_TYPE_F2, KEY_MOD_CTRL, HOTKEY_SET_BOOKMARK_2);
    set_mapping(KEY_TYPE_F3, KEY_MOD_CTRL, HOTKEY_SET_BOOKMARK_3);
    set_mapping(KEY_TYPE_F4, KEY_MOD_CTRL, HOTKEY_SET_BOOKMARK_4);
    // Editor
    set_mapping(KEY_TYPE_A, KEY_MOD_CTRL, HOTKEY_EDITOR_TOGGLE_BATTLE_INFO);
    // Cheats
    set_mapping(KEY_TYPE_COMMA, KEY_MOD_CTRL, HOTKEY_CHEAT_MONEY);
    set_mapping(KEY_TYPE_PERIOD, KEY_MOD_CTRL, HOTKEY_CHEAT_INVASION);
    set_mapping(KEY_TYPE_SLASH, KEY_MOD_CTRL, HOTKEY_CHEAT_VICTORY);
    // Construction hotkeys
    set_mapping(KEY_TYPE_Q, KEY_MOD_ALT, HOTKEY_BUILD_CLONE);
    set_mapping(KEY_TYPE_TAB, KEY_MOD_NONE, HOTKEY_CYCLE_BUILDINGS);
    set_mapping(KEY_TYPE_TAB, KEY_MOD_SHIFT, HOTKEY_CYCLE_BUILDINGS_REVERSE);
    set_mapping(KEY_TYPE_Z, KEY_MOD_CTRL, HOTKEY_UNDO);
    set_mapping(KEY_TYPE_Q, KEY_MOD_NONE, HOTKEY_BUILD_VACANT_HOUSE);
    set_mapping(KEY_TYPE_W, KEY_MOD_NONE, HOTKEY_BUILD_CLEAR_LAND);
    set_mapping(KEY_TYPE_E, KEY_MOD_NONE, HOTKEY_BUILD_ROAD);
    set_mapping(KEY_TYPE_R, KEY_MOD_NONE, HOTKEY_BUILD_RESERVOIR);
    set_mapping(KEY_TYPE_R, KEY_MOD_ALT, HOTKEY_BUILD_FOUNTAIN);
    set_mapping(KEY_TYPE_S, KEY_MOD_ALT, HOTKEY_BUILD_DOCTOR);
    set_mapping(KEY_TYPE_F, KEY_MOD_NONE, HOTKEY_BUILD_BATHHOUSE);
    set_mapping(KEY_TYPE_G, KEY_MOD_ALT, HOTKEY_BUILD_BARBER);
    set_mapping(KEY_TYPE_S, KEY_MOD_NONE, HOTKEY_BUILD_SMALL_TEMPLE_CERES);
    set_mapping(KEY_TYPE_D, KEY_MOD_ALT, HOTKEY_BUILD_SCHOOL);
    set_mapping(KEY_TYPE_G, KEY_MOD_NONE, HOTKEY_BUILD_LIBRARY);
    set_mapping(KEY_TYPE_D, KEY_MOD_NONE, HOTKEY_BUILD_THEATER);
    set_mapping(KEY_TYPE_F, KEY_MOD_ALT, HOTKEY_BUILD_AMPHITHEATER);
    set_mapping(KEY_TYPE_Z, KEY_MOD_ALT, HOTKEY_BUILD_LION_HOUSE);
    set_mapping(KEY_TYPE_Z, KEY_MOD_NONE, HOTKEY_BUILD_COLOSSEUM);
    set_mapping(KEY_TYPE_W, KEY_MOD_ALT, HOTKEY_BUILD_GARDENS);
    set_mapping(KEY_TYPE_E, KEY_MOD_ALT, HOTKEY_BUILD_PLAZA);
    set_mapping(KEY_TYPE_T, KEY_MOD_NONE, HOTKEY_BUILD_FORUM);
    set_mapping(KEY_TYPE_A, KEY_MOD_NONE, HOTKEY_BUILD_ENGINEERS_POST);
    set_mapping(KEY_TYPE_A, KEY_MOD_ALT, HOTKEY_BUILD_PREFECTURE);
    set_mapping(KEY_TYPE_X, KEY_MOD_ALT, HOTKEY_BUILD_WHEAT_FARM);
    set_mapping(KEY_TYPE_C, KEY_MOD_NONE, HOTKEY_BUILD_CLAY_PIT);
    set_mapping(KEY_TYPE_C, KEY_MOD_ALT, HOTKEY_BUILD_WINE_WORKSHOP);
    set_mapping(KEY_TYPE_X, KEY_MOD_NONE, HOTKEY_BUILD_MARKET);
    set_mapping(KEY_TYPE_V, KEY_MOD_NONE, HOTKEY_BUILD_GRANARY);
    set_mapping(KEY_TYPE_V, KEY_MOD_ALT, HOTKEY_BUILD_WAREHOUSE);
    load_file();
    if (hotkey_config_data.num_mappings == 0) {
        hotkey_config_data.num_mappings = 0;
        for (int action = 0; action < HOTKEY_MAX_ITEMS; action++) {
            for (int index = 0; index < 2; index++) {
                if (hotkey_config_data.default_mappings[action][index].key) {
                    hotkey_config_add_mapping(&hotkey_config_data.default_mappings[action][index]);
                }
            }
        }
    }
    hotkey_install_mapping(hotkey_config_data.mappings, hotkey_config_data.num_mappings);
    state_data.paused = 0;
    if (!lang_load(0)) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("'c3.eng' or 'c3_mm.eng' files not found or too large.", 0, 0));
        SDL_Log("Exiting: game pre-init failed");
        exit(1);
    }
    font_data.font_mapping = CHAR_TO_FONT_IMAGE_DEFAULT;
    font_data.font_definitions = DEFINITIONS_DEFAULT;
    memset(&data, 0, sizeof(data));
    random_data.iv1 = 0x54657687;
    random_data.iv2 = 0x72641663;
    srand(time(0));

    if (!create_screen("Caesar III", values[CONFIG_SCREEN_DISPLAY_SCALE])) {
        SDL_Log("Exiting: SDL create window failed");
        exit(-2);
    }
    init_cursors(values[CONFIG_SCREEN_CURSOR_SCALE]);
    current_time = SDL_GetTicks();
    for (int i = 0; i < ENEMY_FILES_COUNT; i++) {
        image_data_s.enemy_data[i] = (color_t *) malloc(ENEMY_DATA_SIZE);
    }
    image_data_s.main_data = (color_t *) malloc(MAIN_DATA_SIZE);
    image_data_s.empire_data = (color_t *) malloc(EMPIRE_IMAGE_DATA_SIZE);
    image_data_s.tmp_data = (uint8_t *) malloc(SCRATCH_DATA_SIZE);
    if (!image_data_s.main_data || !image_data_s.empire_data || !image_data_s.enemy_data[0] || !image_data_s.tmp_data) {
        free(image_data_s.main_data);
        free(image_data_s.empire_data);
        free(image_data_s.enemy_data[0]);
        free(image_data_s.tmp_data);
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("unable to init graphics", 0, 0));
        SDL_Log("Exiting: game init failed");
        exit(2);
    }
    if (!image_load_climate(CLIMATE_NORTHERN, 0, 1)) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("unable to load main graphics", 0, 0));
        SDL_Log("Exiting: game init failed");
        exit(2);
    }
    struct buffer_t buf;
    for (int i = 0; i < ENEMY_FILES_COUNT; i++) {
        char *filename_idx = ENEMY_GRAPHICS_SG2[i];

        if (ENEMY_INDEX_SIZE != io_read_file_part_into_buffer(
            filename_idx, image_data_s.tmp_data, ENEMY_INDEX_SIZE, ENEMY_INDEX_OFFSET)) {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("unable to load enemy graphics", 0, 0));
            SDL_Log("Exiting: game init failed");
            exit(2);
        }
        buffer_init(&buf, image_data_s.tmp_data, ENEMY_INDEX_SIZE);
        read_index(&buf, image_data_s.enemy[i], ENEMY_ENTRIES);

        char *filename_bmp = ENEMY_GRAPHICS_555[i];
        int data_size = read_file_into_buffer(filename_bmp, image_data_s.tmp_data, SCRATCH_DATA_SIZE, 1);
        if (!data_size) {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("unable to load enemy graphics", 0, 0));
            SDL_Log("Exiting: game init failed");
            exit(2);
        }
        buffer_init(&buf, image_data_s.tmp_data, data_size);
        convert_images(image_data_s.enemy[i], ENEMY_ENTRIES, &buf, image_data_s.enemy_data[i]);
    }
    // initialize sound
    if (Mix_OpenAudio(AUDIO_RATE, AUDIO_FORMAT, AUDIO_CHANNELS, AUDIO_BUFFERS) == 0) {
        init_channels();
    } else {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Sound failed to initialize using default driver: %s", Mix_GetError());
        // Try to work around SDL choosing the wrong driver on Windows sometimes
        for (int i = 0; i < SDL_GetNumAudioDrivers(); i++) {
            char *driver_name = SDL_GetAudioDriver(i);
            if (SDL_strcmp(driver_name, "disk") == 0 || SDL_strcmp(driver_name, "dummy") == 0) {
                // Skip "write-to-disk" and dummy drivers
                continue;
            }
            if (0 == SDL_AudioInit(driver_name) && Mix_OpenAudio(AUDIO_RATE, AUDIO_FORMAT, AUDIO_CHANNELS, AUDIO_BUFFERS) == 0) {
                SDL_Log("Using audio driver: %s", driver_name);
                init_channels();
                break;
            } else {
                SDL_Log("Not using audio driver %s, reason: %s", driver_name, SDL_GetError());
            }
        }
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Sound failed to initialize: %s", Mix_GetError());
        int max = SDL_GetNumAudioDevices(0);
        SDL_Log("Number of audio devices: %d", max);
        for (int i = 0; i < max; i++) {
            SDL_Log("Audio device: %s", SDL_GetAudioDeviceName(i, 0));
        }
    }
    if (data_channels.initialized) {
        Mix_AllocateChannels(SOUND_CHANNEL_MAX);
        SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Loading audio files", 0, 0));
        for (int i = 0; i < SOUND_CHANNEL_MAX; i++) {
            data_channels.channels[i].chunk = 0;
            data_channels.channels[i].filename = sound_channel_filenames[i][0] ? sound_channel_filenames[i] : 0;
        }
    }
    for (int i = SOUND_CHANNEL_CITY_MIN; i <= SOUND_CHANNEL_CITY_MAX; i++) {
        set_channel_volume(i, settings_values[SETTINGS_CITY_SOUNDS_VOLUME]);
    }
    for (int i = SOUND_CHANNEL_EFFECTS_MIN; i <= SOUND_CHANNEL_EFFECTS_MAX; i++) {
        set_channel_volume(i, settings_values[SETTINGS_SOUND_EFFECTS_VOLUME]);
    }
    Mix_VolumeMusic(settings_values[SETTINGS_MUSIC_VOLUME] * SDL_MIX_MAXVOLUME / 100);
    set_channel_volume(SOUND_CHANNEL_SPEECH, settings_values[SETTINGS_SPEECH_VOLUME]);
    game_state_init();
    // Without patch, the difficulty option string does not exist and
    // getting it "falls through" to the next text group
    char *difficulty_option = lang_get_string(2, 6);
    char *help_menu = lang_get_string(3, 0);
    if (difficulty_option == help_menu) {
        window_logo_show(MESSAGE_MISSING_PATCH);
    } else {
        window_logo_show(MESSAGE_NONE);
    }
    data.quit = 0;
    data.active = 1;
    mouse_data.is_inside_window = 1;
    run_and_draw();
    while (!data.quit) {
        main_loop();
    }
    return 0;
}

static int align_bulding_type_index_to_strings(int building_type_index)
{
    if (building_type_index >= BUILDING_HOUSE_SMALL_TENT) {
        building_type_index += MAX_HOUSE_TYPES;
    }
    return building_type_index;
}

static struct building_t *get_deletable_building(int grid_offset)
{
    int building_id = map_building_at(grid_offset);
    if (!building_id) {
        return 0;
    }
    struct building_t *b = building_main(&all_buildings[building_id]);
    if (b->type == BUILDING_BURNING_RUIN || b->type == BUILDING_NATIVE_CROPS ||
        b->type == BUILDING_NATIVE_HUT || b->type == BUILDING_NATIVE_MEETING) {
        return 0;
    }
    if (b->state == BUILDING_STATE_DELETED_BY_PLAYER || b->is_deleted) {
        return 0;
    }
    return b;
}

static void map_grid_start_end_to_area(int x_start, int y_start, int x_end, int y_end, int *x_min, int *y_min, int *x_max, int *y_max)
{
    if (x_start < x_end) {
        *x_min = x_start;
        *x_max = x_end;
    } else {
        *x_min = x_end;
        *x_max = x_start;
    }
    if (y_start < y_end) {
        *y_min = y_start;
        *y_max = y_end;
    } else {
        *y_min = y_end;
        *y_max = y_start;
    }
    map_grid_bound_area(x_min, y_min, x_max, y_max);
}

static void game_undo_restore_building_state(void)
{
    for (int i = 0; i < undo_data.num_buildings; i++) {
        if (undo_data.buildings[i].id) {
            struct building_t *b = &all_buildings[undo_data.buildings[i].id];
            if (b->state == BUILDING_STATE_DELETED_BY_PLAYER) {
                b->state = BUILDING_STATE_IN_USE;
            }
            b->is_deleted = 0;
        }
    }
    clear_buildings();
}

static void game_undo_add_building(struct building_t *b)
{
    if (b->id <= 0) {
        return;
    }
    undo_data.num_buildings = 0;
    int is_on_list = 0;
    for (int i = 0; i < MAX_UNDO_BUILDINGS; i++) {
        if (undo_data.buildings[i].id) {
            undo_data.num_buildings++;
        }
        if (undo_data.buildings[i].id == b->id) {
            is_on_list = 1;
        }
    }
    if (!is_on_list) {
        for (int i = 0; i < MAX_UNDO_BUILDINGS; i++) {
            if (!undo_data.buildings[i].id) {
                undo_data.num_buildings++;
                memcpy(&undo_data.buildings[i], b, sizeof(struct building_t));
                return;
            }
        }
        undo_data.available = 0;
    }
}

static int clear_land_confirmed(int measure_only, int x_start, int y_start, int x_end, int y_end)
{
    int items_placed = 0;
    game_undo_restore_building_state();
    game_undo_restore_map(0);

    int x_min, x_max, y_min, y_max;
    map_grid_start_end_to_area(x_start, y_start, x_end, y_end, &x_min, &y_min, &x_max, &y_max);

    int visual_feedback_on_delete = values[CONFIG_UI_VISUAL_FEEDBACK_ON_DELETE];

    for (int y = y_min; y <= y_max; y++) {
        for (int x = x_min; x <= x_max; x++) {
            int grid_offset = map_grid_offset(x, y);
            if (measure_only && visual_feedback_on_delete) {
                struct building_t *b = get_deletable_building(grid_offset);
                if (bitfields_grid.items[grid_offset] & BIT_DELETED || (b && bitfields_grid.items[b->grid_offset] & BIT_DELETED)) {
                    continue;
                }
                map_building_tiles_mark_deleting(grid_offset);
                if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
                    if (b) {
                        items_placed++;
                    }
                } else if (map_terrain_is(grid_offset, TERRAIN_SHRUB | TERRAIN_TREE) && !scenario.allowed_buildings[BUILDING_CLEAR_LAND]) {
                    continue;
                } else if (map_terrain_is(grid_offset, TERRAIN_ROCK | TERRAIN_ELEVATION)) {
                    continue;
                } else if (map_terrain_is(grid_offset, TERRAIN_WATER)) { // keep the "bridge is free" bug from C3
                    continue;
                } else if (map_terrain_is(grid_offset, TERRAIN_AQUEDUCT)
                    || map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR)) {
                    items_placed++;
                }
                continue;
            }
            if (map_terrain_is(grid_offset, TERRAIN_SHRUB | TERRAIN_TREE) && !scenario.allowed_buildings[BUILDING_CLEAR_LAND]) {
                continue;
            }
            if (map_terrain_is(grid_offset, TERRAIN_ROCK | TERRAIN_ELEVATION)) {
                continue;
            }
            if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
                struct building_t *b = get_deletable_building(grid_offset);
                if (!b) {
                    continue;
                }
                if (b->type == BUILDING_FORT_GROUND || building_is_fort(b->type)) {
                    if (!measure_only && confirm.fort_confirmed != 1) {
                        continue;
                    }
                    if (!measure_only && confirm.fort_confirmed == 1) {
                        undo_data.available = 0;
                    }
                }
                if (b->house_size && b->house_population && !measure_only) {
                    figure_create_homeless(b->x, b->y, b->house_population);
                    b->house_population = 0;
                }
                if (b->state != BUILDING_STATE_DELETED_BY_PLAYER) {
                    items_placed++;
                    game_undo_add_building(b);
                }
                b->state = BUILDING_STATE_DELETED_BY_PLAYER;
                b->is_deleted = 1;
                struct building_t *space = b;
                for (int i = 0; i < 9; i++) {
                    if (space->prev_part_building_id <= 0) {
                        break;
                    }
                    space = &all_buildings[space->prev_part_building_id];
                    game_undo_add_building(space);
                    space->state = BUILDING_STATE_DELETED_BY_PLAYER;
                }
                space = b;
                for (int i = 0; i < 9; i++) {
                    space = &all_buildings[space->next_part_building_id];
                    if (space->id <= 0) {
                        break;
                    }
                    game_undo_add_building(space);
                    space->state = BUILDING_STATE_DELETED_BY_PLAYER;
                }
            } else if (map_terrain_is(grid_offset, TERRAIN_AQUEDUCT)) {
                terrain_grid.items[grid_offset] &= ~TERRAIN_CLEARABLE;
                items_placed++;
                aqueduct.items[grid_offset] = 0;
                if (aqueduct.items[grid_offset + map_grid_delta(0, -1)] == 5) {
                    aqueduct.items[grid_offset + map_grid_delta(0, -1)] = 1;
                }
                if (aqueduct.items[grid_offset + map_grid_delta(1, 0)] == 6) {
                    aqueduct.items[grid_offset + map_grid_delta(1, 0)] = 2;
                }
                if (aqueduct.items[grid_offset + map_grid_delta(0, 1)] == 5) {
                    aqueduct.items[grid_offset + map_grid_delta(0, 1)] = 3;
                }
                if (aqueduct.items[grid_offset + map_grid_delta(-1, 0)] == 6) {
                    aqueduct.items[grid_offset + map_grid_delta(-1, 0)] = 4;
                }
            } else if (map_terrain_is(grid_offset, TERRAIN_WATER)) {
                int figures_n = 0;
                if (map_is_bridge(grid_offset)) {
                    int tiles_x = get_x_bridge_tiles(grid_offset);
                    int tiles_y = get_y_bridge_tiles(grid_offset);
                    int offset_up = tiles_x > tiles_y ? map_grid_delta(1, 0) : map_grid_delta(0, 1);
                    // find lower end of the bridge
                    while (map_is_bridge(grid_offset - offset_up)) {
                        grid_offset -= offset_up;
                    }
                    if (map_grid_is_valid_offset(grid_offset) && map_figures.items[grid_offset] > 0) {
                        figures_n = 1;
                    }
                    while (map_is_bridge(grid_offset + offset_up)) {
                        grid_offset += offset_up;
                        if (map_grid_is_valid_offset(grid_offset) && map_figures.items[grid_offset] > 0) {
                            figures_n++;
                        }
                    }
                }
                if (!measure_only && figures_n) {
                    city_warning_show(WARNING_PEOPLE_ON_BRIDGE);
                } else if (confirm.bridge_confirmed == 1) {
                    map_bridge_remove(grid_offset, measure_only);
                    items_placed++;
                }
            } else if (map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR)) {
                if (map_terrain_is(grid_offset, TERRAIN_ROAD)) {
                    bitfields_grid.items[grid_offset] &= BIT_NO_PLAZA;
                }
                terrain_grid.items[grid_offset] &= ~TERRAIN_CLEARABLE;
                items_placed++;
            }
        }
    }
    if (!measure_only || !visual_feedback_on_delete) {
        int radius;
        if (x_max - x_min <= y_max - y_min) {
            radius = y_max - y_min + 3;
        } else {
            radius = x_max - x_min + 3;
        }
        map_tiles_update_region_empty_land(x_min, y_min, x_max, y_max);
        foreach_region_tile(x_min, y_min, x_max, y_max, update_meadow_tile);
        foreach_region_tile(x_min, y_min, x_max, y_max, set_rubble_image);
        map_tiles_update_all_gardens();
        foreach_region_tile(x_min - 1, y_min - 1, x_min + radius - 2, y_min + radius - 2, set_road_image);
        map_tiles_update_all_plazas();
        foreach_region_tile(x_min - 1, y_min - 1, x_min + radius - 2, y_min + radius - 2, set_wall_image);
        foreach_region_tile(x_min - 3, y_min - 3, x_max + 3, y_max + 3, update_aqueduct_tile);
    }
    if (!measure_only) {
        map_routing_update_land();
        map_routing_update_walls();
        map_routing_update_water();
        window_invalidate();
    }
    return items_placed;
}

static void show(int warning)
{
    city_warning_show(warning);
    has_warning = 1;
}

static void building_construction_warning_check_food_stocks(int type)
{
    if (!has_warning && type == BUILDING_HOUSE_VACANT_LOT) {
        if (city_data.population.population >= 200 && !scenario.rome_supplies_wheat) {
            if (calc_percentage(city_data.resource.food_produced_last_month, city_data.resource.food_consumed_last_month) <= 95) {
                show(WARNING_MORE_FOOD_NEEDED);
            }
        }
    }
}

static void adjust_to_absolute_xy(int *x, int *y, int size)
{
    switch (view_data.orientation) {
        case DIR_2_RIGHT:
            *x = *x - size + 1;
            break;
        case DIR_4_BOTTOM:
            *x = *x - size + 1;
            /* fall through */
        case DIR_6_LEFT:
            *y = *y - size + 1;
            break;
    }
}

static void mark_construction(int x, int y, int size, int terrain, int absolute_xy)
{
    if (!absolute_xy) {
        adjust_to_absolute_xy(&x, &y, size);
    }
    if (map_grid_is_inside(x, y, size)) {
        for (int dy = 0; dy < size; dy++) {
            for (int dx = 0; dx < size; dx++) {
                int grid_offset = map_grid_offset(x + dx, y + dy);
                if (map_terrain_is(grid_offset, terrain & TERRAIN_NOT_CLEAR) || (map_grid_is_valid_offset(grid_offset) && map_figures.items[grid_offset] > 0)) {
                    return;
                }
            }
        }
        // mark as being constructed
        for (int dy = 0; dy < size; dy++) {
            for (int dx = 0; dx < size; dx++) {
                int grid_offset = map_grid_offset(x + dx, y + dy);
                bitfields_grid.items[grid_offset] |= BIT_CONSTRUCTION;
            }
        }
    }
    construction_data.draw_as_constructing = 1;
}

static int place_houses(int measure_only, int x_start, int y_start, int x_end, int y_end)
{
    int x_min, x_max, y_min, y_max;
    map_grid_start_end_to_area(x_start, y_start, x_end, y_end, &x_min, &y_min, &x_max, &y_max);

    int needs_road_warning = 0;
    int items_placed = 0;
    game_undo_restore_building_state();
    for (int y = y_min; y <= y_max; y++) {
        for (int x = x_min; x <= x_max; x++) {
            int grid_offset = map_grid_offset(x, y);
            if (map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR)) {
                continue;
            }
            if (measure_only) {
                bitfields_grid.items[grid_offset] |= BIT_CONSTRUCTION;
                items_placed++;
            } else {
                struct building_t *b = building_create(BUILDING_HOUSE_VACANT_LOT, x, y);
                game_undo_add_building(b);
                if (b->id > 0) {
                    items_placed++;
                    map_building_tiles_add(b->id, x, y, 1,
                        image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_VACANT_LOT], TERRAIN_BUILDING);
                    if (!map_terrain_exists_tile_in_radius_with_type(x, y, 1, 2, TERRAIN_ROAD)) {
                        needs_road_warning = 1;
                    }
                }
            }
        }
    }
    if (!measure_only) {
        building_construction_warning_check_food_stocks(BUILDING_HOUSE_VACANT_LOT);
        if (needs_road_warning) {
            city_warning_show(WARNING_HOUSE_TOO_FAR_FROM_ROAD);
        }
        map_routing_update_land();
        window_invalidate();
    }
    return items_placed;
}

static int place_plaza(int x_start, int y_start, int x_end, int y_end)
{
    int x_min, y_min, x_max, y_max;
    map_grid_start_end_to_area(x_start, y_start, x_end, y_end, &x_min, &y_min, &x_max, &y_max);
    game_undo_restore_map(1);

    int items_placed = 0;
    for (int y = y_min; y <= y_max; y++) {
        for (int x = x_min; x <= x_max; x++) {
            int grid_offset = map_grid_offset(x, y);
            if (map_terrain_is(grid_offset, TERRAIN_ROAD) &&
                !map_terrain_is(grid_offset, TERRAIN_WATER | TERRAIN_BUILDING | TERRAIN_AQUEDUCT)) {
                if (!(bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE)) {
                    items_placed++;
                }
                images.items[grid_offset] = 0;
                bitfields_grid.items[grid_offset] |= BIT_PLAZA_OR_EARTHQUAKE;
                map_property_set_multi_tile_size(grid_offset, 1);
                edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
            }
        }
    }
    map_tiles_update_all_plazas();
    return items_placed;
}

static int place_garden(int x_start, int y_start, int x_end, int y_end)
{
    game_undo_restore_map(1);
    int x_min, y_min, x_max, y_max;
    map_grid_start_end_to_area(x_start, y_start, x_end, y_end, &x_min, &y_min, &x_max, &y_max);

    int items_placed = 0;
    for (int y = y_min; y <= y_max; y++) {
        for (int x = x_min; x <= x_max; x++) {
            int grid_offset = map_grid_offset(x, y);
            if (!map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR)) {
                items_placed++;
                terrain_grid.items[grid_offset] |= TERRAIN_GARDEN;
            }
        }
    }
    map_tiles_update_all_gardens();
    return items_placed;
}

static int building_construction_place_aqueduct(int x_start, int y_start, int x_end, int y_end, int *cost)
{
    game_undo_restore_map(0);

    *cost = 0;
    int blocked = 0;
    int grid_offset = map_grid_offset(x_start, y_start);
    if (map_terrain_is(grid_offset, TERRAIN_ROAD)) {
        if (bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
            blocked = 1;
        }
    } else if (map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR)) {
        blocked = 1;
    }
    grid_offset = map_grid_offset(x_end, y_end);
    if (map_terrain_is(grid_offset, TERRAIN_ROAD)) {
        if (bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
            blocked = 1;
        }
    } else if (map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR)) {
        blocked = 1;
    }
    if (blocked) {
        return 0;
    }
    if (!map_routing_calculate_distances_for_building(ROUTED_BUILDING_AQUEDUCT, x_start, y_start)) {
        return 0;
    }
    int num_items;
    place_routed_building(x_start, y_start, x_end, y_end, ROUTED_BUILDING_AQUEDUCT, &num_items);
    *cost = building_properties[BUILDING_AQUEDUCT].cost * num_items;
    return 1;
}

static int building_construction_place_wall(int measure_only, int x_start, int y_start, int x_end, int y_end)
{
    game_undo_restore_map(0);

    int start_offset = map_grid_offset(x_start, y_start);
    int end_offset = map_grid_offset(x_end, y_end);
    int forbidden_terrain_mask =
        TERRAIN_SHRUB | TERRAIN_ROCK | TERRAIN_WATER | TERRAIN_BUILDING |
        TERRAIN_TREE | TERRAIN_ROAD | TERRAIN_GARDEN | TERRAIN_ELEVATION |
        TERRAIN_RUBBLE | TERRAIN_AQUEDUCT | TERRAIN_ACCESS_RAMP;
    if (map_terrain_is(start_offset, forbidden_terrain_mask)) {
        return 0;
    }
    if (map_terrain_is(end_offset, forbidden_terrain_mask)) {
        return 0;
    }
    int items_placed = 0;
    if (place_routed_building(x_start, y_start, x_end, y_end, ROUTED_BUILDING_WALL, &items_placed)) {
        if (!measure_only) {
            map_routing_update_land();
            map_routing_update_walls();
            window_invalidate();
        }
    }
    return items_placed;
}

static void confirm_delete_fort(void)
{
    confirm.fort_confirmed = 1;
    clear_land_confirmed(0, confirm.x_start, confirm.y_start, confirm.x_end, confirm.y_end);
}

static void confirm_delete_bridge(void)
{
    confirm.bridge_confirmed = 1;
    clear_land_confirmed(0, confirm.x_start, confirm.y_start, confirm.x_end, confirm.y_end);
}

static int building_construction_clear_land(int measure_only, int x_start, int y_start, int x_end, int y_end)
{
    confirm.fort_confirmed = 0;
    confirm.bridge_confirmed = 0;
    if (measure_only) {
        return clear_land_confirmed(measure_only, x_start, y_start, x_end, y_end);
    }

    int x_min, x_max, y_min, y_max;
    map_grid_start_end_to_area(x_start, y_start, x_end, y_end, &x_min, &y_min, &x_max, &y_max);

    int ask_confirm_bridge = 0;
    int ask_confirm_fort = 0;
    for (int y = y_min; y <= y_max; y++) {
        for (int x = x_min; x <= x_max; x++) {
            int grid_offset = map_grid_offset(x, y);
            int building_id = map_building_at(grid_offset);
            if (building_id) {
                struct building_t *b = &all_buildings[building_id];
                if (building_is_fort(b->type) || b->type == BUILDING_FORT_GROUND) {
                    ask_confirm_fort = 1;
                }
            }
            if (map_is_bridge(grid_offset)) {
                ask_confirm_bridge = 1;
            }
        }
    }
    confirm.x_start = x_start;
    confirm.y_start = y_start;
    confirm.x_end = x_end;
    confirm.y_end = y_end;
    if (ask_confirm_fort) {
        window_popup_dialog_show(POPUP_DIALOG_DELETE_FORT, confirm_delete_fort, 2);
        return -1;
    } else if (ask_confirm_bridge) {
        window_popup_dialog_show(POPUP_DIALOG_DELETE_BRIDGE, confirm_delete_bridge, 2);
        return -1;
    } else {
        return clear_land_confirmed(measure_only, x_start, y_start, x_end, y_end);
    }
}

static int map_building_tiles_are_clear(int x, int y, int size, int terrain)
{
    adjust_to_absolute_xy(&x, &y, size);
    if (!map_grid_is_inside(x, y, size)) {
        return 0;
    }
    for (int dy = 0; dy < size; dy++) {
        for (int dx = 0; dx < size; dx++) {
            int grid_offset = map_grid_offset(x + dx, y + dy);
            if (map_terrain_is(grid_offset, terrain & TERRAIN_NOT_CLEAR)) {
                return 0;
            }
        }
    }
    return 1;
}

static struct building_t *add_warehouse_space(int x, int y, struct building_t *prev)
{
    struct building_t *b = building_create(BUILDING_WAREHOUSE_SPACE, x, y);
    game_undo_add_building(b);
    b->prev_part_building_id = prev->id;
    prev->next_part_building_id = b->id;
    map_building_tiles_add(b->id, x, y, 1, EMPTY_WAREHOUSE_IMG_ID, TERRAIN_BUILDING);
    return b;
}

static int map_bridge_add(int x, int y, int is_ship_bridge)
{
    int min_length = is_ship_bridge ? 5 : 2;
    if (bridge.end_grid_offset <= 0 || bridge.length < min_length) {
        bridge.length = 0;
        return bridge.length;
    }
    bridge.direction -= view_data.orientation;
    if (bridge.direction < 0) {
        bridge.direction += 8;
    }

    int grid_offset = map_grid_offset(x, y);
    for (int i = 0; i < bridge.length; i++) {
        terrain_grid.items[grid_offset] |= TERRAIN_ROAD;
        int value = map_bridge_get_sprite_id(i, bridge.length, bridge.direction, is_ship_bridge);
        sprite.items[grid_offset] = value;
        grid_offset += bridge.direction_grid_delta;
    }
    map_routing_update_land();
    map_routing_update_water();
    return bridge.length;
}

static void building_construction_place(void)
{
    construction_data.cost_preview = 0;
    construction_data.in_progress = 0;
    int x_start = construction_data.start.x;
    int y_start = construction_data.start.y;
    int x_end = construction_data.end.x;
    int y_end = construction_data.end.y;
    has_warning = 0;
    if (!construction_data.type) {
        return;
    }
    if (construction_data.type >= BUILDING_LARGE_TEMPLE_CERES && construction_data.type <= BUILDING_LARGE_TEMPLE_VENUS
        && city_data.resource.stored_in_warehouses[RESOURCE_MARBLE] < 2) {
        map_property_clear_constructing_and_deleted();
        city_warning_show(WARNING_MARBLE_NEEDED_LARGE_TEMPLE);
        return;
    }
    if (construction_data.type == BUILDING_ORACLE && city_data.resource.stored_in_warehouses[RESOURCE_MARBLE] < 2) {
        map_property_clear_constructing_and_deleted();
        city_warning_show(WARNING_MARBLE_NEEDED_ORACLE);
        return;
    }
    int enemy_type = 0;
    for (int i = 1; i < MAX_FIGURES; i++) {
        struct figure_t *f = &figures[i];
        if (figure_is_alive(f) && (figure_properties[f->type].is_enemy_unit || figure_properties[f->type].is_caesar_legion_unit || f->type == FIGURE_WOLF)) {
            int dx = (f->x > x_start) ? (f->x - x_start) : (x_start - f->x);
            int dy = (f->y > y_start) ? (f->y - y_start) : (y_start - f->y);
            if (dx <= 12 && dy <= 12) {
                enemy_type = f->type;
                break;
            }
            dx = (f->x > x_end) ? (f->x - x_end) : (x_end - f->x);
            dy = (f->y > y_end) ? (f->y - y_end) : (y_end - f->y);
            if (dx <= 12 && dy <= 12) {
                enemy_type = f->type;
                break;
            }
        }
    }
    if (construction_data.type != BUILDING_CLEAR_LAND && enemy_type) {
        if (construction_data.type == BUILDING_WALL || construction_data.type == BUILDING_ROAD || construction_data.type == BUILDING_AQUEDUCT) {
            game_undo_restore_map(0);
        } else if (construction_data.type == BUILDING_PLAZA || construction_data.type == BUILDING_GARDENS) {
            game_undo_restore_map(1);
        } else if (construction_data.type == BUILDING_LOW_BRIDGE || construction_data.type == BUILDING_SHIP_BRIDGE) {
            bridge.length = 0;
        } else {
            map_property_clear_constructing_and_deleted();
        }
        if (enemy_type == FIGURE_WOLF) {
            play_sound_effect(SOUND_EFFECT_WOLF_ATTACK_2);
        } else {
            city_warning_show(WARNING_ENEMY_NEARBY);
        }
        return;
    }

    int placement_cost = building_properties[construction_data.type].cost;
    if (construction_data.type == BUILDING_CLEAR_LAND) {
        // BUG in original (keep this behaviour): if confirmation has to be asked (bridge/fort),
        // the previous cost is deducted from treasury and if user chooses 'no', they still pay for removal.
        // If we don't do it this way, the user doesn't pay for the removal at all since we don't come back
        // here when the user says yes.
        int items_placed = building_construction_clear_land(0, x_start, y_start, x_end, y_end);
        if (items_placed < 0) {
            items_placed = last_items_cleared;
        }
        placement_cost *= items_placed;
        map_property_clear_constructing_and_deleted();
    } else if (construction_data.type == BUILDING_WALL) {
        placement_cost *= building_construction_place_wall(0, x_start, y_start, x_end, y_end);
    } else if (construction_data.type == BUILDING_ROAD) {
        placement_cost *= building_construction_place_road(0, x_start, y_start, x_end, y_end);
    } else if (construction_data.type == BUILDING_PLAZA) {
        placement_cost *= place_plaza(x_start, y_start, x_end, y_end);
    } else if (construction_data.type == BUILDING_GARDENS) {
        placement_cost *= place_garden(x_start, y_start, x_end, y_end);
        map_routing_update_land();
    } else if (construction_data.type == BUILDING_LOW_BRIDGE) {
        int length = map_bridge_add(x_end, y_end, 0);
        if (length <= 1) {
            city_warning_show(WARNING_SHORE_NEEDED);
            return;
        }
        placement_cost *= length;
    } else if (construction_data.type == BUILDING_SHIP_BRIDGE) {
        int length = map_bridge_add(x_end, y_end, 1);
        if (length <= 1) {
            city_warning_show(WARNING_SHORE_NEEDED);
            return;
        }
        placement_cost *= length;
    } else if (construction_data.type == BUILDING_AQUEDUCT) {
        int cost;
        if (!building_construction_place_aqueduct(x_start, y_start, x_end, y_end, &cost)) {
            city_warning_show(WARNING_CLEAR_LAND_NEEDED);
            return;
        }
        placement_cost = cost;
        map_tiles_update_all_aqueducts(0);
        map_routing_update_land();
    } else if (construction_data.type == BUILDING_HOUSE_VACANT_LOT) {
        placement_cost *= place_houses(0, x_start, y_start, x_end, y_end);
    } else {
        int terrain_mask = TERRAIN_ALL;
        if (construction_data.type == BUILDING_GATEHOUSE || construction_data.type == BUILDING_TRIUMPHAL_ARCH) {
            terrain_mask = ~TERRAIN_ROAD;
        } else if (construction_data.type == BUILDING_TOWER) {
            terrain_mask = ~TERRAIN_WALL;
        }
        int size = building_properties[construction_data.type].size;
        if (construction_data.type == BUILDING_WAREHOUSE) {
            size = 3;
        }
        int building_orientation = 0;
        if (construction_data.type == BUILDING_GATEHOUSE) {
            building_orientation = map_orientation_for_gatehouse(x_end, y_end);
        } else if (construction_data.type == BUILDING_TRIUMPHAL_ARCH) {
            building_orientation = map_orientation_for_triumphal_arch(x_end, y_end);
        }
        switch (view_data.orientation) {
            case DIR_2_RIGHT: x_end = x_end - size + 1; break;
            case DIR_4_BOTTOM: x_end = x_end - size + 1; y_end = y_end - size + 1; break;
            case DIR_6_LEFT: y_end = y_end - size + 1; break;
        }
        // extra checks
        if (construction_data.type == BUILDING_GATEHOUSE) {
            if (!is_clear(x_end, y_end, size, terrain_mask, 0)) {
                city_warning_show(WARNING_CLEAR_LAND_NEEDED);
                return;
            }
            if (!building_orientation) {
                if (construction_data.road_orientation == 1) {
                    building_orientation = 1;
                } else {
                    building_orientation = 2;
                }
            }
        }
        if (construction_data.type == BUILDING_TRIUMPHAL_ARCH) {
            if (!is_clear(x_end, y_end, size, terrain_mask, 0)) {
                city_warning_show(WARNING_CLEAR_LAND_NEEDED);
                return;
            }
            if (!building_orientation) {
                if (construction_data.road_orientation == 1) {
                    building_orientation = 1;
                } else {
                    building_orientation = 3;
                }
            }
        }
        int waterside_orientation_abs = 0, waterside_orientation_rel = 0;
        if (construction_data.type == BUILDING_SHIPYARD || construction_data.type == BUILDING_WHARF) {
            if (map_water_determine_orientation_size2(
                x_end, y_end, 0, &waterside_orientation_abs, &waterside_orientation_rel)) {
                city_warning_show(WARNING_SHORE_NEEDED);
                return;
            }
        } else if (construction_data.type == BUILDING_DOCK) {
            if (map_water_determine_orientation_size3(
                x_end, y_end, 0, &waterside_orientation_abs, &waterside_orientation_rel)) {
                city_warning_show(WARNING_SHORE_NEEDED);
                return;
            }
            map_routing_calculate_distances_water_boat(scenario.river_entry_point.x, scenario.river_entry_point.y);
            if (!map_terrain_is_adjacent_to_open_water(x_end, y_end, 3)) {
                city_warning_show(WARNING_DOCK_OPEN_WATER_NEEDED);
                return;
            }
        } else {
            if (!is_clear(x_end, y_end, size, terrain_mask, 0)) {
                city_warning_show(WARNING_CLEAR_LAND_NEEDED);
                return;
            }
            int warning_id;
            if (!check_building_terrain_requirements(x_end, y_end, &warning_id)) {
                city_warning_show(warning_id);
                return;
            }
        }
        if (building_is_fort(construction_data.type)) {
            if (!is_clear(x_end + 3, y_end - 1, 4, terrain_mask, 0)) {
                city_warning_show(WARNING_CLEAR_LAND_NEEDED);
                return;
            }
            if (city_data.military.total_legions >= MAX_LEGIONS) {
                city_warning_show(WARNING_MAX_LEGIONS_REACHED);
                return;
            }
        }
        if (construction_data.type == BUILDING_HIPPODROME) {
            if (city_data.building.hippodrome_placed) {
                city_warning_show(WARNING_ONE_BUILDING_OF_TYPE);
                return;
            }
            if (!is_clear(x_end + 5, y_end, 5, terrain_mask, 0)
               || !is_clear(x_end + 10, y_end, 5, terrain_mask, 0)) {
                city_warning_show(WARNING_CLEAR_LAND_NEEDED);
                return;
            }
        }
        if (construction_data.type == BUILDING_SENATE && city_data.building.senate_placed) {
            city_warning_show(WARNING_ONE_BUILDING_OF_TYPE);
            return;
        }
        if (construction_data.type == BUILDING_BARRACKS && count_data.buildings[BUILDING_BARRACKS].total > 0) {
            city_warning_show(WARNING_ONE_BUILDING_OF_TYPE);
            return;
        }
        building_construction_warning_check_food_stocks(construction_data.type);
        if (!has_warning && construction_data.type != BUILDING_WELL && !building_is_fort(construction_data.type)) {
            if (building_properties[construction_data.type].n_laborers > 0 && city_data.labor.workers_needed >= 10) {
                show(WARNING_WORKERS_NEEDED);
            }
        }
        if (!has_warning && construction_data.type == BUILDING_GRANARY) {
            if (!count_data.buildings[BUILDING_MARKET].active) {
                show(WARNING_BUILD_MARKET);
            }
        }
        if (!has_warning && construction_data.type == BUILDING_THEATER) {
            if (!count_data.buildings[BUILDING_ACTOR_COLONY].active) {
                show(WARNING_BUILD_ACTOR_COLONY);
            }
        }
        if (!has_warning && construction_data.type == BUILDING_AMPHITHEATER) {
            if (!count_data.buildings[BUILDING_GLADIATOR_SCHOOL].active) {
                show(WARNING_BUILD_GLADIATOR_SCHOOL);
            }
        }
        if (!has_warning && construction_data.type == BUILDING_COLOSSEUM) {
            if (!count_data.buildings[BUILDING_LION_HOUSE].active) {
                show(WARNING_BUILD_LION_HOUSE);
            }
        }
        if (!has_warning && construction_data.type == BUILDING_HIPPODROME) {
            if (!count_data.buildings[BUILDING_CHARIOT_MAKER].active) {
                show(WARNING_BUILD_CHARIOT_MAKER);
            }
        }
        if (!has_warning) {
            if (building_is_fort(construction_data.type) && !count_data.buildings[BUILDING_BARRACKS].active) {
                show(WARNING_BUILD_BARRACKS);
            }
        }
        if (!has_warning && construction_data.type == BUILDING_BARRACKS) {
            if (city_data.resource.stored_in_warehouses[RESOURCE_WEAPONS] <= 0) {
                show(WARNING_WEAPONS_NEEDED);
            }
        }
        if (!has_warning && construction_data.type == BUILDING_TOWER) {
            int terrain_is_adjacent_to_wall = 0;
            int base_offset = map_grid_offset(x_end, y_end);
            for (int *tile_delta = ADJACENT_OFFSETS_MAP_GRID[size]; *tile_delta; tile_delta++) {
                if (map_terrain_is(base_offset + *tile_delta, TERRAIN_WALL)) {
                    terrain_is_adjacent_to_wall = 1;
                    break;
                }
            }
            if (!terrain_is_adjacent_to_wall) {
                show(WARNING_SENTRIES_NEED_WALL);
            }
        }
        if (!has_warning
        && (construction_data.type == BUILDING_FOUNTAIN || construction_data.type == BUILDING_BATHHOUSE)) {
            int grid_offset = map_grid_offset(x_end, y_end);
            int has_water = 0;
            if (map_terrain_is(grid_offset, TERRAIN_RESERVOIR_RANGE)) {
                has_water = 1;
            } else if (construction_data.type == BUILDING_BATHHOUSE) {
                if (map_terrain_is(grid_offset + map_grid_delta(1, 0), TERRAIN_RESERVOIR_RANGE) ||
                    map_terrain_is(grid_offset + map_grid_delta(0, 1), TERRAIN_RESERVOIR_RANGE) ||
                    map_terrain_is(grid_offset + map_grid_delta(1, 1), TERRAIN_RESERVOIR_RANGE)) {
                    has_water = 1;
                }
            }
            if (!has_water) {
                show(WARNING_WATER_PIPE_ACCESS_NEEDED);
            }
        }
        switch (construction_data.type) {
            case BUILDING_SMALL_STATUE:
            case BUILDING_MEDIUM_STATUE:
            case BUILDING_LARGE_STATUE:
            case BUILDING_FOUNTAIN:
            case BUILDING_WELL:
            case BUILDING_RESERVOIR:
            case BUILDING_GATEHOUSE:
            case BUILDING_TRIUMPHAL_ARCH:
            case BUILDING_HOUSE_VACANT_LOT:
            case BUILDING_FORT_LEGIONARIES:
            case BUILDING_FORT_JAVELIN:
            case BUILDING_FORT_MOUNTED:
                break;
            default:
            {
                int has_road = 0;
                if (map_has_road_access(x_end, y_end, size, 0)
                || (construction_data.type == BUILDING_WAREHOUSE && map_has_road_access(x_end, y_end, size, 0))
                || (construction_data.type == BUILDING_HIPPODROME && map_has_road_access_hippodrome(x_end, y_end, 0))) {
                    has_road = 1;
                }
                if (!has_road) {
                    show(WARNING_ROAD_ACCESS_NEEDED);
                }
            }
        }
        // check raw resources availability
        int raw_resource = 0;
        int finished_good = 0;
        int warning_resource_needed = 0;
        int warning_resource_building = 0;
        switch (construction_data.type) {
            case BUILDING_OIL_WORKSHOP:
                raw_resource = RESOURCE_OLIVES;
                finished_good = RESOURCE_OIL;
                warning_resource_needed = WARNING_OLIVES_NEEDED;
                warning_resource_building = WARNING_BUILD_OLIVE_FARM;
                break;
            case BUILDING_WINE_WORKSHOP:
                raw_resource = RESOURCE_VINES;
                finished_good = RESOURCE_WINE;
                warning_resource_needed = WARNING_VINES_NEEDED;
                warning_resource_building = WARNING_BUILD_VINES_FARM;
                break;
            case BUILDING_WEAPONS_WORKSHOP:
                raw_resource = RESOURCE_IRON;
                finished_good = RESOURCE_WEAPONS;
                warning_resource_needed = WARNING_IRON_NEEDED;
                warning_resource_building = WARNING_BUILD_IRON_MINE;
                break;
            case BUILDING_FURNITURE_WORKSHOP:
                raw_resource = RESOURCE_TIMBER;
                finished_good = RESOURCE_FURNITURE;
                warning_resource_needed = WARNING_TIMBER_NEEDED;
                warning_resource_building = WARNING_BUILD_TIMBER_YARD;
                break;
            case BUILDING_POTTERY_WORKSHOP:
                raw_resource = RESOURCE_CLAY;
                finished_good = RESOURCE_POTTERY;
                warning_resource_needed = WARNING_CLAY_NEEDED;
                warning_resource_building = WARNING_BUILD_CLAY_PIT;
                break;
            default:
                break;
        }
        if (raw_resource && !count_data.industry[raw_resource].active) {
            if (city_data.resource.stored_in_warehouses[finished_good] <= 0 && city_data.resource.stored_in_warehouses[raw_resource] <= 0) {
                show(warning_resource_needed);
                int empire_offers_resource = 0;
                for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
                    if (empire_objects[i].in_use
                        && empire_objects[i].city_type == EMPIRE_CITY_TRADE
                        && empire_objects[i].resource_sell_limit[raw_resource]) {
                        empire_offers_resource = 1;
                        break;
                    }
                }
                if (our_city_can_produce_resource(raw_resource)) {
                    show(warning_resource_building);
                } else if (empire_offers_resource && !resource_import_trade_route_open(raw_resource)) {
                    show(WARNING_OPEN_TRADE_TO_IMPORT);
                } else if (city_data.resource.trade_status[raw_resource] != TRADE_STATUS_IMPORT) {
                    show(WARNING_TRADE_IMPORT_RESOURCE);
                }
            }
        }
        // phew, checks done!
        struct building_t *b;
        b = building_create(construction_data.type, x_end, y_end);
        game_undo_add_building(b);
        if (b->id <= 0) {
            return;
        }
        switch (b->type) {
            case BUILDING_HOUSE_LARGE_TENT:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_TENT] + 2, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_SMALL_SHACK:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_SHACK], TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_LARGE_SHACK:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_SHACK] + 2, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_SMALL_HOVEL:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_HOVEL], TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_LARGE_HOVEL:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_HOVEL] + 2, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_SMALL_CASA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_CASA], TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_LARGE_CASA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_CASA] + 2, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_SMALL_INSULA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_INSULA_1], TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_MEDIUM_INSULA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_INSULA_1] + 2, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_LARGE_INSULA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_INSULA_2], TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_GRAND_INSULA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_INSULA_2] + 2, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_SMALL_VILLA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_VILLA_1], TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_MEDIUM_VILLA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_VILLA_1] + 2, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_LARGE_VILLA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_VILLA_2], TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_GRAND_VILLA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_VILLA_2] + 1, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_SMALL_PALACE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_PALACE_1], TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_MEDIUM_PALACE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_PALACE_1] + 1, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_LARGE_PALACE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_PALACE_2], TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_LUXURY_PALACE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_HOUSE_PALACE_2] + 1, TERRAIN_BUILDING);
                break;
            case BUILDING_AMPHITHEATER:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_AMPHITHEATER], TERRAIN_BUILDING);
                break;
            case BUILDING_THEATER:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_THEATER], TERRAIN_BUILDING);
                break;
            case BUILDING_COLOSSEUM:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_COLOSSEUM], TERRAIN_BUILDING);
                break;
            case BUILDING_GLADIATOR_SCHOOL:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_GLADIATOR_SCHOOL], TERRAIN_BUILDING);
                break;
            case BUILDING_LION_HOUSE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_LION_HOUSE], TERRAIN_BUILDING);
                break;
            case BUILDING_ACTOR_COLONY:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_ACTOR_COLONY], TERRAIN_BUILDING);
                break;
            case BUILDING_CHARIOT_MAKER:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_CHARIOT_MAKER], TERRAIN_BUILDING);
                break;
            case BUILDING_SMALL_STATUE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_STATUE], TERRAIN_BUILDING);
                break;
            case BUILDING_MEDIUM_STATUE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_STATUE] + 1, TERRAIN_BUILDING);
                break;
            case BUILDING_LARGE_STATUE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_STATUE] + 2, TERRAIN_BUILDING);
                break;
            case BUILDING_DOCTOR:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_DOCTOR], TERRAIN_BUILDING);
                break;
            case BUILDING_HOSPITAL:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_HOSPITAL], TERRAIN_BUILDING);
                break;
            case BUILDING_BATHHOUSE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_BATHHOUSE_NO_WATER], TERRAIN_BUILDING);
                break;
            case BUILDING_BARBER:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_BARBER], TERRAIN_BUILDING);
                break;
            case BUILDING_SCHOOL:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_SCHOOL], TERRAIN_BUILDING);
                break;
            case BUILDING_ACADEMY:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_ACADEMY], TERRAIN_BUILDING);
                break;
            case BUILDING_LIBRARY:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_LIBRARY], TERRAIN_BUILDING);
                break;
            case BUILDING_PREFECTURE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_PREFECTURE], TERRAIN_BUILDING);
                break;
            case BUILDING_WHEAT_FARM:
                map_building_tiles_add_farm(b->id, b->x, b->y, image_data_s.group_image_ids[GROUP_BUILDING_FARM_CROPS], 0);
                break;
            case BUILDING_VEGETABLE_FARM:
                map_building_tiles_add_farm(b->id, b->x, b->y, image_data_s.group_image_ids[GROUP_BUILDING_FARM_CROPS] + 5, 0);
                break;
            case BUILDING_FRUIT_FARM:
                map_building_tiles_add_farm(b->id, b->x, b->y, image_data_s.group_image_ids[GROUP_BUILDING_FARM_CROPS] + 10, 0);
                break;
            case BUILDING_OLIVE_FARM:
                map_building_tiles_add_farm(b->id, b->x, b->y, image_data_s.group_image_ids[GROUP_BUILDING_FARM_CROPS] + 15, 0);
                break;
            case BUILDING_VINES_FARM:
                map_building_tiles_add_farm(b->id, b->x, b->y, image_data_s.group_image_ids[GROUP_BUILDING_FARM_CROPS] + 20, 0);
                break;
            case BUILDING_PIG_FARM:
                map_building_tiles_add_farm(b->id, b->x, b->y, image_data_s.group_image_ids[GROUP_BUILDING_FARM_CROPS] + 25, 0);
                break;
            case BUILDING_MARBLE_QUARRY:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_MARBLE_QUARRY], TERRAIN_BUILDING);
                break;
            case BUILDING_IRON_MINE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_IRON_MINE], TERRAIN_BUILDING);
                break;
            case BUILDING_TIMBER_YARD:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_TIMBER_YARD], TERRAIN_BUILDING);
                break;
            case BUILDING_CLAY_PIT:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_CLAY_PIT], TERRAIN_BUILDING);
                break;
            case BUILDING_WINE_WORKSHOP:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_WINE_WORKSHOP], TERRAIN_BUILDING);
                break;
            case BUILDING_OIL_WORKSHOP:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_OIL_WORKSHOP], TERRAIN_BUILDING);
                break;
            case BUILDING_WEAPONS_WORKSHOP:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_WEAPONS_WORKSHOP], TERRAIN_BUILDING);
                break;
            case BUILDING_FURNITURE_WORKSHOP:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_FURNITURE_WORKSHOP], TERRAIN_BUILDING);
                break;
            case BUILDING_POTTERY_WORKSHOP:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_POTTERY_WORKSHOP], TERRAIN_BUILDING);
                break;
            case BUILDING_GRANARY:
                b->storage_id = building_storage_create();
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_GRANARY], TERRAIN_BUILDING);
                foreach_region_tile(b->x - 1, b->y - 1, b->x + 5 - 2, b->y + 5 - 2, set_road_image);
                break;
            case BUILDING_MARKET:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_MARKET], TERRAIN_BUILDING);
                break;
            case BUILDING_GOVERNORS_HOUSE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_GOVERNORS_HOUSE], TERRAIN_BUILDING);
                break;
            case BUILDING_GOVERNORS_VILLA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_GOVERNORS_VILLA], TERRAIN_BUILDING);
                break;
            case BUILDING_GOVERNORS_PALACE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_GOVERNORS_PALACE], TERRAIN_BUILDING);
                break;
            case BUILDING_MISSION_POST:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_MISSION_POST], TERRAIN_BUILDING);
                break;
            case BUILDING_ENGINEERS_POST:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_ENGINEERS_POST], TERRAIN_BUILDING);
                break;
            case BUILDING_FORUM:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_FORUM], TERRAIN_BUILDING);
                break;
            case BUILDING_RESERVOIR:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_RESERVOIR], TERRAIN_BUILDING);
                break;
            case BUILDING_FOUNTAIN:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_FOUNTAIN_1], TERRAIN_BUILDING);
                break;
            case BUILDING_WELL:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_WELL], TERRAIN_BUILDING);
                break;
            case BUILDING_MILITARY_ACADEMY:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_MILITARY_ACADEMY], TERRAIN_BUILDING);
                break;
            case BUILDING_SMALL_TEMPLE_CERES:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_TEMPLE_CERES], TERRAIN_BUILDING);
                break;
            case BUILDING_SMALL_TEMPLE_NEPTUNE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_TEMPLE_NEPTUNE], TERRAIN_BUILDING);
                break;
            case BUILDING_SMALL_TEMPLE_MERCURY:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_TEMPLE_MERCURY], TERRAIN_BUILDING);
                break;
            case BUILDING_SMALL_TEMPLE_MARS:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_TEMPLE_MARS], TERRAIN_BUILDING);
                break;
            case BUILDING_SMALL_TEMPLE_VENUS:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_TEMPLE_VENUS], TERRAIN_BUILDING);
                break;
            case BUILDING_LARGE_TEMPLE_CERES:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_TEMPLE_CERES] + 1, TERRAIN_BUILDING);
                break;
            case BUILDING_LARGE_TEMPLE_NEPTUNE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_TEMPLE_NEPTUNE] + 1, TERRAIN_BUILDING);
                break;
            case BUILDING_LARGE_TEMPLE_MERCURY:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_TEMPLE_MERCURY] + 1, TERRAIN_BUILDING);
                break;
            case BUILDING_LARGE_TEMPLE_MARS:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_TEMPLE_MARS] + 1, TERRAIN_BUILDING);
                break;
            case BUILDING_LARGE_TEMPLE_VENUS:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_TEMPLE_VENUS] + 1, TERRAIN_BUILDING);
                break;
            case BUILDING_ORACLE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_ORACLE], TERRAIN_BUILDING);
                break;
            case BUILDING_SHIPYARD:
                b->data.industry.orientation = waterside_orientation_abs;
                map_water_add_building(b->id, b->x, b->y, 2,
                    image_data_s.group_image_ids[GROUP_BUILDING_SHIPYARD] + waterside_orientation_rel);
                break;
            case BUILDING_WHARF:
                b->data.industry.orientation = waterside_orientation_abs;
                map_water_add_building(b->id, b->x, b->y, 2,
                    image_data_s.group_image_ids[GROUP_BUILDING_WHARF] + waterside_orientation_rel);
                break;
            case BUILDING_DOCK:
                city_data.building.working_docks++;
                b->data.dock.orientation = waterside_orientation_abs;
                {
                    int image_id;
                    switch (waterside_orientation_rel) {
                        case 0: image_id = image_data_s.group_image_ids[GROUP_BUILDING_DOCK_1]; break;
                        case 1: image_id = image_data_s.group_image_ids[GROUP_BUILDING_DOCK_2]; break;
                        case 2: image_id = image_data_s.group_image_ids[GROUP_BUILDING_DOCK_3]; break;
                        default:image_id = image_data_s.group_image_ids[GROUP_BUILDING_DOCK_4]; break;
                    }
                    map_water_add_building(b->id, b->x, b->y, b->size, image_id);
                }
                break;
            case BUILDING_TOWER:
            {
                int x_min, y_min, x_max, y_max;
                map_grid_get_area(b->x, b->y, size, 0, &x_min, &y_min, &x_max, &y_max);

                for (int yy = y_min; yy <= y_max; yy++) {
                    for (int xx = x_min; xx <= x_max; xx++) {
                        terrain_grid.items[map_grid_offset(xx, yy)] &= ~TERRAIN_WALL;
                    }
                }
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_TOWER],
                    TERRAIN_BUILDING | TERRAIN_GATEHOUSE);
                foreach_region_tile(b->x - 1, b->y - 1, b->x + 5 - 2, b->y + 5 - 2, set_wall_image);
                break;
            }
            case BUILDING_GATEHOUSE:
                map_building_tiles_add(b->id, b->x, b->y, b->size,
                    image_data_s.group_image_ids[GROUP_BUILDING_TOWER] + building_orientation, TERRAIN_BUILDING | TERRAIN_GATEHOUSE);
                b->subtype.orientation = building_orientation;
                map_orientation_update_buildings();
                map_terrain_add_gatehouse_roads(b->x, b->y, building_orientation);
                foreach_region_tile(b->x - 1, b->y - 1, b->x + 5 - 2, b->y + 5 - 2, set_road_image);
                map_tiles_update_all_plazas();
                foreach_region_tile(b->x - 1, b->y - 1, b->x + 5 - 2, b->y + 5 - 2, set_wall_image);
                break;
            case BUILDING_TRIUMPHAL_ARCH:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_TRIUMPHAL_ARCH] + building_orientation - 1, TERRAIN_BUILDING);
                b->subtype.orientation = building_orientation;
                map_orientation_update_buildings();
                map_terrain_add_triumphal_arch_roads(b->x, b->y, building_orientation);
                foreach_region_tile(b->x - 1, b->y - 1, b->x + 5 - 2, b->y + 5 - 2, set_road_image);
                map_tiles_update_all_plazas();
                city_data.building.triumphal_arches_available--;
                if (!city_data.building.triumphal_arches_available) { // none left
                    build_menus[MENU_ADMINISTRATION].menu_items[10].building_id = 0;
                    // disable menu if this was the only enabled item
                    int menu_enabled = 0;
                    for (int j = 0; j < MAX_ITEMS_PER_BUILD_MENU; j++) {
                        if (build_menus[MENU_ADMINISTRATION].menu_items[j].building_id) {
                            menu_enabled = 1;
                            break;
                        }
                    }
                    if (!menu_enabled) {
                        build_menus[MENU_ADMINISTRATION].is_enabled = 0;
                    }
                }
                building_construction_clear_type();
                break;
            case BUILDING_SENATE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_SENATE], TERRAIN_BUILDING);
                city_data.building.senate_placed = 1;
                if (!city_data.building.senate_grid_offset) {
                    city_data.building.senate_building_id = b->id;
                    city_data.building.senate_x = b->x;
                    city_data.building.senate_y = b->y;
                    city_data.building.senate_grid_offset = b->grid_offset;
                }
                break;
            case BUILDING_BARRACKS:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_BARRACKS], TERRAIN_BUILDING);
                if (!city_data.building.barracks_grid_offset) {
                    city_data.building.barracks_building_id = b->id;
                    city_data.building.barracks_x = b->x;
                    city_data.building.barracks_y = b->y;
                    city_data.building.barracks_grid_offset = b->grid_offset;
                }
                break;
            case BUILDING_WAREHOUSE:
                b->storage_id = building_storage_create();
                b->prev_part_building_id = 0;
                map_building_tiles_add(b->id, b->x, b->y, 1, image_data_s.group_image_ids[GROUP_BUILDING_WAREHOUSE], TERRAIN_BUILDING);
                struct building_t *prev = b;
                prev = add_warehouse_space(b->x + 1, b->y, prev);
                prev = add_warehouse_space(b->x + 2, b->y, prev);
                prev = add_warehouse_space(b->x, b->y + 1, prev);
                prev = add_warehouse_space(b->x + 1, b->y + 1, prev);
                prev = add_warehouse_space(b->x + 2, b->y + 1, prev);
                prev = add_warehouse_space(b->x, b->y + 2, prev);
                prev = add_warehouse_space(b->x + 1, b->y + 2, prev);
                prev = add_warehouse_space(b->x + 2, b->y + 2, prev);
                prev->next_part_building_id = 0;
                break;
            case BUILDING_HIPPODROME:
            {
                int image1 = image_data_s.group_image_ids[GROUP_BUILDING_HIPPODROME_1];
                int image2 = image_data_s.group_image_ids[GROUP_BUILDING_HIPPODROME_2];
                city_data.building.hippodrome_placed = 1;
                int orientation = view_data.orientation;
                struct building_t *part1 = b;
                if (orientation == DIR_0_TOP || orientation == DIR_4_BOTTOM) {
                    part1->subtype.orientation = 0;
                } else {
                    part1->subtype.orientation = 3;
                }
                part1->prev_part_building_id = 0;
                int image_id;
                switch (orientation) {
                    case DIR_0_TOP:
                        image_id = image2;
                        break;
                    case DIR_2_RIGHT:
                        image_id = image1 + 4;
                        break;
                    case DIR_4_BOTTOM:
                        image_id = image2 + 4;
                        break;
                    case DIR_6_LEFT:
                        image_id = image1;
                        break;
                    default:
                        return;
                }
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_id, TERRAIN_BUILDING);
                struct building_t *part2 = building_create(BUILDING_HIPPODROME, b->x + 5, b->y);
                game_undo_add_building(part2);
                if (orientation == DIR_0_TOP || orientation == DIR_4_BOTTOM) {
                    part2->subtype.orientation = 1;
                } else {
                    part2->subtype.orientation = 4;
                }
                part2->prev_part_building_id = part1->id;
                part1->next_part_building_id = part2->id;
                part2->next_part_building_id = 0;
                switch (orientation) {
                    case DIR_0_TOP:
                    case DIR_4_BOTTOM:
                        image_id = image2 + 2;
                        break;
                    case DIR_2_RIGHT:
                    case DIR_6_LEFT:
                        image_id = image1 + 2;
                        break;
                }
                map_building_tiles_add(part2->id, b->x + 5, b->y, b->size, image_id, TERRAIN_BUILDING);
                struct building_t *part3 = building_create(BUILDING_HIPPODROME, b->x + 10, b->y);
                game_undo_add_building(part3);
                if (orientation == DIR_0_TOP || orientation == DIR_4_BOTTOM) {
                    part3->subtype.orientation = 2;
                } else {
                    part3->subtype.orientation = 5;
                }
                part3->prev_part_building_id = part2->id;
                part2->next_part_building_id = part3->id;
                part3->next_part_building_id = 0;
                switch (orientation) {
                    case DIR_0_TOP:
                        image_id = image2 + 4;
                        break;
                    case DIR_2_RIGHT:
                        image_id = image1;
                        break;
                    case DIR_4_BOTTOM:
                        image_id = image2;
                        break;
                    case DIR_6_LEFT:
                        image_id = image1 + 4;
                        break;
                }
                map_building_tiles_add(part3->id, b->x + 10, b->y, b->size, image_id, TERRAIN_BUILDING);
                break;
            }
            case BUILDING_FORT_LEGIONARIES:
            case BUILDING_FORT_JAVELIN:
            case BUILDING_FORT_MOUNTED:
                b->prev_part_building_id = 0;
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_FORT], TERRAIN_BUILDING);
                if (b->type == BUILDING_FORT_LEGIONARIES) {
                    b->subtype.fort_figure_type = FIGURE_FORT_LEGIONARY;
                } else if (b->type == BUILDING_FORT_JAVELIN) {
                    b->subtype.fort_figure_type = FIGURE_FORT_JAVELIN;
                } else if (b->type == BUILDING_FORT_MOUNTED) {
                    b->subtype.fort_figure_type = FIGURE_FORT_MOUNTED;
                }
                for (int i = 0; i < MAX_LEGIONS; i++) {
                    if (!legion_formations[i].in_use) {
                        struct formation_t *m = &legion_formations[i];
                        m->in_use = 1;
                        m->figure_type = b->subtype.fort_figure_type;
                        m->max_figures = MAX_FORMATION_FIGURES;
                        m->layout = FORMATION_DOUBLE_LINE_1;
                        if (b->subtype.fort_figure_type == FIGURE_FORT_LEGIONARY) {
                            m->max_morale = 80;
                        } else {
                            m->max_morale = 60;
                        }
                        m->morale = m->max_morale;
                        m->building_id = b->id;
                        m->standard_x = b->x + 3;
                        m->standard_y = b->y - 1;
                        struct figure_t *standard = figure_create(FIGURE_FORT_STANDARD, m->standard_x, m->standard_y, DIR_0_TOP);
                        standard->building_id = b->id;
                        standard->formation_id = m->id;
                        standard->terrain_usage = TERRAIN_USAGE_ANY;
                        m->legion_standard__figure_id = standard->id;
                        city_data.military.total_legions++;
                        if (m->figure_type == FIGURE_FORT_LEGIONARY) {
                            city_data.military.legionary_legions++;
                        }

                        b->formation_id = m->id;
                    }
                }
                // create parade ground
                struct building_t *ground = building_create(BUILDING_FORT_GROUND, b->x + 3, b->y - 1);
                game_undo_add_building(ground);
                ground->formation_id = b->formation_id;
                ground->prev_part_building_id = b->id;
                b->next_part_building_id = ground->id;
                ground->next_part_building_id = 0;
                map_building_tiles_add(ground->id, b->x + 3, b->y - 1, 4, image_data_s.group_image_ids[GROUP_BUILDING_FORT] + 1, TERRAIN_BUILDING);
                break;
            case BUILDING_NATIVE_HUT:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_NATIVE] + (random_data.random1_7bit & 1), TERRAIN_BUILDING);
                break;
            case BUILDING_NATIVE_MEETING:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_NATIVE] + 2, TERRAIN_BUILDING);
                break;
            case BUILDING_NATIVE_CROPS:
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_data_s.group_image_ids[GROUP_BUILDING_FARM_CROPS], TERRAIN_BUILDING);
                break;
        }
        map_routing_update_land();
        map_routing_update_walls();
    }
    if ((construction_data.type >= BUILDING_LARGE_TEMPLE_CERES && construction_data.type <= BUILDING_LARGE_TEMPLE_VENUS) || construction_data.type == BUILDING_ORACLE) {
        building_warehouses_remove_resource(RESOURCE_MARBLE, 2);
    }
    if (construction_data.type >= BUILDING_SMALL_TEMPLE_CERES && construction_data.type <= BUILDING_SMALL_TEMPLE_VENUS) {
        construction_data.type++;
        if (construction_data.type > BUILDING_SMALL_TEMPLE_VENUS) {
            construction_data.type = BUILDING_SMALL_TEMPLE_CERES;
        }
    }
    if (construction_data.type >= BUILDING_LARGE_TEMPLE_CERES && construction_data.type <= BUILDING_LARGE_TEMPLE_VENUS) {
        construction_data.type++;
        if (construction_data.type > BUILDING_LARGE_TEMPLE_VENUS) {
            construction_data.type = BUILDING_LARGE_TEMPLE_CERES;
        }
    }
    city_finance_process_construction(placement_cost);
    // move herds away
    for (int i = 0; i < MAX_HERD_POINTS; i++) {
        if (herd_formations[i].in_use && herd_formations[i].figure_type != FIGURE_WOLF) {
            if (calc_maximum_distance(x_end, y_end, herd_formations[i].destination_x, herd_formations[i].destination_y) <= 6) {
                // force new roaming destination search
                herd_formations[i].wait_ticks_movement = SHEEP_HERD_ROAM_DELAY; // largest roam delay
            }
        }
    }
    if (construction_data.type != BUILDING_TRIUMPHAL_ARCH) {
        undo_data.ready = 1;
        undo_data.timeout_ticks = 500;
        undo_data.building_cost = placement_cost;
        window_invalidate();
    }
}

static void button_help_resource_settings(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_message_dialog_show(MESSAGE_DIALOG_INDUSTRY, 0);
}

static void button_export_amount_adjust(int value, __attribute__((unused)) int param2)
{
    city_data.resource.export_over[resource_settings_data.resource] = calc_bound(city_data.resource.export_over[resource_settings_data.resource] + value, 0, 100);
}

static struct arrow_button_t resource_arrow_buttons[] = {
    {310, 207, 17, 24, button_export_amount_adjust, -1, 0, 0, 0},
    {334, 207, 15, 24, button_export_amount_adjust, 1, 0, 0, 0}
};

static struct image_button_t help_button_resource_settings[] = {
    {64, 297, 27, 27, IB_NORMAL, GROUP_CONTEXT_ICONS, 0, button_help_resource_settings, button_none, 0, 0, 1, 0, 0, 0},
};

static int resource_export_trade_route_open(int resource)
{
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        if (empire_objects[i].in_use
            && empire_objects[i].city_type == EMPIRE_CITY_TRADE
            && empire_objects[i].trade_route_open
            && empire_objects[i].resource_buy_limit[resource]) {
            return 1;
        }
    }
    return 0;
}

static void button_toggle_trade(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    ++city_data.resource.trade_status[resource_settings_data.resource];
    if (city_data.resource.trade_status[resource_settings_data.resource] > TRADE_STATUS_EXPORT) {
        city_data.resource.trade_status[resource_settings_data.resource] = TRADE_STATUS_NONE;
    }

    if (city_data.resource.trade_status[resource_settings_data.resource] == TRADE_STATUS_IMPORT &&
        !resource_import_trade_route_open(resource_settings_data.resource)) {
        city_data.resource.trade_status[resource_settings_data.resource] = TRADE_STATUS_EXPORT;
    }
    if (city_data.resource.trade_status[resource_settings_data.resource] == TRADE_STATUS_EXPORT &&
        !resource_export_trade_route_open(resource_settings_data.resource)) {
        city_data.resource.trade_status[resource_settings_data.resource] = TRADE_STATUS_NONE;
    }
    if (city_data.resource.trade_status[resource_settings_data.resource] == TRADE_STATUS_EXPORT) {
        city_data.resource.stockpiled[resource_settings_data.resource] = 0;
    }
}

static void button_toggle_industry(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    if (count_data.industry[resource_settings_data.resource].total > 0) {
        city_data.resource.mothballed[resource_settings_data.resource] = city_data.resource.mothballed[resource_settings_data.resource] ? 0 : 1;
    }
}

static void button_toggle_stockpile(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    if (city_data.resource.stockpiled[resource_settings_data.resource]) {
        city_data.resource.stockpiled[resource_settings_data.resource] = 0;
    } else {
        city_data.resource.stockpiled[resource_settings_data.resource] = 1;
        if (city_data.resource.trade_status[resource_settings_data.resource] == TRADE_STATUS_EXPORT) {
            city_data.resource.trade_status[resource_settings_data.resource] = TRADE_STATUS_NONE;
        }
    }
}

static struct generic_button_t resource_generic_buttons[] = {
    {104, 204, 432, 30, button_toggle_trade, button_none, 0, 0},
    {104, 240, 432, 30, button_toggle_industry, button_none, 0, 0},
    {104, 276, 432, 50, button_toggle_stockpile, button_none, 0, 0},
};

static void draw_foreground_resource_settings(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    outer_panel_draw(48, 100, 34, 15);
    // Resource image
    image_draw(resource_images[resource_settings_data.resource].icon_img_id + resource_image_offset(resource_settings_data.resource, RESOURCE_IMAGE_ICON), 64, 116);
    // Resource name
    text_draw_centered(resource_strings[resource_settings_data.resource], 48, 116, 544, FONT_LARGE_BLACK, COLOR_BLACK);
    int total_buildings = count_data.industry[resource_settings_data.resource].total;
    int active_buildings = count_data.industry[resource_settings_data.resource].active;
    if (total_buildings <= 0) {
        // No industries in the city
        lang_text_draw(54, 7, 109, 164, FONT_NORMAL_BLACK);
    } else if (city_data.resource.mothballed[resource_settings_data.resource]) {
        // [count of] mothballed industry/ies in the city
        int width = text_draw_number(total_buildings, 0, " ", 109, 164, FONT_NORMAL_BLACK);
        if (total_buildings == 1) {
            lang_text_draw(54, 10, 109 + width, 164, FONT_NORMAL_BLACK);
        } else {
            lang_text_draw(54, 11, 109 + width, 164, FONT_NORMAL_BLACK);
        }
    } else {
        if (total_buildings == active_buildings) {
            // [count of] working industry/ies in the city
            int width = text_draw_number(total_buildings, 0, " ", 109, 164, FONT_NORMAL_BLACK);
            if (total_buildings == 1) {
                lang_text_draw(54, 8, 109 + width, 164, FONT_NORMAL_BLACK);
            } else {
                lang_text_draw(54, 9, 109 + width, 164, FONT_NORMAL_BLACK);
            }
        } else if (total_buildings > active_buildings) {
            // [count of] working [count of] idle industry/ies in the city
            int idle_buildings_count = total_buildings - active_buildings;
            int width = text_draw_number(active_buildings, 0, " ", 109, 164, FONT_NORMAL_BLACK);
            width += lang_text_draw(54, 12, 109 + width, 164, FONT_NORMAL_BLACK);
            width += text_draw_number(idle_buildings_count, 0, " ", 109 + width, 164, FONT_NORMAL_BLACK);
            if (idle_buildings_count == 1) {
                lang_text_draw(54, 14, 109 + width, 164, FONT_NORMAL_BLACK);
            } else {
                lang_text_draw(54, 13, 109 + width, 164, FONT_NORMAL_BLACK);
            }
        }
    }
    // Units stored in the city's warehouses
    int width = lang_text_draw_amount(8, 10, city_data.resource.stored_in_warehouses[resource_settings_data.resource], 104, 180, FONT_NORMAL_BLACK);
    lang_text_draw(54, 15, 104 + width, 180, FONT_NORMAL_BLACK);
    // Import/Export
    int trade_flags = TRADE_STATUS_NONE;
    int trade_status = city_data.resource.trade_status[resource_settings_data.resource];
    if (resource_import_trade_route_open(resource_settings_data.resource)) {
        trade_flags |= TRADE_STATUS_IMPORT;
    }
    if (resource_export_trade_route_open(resource_settings_data.resource)) {
        trade_flags |= TRADE_STATUS_EXPORT;
    }
    if (!trade_flags) {
        // There are no trade routes open for these goods
        lang_text_draw(54, 24, 109, 212, FONT_NORMAL_BLACK);
    } else {
        button_border_draw(104, 204, 432, 30, resource_settings_data.focus_button_id == 1);
        switch (trade_status) {
            case TRADE_STATUS_NONE:
                // Not trading
                lang_text_draw_centered(54, 18, 104, 212, 432, FONT_NORMAL_BLACK);
                break;
            case TRADE_STATUS_IMPORT:
                // Importing goods
                lang_text_draw_centered(54, 19, 104, 212, 432, FONT_NORMAL_BLACK);
                break;
            case TRADE_STATUS_EXPORT:
                // Export goods over
                lang_text_draw(54, 20, 152, 212, FONT_NORMAL_BLACK);
                break;
        }
    }
    if (trade_status == TRADE_STATUS_EXPORT) {
        arrow_buttons_draw(0, 0, resource_arrow_buttons, 2);
        lang_text_draw_amount(8, 10, city_data.resource.export_over[resource_settings_data.resource], 365, 212, FONT_NORMAL_BLACK);
    }
    if (count_data.industry[resource_settings_data.resource].total > 0) {
        button_border_draw(104, 240, 432, 30, resource_settings_data.focus_button_id == 2);
        if (city_data.resource.mothballed[resource_settings_data.resource]) {
            // Industry is OFF
            lang_text_draw_centered(54, 17, 104, 248, 432, FONT_NORMAL_BLACK);
        } else {
            // Industry is ON
            lang_text_draw_centered(54, 16, 104, 248, 432, FONT_NORMAL_BLACK);
        }
    }
    button_border_draw(104, 276, 432, 50, resource_settings_data.focus_button_id == 3);
    if (city_data.resource.stockpiled[resource_settings_data.resource]) {
        // Stockpiling resource
        lang_text_draw_centered(54, 26, 104, 284, 432, FONT_NORMAL_BLACK);
        // Click here to turn off stockpiling
        lang_text_draw_centered(54, 27, 104, 304, 432, FONT_NORMAL_BLACK);
    } else {
        // Using and trading this resource
        lang_text_draw_centered(54, 28, 104, 284, 432, FONT_NORMAL_BLACK);
        // Click here to stockpile it
        lang_text_draw_centered(54, 29, 104, 304, 432, FONT_NORMAL_BLACK);
    }
    image_buttons_draw(0, 0, help_button_resource_settings, 1);
    set_translation(0, 0);
}

static void handle_input_resource_settings(struct mouse_t *m, struct hotkeys_t *h)
{
    if (m->right.went_up || h->escape_pressed) {
        window_go_back();
        return;
    }
    struct mouse_t *m_dialog = mouse_in_dialog(m);
    if (city_data.resource.trade_status[resource_settings_data.resource] == TRADE_STATUS_EXPORT) {
        int button = 0;
        arrow_buttons_handle_mouse(m_dialog, 0, 0, resource_arrow_buttons, 2, &button);
        if (button) {
            return;
        }
    }
    if (generic_buttons_handle_mouse(m_dialog, 0, 0, resource_generic_buttons, sizeof(resource_generic_buttons) / sizeof(struct generic_button_t), &resource_settings_data.focus_button_id)) {
        return;
    }
    if (image_buttons_handle_mouse(m_dialog, 0, 0, help_button_resource_settings, 1, 0)) {
        return;
    }
    // exit window on click outside of outer panel boundaries
    if (m_dialog->left.went_up && (m_dialog->x < 48 || m_dialog->y < 100 || m_dialog->x > 592 || m_dialog->y > 340)) {
        window_go_back();
        return;
    }
}

static void window_resource_settings_show(int resource)
{
    struct window_type_t window = {
        WINDOW_RESOURCE_SETTINGS,
        window_draw_underlying_window,
        draw_foreground_resource_settings,
        handle_input_resource_settings,
    };
    resource_settings_data.resource = resource;
    window_show(&window);
}

static void button_change_advisor(int advisor, __attribute__((unused)) int param2)
{
    if (advisor) {
        set_advisor(advisor);
        window_invalidate();
    } else {
        window_city_show();
    }
}

static struct generic_button_t advisor_buttons[] = {
    {12, 1, 40, 40, button_change_advisor, button_none, ADVISOR_LABOR, 0},
    {60, 1, 40, 40, button_change_advisor, button_none, ADVISOR_MILITARY, 0},
    {108, 1, 40, 40, button_change_advisor, button_none, ADVISOR_IMPERIAL, 0},
    {156, 1, 40, 40, button_change_advisor, button_none, ADVISOR_RATINGS, 0},
    {204, 1, 40, 40, button_change_advisor, button_none, ADVISOR_TRADE, 0},
    {252, 1, 40, 40, button_change_advisor, button_none, ADVISOR_POPULATION, 0},
    {300, 1, 40, 40, button_change_advisor, button_none, ADVISOR_HEALTH, 0},
    {348, 1, 40, 40, button_change_advisor, button_none, ADVISOR_EDUCATION, 0},
    {396, 1, 40, 40, button_change_advisor, button_none, ADVISOR_ENTERTAINMENT, 0},
    {444, 1, 40, 40, button_change_advisor, button_none, ADVISOR_RELIGION, 0},
    {492, 1, 40, 40, button_change_advisor, button_none, ADVISOR_FINANCIAL, 0},
    {540, 1, 40, 40, button_change_advisor, button_none, ADVISOR_CHIEF, 0},
    {588, 1, 40, 40, button_change_advisor, button_none, 0, 0},
};

static void handle_input_advisors(struct mouse_t *m, struct hotkeys_t *h)
{
    if (h->show_last_advisor) {
        window_city_show();
        return;
    }
    if (h->show_empire_map) {
        window_empire_show();
        return;
    }
    struct mouse_t *m_dialog = mouse_in_dialog(m);
    if (generic_buttons_handle_mouse(m_dialog, 0, 440, advisor_buttons, sizeof(advisor_buttons) / sizeof(struct generic_button_t), &focus_button_id_advisors)) {
        return;
    }
    int button_id;
    image_buttons_handle_mouse(m_dialog, 0, BLOCK_SIZE * (advisor_height - 2), &help_button, 1, &button_id);
    if (button_id) {
        focus_button_id_advisors = -1;
    }
    if (current_advisor_window->handle_mouse && current_advisor_window->handle_mouse(m_dialog)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        window_city_show();
        return;
    }
}

static void button_advisors_city_widget(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_advisors_show(settings_values[SETTINGS_LAST_ADVISOR]);
}

static void button_empire_city_widget(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_empire_show();
}

static void draw_background_mission_briefing(void)
{
    image_draw_fullscreen_background(image_data_s.group_image_ids[GROUP_INTERMEZZO_BACKGROUND] + 16);
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    outer_panel_draw(-100, -75, 52, 39);
    // Scenario name
    text_draw(scenario.scenario_name, -84, -59, FONT_LARGE_BLACK, 0);
    // Scenario brief description
    text_draw(scenario.brief_description, -84, -27, FONT_NORMAL_BLACK, 0);
    // Player name
    text_draw(scenario_settings.player_name, -84, 5, FONT_NORMAL_BLACK, 0);
    // Objectives
    inner_panel_draw(-84, 37, 50, 5);
    lang_text_draw(62, 10, -60, 72, FONT_NORMAL_WHITE);
    if (scenario.culture_win_criteria.enabled) {
        label_draw(52, 51, 13, 1);
        int width = lang_text_draw(62, 12, 60, 55, FONT_NORMAL_RED);
        text_draw_number(scenario.culture_win_criteria.goal, 0, 0, width + 60, 55, FONT_NORMAL_RED);
    }
    if (scenario.prosperity_win_criteria.enabled) {
        label_draw(52, 83, 13, 1);
        int width = lang_text_draw(62, 13, 60, 87, FONT_NORMAL_RED);
        text_draw_number(scenario.prosperity_win_criteria.goal, 0, 0, width + 60, 87, FONT_NORMAL_RED);
    }
    if (scenario.peace_win_criteria.enabled) {
        label_draw(268, 51, 13, 1);
        int width = lang_text_draw(62, 14, 276, 55, FONT_NORMAL_RED);
        text_draw_number(scenario.peace_win_criteria.goal, 0, 0, width + 276, 55, FONT_NORMAL_RED);
    }
    if (scenario.favor_win_criteria.enabled) {
        label_draw(268, 83, 13, 1);
        int width = lang_text_draw(62, 15, 276, 87, FONT_NORMAL_RED);
        text_draw_number(scenario.favor_win_criteria.goal, 0, 0, width + 276, 87, FONT_NORMAL_RED);
    }
    if (scenario.population_win_criteria.enabled) {
        label_draw(492, 51, 13, 1);
        int width = lang_text_draw(62, 11, 500, 55, FONT_NORMAL_RED);
        text_draw_number(scenario.population_win_criteria.goal, 0, 0, width + 500, 55, FONT_NORMAL_RED);
    }
    if (scenario.time_limit_win_criteria.enabled) {
        label_draw(492, 83, 13, 2);
        int width = text_draw("Fired after", 500, 87, FONT_NORMAL_RED, COLOR_BLACK);
        text_draw_number(scenario.time_limit_win_criteria.years, 0, " Years", width + 500, 87, FONT_NORMAL_RED);
    } else if (scenario.survival_time_win_criteria.enabled) {
        label_draw(492, 83, 13, 2);
        int width = text_draw("Survive for", 500, 87, FONT_NORMAL_RED, COLOR_BLACK);
        text_draw_number(scenario.survival_time_win_criteria.years, 0, " Years", width + 500, 87, FONT_NORMAL_RED);
    }
    inner_panel_draw(-84, 141, 50, 24);
    // Text body (map description)
    rich_text_set_fonts(FONT_NORMAL_WHITE, FONT_NORMAL_RED, 5);
    rich_text_init(scenario.briefing, -60, 141, 46, 24, 0);
    graphics_set_clip_rectangle(-68, 157, 800, 365);
    draw_text(scenario.briefing, -68, 157, 800, 384, 0, 0);
    graphics_reset_clip_rectangle();
    scrollbar_draw(&scrollbar);
    set_translation(0, 0);
}

static void handle_input_mission_briefing(struct mouse_t *m, struct hotkeys_t *h)
{
    scrollbar_handle_mouse(&scrollbar, mouse_in_dialog(m));
    if (m->right.went_up || h->escape_pressed || h->enter_pressed) {
        rich_text_reset(0);
        stop_sound_channel(SOUND_CHANNEL_SPEECH);
        update_music(1);
        window_city_show();
        return;
    }
}

static void window_mission_briefing_show(void)
{
    struct window_type_t window = {
        WINDOW_MISSION_BRIEFING,
        draw_background_mission_briefing,
        0,
        handle_input_mission_briefing,
    };
    rich_text_reset(0);
    window_show(&window);
}

static void button_mission_briefing(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_mission_briefing_show();
}

static void button_rotate_north_city_widget(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    switch (view_data.orientation) {
        case DIR_2_RIGHT:
            city_view_rotate_right();
            map_orientation_change(1);
            break;
        case DIR_4_BOTTOM:
            city_view_rotate_left();
            map_orientation_change(0);
            /* fall through */
        case DIR_6_LEFT:
            city_view_rotate_left();
            map_orientation_change(0);
            break;
        default: // already north
            break;
    }
    minimap_data.refresh_requested = 1;
    city_warning_show(WARNING_ORIENTATION);
    window_invalidate();
}

static void button_rotate_city_widget(int clockwise, __attribute__((unused)) int param2)
{
    if (clockwise) {
        game_orientation_rotate_right();
    } else {
        game_orientation_rotate_left();
    }
    window_invalidate();
}

static struct image_button_t buttons_top_expanded[] = {
    {7, 155, 71, 23, IB_NORMAL, GROUP_SIDEBAR_ADVISORS_EMPIRE, 0, button_advisors_city_widget, button_none, 0, 0, 1, 0, 0, 0},
    {84, 155, 71, 23, IB_NORMAL, GROUP_SIDEBAR_ADVISORS_EMPIRE, 3, button_empire_city_widget, button_help_city_widget, 0, MESSAGE_DIALOG_EMPIRE_MAP, 1, 0, 0, 0},
    {7, 184, 33, 22, IB_NORMAL, GROUP_SIDEBAR_BRIEFING_ROTATE_BUTTONS, 0, button_mission_briefing, button_none, 0, 0, 1, 0, 0, 0},
    {46, 184, 33, 22, IB_NORMAL, GROUP_SIDEBAR_BRIEFING_ROTATE_BUTTONS, 3, button_rotate_north_city_widget, button_none, 0, 0, 1, 0, 0, 0},
    {84, 184, 33, 22, IB_NORMAL, GROUP_SIDEBAR_BRIEFING_ROTATE_BUTTONS, 6, button_rotate_city_widget, button_none, 0, 0, 1, 0, 0, 0},
    {123, 184, 33, 22, IB_NORMAL, GROUP_SIDEBAR_BRIEFING_ROTATE_BUTTONS, 9, button_rotate_city_widget, button_none, 1, 0, 1, 0, 0, 0},
};

static void build_move(struct map_tile_t *tile)
{
    if (!construction_data.in_progress) {
        return;
    }
    if (tile->grid_offset) {
        construction_data.end.x = tile->x;
        construction_data.end.y = tile->y;
        construction_data.end.grid_offset = tile->grid_offset;
    } else {
        tile->x = construction_data.end.x;
        tile->y = construction_data.end.y;
    }
    if (!construction_data.type) {
        construction_data.cost_preview = 0;
        return;
    }
    map_property_clear_constructing_and_deleted();
    int current_cost = building_properties[construction_data.type].cost;

    if (construction_data.type == BUILDING_CLEAR_LAND) {
        int items_placed = last_items_cleared = building_construction_clear_land(1, construction_data.start.x, construction_data.start.y, tile->x, tile->y);
        if (items_placed >= 0) current_cost *= items_placed;
    } else if (construction_data.type == BUILDING_WALL) {
        int items_placed = building_construction_place_wall(1, construction_data.start.x, construction_data.start.y, tile->x, tile->y);
        if (items_placed >= 0) current_cost *= items_placed;
    } else if (construction_data.type == BUILDING_ROAD) {
        int items_placed = building_construction_place_road(1, construction_data.start.x, construction_data.start.y, tile->x, tile->y);
        if (items_placed >= 0) current_cost *= items_placed;
    } else if (construction_data.type == BUILDING_PLAZA) {
        int items_placed = place_plaza(construction_data.start.x, construction_data.start.y, tile->x, tile->y);
        if (items_placed >= 0) current_cost *= items_placed;
    } else if (construction_data.type == BUILDING_GARDENS) {
        int items_placed = place_garden(construction_data.start.x, construction_data.start.y, tile->x, tile->y);
        if (items_placed >= 0) current_cost *= items_placed;
    } else if (construction_data.type == BUILDING_LOW_BRIDGE || construction_data.type == BUILDING_SHIP_BRIDGE) {
        int length = bridge.length;
        if (length > 1) current_cost *= length;
    } else if (construction_data.type == BUILDING_AQUEDUCT) {
        building_construction_place_aqueduct(construction_data.start.x, construction_data.start.y, tile->x, tile->y, &current_cost);
        map_tiles_update_all_aqueducts(0);
    } else if (construction_data.type == BUILDING_HOUSE_VACANT_LOT) {
        int items_placed = place_houses(1, construction_data.start.x, construction_data.start.y, tile->x, tile->y);
        if (items_placed >= 0) current_cost *= items_placed;
    } else if (construction_data.type == BUILDING_GATEHOUSE) {
        mark_construction(tile->x, tile->y, 2, ~TERRAIN_ROAD, 0);
    } else if (construction_data.type == BUILDING_TRIUMPHAL_ARCH) {
        mark_construction(tile->x, tile->y, 3, ~TERRAIN_ROAD, 0);
    } else if (construction_data.type == BUILDING_WAREHOUSE) {
        mark_construction(tile->x, tile->y, 3, TERRAIN_ALL, 0);
    } else if (building_is_fort(construction_data.type)) {
        if (city_data.military.total_legions < MAX_LEGIONS) {
            int offsets_x[] = { 3, 4, 4, 3 };
            int offsets_y[] = { -1, -1, 0, 0 };
            int orient_index = view_data.orientation / 2;
            int x_offset = offsets_x[orient_index];
            int y_offset = offsets_y[orient_index];
            if (map_building_tiles_are_clear(tile->x, tile->y, 3, TERRAIN_ALL) &&
                map_building_tiles_are_clear(tile->x + x_offset, tile->y + y_offset, 4, TERRAIN_ALL)) {
                mark_construction(tile->x, tile->y, 3, TERRAIN_ALL, 0);
                mark_construction(tile->x + x_offset, tile->y + y_offset, 4, TERRAIN_ALL, 0);
            }
        }
    } else if (construction_data.type == BUILDING_HIPPODROME) {
        if (map_building_tiles_are_clear(tile->x, tile->y, 5, TERRAIN_ALL) &&
            map_building_tiles_are_clear(tile->x + 5, tile->y, 5, TERRAIN_ALL) &&
            map_building_tiles_are_clear(tile->x + 10, tile->y, 5, TERRAIN_ALL) &&
            !city_data.building.hippodrome_placed) {
            mark_construction(tile->x, tile->y, 5, TERRAIN_ALL, 0);
            mark_construction(tile->x + 5, tile->y, 5, TERRAIN_ALL, 0);
            mark_construction(tile->x + 10, tile->y, 5, TERRAIN_ALL, 0);
        }
    } else if (construction_data.type == BUILDING_SHIPYARD || construction_data.type == BUILDING_WHARF) {
        if (!map_water_determine_orientation_size2(tile->x, tile->y, 1, 0, 0)) {
            construction_data.draw_as_constructing = 1;
        }
    } else if (construction_data.type == BUILDING_DOCK) {
        if (!map_water_determine_orientation_size3(tile->x, tile->y, 1, 0, 0)) {
            construction_data.draw_as_constructing = 1;
        }
    } else if (construction_data.required_terrain.meadow || construction_data.required_terrain.rock || construction_data.required_terrain.tree ||
            construction_data.required_terrain.water || construction_data.required_terrain.wall) {
        // never mark as constructing
    } else {
        if (!(construction_data.type == BUILDING_SENATE && city_data.building.senate_placed) &&
            !(construction_data.type == BUILDING_BARRACKS && count_data.buildings[BUILDING_BARRACKS].total > 0)) {
            mark_construction(tile->x, tile->y, building_properties[construction_data.type].size, TERRAIN_ALL, 0);
        }
    }
    if (!city_finance_can_afford(current_cost)) {
        map_property_clear_constructing_and_deleted();
        building_construction_cancel();
        construction_data.cost_preview = 0;
        city_warning_show(WARNING_OUT_OF_MONEY);
        return;
    }
    construction_data.cost_preview = current_cost;
}

static void button_layout(int index, __attribute__((unused)) int param2)
{
    struct formation_t *m = &legion_formations[building_military_data.context_for_callback->formation_id];
    if (m->in_distant_battle || m->cursed_by_mars) {
        return;
    }

    if (m->figure_type == FIGURE_FORT_LEGIONARY) {
        switch (index) {
            case 0:
                if (m->has_military_training) {
                    m->layout = FORMATION_TORTOISE; break;
                } else {
                    return;
                }
            case 1: return;
            case 2: m->layout = FORMATION_DOUBLE_LINE_1; break;
            case 3: m->layout = FORMATION_DOUBLE_LINE_2; break;
            default: break;
        }
    } else {
        switch (index) {
            case 0: m->layout = FORMATION_SINGLE_LINE_1; break;
            case 1: m->layout = FORMATION_SINGLE_LINE_2; break;
            case 2: m->layout = FORMATION_DOUBLE_LINE_1; break;
            case 3: m->layout = FORMATION_DOUBLE_LINE_2; break;
            default: break;
        }
    }
    if (index == 4) { // mop up
        for (int i = 0; i < m->num_figures; i++) {
            struct figure_t *unit = &figures[m->figures[i]];
            unit->action_state = FIGURE_ACTION_SOLDIER_MOPPING_UP;
        }
    }
    switch (index) {
        case 0: play_speech_file("wavs/cohort1.wav"); break;
        case 1: play_speech_file("wavs/cohort2.wav"); break;
        case 2: play_speech_file("wavs/cohort3.wav"); break;
        case 3: play_speech_file("wavs/cohort4.wav"); break;
        case 4: play_speech_file("wavs/cohort5.wav"); break;
    }
    window_city_military_show(building_military_data.context_for_callback->formation_id);
}

static struct generic_button_t layout_buttons[] = {
    {19, 139, 84, 84, button_layout, button_none, 0, 0},
    {104, 139, 84, 84, button_layout, button_none, 1, 0},
    {189, 139, 84, 84, button_layout, button_none, 2, 0},
    {274, 139, 84, 84, button_layout, button_none, 3, 0},
    {359, 139, 84, 84, button_layout, button_none, 4, 0}
};

static void button_return_to_fort_legion_info(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    struct formation_t *m = &legion_formations[building_military_data.context_for_callback->formation_id];
    if (!m->in_distant_battle && !m->is_at_rest) {
        return_legion_formation_home(m);
        window_city_show();
    }
}

static struct generic_button_t return_button[] = {
    {0, 0, 288, 32, button_return_to_fort_legion_info, button_none, 0, 0},
};

static void button_help(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    if (b_info_context.help_id > 0) {
        window_message_dialog_show(b_info_context.help_id, window_city_draw_all);
    } else {
        window_message_dialog_show(MESSAGE_DIALOG_HELP, window_city_draw_all);
    }
    window_invalidate();
}

static void button_close(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    if (b_info_context.storage_show_special_orders) {
        b_info_context.storage_show_special_orders = 0;
        window_invalidate();
    } else {
        window_city_show();
    }
}

static struct image_button_t image_buttons_help_close[] = {
    {14, 0, 27, 27, IB_NORMAL, GROUP_CONTEXT_ICONS, 0, button_help, button_none, 0, 0, 1, 0, 0, 0},
    {424, 3, 24, 24, IB_NORMAL, GROUP_CONTEXT_ICONS, 4, button_close, button_none, 0, 0, 1, 0, 0, 0}
};

static void button_advisor(int advisor, __attribute__((unused)) int param2)
{
    window_advisors_show(advisor);
}

static struct image_button_t image_buttons_advisor[] = {
    {350, -38, 28, 28, IB_NORMAL, GROUP_MESSAGE_ADVISOR_BUTTONS, 9, button_advisor, button_none, ADVISOR_RATINGS, 0, 1, 0, 0, 0}
};

static int get_height_id(void)
{
    if (b_info_context.type == BUILDING_INFO_TERRAIN) {
        switch (b_info_context.terrain_type) {
            case TERRAIN_INFO_AQUEDUCT:
                return 4;
            case TERRAIN_INFO_RUBBLE:
            case TERRAIN_INFO_WALL:
            case TERRAIN_INFO_GARDEN:
                return 1;
            default:
                return 5;
        }
    } else if (b_info_context.type == BUILDING_INFO_BUILDING) {
        struct building_t *b = &all_buildings[b_info_context.building_id];
        if (building_is_house(b->type) && b->house_population <= 0) {
            return 5;
        }
        switch (b->type) {
            case BUILDING_SMALL_TEMPLE_CERES:
            case BUILDING_SMALL_TEMPLE_NEPTUNE:
            case BUILDING_SMALL_TEMPLE_MERCURY:
            case BUILDING_SMALL_TEMPLE_MARS:
            case BUILDING_SMALL_TEMPLE_VENUS:
            case BUILDING_LARGE_TEMPLE_CERES:
            case BUILDING_LARGE_TEMPLE_NEPTUNE:
            case BUILDING_LARGE_TEMPLE_MERCURY:
            case BUILDING_LARGE_TEMPLE_MARS:
            case BUILDING_LARGE_TEMPLE_VENUS:
            case BUILDING_ORACLE:
            case BUILDING_SMALL_STATUE:
            case BUILDING_MEDIUM_STATUE:
            case BUILDING_LARGE_STATUE:
            case BUILDING_GLADIATOR_SCHOOL:
            case BUILDING_LION_HOUSE:
            case BUILDING_ACTOR_COLONY:
            case BUILDING_CHARIOT_MAKER:
            case BUILDING_DOCTOR:
            case BUILDING_HOSPITAL:
            case BUILDING_BATHHOUSE:
            case BUILDING_BARBER:
            case BUILDING_BURNING_RUIN:
            case BUILDING_RESERVOIR:
            case BUILDING_NATIVE_HUT:
            case BUILDING_NATIVE_MEETING:
            case BUILDING_NATIVE_CROPS:
            case BUILDING_MISSION_POST:
            case BUILDING_PREFECTURE:
            case BUILDING_ENGINEERS_POST:
            case BUILDING_SCHOOL:
            case BUILDING_ACADEMY:
            case BUILDING_LIBRARY:
            case BUILDING_GATEHOUSE:
            case BUILDING_TOWER:
            case BUILDING_FORT_LEGIONARIES:
            case BUILDING_FORT_JAVELIN:
            case BUILDING_FORT_MOUNTED:
            case BUILDING_MILITARY_ACADEMY:
            case BUILDING_BARRACKS:
            case BUILDING_MARKET:
            case BUILDING_GRANARY:
            case BUILDING_SHIPYARD:
            case BUILDING_DOCK:
            case BUILDING_WHARF:
            case BUILDING_GOVERNORS_HOUSE:
            case BUILDING_GOVERNORS_VILLA:
            case BUILDING_GOVERNORS_PALACE:
            case BUILDING_FORUM:
            case BUILDING_WINE_WORKSHOP:
            case BUILDING_OIL_WORKSHOP:
            case BUILDING_WEAPONS_WORKSHOP:
            case BUILDING_FURNITURE_WORKSHOP:
            case BUILDING_POTTERY_WORKSHOP:
                return 1;
            case BUILDING_THEATER:
            case BUILDING_HIPPODROME:
            case BUILDING_COLOSSEUM:
            case BUILDING_SENATE:
            case BUILDING_FOUNTAIN:
                return 2;
            case BUILDING_AMPHITHEATER:
                return 3;
            case BUILDING_WELL:
                return 4;
            default:
                return 0;
        }
    }
    return 0;
}

static int trader_has_traded(int trader_id)
{
    return figure_trader_data.traders[trader_id].bought_amount || figure_trader_data.traders[trader_id].sold_amount;
}

static int trade_caravan_phrase(struct figure_t *f)
{
    if (++f->phrase_sequence_exact >= 2) {
        f->phrase_sequence_exact = 0;
    }
    if (f->action_state == FIGURE_ACTION_TRADE_CARAVAN_LEAVING) {
        if (!trader_has_traded(f->trader_id)) {
            return 7; // no trade
        }
    } else if (f->action_state == FIGURE_ACTION_TRADE_CARAVAN_TRADING) {
        if (figure_trade_caravan_can_buy(f, f->destination_building_id, f->empire_city_id)) {
            return 11; // buying goods
        } else if (figure_trade_caravan_can_sell(f, f->destination_building_id, f->empire_city_id)) {
            return 10; // selling goods
        }
    }
    return 8 + f->phrase_sequence_exact;
}

static int trader_sold_resources(int trader_id, int resource)
{
    return figure_trader_data.traders[trader_id].sold_resources[resource];
}

static int trader_bought_resources(int trader_id, int resource)
{
    return figure_trader_data.traders[trader_id].bought_resources[resource];
}

static void window_building_draw_figure_list(struct building_info_context_t *c)
{
    inner_panel_draw(c->x_offset + 16, c->y_offset + 40, c->width_blocks - 2, 13);
    if (c->figure.count <= 0) {
        lang_text_draw_centered(70, 0, c->x_offset, c->y_offset + 120,
            BLOCK_SIZE * c->width_blocks, FONT_NORMAL_BROWN);
    } else {
        for (int i = 0; i < c->figure.count; i++) {
            button_border_draw(c->x_offset + 60 * i + 25, c->y_offset + 45, 52, 52, i == c->figure.selected_index);
            graphics_draw_from_buffer(c->x_offset + 27 + 60 * i, c->y_offset + 47, 48, 48, building_figures_data.figure_images[i]);
        }
        button_border_draw(c->x_offset + 24, c->y_offset + 102, BLOCK_SIZE * (c->width_blocks - 3), 138, 0);
        struct figure_t *f = &figures[c->figure.figure_ids[c->figure.selected_index]];
        if (figure_properties[f->type].is_empire_trader) {
            while (f->type == FIGURE_TRADE_CARAVAN_DONKEY) {
                f = &figures[f->leading_figure_id];
            }
            lang_text_draw(65, f->name_id, c->x_offset + 40, c->y_offset + 110, FONT_NORMAL_BROWN);
            int width = text_draw(figure_desc_strings[f->type], c->x_offset + 40, c->y_offset + 130, FONT_NORMAL_BROWN, COLOR_BLACK);
            lang_text_draw(21, empire_objects[f->empire_city_id].city_name_id, c->x_offset + 40 + width, c->y_offset + 130, FONT_NORMAL_BROWN);

            width = lang_text_draw(129, 1, c->x_offset + 40, c->y_offset + 150, FONT_NORMAL_BROWN);
            lang_text_draw_amount(8, 10, f->type == FIGURE_TRADE_SHIP ? 12 : 8, c->x_offset + 40 + width, c->y_offset + 150, FONT_NORMAL_BROWN);

            int trader_id = f->trader_id;
            int text_id;
            if (f->type == FIGURE_TRADE_SHIP) {
                switch (f->action_state) {
                    case FIGURE_ACTION_TRADE_SHIP_ANCHORED: text_id = 6; break;
                    case FIGURE_ACTION_TRADE_SHIP_MOORED: text_id = 7; break;
                    case FIGURE_ACTION_TRADE_SHIP_LEAVING: text_id = 8; break;
                    default: text_id = 9; break;
                }
            } else {
                switch (f->action_state) {
                    case FIGURE_ACTION_TRADE_CARAVAN_ARRIVING:
                        text_id = 12;
                        break;
                    case FIGURE_ACTION_TRADE_CARAVAN_TRADING:
                        text_id = 10;
                        break;
                    case FIGURE_ACTION_TRADE_CARAVAN_LEAVING:
                        if (trader_has_traded(trader_id)) {
                            text_id = 11;
                        } else {
                            text_id = 13;
                        }
                        break;
                    default:
                        text_id = 11;
                        break;
                }
            }
            lang_text_draw(129, text_id, c->x_offset + 40, c->y_offset + 170, FONT_NORMAL_BROWN);
            if (trader_has_traded(trader_id)) {
                // bought
                int y_base = c->y_offset + 192;
                width = lang_text_draw(129, 4, c->x_offset + 40, y_base, FONT_NORMAL_BROWN);
                for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                    if (trader_bought_resources(trader_id, r)) {
                        width += text_draw_number(trader_bought_resources(trader_id, r), ' ', "", c->x_offset + 40 + width, y_base, FONT_NORMAL_BROWN);
                        image_draw(resource_images[r].icon_img_id + resource_image_offset(r, RESOURCE_IMAGE_ICON), c->x_offset + 40 + width, y_base - 3);
                        width += 25;
                    }
                }
                // sold
                y_base = c->y_offset + 213;
                width = lang_text_draw(129, 5, c->x_offset + 40, y_base, FONT_NORMAL_BROWN);
                for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                    if (trader_sold_resources(trader_id, r)) {
                        width += text_draw_number(trader_sold_resources(trader_id, r), ' ', "", c->x_offset + 40 + width, y_base, FONT_NORMAL_BROWN);
                        image_draw(resource_images[r].icon_img_id + resource_image_offset(r, RESOURCE_IMAGE_ICON), c->x_offset + 40 + width, y_base - 3);
                        width += 25;
                    }
                }
            } else { // nothing sold/bought (yet)
                // buying
                int y_base = c->y_offset + 192;
                width = lang_text_draw(129, 2, c->x_offset + 40, y_base, FONT_NORMAL_BROWN);
                for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                    if (empire_objects[f->empire_city_id].resource_buy_limit[r]) {
                        image_draw(resource_images[r].icon_img_id + resource_image_offset(r, RESOURCE_IMAGE_ICON), c->x_offset + 40 + width, y_base - 3);
                        width += 25;
                    }
                }
                // selling
                y_base = c->y_offset + 213;
                width = lang_text_draw(129, 3, c->x_offset + 40, y_base, FONT_NORMAL_BROWN);
                for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                    if (empire_objects[f->empire_city_id].resource_sell_limit[r]) {
                        image_draw(resource_images[r].icon_img_id + resource_image_offset(r, RESOURCE_IMAGE_ICON), c->x_offset + 40 + width, y_base - 3);
                        width += 25;
                    }
                }
            }
        } else if (figure_properties[f->type].is_enemy_unit) {
            image_draw(image_data_s.group_image_ids[GROUP_BIG_PEOPLE] + figure_properties[f->type].big_img_id - 1, c->x_offset + 28, c->y_offset + 112);

            lang_text_draw(65, f->name_id, c->x_offset + 90, c->y_offset + 108, FONT_LARGE_BROWN);

            switch (f->type) {
                case FIGURE_ENEMY_BARBARIAN_SWORDSMAN:
                    text_draw(enemy_desc_strings[0], c->x_offset + 92, c->y_offset + 149, FONT_NORMAL_BROWN, COLOR_BLACK);
                    break;
                case FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN:
                case FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT:
                    text_draw(enemy_desc_strings[1], c->x_offset + 92, c->y_offset + 149, FONT_NORMAL_BROWN, COLOR_BLACK);
                    break;
                case FIGURE_ENEMY_BRITON_SWORDSMAN:
                case FIGURE_ENEMY_BRITON_CHARIOT:
                    text_draw(enemy_desc_strings[2], c->x_offset + 92, c->y_offset + 149, FONT_NORMAL_BROWN, COLOR_BLACK);
                    break;
                case FIGURE_ENEMY_CELT_SWORDSMAN:
                case FIGURE_ENEMY_CELT_CHARIOT:
                    text_draw(enemy_desc_strings[3], c->x_offset + 92, c->y_offset + 149, FONT_NORMAL_BROWN, COLOR_BLACK);
                    break;
                case FIGURE_ENEMY_PICT_SWORDSMAN:
                case FIGURE_ENEMY_PICT_CHARIOT:
                    text_draw(enemy_desc_strings[4], c->x_offset + 92, c->y_offset + 149, FONT_NORMAL_BROWN, COLOR_BLACK);
                    break;
                case FIGURE_ENEMY_EGYPTIAN_SWORDSMAN:
                case FIGURE_ENEMY_EGYPTIAN_CAMEL:
                    text_draw(enemy_desc_strings[5], c->x_offset + 92, c->y_offset + 149, FONT_NORMAL_BROWN, COLOR_BLACK);
                    break;
                case FIGURE_ENEMY_ETRUSCAN_SWORDSMAN:
                case FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER:
                    text_draw(enemy_desc_strings[6], c->x_offset + 92, c->y_offset + 149, FONT_NORMAL_BROWN, COLOR_BLACK);
                    break;
                case FIGURE_ENEMY_SAMNITE_SWORDSMAN:
                case FIGURE_ENEMY_SAMNITE_SPEAR_THROWER:
                    text_draw(enemy_desc_strings[7], c->x_offset + 92, c->y_offset + 149, FONT_NORMAL_BROWN, COLOR_BLACK);
                    break;
                case FIGURE_ENEMY_GAUL_SWORDSMAN:
                case FIGURE_ENEMY_GAUL_AXEMAN:
                    text_draw(enemy_desc_strings[8], c->x_offset + 92, c->y_offset + 149, FONT_NORMAL_BROWN, COLOR_BLACK);
                    break;
                case FIGURE_ENEMY_HELVETIUS_SWORDSMAN:
                case FIGURE_ENEMY_HELVETIUS_AXEMAN:
                    text_draw(enemy_desc_strings[9], c->x_offset + 92, c->y_offset + 149, FONT_NORMAL_BROWN, COLOR_BLACK);
                    break;
                case FIGURE_ENEMY_HUN_SWORDSMAN:
                case FIGURE_ENEMY_HUN_MOUNTED_ARCHER:
                    text_draw(enemy_desc_strings[10], c->x_offset + 92, c->y_offset + 149, FONT_NORMAL_BROWN, COLOR_BLACK);
                    break;
                case FIGURE_ENEMY_GOTH_SWORDSMAN:
                case FIGURE_ENEMY_GOTH_MOUNTED_ARCHER:
                    text_draw(enemy_desc_strings[11], c->x_offset + 92, c->y_offset + 149, FONT_NORMAL_BROWN, COLOR_BLACK);
                    break;
                case FIGURE_ENEMY_VISIGOTH_SWORDSMAN:
                case FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER:
                    text_draw(enemy_desc_strings[12], c->x_offset + 92, c->y_offset + 149, FONT_NORMAL_BROWN, COLOR_BLACK);
                    break;
                case FIGURE_ENEMY_GREEK_SWORDSMAN:
                case FIGURE_ENEMY_GREEK_SPEAR_THROWER:
                    text_draw(enemy_desc_strings[13], c->x_offset + 92, c->y_offset + 149, FONT_NORMAL_BROWN, COLOR_BLACK);
                    break;
                case FIGURE_ENEMY_MACEDONIAN_SWORDSMAN:
                case FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER:
                    text_draw(enemy_desc_strings[14], c->x_offset + 92, c->y_offset + 149, FONT_NORMAL_BROWN, COLOR_BLACK);
                    break;
                case FIGURE_ENEMY_NUMIDIAN_SWORDSMAN:
                case FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER:
                    text_draw(enemy_desc_strings[15], c->x_offset + 92, c->y_offset + 149, FONT_NORMAL_BROWN, COLOR_BLACK);
                    break;
                case FIGURE_ENEMY_PERGAMUM_SWORDSMAN:
                case FIGURE_ENEMY_PERGAMUM_ARCHER:
                    text_draw(enemy_desc_strings[16], c->x_offset + 92, c->y_offset + 149, FONT_NORMAL_BROWN, COLOR_BLACK);
                    break;
                case FIGURE_ENEMY_IBERIAN_SWORDSMAN:
                case FIGURE_ENEMY_IBERIAN_SPEAR_THROWER:
                    text_draw(enemy_desc_strings[17], c->x_offset + 92, c->y_offset + 149, FONT_NORMAL_BROWN, COLOR_BLACK);
                    break;
                case FIGURE_ENEMY_JUDEAN_SWORDSMAN:
                case FIGURE_ENEMY_JUDEAN_SPEAR_THROWER:
                    text_draw(enemy_desc_strings[18], c->x_offset + 92, c->y_offset + 149, FONT_NORMAL_BROWN, COLOR_BLACK);
                    break;
                case FIGURE_ENEMY_SELEUCID_SWORDSMAN:
                case FIGURE_ENEMY_SELEUCID_SPEAR_THROWER:
                    text_draw(enemy_desc_strings[19], c->x_offset + 92, c->y_offset + 149, FONT_NORMAL_BROWN, COLOR_BLACK);
                    break;
            }
        } else if (f->type == FIGURE_SHIPWRECK || figure_properties[f->type].is_herd_animal) {
            image_draw(image_data_s.group_image_ids[GROUP_BIG_PEOPLE] + figure_properties[f->type].big_img_id - 1, c->x_offset + 28, c->y_offset + 112);
            text_draw(figure_desc_strings[f->type], c->x_offset + 92, c->y_offset + 139, FONT_NORMAL_BROWN, COLOR_BLACK);
        } else if (f->type == FIGURE_CART_PUSHER || f->type == FIGURE_WAREHOUSEMAN || f->type == FIGURE_DOCKER) {
            image_draw(image_data_s.group_image_ids[GROUP_BIG_PEOPLE] + figure_properties[f->type].big_img_id - 1, c->x_offset + 28, c->y_offset + 112);
            lang_text_draw(65, f->name_id, c->x_offset + 90, c->y_offset + 108, FONT_LARGE_BROWN);
            int width = text_draw(figure_desc_strings[f->type], c->x_offset + 92, c->y_offset + 139, FONT_NORMAL_BROWN, COLOR_BLACK);
            if (f->action_state != FIGURE_ACTION_DOCKER_IDLING && f->resource_id) {
                int resource = f->resource_id;
                image_draw(resource_images[resource].icon_img_id + resource_image_offset(resource, RESOURCE_IMAGE_ICON),
                    c->x_offset + 92 + width, c->y_offset + 135);
            }
            int phrase_height = lang_text_draw_multiline(130, 21 * c->figure.sound_id + c->figure.phrase_id + 1,
                c->x_offset + 90, c->y_offset + 160, BLOCK_SIZE * (c->width_blocks - 8), FONT_NORMAL_BROWN);

            if (!f->building_id) {
                return;
            }
            int is_returning = 0;
            switch (f->action_state) {
                case FIGURE_ACTION_CARTPUSHER_RETURNING:
                case FIGURE_ACTION_WAREHOUSEMAN_RETURNING_EMPTY:
                case FIGURE_ACTION_WAREHOUSEMAN_RETURNING_WITH_FOOD:
                case FIGURE_ACTION_WAREHOUSEMAN_RETURNING_WITH_RESOURCE:
                case FIGURE_ACTION_DOCKER_EXPORT_QUEUE:
                case FIGURE_ACTION_DOCKER_EXPORT_RETURNING:
                case FIGURE_ACTION_DOCKER_IMPORT_RETURNING:
                    is_returning = 1;
                    break;
            }
            if (f->action_state != FIGURE_ACTION_DOCKER_IDLING) {
                int x_base = c->x_offset + 40;
                int y_base = c->y_offset + 216;
                if (phrase_height > 60) {
                    y_base += 8;
                }
                struct building_t *source_building = &all_buildings[f->building_id];
                struct building_t *target_building = &all_buildings[f->destination_building_id];
                if (is_returning) {
                    width = lang_text_draw(129, 16, x_base, y_base, FONT_NORMAL_BROWN);
                    width += text_draw(all_buildings_strings[source_building->type], x_base + width, y_base, FONT_NORMAL_BROWN, COLOR_BLACK);
                    width += lang_text_draw(129, 14, x_base + width, y_base, FONT_NORMAL_BROWN);
                    text_draw(all_buildings_strings[target_building->type], x_base + width, y_base, FONT_NORMAL_BROWN, COLOR_BLACK);
                } else {
                    width = lang_text_draw(129, 15, x_base, y_base, FONT_NORMAL_BROWN);
                    width += text_draw(all_buildings_strings[target_building->type], x_base + width, y_base, FONT_NORMAL_BROWN, COLOR_BLACK);
                    width += lang_text_draw(129, 14, x_base + width, y_base, FONT_NORMAL_BROWN);
                    text_draw(all_buildings_strings[source_building->type], x_base + width, y_base, FONT_NORMAL_BROWN, COLOR_BLACK);
                }
            }
        } else if (f->type == FIGURE_MARKET_BUYER) {
            image_draw(image_data_s.group_image_ids[GROUP_BIG_PEOPLE] + figure_properties[f->type].big_img_id - 1, c->x_offset + 28, c->y_offset + 112);

            lang_text_draw(65, f->name_id, c->x_offset + 90, c->y_offset + 108, FONT_LARGE_BROWN);
            int width = text_draw(figure_desc_strings[f->type], c->x_offset + 92, c->y_offset + 139, FONT_NORMAL_BROWN, COLOR_BLACK);

            if (f->action_state == FIGURE_ACTION_MARKET_BUYER_GOING_TO_STORAGE) {
                width += lang_text_draw(129, 17, c->x_offset + 90 + width, c->y_offset + 139, FONT_NORMAL_BROWN);
                image_draw(resource_images[f->collecting_item_id + 1].icon_img_id + resource_image_offset(f->collecting_item_id + 1, RESOURCE_IMAGE_ICON),
                    c->x_offset + 90 + width, c->y_offset + 135);
            } else if (f->action_state == FIGURE_ACTION_MARKET_BUYER_RETURNING) {
                width += lang_text_draw(129, 18, c->x_offset + 90 + width, c->y_offset + 139, FONT_NORMAL_BROWN);
                image_draw(resource_images[f->collecting_item_id + 1].icon_img_id + resource_image_offset(f->collecting_item_id + 1, RESOURCE_IMAGE_ICON),
                    c->x_offset + 90 + width, c->y_offset + 135);
            }
            if (c->figure.phrase_id >= 0) {
                lang_text_draw_multiline(130, 21 * c->figure.sound_id + c->figure.phrase_id + 1,
                    c->x_offset + 90, c->y_offset + 160, BLOCK_SIZE * (c->width_blocks - 8), FONT_NORMAL_BROWN);
            }
        } else {
            int image_id = image_data_s.group_image_ids[GROUP_BIG_PEOPLE] + figure_properties[f->type].big_img_id - 1;
            if (f->action_state == FIGURE_ACTION_PREFECT_GOING_TO_FIRE ||
                f->action_state == FIGURE_ACTION_PREFECT_AT_FIRE) {
                image_id = image_data_s.group_image_ids[GROUP_BIG_PEOPLE] + 18;
            }
            image_draw(image_id, c->x_offset + 28, c->y_offset + 112);

            lang_text_draw(65, f->name_id, c->x_offset + 90, c->y_offset + 108, FONT_LARGE_BROWN);
            if (figure_properties[f->type].is_caesar_legion_unit) {
                text_draw(enemy_desc_strings[20], c->x_offset + 92, c->y_offset + 139, FONT_NORMAL_BROWN, COLOR_BLACK);
            } else {
                text_draw(figure_desc_strings[f->type], c->x_offset + 92, c->y_offset + 139, FONT_NORMAL_BROWN, COLOR_BLACK);
            }
            if (c->figure.phrase_id >= 0) {
                lang_text_draw_multiline(130, 21 * c->figure.sound_id + c->figure.phrase_id + 1,
                    c->x_offset + 90, c->y_offset + 160, BLOCK_SIZE * (c->width_blocks - 8), FONT_NORMAL_BROWN);
            }
        }
    }
    c->figure.drawn = 1;
}

static void window_building_prepare_figure_list(struct building_info_context_t *c)
{
    if (c->figure.count > 0) {
        struct pixel_coordinate_t coord = { 0, 0 };
        for (int i = 0; i < c->figure.count; i++) {
            int x_cam, y_cam;
            city_view_get_camera(&x_cam, &y_cam);
            int x, y;
            city_view_grid_offset_to_xy_view(figures[c->figure.figure_ids[i]].grid_offset, &x, &y);
            city_view_set_camera(x - 2, y - 6);
            set_city_clip_rectangle();
            city_without_overlay_draw(c->figure.figure_ids[i], &coord, &widget_city_data.current_tile);
            graphics_reset_clip_rectangle();
            city_view_set_camera(x_cam, y_cam);
            graphics_save_to_buffer(coord.x, coord.y, 48, 48, building_figures_data.figure_images[i]);
        }
        widget_city_draw();
    }
}

static void window_building_draw_employment_without_house_cover(struct building_info_context_t *c, int y_offset)
{
    struct building_t *b = &all_buildings[c->building_id];
    int text_id = draw_employment_info(b, 0);
    draw_employment_details(c, b, y_offset, text_id);
}

static int window_building_get_vertical_offset(struct building_info_context_t *c, int new_window_height)
{
    new_window_height = new_window_height * BLOCK_SIZE;
    int old_window_height = c->height_blocks * BLOCK_SIZE;
    int y_offset = c->y_offset;

    int center = (old_window_height / 2) + y_offset;
    int new_window_y = center - (new_window_height / 2);

    if (new_window_y < MIN_Y_POSITION) {
        new_window_y = MIN_Y_POSITION;
    } else {
        int height = screen_data.height - MARGIN_POSITION;

        if (new_window_y + new_window_height > height) {
            new_window_y = height - new_window_height;
        }
    }

    return new_window_y;
}

static void draw_native(struct building_info_context_t *c, int group_id)
{
    c->help_id = 0;
    window_building_play_sound(c, "wavs/empty_land.wav");
    outer_panel_draw(c->x_offset, c->y_offset, c->width_blocks, c->height_blocks);
    lang_text_draw_centered(group_id, 0, c->x_offset, c->y_offset + 10,
        BLOCK_SIZE * c->width_blocks, FONT_LARGE_BLACK);
    window_building_draw_description_at(c, 106, group_id, 1);
}

static void window_building_draw_description(struct building_info_context_t *c, int text_group, int text_id)
{
    lang_text_draw_multiline(text_group, text_id, c->x_offset + 32, c->y_offset + 56, BLOCK_SIZE * (c->width_blocks - 4), FONT_NORMAL_BLACK);
}

static void draw_entertainment_school(struct building_info_context_t *c, char *sound_file, int group_id)
{
    c->help_id = 75;
    window_building_play_sound(c, sound_file);

    outer_panel_draw(c->x_offset, c->y_offset, c->width_blocks, c->height_blocks);
    lang_text_draw_centered(group_id, 0, c->x_offset, c->y_offset + 10,
        BLOCK_SIZE * c->width_blocks, FONT_LARGE_BLACK);
    if (!c->has_road_access) {
        window_building_draw_description(c, 69, 25);
    } else if (all_buildings[c->building_id].num_workers <= 0) {
        window_building_draw_description(c, group_id, 7);
    } else if (c->worker_percentage >= 100) {
        window_building_draw_description(c, group_id, 2);
    } else if (c->worker_percentage >= 75) {
        window_building_draw_description(c, group_id, 3);
    } else if (c->worker_percentage >= 50) {
        window_building_draw_description(c, group_id, 4);
    } else if (c->worker_percentage >= 25) {
        window_building_draw_description(c, group_id, 5);
    } else {
        window_building_draw_description(c, group_id, 6);
    }
    inner_panel_draw(c->x_offset + 16, c->y_offset + 136, c->width_blocks - 2, 4);
    window_building_draw_employment(c, 142);
}

static void draw_temple(struct building_info_context_t *c, char *sound_file, int group_id, int image_offset)
{
    c->help_id = 67;
    window_building_play_sound(c, sound_file);
    outer_panel_draw(c->x_offset, c->y_offset, c->width_blocks, c->height_blocks);
    lang_text_draw_centered(group_id, 0, c->x_offset, c->y_offset + 12,
        BLOCK_SIZE * c->width_blocks, FONT_LARGE_BLACK);
    inner_panel_draw(c->x_offset + 16, c->y_offset + 56, c->width_blocks - 2, 4);
    window_building_draw_employment(c, 62);
    if (c->has_road_access) {
        image_draw(image_offset + image_data_s.group_image_ids[GROUP_PANEL_WINDOWS],
            c->x_offset + 190, c->y_offset + BLOCK_SIZE * c->height_blocks - 118);
    } else {
        window_building_draw_description_at(c, BLOCK_SIZE * c->height_blocks - 128, 69, 25);
    }
}

static void draw_culture_info(struct building_info_context_t *c, int help_id, char *sound_file, int group_id)
{
    c->help_id = help_id;
    window_building_play_sound(c, sound_file);
    outer_panel_draw(c->x_offset, c->y_offset, c->width_blocks, c->height_blocks);
    lang_text_draw_centered(group_id, 0, c->x_offset, c->y_offset + 10, BLOCK_SIZE * c->width_blocks, FONT_LARGE_BLACK);
    if (!c->has_road_access) {
        window_building_draw_description(c, 69, 25);
    } else if (all_buildings[c->building_id].num_workers <= 0) {
        window_building_draw_description(c, group_id, 2);
    } else {
        window_building_draw_description(c, group_id, 3);
    }
    inner_panel_draw(c->x_offset + 16, c->y_offset + 136, c->width_blocks - 2, 4);
    window_building_draw_employment(c, 142);
}

static void draw_background_building_info(void)
{
    window_city_draw_background();
    widget_city_draw();
    if (b_info_context.type == BUILDING_INFO_NONE) {
        outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
        lang_text_draw_centered(70, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
    } else if (b_info_context.type == BUILDING_INFO_TERRAIN) {
        switch (b_info_context.terrain_type) {
            case TERRAIN_INFO_ROAD: b_info_context.help_id = 57; break;
            case TERRAIN_INFO_AQUEDUCT: b_info_context.help_id = 60; break;
            case TERRAIN_INFO_WALL: b_info_context.help_id = 85; break;
            case TERRAIN_INFO_BRIDGE: b_info_context.help_id = 58; break;
            default: b_info_context.help_id = 0; break;
        }

        if (b_info_context.terrain_type == TERRAIN_INFO_AQUEDUCT) {
            b_info_context.help_id = 60;
            window_building_play_sound(&b_info_context, "wavs/aquaduct.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(141, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            window_building_draw_description_at(&b_info_context, BLOCK_SIZE * b_info_context.height_blocks - 144, 141, b_info_context.aqueduct_has_water ? 1 : 2);
        } else if (b_info_context.terrain_type == TERRAIN_INFO_RUBBLE) {
            b_info_context.help_id = 0;
            window_building_play_sound(&b_info_context, "wavs/ruin.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(140, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);

            lang_text_draw(41, b_info_context.rubble_building_type,
                b_info_context.x_offset + 32, b_info_context.y_offset + BLOCK_SIZE * b_info_context.height_blocks - 173, FONT_NORMAL_BLACK);
            lang_text_draw_multiline(140, 1, b_info_context.x_offset + 32, b_info_context.y_offset + BLOCK_SIZE * b_info_context.height_blocks - 143,
                BLOCK_SIZE * (b_info_context.width_blocks - 4), FONT_NORMAL_BLACK);
        } else if (b_info_context.terrain_type == TERRAIN_INFO_WALL) {
            b_info_context.help_id = 85;
            window_building_play_sound(&b_info_context, "wavs/wall.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(139, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            window_building_draw_description_at(&b_info_context, BLOCK_SIZE * b_info_context.height_blocks - 158, 139, 1);
        } else if (b_info_context.terrain_type == TERRAIN_INFO_GARDEN) {
            b_info_context.help_id = 80;
            window_building_play_sound(&b_info_context, "wavs/park.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(79, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            window_building_draw_description_at(&b_info_context, BLOCK_SIZE * b_info_context.height_blocks - 158, 79, 1);
        } else if (b_info_context.terrain_type == TERRAIN_INFO_PLAZA && b_info_context.figure.count <= 0) {
            b_info_context.help_id = 80;
            window_building_play_sound(&b_info_context, "wavs/plaza.wav");
            window_building_prepare_figure_list(&b_info_context);
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(137, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            window_building_draw_figure_list(&b_info_context);
            window_building_draw_description_at(&b_info_context, BLOCK_SIZE * b_info_context.height_blocks - 113, 137, 1);
        } else {
            if (b_info_context.can_play_sound) {
                b_info_context.can_play_sound = 0;
                if (b_info_context.figure.count > 0) {
                    window_building_play_figure_phrase(&b_info_context);
                } else {
                    play_speech_file("wavs/empty_land.wav");
                }
            }
            if (b_info_context.figure.count > 0 && b_info_context.figure.figure_ids[b_info_context.figure.selected_index]) {
                struct figure_t *f = &figures[b_info_context.figure.figure_ids[b_info_context.figure.selected_index]];
                if (f->type < FIGURE_SHIPWRECK) {
                    b_info_context.help_id = 42;
                } else {
                    b_info_context.help_id = 330;
                }
            }

            window_building_prepare_figure_list(&b_info_context);
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            if (!b_info_context.figure.count) {
                lang_text_draw_centered(70, b_info_context.terrain_type + 10, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            }
            if (b_info_context.terrain_type != TERRAIN_INFO_ROAD && b_info_context.terrain_type != TERRAIN_INFO_PLAZA) {
                lang_text_draw_multiline(70, b_info_context.terrain_type + 25, b_info_context.x_offset + 40, b_info_context.y_offset + BLOCK_SIZE * b_info_context.height_blocks - 113,
                    BLOCK_SIZE * (b_info_context.width_blocks - 4), FONT_NORMAL_BLACK);
            }
            if (b_info_context.figure.count) {
                window_building_draw_figure_list(&b_info_context);
            }
        }
    } else if (b_info_context.type == BUILDING_INFO_BUILDING) {
        int btype = all_buildings[b_info_context.building_id].type;
        if (building_is_house(btype)) {
            b_info_context.help_id = 56;
            struct building_t *b = &all_buildings[b_info_context.building_id];
            if (b->house_population == 0) {
                window_building_play_sound(&b_info_context, "wavs/empty_land.wav");
            } else {
                window_building_play_sound(&b_info_context, "wavs/housing.wav");
            }
            if (b->house_population <= 0) {
                window_building_prepare_figure_list(&b_info_context);
                outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
                lang_text_draw_centered(128, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
                window_building_draw_figure_list(&b_info_context);

                int text_id = 2;
                b = &all_buildings[b_info_context.building_id];
                if (map_closest_road_within_radius(b->x, b->y, 1, 2, 0, 0)) {
                    text_id = 1;
                }
                window_building_draw_description_at(&b_info_context, BLOCK_SIZE * b_info_context.height_blocks - 113, 128, text_id);
                return;
            }
            int level = b->type - 2;
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(29, level, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 148, b_info_context.width_blocks - 2, 10);

            // draw population info
            b = &all_buildings[b_info_context.building_id];
            image_draw(image_data_s.group_image_ids[GROUP_CONTEXT_ICONS] + 13, b_info_context.x_offset + 34, b_info_context.y_offset + 154 + 4);
            int width = text_draw_number(b->house_population, '@', " ", b_info_context.x_offset + 50, b_info_context.y_offset + 154 + 14, FONT_NORMAL_BROWN);
            width += lang_text_draw(127, 20, b_info_context.x_offset + 50 + width, b_info_context.y_offset + 154 + 14, FONT_NORMAL_BROWN);

            if (b->house_population_room < 0) {
                width += text_draw_number(-b->house_population_room, '@', " ",
                    b_info_context.x_offset + 50 + width, b_info_context.y_offset + 154 + 14, FONT_NORMAL_BROWN);
                lang_text_draw(127, 21, b_info_context.x_offset + 50 + width, b_info_context.y_offset + 154 + 14, FONT_NORMAL_BROWN);
            } else if (b->house_population_room > 0) {
                width += lang_text_draw(127, 22, b_info_context.x_offset + 50 + width, b_info_context.y_offset + 154 + 14, FONT_NORMAL_BROWN);
                text_draw_number(b->house_population_room, '@', " ",
                    b_info_context.x_offset + 50 + width, b_info_context.y_offset + 154 + 14, FONT_NORMAL_BROWN);
            }

            // draw tax info
            b = &all_buildings[b_info_context.building_id];
            if (b->house_tax_coverage) {
                width = lang_text_draw(127, 24, b_info_context.x_offset + 36, b_info_context.y_offset + 194, FONT_NORMAL_BROWN);
                width += lang_text_draw_amount(8, 0, calc_adjust_with_percentage(b->tax_income_or_storage / 2, city_data.finance.tax_percentage), b_info_context.x_offset + 36 + width, b_info_context.y_offset + 194, FONT_NORMAL_BROWN);
                lang_text_draw(127, 25, b_info_context.x_offset + 36 + width, b_info_context.y_offset + 194, FONT_NORMAL_BROWN);
            } else {
                lang_text_draw(127, 23, b_info_context.x_offset + 36, b_info_context.y_offset + 194, FONT_NORMAL_BROWN);
            }

            // draw happiness info
            int happiness = all_buildings[b_info_context.building_id].sentiment.house_happiness;
            int text_id;
            if (happiness >= 50) {
                text_id = 26;
            } else if (happiness >= 40) {
                text_id = 27;
            } else if (happiness >= 30) {
                text_id = 28;
            } else if (happiness >= 20) {
                text_id = 29;
            } else if (happiness >= 10) {
                text_id = 30;
            } else if (happiness >= 1) {
                text_id = 31;
            } else {
                text_id = 32;
            }
            lang_text_draw(127, text_id, b_info_context.x_offset + 36, b_info_context.y_offset + 214, FONT_NORMAL_BROWN);

            // food inventory
            if (house_properties[b->subtype.house_level].food_types) {
                // wheat
                image_draw(resource_images[RESOURCE_WHEAT].icon_img_id, b_info_context.x_offset + 32, b_info_context.y_offset + 234);
                text_draw_number(b->data.house.inventory[INVENTORY_WHEAT], '@', " ",
                    b_info_context.x_offset + 64, b_info_context.y_offset + 238, FONT_NORMAL_BROWN);
                // vegetables
                image_draw(resource_images[RESOURCE_VEGETABLES].icon_img_id, b_info_context.x_offset + 142, b_info_context.y_offset + 234);
                text_draw_number(b->data.house.inventory[INVENTORY_VEGETABLES], '@', " ",
                    b_info_context.x_offset + 174, b_info_context.y_offset + 238, FONT_NORMAL_BROWN);
                // fruit
                image_draw(resource_images[RESOURCE_FRUIT].icon_img_id, b_info_context.x_offset + 252, b_info_context.y_offset + 234);
                text_draw_number(b->data.house.inventory[INVENTORY_FRUIT], '@', " ",
                    b_info_context.x_offset + 284, b_info_context.y_offset + 238, FONT_NORMAL_BROWN);
                // meat/fish
                image_draw(resource_images[RESOURCE_MEAT].icon_img_id + resource_image_offset(RESOURCE_MEAT, RESOURCE_IMAGE_ICON),
                    b_info_context.x_offset + 362, b_info_context.y_offset + 234);
                text_draw_number(b->data.house.inventory[INVENTORY_MEAT], '@', " ",
                    b_info_context.x_offset + 394, b_info_context.y_offset + 238, FONT_NORMAL_BROWN);
            } else {
                // no food necessary
                lang_text_draw_multiline(127, 33, b_info_context.x_offset + 36, b_info_context.y_offset + 234,
                    BLOCK_SIZE * (b_info_context.width_blocks - 6), FONT_NORMAL_BROWN);
            }
            // goods inventory
            // pottery
            image_draw(resource_images[RESOURCE_POTTERY].icon_img_id, b_info_context.x_offset + 32, b_info_context.y_offset + 274);
            text_draw_number(b->data.house.inventory[INVENTORY_POTTERY], '@', " ",
                b_info_context.x_offset + 64, b_info_context.y_offset + 278, FONT_NORMAL_BROWN);
            // furniture
            image_draw(resource_images[RESOURCE_FURNITURE].icon_img_id, b_info_context.x_offset + 142, b_info_context.y_offset + 274);
            text_draw_number(b->data.house.inventory[INVENTORY_FURNITURE], '@', " ",
                b_info_context.x_offset + 174, b_info_context.y_offset + 278, FONT_NORMAL_BROWN);
            // oil
            image_draw(resource_images[RESOURCE_OIL].icon_img_id, b_info_context.x_offset + 252, b_info_context.y_offset + 274);
            text_draw_number(b->data.house.inventory[INVENTORY_OIL], '@', " ",
                b_info_context.x_offset + 284, b_info_context.y_offset + 278, FONT_NORMAL_BROWN);
            // wine
            image_draw(resource_images[RESOURCE_WINE].icon_img_id, b_info_context.x_offset + 362, b_info_context.y_offset + 274);
            text_draw_number(b->data.house.inventory[INVENTORY_WINE], '@', " ",
                b_info_context.x_offset + 394, b_info_context.y_offset + 278, FONT_NORMAL_BROWN);

            if (b->data.house.evolve_text_id == 62) {
                width = lang_text_draw(127, 40 + b->data.house.evolve_text_id, b_info_context.x_offset + 32, b_info_context.y_offset + 60, FONT_NORMAL_BLACK);
                width += text_draw(all_buildings_strings[all_buildings[b_info_context.worst_desirability_building_id].type], b_info_context.x_offset + 32 + width, b_info_context.y_offset + 60, FONT_NORMAL_PLAIN, COLOR_FONT_RED);
                text_draw(")", b_info_context.x_offset + 32 + width, b_info_context.y_offset + 60, FONT_NORMAL_BLACK, 0);
                lang_text_draw_multiline(127, 41 + b->data.house.evolve_text_id,
                    b_info_context.x_offset + 32, b_info_context.y_offset + 76, BLOCK_SIZE * (b_info_context.width_blocks - 4), FONT_NORMAL_BLACK);
            } else {
                lang_text_draw_multiline(127, 40 + b->data.house.evolve_text_id, b_info_context.x_offset + 32, b_info_context.y_offset + 70, BLOCK_SIZE * (b_info_context.width_blocks - 4), FONT_NORMAL_BLACK);
            }
        } else if (btype == BUILDING_WHEAT_FARM) {
            draw_farm(&b_info_context, 89, "wavs/wheat_farm.wav", 112, RESOURCE_WHEAT);
        } else if (btype == BUILDING_VEGETABLE_FARM) {
            draw_farm(&b_info_context, 90, "wavs/veg_farm.wav", 113, RESOURCE_VEGETABLES);
        } else if (btype == BUILDING_FRUIT_FARM) {
            draw_farm(&b_info_context, 90, "wavs/figs_farm.wav", 114, RESOURCE_FRUIT);
        } else if (btype == BUILDING_OLIVE_FARM) {
            draw_farm(&b_info_context, 91, "wavs/olives_farm.wav", 115, RESOURCE_OLIVES);
        } else if (btype == BUILDING_VINES_FARM) {
            draw_farm(&b_info_context, 91, "wavs/vines_farm.wav", 116, RESOURCE_VINES);
        } else if (btype == BUILDING_PIG_FARM) {
            draw_farm(&b_info_context, 90, "wavs/meat_farm.wav", 117, RESOURCE_MEAT);
        } else if (btype == BUILDING_MARBLE_QUARRY) {
            draw_raw_material(&b_info_context, 95, "wavs/quarry.wav", 118, RESOURCE_MARBLE);
        } else if (btype == BUILDING_IRON_MINE) {
            draw_raw_material(&b_info_context, 93, "wavs/mine.wav", 119, RESOURCE_IRON);
        } else if (btype == BUILDING_TIMBER_YARD) {
            draw_raw_material(&b_info_context, 94, "wavs/timber.wav", 120, RESOURCE_TIMBER);
        } else if (btype == BUILDING_CLAY_PIT) {
            draw_raw_material(&b_info_context, 92, "wavs/clay.wav", 121, RESOURCE_CLAY);
        } else if (btype == BUILDING_WINE_WORKSHOP) {
            draw_workshop(&b_info_context, 96, "wavs/wine_workshop.wav", 122, RESOURCE_WINE, RESOURCE_VINES);
        } else if (btype == BUILDING_OIL_WORKSHOP) {
            draw_workshop(&b_info_context, 97, "wavs/oil_workshop.wav", 123, RESOURCE_OIL, RESOURCE_OLIVES);
        } else if (btype == BUILDING_WEAPONS_WORKSHOP) {
            draw_workshop(&b_info_context, 98, "wavs/weapons_workshop.wav", 124, RESOURCE_WEAPONS, RESOURCE_IRON);
        } else if (btype == BUILDING_FURNITURE_WORKSHOP) {
            draw_workshop(&b_info_context, 99, "wavs/furniture_workshop.wav", 125, RESOURCE_FURNITURE, RESOURCE_TIMBER);
        } else if (btype == BUILDING_POTTERY_WORKSHOP) {
            draw_workshop(&b_info_context, 1, "wavs/pottery_workshop.wav", 126, RESOURCE_POTTERY, RESOURCE_CLAY);
        } else if (btype == BUILDING_MARKET) {
            b_info_context.help_id = 2;
            window_building_play_sound(&b_info_context, "wavs/market.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(97, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            struct building_t *b = &all_buildings[b_info_context.building_id];
            if (!b_info_context.has_road_access) {
                window_building_draw_description(&b_info_context, 69, 25);
            } else if (b->num_workers <= 0) {
                window_building_draw_description(&b_info_context, 97, 2);
            } else {
                if (b->data.market.inventory[INVENTORY_WHEAT] || b->data.market.inventory[INVENTORY_VEGETABLES] ||
                    b->data.market.inventory[INVENTORY_FRUIT] || b->data.market.inventory[INVENTORY_MEAT]) {
                    // food stocks
                    image_draw(resource_images[RESOURCE_WHEAT].icon_img_id, b_info_context.x_offset + 32, b_info_context.y_offset + 64);
                    text_draw_number(b->data.market.inventory[INVENTORY_WHEAT], '@', " ",
                        b_info_context.x_offset + 64, b_info_context.y_offset + 70, FONT_NORMAL_BLACK);

                    image_draw(resource_images[RESOURCE_VEGETABLES].icon_img_id, b_info_context.x_offset + 142, b_info_context.y_offset + 64);
                    text_draw_number(b->data.market.inventory[INVENTORY_VEGETABLES], '@', " ",
                        b_info_context.x_offset + 174, b_info_context.y_offset + 70, FONT_NORMAL_BLACK);

                    image_draw(resource_images[RESOURCE_FRUIT].icon_img_id, b_info_context.x_offset + 252, b_info_context.y_offset + 64);
                    text_draw_number(b->data.market.inventory[INVENTORY_FRUIT], '@', " ",
                        b_info_context.x_offset + 284, b_info_context.y_offset + 70, FONT_NORMAL_BLACK);

                    image_draw(resource_images[RESOURCE_MEAT].icon_img_id + resource_image_offset(RESOURCE_MEAT, RESOURCE_IMAGE_ICON),
                        b_info_context.x_offset + 362, b_info_context.y_offset + 64);
                    text_draw_number(b->data.market.inventory[INVENTORY_MEAT], '@', " ",
                        b_info_context.x_offset + 394, b_info_context.y_offset + 70, FONT_NORMAL_BLACK);
                } else {
                    window_building_draw_description_at(&b_info_context, 48, 97, 4);
                }
                // good stocks
                image_draw(resource_images[RESOURCE_POTTERY].icon_img_id, b_info_context.x_offset + 32, b_info_context.y_offset + 104);
                text_draw_number(b->data.market.inventory[INVENTORY_POTTERY], '@', " ",
                    b_info_context.x_offset + 64, b_info_context.y_offset + 110, FONT_NORMAL_BLACK);

                image_draw(resource_images[RESOURCE_FURNITURE].icon_img_id, b_info_context.x_offset + 142, b_info_context.y_offset + 104);
                text_draw_number(b->data.market.inventory[INVENTORY_FURNITURE], '@', " ",
                    b_info_context.x_offset + 174, b_info_context.y_offset + 110, FONT_NORMAL_BLACK);

                image_draw(resource_images[RESOURCE_OIL].icon_img_id, b_info_context.x_offset + 252, b_info_context.y_offset + 104);
                text_draw_number(b->data.market.inventory[INVENTORY_OIL], '@', " ",
                    b_info_context.x_offset + 284, b_info_context.y_offset + 110, FONT_NORMAL_BLACK);

                image_draw(resource_images[RESOURCE_WINE].icon_img_id, b_info_context.x_offset + 362, b_info_context.y_offset + 104);
                text_draw_number(b->data.market.inventory[INVENTORY_WINE], '@', " ",
                    b_info_context.x_offset + 394, b_info_context.y_offset + 110, FONT_NORMAL_BLACK);
            }
            inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 136, b_info_context.width_blocks - 2, 4);
            window_building_draw_employment(&b_info_context, 142);
        } else if (btype == BUILDING_GRANARY) {
            if (b_info_context.storage_show_special_orders) {
                b_info_context.help_id = 3;
                int y_offset = window_building_get_vertical_offset(&b_info_context, 28);
                outer_panel_draw(b_info_context.x_offset, y_offset, 29, 28);
                lang_text_draw_centered(98, 6, b_info_context.x_offset, y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
                inner_panel_draw(b_info_context.x_offset + 16, y_offset + 42, b_info_context.width_blocks - 2, 21);
            } else {
                b_info_context.help_id = 3;
                window_building_play_sound(&b_info_context, "wavs/granary.wav");
                outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
                lang_text_draw_centered(98, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
                struct building_t *b = &all_buildings[b_info_context.building_id];
                if (!b_info_context.has_road_access) {
                    window_building_draw_description_at(&b_info_context, 40, 69, 25);
                } else if (scenario.rome_supplies_wheat) {
                    window_building_draw_description_at(&b_info_context, 40, 98, 4);
                } else {
                    int total_stored = 0;
                    for (int i = RESOURCE_WHEAT; i < FOOD_TYPES_MAX; i++) {
                        total_stored += b->data.granary.resource_stored[i];
                    }
                    int width = lang_text_draw(98, 2, b_info_context.x_offset + 34, b_info_context.y_offset + 40, FONT_NORMAL_BLACK);
                    lang_text_draw_amount(8, 16, total_stored, b_info_context.x_offset + 34 + width, b_info_context.y_offset + 40, FONT_NORMAL_BLACK);

                    width = lang_text_draw(98, 3, b_info_context.x_offset + 220, b_info_context.y_offset + 40, FONT_NORMAL_BLACK);
                    lang_text_draw_amount(8, 16, b->data.granary.resource_stored[RESOURCE_NONE],
                        b_info_context.x_offset + 220 + width, b_info_context.y_offset + 40, FONT_NORMAL_BLACK);

                    // wheat
                    image_draw(resource_images[RESOURCE_WHEAT].icon_img_id, b_info_context.x_offset + 34, b_info_context.y_offset + 68);
                    width = text_draw_number(b->data.granary.resource_stored[RESOURCE_WHEAT], '@', " ",
                        b_info_context.x_offset + 68, b_info_context.y_offset + 75, FONT_NORMAL_BLACK);
                    text_draw(resource_strings[RESOURCE_WHEAT], b_info_context.x_offset + 68 + width, b_info_context.y_offset + 75, FONT_NORMAL_BLACK, COLOR_BLACK);

                    // vegetables
                    image_draw(resource_images[RESOURCE_VEGETABLES].icon_img_id, b_info_context.x_offset + 34, b_info_context.y_offset + 92);
                    width = text_draw_number(b->data.granary.resource_stored[RESOURCE_VEGETABLES], '@', " ",
                        b_info_context.x_offset + 68, b_info_context.y_offset + 99, FONT_NORMAL_BLACK);
                    text_draw(resource_strings[RESOURCE_VEGETABLES], b_info_context.x_offset + 68 + width, b_info_context.y_offset + 99, FONT_NORMAL_BLACK, COLOR_BLACK);

                    // fruit
                    image_draw(resource_images[RESOURCE_FRUIT].icon_img_id, b_info_context.x_offset + 240, b_info_context.y_offset + 68);
                    width = text_draw_number(b->data.granary.resource_stored[RESOURCE_FRUIT], '@', " ",
                        b_info_context.x_offset + 274, b_info_context.y_offset + 75, FONT_NORMAL_BLACK);
                    text_draw(resource_strings[RESOURCE_FRUIT], b_info_context.x_offset + 274 + width, b_info_context.y_offset + 75, FONT_NORMAL_BLACK, COLOR_BLACK);

                    // meat/fish
                    image_draw(resource_images[RESOURCE_MEAT].icon_img_id + resource_image_offset(RESOURCE_MEAT, RESOURCE_IMAGE_ICON),
                        b_info_context.x_offset + 240, b_info_context.y_offset + 92);
                    width = text_draw_number(b->data.granary.resource_stored[RESOURCE_MEAT], '@', " ",
                        b_info_context.x_offset + 274, b_info_context.y_offset + 99, FONT_NORMAL_BLACK);
                    text_draw(resource_strings[RESOURCE_MEAT], b_info_context.x_offset + 274 + width, b_info_context.y_offset + 99, FONT_NORMAL_BLACK, COLOR_BLACK);
                }
                // cartpusher state
                int cartpusher = b->figure_id;
                int has_cart_orders = cartpusher && figure_is_alive(&figures[cartpusher]);
                inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 136, b_info_context.width_blocks - 2, has_cart_orders ? 5 : 4);
                window_building_draw_employment(&b_info_context, 142);
                if (has_cart_orders) {
                    image_draw(resource_images[figures[cartpusher].resource_id].icon_img_id +
                        resource_image_offset(figures[cartpusher].resource_id, RESOURCE_IMAGE_ICON),
                        b_info_context.x_offset + 32, b_info_context.y_offset + 190);
                    lang_text_draw_multiline(99, 17, b_info_context.x_offset + 64, b_info_context.y_offset + 193,
                        BLOCK_SIZE * (b_info_context.width_blocks - 5), FONT_NORMAL_BROWN);
                }
            }
        } else if (btype == BUILDING_WAREHOUSE) {
            if (b_info_context.storage_show_special_orders) {
                int y_offset = window_building_get_vertical_offset(&b_info_context, 28);
                b_info_context.help_id = 4;
                outer_panel_draw(b_info_context.x_offset, y_offset, 29, 28);
                lang_text_draw_centered(99, 3, b_info_context.x_offset, y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
                inner_panel_draw(b_info_context.x_offset + 16, y_offset + 42, b_info_context.width_blocks - 2, 21);
            } else {
                b_info_context.help_id = 4;
                window_building_play_sound(&b_info_context, "wavs/warehouse.wav");
                outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
                lang_text_draw_centered(99, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
                struct building_t *b = &all_buildings[b_info_context.building_id];
                if (!b_info_context.has_road_access) {
                    window_building_draw_description(&b_info_context, 69, 25);
                } else {
                    for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                        int x, y;
                        if (r <= 5) {
                            x = b_info_context.x_offset + 20;
                            y = b_info_context.y_offset + 24 * (r - 1) + 36;
                        } else if (r <= 10) {
                            x = b_info_context.x_offset + 170;
                            y = b_info_context.y_offset + 24 * (r - 6) + 36;
                        } else {
                            x = b_info_context.x_offset + 320;
                            y = b_info_context.y_offset + 24 * (r - 11) + 36;
                        }
                        int amount = building_warehouse_get_amount(b, r);
                        int image_id = resource_images[r].icon_img_id + resource_image_offset(r, RESOURCE_IMAGE_ICON);
                        image_draw(image_id, x, y);
                        int width = text_draw_number(amount, '@', " ", x + 24, y + 7, FONT_SMALL_PLAIN);
                        text_draw(resource_strings[r], x + 24 + width, y + 7, FONT_SMALL_PLAIN, COLOR_BLACK);
                    }
                }
                inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 168, b_info_context.width_blocks - 2, 5);
                window_building_draw_employment(&b_info_context, 173);
                // cartpusher state
                int cartpusher = b->figure_id;
                if (cartpusher && figure_is_alive(&figures[cartpusher])) {
                    image_draw(resource_images[figures[cartpusher].resource_id].icon_img_id +
                        resource_image_offset(figures[cartpusher].resource_id, RESOURCE_IMAGE_ICON),
                        b_info_context.x_offset + 32, b_info_context.y_offset + 220);
                    lang_text_draw_multiline(99, 17, b_info_context.x_offset + 64, b_info_context.y_offset + 223,
                        BLOCK_SIZE * (b_info_context.width_blocks - 5), FONT_NORMAL_BROWN);
                } else if (b->num_workers) {
                    // cartpusher is waiting for orders
                    lang_text_draw_multiline(99, 15, b_info_context.x_offset + 32, b_info_context.y_offset + 223,
                        BLOCK_SIZE * (b_info_context.width_blocks - 3), FONT_NORMAL_BROWN);
                }

                if (b_info_context.warehouse_space_text == 1) { // full
                    lang_text_draw_multiline(99, 13, b_info_context.x_offset + 32, b_info_context.y_offset + BLOCK_SIZE * b_info_context.height_blocks - 93,
                        BLOCK_SIZE * (b_info_context.width_blocks - 4), FONT_NORMAL_BLACK);
                } else if (b_info_context.warehouse_space_text == 2) {
                    lang_text_draw_multiline(99, 14, b_info_context.x_offset + 32, b_info_context.y_offset + BLOCK_SIZE * b_info_context.height_blocks - 93,
                        BLOCK_SIZE * (b_info_context.width_blocks - 4), FONT_NORMAL_BLACK);
                }
            }
        } else if (btype == BUILDING_AMPHITHEATER) {
            b_info_context.help_id = 72;
            window_building_play_sound(&b_info_context, "wavs/ampitheatre.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(71, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            struct building_t *b = &all_buildings[b_info_context.building_id];
            if (!b_info_context.has_road_access) {
                window_building_draw_description(&b_info_context, 69, 25);
            } else if (b->num_workers <= 0) {
                window_building_draw_description(&b_info_context, 71, 6);
            } else if (!b->data.entertainment.num_shows) {
                window_building_draw_description(&b_info_context, 71, 2);
            } else if (b->data.entertainment.num_shows == 2) {
                window_building_draw_description(&b_info_context, 71, 3);
            } else if (b->data.entertainment.days1) {
                window_building_draw_description(&b_info_context, 71, 4);
            } else if (b->data.entertainment.days2) {
                window_building_draw_description(&b_info_context, 71, 5);
            }
            inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 136, b_info_context.width_blocks - 2, 7);
            window_building_draw_employment(&b_info_context, 138);
            if (b->data.entertainment.days1 > 0) {
                int width = lang_text_draw(71, 8, b_info_context.x_offset + 32, b_info_context.y_offset + 182, FONT_NORMAL_BROWN);
                lang_text_draw_amount(8, 44, 2 * b->data.entertainment.days1,
                    b_info_context.x_offset + width + 32, b_info_context.y_offset + 182, FONT_NORMAL_BROWN);
            } else {
                lang_text_draw(71, 7, b_info_context.x_offset + 32, b_info_context.y_offset + 182, FONT_NORMAL_BROWN);
            }
            if (b->data.entertainment.days2 > 0) {
                int width = lang_text_draw(71, 10, b_info_context.x_offset + 32, b_info_context.y_offset + 202, FONT_NORMAL_BROWN);
                lang_text_draw_amount(8, 44, 2 * b->data.entertainment.days2,
                    b_info_context.x_offset + width + 32, b_info_context.y_offset + 202, FONT_NORMAL_BROWN);
                lang_text_draw(72, 7 + b->data.entertainment.play,
                    b_info_context.x_offset + 32, b_info_context.y_offset + 222, FONT_NORMAL_BROWN);
            } else {
                lang_text_draw(71, 9, b_info_context.x_offset + 32, b_info_context.y_offset + 202, FONT_NORMAL_BROWN);
            }
        } else if (btype == BUILDING_THEATER) {
            b_info_context.help_id = 71;
            window_building_play_sound(&b_info_context, "wavs/theatre.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(72, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            struct building_t *b = &all_buildings[b_info_context.building_id];
            if (!b_info_context.has_road_access) {
                window_building_draw_description(&b_info_context, 69, 25);
            } else if (b->num_workers <= 0) {
                window_building_draw_description(&b_info_context, 72, 4);
            } else if (!b->data.entertainment.num_shows) {
                window_building_draw_description(&b_info_context, 72, 2);
            } else if (b->data.entertainment.days1) {
                window_building_draw_description(&b_info_context, 72, 3);
            }
            inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 136, b_info_context.width_blocks - 2, 6);
            window_building_draw_employment(&b_info_context, 138);
            if (b->data.entertainment.days1 > 0) {
                int width = lang_text_draw(72, 6, b_info_context.x_offset + 32, b_info_context.y_offset + 182, FONT_NORMAL_BROWN);
                lang_text_draw_amount(8, 44, 2 * b->data.entertainment.days1,
                    b_info_context.x_offset + width + 32, b_info_context.y_offset + 182, FONT_NORMAL_BROWN);
                lang_text_draw(72, 7 + b->data.entertainment.play,
                    b_info_context.x_offset + 32, b_info_context.y_offset + 202, FONT_NORMAL_BROWN);
            } else {
                lang_text_draw(72, 5, b_info_context.x_offset + 32, b_info_context.y_offset + 182, FONT_NORMAL_BROWN);
            }
        } else if (btype == BUILDING_HIPPODROME) {
            b_info_context.help_id = 74;
            window_building_play_sound(&b_info_context, "wavs/hippodrome.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(73, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            struct building_t *b = &all_buildings[b_info_context.building_id];
            if (!b_info_context.has_road_access) {
                window_building_draw_description(&b_info_context, 69, 25);
            } else if (b->num_workers <= 0) {
                window_building_draw_description(&b_info_context, 73, 4);
            } else if (!b->data.entertainment.num_shows) {
                window_building_draw_description(&b_info_context, 73, 2);
            } else if (b->data.entertainment.days1) {
                window_building_draw_description(&b_info_context, 73, 3);
            }
            inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 136, b_info_context.width_blocks - 2, 6);
            window_building_draw_employment(&b_info_context, 138);
            if (b->data.entertainment.days1 > 0) {
                int width = lang_text_draw(73, 6, b_info_context.x_offset + 32, b_info_context.y_offset + 202, FONT_NORMAL_BROWN);
                lang_text_draw_amount(8, 44, 2 * b->data.entertainment.days1,
                    b_info_context.x_offset + width + 32, b_info_context.y_offset + 202, FONT_NORMAL_BROWN);
            } else {
                lang_text_draw(73, 5, b_info_context.x_offset + 32, b_info_context.y_offset + 202, FONT_NORMAL_BROWN);
            }
        } else if (btype == BUILDING_COLOSSEUM) {
            b_info_context.help_id = 73;
            window_building_play_sound(&b_info_context, "wavs/colloseum.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(74, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            struct building_t *b = &all_buildings[b_info_context.building_id];
            if (!b_info_context.has_road_access) {
                window_building_draw_description(&b_info_context, 69, 25);
            } else if (b->num_workers <= 0) {
                window_building_draw_description(&b_info_context, 74, 6);
            } else if (!b->data.entertainment.num_shows) {
                window_building_draw_description(&b_info_context, 74, 2);
            } else if (b->data.entertainment.num_shows == 2) {
                window_building_draw_description(&b_info_context, 74, 3);
            } else if (b->data.entertainment.days1) {
                window_building_draw_description(&b_info_context, 74, 5);
            } else if (b->data.entertainment.days2) {
                window_building_draw_description(&b_info_context, 74, 4);
            }
            inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 136, b_info_context.width_blocks - 2, 6);
            window_building_draw_employment(&b_info_context, 138);
            if (b->data.entertainment.days1 > 0) {
                int width = lang_text_draw(74, 8, b_info_context.x_offset + 32, b_info_context.y_offset + 182, FONT_NORMAL_BROWN);
                lang_text_draw_amount(8, 44, 2 * b->data.entertainment.days1,
                    b_info_context.x_offset + width + 32, b_info_context.y_offset + 182, FONT_NORMAL_BROWN);
            } else {
                lang_text_draw(74, 7, b_info_context.x_offset + 32, b_info_context.y_offset + 182, FONT_NORMAL_BROWN);
            }
            if (b->data.entertainment.days2 > 0) {
                int width = lang_text_draw(74, 10, b_info_context.x_offset + 32, b_info_context.y_offset + 202, FONT_NORMAL_BROWN);
                lang_text_draw_amount(8, 44, 2 * b->data.entertainment.days2,
                    b_info_context.x_offset + width + 32, b_info_context.y_offset + 202, FONT_NORMAL_BROWN);
            } else {
                lang_text_draw(74, 9, b_info_context.x_offset + 32, b_info_context.y_offset + 202, FONT_NORMAL_BROWN);
            }
        } else if (btype == BUILDING_GLADIATOR_SCHOOL) {
            draw_entertainment_school(&b_info_context, "wavs/glad_pit.wav", 75);
        } else if (btype == BUILDING_LION_HOUSE) {
            draw_entertainment_school(&b_info_context, "wavs/lion_pit.wav", 76);
        } else if (btype == BUILDING_ACTOR_COLONY) {
            draw_entertainment_school(&b_info_context, "wavs/art_pit.wav", 77);
        } else if (btype == BUILDING_CHARIOT_MAKER) {
            draw_entertainment_school(&b_info_context, "wavs/char_pit.wav", 78);
        } else if (btype == BUILDING_DOCTOR) {
            draw_culture_info(&b_info_context, 65, "wavs/clinic.wav", 81);
        } else if (btype == BUILDING_HOSPITAL) {
            draw_culture_info(&b_info_context, 66, "wavs/hospital.wav", 82);
        } else if (btype == BUILDING_BATHHOUSE) {
            b_info_context.help_id = 64;
            window_building_play_sound(&b_info_context, "wavs/baths.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(83, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            struct building_t *b = &all_buildings[b_info_context.building_id];
            if (!b->has_water_access) {
                window_building_draw_description(&b_info_context, 83, 4);
            } else if (!b_info_context.has_road_access) {
                window_building_draw_description(&b_info_context, 69, 25);
            } else if (b->num_workers <= 0) {
                window_building_draw_description(&b_info_context, 83, 2);
            } else {
                window_building_draw_description(&b_info_context, 83, 3);
            }
            inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 136, b_info_context.width_blocks - 2, 4);
            window_building_draw_employment(&b_info_context, 142);
        } else if (btype == BUILDING_BARBER) {
            draw_culture_info(&b_info_context, 63, "wavs/barber.wav", 84);
        } else if (btype == BUILDING_SCHOOL) {
            draw_culture_info(&b_info_context, 68, "wavs/school.wav", 85);
        } else if (btype == BUILDING_ACADEMY) {
            draw_culture_info(&b_info_context, 69, "wavs/academy.wav", 86);
        } else if (btype == BUILDING_LIBRARY) {
            draw_culture_info(&b_info_context, 70, "wavs/library.wav", 87);
        } else if (btype == BUILDING_SMALL_TEMPLE_CERES || btype == BUILDING_LARGE_TEMPLE_CERES) {
            draw_temple(&b_info_context, "wavs/temple_farm.wav", 92, 21);
        } else if (btype == BUILDING_SMALL_TEMPLE_NEPTUNE || btype == BUILDING_LARGE_TEMPLE_NEPTUNE) {
            draw_temple(&b_info_context, "wavs/temple_ship.wav", 93, 22);
        } else if (btype == BUILDING_SMALL_TEMPLE_MERCURY || btype == BUILDING_LARGE_TEMPLE_MERCURY) {
            draw_temple(&b_info_context, "wavs/temple_comm.wav", 94, 23);
        } else if (btype == BUILDING_SMALL_TEMPLE_MARS || btype == BUILDING_LARGE_TEMPLE_MARS) {
            draw_temple(&b_info_context, "wavs/temple_war.wav", 95, 24);
        } else if (btype == BUILDING_SMALL_TEMPLE_VENUS || btype == BUILDING_LARGE_TEMPLE_VENUS) {
            draw_temple(&b_info_context, "wavs/temple_love.wav", 96, 25);
        } else if (btype == BUILDING_ORACLE) {
            b_info_context.help_id = 67;
            window_building_play_sound(&b_info_context, "wavs/oracle.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(110, 0, b_info_context.x_offset, b_info_context.y_offset + 12, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            window_building_draw_description_at(&b_info_context, BLOCK_SIZE * b_info_context.height_blocks - 158, 110, 1);
        } else if (btype == BUILDING_GOVERNORS_HOUSE || btype == BUILDING_GOVERNORS_VILLA || btype == BUILDING_GOVERNORS_PALACE) {
            b_info_context.help_id = 78;
            window_building_play_sound(&b_info_context, "wavs/gov_palace.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(103, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            window_building_draw_description_at(&b_info_context, BLOCK_SIZE * b_info_context.height_blocks - 143, 103, 1);
        } else if (btype == BUILDING_FORUM) {
            b_info_context.help_id = 76;
            window_building_play_sound(&b_info_context, "wavs/forum.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(106, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            image_draw(COIN_IMAGE_ID, b_info_context.x_offset + 16, b_info_context.y_offset + 36);

            struct building_t *b = &all_buildings[b_info_context.building_id];
            int width = lang_text_draw(106, 2, b_info_context.x_offset + 44, b_info_context.y_offset + 43, FONT_NORMAL_BLACK);
            lang_text_draw_amount(8, 0, b->tax_income_or_storage,
                b_info_context.x_offset + 44 + width, b_info_context.y_offset + 43, FONT_NORMAL_BLACK);

            if (!b_info_context.has_road_access) {
                window_building_draw_description(&b_info_context, 69, 25);
            } else if (b->num_workers <= 0) {
                window_building_draw_description_at(&b_info_context, 72, 106, 10);
            } else if (b_info_context.worker_percentage >= 100) {
                window_building_draw_description_at(&b_info_context, 72, 106, 5);
            } else if (b_info_context.worker_percentage >= 75) {
                window_building_draw_description_at(&b_info_context, 72, 106, 6);
            } else if (b_info_context.worker_percentage >= 50) {
                window_building_draw_description_at(&b_info_context, 72, 106, 7);
            } else if (b_info_context.worker_percentage >= 25) {
                window_building_draw_description_at(&b_info_context, 72, 106, 8);
            } else {
                window_building_draw_description_at(&b_info_context, 72, 106, 9);
            }

            inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 136, b_info_context.width_blocks - 2, 4);
            window_building_draw_employment(&b_info_context, 142);
        } else if (btype == BUILDING_SENATE) {
            b_info_context.can_go_to_advisor = 1;
            b_info_context.help_id = 77;
            window_building_play_sound(&b_info_context, "wavs/senate.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(105, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            image_draw(COIN_IMAGE_ID, b_info_context.x_offset + 16, b_info_context.y_offset + 36);

            struct building_t *b = &all_buildings[b_info_context.building_id];
            int width = lang_text_draw(105, 2, b_info_context.x_offset + 44, b_info_context.y_offset + 43, FONT_NORMAL_BLACK);
            lang_text_draw_amount(8, 0, b->tax_income_or_storage,
                b_info_context.x_offset + 44 + width, b_info_context.y_offset + 43, FONT_NORMAL_BLACK);

            if (!b_info_context.has_road_access) {
                window_building_draw_description(&b_info_context, 69, 25);
            } else if (b->num_workers <= 0) {
                window_building_draw_description_at(&b_info_context, 72, 106, 10);
            } else if (b_info_context.worker_percentage >= 100) {
                window_building_draw_description_at(&b_info_context, 72, 106, 5);
            } else if (b_info_context.worker_percentage >= 75) {
                window_building_draw_description_at(&b_info_context, 72, 106, 6);
            } else if (b_info_context.worker_percentage >= 50) {
                window_building_draw_description_at(&b_info_context, 72, 106, 7);
            } else if (b_info_context.worker_percentage >= 25) {
                window_building_draw_description_at(&b_info_context, 72, 106, 8);
            } else {
                window_building_draw_description_at(&b_info_context, 72, 106, 9);
            }
            inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 136, b_info_context.width_blocks - 2, 4);
            window_building_draw_employment(&b_info_context, 142);
            lang_text_draw(105, 3, b_info_context.x_offset + 60, b_info_context.y_offset + 220, FONT_NORMAL_BLACK);
        } else if (btype == BUILDING_ENGINEERS_POST) {
            b_info_context.help_id = 81;
            window_building_play_sound(&b_info_context, "wavs/eng_post.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(104, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);

            struct building_t *b = &all_buildings[b_info_context.building_id];

            if (!b_info_context.has_road_access) {
                window_building_draw_description(&b_info_context, 69, 25);
            } else if (!b->num_workers) {
                window_building_draw_description(&b_info_context, 104, 9);
            } else {
                if (b->figure_id) {
                    window_building_draw_description(&b_info_context, 104, 2);
                } else {
                    window_building_draw_description(&b_info_context, 104, 3);
                }
                if (b_info_context.worker_percentage >= 100) {
                    window_building_draw_description_at(&b_info_context, 72, 104, 4);
                } else if (b_info_context.worker_percentage >= 75) {
                    window_building_draw_description_at(&b_info_context, 72, 104, 5);
                } else if (b_info_context.worker_percentage >= 50) {
                    window_building_draw_description_at(&b_info_context, 72, 104, 6);
                } else if (b_info_context.worker_percentage >= 25) {
                    window_building_draw_description_at(&b_info_context, 72, 104, 7);
                } else {
                    window_building_draw_description_at(&b_info_context, 72, 104, 8);
                }
            }
            inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 136, b_info_context.width_blocks - 2, 4);
            window_building_draw_employment(&b_info_context, 142);
        } else if (btype == BUILDING_SHIPYARD) {
            b_info_context.help_id = 82;
            window_building_play_sound(&b_info_context, "wavs/shipyard.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(100, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            struct building_t *b = &all_buildings[b_info_context.building_id];
            if (!b_info_context.has_road_access) {
                window_building_draw_description(&b_info_context, 69, 25);
            } else {
                int pct_done = calc_percentage(b->data.industry.progress, 160);
                int width = lang_text_draw(100, 2, b_info_context.x_offset + 32, b_info_context.y_offset + 56, FONT_NORMAL_BLACK);
                width += text_draw_percentage(pct_done, b_info_context.x_offset + 32 + width, b_info_context.y_offset + 56, FONT_NORMAL_BLACK);
                lang_text_draw(100, 3, b_info_context.x_offset + 32 + width, b_info_context.y_offset + 56, FONT_NORMAL_BLACK);
                if (city_data.building.shipyard_boats_requested) {
                    lang_text_draw_multiline(100, 5, b_info_context.x_offset + 32, b_info_context.y_offset + 80,
                        BLOCK_SIZE * (b_info_context.width_blocks - 6), FONT_NORMAL_BLACK);
                } else {
                    lang_text_draw_multiline(100, 4, b_info_context.x_offset + 32, b_info_context.y_offset + 80,
                        BLOCK_SIZE * (b_info_context.width_blocks - 6), FONT_NORMAL_BLACK);
                }
            }
            inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 136, b_info_context.width_blocks - 2, 4);
            window_building_draw_employment(&b_info_context, 142);
        } else if (btype == BUILDING_DOCK) {
            b_info_context.help_id = 83;
            window_building_play_sound(&b_info_context, "wavs/dock.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(101, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);

            struct building_t *b = &all_buildings[b_info_context.building_id];

            if (!b_info_context.has_road_access) {
                window_building_draw_description(&b_info_context, 69, 25);
            } else if (b->data.dock.trade_ship_id) {
                if (b_info_context.worker_percentage <= 0) {
                    window_building_draw_description(&b_info_context, 101, 2);
                } else if (b_info_context.worker_percentage < 50) {
                    window_building_draw_description(&b_info_context, 101, 3);
                } else if (b_info_context.worker_percentage < 75) {
                    window_building_draw_description(&b_info_context, 101, 4);
                } else {
                    window_building_draw_description(&b_info_context, 101, 5);
                }
            } else {
                if (b_info_context.worker_percentage <= 0) {
                    window_building_draw_description(&b_info_context, 101, 6);
                } else if (b_info_context.worker_percentage < 50) {
                    window_building_draw_description(&b_info_context, 101, 7);
                } else if (b_info_context.worker_percentage < 75) {
                    window_building_draw_description(&b_info_context, 101, 8);
                } else {
                    window_building_draw_description(&b_info_context, 101, 9);
                }
            }
            inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 136, b_info_context.width_blocks - 2, 4);
            window_building_draw_employment(&b_info_context, 142);
        } else if (btype == BUILDING_WHARF) {
            b_info_context.help_id = 84;
            window_building_play_sound(&b_info_context, "wavs/wharf.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(102, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            image_draw(resource_images[RESOURCE_MEAT].icon_img_id + resource_image_offset(RESOURCE_MEAT, RESOURCE_IMAGE_ICON), b_info_context.x_offset + 10, b_info_context.y_offset + 10);
            struct building_t *b = &all_buildings[b_info_context.building_id];
            if (!b_info_context.has_road_access) {
                window_building_draw_description(&b_info_context, 69, 25);
            } else if (!b->data.industry.fishing_boat_id) {
                window_building_draw_description(&b_info_context, 102, 2);
            } else {
                int text_id;
                switch (figures[b->data.industry.fishing_boat_id].action_state) {
                    case FIGURE_ACTION_FISHING_BOAT_GOING_TO_FISH: text_id = 3; break;
                    case FIGURE_ACTION_FISHING_BOAT_FISHING: text_id = 4; break;
                    case FIGURE_ACTION_FISHING_BOAT_GOING_TO_WHARF: text_id = 5; break;
                    case FIGURE_ACTION_FISHING_BOAT_AT_WHARF: text_id = 6; break;
                    case FIGURE_ACTION_FISHING_BOAT_RETURNING_WITH_FISH: text_id = 7; break;
                    default: text_id = 8; break;
                }
                window_building_draw_description(&b_info_context, 102, text_id);
            }
            inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 136, b_info_context.width_blocks - 2, 4);
            window_building_draw_employment(&b_info_context, 142);
        } else if (btype == BUILDING_RESERVOIR) {
            b_info_context.help_id = 59;
            window_building_play_sound(&b_info_context, "wavs/resevoir.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(107, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            int text_id = all_buildings[b_info_context.building_id].has_water_access ? 1 : 3;
            window_building_draw_description_at(&b_info_context, BLOCK_SIZE * b_info_context.height_blocks - 173, 107, text_id);
        } else if (btype == BUILDING_FOUNTAIN) {
            b_info_context.help_id = 61;
            window_building_play_sound(&b_info_context, "wavs/fountain.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(108, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            int text_id;
            struct building_t *b = &all_buildings[b_info_context.building_id];
            if (b->has_water_access) {
                if (b->num_workers > 0) {
                    text_id = 1;
                } else {
                    text_id = 2;
                }
            } else if (b_info_context.has_reservoir_pipes) {
                text_id = 2;
            } else {
                text_id = 3;
            }
            window_building_draw_description(&b_info_context, 108, text_id);
            inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 166, b_info_context.width_blocks - 2, 4);
            window_building_draw_employment_without_house_cover(&b_info_context, 172);
        } else if (btype == BUILDING_WELL) {
            b_info_context.help_id = 62;
            window_building_play_sound(&b_info_context, "wavs/well.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(109, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            int well_necessity = WELL_UNNECESSARY_NO_HOUSES;
            struct building_t *well = &all_buildings[b_info_context.building_id];
            int x_min, y_min, x_max, y_max;
            map_grid_get_area(well->x, well->y, 1, 2, &x_min, &y_min, &x_max, &y_max);
            for (int yy = y_min; yy <= y_max; yy++) {
                for (int xx = x_min; xx <= x_max; xx++) {
                    int grid_offset = map_grid_offset(xx, yy);
                    int building_id = map_building_at(grid_offset);
                    if (building_id && all_buildings[building_id].house_size) {
                        if (!map_terrain_is(grid_offset, TERRAIN_FOUNTAIN_RANGE)) {
                            well_necessity = WELL_NECESSARY;
                            break;
                        }
                    }
                }
            }
            int text_id = 0;
            if (well_necessity == WELL_NECESSARY) { // well is OK
                text_id = 1;
            } else if (well_necessity == WELL_UNNECESSARY_FOUNTAIN) { // all houses have fountain
                text_id = 2;
            } else if (well_necessity == WELL_UNNECESSARY_NO_HOUSES) { // no houses around
                text_id = 3;
            }
            if (text_id) {
                window_building_draw_description_at(&b_info_context, BLOCK_SIZE * b_info_context.height_blocks - 160, 109, text_id);
            }
        } else if (btype == BUILDING_SMALL_STATUE
            || btype == BUILDING_MEDIUM_STATUE
            || btype == BUILDING_LARGE_STATUE) {
            b_info_context.help_id = 79;
            window_building_play_sound(&b_info_context, "wavs/statue.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(80, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            window_building_draw_description_at(&b_info_context, BLOCK_SIZE * b_info_context.height_blocks - 158, 80, 1);
        } else if (btype == BUILDING_TRIUMPHAL_ARCH) {
            b_info_context.help_id = 79;
            window_building_play_sound(&b_info_context, "wavs/statue.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(80, 2, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            window_building_draw_description_at(&b_info_context, BLOCK_SIZE * b_info_context.height_blocks - 158, 80, 3);
        } else if (btype == BUILDING_PREFECTURE) {
            b_info_context.help_id = 86;
            window_building_play_sound(&b_info_context, "wavs/prefecture.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(88, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            struct building_t *b = &all_buildings[b_info_context.building_id];
            if (!b_info_context.has_road_access) {
                window_building_draw_description(&b_info_context, 69, 25);
            } else if (b->num_workers <= 0) {
                window_building_draw_description(&b_info_context, 88, 9);
            } else {
                if (b->figure_id) {
                    window_building_draw_description(&b_info_context, 88, 2);
                } else {
                    window_building_draw_description(&b_info_context, 88, 3);
                }
                if (b_info_context.worker_percentage >= 100) {
                    window_building_draw_description_at(&b_info_context, 72, 88, 4);
                } else if (b_info_context.worker_percentage >= 75) {
                    window_building_draw_description_at(&b_info_context, 72, 88, 5);
                } else if (b_info_context.worker_percentage >= 50) {
                    window_building_draw_description_at(&b_info_context, 72, 88, 6);
                } else if (b_info_context.worker_percentage >= 25) {
                    window_building_draw_description_at(&b_info_context, 72, 88, 7);
                } else {
                    window_building_draw_description_at(&b_info_context, 72, 88, 8);
                }
            }
            inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 136, b_info_context.width_blocks - 2, 4);
            window_building_draw_employment(&b_info_context, 142);
        } else if (btype == BUILDING_GATEHOUSE) {
            b_info_context.help_id = 85;
            window_building_play_sound(&b_info_context, "wavs/gatehouse.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(90, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            window_building_draw_description_at(&b_info_context, BLOCK_SIZE * b_info_context.height_blocks - 158, 90, 1);
        } else if (btype == BUILDING_TOWER) {
            b_info_context.help_id = 85;
            window_building_play_sound(&b_info_context, "wavs/tower.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(91, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            struct building_t *b = &all_buildings[b_info_context.building_id];
            if (!b_info_context.has_road_access) {
                window_building_draw_description(&b_info_context, 69, 25);
            } else if (b->num_workers <= 0) {
                window_building_draw_description(&b_info_context, 91, 2);
            } else if (b->figure_id) {
                window_building_draw_description(&b_info_context, 91, 3);
            } else {
                window_building_draw_description(&b_info_context, 91, 4);
            }
            inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 136, b_info_context.width_blocks - 2, 4);
            window_building_draw_employment(&b_info_context, 142);
        } else if (btype == BUILDING_MILITARY_ACADEMY) {
            b_info_context.help_id = 88;
            window_building_play_sound(&b_info_context, "wavs/mil_acad.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(135, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            struct building_t *b = &all_buildings[b_info_context.building_id];
            if (!b_info_context.has_road_access) {
                window_building_draw_description(&b_info_context, 69, 25);
            } else if (b->num_workers <= 0) {
                window_building_draw_description(&b_info_context, 135, 2);
            } else if (b_info_context.worker_percentage < 100) {
                window_building_draw_description(&b_info_context, 135, 1);
            } else {
                window_building_draw_description(&b_info_context, 135, 3);
            }
            inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 136, b_info_context.width_blocks - 2, 4);
            window_building_draw_employment(&b_info_context, 142);
        } else if (btype == BUILDING_BARRACKS) {
            b_info_context.help_id = 37;
            window_building_play_sound(&b_info_context, "wavs/barracks.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(136, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            image_draw(resource_images[RESOURCE_WEAPONS].icon_img_id, b_info_context.x_offset + 64, b_info_context.y_offset + 38);
            struct building_t *b = &all_buildings[b_info_context.building_id];
            if (b->loads_stored < 1) {
                lang_text_draw_amount(8, 10, 0, b_info_context.x_offset + 92, b_info_context.y_offset + 44, FONT_NORMAL_BLACK);
            } else {
                lang_text_draw_amount(8, 10, b->loads_stored, b_info_context.x_offset + 92, b_info_context.y_offset + 44, FONT_NORMAL_BLACK);
            }
            if (!b_info_context.has_road_access) {
                window_building_draw_description_at(&b_info_context, 70, 69, 25);
            } else if (b->num_workers <= 0) {
                window_building_draw_description_at(&b_info_context, 70, 136, 3);
            } else if (!b_info_context.barracks_soldiers_requested) {
                window_building_draw_description_at(&b_info_context, 70, 136, 4);
            } else {
                int offset = 0;
                if (b->loads_stored > 0) {
                    offset = 4;
                }
                if (b_info_context.worker_percentage >= 100) {
                    window_building_draw_description_at(&b_info_context, 70, 136, 5 + offset);
                } else if (b_info_context.worker_percentage >= 66) {
                    window_building_draw_description_at(&b_info_context, 70, 136, 6 + offset);
                } else if (b_info_context.worker_percentage >= 33) {
                    window_building_draw_description_at(&b_info_context, 70, 136, 7 + offset);
                } else {
                    window_building_draw_description_at(&b_info_context, 70, 136, 8 + offset);
                }
            }
            inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 136, b_info_context.width_blocks - 2, 4);
            window_building_draw_employment(&b_info_context, 142);
        } else if (building_is_fort(btype)) {
            b_info_context.help_id = 87;
            window_building_play_sound(&b_info_context, "wavs/fort.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(89, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            window_building_draw_description_at(&b_info_context, BLOCK_SIZE * b_info_context.height_blocks - 158, 89, legion_formations[b_info_context.formation_id].cursed_by_mars ? 1 : 2);
        } else if (btype == BUILDING_BURNING_RUIN) {
            b_info_context.help_id = 0;
            window_building_play_sound(&b_info_context, "wavs/ruin.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(111, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            lang_text_draw(41, b_info_context.rubble_building_type, b_info_context.x_offset + 32, b_info_context.y_offset + BLOCK_SIZE * b_info_context.height_blocks - 173, FONT_NORMAL_BLACK);
            lang_text_draw_multiline(111, 1, b_info_context.x_offset + 32, b_info_context.y_offset + BLOCK_SIZE * b_info_context.height_blocks - 143, BLOCK_SIZE * (b_info_context.width_blocks - 4), FONT_NORMAL_BLACK);
        } else if (btype == BUILDING_NATIVE_HUT) {
            draw_native(&b_info_context, 131);
        } else if (btype == BUILDING_NATIVE_MEETING) {
            draw_native(&b_info_context, 132);
        } else if (btype == BUILDING_NATIVE_CROPS) {
            draw_native(&b_info_context, 133);
        } else if (btype == BUILDING_MISSION_POST) {
            b_info_context.help_id = 8;
            window_building_play_sound(&b_info_context, "wavs/mission.wav");
            outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
            lang_text_draw_centered(134, 0, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
            window_building_draw_description(&b_info_context, 134, 1);
            inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 136, b_info_context.width_blocks - 2, 4);
            window_building_draw_employment_without_house_cover(&b_info_context, 142);
        }
    } else if (b_info_context.type == BUILDING_INFO_LEGION) {
        int text_id;
        b_info_context.help_id = 87;
        struct formation_t *m = &legion_formations[b_info_context.formation_id];
        outer_panel_draw(b_info_context.x_offset, b_info_context.y_offset, b_info_context.width_blocks, b_info_context.height_blocks);
        // legion name
        lang_text_draw_centered(138, m->id, b_info_context.x_offset, b_info_context.y_offset + 10, BLOCK_SIZE * b_info_context.width_blocks, FONT_LARGE_BLACK);
        // animal symbol at the top of banner pole
        int icon_image_id = image_data_s.group_image_ids[GROUP_FIGURE_FORT_STANDARD_ICONS] + m->id;
        struct image_t *icon_image = image_get(icon_image_id);
        image_draw(icon_image_id, b_info_context.x_offset + 16 + (40 - icon_image->width) / 2, b_info_context.y_offset + 16);
        // legion banner
        int flag_image_id = image_data_s.group_image_ids[GROUP_FIGURE_FORT_FLAGS];
        if (m->figure_type == FIGURE_FORT_JAVELIN) {
            flag_image_id += 9;
        } else if (m->figure_type == FIGURE_FORT_MOUNTED) {
            flag_image_id += 18;
        }
        struct image_t *flag_image = image_get(flag_image_id);
        image_draw(flag_image_id, b_info_context.x_offset + 16 + (40 - flag_image->width) / 2, b_info_context.y_offset + 16 + icon_image->height);
        // banner pole and morale ball
        int pole_image_id = image_data_s.group_image_ids[GROUP_FIGURE_FORT_STANDARD_POLE] + 20 - m->morale / 5;
        image_draw(pole_image_id, b_info_context.x_offset + 16 + (40 - image_get(pole_image_id)->width) / 2, b_info_context.y_offset + 16 + icon_image->height + flag_image->height);
        // number of soldiers
        lang_text_draw(138, 23, b_info_context.x_offset + 100, b_info_context.y_offset + 60, FONT_NORMAL_BLACK);
        text_draw_number(m->num_figures, ' ', "", b_info_context.x_offset + 294, b_info_context.y_offset + 60, FONT_NORMAL_BLACK);
        // health
        lang_text_draw(138, 24, b_info_context.x_offset + 100, b_info_context.y_offset + 80, FONT_NORMAL_BLACK);
        int formation_damage = 0;
        int formation_max_damage = 0;
        for (int i = 0; i < m->num_figures; i++) {
            struct figure_t *f = &figures[m->figures[i]];
            if (figure_is_alive(f)) {
                formation_damage += f->damage;
                formation_max_damage += figure_properties[f->type].max_damage;
            }
        }
        int formation_damage_perc = calc_percentage(formation_damage, formation_max_damage);
        if (formation_damage_perc <= 0) {
            text_id = 26;
        } else if (formation_damage_perc <= 20) {
            text_id = 27;
        } else if (formation_damage_perc <= 40) {
            text_id = 28;
        } else if (formation_damage_perc <= 55) {
            text_id = 29;
        } else if (formation_damage_perc <= 70) {
            text_id = 30;
        } else if (formation_damage_perc <= 90) {
            text_id = 31;
        } else {
            text_id = 32;
        }
        lang_text_draw(138, text_id, b_info_context.x_offset + 300, b_info_context.y_offset + 80, FONT_NORMAL_BLACK);
        // military training
        lang_text_draw(138, 25, b_info_context.x_offset + 100, b_info_context.y_offset + 100, FONT_NORMAL_BLACK);
        lang_text_draw(18, m->has_military_training, b_info_context.x_offset + 300, b_info_context.y_offset + 100, FONT_NORMAL_BLACK);
        // morale
        if (m->cursed_by_mars) {
            lang_text_draw(138, 59, b_info_context.x_offset + 100, b_info_context.y_offset + 120, FONT_NORMAL_BLACK);
        } else {
            lang_text_draw(138, 36, b_info_context.x_offset + 100, b_info_context.y_offset + 120, FONT_NORMAL_BLACK);
            lang_text_draw(138, 37 + m->morale / 5, b_info_context.x_offset + 300, b_info_context.y_offset + 120, FONT_NORMAL_BLACK);
        }
        if (m->num_figures) {
            // layout
            static   int OFFSETS_LEGIONARY[2][5] = {
                {0, 0, 2, 3, 4},
                {0, 0, 3, 2, 4},
            };
            static   int OFFSETS_OTHER[2][5] = {
                {5, 6, 2, 3, 4},
                {6, 5, 3, 2, 4},
            };
            int *offsets;
            int rotation_index = 0;
            if (view_data.orientation == DIR_6_LEFT || view_data.orientation == DIR_2_RIGHT) {
                rotation_index = 1;
            }
            if (m->figure_type == FIGURE_FORT_LEGIONARY) {
                offsets = OFFSETS_LEGIONARY[rotation_index];
            } else {
                offsets = OFFSETS_OTHER[rotation_index];
            }
            for (int i = 0; i < 5; i++) {
                // for legionaries, draw tortoise formation in first position if academy trained, skip second position
                if (m->figure_type == FIGURE_FORT_LEGIONARY) {
                    if ((i == 0 && !m->has_military_training) || i == 1) {
                        continue;
                    }
                }
                image_draw(image_data_s.group_image_ids[GROUP_FORT_FORMATIONS] + offsets[i], b_info_context.x_offset + 21 + 85 * i, b_info_context.y_offset + 141);
            }
        } else {
            // no soldiers
            int group_id;
            if (m->cursed_by_mars) {
                group_id = 89;
                text_id = 1;
            } else if (count_data.buildings[BUILDING_BARRACKS].active) {
                group_id = 138;
                text_id = 10;
            } else {
                group_id = 138;
                text_id = 11;
            }
            window_building_draw_description_at(&b_info_context, 172, group_id, text_id);
        }
    }
}

static void draw_foreground_building_info(void)
{
    // building-specific buttons
    if (b_info_context.type == BUILDING_INFO_BUILDING) {
        int btype = all_buildings[b_info_context.building_id].type;
        if (btype == BUILDING_GRANARY) {
            if (b_info_context.storage_show_special_orders) {
                int y_offset = window_building_get_vertical_offset(&b_info_context, 28);
                // empty button
                button_border_draw(b_info_context.x_offset + 80, y_offset + 404, BLOCK_SIZE * (b_info_context.width_blocks - 10), 20,
                    distribution_data.orders_focus_button_id == 1 ? 1 : 0);
                struct building_storage_t *storage = &storages[all_buildings[b_info_context.building_id].storage_id].storage;
                if (storage->empty_all) {
                    lang_text_draw_centered(98, 8, b_info_context.x_offset + 80, y_offset + 408, BLOCK_SIZE * (b_info_context.width_blocks - 10), FONT_NORMAL_BLACK);
                    lang_text_draw_centered(98, 9, b_info_context.x_offset, y_offset + 384, BLOCK_SIZE * b_info_context.width_blocks, FONT_NORMAL_BLACK);
                } else {
                    lang_text_draw_centered(98, 7, b_info_context.x_offset + 80, y_offset + 408, BLOCK_SIZE * (b_info_context.width_blocks - 10), FONT_NORMAL_BLACK);
                }
                // accept none button
                draw_accept_none_button(b_info_context.x_offset + 394, y_offset + 404, distribution_data.orders_focus_button_id == 2);
                struct resource_list_t *list = &available.food_list;
                for (int i = 0; i < list->size; i++) {
                    int resource = list->items[i];
                    int image_id = resource_images[resource].icon_img_id + resource_image_offset(resource, RESOURCE_IMAGE_ICON);
                    image_draw(image_id, b_info_context.x_offset + 32, y_offset + 46 + 22 * i);
                    image_draw(image_id, b_info_context.x_offset + 408, y_offset + 46 + 22 * i);
                    text_draw(resource_strings[resource], b_info_context.x_offset + 72, y_offset + 50 + 22 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                    button_border_draw(b_info_context.x_offset + 180, y_offset + 46 + 22 * i, 210, 22, distribution_data.resource_focus_button_id == i + 1);

                    int state = storage->resource_state[resource];
                    if (state == BUILDING_STORAGE_STATE_ACCEPTING) {
                        lang_text_draw(99, 7, b_info_context.x_offset + 230, y_offset + 51 + 22 * i, FONT_NORMAL_WHITE);
                    } else if (state == BUILDING_STORAGE_STATE_NOT_ACCEPTING) {
                        lang_text_draw(99, 8, b_info_context.x_offset + 230, y_offset + 51 + 22 * i, FONT_NORMAL_RED);
                    } else if (state == BUILDING_STORAGE_STATE_GETTING) {
                        image_draw(image_data_s.group_image_ids[GROUP_CONTEXT_ICONS] + 12, b_info_context.x_offset + 186, y_offset + 49 + 22 * i);
                        lang_text_draw(99, 10, b_info_context.x_offset + 230, y_offset + 51 + 22 * i, FONT_NORMAL_WHITE);
                    }
                }
            } else {
                button_border_draw(b_info_context.x_offset + 80, b_info_context.y_offset + BLOCK_SIZE * b_info_context.height_blocks - 34, BLOCK_SIZE * (b_info_context.width_blocks - 10), 20, distribution_data.focus_button_id == 1 ? 1 : 0);
                lang_text_draw_centered(98, 5, b_info_context.x_offset + 80, b_info_context.y_offset + BLOCK_SIZE * b_info_context.height_blocks - 30, BLOCK_SIZE * (b_info_context.width_blocks - 10), FONT_NORMAL_BLACK);
            }
        } else if (btype == BUILDING_WAREHOUSE) {
            if (b_info_context.storage_show_special_orders) {
                int y_offset = window_building_get_vertical_offset(&b_info_context, 28);
                // emptying button
                button_border_draw(b_info_context.x_offset + 80, y_offset + 404, BLOCK_SIZE * (b_info_context.width_blocks - 10),
                    20, distribution_data.orders_focus_button_id == 1 ? 1 : 0);
                struct building_storage_t *storage = &storages[all_buildings[b_info_context.building_id].storage_id].storage;
                if (storage->empty_all) {
                    lang_text_draw_centered(99, 5, b_info_context.x_offset + 80, y_offset + 408,
                        BLOCK_SIZE * (b_info_context.width_blocks - 10), FONT_NORMAL_BLACK);
                    lang_text_draw_centered(99, 6, b_info_context.x_offset, y_offset + 426, BLOCK_SIZE * b_info_context.width_blocks, FONT_SMALL_PLAIN);
                } else {
                    lang_text_draw_centered(99, 4, b_info_context.x_offset + 80, y_offset + 408,
                        BLOCK_SIZE * (b_info_context.width_blocks - 10), FONT_NORMAL_BLACK);
                }
                // trade center
                button_border_draw(b_info_context.x_offset + 80, y_offset + 382, BLOCK_SIZE * (b_info_context.width_blocks - 10),
                    20, distribution_data.orders_focus_button_id == 2 ? 1 : 0);
                int is_trade_center = b_info_context.building_id == city_data.building.trade_center_building_id;
                lang_text_draw_centered(99, is_trade_center ? 11 : 12, b_info_context.x_offset + 80, y_offset + 386,
                    BLOCK_SIZE * (b_info_context.width_blocks - 10), FONT_NORMAL_BLACK);
                // accept none button
                draw_accept_none_button(b_info_context.x_offset + 394, y_offset + 404, distribution_data.orders_focus_button_id == 3);
                struct resource_list_t *list = &available.resource_list;
                for (int i = 0; i < list->size; i++) {
                    int resource = list->items[i];
                    int image_id = resource_images[resource].icon_img_id + resource_image_offset(resource, RESOURCE_IMAGE_ICON);
                    image_draw(image_id, b_info_context.x_offset + 32, y_offset + 46 + 22 * i);
                    image_draw(image_id, b_info_context.x_offset + 408, y_offset + 46 + 22 * i);
                    text_draw(resource_strings[resource], b_info_context.x_offset + 72, y_offset + 50 + 22 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                    button_border_draw(b_info_context.x_offset + 180, y_offset + 46 + 22 * i, 210, 22, distribution_data.resource_focus_button_id == i + 1);
                    int state = storage->resource_state[resource];
                    if (state == BUILDING_STORAGE_STATE_ACCEPTING) {
                        lang_text_draw(99, 7, b_info_context.x_offset + 230, y_offset + 51 + 22 * i, FONT_NORMAL_WHITE);
                    } else if (state == BUILDING_STORAGE_STATE_NOT_ACCEPTING) {
                        lang_text_draw(99, 8, b_info_context.x_offset + 230, y_offset + 51 + 22 * i, FONT_NORMAL_RED);
                    } else if (state == BUILDING_STORAGE_STATE_GETTING) {
                        image_draw(image_data_s.group_image_ids[GROUP_CONTEXT_ICONS] + 12, b_info_context.x_offset + 186, y_offset + 49 + 22 * i);
                        lang_text_draw(99, 9, b_info_context.x_offset + 230, y_offset + 51 + 22 * i, FONT_NORMAL_WHITE);
                    }
                }
            } else {
                button_border_draw(b_info_context.x_offset + 80, b_info_context.y_offset + BLOCK_SIZE * b_info_context.height_blocks - 34, BLOCK_SIZE * (b_info_context.width_blocks - 10), 20, distribution_data.focus_button_id == 1 ? 1 : 0);
                lang_text_draw_centered(99, 2, b_info_context.x_offset + 80, b_info_context.y_offset + BLOCK_SIZE * b_info_context.height_blocks - 30, BLOCK_SIZE * (b_info_context.width_blocks - 10), FONT_NORMAL_BLACK);
            }
        }
    } else if (b_info_context.type == BUILDING_INFO_LEGION) {
        struct formation_t *m = &legion_formations[b_info_context.formation_id];
        if (!m->num_figures) {
            return;
        }
        for (int i = 0; i < 5; i++) {
            // for legionaries, draw tortoise formation border in first position if academy trained, skip second position
            if (m->figure_type == FIGURE_FORT_LEGIONARY) {
                if ((i == 0 && !m->has_military_training) || i == 1) {
                    continue;
                }
            }
            button_border_draw(b_info_context.x_offset + 19 + 85 * i, b_info_context.y_offset + 139, 84, 84, building_military_data.focus_button_id == i + 1);
        }

        inner_panel_draw(b_info_context.x_offset + 16, b_info_context.y_offset + 230, b_info_context.width_blocks - 2, 4);

        int title_id;
        int text_id;
        switch (building_military_data.focus_button_id) {
            case 1: // tortoise formation for legionaries, single line for aux
                if (m->figure_type == FIGURE_FORT_LEGIONARY) {
                    title_id = 12;
                    text_id = m->has_military_training ? 18 : 17;
                } else {
                    title_id = 16;
                    text_id = 22;
                }
                break;
            case 2: // skip for legionaries, single line for aux
                if (m->figure_type == FIGURE_FORT_LEGIONARY) {
                    goto default_label;
                } else {
                    title_id = 16;
                    text_id = 22;
                }
                break;
            case 3: // double line
            case 4: // double line
                title_id = 14;
                text_id = 20;
                break;
            case 5: // mop up
                title_id = 15;
                text_id = 21;
                break;
            default_label:
            default:
                // no button selected: go for formation layout
                switch (m->layout) {
                    case FORMATION_TORTOISE:
                        title_id = 12;
                        text_id = 18;
                        break;
                    case FORMATION_SINGLE_LINE_1:
                    case FORMATION_SINGLE_LINE_2:
                        title_id = 16;
                        text_id = 22;
                        break;
                    case FORMATION_DOUBLE_LINE_1:
                    case FORMATION_DOUBLE_LINE_2:
                        title_id = 14;
                        text_id = 20;
                        break;
                    case FORMATION_MOP_UP:
                        title_id = 15;
                        text_id = 21;
                        break;
                    default:
                        title_id = 16;
                        text_id = 22;
                        SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unknown formation", 0, m->layout));
                        break;
                }
                break;
        }
        // draw formation info
        lang_text_draw(138, title_id, b_info_context.x_offset + 24, b_info_context.y_offset + 236, FONT_NORMAL_WHITE);
        lang_text_draw_multiline(138, text_id, b_info_context.x_offset + 24, b_info_context.y_offset + 252, BLOCK_SIZE * (b_info_context.width_blocks - 4), FONT_NORMAL_GREEN);

        // Return to fort
        if (!m->is_at_rest && !m->in_distant_battle) {
            button_border_draw(b_info_context.x_offset + BLOCK_SIZE * (b_info_context.width_blocks - 18) / 2, b_info_context.y_offset + BLOCK_SIZE * b_info_context.height_blocks - 48, 288, 32, building_military_data.return_button_id == 1);
            lang_text_draw_centered(138, 58, b_info_context.x_offset + BLOCK_SIZE * (b_info_context.width_blocks - 18) / 2, b_info_context.y_offset + BLOCK_SIZE * b_info_context.height_blocks - 39, 288, FONT_NORMAL_BLACK);
        }
    }
    // general buttons
    if (b_info_context.storage_show_special_orders) {
        int y_offset = window_building_get_vertical_offset(&b_info_context, 28);
        image_buttons_draw(b_info_context.x_offset, y_offset + 400, image_buttons_help_close, 2);
    } else {
        image_buttons_draw(b_info_context.x_offset, b_info_context.y_offset + BLOCK_SIZE * b_info_context.height_blocks - 40,
            image_buttons_help_close, 2);
    }
    if (b_info_context.can_go_to_advisor) {
        image_buttons_draw(b_info_context.x_offset, b_info_context.y_offset + BLOCK_SIZE * b_info_context.height_blocks - 40,
            image_buttons_advisor, 1);
    }
}

static void handle_input_building_info(struct mouse_t *m, struct hotkeys_t *h)
{
    int handled = 0;
    // general buttons
    if (b_info_context.storage_show_special_orders) {
        int y_offset = window_building_get_vertical_offset(&b_info_context, 28);
        handled |= image_buttons_handle_mouse(m, b_info_context.x_offset, y_offset + 400, image_buttons_help_close, 2, &focus_image_button_id_building_info);
    } else {
        handled |= image_buttons_handle_mouse(m, b_info_context.x_offset, b_info_context.y_offset + BLOCK_SIZE * b_info_context.height_blocks - 40, image_buttons_help_close, 2, &focus_image_button_id_building_info);
    }
    if (b_info_context.can_go_to_advisor) {
        handled |= image_buttons_handle_mouse(m, b_info_context.x_offset, b_info_context.y_offset + BLOCK_SIZE * b_info_context.height_blocks - 40, image_buttons_advisor, 1, 0);
    }
    if (!handled) {
        // building-specific buttons
        if (b_info_context.type == BUILDING_INFO_LEGION) {
            building_military_data.context_for_callback = &b_info_context;
            handled = generic_buttons_handle_mouse(m, b_info_context.x_offset, b_info_context.y_offset, layout_buttons, sizeof(layout_buttons) / sizeof(struct generic_button_t), &building_military_data.focus_button_id);
            if (legion_formations[b_info_context.formation_id].figure_type == FIGURE_FORT_LEGIONARY) {
                if (building_military_data.focus_button_id == 2 || (building_military_data.focus_button_id == 1 && b_info_context.formation_types == 3)) {
                    building_military_data.focus_button_id = 0;
                }
            }
            if (!handled) {
                handled = generic_buttons_handle_mouse(m, b_info_context.x_offset + BLOCK_SIZE * (b_info_context.width_blocks - 18) / 2,
                    b_info_context.y_offset + BLOCK_SIZE * b_info_context.height_blocks - 48, return_button, 1, &building_military_data.return_button_id);
            }
            building_military_data.context_for_callback = 0;
        } else if (b_info_context.figure.drawn) {
            building_figures_data.context_for_callback = &b_info_context;
            handled = generic_buttons_handle_mouse(m, b_info_context.x_offset, b_info_context.y_offset, figure_buttons, b_info_context.figure.count, &building_figures_data.focus_button_id);
            building_figures_data.context_for_callback = 0;
        } else if (b_info_context.type == BUILDING_INFO_BUILDING) {
            int btype = all_buildings[b_info_context.building_id].type;
            if (btype == BUILDING_GRANARY) {
                if (b_info_context.storage_show_special_orders) {
                    int y_offset = window_building_get_vertical_offset(&b_info_context, 28);
                    distribution_data.building_id = b_info_context.building_id;
                    if (generic_buttons_handle_mouse(m, b_info_context.x_offset + 180, y_offset + 46,
                        orders_resource_buttons, available.food_list.size,
                        &distribution_data.resource_focus_button_id)) {
                    }
                    generic_buttons_handle_mouse(m, b_info_context.x_offset + 80, y_offset + 404, granary_order_buttons, 2, &distribution_data.orders_focus_button_id);
                } else {
                    generic_buttons_handle_mouse(m, b_info_context.x_offset + 80, b_info_context.y_offset + BLOCK_SIZE * b_info_context.height_blocks - 34, go_to_orders_button, 1, &distribution_data.focus_button_id);
                }
            } else if (btype == BUILDING_WAREHOUSE) {
                if (b_info_context.storage_show_special_orders) {
                    int y_offset = window_building_get_vertical_offset(&b_info_context, 28);
                    distribution_data.building_id = b_info_context.building_id;
                    if (generic_buttons_handle_mouse(m, b_info_context.x_offset + 180, y_offset + 46, orders_resource_buttons, available.resource_list.size,
                        &distribution_data.resource_focus_button_id)) {
                    }
                    generic_buttons_handle_mouse(m, b_info_context.x_offset + 80, y_offset + 404, warehouse_order_buttons, 3, &distribution_data.orders_focus_button_id);
                } else {
                    generic_buttons_handle_mouse(m, b_info_context.x_offset + 80, b_info_context.y_offset + BLOCK_SIZE * b_info_context.height_blocks - 34, go_to_orders_button, 1, &distribution_data.focus_button_id);
                }
            }
        }
    }
    if (m->right.went_up || h->escape_pressed) {
        window_city_show();
    }
}

static void button_start_scenario(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    if (game_file_start_scenario(cck_selection_data.selected_scenario_filename)) {
        update_music(1);
        window_mission_briefing_show();
    }
}

static struct image_button_t start_button =
{ 600, 440, 27, 27, IB_NORMAL, GROUP_SIDEBAR_BUTTONS, 56, button_start_scenario, button_none, 1, 0, 1, 0, 0, 0 };

static void button_toggle_minimap(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    cck_selection_data.show_minimap = !cck_selection_data.show_minimap;
    window_invalidate();
}

static struct generic_button_t toggle_minimap_button =
{ 570, 87, 39, 28, button_toggle_minimap, button_none, 0, 0 };

static void on_scroll_cck(void)
{
    window_invalidate();
}

static struct scrollbar_type_t scrollbar_cck = { 276, 210, 256, on_scroll_cck, 8, 1, 0, 0, 0, 0 };

static void button_select_item(int index, __attribute__((unused)) int param2)
{
    if (index >= cck_selection_data.scenarios->num_files) {
        return;
    }
    cck_selection_data.selected_item = scrollbar_cck.scroll_position + index;
    string_copy(cck_selection_data.scenarios->files[cck_selection_data.selected_item], cck_selection_data.selected_scenario_filename, FILE_NAME_MAX - 1);
    game_file_load_scenario_data(cck_selection_data.selected_scenario_filename);
    string_copy(cck_selection_data.selected_scenario_filename, cck_selection_data.selected_scenario_display, FILE_NAME_MAX - 1);
    file_remove_extension(cck_selection_data.selected_scenario_display);
    window_invalidate();
}

static struct generic_button_t file_buttons_cck[] = {
    {18, 220, 252, 16, button_select_item, button_none, 0, 0},
    {18, 236, 252, 16, button_select_item, button_none, 1, 0},
    {18, 252, 252, 16, button_select_item, button_none, 2, 0},
    {18, 268, 252, 16, button_select_item, button_none, 3, 0},
    {18, 284, 252, 16, button_select_item, button_none, 4, 0},
    {18, 300, 252, 16, button_select_item, button_none, 5, 0},
    {18, 316, 252, 16, button_select_item, button_none, 6, 0},
    {18, 332, 252, 16, button_select_item, button_none, 7, 0},
    {18, 348, 252, 16, button_select_item, button_none, 8, 0},
    {18, 364, 252, 16, button_select_item, button_none, 9, 0},
    {18, 380, 252, 16, button_select_item, button_none, 10, 0},
    {18, 396, 252, 16, button_select_item, button_none, 11, 0},
    {18, 412, 252, 16, button_select_item, button_none, 12, 0},
    {18, 428, 252, 16, button_select_item, button_none, 13, 0},
    {18, 444, 252, 16, button_select_item, button_none, 14, 0},
};

static void draw_scenario_list(void)
{
    inner_panel_draw(16, 210, 16, 16);
    char file[FILE_NAME_MAX];
    for (int i = 0; i < MAX_SCENARIOS; i++) {
        if (i >= cck_selection_data.scenarios->num_files) {
            break;
        }
        int font = FONT_NORMAL_GREEN;
        if (cck_selection_data.focus_button_id == i + 1) {
            font = FONT_NORMAL_WHITE;
        }
        string_copy(cck_selection_data.scenarios->files[i + scrollbar_cck.scroll_position], file, FILE_NAME_MAX - 1);
        file_remove_extension(file);
        text_ellipsize(file, font, 240);
        text_draw(file, 24, 220 + 16 * i, font, 0);
    }
    if (cck_selection_data.scenarios->file_overflow) {
        text_draw(too_many_files_string, 35, 186, FONT_NORMAL_PLAIN, COLOR_RED);
    }
}

static void draw_scenario_minimap_tile(int x_view, int y_view, int grid_offset)
{
    if (grid_offset < 0) {
        return;
    }

    if (terrain_grid.items[grid_offset] & TERRAIN_BUILDING) {
        // Native huts/fields
        if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
            int image_id = image_data_s.group_image_ids[GROUP_MINIMAP_BUILDING];
            switch (map_property_multi_tile_size(grid_offset)) {
                case 1: image_draw(image_id, x_view, y_view); break;
                case 2: image_draw(image_id + 1, x_view, y_view - 1); break;
            }
        }
    } else {
        int rand = random.items[grid_offset];
        struct tile_color_t *color;
        struct tile_color_set_t *set = &MINIMAP_COLOR_SETS[scenario.climate];
        if (terrain_grid.items[grid_offset] & TERRAIN_WATER) {
            color = &set->water[rand & 3];
        } else if (terrain_grid.items[grid_offset] & (TERRAIN_TREE | TERRAIN_SHRUB)) {
            color = &set->tree[rand & 3];
        } else if (terrain_grid.items[grid_offset] & (TERRAIN_ROCK | TERRAIN_ELEVATION)) {
            color = &set->rock[rand & 3];
        } else if (terrain_grid.items[grid_offset] & TERRAIN_ROAD) {
            color = &set->road;
        } else if (terrain_grid.items[grid_offset] & TERRAIN_MEADOW) {
            color = &set->meadow[rand & 3];
        } else {
            color = &set->grass[rand & 7];
        }
        graphics_draw_vertical_line(x_view, y_view, y_view, color->left);
        graphics_draw_vertical_line(x_view + 1, y_view, y_view, color->right);
    }
}

static void widget_scenario_minimap_draw(int x_offset, int y_offset, int width, int height)
{
    scenario_minimap_data.width_tiles = (width + 2) / 2;
    scenario_minimap_data.height_tiles = height;
    scenario_minimap_data.x_offset = x_offset;
    scenario_minimap_data.y_offset = y_offset;
    scenario_minimap_data.absolute_x = (VIEW_X_MAX - scenario_minimap_data.width_tiles) / 2;
    scenario_minimap_data.absolute_y = (VIEW_Y_MAX - scenario_minimap_data.height_tiles) / 2;
    // ensure even height
    scenario_minimap_data.absolute_y &= ~1;
    graphics_set_clip_rectangle(x_offset, y_offset, width, height);
    city_view_foreach_minimap_tile(
    scenario_minimap_data.x_offset, scenario_minimap_data.y_offset, scenario_minimap_data.absolute_x, scenario_minimap_data.absolute_y,
    scenario_minimap_data.width_tiles, scenario_minimap_data.height_tiles, draw_scenario_minimap_tile);
    graphics_reset_clip_rectangle();
}

static void draw_version_string(void)
{
    char version_string[100] = "Brutus v";
    int text_y = screen_data.height - 30;
    string_copy(string_from_ascii(system_version()), version_string + string_length(version_string), 99);
    int text_width = text_get_width(version_string, FONT_SMALL_PLAIN);
    if (text_y <= 500 && (screen_data.width - 640) / 2 < text_width + 18) {
        graphics_draw_rect(10, text_y, text_width + 14, 20, COLOR_BLACK);
        graphics_fill_rect(11, text_y + 1, text_width + 12, 18, COLOR_WHITE);
        text_draw(version_string, 18, text_y + 6, FONT_SMALL_PLAIN, COLOR_BLACK);
    } else {
        text_draw(version_string, 18, text_y + 6, FONT_SMALL_PLAIN, COLOR_FONT_LIGHT_GRAY);
    }
}

static void draw_background_cck(void)
{
    image_draw_fullscreen_background(image_data_s.group_image_ids[GROUP_INTERMEZZO_BACKGROUND] + 16);
    draw_version_string();
    graphics_set_clip_rectangle((screen_data.width - 640) / 2, (screen_data.height - 480) / 2, 640, 480);
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    image_draw(image_data_s.group_image_ids[GROUP_CCK_BACKGROUND], (640 - 1024) / 2, (480 - 768) / 2);
    graphics_reset_clip_rectangle();
    inner_panel_draw(280, 242, 2, 12);
    draw_scenario_list();
    int scenario_info_x = 335;
    int scenario_info_width = 280;
    int scenario_criteria_x = 420;
    button_border_draw(75, 35, 184, 144, 0);
    image_draw(image_data_s.group_image_ids[GROUP_SCENARIO_IMAGE] + scenario.brief_description_image_id, 77, 37);
    text_ellipsize(cck_selection_data.selected_scenario_display, FONT_LARGE_BLACK, scenario_info_width + 10);
    text_draw_centered(cck_selection_data.selected_scenario_display, scenario_info_x, 25, scenario_info_width + 10, FONT_LARGE_BLACK, 0);
    text_draw_centered(scenario.brief_description, scenario_info_x, 60, scenario_info_width, FONT_NORMAL_WHITE, 0);
    lang_text_draw_year(scenario.start_year, scenario_criteria_x, 90, FONT_LARGE_BLACK);

    if (cck_selection_data.show_minimap) {
        widget_scenario_minimap_draw(332, 119, 286, 300);
        // minimap button: draw mission instructions image
        image_draw(image_data_s.group_image_ids[GROUP_SIDEBAR_BRIEFING_ROTATE_BUTTONS],
            toggle_minimap_button.x + 3, toggle_minimap_button.y + 3);
    } else {
        // minimap button: draw minimap
        widget_scenario_minimap_draw(
            toggle_minimap_button.x + 3, toggle_minimap_button.y + 3,
            toggle_minimap_button.width - 6, toggle_minimap_button.height - 6
        );
        text_draw_centered(climate_types_strings[scenario.climate], scenario_info_x, 150, scenario_info_width, FONT_NORMAL_BLACK, COLOR_BLACK);
        // map size
        int text_id;
        switch (scenario.map.width) {
            case 40: text_id = 121; break;
            case 60: text_id = 122; break;
            case 80: text_id = 123; break;
            case 100: text_id = 124; break;
            case 120: text_id = 125; break;
            default: text_id = 126; break;
        }
        lang_text_draw_centered(44, text_id, scenario_info_x, 170, scenario_info_width, FONT_NORMAL_BLACK);

        // military
        int num_invasions = 0;
        for (int i = 0; i < MAX_INVASIONS; i++) {
            if (scenario.invasions[i].type) {
                num_invasions++;
            }
        }
        if (num_invasions <= 0) {
            text_id = 112;
        } else if (num_invasions <= 2) {
            text_id = 113;
        } else if (num_invasions <= 4) {
            text_id = 114;
        } else if (num_invasions <= 10) {
            text_id = 115;
        } else {
            text_id = 116;
        }
        lang_text_draw_centered(44, text_id, scenario_info_x, 190, scenario_info_width, FONT_NORMAL_BLACK);

        lang_text_draw_centered(32, 11 + scenario.player_rank,
            scenario_info_x, 210, scenario_info_width, FONT_NORMAL_BLACK);
        lang_text_draw_centered(44, 127, scenario_info_x, 262, scenario_info_width, FONT_NORMAL_BLACK);
        int width;
        if (scenario.culture_win_criteria.enabled) {
            width = text_draw_number(scenario.culture_win_criteria.goal, '@', " ",
                scenario_criteria_x, 290, FONT_NORMAL_BLACK);
            lang_text_draw(44, 129, scenario_criteria_x + width, 290, FONT_NORMAL_BLACK);
        }
        if (scenario.prosperity_win_criteria.enabled) {
            width = text_draw_number(scenario.prosperity_win_criteria.goal, '@', " ",
                scenario_criteria_x, 306, FONT_NORMAL_BLACK);
            lang_text_draw(44, 130, scenario_criteria_x + width, 306, FONT_NORMAL_BLACK);
        }
        if (scenario.peace_win_criteria.enabled) {
            width = text_draw_number(scenario.peace_win_criteria.goal, '@', " ",
                scenario_criteria_x, 322, FONT_NORMAL_BLACK);
            lang_text_draw(44, 131, scenario_criteria_x + width, 322, FONT_NORMAL_BLACK);
        }
        if (scenario.favor_win_criteria.enabled) {
            width = text_draw_number(scenario.favor_win_criteria.goal, '@', " ",
                scenario_criteria_x, 338, FONT_NORMAL_BLACK);
            lang_text_draw(44, 132, scenario_criteria_x + width, 338, FONT_NORMAL_BLACK);
        }
        if (scenario.population_win_criteria.enabled) {
            width = text_draw_number(scenario.population_win_criteria.goal, '@', " ",
                scenario_criteria_x, 354, FONT_NORMAL_BLACK);
            lang_text_draw(44, 133, scenario_criteria_x + width, 354, FONT_NORMAL_BLACK);
        }
        if (scenario.time_limit_win_criteria.enabled) {
            width = text_draw_number(scenario.time_limit_win_criteria.years, '@', " ",
                scenario_criteria_x, 370, FONT_NORMAL_BLACK);
            lang_text_draw(44, 134, scenario_criteria_x + width, 370, FONT_NORMAL_BLACK);
        }
        if (scenario.survival_time_win_criteria.enabled) {
            width = text_draw_number(scenario.survival_time_win_criteria.years, '@', " ",
                scenario_criteria_x, 386, FONT_NORMAL_BLACK);
            lang_text_draw(44, 135, scenario_criteria_x + width, 386, FONT_NORMAL_BLACK);
        }
    }
    lang_text_draw_centered(44, 136, scenario_info_x, 446, scenario_info_width, FONT_NORMAL_BLACK);
    set_translation(0, 0);
}

static void draw_foreground_cck(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    image_buttons_draw(0, 0, &start_button, 1);
    button_border_draw(
        toggle_minimap_button.x, toggle_minimap_button.y,
        toggle_minimap_button.width, toggle_minimap_button.height,
        cck_selection_data.focus_toggle_button);
    scrollbar_draw(&scrollbar_cck);
    draw_scenario_list();
    set_translation(0, 0);
}

static void handle_input_cck(struct mouse_t *m, struct hotkeys_t *h)
{
    struct mouse_t *m_dialog = mouse_in_dialog(m);
    if (scrollbar_handle_mouse(&scrollbar_cck, m_dialog)) {
        return;
    }
    if (image_buttons_handle_mouse(m_dialog, 0, 0, &start_button, 1, 0)) {
        return;
    }
    if (generic_buttons_handle_mouse(m_dialog, 0, 0, &toggle_minimap_button, 1, &cck_selection_data.focus_toggle_button)) {
        return;
    }
    if (generic_buttons_handle_mouse(m_dialog, 0, 0, file_buttons_cck, MAX_SCENARIOS, &cck_selection_data.focus_button_id)) {
        return;
    }
    if (h->enter_pressed) {
        button_start_scenario(0, 0);
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        window_main_menu_show(0);
    }
}

static void button_click_main_menu(int type, __attribute__((unused)) int param2)
{
    if (type == 1) {
        struct window_type_t window = {
            WINDOW_CCK_SELECTION,
            draw_background_cck,
            draw_foreground_cck,
            handle_input_cck,
        };
        cck_selection_data.scenarios = dir_list_files("map");
        cck_selection_data.focus_button_id = 0;
        cck_selection_data.focus_toggle_button = 0;
        cck_selection_data.show_minimap = 0;
        button_select_item(0, 0);
        scrollbar_init(&scrollbar_cck, 0, cck_selection_data.scenarios->num_files - MAX_SCENARIOS);
        window_show(&window);
    } else if (type == 2) {
        window_file_dialog_show(FILE_TYPE_SAVED_GAME, FILE_DIALOG_LOAD);
    } else if (type == 3) {
        int editor_present = 1;
        for (int i = 0; i < MAX_EDITOR_FILES; i++) {
            if (!file_exists(0, EDITOR_FILES[i])) {
                editor_present = 0;
                break;
            }
        }
        if (!editor_present) {
            window_plain_message_dialog_show("Editor not installed", "Your Caesar 3 installation does not contain the editor files.\n\
                You can download them from: https://github.com/bvschaik/julius/wiki/Editor");
        } else if (reload_language(1, 0)) {
            city_victory_reset();
            building_construction_clear_type();
            city_data_init();
            city_data_init_scenario();
            city_message_init_scenario();
            game_state_init();
            game_animation_init();
            initialize_city_sounds();
            building_clear_all();
            memset(storages, 0, MAX_STORAGES * sizeof(struct data_storage));
            figure_init_scenario();
            figure_name_init();
            reset_all_formations();
            figure_route_clear_all();
            memset(&figure_trader_data, 0, sizeof(figure_trader_data));
            game_time_init(2098);
            game_file_editor_create_scenario(2);
            if (view_data.sidebar_collapsed) {
                city_view_toggle_sidebar();
            }
            editor_active = 1;
            show_editor_map();
            update_music(1);
        }
    } else if (type == 4) {
        window_config_show();
    } else if (type == 5) {
        post_event(USER_EVENT_QUIT);
    }
}

static struct generic_button_t buttons_main_menu[] = {
    {192, 140, 256, 25, button_click_main_menu, button_none, 1, 0},
    {192, 180, 256, 25, button_click_main_menu, button_none, 2, 0},
    {192, 220, 256, 25, button_click_main_menu, button_none, 3, 0},
    {192, 260, 256, 25, button_click_main_menu, button_none, 4, 0},
    {192, 300, 256, 25, button_click_main_menu, button_none, 5, 0},
};

static void draw_background_main_menu(void)
{
    graphics_clear_screen();
    image_draw_fullscreen_background(image_data_s.group_image_ids[GROUP_INTERMEZZO_BACKGROUND] + 16);
    draw_version_string();
}

static void draw_foreground_main_menu(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    for (int i = 0; i < MAX_BUTTONS_MAIN_MENU; i++) {
        large_label_draw(buttons_main_menu[i].x, buttons_main_menu[i].y, buttons_main_menu[i].width / BLOCK_SIZE, focus_button_id_main_menu == i + 1 ? 1 : 0);
    }
    lang_text_draw_centered(30, 3, 192, 146, 256, FONT_NORMAL_GREEN);
    lang_text_draw_centered(30, 2, 192, 186, 256, FONT_NORMAL_GREEN);
    lang_text_draw_centered(9, 8, 192, 226, 256, FONT_NORMAL_GREEN);
    lang_text_draw_centered(2, 0, 192, 266, 256, FONT_NORMAL_GREEN);
    lang_text_draw_centered(30, 5, 192, 306, 256, FONT_NORMAL_GREEN);
    set_translation(0, 0);
}

static void handle_input_main_menu(struct mouse_t *m, struct hotkeys_t *h)
{
    struct mouse_t *m_dialog = mouse_in_dialog(m);
    if (generic_buttons_handle_mouse(m_dialog, 0, 0, buttons_main_menu, MAX_BUTTONS_MAIN_MENU, &focus_button_id_main_menu)) {
        return;
    }
    if (h->escape_pressed) {
        post_event(USER_EVENT_QUIT);
    }
    if (h->load_file) {
        window_file_dialog_show(FILE_TYPE_SAVED_GAME, FILE_DIALOG_LOAD);
    }
}

static void window_main_menu_show(int restart_music)
{
    if (restart_music) {
        play_intro_music();
    }
    struct window_type_t window = {
        WINDOW_MAIN_MENU,
        draw_background_main_menu,
        draw_foreground_main_menu,
        handle_input_main_menu,
    };
    window_show(&window);
}

static void stop_brief_description_box_input(void)
{
    input_box_stop(&scenario_description_input);
    if (!string_equals(scenario.brief_description, brief_description)) {
        string_copy(brief_description, scenario.brief_description, MAX_BRIEF_DESCRIPTION);
        scenario.is_saved = 0;
    }
}

static void stop_briefing_box_input(void)
{
    input_box_stop(&scenario_briefing_input);
    if (!string_equals(scenario.briefing, briefing)) {
        string_copy(briefing, scenario.briefing, MAX_BRIEFING);
        scenario.is_saved = 0;
    }
}

static void start_briefing_box_input(void)
{
    string_copy(scenario.briefing, briefing, MAX_BRIEFING);
    input_box_start(&scenario_briefing_input);
}

static void button_reset_briefing_text(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    briefing[0] = '\0';
    stop_briefing_box_input();
    rich_text_reset(0);
    start_briefing_box_input();
}

static struct generic_button_t button_reset[] = {
    {455, 540, 190, 35, button_reset_briefing_text, button_none, 0, 0}
};

static void draw_foreground_briefing(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);

    outer_panel_draw(-300, -165, 60, 4);
    input_box_draw(&scenario_briefing_input);

    outer_panel_draw(-300, -100, 60, 43);
    // Formatted typed in text
    rich_text_set_fonts(FONT_NORMAL_BLACK, FONT_NORMAL_RED, 6);
    rich_text_init(briefing, -350, -75, 60, 38, 0);
    graphics_set_clip_rectangle(-300, -100, 970, 635);
    draw_text(briefing, -260, -70, 912, 35, 0, 0);
    rich_text_data.num_lines = 0;
    scrollbar_draw(&scrollbar);
    graphics_reset_clip_rectangle();

    // @L, @P hint
    text_draw(common_editor_strings[5], -285, 550, FONT_NORMAL_PLAIN, COLOR_TOOLTIP);

    // Reset briefing
    button_border_draw(455, 540, 190, 35, focus_button_id_briefing);
    text_draw_centered("Reset briefing", 455, 545, 190, FONT_LARGE_PLAIN, COLOR_RED);

    set_translation(0, 0);
}

static void handle_input_briefing(struct mouse_t *m, struct hotkeys_t *h)
{
    struct mouse_t *m_dialog = mouse_in_dialog(m);
    if (m->right.went_up || h->escape_pressed) {
        stop_briefing_box_input();
        rich_text_reset(0);
        show_editor_attributes();
    }
    if (generic_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, button_reset, 1, &focus_button_id_briefing)) {
        return;
    }
    scrollbar_handle_mouse(&scrollbar, m_dialog);
}

static int items_in_first_list(void)
{
    return select_list_data.num_items / 2 + select_list_data.num_items % 2;
}

static void select_item_select_list(int id, int list_id)
{
    window_go_back();
    if (list_id == 0) {
        select_list_data.callback(id);
    } else {
        select_list_data.callback(id + items_in_first_list());
    }
}

static struct generic_button_t buttons_list1[MAX_ITEMS_PER_LIST] = {
    {5, 8, 190, 18, select_item_select_list, button_none, 0, 0},
    {5, 28, 190, 18, select_item_select_list, button_none, 1, 0},
    {5, 48, 190, 18, select_item_select_list, button_none, 2, 0},
    {5, 68, 190, 18, select_item_select_list, button_none, 3, 0},
    {5, 88, 190, 18, select_item_select_list, button_none, 4, 0},
    {5, 108, 190, 18, select_item_select_list, button_none, 5, 0},
    {5, 128, 190, 18, select_item_select_list, button_none, 6, 0},
    {5, 148, 190, 18, select_item_select_list, button_none, 7, 0},
    {5, 168, 190, 18, select_item_select_list, button_none, 8, 0},
    {5, 188, 190, 18, select_item_select_list, button_none, 9, 0},
    {5, 208, 190, 18, select_item_select_list, button_none, 10, 0},
    {5, 228, 190, 18, select_item_select_list, button_none, 11, 0},
    {5, 248, 190, 18, select_item_select_list, button_none, 12, 0},
    {5, 268, 190, 18, select_item_select_list, button_none, 13, 0},
    {5, 288, 190, 18, select_item_select_list, button_none, 14, 0},
    {5, 308, 190, 18, select_item_select_list, button_none, 15, 0},
    {5, 328, 190, 18, select_item_select_list, button_none, 16, 0},
    {5, 348, 190, 18, select_item_select_list, button_none, 17, 0},
    {5, 368, 190, 18, select_item_select_list, button_none, 18, 0},
    {5, 388, 190, 18, select_item_select_list, button_none, 19, 0},
};

static struct generic_button_t buttons_list2[MAX_ITEMS_PER_LIST] = {
    {205, 8, 190, 18, select_item_select_list, button_none, 0, 1},
    {205, 28, 190, 18, select_item_select_list, button_none, 1, 1},
    {205, 48, 190, 18, select_item_select_list, button_none, 2, 1},
    {205, 68, 190, 18, select_item_select_list, button_none, 3, 1},
    {205, 88, 190, 18, select_item_select_list, button_none, 4, 1},
    {205, 108, 190, 18, select_item_select_list, button_none, 5, 1},
    {205, 128, 190, 18, select_item_select_list, button_none, 6, 1},
    {205, 148, 190, 18, select_item_select_list, button_none, 7, 1},
    {205, 168, 190, 18, select_item_select_list, button_none, 8, 1},
    {205, 188, 190, 18, select_item_select_list, button_none, 9, 1},
    {205, 208, 190, 18, select_item_select_list, button_none, 10, 1},
    {205, 228, 190, 18, select_item_select_list, button_none, 11, 1},
    {205, 248, 190, 18, select_item_select_list, button_none, 12, 1},
    {205, 268, 190, 18, select_item_select_list, button_none, 13, 1},
    {205, 288, 190, 18, select_item_select_list, button_none, 14, 1},
    {205, 308, 190, 18, select_item_select_list, button_none, 15, 1},
    {205, 328, 190, 18, select_item_select_list, button_none, 16, 1},
    {205, 348, 190, 18, select_item_select_list, button_none, 17, 1},
    {205, 368, 190, 18, select_item_select_list, button_none, 18, 1},
    {205, 388, 190, 18, select_item_select_list, button_none, 19, 1},
};

static void draw_item(int item_id, int x, int y, int selected)
{
    color_t color = selected ? COLOR_FONT_BLUE : COLOR_BLACK;
    if (select_list_data.mode == MODE_GROUP) {
        lang_text_draw_centered_colored(select_list_data.group, item_id, select_list_data.x + x, select_list_data.y + y, 190, FONT_NORMAL_PLAIN, color);
    } else {
        text_draw_centered(select_list_data.items[item_id], select_list_data.x + x, select_list_data.y + y, 190, FONT_NORMAL_PLAIN, color);
    }
}

static void draw_foreground_select_list(void)
{
    if (select_list_data.num_items > MAX_ITEMS_PER_LIST) {
        int max_first = items_in_first_list();
        outer_panel_draw(select_list_data.x, select_list_data.y, 26, (20 * max_first + 24) / BLOCK_SIZE);
        for (int i = 0; i < max_first; i++) {
            draw_item(i, 5, 11 + 20 * i, i + 1 == select_list_data.focus_button_id);
        }
        for (int i = 0; i < select_list_data.num_items - max_first; i++) {
            draw_item(i + max_first, 205, 11 + 20 * i, MAX_ITEMS_PER_LIST + i + 1 == select_list_data.focus_button_id);
        }
    } else {
        outer_panel_draw(select_list_data.x, select_list_data.y, 13, (20 * select_list_data.num_items + 24) / BLOCK_SIZE);
        for (int i = 0; i < select_list_data.num_items; i++) {
            draw_item(i, 5, 11 + 20 * i, i + 1 == select_list_data.focus_button_id);
        }
    }
}

static void handle_input_select_list(struct mouse_t *m, struct hotkeys_t *h)
{
    if (select_list_data.num_items > MAX_ITEMS_PER_LIST) {
        int items_first = items_in_first_list();
        if (generic_buttons_handle_mouse(m, select_list_data.x, select_list_data.y, buttons_list1, items_first, &select_list_data.focus_button_id)) {
            return;
        }
        int second_id = 0;
        generic_buttons_handle_mouse(m, select_list_data.x, select_list_data.y, buttons_list2, select_list_data.num_items - items_first, &second_id);
        if (second_id > 0) {
            select_list_data.focus_button_id = second_id + MAX_ITEMS_PER_LIST;
        }
    } else {
        if (generic_buttons_handle_mouse(m, select_list_data.x, select_list_data.y, buttons_list1, select_list_data.num_items, &select_list_data.focus_button_id)) {
            return;
        }
    }
    if (m->right.went_up || h->escape_pressed) {
        window_go_back();
    }
}

static void window_select_list_show(int x, int y, int group, int num_items, void (*callback)(int))
{
    struct window_type_t window = {
        WINDOW_SELECT_LIST,
        window_draw_underlying_window,
        draw_foreground_select_list,
        handle_input_select_list,
    };
    select_list_data.x = x;
    select_list_data.y = y;
    select_list_data.mode = MODE_GROUP;
    select_list_data.group = group;
    select_list_data.num_items = num_items;
    select_list_data.callback = callback;
    window_show(&window);
}

static void set_hotkey(int action, int index, int key, int modifiers)
{
    // clear conflicting mappings
    for (int i = 0; i < HOTKEY_MAX_ITEMS; i++) {
        for (int j = 0; j < 2; j++) {
            if (hotkey_config_window_data.mappings[i][j].key == key && hotkey_config_window_data.mappings[i][j].modifiers == modifiers) {
                hotkey_config_window_data.mappings[i][j].key = KEY_TYPE_NONE;
                hotkey_config_window_data.mappings[i][j].modifiers = KEY_MOD_NONE;
            }
        }
    }
    // set new mapping
    hotkey_config_window_data.mappings[action][index].key = key;
    hotkey_config_window_data.mappings[action][index].modifiers = modifiers;
}

static struct generic_button_t bottom_buttons_hotkey_editor_window[] = {
    {192, 228, 120, 24, button_close_hotkey_editor_window, button_none, 0, 0},
    {328, 228, 120, 24, button_close_hotkey_editor_window, button_none, 1, 0},
};

static void draw_background_hotkey_editor_window(void)
{
    window_draw_underlying_window();
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    outer_panel_draw(128, 128, 24, 9);
    text_draw_centered(hotkey_editor_bottom_button_strings[0], 136, 144, 376, FONT_LARGE_BLACK, 0);
    for (int i = 0; i < NUM_BOTTOM_BUTTONS_HOTKEY_EDITOR_WINDOW; i++) {
        struct generic_button_t *btn = &bottom_buttons_hotkey_editor_window[i];
        text_draw_centered(hotkey_editor_bottom_button_strings[i + 1], btn->x, btn->y + 6, btn->width, FONT_NORMAL_BLACK, 0);
    }
    set_translation(0, 0);
}

static   char *key_combination_display_name(int key, int modifiers)
{
    static char result[100];
    result[0] = 0;
    if (modifiers & KEY_MOD_CTRL) {
        strcat(result, "Ctrl");
        strcat(result, " ");
    }
    if (modifiers & KEY_MOD_ALT) {
        strcat(result, "Alt");
        strcat(result, " ");
    }
    if (modifiers & KEY_MOD_GUI) {
        strcat(result, "Gui");
        strcat(result, " ");
    }
    if (modifiers & KEY_MOD_SHIFT) {
        strcat(result, "Shift");
        strcat(result, " ");
    }
    // Modifiers are easy, now for key name...
    SDL_Scancode scan_code;
    switch (key) {
        case KEY_TYPE_A: scan_code = SDL_SCANCODE_A; break;
        case KEY_TYPE_B: scan_code = SDL_SCANCODE_B; break;
        case KEY_TYPE_C: scan_code = SDL_SCANCODE_C; break;
        case KEY_TYPE_D: scan_code = SDL_SCANCODE_D; break;
        case KEY_TYPE_E: scan_code = SDL_SCANCODE_E; break;
        case KEY_TYPE_F: scan_code = SDL_SCANCODE_F; break;
        case KEY_TYPE_G: scan_code = SDL_SCANCODE_G; break;
        case KEY_TYPE_H: scan_code = SDL_SCANCODE_H; break;
        case KEY_TYPE_I: scan_code = SDL_SCANCODE_I; break;
        case KEY_TYPE_J: scan_code = SDL_SCANCODE_J; break;
        case KEY_TYPE_K: scan_code = SDL_SCANCODE_K; break;
        case KEY_TYPE_L: scan_code = SDL_SCANCODE_L; break;
        case KEY_TYPE_M: scan_code = SDL_SCANCODE_M; break;
        case KEY_TYPE_N: scan_code = SDL_SCANCODE_N; break;
        case KEY_TYPE_O: scan_code = SDL_SCANCODE_O; break;
        case KEY_TYPE_P: scan_code = SDL_SCANCODE_P; break;
        case KEY_TYPE_Q: scan_code = SDL_SCANCODE_Q; break;
        case KEY_TYPE_R: scan_code = SDL_SCANCODE_R; break;
        case KEY_TYPE_S: scan_code = SDL_SCANCODE_S; break;
        case KEY_TYPE_T: scan_code = SDL_SCANCODE_T; break;
        case KEY_TYPE_U: scan_code = SDL_SCANCODE_U; break;
        case KEY_TYPE_V: scan_code = SDL_SCANCODE_V; break;
        case KEY_TYPE_W: scan_code = SDL_SCANCODE_W; break;
        case KEY_TYPE_X: scan_code = SDL_SCANCODE_X; break;
        case KEY_TYPE_Y: scan_code = SDL_SCANCODE_Y; break;
        case KEY_TYPE_Z: scan_code = SDL_SCANCODE_Z; break;
        case KEY_TYPE_1: scan_code = SDL_SCANCODE_1; break;
        case KEY_TYPE_2: scan_code = SDL_SCANCODE_2; break;
        case KEY_TYPE_3: scan_code = SDL_SCANCODE_3; break;
        case KEY_TYPE_4: scan_code = SDL_SCANCODE_4; break;
        case KEY_TYPE_5: scan_code = SDL_SCANCODE_5; break;
        case KEY_TYPE_6: scan_code = SDL_SCANCODE_6; break;
        case KEY_TYPE_7: scan_code = SDL_SCANCODE_7; break;
        case KEY_TYPE_8: scan_code = SDL_SCANCODE_8; break;
        case KEY_TYPE_9: scan_code = SDL_SCANCODE_9; break;
        case KEY_TYPE_0: scan_code = SDL_SCANCODE_0; break;
        case KEY_TYPE_ENTER: scan_code = SDL_SCANCODE_RETURN; break;
        case KEY_TYPE_ESCAPE: scan_code = SDL_SCANCODE_ESCAPE; break;
        case KEY_TYPE_BACKSPACE: scan_code = SDL_SCANCODE_BACKSPACE; break;
        case KEY_TYPE_TAB: scan_code = SDL_SCANCODE_TAB; break;
        case KEY_TYPE_SPACE: scan_code = SDL_SCANCODE_SPACE; break;
        case KEY_TYPE_MINUS: scan_code = SDL_SCANCODE_MINUS; break;
        case KEY_TYPE_EQUALS: scan_code = SDL_SCANCODE_EQUALS; break;
        case KEY_TYPE_LEFTBRACKET: scan_code = SDL_SCANCODE_LEFTBRACKET; break;
        case KEY_TYPE_RIGHTBRACKET: scan_code = SDL_SCANCODE_RIGHTBRACKET; break;
        case KEY_TYPE_BACKSLASH: scan_code = SDL_SCANCODE_BACKSLASH; break;
        case KEY_TYPE_SEMICOLON: scan_code = SDL_SCANCODE_SEMICOLON; break;
        case KEY_TYPE_APOSTROPHE: scan_code = SDL_SCANCODE_APOSTROPHE; break;
        case KEY_TYPE_GRAVE: scan_code = SDL_SCANCODE_GRAVE; break;
        case KEY_TYPE_COMMA: scan_code = SDL_SCANCODE_COMMA; break;
        case KEY_TYPE_PERIOD: scan_code = SDL_SCANCODE_PERIOD; break;
        case KEY_TYPE_SLASH: scan_code = SDL_SCANCODE_SLASH; break;
        case KEY_TYPE_CAPSLOCK: scan_code = SDL_SCANCODE_CAPSLOCK; break;
        case KEY_TYPE_F1: scan_code = SDL_SCANCODE_F1; break;
        case KEY_TYPE_F2: scan_code = SDL_SCANCODE_F2; break;
        case KEY_TYPE_F3: scan_code = SDL_SCANCODE_F3; break;
        case KEY_TYPE_F4: scan_code = SDL_SCANCODE_F4; break;
        case KEY_TYPE_F5: scan_code = SDL_SCANCODE_F5; break;
        case KEY_TYPE_F6: scan_code = SDL_SCANCODE_F6; break;
        case KEY_TYPE_F7: scan_code = SDL_SCANCODE_F7; break;
        case KEY_TYPE_F8: scan_code = SDL_SCANCODE_F8; break;
        case KEY_TYPE_F9: scan_code = SDL_SCANCODE_F9; break;
        case KEY_TYPE_F10: scan_code = SDL_SCANCODE_F10; break;
        case KEY_TYPE_F11: scan_code = SDL_SCANCODE_F11; break;
        case KEY_TYPE_F12: scan_code = SDL_SCANCODE_F12; break;
        case KEY_TYPE_INSERT: scan_code = SDL_SCANCODE_INSERT; break;
        case KEY_TYPE_HOME: scan_code = SDL_SCANCODE_HOME; break;
        case KEY_TYPE_PAGEUP: scan_code = SDL_SCANCODE_PAGEUP; break;
        case KEY_TYPE_DELETE: scan_code = SDL_SCANCODE_DELETE; break;
        case KEY_TYPE_END: scan_code = SDL_SCANCODE_END; break;
        case KEY_TYPE_PAGEDOWN: scan_code = SDL_SCANCODE_PAGEDOWN; break;
        case KEY_TYPE_RIGHT: scan_code = SDL_SCANCODE_RIGHT; break;
        case KEY_TYPE_LEFT: scan_code = SDL_SCANCODE_LEFT; break;
        case KEY_TYPE_DOWN: scan_code = SDL_SCANCODE_DOWN; break;
        case KEY_TYPE_UP: scan_code = SDL_SCANCODE_UP; break;
        case KEY_TYPE_KP_1: scan_code = SDL_SCANCODE_KP_1; break;
        case KEY_TYPE_KP_2: scan_code = SDL_SCANCODE_KP_2; break;
        case KEY_TYPE_KP_3: scan_code = SDL_SCANCODE_KP_3; break;
        case KEY_TYPE_KP_4: scan_code = SDL_SCANCODE_KP_4; break;
        case KEY_TYPE_KP_5: scan_code = SDL_SCANCODE_KP_5; break;
        case KEY_TYPE_KP_6: scan_code = SDL_SCANCODE_KP_6; break;
        case KEY_TYPE_KP_7: scan_code = SDL_SCANCODE_KP_7; break;
        case KEY_TYPE_KP_8: scan_code = SDL_SCANCODE_KP_8; break;
        case KEY_TYPE_KP_9: scan_code = SDL_SCANCODE_KP_9; break;
        case KEY_TYPE_KP_0: scan_code = SDL_SCANCODE_KP_0; break;
        case KEY_TYPE_KP_PERIOD: scan_code = SDL_SCANCODE_KP_PERIOD; break;
        case KEY_TYPE_KP_PLUS: scan_code = SDL_SCANCODE_KP_PLUS; break;
        case KEY_TYPE_KP_MINUS: scan_code = SDL_SCANCODE_KP_MINUS; break;
        case KEY_TYPE_KP_MULTIPLY: scan_code = SDL_SCANCODE_KP_MULTIPLY; break;
        case KEY_TYPE_KP_DIVIDE: scan_code = SDL_SCANCODE_KP_DIVIDE; break;
        case KEY_TYPE_NON_US: scan_code = SDL_SCANCODE_NONUSBACKSLASH; break;
        default: scan_code = SDL_SCANCODE_UNKNOWN; break;
    }
    char *key_name = SDL_GetKeyName(SDL_GetKeyFromScancode(scan_code));
    if ((key_name[0] & 0x80) == 0) {
        // Special cases where we know the key is not displayable using the internal font
        switch (key_name[0]) {
            case '[': key_name = "Left bracket"; break;
            case ']': key_name = "Right bracket"; break;
            case '\\': key_name = "Backslash"; break;
            case '`': key_name = "Backtick"; break;
            case '~': key_name = "Tilde"; break;
            case '#': key_name = "Hash"; break;
            case '$': key_name = "Dollar"; break;
            case '&': key_name = "Ampersand"; break;
            case '<': key_name = "Less than"; break;
            case '>': key_name = "Greater than"; break;
            case '@': key_name = "At-sign"; break;
            case '^': key_name = "Caret"; break;
            case '_': key_name = "Underscore"; break;
            case '|': key_name = "Pipe"; break;
            case '{': key_name = "Left curly brace"; break;
            case '}': key_name = "Right curly brace"; break;
            case '\0': key_name = key_display_names[key];
        }
        strcat(result, key_name);
    } else if (font_letter_id(&font_data.font_definitions[FONT_NORMAL_BLACK], key_name) >= 0) {
        strcat(result, key_name);
    } else {
        strcat(result, "? (");
        strcat(result, key_display_names[key]);
        strcat(result, ")");
    }
    return result;
}

static void draw_foreground_hotkey_editor_window(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    inner_panel_draw(192, 184, 16, 2);
    text_draw_centered(key_combination_display_name(hotkey_editor_window_data.key, hotkey_editor_window_data.modifiers), 192, 193, 256, FONT_NORMAL_WHITE, 0);
    for (int i = 0; i < NUM_BOTTOM_BUTTONS_HOTKEY_EDITOR_WINDOW; i++) {
        struct generic_button_t *btn = &bottom_buttons_hotkey_editor_window[i];
        button_border_draw(btn->x, btn->y, btn->width, btn->height, hotkey_editor_window_data.focus_button == i + 1);
    }
    set_translation(0, 0);
}

static void handle_input_hotkey_editor_window(struct mouse_t *m, __attribute__((unused))   struct hotkeys_t *h)
{
    struct mouse_t *m_dialog = mouse_in_dialog(m);
    int handled = 0;
    handled |= generic_buttons_handle_mouse(m_dialog, 0, 0, bottom_buttons_hotkey_editor_window, NUM_BOTTOM_BUTTONS_HOTKEY_EDITOR_WINDOW, &hotkey_editor_window_data.focus_button);
    if (!handled && m->right.went_up) {
        button_close_hotkey_editor_window(0, 0);
    }
}

static void on_scroll_hotkey_config_window(void)
{
    window_invalidate();
}

static struct scrollbar_type_t scrollbar_hotkey_config_window = { 580, 72, 352, on_scroll_hotkey_config_window, 0, 0, 0, 0, 0, 0 };

static void button_hotkey(int row, int is_alternative)
{
    struct hotkey_widget_t *widget = &hotkey_widgets[row + scrollbar_hotkey_config_window.scroll_position];
    if (widget->action == HOTKEY_HEADER) {
        return;
    }
    struct window_type_t window = {
    WINDOW_HOTKEY_EDITOR,
    draw_background_hotkey_editor_window,
    draw_foreground_hotkey_editor_window,
    handle_input_hotkey_editor_window,
    };
    hotkey_editor_window_data.action = widget->action;
    hotkey_editor_window_data.index = is_alternative;
    hotkey_editor_window_data.callback = set_hotkey;
    hotkey_editor_window_data.key = KEY_TYPE_NONE;
    hotkey_editor_window_data.modifiers = KEY_MOD_NONE;
    hotkey_editor_window_data.focus_button = 0;
    window_show(&window);
}

static struct generic_button_t hotkey_buttons[] = {
    {HOTKEY_X_OFFSET_1, 80 + 24 * 0, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 0, 0},
    {HOTKEY_X_OFFSET_2, 80 + 24 * 0, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 0, 1},
    {HOTKEY_X_OFFSET_1, 80 + 24 * 1, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 1, 0},
    {HOTKEY_X_OFFSET_2, 80 + 24 * 1, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 1, 1},
    {HOTKEY_X_OFFSET_1, 80 + 24 * 2, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 2, 0},
    {HOTKEY_X_OFFSET_2, 80 + 24 * 2, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 2, 1},
    {HOTKEY_X_OFFSET_1, 80 + 24 * 3, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 3, 0},
    {HOTKEY_X_OFFSET_2, 80 + 24 * 3, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 3, 1},
    {HOTKEY_X_OFFSET_1, 80 + 24 * 4, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 4, 0},
    {HOTKEY_X_OFFSET_2, 80 + 24 * 4, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 4, 1},
    {HOTKEY_X_OFFSET_1, 80 + 24 * 5, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 5, 0},
    {HOTKEY_X_OFFSET_2, 80 + 24 * 5, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 5, 1},
    {HOTKEY_X_OFFSET_1, 80 + 24 * 6, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 6, 0},
    {HOTKEY_X_OFFSET_2, 80 + 24 * 6, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 6, 1},
    {HOTKEY_X_OFFSET_1, 80 + 24 * 7, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 7, 0},
    {HOTKEY_X_OFFSET_2, 80 + 24 * 7, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 7, 1},
    {HOTKEY_X_OFFSET_1, 80 + 24 * 8, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 8, 0},
    {HOTKEY_X_OFFSET_2, 80 + 24 * 8, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 8, 1},
    {HOTKEY_X_OFFSET_1, 80 + 24 * 9, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 9, 0},
    {HOTKEY_X_OFFSET_2, 80 + 24 * 9, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 9, 1},
    {HOTKEY_X_OFFSET_1, 80 + 24 * 10, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 10, 0},
    {HOTKEY_X_OFFSET_2, 80 + 24 * 10, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 10, 1},
    {HOTKEY_X_OFFSET_1, 80 + 24 * 11, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 11, 0},
    {HOTKEY_X_OFFSET_2, 80 + 24 * 11, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 11, 1},
    {HOTKEY_X_OFFSET_1, 80 + 24 * 12, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 12, 0},
    {HOTKEY_X_OFFSET_2, 80 + 24 * 12, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 12, 1},
    {HOTKEY_X_OFFSET_1, 80 + 24 * 13, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 13, 0},
    {HOTKEY_X_OFFSET_2, 80 + 24 * 13, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT, button_hotkey, button_none, 13, 1},
};

static void button_reset_defaults_hotkey_config_window(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    for (int action = 0; action < HOTKEY_MAX_ITEMS; action++) {
        for (int index = 0; index < 2; index++) {
            if (index < 0 || index >= 2 || (int) action < 0 || action >= HOTKEY_MAX_ITEMS) {
                continue;
            } else {
                hotkey_config_window_data.mappings[action][index] = hotkey_config_data.default_mappings[action][index];
            }
        }
    }
    window_invalidate();
}

static void button_close_hotkey_config_window(int save, __attribute__((unused)) int param2)
{
    if (!save) {
        window_go_back();
        return;
    }
    hotkey_config_data.num_mappings = 0;
    for (int action = 0; action < HOTKEY_MAX_ITEMS; action++) {
        for (int index = 0; index < 2; index++) {
            if (hotkey_config_window_data.mappings[action][index].key != KEY_TYPE_NONE) {
                hotkey_config_add_mapping(&hotkey_config_window_data.mappings[action][index]);
            }
        }
    }
    hotkey_install_mapping(hotkey_config_data.mappings, hotkey_config_data.num_mappings);
    FILE *fp = fopen(HOTKEY_CONFIGS_FILE_PATH, "wt");
    if (!fp) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to write hotkey configuration file", HOTKEY_CONFIGS_FILE_PATH, 0));
        return;
    }
    for (int i = 0; i < hotkey_config_data.num_mappings; i++) {
        static char name[100];
        name[0] = 0;
        for (struct modifier_name_t *modname = modifier_names; modname->modifier; modname++) {
            if (hotkey_config_data.mappings[i].modifiers & modname->modifier) {
                strcat(name, modname->name);
                strcat(name, " ");
            }
        }
        strcat(name, key_names[hotkey_config_data.mappings[i].key]);
        fprintf(fp, "%s=%s\n", ini_keys_hotkey_config[hotkey_config_data.mappings[i].action], name);
    }
    fclose(fp);
    window_go_back();
}

static struct generic_button_t bottom_buttons_hotkey_config_window[] = {
    {230, 430, 180, 30, button_reset_defaults_hotkey_config_window, button_none, 0, 0},
    {415, 430, 100, 30, button_close_hotkey_config_window, button_none, 0, 0},
    {520, 430, 100, 30, button_close_hotkey_config_window, button_none, 1, 0},
};

static void draw_background_hotkey_config_window(void)
{
    graphics_clear_screen();
    image_draw_fullscreen_background(image_data_s.group_image_ids[GROUP_INTERMEZZO_BACKGROUND] + 16);
    draw_version_string();
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    outer_panel_draw(0, 0, 40, 30);
    text_draw_centered(hotkey_strings[0], 16, 16, 608, FONT_LARGE_BLACK, 0);
    text_draw_centered(hotkey_strings[1], HOTKEY_X_OFFSET_1, 55, HOTKEY_BTN_WIDTH, FONT_NORMAL_BLACK, 0);
    text_draw_centered(hotkey_strings[2], HOTKEY_X_OFFSET_2, 55, HOTKEY_BTN_WIDTH, FONT_NORMAL_BLACK, 0);
    inner_panel_draw(20, 72, 35, 22);
    int y_base = 80;
    for (int i = 0; i < NUM_VISIBLE_OPTIONS; i++) {
        int current_pos = i + scrollbar_hotkey_config_window.scroll_position;
        struct hotkey_widget_t *widget = &hotkey_widgets[current_pos];
        int text_offset = y_base + 6 + 24 * i;
        if (current_pos == 0 || current_pos == 5 || current_pos == 12 || current_pos == 25
        || current_pos == 31 || current_pos == 40 || current_pos == 42 || current_pos == 46) { // headers
            text_draw(hotkey_widget_strings[current_pos], 32, text_offset, FONT_NORMAL_WHITE, 0);
        } else {
            if (current_pos <= 51) { // number of entries in hotkey_widget_strings
                text_draw(hotkey_widget_strings[current_pos], 32, text_offset, FONT_NORMAL_GREEN, 0);
            } else {
                int building_index = align_bulding_type_index_to_strings(current_pos - 50);
                text_draw(all_buildings_strings[building_index], 32, text_offset, FONT_NORMAL_GREEN, 0); // reuse building strings
            }
            struct hotkey_mapping_t *mapping1 = &hotkey_config_window_data.mappings[widget->action][0];
            if (mapping1->key) {
                char *keyname = key_combination_display_name(mapping1->key, mapping1->modifiers);
                graphics_set_clip_rectangle(HOTKEY_X_OFFSET_1, text_offset, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT);
                text_draw_centered(keyname, HOTKEY_X_OFFSET_1 + 3, text_offset, HOTKEY_BTN_WIDTH - 6, FONT_NORMAL_WHITE, 0);
                graphics_reset_clip_rectangle();
            }
            struct hotkey_mapping_t *mapping2 = &hotkey_config_window_data.mappings[widget->action][1];
            if (mapping2->key) {
                graphics_set_clip_rectangle(HOTKEY_X_OFFSET_2, text_offset, HOTKEY_BTN_WIDTH, HOTKEY_BTN_HEIGHT);
                char *keyname = key_combination_display_name(mapping2->key, mapping2->modifiers);
                text_draw_centered(keyname, HOTKEY_X_OFFSET_2 + 3, text_offset, HOTKEY_BTN_WIDTH - 6, FONT_NORMAL_WHITE, 0);
                graphics_reset_clip_rectangle();
            }
        }
    }
    for (int i = 0; i < NUM_BOTTOM_BUTTONS_HOTKEY_CONFIG_WINDOW; i++) {
        text_draw_centered(hotkey_strings[i + 3], bottom_buttons_hotkey_config_window[i].x, bottom_buttons_hotkey_config_window[i].y + 9, bottom_buttons_hotkey_config_window[i].width, FONT_NORMAL_BLACK, 0);
    }
    set_translation(0, 0);
}

static void draw_foreground_hotkey_config_window(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    scrollbar_draw(&scrollbar_hotkey_config_window);
    for (int i = 0; i < NUM_VISIBLE_OPTIONS; i++) {
        struct hotkey_widget_t *widget = &hotkey_widgets[i + scrollbar_hotkey_config_window.scroll_position];
        if (widget->action != HOTKEY_HEADER) {
            struct generic_button_t *btn = &hotkey_buttons[2 * i];
            button_border_draw(btn->x, btn->y, btn->width, btn->height, hotkey_config_window_data.focus_button == 1 + 2 * i);
            btn++;
            button_border_draw(btn->x, btn->y, btn->width, btn->height, hotkey_config_window_data.focus_button == 2 + 2 * i);
        }
    }
    for (int i = 0; i < NUM_BOTTOM_BUTTONS_HOTKEY_CONFIG_WINDOW; i++) {
        button_border_draw(bottom_buttons_hotkey_config_window[i].x, bottom_buttons_hotkey_config_window[i].y,
            bottom_buttons_hotkey_config_window[i].width, bottom_buttons_hotkey_config_window[i].height,
            hotkey_config_window_data.bottom_focus_button == i + 1);
    }
    set_translation(0, 0);
}

static void handle_input_hotkey_config_window(struct mouse_t *m, struct hotkeys_t *h)
{
    struct mouse_t *m_dialog = mouse_in_dialog(m);
    if (scrollbar_handle_mouse(&scrollbar_hotkey_config_window, m_dialog)) {
        return;
    }
    int handled = 0;
    handled |= generic_buttons_handle_mouse(m_dialog, 0, 0,
        hotkey_buttons, NUM_VISIBLE_OPTIONS * 2, &hotkey_config_window_data.focus_button);
    handled |= generic_buttons_handle_mouse(m_dialog, 0, 0,
        bottom_buttons_hotkey_config_window, NUM_BOTTOM_BUTTONS_HOTKEY_CONFIG_WINDOW, &hotkey_config_window_data.bottom_focus_button);
    if (!handled && (m->right.went_up || h->escape_pressed)) {
        window_config_show();
    }
}

static   struct hotkey_mapping_t *hotkey_for_action(int action, int index)
{
    int num = 0;
    for (int i = 0; i < hotkey_config_data.num_mappings; i++) {
        if (hotkey_config_data.mappings[i].action == action) {
            if (num == index) {
                return &hotkey_config_data.mappings[i];
            }
            num++;
        }
    }
    return 0;
}

static void button_hotkeys(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    struct window_type_t window = {
        WINDOW_HOTKEY_CONFIG,
        draw_background_hotkey_config_window,
        draw_foreground_hotkey_config_window,
        handle_input_hotkey_config_window,
    };
    scrollbar_init(&scrollbar_hotkey_config_window, 0, sizeof(hotkey_widgets) / sizeof(struct hotkey_widget_t) - NUM_VISIBLE_OPTIONS);
    for (int i = 0; i < HOTKEY_MAX_ITEMS; i++) {
        struct hotkey_mapping_t empty = { KEY_TYPE_NONE, KEY_MOD_NONE, i };
        struct hotkey_mapping_t *mapping = hotkey_for_action(i, 0);
        hotkey_config_window_data.mappings[i][0] = mapping ? *mapping : empty;
        mapping = hotkey_for_action(i, 1);
        hotkey_config_window_data.mappings[i][1] = mapping ? *mapping : empty;
    }
    window_show(&window);
}

static void button_reset_defaults_window_config(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    for (int i = 0; i < CONFIG_MAX_ENTRIES; ++i) {
        window_config_data.config_values[i].new_value = default_values[i];
    }
    for (int i = 0; i < CONFIG_STRING_MAX_ENTRIES; ++i) {
        string_copy(default_string_values[i], window_config_data.config_string_values[i].new_value, CONFIG_STRING_VALUE_MAX - 1);
    }
    window_invalidate();
}

static void button_close_window_config(int save, __attribute__((unused)) int param2)
{
    if (!save) {
        for (int i = 0; i < CONFIG_MAX_ENTRIES; i++) {
            window_config_data.config_values[i].new_value = window_config_data.config_values[i].original_value;
        }
        for (int i = 0; i < CONFIG_STRING_MAX_ENTRIES; i++) {
            // memcpy required to fix warning on Switch build
            memcpy(window_config_data.config_string_values[i].new_value,
                window_config_data.config_string_values[i].original_value, CONFIG_STRING_VALUE_MAX - 1);
        }
        window_main_menu_show(0);
        return;
    }
    int apply_changed_configs = 1;
    for (int i = 0; i < CONFIG_MAX_ENTRIES; ++i) {
        if (window_config_data.config_values[i].original_value != window_config_data.config_values[i].new_value) {
            if (!window_config_data.config_values[i].change_action(i)) {
                apply_changed_configs = 0;
                break;
            }
        }
    }
    if (apply_changed_configs) {
        for (int i = 0; i < CONFIG_STRING_MAX_ENTRIES; ++i) {
            if (!string_equals(window_config_data.config_string_values[i].original_value, window_config_data.config_string_values[i].new_value)) {
                if (!window_config_data.config_string_values[i].change_action(i)) {
                    apply_changed_configs = 0;
                    break;
                }
            }
        }
    }
    if (apply_changed_configs) {
        input_box_stop(&player_name_input);
        string_copy(window_config_data.config_string_values[CONFIG_STRING_PLAYER_NAME].new_value, scenario_settings.player_name, MAX_PLAYER_NAME);
    }
    config_save();
    window_main_menu_show(0);
}

static struct generic_button_t bottom_buttons_window_config[NUM_BOTTOM_BUTTONS_WINDOW_CONFIG] = {
    {20, 480, 180, 30, button_hotkeys, button_none, 0, 0},
    {230, 480, 180, 30, button_reset_defaults_window_config, button_none, 0, 0},
    {415, 480, 100, 30, button_close_window_config, button_none, 0, 0},
    {520, 480, 100, 30, button_close_window_config, button_none, 1, 0},
};

static void on_scroll_window_config(void)
{
    window_invalidate();
}

static struct scrollbar_type_t scrollbar_window_config = { 580, ITEM_Y_OFFSET, ITEM_HEIGHT * NUM_VISIBLE_ITEMS, on_scroll_window_config, 4, 0, 0, 0, 0, 0 };

static void draw_background_window_config(void)
{
    int width, height;
    SDL_GetWindowSize(SDL.window, &width, &height);
    int max_scale = get_max_scale_percentage(width, height);
    scale_ranges[RANGE_DISPLAY_SCALE].max = max_scale;
    if (*scale_ranges[RANGE_DISPLAY_SCALE].value > max_scale) {
        *scale_ranges[RANGE_DISPLAY_SCALE].value = max_scale;
    }
    graphics_clear_screen();
    image_draw_fullscreen_background(image_data_s.group_image_ids[GROUP_INTERMEZZO_BACKGROUND] + 16);
    draw_version_string();
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    outer_panel_draw(0, 0, 40, 33);
    text_draw_centered("Brutus configuration options", 16, 16, 608, FONT_LARGE_BLACK, 0);
    int drawn = 0;
    for (int i = 0; i < NUM_VISIBLE_ITEMS && i < window_config_data.num_widgets; i++) {
        struct config_widget_t *w = window_config_data.widgets[i + scrollbar_window_config.scroll_position];
        int y = ITEM_Y_OFFSET + ITEM_HEIGHT * i;
        if (w->type == TYPE_HEADER) {
            text_draw(config_widget_strings[drawn + scrollbar_window_config.scroll_position], 20, y, FONT_NORMAL_BLACK, 0);
            drawn++;
        } else if (w->type == TYPE_CHECKBOX) {
            if (window_config_data.config_values[w->subtype].new_value) {
                text_draw(string_from_ascii("x"), 20 + 6, y + 3, FONT_NORMAL_BLACK, 0);
            }
            static char buffer[1000];
            string_copy(config_widget_strings[drawn + scrollbar_window_config.scroll_position], buffer, 1000);
            text_ellipsize(buffer, FONT_NORMAL_BLACK, CHECKBOX_TEXT_WIDTH);
            text_draw(buffer, 50, y + 5, FONT_NORMAL_BLACK, 0);
            drawn++;
        } else if (w->type == TYPE_INPUT_BOX) {
            text_draw(config_widget_strings[drawn + scrollbar_window_config.scroll_position], 20, y + 6, FONT_NORMAL_BLACK, 0);
            drawn++;
        } else if (w->type == TYPE_NUMERICAL_RANGE) {
            struct numerical_range_widget_t *ww = &scale_ranges[w->subtype];
            text_draw(w->get_display_text(), NUMERICAL_RANGE_X, y + 6, FONT_NORMAL_BLACK, 0);
            inner_panel_draw(NUMERICAL_RANGE_X + NUMERICAL_SLIDER_X, y + 4, ww->width_blocks, 1);
            width = ww->width_blocks * BLOCK_SIZE - NUMERICAL_SLIDER_PADDING * 2 - NUMERICAL_DOT_SIZE;
            int scroll_position = (*ww->value - ww->min) * width / (ww->max - ww->min);
            image_draw(image_data_s.group_image_ids[GROUP_PANEL_BUTTON] + 37, NUMERICAL_RANGE_X + NUMERICAL_SLIDER_X + NUMERICAL_SLIDER_PADDING + scroll_position, y + 2);
        } else if (w->type == TYPE_NUMERICAL_DESC) {
            text_draw(config_widget_strings[drawn + scrollbar_window_config.scroll_position], 20, y + 10, FONT_NORMAL_BLACK, 0);
            drawn++;
        }
    }

    for (int i = 0; i < NUM_BOTTOM_BUTTONS_WINDOW_CONFIG; i++) {
        text_draw_centered(config_bottom_button_strings[i], bottom_buttons_window_config[i].x, bottom_buttons_window_config[i].y + 9, bottom_buttons_window_config[i].width, FONT_NORMAL_BLACK, 0);
    }

    set_translation(0, 0);
}

static void draw_foreground_window_config(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);

    for (int i = 0; i < NUM_VISIBLE_ITEMS && i < window_config_data.num_widgets; i++) {
        struct config_widget_t *w = window_config_data.widgets[i + scrollbar_window_config.scroll_position];
        int y = ITEM_Y_OFFSET + ITEM_HEIGHT * i;
        if (w->type == TYPE_CHECKBOX) {
            button_border_draw(20, y, CHECKBOX_CHECK_SIZE, CHECKBOX_CHECK_SIZE, window_config_data.focus_button == i + 1);
        } else if (w->type == TYPE_INPUT_BOX) {
            input_box_draw(&player_name_input);
        }
    }

    for (int i = 0; i < NUM_BOTTOM_BUTTONS_WINDOW_CONFIG; i++) {
        button_border_draw(bottom_buttons_window_config[i].x, bottom_buttons_window_config[i].y,
            bottom_buttons_window_config[i].width, bottom_buttons_window_config[i].height, window_config_data.bottom_focus_button == i + 1);
    }

    if (window_config_data.num_widgets > NUM_VISIBLE_ITEMS) {
        inner_panel_draw(scrollbar_window_config.x + 4, scrollbar_window_config.y + 28, 2, scrollbar_window_config.height / BLOCK_SIZE - 3);
        scrollbar_draw(&scrollbar_window_config);
    }

    set_translation(0, 0);
}

static int input_box_is_mouse_inside_input(struct mouse_t *m, struct input_box_t *box)
{
    return m->x >= box->x && m->x < box->x + box->width_blocks * BLOCK_SIZE &&
        m->y >= box->y && m->y < box->y + box->height_blocks * BLOCK_SIZE;
}

static int numerical_range_handle_mouse(struct mouse_t *m, int x, int y, int numerical_range_id)
{
    struct numerical_range_widget_t *w = &scale_ranges[numerical_range_id - 1];
    int is_numerical_range = 0;
    if (x + NUMERICAL_SLIDER_X <= m->x && x + w->width_blocks * BLOCK_SIZE + NUMERICAL_SLIDER_X >= m->x && y <= m->y && y + 16 > m->y) {
        is_numerical_range = 1;
    }
    if (window_config_data.active_numerical_range) {
        if (window_config_data.active_numerical_range != numerical_range_id) {
            return 0;
        }
        if (!m->left.is_down) {
            window_config_data.active_numerical_range = 0;
            return 0;
        }
    } else if (!m->left.went_down
    || !is_numerical_range) {
        return 0;
    }
    int slider_width = w->width_blocks * BLOCK_SIZE - NUMERICAL_SLIDER_PADDING * 2 - NUMERICAL_DOT_SIZE;
    int pixels_per_pct = slider_width / (w->max - w->min);
    int dot_position = m->x - x - NUMERICAL_SLIDER_X - NUMERICAL_DOT_SIZE / 2 + pixels_per_pct / 2;

    int exact_value = calc_bound(w->min + dot_position * (w->max - w->min) / slider_width, w->min, w->max);
    int left_step_value = (exact_value / w->step) * w->step;
    int right_step_value = calc_bound(left_step_value + w->step, w->min, w->max);
    int closest_step_value = (exact_value - left_step_value) < (right_step_value - exact_value) ?
        left_step_value : right_step_value;
    if (closest_step_value != *w->value) {
        *w->value = closest_step_value;
        window_data.refresh_on_draw = 1;
    }
    window_config_data.active_numerical_range = numerical_range_id;
    return 1;
}

static void handle_input_window_config(struct mouse_t *m, struct hotkeys_t *h)
{
    struct mouse_t *m_dialog = mouse_in_dialog(m);
    if (window_config_data.active_numerical_range) {
        numerical_range_handle_mouse(m_dialog, NUMERICAL_RANGE_X, 0, window_config_data.active_numerical_range);
        return;
    }
    if (scrollbar_handle_mouse(&scrollbar_window_config, m_dialog)) {
        return;
    }

    if (m->left.went_up && input_box_is_mouse_inside_input(m_dialog, &player_name_input)) {
        input_box_start(&player_name_input);
    }
    if (m->left.went_up && !input_box_is_mouse_inside_input(m_dialog, &player_name_input)) {
        input_box_stop(&player_name_input);
        string_copy(window_config_data.config_string_values[CONFIG_STRING_PLAYER_NAME].new_value, scenario_settings.player_name, MAX_PLAYER_NAME);
    }

    int handled = 0;
    window_config_data.focus_button = 0;

    for (int i = 0; i < NUM_VISIBLE_ITEMS && i < window_config_data.num_widgets; i++) {
        struct config_widget_t *w = window_config_data.widgets[i + scrollbar_window_config.scroll_position];
        int y = ITEM_Y_OFFSET + ITEM_HEIGHT * i;
        if (w->type == TYPE_CHECKBOX) {
            int focus = 0;
            if (20 <= m_dialog->x && 20 + CHECKBOX_WIDTH > m_dialog->x && y <= m_dialog->y && y + CHECKBOX_HEIGHT > m_dialog->y) {
                focus = 1;
                if (m_dialog->left.went_up) {
                    window_config_data.config_values[w->subtype].new_value = 1 - window_config_data.config_values[w->subtype].new_value;
                    window_invalidate();
                    handled |= 1;
                } else {
                    handled |= 0;
                }
            }
            if (focus) {
                window_config_data.focus_button = i + 1;
            }
        } else if (w->type == TYPE_NUMERICAL_RANGE) {
            handled |= numerical_range_handle_mouse(m_dialog, NUMERICAL_RANGE_X, y, w->subtype + 1);
        }
    }

    handled |= generic_buttons_handle_mouse(m_dialog, 0, 0,
        bottom_buttons_window_config, NUM_BOTTOM_BUTTONS_WINDOW_CONFIG, &window_config_data.bottom_focus_button);

    if (!handled && (m->right.went_up || h->escape_pressed)) {
        window_main_menu_show(0);
    }
}

static int config_change_string_basic(int key)
{
    string_copy(window_config_data.config_string_values[key].new_value, string_values[key], CONFIG_STRING_VALUE_MAX - 1);
    string_copy(window_config_data.config_string_values[key].new_value, window_config_data.config_string_values[key].original_value, CONFIG_STRING_VALUE_MAX - 1);
    return 1;
}

static int config_change_basic(int key)
{
    values[key] = window_config_data.config_values[key].new_value;
    window_config_data.config_values[key].original_value = window_config_data.config_values[key].new_value;
    return 1;
}

static int config_change_display_scale(int key)
{
    int width, height;
    SDL_GetWindowSize(SDL.window, &width, &height);
    set_scale_percentage(window_config_data.config_values[key].new_value, width, height);
    resize_screen(width, height);
    window_config_data.config_values[key].new_value = scale_percentage;
    config_change_basic(key);
    return 1;
}

static int config_change_cursor_scale(int key)
{
    config_change_basic(key);
    init_cursors(window_config_data.config_values[key].new_value);
    return 1;
}

static char *percentage_string(char *string, int percentage)
{
    int offset = string_from_int(string, percentage, 0);
    string[offset] = '%';
    string[offset + 1] = 0;
    return string;
}

static   char *display_text_display_scale(void)
{
    static char value[10];
    return percentage_string(value, window_config_data.config_values[CONFIG_SCREEN_DISPLAY_SCALE].new_value);
}

static   char *display_text_cursor_scale(void)
{
    static char value[10];
    return percentage_string(value, window_config_data.config_values[CONFIG_SCREEN_CURSOR_SCALE].new_value);
}

static struct config_widget_t all_widgets[MAX_WIDGETS] = {
    {TYPE_INPUT_BOX, 0, 0, 0},
    {TYPE_NUMERICAL_DESC, RANGE_DISPLAY_SCALE, 0, 0},
    {TYPE_NUMERICAL_RANGE, RANGE_DISPLAY_SCALE, display_text_display_scale, 0},
    {TYPE_NUMERICAL_DESC, RANGE_CURSOR_SCALE, 0, 0},
    {TYPE_NUMERICAL_RANGE, RANGE_CURSOR_SCALE, display_text_cursor_scale, 0},
    {TYPE_SPACE, 0, 0, 0},
    {TYPE_HEADER, 0, 0, 0},
    {TYPE_CHECKBOX, CONFIG_UI_SIDEBAR_INFO, 0, 0},
    {TYPE_CHECKBOX, CONFIG_UI_SHOW_INTRO_VIDEO, 0, 0},
    {TYPE_CHECKBOX, CONFIG_UI_DISABLE_MOUSE_EDGE_SCROLLING, 0, 0},
    {TYPE_CHECKBOX, CONFIG_UI_DISABLE_RIGHT_CLICK_MAP_DRAG, 0, 0},
    {TYPE_CHECKBOX, CONFIG_UI_VISUAL_FEEDBACK_ON_DELETE, 0, 0},
    {TYPE_CHECKBOX, CONFIG_UI_HIGHLIGHT_LEGIONS, 0, 0},
};

static void window_config_show(void)
{
    struct window_type_t window = {
        WINDOW_CONFIG,
        draw_background_window_config,
        draw_foreground_window_config,
        handle_input_window_config,
    };
    if (!window_config_data.config_values[0].change_action) {
        for (int i = 0; i < CONFIG_MAX_ENTRIES; ++i) {
            window_config_data.config_values[i].change_action = config_change_basic;
        }
        for (int i = 0; i < CONFIG_STRING_MAX_ENTRIES; ++i) {
            window_config_data.config_string_values[i].change_action = config_change_string_basic;
        }
        window_config_data.config_values[CONFIG_SCREEN_DISPLAY_SCALE].change_action = config_change_display_scale;
        window_config_data.config_values[CONFIG_SCREEN_CURSOR_SCALE].change_action = config_change_cursor_scale;
        scale_ranges[RANGE_DISPLAY_SCALE].value = &window_config_data.config_values[CONFIG_SCREEN_DISPLAY_SCALE].new_value;
        scale_ranges[RANGE_CURSOR_SCALE].value = &window_config_data.config_values[CONFIG_SCREEN_CURSOR_SCALE].new_value;
    }
    for (int i = 0; i < CONFIG_MAX_ENTRIES; i++) {
        window_config_data.config_values[i].original_value = values[i];
        window_config_data.config_values[i].new_value = values[i];
    }
    for (int i = 0; i < CONFIG_STRING_MAX_ENTRIES; i++) {
        char *value = string_values[i];
        string_copy(value, window_config_data.config_string_values[i].original_value, CONFIG_STRING_VALUE_MAX - 1);
        string_copy(value, window_config_data.config_string_values[i].new_value, CONFIG_STRING_VALUE_MAX - 1);
    }
    for (int i = 0; i < MAX_WIDGETS; i++) {
        if (all_widgets[i].type) {
            all_widgets[i].enabled = 1;
        }
    }
    window_config_data.num_widgets = 0;
    for (int i = 0; i < MAX_WIDGETS; i++) {
        if (all_widgets[i].enabled) {
            window_config_data.widgets[window_config_data.num_widgets++] = &all_widgets[i];
        }
    }
    scrollbar_init(&scrollbar_window_config, 0, window_config_data.num_widgets - NUM_VISIBLE_ITEMS);
    window_show(&window);
}

static void show_editor_briefing(void)
{
    struct window_type_t window = {
        WINDOW_EDITOR_BRIEFING,
        window_editor_map_draw_all,
        draw_foreground_briefing,
        handle_input_briefing,
    };
    start_briefing_box_input();
    window_show(&window);
}

static void button_briefing(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    stop_brief_description_box_input();
    show_editor_briefing();
}

static void change_climate(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.climate++;
    if (scenario.climate > 2) {
        scenario.climate = 0;
    }
    scenario.is_saved = 0;
    image_load_climate(scenario.climate, 1, 0);
    minimap_data.refresh_requested = 1;
    window_data.refresh_on_draw = 1;
}

static void set_player_rank(int rank)
{
    scenario.player_rank = rank;
    scenario.is_saved = 0;
}

static void button_rank(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_select_list_show(screen_data.dialog_offset.x + 462, screen_data.dialog_offset.y - 55, 32, 11, set_player_rank);
}

static void set_start_year(int year)
{
    scenario.start_year = year;
    scenario.is_saved = 0;
}

static void button_era_start_year(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    set_start_year(-scenario.start_year);
}

static void set_year_start_year(int value)
{
    if (scenario.start_year < 0) {
        value = -value;
    }
    set_start_year(value);
}

static void button_year_start_year(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 140, screen_data.dialog_offset.y + 80, 4, 9999, set_year_start_year);
}

static struct generic_button_t buttons_start_year[] = {
    {158, 100, 100, 30, button_era_start_year, button_none, 0, 0},
    {278, 100, 120, 30, button_year_start_year, button_none, 0, 0},
};

static void draw_foreground_start_year(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);

    outer_panel_draw(128, 44, 19, 7);

    lang_text_draw_centered(44, 13, 128, 60, 304, FONT_LARGE_BLACK);

    int start_year = scenario.start_year;
    button_border_draw(158, 100, 100, 30, focus_button_id_start_year == 1);
    lang_text_draw_centered(20, start_year >= 0 ? 1 : 0, 158, 110, 100, FONT_NORMAL_BLACK);

    button_border_draw(278, 100, 120, 30, focus_button_id_start_year == 2);
    text_draw_number_centered(start_year >= 0 ? start_year : -start_year, 278, 110, 120, FONT_NORMAL_BLACK);

    set_translation(0, 0);
}

static void draw_foreground_starting_conditions(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    outer_panel_draw(0, 0, 30, 24);
    lang_text_draw_centered(44, 88, 0, 16, 480, FONT_LARGE_BLACK);
    // Initial rank
    lang_text_draw(44, 108, 32, 57, FONT_NORMAL_BLACK);
    button_border_draw(262, 48, 200, 30, focus_button_id_starting_conditions == 1);
    lang_text_draw_centered(32, scenario.player_rank, 262, 57, 200, FONT_NORMAL_BLACK);
    // Adjust the start date
    lang_text_draw(44, 89, 32, 97, FONT_NORMAL_BLACK);
    button_border_draw(262, 88, 200, 30, focus_button_id_starting_conditions == 2);
    lang_text_draw_year(scenario.start_year, 330, 97, FONT_NORMAL_BLACK);
    // Initial favor
    text_draw("Initial favor", 32, 137, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(262, 128, 200, 30, focus_button_id_starting_conditions == 3);
    text_draw_number_centered(scenario.initial_favor, 262, 137, 200, FONT_NORMAL_BLACK);
    // Initial funds
    lang_text_draw(44, 39, 32, 177, FONT_NORMAL_BLACK);
    button_border_draw(262, 168, 200, 30, focus_button_id_starting_conditions == 4);
    text_draw_number_centered(scenario.initial_funds, 262, 177, 200, FONT_NORMAL_BLACK);
    // Rescue loan
    lang_text_draw(44, 68, 32, 217, FONT_NORMAL_BLACK);
    button_border_draw(262, 208, 200, 30, focus_button_id_starting_conditions == 5);
    text_draw_number_centered(scenario.rescue_loan, 262, 217, 200, FONT_NORMAL_BLACK);
    // Initial personal savings
    text_draw("Initial personal savings", 32, 257, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(262, 248, 200, 30, focus_button_id_starting_conditions == 6);
    text_draw_number_centered(scenario.initial_personal_savings, 262, 257, 200, FONT_NORMAL_BLACK);
    // Rome supplies wheat?
    lang_text_draw(44, 43, 32, 297, FONT_NORMAL_BLACK);
    button_border_draw(262, 288, 200, 30, focus_button_id_starting_conditions == 7);
    lang_text_draw_centered(18, scenario.rome_supplies_wheat, 262, 297, 200, FONT_NORMAL_BLACK);
    // Flotsam on?
    lang_text_draw(44, 80, 32, 337, FONT_NORMAL_BLACK);
    button_border_draw(262, 328, 200, 30, focus_button_id_starting_conditions == 8);
    lang_text_draw_centered(18, scenario.flotsam_enabled, 262, 337, 200, FONT_NORMAL_BLACK);
    set_translation(0, 0);
}

static void handle_input_starting_conditions(struct mouse_t *m, struct hotkeys_t *h);
static void show_editor_starting_conditions(void)
{
    struct window_type_t window = {
        WINDOW_EDITOR_STARTING_CONDITIONS,
        window_editor_map_draw_all,
        draw_foreground_starting_conditions,
        handle_input_starting_conditions,
    };
    window_show(&window);
}

static void handle_input_start_year(struct mouse_t *m, struct hotkeys_t *h)
{
    if (generic_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, buttons_start_year, 2, &focus_button_id_start_year)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        show_editor_starting_conditions();
    }
}

static void show_editor_start_year(void)
{
    struct window_type_t window = {
        WINDOW_EDITOR_START_YEAR,
        window_editor_map_draw_all,
        draw_foreground_start_year,
        handle_input_start_year,
    };
    window_show(&window);
}

static void button_start_year(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    show_editor_start_year();
}

static void set_initial_favor(int amount)
{
    scenario.initial_favor = amount;
    scenario.is_saved = 0;
}

static void button_initial_favor(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 300, screen_data.dialog_offset.y + 50, 3, 100, set_initial_favor);
}

static void set_initial_funds(int amount)
{
    scenario.initial_funds = amount;
    scenario.is_saved = 0;
}

static void button_initial_funds(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 300, screen_data.dialog_offset.y + 90, 5, 99999, set_initial_funds);
}

static void set_rescue_loan(int amount)
{
    scenario.rescue_loan = amount;
    scenario.is_saved = 0;
}

static void button_rescue_loan(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 300, screen_data.dialog_offset.y + 130, 5, 99999, set_rescue_loan);
}

static void set_initial_personal_savings(int amount)
{
    scenario.initial_personal_savings = amount;
    scenario.is_saved = 0;
}

static void button_initial_personal_savings(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 300, screen_data.dialog_offset.y + 170, 5, 99999, set_initial_personal_savings);
}

static void button_wheat(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.rome_supplies_wheat = !scenario.rome_supplies_wheat;
    scenario.is_saved = 0;
}

static void button_flotsam(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.flotsam_enabled = !scenario.flotsam_enabled;
    scenario.is_saved = 0;
}

static struct generic_button_t buttons_starting_conditions[] = {
    {262, 48, 200, 30, button_rank, button_none, 0, 0},
    {262, 88, 200, 30, button_start_year, button_none, 0, 0},
    {262, 128, 200, 30, button_initial_favor, button_none, 0, 0},
    {262, 168, 200, 30, button_initial_funds,button_none, 0, 0},
    {262, 208, 200, 30, button_rescue_loan,button_none, 0, 0},
    {262, 248, 200, 30, button_initial_personal_savings, button_none, 0, 0},
    {262, 288, 200, 30, button_wheat,button_none, 0, 0},
    {262, 328, 200, 30, button_flotsam, button_none, 0, 0},
};

static void handle_input_starting_conditions(struct mouse_t *m, struct hotkeys_t *h)
{
    if (generic_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, buttons_starting_conditions, sizeof(buttons_starting_conditions) / sizeof(struct generic_button_t), &focus_button_id_starting_conditions)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        show_editor_attributes();
    }
}

static void button_starting_conditions(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    stop_brief_description_box_input();
    show_editor_starting_conditions();
}

static void button_population_toggle(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.population_win_criteria.enabled = !scenario.population_win_criteria.enabled;
    scenario.is_saved = 0;
}

static void set_population(int goal)
{
    scenario.population_win_criteria.goal = goal;
    scenario.is_saved = 0;
}

static void button_population_value(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 402, screen_data.dialog_offset.y + 24, 5, 99999, set_population);
}

static void button_rating_toggle(int rating, __attribute__((unused)) int param2)
{
    switch (rating) {
        case RATING_CULTURE:
            scenario.culture_win_criteria.enabled = !scenario.culture_win_criteria.enabled;
            scenario.is_saved = 0;
            break;
        case RATING_PROSPERITY:
            scenario.prosperity_win_criteria.enabled = !scenario.prosperity_win_criteria.enabled;
            scenario.is_saved = 0;
            break;
        case RATING_PEACE:
            scenario.peace_win_criteria.enabled = !scenario.peace_win_criteria.enabled;
            scenario.is_saved = 0;
            break;
        case RATING_FAVOR:
            scenario.favor_win_criteria.enabled = !scenario.favor_win_criteria.enabled;
            scenario.is_saved = 0;
            break;
    }
}

static void set_culture(int goal)
{
    scenario.culture_win_criteria.goal = goal;
    scenario.is_saved = 0;
}

static void set_prosperity(int goal)
{
    scenario.prosperity_win_criteria.goal = goal;
    scenario.is_saved = 0;
}

static void set_peace(int goal)
{
    scenario.peace_win_criteria.goal = goal;
    scenario.is_saved = 0;
}

static void set_favor(int goal)
{
    scenario.favor_win_criteria.goal = goal;
    scenario.is_saved = 0;
}

static void button_rating_value(int rating, __attribute__((unused)) int param2)
{
    switch (rating) {
        case RATING_CULTURE:
            window_numeric_input_show(screen_data.dialog_offset.x + 402, screen_data.dialog_offset.y + 104, 3, 100, set_culture);
            break;
        case RATING_PROSPERITY:
            window_numeric_input_show(screen_data.dialog_offset.x + 402, screen_data.dialog_offset.y + 104, 3, 100, set_prosperity);
            break;
        case RATING_PEACE:
            window_numeric_input_show(screen_data.dialog_offset.x + 402, screen_data.dialog_offset.y + 104, 3, 100, set_peace);
            break;
        case RATING_FAVOR:
            window_numeric_input_show(screen_data.dialog_offset.x + 402, screen_data.dialog_offset.y + 104, 3, 100, set_favor);
            break;
        default:
            return;
    }
}

static void button_time_limit_toggle(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.time_limit_win_criteria.enabled = !scenario.time_limit_win_criteria.enabled;
    if (scenario.time_limit_win_criteria.enabled) {
        scenario.survival_time_win_criteria.enabled = 0;
    }
    scenario.is_saved = 0;
}

static void set_time_limit_years(int years)
{
    scenario.time_limit_win_criteria.years = years;
    scenario.is_saved = 0;
}

static void button_time_limit_years(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 402, screen_data.dialog_offset.y + 224, 3, 999, set_time_limit_years);
}

static void button_survival_toggle(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.survival_time_win_criteria.enabled = !scenario.survival_time_win_criteria.enabled;
    if (scenario.survival_time_win_criteria.enabled) {
        scenario.time_limit_win_criteria.enabled = 0;
    }
    scenario.is_saved = 0;
}

static void set_survival_time_years(int years)
{
    scenario.survival_time_win_criteria.years = years;
    scenario.is_saved = 0;
}

static void button_survival_years(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 402, screen_data.dialog_offset.y + 264, 3, 999, set_survival_time_years);
}

static struct generic_button_t buttons_win_criteria[] = {
    {260, 62, 80, 30, button_population_toggle, button_none, 0, 0},
    {360, 62, 150, 30, button_population_value, button_none, 0, 0},
    {260, 102, 80, 30, button_rating_toggle, button_none, RATING_CULTURE, 0},
    {360, 102, 150, 30, button_rating_value, button_none, RATING_CULTURE, 0},
    {260, 142, 80, 30, button_rating_toggle, button_none, RATING_PROSPERITY, 0},
    {360, 142, 150, 30, button_rating_value, button_none, RATING_PROSPERITY, 0},
    {260, 182, 80, 30, button_rating_toggle, button_none, RATING_PEACE, 0},
    {360, 182, 150, 30, button_rating_value, button_none, RATING_PEACE, 0},
    {260, 222, 80, 30, button_rating_toggle, button_none, RATING_FAVOR, 0},
    {360, 222, 150, 30, button_rating_value, button_none, RATING_FAVOR, 0},
    {260, 262, 80, 30, button_time_limit_toggle, button_none, 0, 0},
    {360, 262, 150, 30, button_time_limit_years, button_none, 0, 0},
    {260, 302, 80, 30, button_survival_toggle, button_none, 0, 0},
    {360, 302, 150, 30, button_survival_years, button_none, 0, 0},
};

static void draw_foreground_win_criteria(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);

    outer_panel_draw(0, 0, 34, 24);

    lang_text_draw_centered(44, 48, 0, 16, 544, FONT_LARGE_BLACK);

    // Winning population
    lang_text_draw(44, 56, 30, 70, FONT_NORMAL_BLACK);
    button_border_draw(260, 62, 80, 30, focus_button_id_win_criteria == 1);
    lang_text_draw_centered(18, scenario.population_win_criteria.enabled, 260, 70, 80, FONT_NORMAL_BLACK);
    button_border_draw(360, 62, 150, 30, focus_button_id_win_criteria == 2);
    text_draw_number_centered(scenario.population_win_criteria.goal, 360, 70, 150, FONT_NORMAL_BLACK);

    // Culture needed
    lang_text_draw(44, 50, 30, 110, FONT_NORMAL_BLACK);
    button_border_draw(260, 102, 80, 30, focus_button_id_win_criteria == 3);
    lang_text_draw_centered(18, scenario.culture_win_criteria.enabled, 260, 110, 80, FONT_NORMAL_BLACK);
    button_border_draw(360, 102, 150, 30, focus_button_id_win_criteria == 4);
    text_draw_number_centered(scenario.culture_win_criteria.goal, 360, 110, 150, FONT_NORMAL_BLACK);

    // Prosperity needed
    lang_text_draw(44, 51, 30, 150, FONT_NORMAL_BLACK);
    button_border_draw(260, 142, 80, 30, focus_button_id_win_criteria == 5);
    lang_text_draw_centered(18, scenario.prosperity_win_criteria.enabled, 260, 150, 80, FONT_NORMAL_BLACK);
    button_border_draw(360, 142, 150, 30, focus_button_id_win_criteria == 6);
    text_draw_number_centered(scenario.prosperity_win_criteria.goal, 360, 150, 150, FONT_NORMAL_BLACK);

    // Peace needed
    lang_text_draw(44, 52, 30, 190, FONT_NORMAL_BLACK);
    button_border_draw(260, 182, 80, 30, focus_button_id_win_criteria == 7);
    lang_text_draw_centered(18, scenario.peace_win_criteria.enabled, 260, 190, 80, FONT_NORMAL_BLACK);
    button_border_draw(360, 182, 150, 30, focus_button_id_win_criteria == 8);
    text_draw_number_centered(scenario.peace_win_criteria.goal, 360, 190, 150, FONT_NORMAL_BLACK);

    // Favor needed
    lang_text_draw(44, 53, 30, 230, FONT_NORMAL_BLACK);
    button_border_draw(260, 222, 80, 30, focus_button_id_win_criteria == 9);
    lang_text_draw_centered(18, scenario.favor_win_criteria.enabled, 260, 230, 80, FONT_NORMAL_BLACK);
    button_border_draw(360, 222, 150, 30, focus_button_id_win_criteria == 10);
    text_draw_number_centered(scenario.favor_win_criteria.goal, 360, 230, 150, FONT_NORMAL_BLACK);

    // Time limit (losing time)
    lang_text_draw(44, 54, 30, 270, FONT_NORMAL_BLACK);
    button_border_draw(260, 262, 80, 30, focus_button_id_win_criteria == 11);
    lang_text_draw_centered(18, scenario.time_limit_win_criteria.enabled, 260, 270, 80, FONT_NORMAL_BLACK);
    button_border_draw(360, 262, 150, 30, focus_button_id_win_criteria == 12);
    int width = text_draw_number(scenario.time_limit_win_criteria.years, '+', 0, 380, 270, FONT_NORMAL_BLACK);
    lang_text_draw_year(scenario.start_year + scenario.time_limit_win_criteria.years, width + 404, 270, FONT_NORMAL_BLACK);

    // Survival (winning time)
    lang_text_draw(44, 55, 30, 310, FONT_NORMAL_BLACK);
    button_border_draw(260, 302, 80, 30, focus_button_id_win_criteria == 13);
    lang_text_draw_centered(18, scenario.survival_time_win_criteria.enabled, 260, 310, 80, FONT_NORMAL_BLACK);
    button_border_draw(360, 302, 150, 30, focus_button_id_win_criteria == 14);
    width = text_draw_number(scenario.survival_time_win_criteria.years, '+', 0, 380, 310, FONT_NORMAL_BLACK);
    lang_text_draw_year(scenario.start_year + scenario.survival_time_win_criteria.years, width + 404, 310, FONT_NORMAL_BLACK);

    set_translation(0, 0);
}

static void handle_input_win_criteria(struct mouse_t *m, struct hotkeys_t *h)
{
    if (generic_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, buttons_win_criteria, sizeof(buttons_win_criteria) / sizeof(struct generic_button_t), &focus_button_id_win_criteria)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        show_editor_attributes();
    }
}

static void show_editor_win_criteria(void)
{
    struct window_type_t window = {
        WINDOW_EDITOR_WIN_CRITERIA,
        window_editor_map_draw_all,
        draw_foreground_win_criteria,
        handle_input_win_criteria,
    };
    window_show(&window);
}

static void button_win_criteria(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    stop_brief_description_box_input();
    show_editor_win_criteria();
}

static void toggle_allowed_building(int id, __attribute__((unused)) int param2)
{
    // sync with building types index
    int building_index = align_bulding_type_index_to_strings(id);

    scenario.allowed_buildings[building_index] = !scenario.allowed_buildings[building_index];
    scenario.is_saved = 0;
}

static struct generic_button_t buttons_allowed_buildings[] = {
    {-138, 50, 190, 20, toggle_allowed_building, button_none, 1, 0},
    {-138, 70, 190, 20, toggle_allowed_building, button_none, 2, 0},
    {-138, 90, 190, 20, toggle_allowed_building, button_none, 3, 0},
    {-138, 110, 190, 20, toggle_allowed_building, button_none, 4, 0},
    {-138, 130, 190, 20, toggle_allowed_building, button_none, 5, 0},
    {-138, 150, 190, 20, toggle_allowed_building, button_none, 6, 0},
    {-138, 170, 190, 20, toggle_allowed_building, button_none, 7, 0},
    {-138, 190, 190, 20, toggle_allowed_building, button_none, 8, 0},
    {-138, 210, 190, 20, toggle_allowed_building, button_none, 9, 0},
    {-138, 230, 190, 20, toggle_allowed_building, button_none, 10, 0},
    {-138, 250, 190, 20, toggle_allowed_building, button_none, 11, 0},
    {-138, 270, 190, 20, toggle_allowed_building, button_none, 12, 0},
    {-138, 290, 190, 20, toggle_allowed_building, button_none, 13, 0},
    {-138, 310, 190, 20, toggle_allowed_building, button_none, 14, 0},
    {-138, 330, 190, 20, toggle_allowed_building, button_none, 15, 0},
    {-138, 350, 190, 20, toggle_allowed_building, button_none, 16, 0},
    {-138, 370, 190, 20, toggle_allowed_building, button_none, 17, 0},
    {-138, 390, 190, 20, toggle_allowed_building, button_none, 18, 0},
    {-138, 410, 190, 20, toggle_allowed_building, button_none, 19, 0},
    {-138, 430, 190, 20, toggle_allowed_building, button_none, 20, 0},
    {61, 50, 190, 20, toggle_allowed_building, button_none, 21, 0},
    {61, 70, 190, 20, toggle_allowed_building, button_none, 22, 0},
    {61, 90, 190, 20, toggle_allowed_building, button_none, 23, 0},
    {61, 110, 190, 20, toggle_allowed_building, button_none, 24, 0},
    {61, 130, 190, 20, toggle_allowed_building, button_none, 25, 0},
    {61, 150, 190, 20, toggle_allowed_building, button_none, 26, 0},
    {61, 170, 190, 20, toggle_allowed_building, button_none, 27, 0},
    {61, 190, 190, 20, toggle_allowed_building, button_none, 28, 0},
    {61, 210, 190, 20, toggle_allowed_building, button_none, 29, 0},
    {61, 230, 190, 20, toggle_allowed_building, button_none, 30, 0},
    {61, 250, 190, 20, toggle_allowed_building, button_none, 31, 0},
    {61, 270, 190, 20, toggle_allowed_building, button_none, 32, 0},
    {61, 290, 190, 20, toggle_allowed_building, button_none, 33, 0},
    {61, 310, 190, 20, toggle_allowed_building, button_none, 34, 0},
    {61, 330, 190, 20, toggle_allowed_building, button_none, 35, 0},
    {61, 350, 190, 20, toggle_allowed_building, button_none, 36, 0},
    {61, 370, 190, 20, toggle_allowed_building, button_none, 37, 0},
    {61, 390, 190, 20, toggle_allowed_building, button_none, 38, 0},
    {61, 410, 190, 20, toggle_allowed_building, button_none, 39, 0},
    {61, 430, 190, 20, toggle_allowed_building, button_none, 40, 0},
    {260, 50, 190, 20, toggle_allowed_building, button_none, 41, 0},
    {260, 70, 190, 20, toggle_allowed_building, button_none, 42, 0},
    {260, 90, 190, 20, toggle_allowed_building, button_none, 43, 0},
    {260, 110, 190, 20, toggle_allowed_building, button_none, 44, 0},
    {260, 130, 190, 20, toggle_allowed_building, button_none, 45, 0},
    {260, 150, 190, 20, toggle_allowed_building, button_none, 46, 0},
    {260, 170, 190, 20, toggle_allowed_building, button_none, 47, 0},
    {260, 190, 190, 20, toggle_allowed_building, button_none, 48, 0},
    {260, 210, 190, 20, toggle_allowed_building, button_none, 49, 0},
    {260, 230, 190, 20, toggle_allowed_building, button_none, 50, 0},
    {260, 250, 190, 20, toggle_allowed_building, button_none, 51, 0},
    {260, 270, 190, 20, toggle_allowed_building, button_none, 52, 0},
    {260, 290, 190, 20, toggle_allowed_building, button_none, 53, 0},
    {260, 310, 190, 20, toggle_allowed_building, button_none, 54, 0},
    {260, 330, 190, 20, toggle_allowed_building, button_none, 55, 0},
    {260, 350, 190, 20, toggle_allowed_building, button_none, 56, 0},
    {260, 370, 190, 20, toggle_allowed_building, button_none, 57, 0},
    {260, 390, 190, 20, toggle_allowed_building, button_none, 58, 0},
    {260, 410, 190, 20, toggle_allowed_building, button_none, 59, 0},
    {260, 430, 190, 20, toggle_allowed_building, button_none, 60, 0},
    {459, 50, 190, 20, toggle_allowed_building, button_none, 61, 0},
    {459, 70, 190, 20, toggle_allowed_building, button_none, 62, 0},
    {459, 90, 190, 20, toggle_allowed_building, button_none, 63, 0},
    {459, 110, 190, 20, toggle_allowed_building, button_none, 64, 0},
    {459, 130, 190, 20, toggle_allowed_building, button_none, 65, 0},
    {459, 150, 190, 20, toggle_allowed_building, button_none, 66, 0},
    {459, 170, 190, 20, toggle_allowed_building, button_none, 67, 0},
    {459, 190, 190, 20, toggle_allowed_building, button_none, 68, 0},
    {459, 210, 190, 20, toggle_allowed_building, button_none, 69, 0},
    {459, 230, 190, 20, toggle_allowed_building, button_none, 70, 0},
    {459, 250, 190, 20, toggle_allowed_building, button_none, 71, 0},
    {459, 270, 190, 20, toggle_allowed_building, button_none, 72, 0},
    {459, 290, 190, 20, toggle_allowed_building, button_none, 73, 0},
    {459, 310, 190, 20, toggle_allowed_building, button_none, 74, 0},
    {459, 330, 190, 20, toggle_allowed_building, button_none, 75, 0},
    {459, 350, 190, 20, toggle_allowed_building, button_none, 76, 0},
    {459, 370, 190, 20, toggle_allowed_building, button_none, 77, 0},
    {459, 390, 190, 20, toggle_allowed_building, button_none, 78, 0},
};

static void draw_foreground_allowed_buildings(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);

    outer_panel_draw(-160, 0, 52, 30);

    lang_text_draw_centered(44, 47, -160, 16, 832, FONT_LARGE_BLACK);

    for (int i = 0; i < MAX_ALLOWED_BUILDINGS; i++) {
        int x, y;
        if (i < 20) {
            x = -138;
            y = 50 + 20 * (i);
        } else if (i < 40) {
            x = 61;
            y = 50 + 20 * (i - 20);
        } else if (i < 60) {
            x = 260;
            y = 50 + 20 * (i - 40);
        } else {
            x = 459;
            y = 50 + 20 * (i - 60);
        }
        button_border_draw(x, y, 190, 20, focus_button_id_allowed_buildings == i + 1);
        int building_index = align_bulding_type_index_to_strings(i + 1);
        if (scenario.allowed_buildings[building_index]) {
            text_draw_centered(all_buildings_strings[building_index], x, y + 5, 190, FONT_NORMAL_BLACK, 0);
        } else {
            text_draw_centered(all_buildings_strings[building_index], x, y + 5, 190, FONT_NORMAL_PLAIN, COLOR_FONT_RED);
        }

    }

    set_translation(0, 0);
}

static void handle_input_allowed_buildings(struct mouse_t *m, struct hotkeys_t *h)
{
    if (generic_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, buttons_allowed_buildings, MAX_ALLOWED_BUILDINGS, &focus_button_id_allowed_buildings)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        empire_object_our_city_set_resources_sell();
        show_editor_attributes();
    }
}

static void show_editor_allowed_buildings(void)
{
    struct window_type_t window = {
        WINDOW_EDITOR_ALLOWED_BUILDINGS,
        window_editor_map_draw_all,
        draw_foreground_allowed_buildings,
        handle_input_allowed_buildings,
    };
    window_show(&window);
}

static void button_allowed_buildings(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    stop_brief_description_box_input();
    show_editor_allowed_buildings();
}

static void button_gladiator_toggle(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.gladiator_revolt.state = !scenario.gladiator_revolt.state;
    scenario.is_saved = 0;
    window_data.refresh_on_draw = 1;
}

static void set_gladiator_revolt_month(int value)
{
    // Jan is 1 for input/draw purposes
    if (value == 0) {
        value = 1;
    }
    // change month back to 0 indexed before saving
    scenario.gladiator_revolt.month = value - 1;
}

static void button_gladiator_month(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 237, screen_data.dialog_offset.y + 17, 2, 12, set_gladiator_revolt_month);
}

static void set_gladiator_revolt_year(int year)
{
    scenario.gladiator_revolt.year = year;
    scenario.is_saved = 0;
}

static void button_gladiator_year(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 335, screen_data.dialog_offset.y + 20, 3, 999, set_gladiator_revolt_year);
}

static void button_sea_trade_toggle(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.random_events.sea_trade_problem = !scenario.random_events.sea_trade_problem;
    scenario.is_saved = 0;
    window_data.refresh_on_draw = 1;
}

static void button_land_trade_toggle(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.random_events.land_trade_problem = !scenario.random_events.land_trade_problem;
    scenario.is_saved = 0;
    window_data.refresh_on_draw = 1;
}

static void button_raise_wages_toggle(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.random_events.raise_wages = !scenario.random_events.raise_wages;
    scenario.is_saved = 0;
    window_data.refresh_on_draw = 1;
}

static void button_lower_wages_toggle(__attribute__((unused)) int param1, __attribute__((unused))  int param2)
{
    scenario.random_events.lower_wages = !scenario.random_events.lower_wages;
    scenario.is_saved = 0;
    window_data.refresh_on_draw = 1;
}

static void button_contamination_toggle(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.random_events.contaminated_water = !scenario.random_events.contaminated_water;
    scenario.is_saved = 0;
    window_data.refresh_on_draw = 1;
}

static struct generic_button_t buttons_special_events[] = {
    {200, 74, 75, 24, button_gladiator_toggle, button_none, 0, 0},
    {280, 74, 45, 24, button_gladiator_month,button_none, 0, 0},
    {330, 74, 150, 24, button_gladiator_year, button_none, 0, 0},
    {200, 104, 75, 24, button_sea_trade_toggle,button_none, 0, 0},
    {200, 134, 75, 24, button_land_trade_toggle,button_none, 0, 0},
    {200, 164, 75, 24, button_raise_wages_toggle,button_none, 0, 0},
    {200, 194, 75, 24, button_lower_wages_toggle, button_none, 0, 0},
    {200, 224, 75, 24, button_contamination_toggle, button_none, 0, 0},
};

static void draw_foreground_special_events(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);

    outer_panel_draw(0, 0, 32, 17);

    lang_text_draw_centered(38, 0, 0, 16, 480, FONT_LARGE_BLACK);

    // table header
    lang_text_draw(38, 11, 220, 60, FONT_SMALL_PLAIN);
    lang_text_draw(38, 12, 330, 60, FONT_SMALL_PLAIN);

    // Gladiator revolt
    lang_text_draw(38, 2, 20, 80, FONT_NORMAL_BLACK);
    button_border_draw(200, 74, 75, 24, focus_button_id_special_events == 1);
    lang_text_draw_centered(18, scenario.gladiator_revolt.state, 200, 80, 75, FONT_NORMAL_BLACK);

    button_border_draw(280, 74, 45, 24, focus_button_id_special_events == 2);
    lang_text_draw(25, scenario.gladiator_revolt.month, 288, 80, FONT_NORMAL_BLACK);

    button_border_draw(330, 74, 150, 24, focus_button_id_special_events == 3);
    int width = text_draw_number(scenario.gladiator_revolt.year, '+', 0, 346, 80, FONT_NORMAL_BLACK);
    lang_text_draw_year(scenario.start_year + scenario.gladiator_revolt.year, width + 346, 80, FONT_NORMAL_BLACK);

    // Invalid year/month combination
    if (scenario.gladiator_revolt.year == 0 && scenario.gladiator_revolt.month == 0) {
        text_draw(common_editor_strings[2], 346, 24, FONT_NORMAL_PLAIN, COLOR_RED);
    }

    // random events
    // Sea trade problem
    lang_text_draw(38, 4, 20, 110, FONT_NORMAL_BLACK);
    button_border_draw(200, 104, 75, 24, focus_button_id_special_events == 4);
    lang_text_draw_centered(18, scenario.random_events.sea_trade_problem, 200, 110, 75, FONT_NORMAL_BLACK);
    lang_text_draw(38, 13, 330, 110, FONT_SMALL_PLAIN);

    // Land trade problem
    lang_text_draw(38, 5, 20, 140, FONT_NORMAL_BLACK);
    button_border_draw(200, 134, 75, 24, focus_button_id_special_events == 5);
    lang_text_draw_centered(18, scenario.random_events.land_trade_problem, 200, 140, 75, FONT_NORMAL_BLACK);
    lang_text_draw(38, 13, 330, 140, FONT_SMALL_PLAIN);

    // Rome raises wages
    lang_text_draw(38, 6, 20, 170, FONT_NORMAL_BLACK);
    button_border_draw(200, 164, 75, 24, focus_button_id_special_events == 6);
    lang_text_draw_centered(18, scenario.random_events.raise_wages, 200, 170, 75, FONT_NORMAL_BLACK);
    lang_text_draw(38, 13, 330, 170, FONT_SMALL_PLAIN);

    // Rome lowers wages
    lang_text_draw(38, 7, 20, 200, FONT_NORMAL_BLACK);
    button_border_draw(200, 194, 75, 24, focus_button_id_special_events == 7);
    lang_text_draw_centered(18, scenario.random_events.lower_wages, 200, 200, 75, FONT_NORMAL_BLACK);
    lang_text_draw(38, 13, 330, 200, FONT_SMALL_PLAIN);

    // Contaminated water
    lang_text_draw(38, 8, 20, 230, FONT_NORMAL_BLACK);
    button_border_draw(200, 224, 75, 24, focus_button_id_special_events == 8);
    lang_text_draw_centered(18, scenario.random_events.contaminated_water, 200, 230, 75, FONT_NORMAL_BLACK);
    lang_text_draw(38, 13, 330, 230, FONT_SMALL_PLAIN);

    set_translation(0, 0);
}

static void handle_input_special_events(struct mouse_t *m, struct hotkeys_t *h)
{
    if (generic_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, buttons_special_events, sizeof(buttons_special_events) / sizeof(struct generic_button_t), &focus_button_id_special_events)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        show_editor_attributes();
    }
}

static void show_editor_special_events(void)
{
    struct window_type_t window = {
        WINDOW_EDITOR_SPECIAL_EVENTS,
        window_editor_map_draw_all,
        draw_foreground_special_events,
        handle_input_special_events,
    };
    window_show(&window);
}

static void button_special_events(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    stop_brief_description_box_input();
    show_editor_special_events();
}

static void set_year_request(int value)
{
    scenario.requests[id_edit_request].year = value;
}

static void button_year_request(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 140, screen_data.dialog_offset.y + 65, 3, 999, set_year_request);
}

static void set_month_request(int value)
{
    // Jan is 1 for input/draw purposes
    if (value == 0) {
        value = 1;
    }
    // change month back to 0 indexed before saving
    scenario.requests[id_edit_request].month = value - 1;
}

static void button_month_request(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 140, screen_data.dialog_offset.y + 95, 2, 12, set_month_request);
}

static void set_amount_request(int value)
{
    // don't allow 0
    scenario.requests[id_edit_request].amount = value ? value : 1;
}

static void button_amount_request(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    int max_digits = 3;
    int max_amount = 999;
    if (scenario.requests[id_edit_request].resource == RESOURCE_DENARII) {
        max_digits = 5;
        max_amount = 99999;
    }
    window_numeric_input_show(
        screen_data.dialog_offset.x + 140, screen_data.dialog_offset.y + 125,
        max_digits, max_amount, set_amount_request
    );
}

static void set_resource_request(int value)
{
    scenario.requests[id_edit_request].resource = value;
    if (scenario.requests[id_edit_request].amount > 999 && scenario.requests[id_edit_request].resource != RESOURCE_DENARII) {
        scenario.requests[id_edit_request].amount = 999;
    }
}

static void window_select_list_show_text(int x, int y, char **items, int num_items, void (*callback)(int))
{
    struct window_type_t window = {
        WINDOW_SELECT_LIST,
        window_draw_underlying_window,
        draw_foreground_select_list,
        handle_input_select_list,
    };
    select_list_data.x = x;
    select_list_data.y = y;
    select_list_data.mode = MODE_TEXT;
    select_list_data.items = items;
    select_list_data.num_items = num_items;
    select_list_data.callback = callback;
    window_show(&window);
}

static void button_resource_request(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_select_list_show_text(screen_data.dialog_offset.x + 255, screen_data.dialog_offset.y + 77, resource_strings, RESOURCE_TYPES_MAX + 1, set_resource_request);
}

static void set_deadline_years_request(int value)
{
    // don't allow 0
    scenario.requests[id_edit_request].years_deadline = value ? value : 1;
    scenario.requests[id_edit_request].months_to_comply = 12 * scenario.requests[id_edit_request].years_deadline;
}

static void button_deadline_years_request(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 140, screen_data.dialog_offset.y + 185, 3, 999, set_deadline_years_request);
}

static void set_favor_request(int value)
{
    scenario.requests[id_edit_request].favor = value;
}

static void button_favor_request(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 140, screen_data.dialog_offset.y + 215, 3, 100, set_favor_request);
}

static void sort_editor_requests(void)
{
    for (int i = 0; i < MAX_REQUESTS; i++) {
        for (int j = MAX_REQUESTS - 1; j > 0; j--) {
            if (scenario.requests[j].resource) {
                // if no previous request scheduled, move current back until first; if previous request is later than current, swap
                if (!scenario.requests[j - 1].resource || scenario.requests[j - 1].year > scenario.requests[j].year
                || (scenario.requests[j - 1].year == scenario.requests[j].year && scenario.requests[j - 1].month > scenario.requests[j].month)) {
                    struct request_t tmp = scenario.requests[j];
                    scenario.requests[j] = scenario.requests[j - 1];
                    scenario.requests[j - 1] = tmp;
                }
            }
        }
    }
    scenario.is_saved = 0;
}

static void show_editor_requests(void);
static void button_delete_edit_request(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.requests[id_edit_request].year = 1;
    scenario.requests[id_edit_request].month = 0;
    scenario.requests[id_edit_request].amount = 1;
    scenario.requests[id_edit_request].resource = 0;
    scenario.requests[id_edit_request].years_deadline = 5;
    scenario.requests[id_edit_request].months_to_comply = 60;
    scenario.requests[id_edit_request].favor = 8;
    sort_editor_requests();
    show_editor_requests();
}

static struct generic_button_t buttons_edit_request[] = {
    {155, 152, 100, 25, button_year_request, button_none, 0, 0},
    {155, 182, 100, 25, button_month_request, button_none, 0, 0},
    {155, 212, 100, 25, button_amount_request, button_none, 0, 0},
    {155, 242, 100, 25, button_resource_request, button_none, 0, 0},
    {155, 272, 100, 25, button_deadline_years_request, button_none, 0, 0},
    {155, 302, 100, 25, button_favor_request, button_none, 0, 0},
    {105, 342, 200, 25, button_delete_edit_request, button_none, 0, 0},
};

static void text_draw_number_centered_prefix(int value, char prefix, int x_offset, int y_offset, int box_width, int font)
{
    char str[NUMBER_BUFFER_LENGTH];
    number_to_string(str, value, prefix, " ");
    text_draw_centered(str, x_offset, y_offset, box_width, font, 0);
}

static void draw_foreground_edit_request(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);

    outer_panel_draw(0, 100, 26, 18);
    // Request from the Emperor
    text_draw_centered("Request from the Emperor", 0, 116, 416, FONT_LARGE_BLACK, COLOR_BLACK);

    // Year offset
    text_draw(common_editor_strings[0], 30, 158, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(155, 152, 100, 25, focus_button_id_edit_request == 1);
    text_draw_number_centered_prefix(scenario.requests[id_edit_request].year, '+', 157, 158, 100, FONT_NORMAL_BLACK);
    lang_text_draw_year(scenario.start_year + scenario.requests[id_edit_request].year, 275, 158, FONT_NORMAL_BLACK);

    // Month
    text_draw(common_editor_strings[1], 30, 188, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(155, 182, 100, 25, focus_button_id_edit_request == 2);
    text_draw_number_centered(scenario.requests[id_edit_request].month + 1, 155, 188, 100, FONT_NORMAL_BLACK);

    // Invalid year/month combination
    if (scenario.requests[id_edit_request].year == 0 && scenario.requests[id_edit_request].month == 0) {
        text_draw(common_editor_strings[2], 260, 188, FONT_NORMAL_PLAIN, COLOR_RED);
    }

    // Amount
    text_draw(common_editor_strings[3], 30, 218, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(155, 212, 100, 25, focus_button_id_edit_request == 3);
    text_draw_number_centered(scenario.requests[id_edit_request].amount, 155, 218, 100, FONT_NORMAL_BLACK);

    // Resource
    text_draw(common_editor_strings[4], 30, 248, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(155, 242, 100, 25, focus_button_id_edit_request == 4);
    text_draw_centered(resource_strings[scenario.requests[id_edit_request].resource], 155, 248, 100, FONT_NORMAL_BLACK, COLOR_BLACK);

    // Years deadline
    text_draw("Years deadline:", 30, 278, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(155, 272, 100, 25, focus_button_id_edit_request == 5);
    lang_text_draw_amount(8, 8, scenario.requests[id_edit_request].years_deadline, 160, 278, FONT_NORMAL_BLACK);

    // Favor granted
    text_draw("Favor granted:", 30, 308, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(155, 302, 100, 25, focus_button_id_edit_request == 6);
    text_draw_number_centered_prefix(scenario.requests[id_edit_request].favor, '+', 157, 308, 100, FONT_NORMAL_BLACK);

    // Unschedule request
    button_border_draw(105, 342, 200, 25, focus_button_id_edit_request == 7);
    lang_text_draw_centered(44, 25, 105, 348, 200, FONT_NORMAL_BLACK);

    set_translation(0, 0);
}

static void handle_input_edit_request(struct mouse_t *m, struct hotkeys_t *h)
{
    if (generic_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, buttons_edit_request, sizeof(buttons_edit_request) / sizeof(struct generic_button_t), &focus_button_id_edit_request)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        sort_editor_requests();
        show_editor_requests();
    }
}

static void show_editor_edit_request(int id, __attribute__((unused)) int param2)
{
    struct window_type_t window = {
        WINDOW_EDITOR_EDIT_REQUEST,
        window_editor_map_draw_all,
        draw_foreground_edit_request,
        handle_input_edit_request,
    };
    id_edit_request = id;
    window_show(&window);
}

static struct generic_button_t buttons_requests[] = {
    {-300, 48, 290, 25, show_editor_edit_request, button_none, 0, 0},
    {-300, 78, 290, 25, show_editor_edit_request, button_none, 1, 0},
    {-300, 108, 290, 25, show_editor_edit_request, button_none, 2, 0},
    {-300, 138, 290, 25, show_editor_edit_request, button_none, 3, 0},
    {-300, 168, 290, 25, show_editor_edit_request, button_none, 4, 0},
    {-300, 198, 290, 25, show_editor_edit_request, button_none, 5, 0},
    {-300, 228, 290, 25, show_editor_edit_request, button_none, 6, 0},
    {-300, 258, 290, 25, show_editor_edit_request, button_none, 7, 0},
    {-300, 288, 290, 25, show_editor_edit_request, button_none, 8, 0},
    {-300, 318, 290, 25, show_editor_edit_request, button_none, 9, 0},
    {0, 48, 290, 25, show_editor_edit_request, button_none, 10, 0},
    {0, 78, 290, 25, show_editor_edit_request, button_none, 11, 0},
    {0, 108, 290, 25, show_editor_edit_request, button_none, 12, 0},
    {0, 138, 290, 25, show_editor_edit_request, button_none, 13, 0},
    {0, 168, 290, 25, show_editor_edit_request, button_none, 14, 0},
    {0, 198, 290, 25, show_editor_edit_request, button_none, 15, 0},
    {0, 228, 290, 25, show_editor_edit_request, button_none, 16, 0},
    {0, 258, 290, 25, show_editor_edit_request, button_none, 17, 0},
    {0, 288, 290, 25, show_editor_edit_request, button_none, 18, 0},
    {0, 318, 290, 25, show_editor_edit_request, button_none, 19, 0},
    {300, 48, 290, 25, show_editor_edit_request, button_none, 20, 0},
    {300, 78, 290, 25, show_editor_edit_request, button_none, 21, 0},
    {300, 108, 290, 25, show_editor_edit_request, button_none, 22, 0},
    {300, 138, 290, 25, show_editor_edit_request, button_none, 23, 0},
    {300, 168, 290, 25, show_editor_edit_request, button_none, 24, 0},
    {300, 198, 290, 25, show_editor_edit_request, button_none, 25, 0},
    {300, 228, 290, 25, show_editor_edit_request, button_none, 26, 0},
    {300, 258, 290, 25, show_editor_edit_request, button_none, 27, 0},
    {300, 288, 290, 25, show_editor_edit_request, button_none, 28, 0},
    {300, 318, 290, 25, show_editor_edit_request, button_none, 29, 0},
    {600, 48, 290, 25, show_editor_edit_request, button_none, 30, 0},
    {600, 78, 290, 25, show_editor_edit_request, button_none, 31, 0},
    {600, 108, 290, 25, show_editor_edit_request, button_none, 32, 0},
    {600, 138, 290, 25, show_editor_edit_request, button_none, 33, 0},
    {600, 168, 290, 25, show_editor_edit_request, button_none, 34, 0},
    {600, 198, 290, 25, show_editor_edit_request, button_none, 35, 0},
    {600, 228, 290, 25, show_editor_edit_request, button_none, 36, 0},
    {600, 258, 290, 25, show_editor_edit_request, button_none, 37, 0},
    {600, 288, 290, 25, show_editor_edit_request, button_none, 38, 0},
    {600, 318, 290, 25, show_editor_edit_request, button_none, 39, 0},
};

static void draw_foreground_requests(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);

    outer_panel_draw(-320, 0, 77, 26);
    lang_text_draw_centered(44, 14, -320, 16, 1232, FONT_LARGE_BLACK);

    for (int i = 0; i < MAX_REQUESTS; i++) {
        int x, y;
        if (i < 10) {
            x = -300;
            y = 48 + 30 * i;
        } else if (i < 20) {
            x = 0;
            y = 48 + 30 * (i - 10);
        } else if (i < 30) {
            x = 300;
            y = 48 + 30 * (i - 20);
        } else {
            x = 600;
            y = 48 + 30 * (i - 30);
        }
        button_border_draw(x, y, 290, 25, focus_button_id_requests == i + 1);
        if (scenario.requests[i].resource) {
            int width = lang_text_draw(25, scenario.requests[i].month, x + 12, y + 6, FONT_NORMAL_BLACK);
            width += lang_text_draw_year(scenario.start_year + scenario.requests[i].year, x + 6 + width, y + 6, FONT_NORMAL_BLACK);
            width += text_draw_number(scenario.requests[i].amount, 0, "", x + 6 + width, y + 6, FONT_NORMAL_BLACK);
            image_draw(resource_images[scenario.requests[i].resource].editor_icon_img_id + resource_image_offset(scenario.requests[i].resource, RESOURCE_IMAGE_ICON), x + 12 + width, y + 3);
            width += text_draw_number(scenario.requests[i].years_deadline, 0, "Y", x + 40 + width, y + 6, FONT_NORMAL_BLACK);
            text_draw_number(scenario.requests[i].favor, 0, "F", x + 40 + width, y + 6, FONT_NORMAL_BLACK);
        } else {
            lang_text_draw_centered(44, 23, x, y + 6, 290, FONT_NORMAL_BLACK);
        }
    }

    // requests hint
    lang_text_draw_multiline(152, 1, -288, 360, 1200, FONT_NORMAL_BLACK);

    set_translation(0, 0);
}

static void handle_input_requests(struct mouse_t *m, struct hotkeys_t *h)
{
    if (generic_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, buttons_requests, sizeof(buttons_requests) / sizeof(struct generic_button_t), &focus_button_id_requests)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        show_editor_attributes();
    }
}

static void show_editor_requests(void)
{
    struct window_type_t window = {
        WINDOW_EDITOR_REQUESTS,
        window_editor_map_draw_all,
        draw_foreground_requests,
        handle_input_requests,
    };
    window_show(&window);
}

static void show_editor_edit_requests(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    stop_brief_description_box_input();
    show_editor_requests();
}

static void set_year_custom_message(int value)
{
    scenario.editor_custom_messages[custom_message_id].year = value;
}

static void button_year_custom_message(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 15, screen_data.dialog_offset.y - 28, 3, 999, set_year_custom_message);
}

static void set_month_custom_message(int value)
{
    // Jan is 1 for input/draw purposes
    if (value == 0) {
        value = 1;
    }
    // change month back to 0 indexed before saving
    scenario.editor_custom_messages[custom_message_id].month = value - 1;
}

static void button_month_custom_message(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 15, screen_data.dialog_offset.y + 2, 2, 12, set_month_custom_message);
}

static void button_urgent_custom_msg(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.editor_custom_messages[custom_message_id].urgent = !scenario.editor_custom_messages[custom_message_id].urgent;
}

static void button_enabled_custom_msg(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.editor_custom_messages[custom_message_id].enabled = !scenario.editor_custom_messages[custom_message_id].enabled;
}

static void scenario_editor_sort_custom_messages(void)
{
    for (int i = 0; i < MAX_EDITOR_CUSTOM_MESSAGES; i++) {
        for (int j = MAX_EDITOR_CUSTOM_MESSAGES - 1; j > 0; j--) {
            if (scenario.editor_custom_messages[j].enabled) {
                // if no previous custom message scheduled, move current back until first; if previous custom message is later than current, swap
                if (!scenario.editor_custom_messages[j - 1].enabled || scenario.editor_custom_messages[j - 1].year > scenario.editor_custom_messages[j].year
                || (scenario.editor_custom_messages[j - 1].year == scenario.editor_custom_messages[j].year && scenario.editor_custom_messages[j - 1].month > scenario.editor_custom_messages[j].month)) {
                    struct editor_custom_messages_t tmp = scenario.editor_custom_messages[j];
                    scenario.editor_custom_messages[j] = scenario.editor_custom_messages[j - 1];
                    scenario.editor_custom_messages[j - 1] = tmp;
                }
            }
        }
    }
    scenario.is_saved = 0;
}

static void show_editor_custom_messages(void);
static void button_reset_message(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.editor_custom_messages[custom_message_id].year = 1;
    scenario.editor_custom_messages[custom_message_id].month = 0;
    scenario.editor_custom_messages[custom_message_id].urgent = 0;
    scenario.editor_custom_messages[custom_message_id].enabled = 0;
    scenario.editor_custom_messages[custom_message_id].title[0] = '\0';
    scenario.editor_custom_messages[custom_message_id].text[0] = '\0';
    scenario.editor_custom_messages[custom_message_id].video_file[0] = '\0';
    scenario_editor_sort_custom_messages();
    show_editor_custom_messages();
}

static void button_reset_title_custom_msg(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.editor_custom_messages[custom_message_id].title[0] = '\0';
    input_box_stop(&editor_custom_message_input_title);
    string_copy(scenario.editor_custom_messages[custom_message_id].title, editor_custom_message_title, MAX_CUSTOM_MESSAGE_TITLE);
    input_box_start(&editor_custom_message_input_title);
}

static void button_reset_text_custom_msg(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.editor_custom_messages[custom_message_id].text[0] = '\0';
    input_box_stop(&editor_custom_message_input_text);
    string_copy(scenario.editor_custom_messages[custom_message_id].text, editor_custom_message_text, MAX_CUSTOM_MESSAGE_TITLE);
    rich_text_reset(0);
    input_box_start(&editor_custom_message_input_text);
}

static struct generic_button_t buttons_edit_custom_message[] = {
    {36, 58, 75, 25, button_year_custom_message, button_none, 0, 0},
    {36, 88, 75, 25, button_month_custom_message, button_none, 0, 0},
    {36, 118, 75, 25, button_urgent_custom_msg, button_none, 0, 0},
    {36, 194, 75, 25, button_enabled_custom_msg, button_none, 0, 0},
    {135, 194, 125, 25, button_reset_message, button_none, 0, 0},
};

static struct generic_button_t reset_title_button[] = {
    {5, 110, 125, 25, button_reset_title_custom_msg, button_none, 0, 0},
};

static struct generic_button_t reset_text_button[] = {
    {515, 16, 150, 35, button_reset_text_custom_msg, button_none, 0, 0},
};

static void draw_foreground_edit_custom_msg(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);

    if (custom_message_category == CUSTOM_MESSAGE_ATTRIBUTES) {
        outer_panel_draw(-100, 0, 24, 15);

        // Attributes
        text_draw_centered(custom_messages_strings[1], -100, 16, 384, FONT_LARGE_BLACK, COLOR_BLACK);

        // Year offset
        text_draw(common_editor_strings[0], -68, 64, FONT_NORMAL_BLACK, COLOR_BLACK);
        button_border_draw(36, 58, 75, 25, focus_button_id_edit_custom_msg == 1);
        text_draw_number_centered_prefix(scenario.editor_custom_messages[custom_message_id].year, '+', 38, 64, 75, FONT_NORMAL_BLACK);
        lang_text_draw_year(scenario.start_year + scenario.editor_custom_messages[custom_message_id].year, 118, 64, FONT_NORMAL_BLACK);

        // Month
        text_draw(common_editor_strings[1], -68, 94, FONT_NORMAL_BLACK, COLOR_BLACK);
        button_border_draw(36, 88, 75, 25, focus_button_id_edit_custom_msg == 2);
        text_draw_number_centered(scenario.editor_custom_messages[custom_message_id].month + 1, 36, 94, 75, FONT_NORMAL_BLACK);

        // Invalid year/month combination
        if (scenario.editor_custom_messages[custom_message_id].year == 0 && scenario.editor_custom_messages[custom_message_id].month == 0) {
            text_draw(common_editor_strings[2], 122, 94, FONT_NORMAL_PLAIN, COLOR_RED);
        }

        // Urgent
        text_draw("Urgent?", -68, 124, FONT_NORMAL_BLACK, COLOR_BLACK);
        button_border_draw(36, 118, 75, 25, focus_button_id_edit_custom_msg == 3);
        lang_text_draw_centered(18, scenario.editor_custom_messages[custom_message_id].urgent, 36, 124, 75, FONT_NORMAL_BLACK);

        // Video file
        text_draw("Video file:", -68, 160, FONT_NORMAL_BLACK, COLOR_BLACK);
        input_box_draw(&editor_custom_message_input_video_file);

        // Video file hint
        text_draw("smk/file", 200, 160, FONT_NORMAL_PLAIN, COLOR_TOOLTIP);

        // Enabled
        text_draw("Enabled?", -68, 200, FONT_NORMAL_BLACK, COLOR_BLACK);
        button_border_draw(36, 194, 75, 25, focus_button_id_edit_custom_msg == 4);
        lang_text_draw_centered(18, scenario.editor_custom_messages[custom_message_id].enabled, 36, 200, 75, FONT_NORMAL_BLACK);

        // Reset message
        button_border_draw(135, 194, 125, 25, focus_button_id_edit_custom_msg == 5);
        text_draw_centered("Reset message", 135, 200, 125, FONT_NORMAL_PLAIN, COLOR_RED);
    }

    else if (custom_message_category == CUSTOM_MESSAGE_TITLE) {
        outer_panel_draw(-100, 0, 21, 10);
        // Title
        text_draw_centered(custom_messages_strings[2], -100, 16, 336, FONT_LARGE_BLACK, COLOR_BLACK);
        input_box_draw(&editor_custom_message_input_title);

        // Reset title
        button_border_draw(5, 110, 125, 25, focus_button_id_edit_custom_msg == 1);
        text_draw_centered("Reset title", 5, 116, 125, FONT_NORMAL_PLAIN, COLOR_RED);
    }

    else if (custom_message_category == CUSTOM_MESSAGE_TEXT) {
        outer_panel_draw(-100, 0, 50, 32);
        // Text
        text_draw_centered(custom_messages_strings[3], -100, 16, 800, FONT_LARGE_BLACK, COLOR_BLACK);
        input_box_draw(&editor_custom_message_input_text);

        // Formatted typed in text
        rich_text_set_fonts(FONT_NORMAL_BLACK, FONT_NORMAL_RED, 6);
        rich_text_init(editor_custom_message_text, -76, 112, 44, 22, 0);
        graphics_set_clip_rectangle(-76, 112, 750, 350);
        draw_text(editor_custom_message_text, -68, 112, 736, 20, 0, 0);
        rich_text_data.num_lines = 0;
        scrollbar_draw(&scrollbar);
        graphics_reset_clip_rectangle();

        // @L, @P hint
        text_draw(common_editor_strings[5], -60, 475, FONT_NORMAL_PLAIN, COLOR_TOOLTIP);

        // Reset text
        button_border_draw(515, 16, 150, 35, focus_button_id_edit_custom_msg == 1);
        text_draw_centered("Reset text", 515, 21, 150, FONT_LARGE_PLAIN, COLOR_RED);
    }

    set_translation(0, 0);
}

static void handle_input_edit_custom_msg(struct mouse_t *m, struct hotkeys_t *h)
{
    if (m->right.went_up || h->escape_pressed) {
        if (custom_message_category == CUSTOM_MESSAGE_ATTRIBUTES) {
            input_box_stop(&editor_custom_message_input_video_file);
            if (!string_equals(scenario.editor_custom_messages[custom_message_id].video_file, editor_custom_message_video_file)) {
                string_copy(editor_custom_message_video_file, scenario.editor_custom_messages[custom_message_id].video_file, MAX_CUSTOM_MESSAGE_VIDEO_TEXT);
            }
        } else if (custom_message_category == CUSTOM_MESSAGE_TITLE) {
            input_box_stop(&editor_custom_message_input_title);
            if (!string_equals(scenario.editor_custom_messages[custom_message_id].title, editor_custom_message_title)) {
                string_copy(editor_custom_message_title, scenario.editor_custom_messages[custom_message_id].title, MAX_CUSTOM_MESSAGE_TITLE);
            }
        } else if (custom_message_category == CUSTOM_MESSAGE_TEXT) {
            input_box_stop(&editor_custom_message_input_text);
            if (!string_equals(scenario.editor_custom_messages[custom_message_id].text, editor_custom_message_text)) {
                string_copy(editor_custom_message_text, scenario.editor_custom_messages[custom_message_id].text, MAX_CUSTOM_MESSAGE_TEXT);
            }
            rich_text_reset(0);
        }
        scenario_editor_sort_custom_messages();
        show_editor_custom_messages();
    }

    struct mouse_t *m_dialog = mouse_in_dialog(m);
    if (custom_message_category == CUSTOM_MESSAGE_ATTRIBUTES) {
        if (generic_buttons_handle_mouse(m_dialog, 0, 0, buttons_edit_custom_message, sizeof(buttons_edit_custom_message) / sizeof(struct generic_button_t), &focus_button_id_edit_custom_msg)) {
            return;
        }
    } else if (custom_message_category == CUSTOM_MESSAGE_TITLE) {
        if (generic_buttons_handle_mouse(m_dialog, 0, 0, reset_title_button, 1, &focus_button_id_edit_custom_msg)) {
            return;
        }
    } else if (custom_message_category == CUSTOM_MESSAGE_TEXT) {
        scrollbar_handle_mouse(&scrollbar, m_dialog);
        if (generic_buttons_handle_mouse(m_dialog, 0, 0, reset_text_button, 1, &focus_button_id_edit_custom_msg)) {
            return;
        }
    }
}

static void show_editor_edit_custom_message(int id, int category)
{
    struct window_type_t window = {
        WINDOW_EDITOR_EDIT_CUSTOM_MESSAGE,
        window_editor_map_draw_all,
        draw_foreground_edit_custom_msg,
        handle_input_edit_custom_msg,
    };
    custom_message_id = id;
    custom_message_category = category;
    if (custom_message_category == CUSTOM_MESSAGE_ATTRIBUTES) {
        string_copy(scenario.editor_custom_messages[id].video_file, editor_custom_message_video_file, MAX_CUSTOM_MESSAGE_TITLE);
        input_box_start(&editor_custom_message_input_video_file);
    } else if (custom_message_category == CUSTOM_MESSAGE_TITLE) {
        string_copy(scenario.editor_custom_messages[id].title, editor_custom_message_title, MAX_CUSTOM_MESSAGE_TITLE);
        input_box_start(&editor_custom_message_input_title);
    } else if (custom_message_category == CUSTOM_MESSAGE_TEXT) {
        string_copy(scenario.editor_custom_messages[id].text, editor_custom_message_text, MAX_CUSTOM_MESSAGE_TEXT);
        input_box_start(&editor_custom_message_input_text);
    }
    window_show(&window);
}

static struct generic_button_t buttons_attributes[] = {
    {-300, 48, 125, 25, show_editor_edit_custom_message, button_none, 0, 0},
    {-300, 78, 125, 25, show_editor_edit_custom_message, button_none, 1, 0},
    {-300, 108, 125, 25, show_editor_edit_custom_message, button_none, 2, 0},
    {-300, 138, 125, 25, show_editor_edit_custom_message, button_none, 3, 0},
    {-300, 168, 125, 25, show_editor_edit_custom_message, button_none, 4, 0},
    {-300, 198, 125, 25, show_editor_edit_custom_message, button_none, 5, 0},
    {-300, 228, 125, 25, show_editor_edit_custom_message, button_none, 6, 0},
    {-300, 258, 125, 25, show_editor_edit_custom_message, button_none, 7, 0},
    {-300, 288, 125, 25, show_editor_edit_custom_message, button_none, 8, 0},
    {-300, 318, 125, 25, show_editor_edit_custom_message, button_none, 9, 0},
    {-300, 348, 125, 25, show_editor_edit_custom_message, button_none, 10, 0},
    {-300, 378, 125, 25, show_editor_edit_custom_message, button_none, 11, 0},
    {-300, 408, 125, 25, show_editor_edit_custom_message, button_none, 12, 0},
    {-300, 438, 125, 25, show_editor_edit_custom_message, button_none, 13, 0},
    {-300, 468, 125, 25, show_editor_edit_custom_message, button_none, 14, 0},
    {100, 48, 125, 25, show_editor_edit_custom_message, button_none, 15, 0},
    {100, 78, 125, 25, show_editor_edit_custom_message, button_none, 16, 0},
    {100, 108, 125, 25, show_editor_edit_custom_message, button_none, 17, 0},
    {100, 138, 125, 25, show_editor_edit_custom_message, button_none, 18, 0},
    {100, 168, 125, 25, show_editor_edit_custom_message, button_none, 19, 0},
    {100, 198, 125, 25, show_editor_edit_custom_message, button_none, 20, 0},
    {100, 228, 125, 25, show_editor_edit_custom_message, button_none, 21, 0},
    {100, 258, 125, 25, show_editor_edit_custom_message, button_none, 22, 0},
    {100, 288, 125, 25, show_editor_edit_custom_message, button_none, 23, 0},
    {100, 318, 125, 25, show_editor_edit_custom_message, button_none, 24, 0},
    {100, 348, 125, 25, show_editor_edit_custom_message, button_none, 25, 0},
    {100, 378, 125, 25, show_editor_edit_custom_message, button_none, 26, 0},
    {100, 408, 125, 25, show_editor_edit_custom_message, button_none, 27, 0},
    {100, 438, 125, 25, show_editor_edit_custom_message, button_none, 28, 0},
    {100, 468, 125, 25, show_editor_edit_custom_message, button_none, 29, 0},
    {500, 48, 125, 25, show_editor_edit_custom_message, button_none, 30, 0},
    {500, 78, 125, 25, show_editor_edit_custom_message, button_none, 31, 0},
    {500, 108, 125, 25, show_editor_edit_custom_message, button_none, 32, 0},
    {500, 138, 125, 25, show_editor_edit_custom_message, button_none, 33, 0},
    {500, 168, 125, 25, show_editor_edit_custom_message, button_none, 34, 0},
    {500, 198, 125, 25, show_editor_edit_custom_message, button_none, 35, 0},
    {500, 228, 125, 25, show_editor_edit_custom_message, button_none, 36, 0},
    {500, 258, 125, 25, show_editor_edit_custom_message, button_none, 37, 0},
    {500, 288, 125, 25, show_editor_edit_custom_message, button_none, 38, 0},
    {500, 318, 125, 25, show_editor_edit_custom_message, button_none, 39, 0},
    {500, 348, 125, 25, show_editor_edit_custom_message, button_none, 39, 0},
    {500, 378, 125, 25, show_editor_edit_custom_message, button_none, 39, 0},
    {500, 408, 125, 25, show_editor_edit_custom_message, button_none, 39, 0},
    {500, 438, 125, 25, show_editor_edit_custom_message, button_none, 39, 0},
    {500, 468, 125, 25, show_editor_edit_custom_message, button_none, 39, 0},
};

static struct generic_button_t buttons_custom_message_title[] = {
    {-170, 48, 125, 25, show_editor_edit_custom_message, button_none, 0, 1},
    {-170, 78, 125, 25, show_editor_edit_custom_message, button_none, 1, 1},
    {-170, 108, 125, 25, show_editor_edit_custom_message, button_none, 2, 1},
    {-170, 138, 125, 25, show_editor_edit_custom_message, button_none, 3, 1},
    {-170, 168, 125, 25, show_editor_edit_custom_message, button_none, 4, 1},
    {-170, 198, 125, 25, show_editor_edit_custom_message, button_none, 5, 1},
    {-170, 228, 125, 25, show_editor_edit_custom_message, button_none, 6, 1},
    {-170, 258, 125, 25, show_editor_edit_custom_message, button_none, 7, 1},
    {-170, 288, 125, 25, show_editor_edit_custom_message, button_none, 8, 1},
    {-170, 318, 125, 25, show_editor_edit_custom_message, button_none, 9, 1},
    {-170, 348, 125, 25, show_editor_edit_custom_message, button_none, 10, 1},
    {-170, 378, 125, 25, show_editor_edit_custom_message, button_none, 11, 1},
    {-170, 408, 125, 25, show_editor_edit_custom_message, button_none, 12, 1},
    {-170, 438, 125, 25, show_editor_edit_custom_message, button_none, 13, 1},
    {-170, 468, 125, 25, show_editor_edit_custom_message, button_none, 14, 1},
    {230, 48, 125, 25, show_editor_edit_custom_message, button_none, 15, 1},
    {230, 78, 125, 25, show_editor_edit_custom_message, button_none, 16, 1},
    {230, 108, 125, 25, show_editor_edit_custom_message, button_none, 17, 1},
    {230, 138, 125, 25, show_editor_edit_custom_message, button_none, 18, 1},
    {230, 168, 125, 25, show_editor_edit_custom_message, button_none, 19, 1},
    {230, 198, 125, 25, show_editor_edit_custom_message, button_none, 20, 1},
    {230, 228, 125, 25, show_editor_edit_custom_message, button_none, 21, 1},
    {230, 258, 125, 25, show_editor_edit_custom_message, button_none, 22, 1},
    {230, 288, 125, 25, show_editor_edit_custom_message, button_none, 23, 1},
    {230, 318, 125, 25, show_editor_edit_custom_message, button_none, 24, 1},
    {230, 348, 125, 25, show_editor_edit_custom_message, button_none, 25, 1},
    {230, 378, 125, 25, show_editor_edit_custom_message, button_none, 26, 1},
    {230, 408, 125, 25, show_editor_edit_custom_message, button_none, 27, 1},
    {230, 438, 125, 25, show_editor_edit_custom_message, button_none, 28, 1},
    {230, 468, 125, 25, show_editor_edit_custom_message, button_none, 29, 1},
    {630, 48, 125, 25, show_editor_edit_custom_message, button_none, 30, 1},
    {630, 78, 125, 25, show_editor_edit_custom_message, button_none, 31, 1},
    {630, 108, 125, 25, show_editor_edit_custom_message, button_none, 32, 1},
    {630, 138, 125, 25, show_editor_edit_custom_message, button_none, 33, 1},
    {630, 168, 125, 25, show_editor_edit_custom_message, button_none, 34, 1},
    {630, 198, 125, 25, show_editor_edit_custom_message, button_none, 35, 1},
    {630, 228, 125, 25, show_editor_edit_custom_message, button_none, 36, 1},
    {630, 258, 125, 25, show_editor_edit_custom_message, button_none, 37, 1},
    {630, 288, 125, 25, show_editor_edit_custom_message, button_none, 38, 1},
    {630, 318, 125, 25, show_editor_edit_custom_message, button_none, 39, 1},
    {630, 348, 125, 25, show_editor_edit_custom_message, button_none, 39, 1},
    {630, 378, 125, 25, show_editor_edit_custom_message, button_none, 39, 1},
    {630, 408, 125, 25, show_editor_edit_custom_message, button_none, 39, 1},
    {630, 438, 125, 25, show_editor_edit_custom_message, button_none, 39, 1},
    {630, 468, 125, 25, show_editor_edit_custom_message, button_none, 39, 1},
};

static struct generic_button_t buttons_custom_message_text[] = {
    {-40, 48, 125, 25, show_editor_edit_custom_message, button_none, 0, 2},
    {-40, 78, 125, 25, show_editor_edit_custom_message, button_none, 1, 2},
    {-40, 108, 125, 25, show_editor_edit_custom_message, button_none, 2, 2},
    {-40, 138, 125, 25, show_editor_edit_custom_message, button_none, 3, 2},
    {-40, 168, 125, 25, show_editor_edit_custom_message, button_none, 4, 2},
    {-40, 198, 125, 25, show_editor_edit_custom_message, button_none, 5, 2},
    {-40, 228, 125, 25, show_editor_edit_custom_message, button_none, 6, 2},
    {-40, 258, 125, 25, show_editor_edit_custom_message, button_none, 7, 2},
    {-40, 288, 125, 25, show_editor_edit_custom_message, button_none, 8, 2},
    {-40, 318, 125, 25, show_editor_edit_custom_message, button_none, 9, 2},
    {-40, 348, 125, 25, show_editor_edit_custom_message, button_none, 10, 2},
    {-40, 378, 125, 25, show_editor_edit_custom_message, button_none, 11, 2},
    {-40, 408, 125, 25, show_editor_edit_custom_message, button_none, 12, 2},
    {-40, 438, 125, 25, show_editor_edit_custom_message, button_none, 13, 2},
    {-40, 468, 125, 25, show_editor_edit_custom_message, button_none, 14, 2},
    {360, 48, 125, 25, show_editor_edit_custom_message, button_none, 15, 2},
    {360, 78, 125, 25, show_editor_edit_custom_message, button_none, 16, 2},
    {360, 108, 125, 25, show_editor_edit_custom_message, button_none, 17, 2},
    {360, 138, 125, 25, show_editor_edit_custom_message, button_none, 18, 2},
    {360, 168, 125, 25, show_editor_edit_custom_message, button_none, 19, 2},
    {360, 198, 125, 25, show_editor_edit_custom_message, button_none, 20, 2},
    {360, 228, 125, 25, show_editor_edit_custom_message, button_none, 21, 2},
    {360, 258, 125, 25, show_editor_edit_custom_message, button_none, 22, 2},
    {360, 288, 125, 25, show_editor_edit_custom_message, button_none, 23, 2},
    {360, 318, 125, 25, show_editor_edit_custom_message, button_none, 24, 2},
    {360, 348, 125, 25, show_editor_edit_custom_message, button_none, 25, 2},
    {360, 378, 125, 25, show_editor_edit_custom_message, button_none, 26, 2},
    {360, 408, 125, 25, show_editor_edit_custom_message, button_none, 27, 2},
    {360, 438, 125, 25, show_editor_edit_custom_message, button_none, 28, 2},
    {360, 468, 125, 25, show_editor_edit_custom_message, button_none, 29, 2},
    {760, 48, 125, 25, show_editor_edit_custom_message, button_none, 30, 2},
    {760, 78, 125, 25, show_editor_edit_custom_message, button_none, 31, 2},
    {760, 108, 125, 25, show_editor_edit_custom_message, button_none, 32, 2},
    {760, 138, 125, 25, show_editor_edit_custom_message, button_none, 33, 2},
    {760, 168, 125, 25, show_editor_edit_custom_message, button_none, 34, 2},
    {760, 198, 125, 25, show_editor_edit_custom_message, button_none, 35, 2},
    {760, 228, 125, 25, show_editor_edit_custom_message, button_none, 36, 2},
    {760, 258, 125, 25, show_editor_edit_custom_message, button_none, 37, 2},
    {760, 288, 125, 25, show_editor_edit_custom_message, button_none, 38, 2},
    {760, 318, 125, 25, show_editor_edit_custom_message, button_none, 39, 2},
    {760, 348, 125, 25, show_editor_edit_custom_message, button_none, 39, 2},
    {760, 378, 125, 25, show_editor_edit_custom_message, button_none, 39, 2},
    {760, 408, 125, 25, show_editor_edit_custom_message, button_none, 39, 2},
    {760, 438, 125, 25, show_editor_edit_custom_message, button_none, 39, 2},
    {760, 468, 125, 25, show_editor_edit_custom_message, button_none, 39, 2},
};

static void draw_foreground_custom_messages(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);

    outer_panel_draw(-320, 0, 77, 32);
    text_draw_centered(custom_messages_strings[0], -320, 16, 1232, FONT_LARGE_BLACK, COLOR_BLACK);

    for (int i = 0; i < MAX_EDITOR_CUSTOM_MESSAGES; i++) {
        int x, y;
        if (i < 15) {
            x = -300;
            y = 48 + 30 * i;
        } else if (i < 30) {
            x = 100;
            y = 48 + 30 * (i - 15);
        } else {
            x = 500;
            y = 48 + 30 * (i - 30);
        }
        button_border_draw(x, y, 125, 25, focus_button_id_attr_custom_messages == i + 1);
        if (scenario.editor_custom_messages[i].enabled) {
            int width = lang_text_draw(25, scenario.editor_custom_messages[i].month, x + 12, y + 6, FONT_NORMAL_BLACK);
            lang_text_draw_year(scenario.start_year + scenario.editor_custom_messages[i].year, x + width + 6, y + 6, FONT_NORMAL_BLACK);
        } else {
            text_draw_centered(custom_messages_strings[1], x, y + 6, 125, FONT_NORMAL_BLACK, COLOR_BLACK);
        }
        int max_preview_length = 12;
        button_border_draw(x + 130, y, 125, 25, focus_button_id_title_custom_messages == i + 1);
        if (scenario.editor_custom_messages[i].title[0] != '\0') {
            char title_preview[max_preview_length + 3];
            string_copy(scenario.editor_custom_messages[i].title, title_preview, max_preview_length);
            if (string_length(scenario.editor_custom_messages[i].title) > max_preview_length) {
                title_preview[max_preview_length - 1] = '.';
                title_preview[max_preview_length] = '.';
                title_preview[max_preview_length + 1] = '.';
                title_preview[max_preview_length + 2] = '\0';
            }
            text_draw(title_preview, x + 138, y + 6, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else {
            text_draw_centered(custom_messages_strings[2], x + 130, y + 6, 125, FONT_NORMAL_BLACK, COLOR_BLACK);
        }
        button_border_draw(x + 260, y, 125, 25, focus_button_id_text_custom_messages == i + 1);
        if (scenario.editor_custom_messages[i].text[0] != '\0') {
            char text_preview[max_preview_length + 3];
            string_copy(scenario.editor_custom_messages[i].text, text_preview, max_preview_length);
            if (string_length(scenario.editor_custom_messages[i].text) > max_preview_length) {
                text_preview[max_preview_length - 1] = '.';
                text_preview[max_preview_length] = '.';
                text_preview[max_preview_length + 1] = '.';
                text_preview[max_preview_length + 2] = '\0';
            }
            text_draw(text_preview, x + 268, y + 6, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else {
            text_draw_centered(custom_messages_strings[3], x + 260, y + 6, 125, FONT_NORMAL_BLACK, COLOR_BLACK);
        }
    }

    set_translation(0, 0);
}

static void handle_input_custom_messages(struct mouse_t *m, struct hotkeys_t *h)
{
    if (generic_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, buttons_attributes, sizeof(buttons_attributes) / sizeof(struct generic_button_t), &focus_button_id_attr_custom_messages)) {
        return;
    }
    if (generic_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, buttons_custom_message_title, sizeof(buttons_custom_message_title) / sizeof(struct generic_button_t), &focus_button_id_title_custom_messages)) {
        return;
    }
    if (generic_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, buttons_custom_message_text, sizeof(buttons_custom_message_text) / sizeof(struct generic_button_t), &focus_button_id_text_custom_messages)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        show_editor_attributes();
    }
}

static void show_editor_custom_messages(void)
{
    struct window_type_t window = {
        WINDOW_EDITOR_CUSTOM_MESSAGES,
        window_editor_map_draw_all,
        draw_foreground_custom_messages,
        handle_input_custom_messages,
    };
    window_show(&window);
}

static void button_custom_messages(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    stop_brief_description_box_input();
    show_editor_custom_messages();
}

static void button_earthquake_severity(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.earthquakes[id_edit_earthquake].severity++;
    switch (scenario.earthquakes[id_edit_earthquake].severity) {
        case 1:
            scenario.earthquakes[id_edit_earthquake].state = 1;
            scenario.earthquakes[id_edit_earthquake].max_duration = 25 + rand() % 32;
            scenario.earthquakes[id_edit_earthquake].max_delay = 10;
            break;
        case 2:
            scenario.earthquakes[id_edit_earthquake].state = 1;
            scenario.earthquakes[id_edit_earthquake].max_duration = 100 + rand() % 64;
            scenario.earthquakes[id_edit_earthquake].max_delay = 8;
            break;
        case 3:
            scenario.earthquakes[id_edit_earthquake].state = 1;
            scenario.earthquakes[id_edit_earthquake].max_duration = 250 + rand() % 128;
            scenario.earthquakes[id_edit_earthquake].max_delay = 6;
            break;
        default:
            scenario.earthquakes[id_edit_earthquake].state = 0;
            scenario.earthquakes[id_edit_earthquake].severity = 0;
            scenario.earthquakes[id_edit_earthquake].max_duration = 0;
            scenario.earthquakes[id_edit_earthquake].max_delay = 0;
            break;
    }
    scenario.is_saved = 0;
    window_data.refresh_on_draw = 1;
}

static void set_month_earthquake(int value)
{
    // Jan is 1 for input/draw purposes
    if (value == 0) {
        value = 1;
    }
    // change month back to 0 indexed before saving
    scenario.earthquakes[id_edit_earthquake].month = value - 1;
}

static void button_earthquake_month(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 115, screen_data.dialog_offset.y + 95, 2, 12, set_month_earthquake);
}

static void set_year_earthquake(int value)
{
    scenario.earthquakes[id_edit_earthquake].year = value;
}

static void button_earthquake_year(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 115, screen_data.dialog_offset.y + 65, 3, 999, set_year_earthquake);
}

static void set_earthquake_point(int value)
{
    scenario.earthquakes[id_edit_earthquake].point = value;
}

static void button_earthquake_point(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_select_list_show_text(screen_data.dialog_offset.x + 330, screen_data.dialog_offset.y + 165, earthquake_point_names, MAX_EARTHQUAKE_POINTS, set_earthquake_point);
}

static void scenario_editor_sort_earthquakes(void)
{
    for (int i = 0; i < MAX_EARTHQUAKES; i++) {
        for (int j = MAX_EARTHQUAKES - 1; j > 0; j--) {
            if (scenario.earthquakes[j].state) {
                // if no previous earthquake scheduled, move current back until first; if previous earthquake is later than current, swap
                if (!scenario.earthquakes[j - 1].state || scenario.earthquakes[j - 1].year > scenario.earthquakes[j].year
                || (scenario.earthquakes[j - 1].year == scenario.earthquakes[j].year && scenario.earthquakes[j - 1].month > scenario.earthquakes[j].month)) {
                    struct earthquake_t tmp = scenario.earthquakes[j];
                    scenario.earthquakes[j] = scenario.earthquakes[j - 1];
                    scenario.earthquakes[j - 1] = tmp;
                }
            }
        }
    }
    scenario.is_saved = 0;
}

static void show_editor_earthquakes(void);
static void button_delete_earthquake(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.earthquakes[id_edit_earthquake].state = 0;
    scenario.earthquakes[id_edit_earthquake].severity = 0;
    scenario.earthquakes[id_edit_earthquake].month = 0;
    scenario.earthquakes[id_edit_earthquake].year = 1;
    scenario.earthquakes[id_edit_earthquake].duration = 0;
    scenario.earthquakes[id_edit_earthquake].max_duration = 0;
    scenario.earthquakes[id_edit_earthquake].delay = 0;
    scenario.earthquakes[id_edit_earthquake].max_delay = 0;
    scenario.earthquakes[id_edit_earthquake].point = 0;
    for (int i = 0; i < MAX_EARTHQUAKE_BRANCHES; i++) {
        scenario.earthquakes[id_edit_earthquake].branch_coordinates[i].x = -1;
        scenario.earthquakes[id_edit_earthquake].branch_coordinates[i].y = -1;
    }
    scenario_editor_sort_earthquakes();
    show_editor_earthquakes();
}

static struct generic_button_t buttons_edit_earthquake[] = {
    {130, 152, 100, 25, button_earthquake_year, button_none, 0, 0},
    {130, 182, 100, 25, button_earthquake_month, button_none, 0, 0},
    {130, 212, 100, 25, button_earthquake_severity, button_none, 0, 0},
    {130, 242, 200, 25, button_earthquake_point, button_none, 0, 0},
    {130, 282, 200, 25, button_delete_earthquake, button_none, 0, 0},
};

static void draw_foreground_edit_earthquake(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);

    outer_panel_draw(0, 100, 29, 14);
    // Scheduling an earthquake
    text_draw_centered("Scheduling an earthquake", 0, 116, 464, FONT_LARGE_BLACK, COLOR_BLACK);

    // Year offset
    text_draw(common_editor_strings[0], 30, 158, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(130, 152, 100, 25, focus_button_id_edit_earthquake == 1);
    text_draw_number_centered_prefix(scenario.earthquakes[id_edit_earthquake].year, '+', 132, 158, 100, FONT_NORMAL_BLACK);
    lang_text_draw_year(scenario.start_year + scenario.earthquakes[id_edit_earthquake].year, 240, 158, FONT_NORMAL_BLACK);

    // Month
    text_draw(common_editor_strings[1], 30, 188, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(130, 182, 100, 25, focus_button_id_edit_earthquake == 2);
    text_draw_number_centered(scenario.earthquakes[id_edit_earthquake].month + 1, 130, 188, 100, FONT_NORMAL_BLACK);

    // Invalid year/month combination
    if (scenario.earthquakes[id_edit_earthquake].year == 0 && scenario.earthquakes[id_edit_earthquake].month == 0) {
        text_draw(common_editor_strings[2], 245, 188, FONT_NORMAL_PLAIN, COLOR_RED);
    }

    // Severity
    lang_text_draw(38, 1, 30, 218, FONT_NORMAL_BLACK);
    button_border_draw(130, 212, 100, 25, focus_button_id_edit_earthquake == 3);
    lang_text_draw_centered(40, scenario.earthquakes[id_edit_earthquake].severity, 130, 218, 100, FONT_NORMAL_BLACK);

    // Point
    text_draw("Point", 30, 248, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(130, 242, 200, 25, focus_button_id_edit_earthquake == 4);
    text_draw_centered(earthquakes_strings[scenario.earthquakes[id_edit_earthquake].point + 2], 130, 248, 200, FONT_NORMAL_BLACK, COLOR_BLACK);

    // Cancel earthquake
    button_border_draw(130, 282, 200, 25, focus_button_id_edit_earthquake == 5);
    text_draw_centered("Cancel earthquake", 130, 288, 200, FONT_NORMAL_BLACK, COLOR_BLACK);

    set_translation(0, 0);
}

static void handle_input_edit_earthquake(struct mouse_t *m, struct hotkeys_t *h)
{
    if (generic_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, buttons_edit_earthquake, sizeof(buttons_edit_earthquake) / sizeof(struct generic_button_t), &focus_button_id_edit_earthquake)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        scenario_editor_sort_earthquakes();
        show_editor_earthquakes();
    }
}

static void show_editor_edit_earthquake(int id, __attribute__((unused)) int param2)
{
    struct window_type_t window = {
        WINDOW_EDITOR_EDIT_EARTHQUAKE,
        window_editor_map_draw_all,
        draw_foreground_edit_earthquake,
        handle_input_edit_earthquake,
    };
    id_edit_earthquake = id;
    for (int i = 0; i <= MAX_EARTHQUAKE_POINTS; i++) {
        earthquake_point_names[i] = earthquakes_strings[i + 2];
    }
    window_show(&window);
}

static struct generic_button_t buttons_earthquake[] = {
    {24, 64, 350, 25, show_editor_edit_earthquake, button_none, 0, 0},
    {24, 94, 350, 25, show_editor_edit_earthquake, button_none, 1, 0},
    {24, 124, 350, 25, show_editor_edit_earthquake, button_none, 2, 0},
    {24, 154, 350, 25, show_editor_edit_earthquake, button_none, 3, 0},
    {24, 184, 350, 25, show_editor_edit_earthquake, button_none, 4, 0},
    {24, 214, 350, 25, show_editor_edit_earthquake, button_none, 5, 0},
    {24, 244, 350, 25, show_editor_edit_earthquake, button_none, 6, 0},
    {24, 274, 350, 25, show_editor_edit_earthquake, button_none, 7, 0},
    {24, 304, 350, 25, show_editor_edit_earthquake, button_none, 8, 0},
    {24, 334, 350, 25, show_editor_edit_earthquake, button_none, 9, 0},
};

static void draw_foreground_earthquakes(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);

    outer_panel_draw(0, 0, 25, 25);
    text_draw_centered(earthquakes_strings[0], 0, 16, 400, FONT_LARGE_BLACK, COLOR_BLACK);

    for (int i = 0; i < MAX_EARTHQUAKES; i++) {
        int x, y;
        x = 24;
        y = 64 + 30 * i;
        button_border_draw(x, y, 350, 25, focus_button_id_earthquakes == i + 1);

        if (scenario.earthquakes[i].state) {
            int width = lang_text_draw(25, scenario.earthquakes[i].month, x + 12, y + 6, FONT_NORMAL_BLACK);
            width += lang_text_draw_year(scenario.start_year + scenario.earthquakes[i].year, x + 6 + width, y + 6, FONT_NORMAL_BLACK);
            width += lang_text_draw(40, scenario.earthquakes[i].severity, x + 15 + width, y + 6, FONT_NORMAL_BLACK);
            text_draw(earthquakes_strings[scenario.earthquakes[i].point + 2], x + 15 + width, y + 6, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else {
            text_draw_centered(earthquakes_strings[1], x, y + 6, 350, FONT_NORMAL_BLACK, COLOR_BLACK);
        }
    }

    set_translation(0, 0);
}

static void handle_input_earthquakes(struct mouse_t *m, struct hotkeys_t *h)
{
    if (generic_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, buttons_earthquake, sizeof(buttons_earthquake) / sizeof(struct generic_button_t), &focus_button_id_earthquakes)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        show_editor_attributes();
    }
}

static void show_editor_earthquakes(void)
{
    struct window_type_t window = {
        WINDOW_EDITOR_EARTHQUAKES,
        window_editor_map_draw_all,
        draw_foreground_earthquakes,
        handle_input_earthquakes,
    };
    window_show(&window);
}

static void button_earthquakes(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    stop_brief_description_box_input();
    show_editor_earthquakes();
}

static void set_year_invasion(int value)
{
    scenario.invasions[id_edit_invasion].year_offset = value;
}

static void button_year_invasion(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 115, screen_data.dialog_offset.y + 65, 3, 999, set_year_invasion);
}

static void set_month_invasion(int value)
{
    // Jan is 1 for input/draw purposes
    if (value == 0) {
        value = 1;
    }
    // change month back to 0 indexed before saving
    scenario.invasions[id_edit_invasion].month = value - 1;
}

static void button_month_invasion(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 115, screen_data.dialog_offset.y + 95, 2, 12, set_month_invasion);
}

static void set_amount_invasion(int value)
{
    scenario.invasions[id_edit_invasion].amount = value;
}

static void button_amount_invasion(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    // if this is set to 0, you get the incoming battle messages, but the enemies never show up... could be a cool trick for a map
    window_numeric_input_show(screen_data.dialog_offset.x + 115, screen_data.dialog_offset.y + 125, 3, 200, set_amount_invasion);
}

static void set_type_invasion(int value)
{
    scenario.invasions[id_edit_invasion].type = value;
}

static void button_type_invasion(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_select_list_show_text(screen_data.dialog_offset.x + 350, screen_data.dialog_offset.y + 197, invasion_type_names, INVASION_TYPE_MAX_COUNT, set_type_invasion);
}

static void set_enemy_type(int value)
{
    scenario.invasions[id_edit_invasion].enemy_type = value;
}

static void button_enemy_type(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    if (scenario.invasions[id_edit_invasion].type == INVASION_TYPE_ENEMY_ARMY) {
        window_select_list_show_text(screen_data.dialog_offset.x + 350, screen_data.dialog_offset.y + 80, enemy_type_names, ENEMY_TYPE_MAX_COUNT, set_enemy_type);
    }
}

static void set_from_invasion(int value)
{
    scenario.invasions[id_edit_invasion].from = value;
}

static void button_from_invasion(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    if (scenario.invasions[id_edit_invasion].type != INVASION_TYPE_DISTANT_BATTLE && scenario.invasions[id_edit_invasion].type != INVASION_TYPE_CAESAR) {
        window_select_list_show(screen_data.dialog_offset.x + 350, screen_data.dialog_offset.y + 225, 35, 9, set_from_invasion);
    }
}

static void set_attack_type(int value)
{
    scenario.invasions[id_edit_invasion].target_type = value;
}

static void button_attack_type(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    if (scenario.invasions[id_edit_invasion].type != INVASION_TYPE_DISTANT_BATTLE) {
        window_select_list_show(screen_data.dialog_offset.x + 350, screen_data.dialog_offset.y + 285, 36, 5, set_attack_type);
    }
}

static void sort_editor_invasions(void)
{
    for (int i = 0; i < MAX_INVASIONS; i++) {
        for (int j = MAX_INVASIONS - 1; j > 0; j--) {
            if (scenario.invasions[j].type) {
                // if no previous invasion scheduled, move current back until first; if previous invasion is later than current, swap
                if (!scenario.invasions[j - 1].type || scenario.invasions[j - 1].year_offset > scenario.invasions[j].year_offset
                || (scenario.invasions[j - 1].year_offset == scenario.invasions[j].year_offset && scenario.invasions[j - 1].month > scenario.invasions[j].month)) {
                    struct invasion_t tmp = scenario.invasions[j];
                    scenario.invasions[j] = scenario.invasions[j - 1];
                    scenario.invasions[j - 1] = tmp;
                }
            }
        }
    }
    scenario.is_saved = 0;
}

static void show_editor_invasions(void);
static void button_delete_invasion(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.invasions[id_edit_invasion].year_offset = 1;
    scenario.invasions[id_edit_invasion].month = 0;
    scenario.invasions[id_edit_invasion].amount = 0;
    scenario.invasions[id_edit_invasion].type = 0;
    scenario.invasions[id_edit_invasion].from = 8;
    scenario.invasions[id_edit_invasion].target_type = 0;
    sort_editor_invasions();
    show_editor_invasions();
}

static struct generic_button_t buttons_edit_invasion[] = {
    {145, 152, 60, 25, button_year_invasion, button_none, 0, 0},
    {145, 182, 60, 25, button_month_invasion, button_none, 0, 0},
    {145, 212, 60, 25, button_amount_invasion, button_none, 0, 0},
    {145, 242, 200, 25, button_type_invasion, button_none, 0, 0},
    {145, 272, 200, 25, button_enemy_type, button_none, 0, 0},
    {145, 302, 200, 25, button_from_invasion, button_none, 0, 0},
    {145, 332, 200, 25, button_attack_type, button_none, 0, 0},
    {90, 372, 200, 25, button_delete_invasion, button_none, 0, 0},
};

static void draw_foreground_edit_invasion(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);

    outer_panel_draw(0, 100, 24, 20);
    // Scheduling an invasion
    lang_text_draw_centered(44, 22, 0, 116, 384, FONT_LARGE_BLACK);

    // Year offset
    text_draw(common_editor_strings[0], 30, 158, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(145, 152, 60, 25, focus_button_id_edit_invasion == 1);
    text_draw_number_centered_prefix(scenario.invasions[id_edit_invasion].year_offset, '+', 147, 158, 60, FONT_NORMAL_BLACK);
    lang_text_draw_year(scenario.start_year + scenario.invasions[id_edit_invasion].year_offset, 215, 158, FONT_NORMAL_BLACK);

    // Month
    text_draw(common_editor_strings[1], 30, 188, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(145, 182, 60, 25, focus_button_id_edit_invasion == 2);
    text_draw_number_centered(scenario.invasions[id_edit_invasion].month + 1, 145, 188, 60, FONT_NORMAL_BLACK);

    // Invalid year/month combination
    if (scenario.invasions[id_edit_invasion].year_offset == 0 && scenario.invasions[id_edit_invasion].month == 0) {
        text_draw(common_editor_strings[2], 220, 188, FONT_NORMAL_PLAIN, COLOR_RED);
    }

    // Amount
    text_draw(common_editor_strings[3], 30, 218, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(145, 212, 60, 25, focus_button_id_edit_invasion == 3);
    text_draw_number_centered(scenario.invasions[id_edit_invasion].amount, 145, 218, 60, FONT_NORMAL_BLACK);

    // Type
    text_draw("Type:", 30, 248, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(145, 242, 200, 25, focus_button_id_edit_invasion == 4);
    text_draw_centered(invasions_enemy_army_type_strings[scenario.invasions[id_edit_invasion].type], 145, 248, 200, FONT_NORMAL_BLACK, COLOR_BLACK);

    if (scenario.invasions[id_edit_invasion].type != INVASION_TYPE_DISTANT_BATTLE) {
        if (scenario.invasions[id_edit_invasion].type == INVASION_TYPE_LOCAL_UPRISING || scenario.invasions[id_edit_invasion].type == INVASION_TYPE_ENEMY_ARMY) {
            if (scenario.invasions[id_edit_invasion].type == INVASION_TYPE_ENEMY_ARMY) {
                // Enemy type
                button_border_draw(145, 272, 200, 25, focus_button_id_edit_invasion == 5);
                text_draw_centered(invasions_enemy_type_strings[scenario.invasions[id_edit_invasion].enemy_type], 145, 278, 200, FONT_NORMAL_BLACK, COLOR_BLACK);
            }
            // From
            text_draw("From:", 30, 308, FONT_NORMAL_BLACK, COLOR_BLACK);
            button_border_draw(145, 302, 200, 25, focus_button_id_edit_invasion == 6);
            lang_text_draw_centered(35, scenario.invasions[id_edit_invasion].from, 145, 308, 200, FONT_NORMAL_BLACK);
        }
        // Attack type
        text_draw("Target type:", 30, 338, FONT_NORMAL_BLACK, COLOR_BLACK);
        button_border_draw(145, 332, 200, 25, focus_button_id_edit_invasion == 7);
        lang_text_draw_centered(36, scenario.invasions[id_edit_invasion].target_type, 145, 338, 200, FONT_NORMAL_BLACK);
    }

    // Unschedule invasion
    button_border_draw(90, 372, 200, 25, focus_button_id_edit_invasion == 8);
    lang_text_draw_centered(44, 26, 90, 378, 200, FONT_NORMAL_BLACK);

    set_translation(0, 0);
}

static void handle_input_edit_invasion(struct mouse_t *m, struct hotkeys_t *h)
{
    if (generic_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, buttons_edit_invasion, sizeof(buttons_edit_invasion) / sizeof(struct generic_button_t), &focus_button_id_edit_invasion)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        sort_editor_invasions();
        show_editor_invasions();
    }
}

static void show_editor_edit_invasion(int id, __attribute__((unused)) int param2)
{
    struct window_type_t window = {
        WINDOW_EDITOR_EDIT_INVASION,
        window_editor_map_draw_all,
        draw_foreground_edit_invasion,
        handle_input_edit_invasion,
    };
    id_edit_invasion = id;
    for (int i = 0; i < INVASION_TYPE_MAX_COUNT; i++) {
        invasion_type_names[i] = invasions_enemy_army_type_strings[i];
    }
    for (int i = 0; i < ENEMY_TYPE_MAX_COUNT; i++) {
        enemy_type_names[i] = invasions_enemy_type_strings[i];
    }
    window_show(&window);
}

static struct generic_button_t buttons_invasions[] = {
    {-300, 48, 290, 25, show_editor_edit_invasion, button_none, 0, 0},
    {-300, 78, 290, 25, show_editor_edit_invasion, button_none, 1, 0},
    {-300, 108, 290, 25, show_editor_edit_invasion, button_none, 2, 0},
    {-300, 138, 290, 25, show_editor_edit_invasion, button_none, 3, 0},
    {-300, 168, 290, 25, show_editor_edit_invasion, button_none, 4, 0},
    {-300, 198, 290, 25, show_editor_edit_invasion, button_none, 5, 0},
    {-300, 228, 290, 25, show_editor_edit_invasion, button_none, 6, 0},
    {-300, 258, 290, 25, show_editor_edit_invasion, button_none, 7, 0},
    {-300, 288, 290, 25, show_editor_edit_invasion, button_none, 8, 0},
    {-300, 318, 290, 25, show_editor_edit_invasion, button_none, 9, 0},
    {0, 48, 290, 25, show_editor_edit_invasion, button_none, 10, 0},
    {0, 78, 290, 25, show_editor_edit_invasion, button_none, 11, 0},
    {0, 108, 290, 25, show_editor_edit_invasion, button_none, 12, 0},
    {0, 138, 290, 25, show_editor_edit_invasion, button_none, 13, 0},
    {0, 168, 290, 25, show_editor_edit_invasion, button_none, 14, 0},
    {0, 198, 290, 25, show_editor_edit_invasion, button_none, 15, 0},
    {0, 228, 290, 25, show_editor_edit_invasion, button_none, 16, 0},
    {0, 258, 290, 25, show_editor_edit_invasion, button_none, 17, 0},
    {0, 288, 290, 25, show_editor_edit_invasion, button_none, 18, 0},
    {0, 318, 290, 25, show_editor_edit_invasion, button_none, 19, 0},
    {300, 48, 290, 25, show_editor_edit_invasion, button_none, 20, 0},
    {300, 78, 290, 25, show_editor_edit_invasion, button_none, 21, 0},
    {300, 108, 290, 25, show_editor_edit_invasion, button_none, 22, 0},
    {300, 138, 290, 25, show_editor_edit_invasion, button_none, 23, 0},
    {300, 168, 290, 25, show_editor_edit_invasion, button_none, 24, 0},
    {300, 198, 290, 25, show_editor_edit_invasion, button_none, 25, 0},
    {300, 228, 290, 25, show_editor_edit_invasion, button_none, 26, 0},
    {300, 258, 290, 25, show_editor_edit_invasion, button_none, 27, 0},
    {300, 288, 290, 25, show_editor_edit_invasion, button_none, 28, 0},
    {300, 318, 290, 25, show_editor_edit_invasion, button_none, 29, 0},
    {600, 48, 290, 25, show_editor_edit_invasion, button_none, 30, 0},
    {600, 78, 290, 25, show_editor_edit_invasion, button_none, 31, 0},
    {600, 108, 290, 25, show_editor_edit_invasion, button_none, 32, 0},
    {600, 138, 290, 25, show_editor_edit_invasion, button_none, 33, 0},
    {600, 168, 290, 25, show_editor_edit_invasion, button_none, 34, 0},
    {600, 198, 290, 25, show_editor_edit_invasion, button_none, 35, 0},
    {600, 228, 290, 25, show_editor_edit_invasion, button_none, 36, 0},
    {600, 258, 290, 25, show_editor_edit_invasion, button_none, 37, 0},
    {600, 288, 290, 25, show_editor_edit_invasion, button_none, 38, 0},
    {600, 318, 290, 25, show_editor_edit_invasion, button_none, 39, 0},
};

static void draw_foreground_invasions(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);

    outer_panel_draw(-320, 0, 77, 26);
    lang_text_draw_centered(44, 15, -320, 16, 1232, FONT_LARGE_BLACK);

    for (int i = 0; i < MAX_INVASIONS; i++) {
        int x, y;
        if (i < 10) {
            x = -300;
            y = 48 + 30 * i;
        } else if (i < 20) {
            x = 0;
            y = 48 + 30 * (i - 10);
        } else if (i < 30) {
            x = 300;
            y = 48 + 30 * (i - 20);
        } else {
            x = 600;
            y = 48 + 30 * (i - 30);
        }
        button_border_draw(x, y, 290, 25, focus_button_id_invasions == i + 1);
        if (scenario.invasions[i].type) {
            int width = lang_text_draw(25, scenario.invasions[i].month, x + 12, y + 6, FONT_NORMAL_BLACK);
            width += lang_text_draw_year(scenario.start_year + scenario.invasions[i].year_offset, x + 6 + width, y + 6, FONT_NORMAL_BLACK);
            width += text_draw_number(scenario.invasions[i].amount, 0, 0, x + 12 + width, y + 6, FONT_NORMAL_BLACK);
            if (scenario.invasions[i].type == INVASION_TYPE_ENEMY_ARMY) {
                char *enemy_type_text = invasions_enemy_type_strings[scenario.invasions[i].enemy_type];
                text_draw(enemy_type_text, x - 12 + width + (290 - width - text_get_width(enemy_type_text, FONT_NORMAL_BLACK)), y + 6, FONT_NORMAL_BLACK, COLOR_BLACK);
            } else {
                char *invasions_type_text = invasions_enemy_army_type_strings[scenario.invasions[i].type];
                text_draw(invasions_type_text, x - 12 + width + (290 - width - text_get_width(invasions_type_text, FONT_NORMAL_BLACK)), y + 6, FONT_NORMAL_BLACK, COLOR_BLACK);
            }
        } else {
            lang_text_draw_centered(44, 23, x, y + 6, 290, FONT_NORMAL_BLACK);
        }
    }

    // invasions hint
    lang_text_draw_multiline(152, 2, -280, 360, 1200, FONT_NORMAL_BLACK);

    set_translation(0, 0);
}

static void handle_input_invasions(struct mouse_t *m, struct hotkeys_t *h)
{
    if (generic_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, buttons_invasions, sizeof(buttons_invasions) / sizeof(struct generic_button_t), &focus_button_id_invasions)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        show_editor_attributes();
    }
}

static void show_editor_invasions(void)
{
    struct window_type_t window = {
        WINDOW_EDITOR_INVASIONS,
        window_editor_map_draw_all,
        draw_foreground_invasions,
        handle_input_invasions,
    };
    window_show(&window);
}

static void show_editor_edit_invasions(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    stop_brief_description_box_input();
    show_editor_invasions();
}

static void set_year_price_change(int value)
{
    scenario.price_changes[id_edit_price_change].year = value;
}

static void button_year_price_change(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 115, screen_data.dialog_offset.y + 65, 3, 999, set_year_price_change);
}

static void set_month_price_change(int value)
{
    // Jan is 1 for input/draw purposes
    if (value == 0) {
        value = 1;
    }
    // change month back to 0 indexed before saving
    scenario.price_changes[id_edit_price_change].month = value - 1;
}

static void button_month_price_change(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 115, screen_data.dialog_offset.y + 95, 2, 12, set_month_price_change);
}

static void set_resource_price_change(int value)
{
    scenario.price_changes[id_edit_price_change].resource = value;
}

static void button_resource_price_change(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_select_list_show_text(screen_data.dialog_offset.x + 80, screen_data.dialog_offset.y + 55, resource_strings, RESOURCE_TYPES_MAX, set_resource_price_change);
}

static void button_toggle_rise_price_change(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.price_changes[id_edit_price_change].is_rise = !scenario.price_changes[id_edit_price_change].is_rise;
}

static void set_amount_price_change(int value)
{
    // don't allow 0
    scenario.price_changes[id_edit_price_change].amount = value ? value : 1;
}

static void button_amount_price_change(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 330, screen_data.dialog_offset.y + 125, 2, 99, set_amount_price_change);
}

static void sort_editor_price_changes(void)
{
    for (int i = 0; i < MAX_PRICE_CHANGES; i++) {
        for (int j = MAX_PRICE_CHANGES - 1; j > 0; j--) {
            if (scenario.price_changes[j].resource) {
                // if no previous price change scheduled, move current back until first; if previous price change is later than current, swap
                if (!scenario.price_changes[j - 1].resource || scenario.price_changes[j - 1].year > scenario.price_changes[j].year
                || (scenario.price_changes[j - 1].year == scenario.price_changes[j].year && scenario.price_changes[j - 1].month > scenario.price_changes[j].month)) {
                    struct price_change_t tmp = scenario.price_changes[j];
                    scenario.price_changes[j] = scenario.price_changes[j - 1];
                    scenario.price_changes[j - 1] = tmp;
                }
            }
        }
    }
    scenario.is_saved = 0;
}

static void show_editor_price_changes(void);
static void button_delete_price_change(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.price_changes[id_edit_price_change].year = 1;
    scenario.price_changes[id_edit_price_change].month = 0;
    scenario.price_changes[id_edit_price_change].resource = 0;
    scenario.price_changes[id_edit_price_change].is_rise = 0;
    scenario.price_changes[id_edit_price_change].amount = 1;
    sort_editor_price_changes();
    show_editor_price_changes();
}

static struct generic_button_t buttons_edit_price_change[] = {
    {130, 152, 100, 25, button_year_price_change, button_none, 0, 0},
    {130, 182, 100, 25, button_month_price_change, button_none, 0, 0},
    {130, 212, 100, 25, button_resource_price_change, button_none, 0, 0},
    {250, 212, 100, 25, button_toggle_rise_price_change, button_none, 0, 0},
    {355, 212, 100, 25, button_amount_price_change, button_none, 0, 0},
    {138, 252, 200, 25, button_delete_price_change, button_none, 0, 0},
};

static void draw_foreground_edit_price_change(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);

    outer_panel_draw(0, 100, 29, 12);
    // Price changes
    lang_text_draw_centered(44, 95, 0, 116, 464, FONT_LARGE_BLACK);

    // Year offset
    text_draw(common_editor_strings[0], 30, 158, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(130, 152, 100, 25, focus_button_id_edit_price_change == 1);
    text_draw_number_centered_prefix(scenario.price_changes[id_edit_price_change].year, '+', 132, 158, 100, FONT_NORMAL_BLACK);
    lang_text_draw_year(scenario.start_year + scenario.price_changes[id_edit_price_change].year, 240, 158, FONT_NORMAL_BLACK);

    // Month
    text_draw(common_editor_strings[1], 30, 188, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(130, 182, 100, 25, focus_button_id_edit_price_change == 2);
    text_draw_number_centered(scenario.price_changes[id_edit_price_change].month + 1, 130, 188, 100, FONT_NORMAL_BLACK);

    // Invalid year/month combination
    if (scenario.price_changes[id_edit_price_change].year == 0 && scenario.price_changes[id_edit_price_change].month == 0) {
        text_draw(common_editor_strings[2], 245, 188, FONT_NORMAL_PLAIN, COLOR_RED);
    }

    // Resource
    text_draw(common_editor_strings[4], 30, 218, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(130, 212, 100, 25, focus_button_id_edit_price_change == 3);
    text_draw_centered(resource_strings[scenario.price_changes[id_edit_price_change].resource], 130, 218, 100, FONT_NORMAL_BLACK, COLOR_BLACK);

    // Rises/falls by
    button_border_draw(235, 212, 100, 25, focus_button_id_edit_price_change == 4);
    lang_text_draw_centered(44, scenario.price_changes[id_edit_price_change].is_rise ? 104 : 103, 235, 218, 100, FONT_NORMAL_BLACK);

    // Amount
    button_border_draw(340, 212, 100, 25, focus_button_id_edit_price_change == 5);
    text_draw_number_centered(scenario.price_changes[id_edit_price_change].amount, 340, 218, 100, FONT_NORMAL_BLACK);

    // Cancel price change
    button_border_draw(130, 252, 200, 25, focus_button_id_edit_price_change == 6);
    lang_text_draw_centered(44, 105, 130, 258, 200, FONT_NORMAL_BLACK);

    set_translation(0, 0);
}

static void handle_input_edit_price_change(struct mouse_t *m, struct hotkeys_t *h)
{
    if (generic_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, buttons_edit_price_change, sizeof(buttons_edit_price_change) / sizeof(struct generic_button_t), &focus_button_id_edit_price_change)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        sort_editor_price_changes();
        show_editor_price_changes();
    }
}

static void show_editor_edit_price_change(int id, __attribute__((unused)) int param2)
{
    struct window_type_t window = {
        WINDOW_EDITOR_EDIT_PRICE_CHANGE,
        window_editor_map_draw_all,
        draw_foreground_edit_price_change,
        handle_input_edit_price_change,
    };
    id_edit_price_change = id;
    window_show(&window);
}

static struct generic_button_t buttons_price_changes[] = {
    {-300, 48, 290, 25, show_editor_edit_price_change, button_none, 0, 0},
    {-300, 78, 290, 25, show_editor_edit_price_change, button_none, 1, 0},
    {-300, 108, 290, 25, show_editor_edit_price_change, button_none, 2, 0},
    {-300, 138, 290, 25, show_editor_edit_price_change, button_none, 3, 0},
    {-300, 168, 290, 25, show_editor_edit_price_change, button_none, 4, 0},
    {-300, 198, 290, 25, show_editor_edit_price_change, button_none, 5, 0},
    {-300, 228, 290, 25, show_editor_edit_price_change, button_none, 6, 0},
    {-300, 258, 290, 25, show_editor_edit_price_change, button_none, 7, 0},
    {-300, 288, 290, 25, show_editor_edit_price_change, button_none, 8, 0},
    {-300, 318, 290, 25, show_editor_edit_price_change, button_none, 9, 0},
    {0, 48, 290, 25, show_editor_edit_price_change, button_none, 10, 0},
    {0, 78, 290, 25, show_editor_edit_price_change, button_none, 11, 0},
    {0, 108, 290, 25, show_editor_edit_price_change, button_none, 12, 0},
    {0, 138, 290, 25, show_editor_edit_price_change, button_none, 13, 0},
    {0, 168, 290, 25, show_editor_edit_price_change, button_none, 14, 0},
    {0, 198, 290, 25, show_editor_edit_price_change, button_none, 15, 0},
    {0, 228, 290, 25, show_editor_edit_price_change, button_none, 16, 0},
    {0, 258, 290, 25, show_editor_edit_price_change, button_none, 17, 0},
    {0, 288, 290, 25, show_editor_edit_price_change, button_none, 18, 0},
    {0, 318, 290, 25, show_editor_edit_price_change, button_none, 19, 0},
    {300, 48, 290, 25, show_editor_edit_price_change, button_none, 20, 0},
    {300, 78, 290, 25, show_editor_edit_price_change, button_none, 21, 0},
    {300, 108, 290, 25, show_editor_edit_price_change, button_none, 22, 0},
    {300, 138, 290, 25, show_editor_edit_price_change, button_none, 23, 0},
    {300, 168, 290, 25, show_editor_edit_price_change, button_none, 24, 0},
    {300, 198, 290, 25, show_editor_edit_price_change, button_none, 25, 0},
    {300, 228, 290, 25, show_editor_edit_price_change, button_none, 26, 0},
    {300, 258, 290, 25, show_editor_edit_price_change, button_none, 27, 0},
    {300, 288, 290, 25, show_editor_edit_price_change, button_none, 28, 0},
    {300, 318, 290, 25, show_editor_edit_price_change, button_none, 29, 0},
    {600, 48, 290, 25, show_editor_edit_price_change, button_none, 30, 0},
    {600, 78, 290, 25, show_editor_edit_price_change, button_none, 31, 0},
    {600, 108, 290, 25, show_editor_edit_price_change, button_none, 32, 0},
    {600, 138, 290, 25, show_editor_edit_price_change, button_none, 33, 0},
    {600, 168, 290, 25, show_editor_edit_price_change, button_none, 34, 0},
    {600, 198, 290, 25, show_editor_edit_price_change, button_none, 35, 0},
    {600, 228, 290, 25, show_editor_edit_price_change, button_none, 36, 0},
    {600, 258, 290, 25, show_editor_edit_price_change, button_none, 37, 0},
    {600, 288, 290, 25, show_editor_edit_price_change, button_none, 38, 0},
    {600, 318, 290, 25, show_editor_edit_price_change, button_none, 39, 0},
};

static void draw_foreground_price_changes(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);

    outer_panel_draw(-320, 0, 77, 26);
    lang_text_draw_centered(44, 95, -320, 16, 1232, FONT_LARGE_BLACK);

    for (int i = 0; i < MAX_PRICE_CHANGES; i++) {
        int x, y;
        if (i < 10) {
            x = -300;
            y = 48 + 30 * i;
        } else if (i < 20) {
            x = 0;
            y = 48 + 30 * (i - 10);
        } else if (i < 30) {
            x = 300;
            y = 48 + 30 * (i - 20);
        } else {
            x = 600;
            y = 48 + 30 * (i - 30);
        }
        button_border_draw(x, y, 290, 25, focus_button_id_price_changes == i + 1);

        if (scenario.price_changes[i].resource) {
            int width = lang_text_draw(25, scenario.price_changes[i].month, x + 12, y + 6, FONT_NORMAL_BLACK);
            width += lang_text_draw_year(scenario.start_year + scenario.price_changes[i].year, x + 6 + width, y + 6, FONT_NORMAL_BLACK);
            image_draw(resource_images[scenario.price_changes[i].resource].editor_icon_img_id + resource_image_offset(scenario.price_changes[i].resource, RESOURCE_IMAGE_ICON), x + 12 + width, y + 3);
            width += lang_text_draw(44, scenario.price_changes[i].is_rise ? 104 : 103, x + 45 + width, y + 6, FONT_NORMAL_BLACK);
            text_draw_number(scenario.price_changes[i].amount, 0, 0, x + 45 + width, y + 6, FONT_NORMAL_BLACK);
        } else {
            lang_text_draw_centered(44, 102, x, y + 6, 290, FONT_NORMAL_BLACK);
        }
    }

    // price changes hint
    lang_text_draw_multiline(152, 3, -280, 360, 1200, FONT_NORMAL_BLACK);

    set_translation(0, 0);
}

static void handle_input_price_changes(struct mouse_t *m, struct hotkeys_t *h)
{
    if (generic_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, buttons_price_changes, sizeof(buttons_price_changes) / sizeof(struct generic_button_t), &focus_button_id_price_changes)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        show_editor_attributes();
    }
}

static void show_editor_price_changes(void)
{
    struct window_type_t window = {
        WINDOW_EDITOR_PRICE_CHANGES,
        window_editor_map_draw_all,
        draw_foreground_price_changes,
        handle_input_price_changes,
    };
    window_show(&window);
}

static void button_price_changes(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    stop_brief_description_box_input();
    show_editor_price_changes();
}

static void set_year_demand_change(int value)
{
    scenario.demand_changes[id_demand_route].year = value;
}

static void button_year_demand_change(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 115, screen_data.dialog_offset.y + 65, 3, 999, set_year_demand_change);
}

static void set_month_demand_change(int value)
{
    // Jan is 1 for input/draw purposes
    if (value == 0) {
        value = 1;
    }
    // change month back to 0 indexed before saving
    scenario.demand_changes[id_demand_route].month = value - 1;
}

static void button_month_demand_change(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_numeric_input_show(screen_data.dialog_offset.x + 115, screen_data.dialog_offset.y + 95, 2, 12, set_month_demand_change);
}

static void set_resource_demand_change(int value)
{
    // reset trade_city_id to force re-selection (upon which valid routes for the resource are determined)
    scenario.demand_changes[id_demand_route].trade_city_id = 0;

    scenario.demand_changes[id_demand_route].resource = value;
}

static void button_resource_demand_change(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_select_list_show_text(screen_data.dialog_offset.x + 230, screen_data.dialog_offset.y + 55, resource_strings, RESOURCE_TYPES_MAX, set_resource_demand_change);
}

static void set_route_id(int index)
{
    scenario.demand_changes[id_demand_route].trade_city_id = demand_routes_route_ids[index];
}

static void create_route_names(void)
{
    demand_routes_num_routes = 0;
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        struct empire_object_t *object = &empire_objects[i];
        if (object && (object->city_type == EMPIRE_CITY_TRADE || object->city_type == EMPIRE_CITY_FUTURE_TRADE)) {
            if (object->resource_sell_limit[scenario.demand_changes[id_demand_route].resource] || object->resource_buy_limit[scenario.demand_changes[id_demand_route].resource]) {
                char *dst = route_display_names[i];
                int offset = string_from_int(dst, i, 0);
                dst[offset++] = ' ';
                dst[offset++] = '-';
                dst[offset++] = ' ';
                string_copy(lang_get_string(21, object->city_name_id), &dst[offset], DEMAND_ROUTE_MAX_NAME_LENGTH - offset);
                demand_routes_route_ids[demand_routes_num_routes] = i;
                demand_routes_route_names[demand_routes_num_routes] = route_display_names[i];
                demand_routes_num_routes++;
            }
        }
    }
}

static void button_route(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    create_route_names();
    // if no routes available, reset to default text in pop-up window
    if (!demand_routes_num_routes) {
        demand_routes_route_ids[0] = 0;
        demand_routes_route_names[0] = route_display_names[0];
        demand_routes_num_routes = 1;
    }
    window_select_list_show_text(screen_data.dialog_offset.x + 330, screen_data.dialog_offset.y + 205, demand_routes_route_names, demand_routes_num_routes, set_route_id);
}

static void button_toggle_rise_demand_change(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.demand_changes[id_demand_route].is_rise = !scenario.demand_changes[id_demand_route].is_rise;
}

static void sort_editor_demand_changes(void)
{
    for (int i = 0; i < MAX_DEMAND_CHANGES; i++) {
        for (int j = MAX_DEMAND_CHANGES - 1; j > 0; j--) {
            if (scenario.demand_changes[j].resource && scenario.demand_changes[j].trade_city_id) {
                // if no previous demand change scheduled, move current back until first; if previous demand change is later than current, swap
                if (!scenario.demand_changes[j - 1].resource || !scenario.demand_changes[j - 1].trade_city_id || scenario.demand_changes[j - 1].year > scenario.demand_changes[j].year
                || (scenario.demand_changes[j - 1].year == scenario.demand_changes[j].year && scenario.demand_changes[j - 1].month > scenario.demand_changes[j].month)) {
                    struct demand_change_t tmp = scenario.demand_changes[j];
                    scenario.demand_changes[j] = scenario.demand_changes[j - 1];
                    scenario.demand_changes[j - 1] = tmp;
                }
            }
        }
    }
    scenario.is_saved = 0;
}

static void draw_foreground_demand_changes(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    outer_panel_draw(-320, 0, 77, 23);
    lang_text_draw_centered(44, 94, -320, 16, 1232, FONT_LARGE_BLACK);
    for (int i = 0; i < MAX_DEMAND_CHANGES; i++) {
        int x, y;
        if (i < 10) {
            x = -300;
            y = 48 + 30 * i;
        } else if (i < 20) {
            x = 0;
            y = 48 + 30 * (i - 10);
        } else if (i < 30) {
            x = 300;
            y = 48 + 30 * (i - 20);
        } else {
            x = 600;
            y = 48 + 30 * (i - 30);
        }
        button_border_draw(x, y, 290, 25, focus_button_id_demand_changes == i + 1);

        if (scenario.demand_changes[i].resource && scenario.demand_changes[i].trade_city_id) {
            int width = lang_text_draw(25, scenario.demand_changes[i].month, x + 12, y + 6, FONT_NORMAL_BLACK);
            width += lang_text_draw_year(scenario.start_year + scenario.demand_changes[i].year, x + 6 + width, y + 6, FONT_NORMAL_BLACK);
            image_draw(resource_images[scenario.demand_changes[i].resource].editor_icon_img_id + resource_image_offset(scenario.demand_changes[i].resource, RESOURCE_IMAGE_ICON), x + 12 + width, y + 3);
            width += lang_text_draw(44, 97, x + 45 + width, y + 6, FONT_NORMAL_BLACK);
            width += text_draw_number(scenario.demand_changes[i].trade_city_id, 0, 0, x + 48 + width, y + 6, FONT_NORMAL_BLACK);
            lang_text_draw(44, scenario.demand_changes[i].is_rise ? 99 : 98, x + 48 + width, y + 6, FONT_NORMAL_BLACK);
        } else {
            lang_text_draw_centered(44, 96, x, y + 6, 290, FONT_NORMAL_BLACK);
        }
    }
    set_translation(0, 0);
}

static void handle_input_demand_changes(struct mouse_t *m, struct hotkeys_t *h);
static void show_editor_demand_changes(void)
{
    struct window_type_t window = {
        WINDOW_EDITOR_DEMAND_CHANGES,
        window_editor_map_draw_all,
        draw_foreground_demand_changes,
        handle_input_demand_changes,
    };
    window_show(&window);
}

static void button_delete_demand_change(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    scenario.demand_changes[id_demand_route].year = 1;
    scenario.demand_changes[id_demand_route].month = 0;
    scenario.demand_changes[id_demand_route].resource = 0;
    scenario.demand_changes[id_demand_route].trade_city_id = 0;
    scenario.demand_changes[id_demand_route].is_rise = 0;
    sort_editor_demand_changes();
    show_editor_demand_changes();
}

static struct generic_button_t buttons_edit_demand_change[] = {
    {130, 152, 100, 25, button_year_demand_change, button_none, 0, 0},
    {130, 182, 100, 25, button_month_demand_change, button_none, 0, 0},
    {130, 212, 100, 25, button_resource_demand_change, button_none, 0, 0},
    {130, 242, 200, 25, button_route, button_none, 0, 0},
    {230, 272, 100, 25, button_toggle_rise_demand_change, button_none, 0, 0},
    {80, 312, 250, 25, button_delete_demand_change, button_none, 0, 0},
};

static void draw_foreground_edit_demand_change(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);

    outer_panel_draw(0, 100, 26, 16);
    // Demand changes
    lang_text_draw_centered(44, 94, 0, 116, 416, FONT_LARGE_BLACK);

    // Year offset
    text_draw(common_editor_strings[0], 30, 158, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(130, 152, 100, 25, focus_button_id_demand_route == 1);
    text_draw_number_centered_prefix(scenario.demand_changes[id_demand_route].year, '+', 132, 158, 100, FONT_NORMAL_BLACK);
    lang_text_draw_year(scenario.start_year + scenario.demand_changes[id_demand_route].year, 240, 158, FONT_NORMAL_BLACK);

    // Month
    text_draw(common_editor_strings[1], 30, 188, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(130, 182, 100, 25, focus_button_id_demand_route == 2);
    text_draw_number_centered(scenario.demand_changes[id_demand_route].month + 1, 130, 188, 100, FONT_NORMAL_BLACK);

    // Invalid year/month combination
    if (scenario.demand_changes[id_demand_route].year == 0 && scenario.demand_changes[id_demand_route].month == 0) {
        text_draw(common_editor_strings[2], 245, 188, FONT_NORMAL_PLAIN, COLOR_RED);
    }

    // Resource
    text_draw(common_editor_strings[4], 30, 218, FONT_NORMAL_BLACK, COLOR_BLACK);
    button_border_draw(130, 212, 100, 25, focus_button_id_demand_route == 3);
    text_draw_centered(resource_strings[scenario.demand_changes[id_demand_route].resource], 130, 218, 100, FONT_NORMAL_BLACK, COLOR_BLACK);

    // in route
    lang_text_draw(44, 97, 30, 248, FONT_NORMAL_BLACK);
    button_border_draw(130, 242, 200, 25, focus_button_id_demand_route == 4);
    if (scenario.demand_changes[id_demand_route].trade_city_id) {
        text_draw_centered(route_display_names[scenario.demand_changes[id_demand_route].trade_city_id], 130, 248, 200, FONT_NORMAL_BLACK, 0);
    }

    // demand for this good rises/falls
    lang_text_draw(44, 100, 30, 278, FONT_NORMAL_BLACK);
    button_border_draw(230, 272, 100, 25, focus_button_id_demand_route == 5);
    lang_text_draw_centered(44, scenario.demand_changes[id_demand_route].is_rise ? 99 : 98, 230, 278, 100, FONT_NORMAL_BLACK);

    // Cancel fluctuation
    button_border_draw(80, 312, 250, 25, focus_button_id_demand_route == 6);
    lang_text_draw_centered(44, 101, 80, 318, 250, FONT_NORMAL_BLACK);

    set_translation(0, 0);
}

static void handle_input_edit_demand_change(struct mouse_t *m, struct hotkeys_t *h)
{
    if (generic_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, buttons_edit_demand_change, sizeof(buttons_edit_demand_change) / sizeof(struct generic_button_t), &focus_button_id_demand_route)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        sort_editor_demand_changes();
        show_editor_demand_changes();
    }
}

static void show_editor_edit_demand_change(int id, __attribute__((unused)) int param2)
{
    struct window_type_t window = {
        WINDOW_EDITOR_EDIT_DEMAND_CHANGE,
        window_editor_map_draw_all,
        draw_foreground_edit_demand_change,
        handle_input_edit_demand_change,
    };
    id_demand_route = id;
    create_route_names();
    window_show(&window);
}

static struct generic_button_t buttons_demand_changes[] = {
    {-300, 48, 290, 25, show_editor_edit_demand_change, button_none, 0, 0},
    {-300, 78, 290, 25, show_editor_edit_demand_change, button_none, 1, 0},
    {-300, 108, 290, 25, show_editor_edit_demand_change, button_none, 2, 0},
    {-300, 138, 290, 25, show_editor_edit_demand_change, button_none, 3, 0},
    {-300, 168, 290, 25, show_editor_edit_demand_change, button_none, 4, 0},
    {-300, 198, 290, 25, show_editor_edit_demand_change, button_none, 5, 0},
    {-300, 228, 290, 25, show_editor_edit_demand_change, button_none, 6, 0},
    {-300, 258, 290, 25, show_editor_edit_demand_change, button_none, 7, 0},
    {-300, 288, 290, 25, show_editor_edit_demand_change, button_none, 8, 0},
    {-300, 318, 290, 25, show_editor_edit_demand_change, button_none, 9, 0},
    {0, 48, 290, 25, show_editor_edit_demand_change, button_none, 10, 0},
    {0, 78, 290, 25, show_editor_edit_demand_change, button_none, 11, 0},
    {0, 108, 290, 25, show_editor_edit_demand_change, button_none, 12, 0},
    {0, 138, 290, 25, show_editor_edit_demand_change, button_none, 13, 0},
    {0, 168, 290, 25, show_editor_edit_demand_change, button_none, 14, 0},
    {0, 198, 290, 25, show_editor_edit_demand_change, button_none, 15, 0},
    {0, 228, 290, 25, show_editor_edit_demand_change, button_none, 16, 0},
    {0, 258, 290, 25, show_editor_edit_demand_change, button_none, 17, 0},
    {0, 288, 290, 25, show_editor_edit_demand_change, button_none, 18, 0},
    {0, 318, 290, 25, show_editor_edit_demand_change, button_none, 19, 0},
    {300, 48, 290, 25, show_editor_edit_demand_change, button_none, 20, 0},
    {300, 78, 290, 25, show_editor_edit_demand_change, button_none, 21, 0},
    {300, 108, 290, 25, show_editor_edit_demand_change, button_none, 22, 0},
    {300, 138, 290, 25, show_editor_edit_demand_change, button_none, 23, 0},
    {300, 168, 290, 25, show_editor_edit_demand_change, button_none, 24, 0},
    {300, 198, 290, 25, show_editor_edit_demand_change, button_none, 25, 0},
    {300, 228, 290, 25, show_editor_edit_demand_change, button_none, 26, 0},
    {300, 258, 290, 25, show_editor_edit_demand_change, button_none, 27, 0},
    {300, 288, 290, 25, show_editor_edit_demand_change, button_none, 28, 0},
    {300, 318, 290, 25, show_editor_edit_demand_change, button_none, 29, 0},
    {600, 48, 290, 25, show_editor_edit_demand_change, button_none, 30, 0},
    {600, 78, 290, 25, show_editor_edit_demand_change, button_none, 31, 0},
    {600, 108, 290, 25, show_editor_edit_demand_change, button_none, 32, 0},
    {600, 138, 290, 25, show_editor_edit_demand_change, button_none, 33, 0},
    {600, 168, 290, 25, show_editor_edit_demand_change, button_none, 34, 0},
    {600, 198, 290, 25, show_editor_edit_demand_change, button_none, 35, 0},
    {600, 228, 290, 25, show_editor_edit_demand_change, button_none, 36, 0},
    {600, 258, 290, 25, show_editor_edit_demand_change, button_none, 37, 0},
    {600, 288, 290, 25, show_editor_edit_demand_change, button_none, 38, 0},
    {600, 318, 290, 25, show_editor_edit_demand_change, button_none, 39, 0},
};

static void handle_input_demand_changes(struct mouse_t *m, struct hotkeys_t *h)
{
    if (generic_buttons_handle_mouse(mouse_in_dialog(m), 0, 0, buttons_demand_changes, sizeof(buttons_demand_changes) / sizeof(struct generic_button_t), &focus_button_id_demand_changes)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        show_editor_attributes();
    }
}

static void button_demand_changes(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    stop_brief_description_box_input();
    show_editor_demand_changes();
}

static struct generic_button_t buttons_editor_attributes[] = {
    {213, 60, 195, 30, button_briefing, button_none, 0, 0},
    {213, 100, 195, 30, change_climate, button_none, 0, 0},
    {213, 140, 195, 30, button_starting_conditions, button_none, 0, 0},
    {213, 180, 195, 30, button_win_criteria, button_none, 0, 0},
    {17, 220, 185, 30, button_allowed_buildings, button_none, 0, 0},
    {213, 220, 195, 30, button_special_events, button_none, 0, 0},
    {17, 260, 185, 30, show_editor_edit_requests, button_none, 0, 0},
    {213, 260, 195, 30, button_custom_messages, button_none, 0, 0},
    {17, 300, 185, 30, button_earthquakes, button_none, 0, 0},
    {213, 300, 195, 30, show_editor_edit_invasions, button_none, 0, 0},
    {17, 340, 185, 30, button_price_changes, button_none, 0, 0},
    {213, 340, 195, 30, button_demand_changes, button_none, 0, 0},
};

static void change_image_attributes(int value, __attribute__((unused)) int param2)
{
    if (scenario.brief_description_image_id == 15 && value == 1) {
        scenario.brief_description_image_id = 0;
    } else if (scenario.brief_description_image_id == 0 && value == -1) {
        scenario.brief_description_image_id = 15;
    } else {
        scenario.brief_description_image_id += value;
    }
    scenario.is_saved = 0;
    window_data.refresh_on_draw = 1;
}

static struct arrow_button_t image_arrows_attributes[] = {
    {19, 16, 19, 24, change_image_attributes, -1, 0, 0, 0},
    {43, 16, 21, 24, change_image_attributes, 1, 0, 0, 0},
};

static void draw_foreground_attributes(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);

    outer_panel_draw(0, 0, 27, 25);

    arrow_buttons_draw(0, 0, image_arrows_attributes, 2);

    // Brief description
    input_box_draw(&scenario_description_input);

    // Brief description image
    button_border_draw(18, 60, 184, 144, 0);
    image_draw(image_data_s.group_image_ids[GROUP_EDITOR_SCENARIO_IMAGE] + scenario.brief_description_image_id, 20, 62);

    // Briefing
    button_border_draw(213, 60, 195, 30, focus_button_id_attributes == 1);
    text_draw_centered(attribute_window_strings[0], 213, 69, 195, FONT_NORMAL_BLACK, COLOR_BLACK);

    // Terrain set
    button_border_draw(213, 100, 195, 30, focus_button_id_attributes == 2);
    text_draw_centered(climate_types_strings[scenario.climate], 213, 109, 195, FONT_NORMAL_BLACK, COLOR_BLACK);

    // Starting conditions
    button_border_draw(213, 140, 195, 30, focus_button_id_attributes == 3);
    lang_text_draw_centered(44, 88, 213, 149, 195, FONT_NORMAL_BLACK);

    // Win criteria
    button_border_draw(213, 180, 195, 30, focus_button_id_attributes == 4);
    lang_text_draw_centered(44, 45, 213, 189, 195, FONT_NORMAL_BLACK);

    // Buildings allowed
    button_border_draw(17, 220, 185, 30, focus_button_id_attributes == 5);
    lang_text_draw_centered(44, 44, 17, 229, 185, FONT_NORMAL_BLACK);

    // Special events
    button_border_draw(213, 220, 195, 30, focus_button_id_attributes == 6);
    lang_text_draw_centered(44, 49, 213, 229, 195, FONT_NORMAL_BLACK);

    // Requests
    button_border_draw(17, 260, 185, 30, focus_button_id_attributes == 7);
    if (scenario.requests[0].resource) {
        text_draw_centered(attribute_window_strings[1], 17, 269, 185, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else {
        text_draw_centered(attribute_window_strings[2], 17, 269, 185, FONT_NORMAL_BLACK, COLOR_BLACK);
    }

    // Custom messages
    button_border_draw(213, 260, 195, 30, focus_button_id_attributes == 8);
    if (scenario.editor_custom_messages[0].enabled) {
        text_draw_centered(attribute_window_strings[3], 213, 269, 195, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else {
        text_draw_centered(attribute_window_strings[4], 213, 269, 195, FONT_NORMAL_BLACK, COLOR_BLACK);
    }

    // Earthquakes
    button_border_draw(17, 300, 185, 30, focus_button_id_attributes == 9);
    if (scenario.earthquakes[0].state) {
        text_draw_centered(attribute_window_strings[5], 17, 309, 185, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else {
        text_draw_centered(attribute_window_strings[6], 17, 309, 185, FONT_NORMAL_BLACK, COLOR_BLACK);
    }

    // Invasions
    button_border_draw(213, 300, 195, 30, focus_button_id_attributes == 10);
    if (scenario.invasions[0].type) {
        text_draw_centered(attribute_window_strings[7], 213, 309, 195, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else {
        text_draw_centered(attribute_window_strings[8], 213, 309, 195, FONT_NORMAL_BLACK, COLOR_BLACK);
    }

    // Price changes
    button_border_draw(17, 340, 185, 30, focus_button_id_attributes == 11);
    if (scenario.price_changes[0].resource) {
        text_draw_centered(attribute_window_strings[9], 17, 349, 185, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else {
        text_draw_centered(attribute_window_strings[10], 17, 349, 185, FONT_NORMAL_BLACK, COLOR_BLACK);
    }

    // Demand changes
    button_border_draw(213, 340, 195, 30, focus_button_id_attributes == 12);
    if (scenario.demand_changes[0].resource && scenario.demand_changes[0].trade_city_id) {
        text_draw_centered(attribute_window_strings[11], 213, 349, 195, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else {
        text_draw_centered(attribute_window_strings[12], 213, 349, 195, FONT_NORMAL_BLACK, COLOR_BLACK);
    }

    set_translation(0, 0);
}

static void handle_input_attributes(struct mouse_t *m, struct hotkeys_t *h)
{
    struct mouse_t *m_dialog = mouse_in_dialog(m);
    if (generic_buttons_handle_mouse(m_dialog, 0, 0, buttons_editor_attributes, sizeof(buttons_editor_attributes) / sizeof(struct generic_button_t), &focus_button_id_attributes) ||
        arrow_buttons_handle_mouse(m_dialog, 0, 0, image_arrows_attributes, 2, 0) ||
        image_buttons_handle_mouse(m, screen_data.width - SIDEBAR_EXPANDED_WIDTH, 24, buttons_build, 1, 0)) {
        return;
    }
    if (m->right.went_up || h->escape_pressed) {
        stop_brief_description_box_input();
        show_editor_map();
    }
}

static void show_editor_attributes(void)
{
    struct window_type_t window = {
        WINDOW_EDITOR_ATTRIBUTES,
        window_editor_map_draw_all,
        draw_foreground_attributes,
        handle_input_attributes,
    };
    string_copy(scenario.brief_description, brief_description, MAX_BRIEF_DESCRIPTION);
    input_box_start(&scenario_description_input);
    window_show(&window);
}

static void draw_foreground_top_menu_editor(void)
{
    if (!open_sub_menu_top_menu_editor) {
        return;
    }
    menu_draw(&top_menu_editor[open_sub_menu_top_menu_editor - 1], focus_sub_menu_id_top_menu_editor);
}

static void show_editor_top_menu_window(void)
{
    struct window_type_t window = {
        WINDOW_EDITOR_TOP_MENU,
        window_editor_map_draw_all,
        draw_foreground_top_menu_editor,
        handle_input_top_menu_editor,
    };
    top_menu_editor[1].items[0].hidden = 0;
    window_show(&window);
}

static void button_messages_city_widget(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_build_menu_hide();
    window_message_list_show();
}

static void button_undo_city_widget(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_build_menu_hide();
    game_undo_perform();
    window_invalidate();
}

static struct image_button_t buttons_build_expanded[] = {
    {13, 277, 39, 26, IB_NORMAL, GROUP_SIDEBAR_BUTTONS, 0, button_build_city_widget, button_none, MENU_VACANT_HOUSE, 0, 1, 0, 0, 0},
    {63, 277, 39, 26, IB_NORMAL, GROUP_SIDEBAR_BUTTONS, 8, button_build_city_widget, button_none, MENU_CLEAR_LAND, 0, 1, 0, 0, 0},
    {113, 277, 39, 26, IB_NORMAL, GROUP_SIDEBAR_BUTTONS, 12, button_build_city_widget, button_none, MENU_ROAD, 0, 1, 0, 0, 0},
    {13, 313, 39, 26, IB_BUILD, GROUP_SIDEBAR_BUTTONS, 4, button_build_city_widget, button_none, MENU_WATER, 0, 1, 0, 0, 0},
    {63, 313, 39, 26, IB_BUILD, GROUP_SIDEBAR_BUTTONS, 40, button_build_city_widget, button_none, MENU_HEALTH, 0, 1, 0, 0, 0},
    {113, 313, 39, 26, IB_BUILD, GROUP_SIDEBAR_BUTTONS, 28, button_build_city_widget, button_none, MENU_TEMPLES, 0, 1, 0, 0, 0},
    {13, 349, 39, 26, IB_BUILD, GROUP_SIDEBAR_BUTTONS, 24, button_build_city_widget, button_none, MENU_EDUCATION, 0, 1, 0, 0, 0},
    {63, 349, 39, 26, IB_BUILD, GROUP_SIDEBAR_BUTTONS, 20, button_build_city_widget, button_none, MENU_ENTERTAINMENT, 0, 1, 0, 0, 0},
    {113, 349, 39, 26, IB_BUILD, GROUP_SIDEBAR_BUTTONS, 16, button_build_city_widget, button_none, MENU_ADMINISTRATION, 0, 1, 0, 0, 0},
    {13, 385, 39, 26, IB_BUILD, GROUP_SIDEBAR_BUTTONS, 44, button_build_city_widget, button_none, MENU_ENGINEERING, 0, 1, 0, 0, 0},
    {63, 385, 39, 26, IB_BUILD, GROUP_SIDEBAR_BUTTONS, 36, button_build_city_widget, button_none, MENU_SECURITY, 0, 1, 0, 0, 0},
    {113, 385, 39, 26, IB_BUILD, GROUP_SIDEBAR_BUTTONS, 32, button_build_city_widget, button_none, MENU_INDUSTRY, 0, 1, 0, 0, 0},
    {13, 421, 39, 26, IB_NORMAL, GROUP_SIDEBAR_BUTTONS, 48, button_undo_city_widget, button_none, 0, 0, 1, 0, 0, 0},
    {63, 421, 39, 26, IB_NORMAL, GROUP_ARROW_MESSAGE_PROBLEMS, 18, button_messages_city_widget, button_help_city_widget, 0, MESSAGE_DIALOG_MESSAGES, 1, 0, 0, 0},
    {113, 421, 39, 26, IB_BUILD, GROUP_ARROW_MESSAGE_PROBLEMS, 22, button_go_to_problem, button_none, 0, 0, 1, 0, 0, 0},
};

static void handle_input_city(struct mouse_t *m, struct hotkeys_t *h)
{
    handle_hotkeys_city(h);
    if (!construction_data.in_progress) {
        if (widget_top_menu_handle_input(m, h)) {
            return;
        }
        if (widget_city_data.capture_input) {
            return;
        }
        int handled = 0;
        int button_id;
        if (view_data.sidebar_collapsed) {
            int x_offset = screen_data.width - SIDEBAR_COLLAPSED_WIDTH;
            handled |= image_buttons_handle_mouse(m, x_offset, 24, button_expand_sidebar, 1, &button_id);
            handled |= image_buttons_handle_mouse(m, x_offset, 24, buttons_build_collapsed, sizeof(buttons_build_collapsed) / sizeof(struct image_button_t), &button_id);
        } else {
            if (widget_minimap_handle_mouse(m)) {
                return;
            }
            int x_offset = screen_data.width - SIDEBAR_EXPANDED_WIDTH;
            handled |= image_buttons_handle_mouse(m, x_offset, 24, buttons_overlays_collapse_sidebar, 2, &button_id);
            handled |= image_buttons_handle_mouse(m, x_offset, 24, buttons_build_expanded, sizeof(buttons_build_expanded) / sizeof(struct image_button_t), &button_id);
            handled |= image_buttons_handle_mouse(m, x_offset, 24, buttons_top_expanded, sizeof(buttons_top_expanded) / sizeof(struct image_button_t), &button_id);
            if (!(extra_widget_data.info_to_display & SIDEBAR_EXTRA_DISPLAY_GAME_SPEED)) {
                return;
            }
            arrow_buttons_handle_mouse(m, extra_widget_data.x_offset, extra_widget_data.y_offset, arrow_buttons_speed, 2, 0);
        }
    }
    scroll_map(m);
    if (h->escape_pressed) {
        if (construction_data.type) {
            building_construction_cancel();
            window_data.refresh_on_draw = 1;
        } else {
            window_popup_dialog_show(POPUP_DIALOG_QUIT, confirm_exit_to_main_menu, 1);
        }
    }
    struct map_tile_t *tile = &widget_city_data.current_tile;
    update_city_view_coords(m->x, m->y, tile);
    construction_data.draw_as_constructing = 0;
    if (m->left.went_down) {
        // handle legion click
        if (tile->grid_offset) {
            int formation_id = formation_legion_at_grid_offset(tile->grid_offset);
            if (formation_id > -1 && !legion_formations[formation_id].in_distant_battle) {
                window_city_military_show(formation_id);
                return;
            }
        }
        if (!construction_data.in_progress && construction_data.type != BUILDING_NONE) {
            if (tile->grid_offset) { // Allow building on paused
                construction_data.start.grid_offset = tile->grid_offset;
                construction_data.start.x = construction_data.end.x = tile->x;
                construction_data.start.y = construction_data.end.y = tile->y;
                if (game_undo_start_build(construction_data.type)) {
                    construction_data.in_progress = 1;
                    int can_start = 1;
                    switch (construction_data.type) {
                        case BUILDING_ROAD:
                            can_start = map_routing_calculate_distances_for_building(
                                ROUTED_BUILDING_ROAD, construction_data.start.x, construction_data.start.y);
                            break;
                        case BUILDING_AQUEDUCT:
                            can_start = map_routing_calculate_distances_for_building(
                                ROUTED_BUILDING_AQUEDUCT, construction_data.start.x, construction_data.start.y);
                            break;
                        case BUILDING_WALL:
                            can_start = map_routing_calculate_distances_for_building(
                                ROUTED_BUILDING_WALL, construction_data.start.x, construction_data.start.y);
                            break;
                        default:
                            break;
                    }
                    if (!can_start) {
                        building_construction_cancel();
                    }
                }
            }
        }
        build_move(tile);
    } else if (m->left.is_down || construction_data.in_progress) {
        build_move(tile);
    }
    if (m->left.went_up) {
        if (construction_data.in_progress) {
            if (construction_data.type != BUILDING_NONE) {
                play_sound_effect(SOUND_EFFECT_BUILD);
            }
            building_construction_place();
            minimap_data.refresh_requested = 1;
        }
    }
    int is_cancel_construction_button;
    if (construction_data.type) {
        int city_x, city_y, width, height;
        city_view_get_viewport(&city_x, &city_y, &width, &height);
        int touch_width = 5 * BLOCK_SIZE;
        int touch_height = 4 * BLOCK_SIZE;
        int x_offset = width - touch_width;
        int y_offset = 24;
        is_cancel_construction_button = m->x >= x_offset && m->x < x_offset + touch_width && m->y >= y_offset && m->y < y_offset + touch_height;
    }
    int x_offset, y_offset, width, height;
    city_view_get_viewport(&x_offset, &y_offset, &width, &height);
    if (m->right.went_down
    && !(m->x < 5 * BLOCK_SIZE && m->y >= 24 && m->y < 24 + 4 * BLOCK_SIZE) // not pause button
    && !is_cancel_construction_button
    && (m->x - x_offset >= 0 && m->x - x_offset < width && m->y - y_offset >= 0 && m->y - y_offset < height) // coords in city
    && !construction_data.type) {
        scroll_drag_start();
    }
    if (m->right.went_up) {
        if (!construction_data.type) {
            int has_scrolled = scroll_drag_end();
            int allow_right_click_info = 1;
            if (window_data.current_window->id != WINDOW_CITY) {
                allow_right_click_info = 0;
            }
            window_city_show();
            if (!tile->grid_offset) {
                allow_right_click_info = 0;
            }
            int city_has_warnings = 0;
            for (int i = 0; i < MAX_WARNINGS; i++) {
                if (warnings[i].in_use) {
                    city_has_warnings = 1;
                    break;
                }
            }
            if (allow_right_click_info && city_has_warnings) {
                city_warning_clear_all();
                allow_right_click_info = 0;
            }
            if (!has_scrolled && allow_right_click_info) {
                struct window_type_t window = {
                    WINDOW_BUILDING_INFO,
                    draw_background_building_info,
                    draw_foreground_building_info,
                    handle_input_building_info,
                };
                b_info_context.can_play_sound = 1;
                b_info_context.storage_show_special_orders = 0;
                b_info_context.can_go_to_advisor = 0;
                b_info_context.building_id = map_building_at(tile->grid_offset);
                b_info_context.rubble_building_type = rubble_type_grid.items[tile->grid_offset];
                b_info_context.has_reservoir_pipes = map_terrain_is(tile->grid_offset, TERRAIN_RESERVOIR_RANGE);
                b_info_context.aqueduct_has_water = aqueduct.items[tile->grid_offset] && images.items[tile->grid_offset] - image_data_s.group_image_ids[GROUP_BUILDING_AQUEDUCT] < 15;
                city_resource_determine_available();
                b_info_context.type = BUILDING_INFO_TERRAIN;
                b_info_context.figure.drawn = 0;
                if (!b_info_context.building_id && sprite.items[tile->grid_offset] > 0) {
                    if (map_terrain_is(tile->grid_offset, TERRAIN_WATER)) {
                        b_info_context.terrain_type = TERRAIN_INFO_BRIDGE;
                    } else {
                        b_info_context.terrain_type = TERRAIN_INFO_EMPTY;
                    }
                } else if (bitfields_grid.items[tile->grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
                    if (map_terrain_is(tile->grid_offset, TERRAIN_ROAD)) {
                        b_info_context.terrain_type = TERRAIN_INFO_PLAZA;
                    }
                    if (map_terrain_is(tile->grid_offset, TERRAIN_ROCK)) {
                        b_info_context.terrain_type = TERRAIN_INFO_EARTHQUAKE;
                    }
                } else if (map_terrain_is(tile->grid_offset, TERRAIN_SHRUB)) {
                    b_info_context.terrain_type = TERRAIN_INFO_TREE;
                } else if (map_terrain_is(tile->grid_offset, TERRAIN_ROCK)) {
                    if (tile->grid_offset == map_grid_offset(scenario.entry_point.x, scenario.entry_point.y)) {
                        b_info_context.terrain_type = TERRAIN_INFO_ENTRY_FLAG;
                    } else if (tile->grid_offset == map_grid_offset(scenario.exit_point.x, scenario.exit_point.y)) {
                        b_info_context.terrain_type = TERRAIN_INFO_EXIT_FLAG;
                    } else {
                        b_info_context.terrain_type = TERRAIN_INFO_ROCK;
                    }
                } else if ((terrain_grid.items[tile->grid_offset] & (TERRAIN_WATER | TERRAIN_BUILDING)) == TERRAIN_WATER) {
                    b_info_context.terrain_type = TERRAIN_INFO_WATER;
                } else if (map_terrain_is(tile->grid_offset, TERRAIN_TREE)) {
                    b_info_context.terrain_type = TERRAIN_INFO_SHRUB;
                } else if (map_terrain_is(tile->grid_offset, TERRAIN_GARDEN)) {
                    b_info_context.terrain_type = TERRAIN_INFO_GARDEN;
                } else if ((terrain_grid.items[tile->grid_offset] & (TERRAIN_ROAD | TERRAIN_BUILDING)) == TERRAIN_ROAD) {
                    b_info_context.terrain_type = TERRAIN_INFO_ROAD;
                } else if (map_terrain_is(tile->grid_offset, TERRAIN_AQUEDUCT)) {
                    b_info_context.terrain_type = TERRAIN_INFO_AQUEDUCT;
                } else if (map_terrain_is(tile->grid_offset, TERRAIN_RUBBLE)) {
                    b_info_context.terrain_type = TERRAIN_INFO_RUBBLE;
                } else if (map_terrain_is(tile->grid_offset, TERRAIN_WALL)) {
                    b_info_context.terrain_type = TERRAIN_INFO_WALL;
                } else if (!b_info_context.building_id) {
                    b_info_context.terrain_type = TERRAIN_INFO_EMPTY;
                } else {
                    struct building_t *b = &all_buildings[b_info_context.building_id];
                    b_info_context.type = BUILDING_INFO_BUILDING;
                    b_info_context.worker_percentage = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                    switch (b->type) {
                        case BUILDING_FORT_GROUND:
                            b_info_context.building_id = b->prev_part_building_id;
                            // fallthrough
                        case BUILDING_FORT_LEGIONARIES:
                        case BUILDING_FORT_JAVELIN:
                        case BUILDING_FORT_MOUNTED:
                            b_info_context.formation_id = b->formation_id;
                            break;
                        case BUILDING_WAREHOUSE_SPACE:
                        case BUILDING_HIPPODROME:
                            b = building_main(b);
                            b_info_context.building_id = b->id;
                            break;
                        case BUILDING_BARRACKS:
                            b_info_context.barracks_soldiers_requested = 0;
                            for (int i = 0; i < MAX_LEGIONS; i++) {
                                if (legion_formations[i].in_use && legion_formations[i].num_figures < legion_formations[i].max_figures) {
                                    b_info_context.barracks_soldiers_requested = 1;
                                    break;
                                }
                            }
                            b_info_context.barracks_soldiers_requested += tower_sentry_request;
                            break;
                        default:
                            if (b->house_size) {
                                int lowest_desirability = 0;
                                int lowest_building_id = 0;
                                int x_min, y_min, x_max, y_max;
                                map_grid_get_area(b->x, b->y, 1, 6, &x_min, &y_min, &x_max, &y_max);
                                for (int y = y_min; y <= y_max; y++) {
                                    for (int x = x_min; x <= x_max; x++) {
                                        int building_id = map_building_at(map_grid_offset(x, y));
                                        if (building_id <= 0) {
                                            continue;
                                        }
                                        struct building_t *bb = &all_buildings[building_id];
                                        if (bb->state != BUILDING_STATE_IN_USE || building_id == b->id) {
                                            continue;
                                        }
                                        if (!bb->house_size || bb->type < b->type) {
                                            int des = building_properties[bb->type].desirability_value;
                                            if (des < 0) {
                                                // simplified desirability calculation
                                                int step_size = building_properties[bb->type].desirability_step_size;
                                                int range = building_properties[bb->type].desirability_range;
                                                int dist = calc_maximum_distance(x, y, b->x, b->y);
                                                if (dist <= range) {
                                                    while (--dist > 1) {
                                                        des += step_size;
                                                    }
                                                    if (des < lowest_desirability) {
                                                        lowest_desirability = des;
                                                        lowest_building_id = building_id;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                b_info_context.worst_desirability_building_id = lowest_building_id;
                                int level = b->subtype.house_level;
                                int foodtypes_available = 0;
                                for (int i = INVENTORY_WHEAT; i <= INVENTORY_MEAT; i++) {
                                    if (b->data.house.inventory[i]) {
                                        foodtypes_available++;
                                    }
                                }
                                // this house will devolve soon because...
                                if (b->desirability <= house_properties[level].devolve_desirability) {
                                    b->data.house.evolve_text_id = 0;
                                } else if (house_properties[level].water == 1 && !b->has_water_access && !b->has_well_access) {
                                    b->data.house.evolve_text_id = 1;
                                } else if (house_properties[level].water == 2 && !b->has_water_access) {
                                    b->data.house.evolve_text_id = 2;
                                } else if (b->data.house.entertainment < house_properties[level].entertainment) {
                                    if (!b->data.house.entertainment) {
                                        b->data.house.evolve_text_id = 3;
                                    } else if (house_properties[level].entertainment < 10) {
                                        b->data.house.evolve_text_id = 4;
                                    } else if (house_properties[level].entertainment < 25) {
                                        b->data.house.evolve_text_id = 5;
                                    } else if (house_properties[level].entertainment < 50) {
                                        b->data.house.evolve_text_id = 6;
                                    } else if (house_properties[level].entertainment < 80) {
                                        b->data.house.evolve_text_id = 7;
                                    } else {
                                        b->data.house.evolve_text_id = 8;
                                    }
                                } else if (foodtypes_available < house_properties[level].food_types) {
                                    if (house_properties[level].food_types == 1) {
                                        b->data.house.evolve_text_id = 9;
                                    } else if (house_properties[level].food_types == 2) {
                                        b->data.house.evolve_text_id = 10;
                                    } else if (house_properties[level].food_types == 3) {
                                        b->data.house.evolve_text_id = 11;
                                    }
                                } else if (b->data.house.education < house_properties[level].education) {
                                    if (house_properties[level].education == 1) {
                                        b->data.house.evolve_text_id = 14;
                                    } else if (house_properties[level].education == 2) {
                                        if (b->data.house.school) {
                                            b->data.house.evolve_text_id = 15;
                                        } else if (b->data.house.library) {
                                            b->data.house.evolve_text_id = 16;
                                        }
                                    } else if (house_properties[level].education == 3) {
                                        b->data.house.evolve_text_id = 17;
                                    }
                                } else if (b->data.house.bathhouse < house_properties[level].bathhouse) {
                                    b->data.house.evolve_text_id = 18;
                                } else if (b->data.house.inventory[INVENTORY_POTTERY] < house_properties[level].pottery) {
                                    b->data.house.evolve_text_id = 19;
                                } else if (b->data.house.num_gods < house_properties[level].religion) {
                                    if (house_properties[level].religion == 1) {
                                        b->data.house.evolve_text_id = 20;
                                    } else if (house_properties[level].religion == 2) {
                                        b->data.house.evolve_text_id = 21;
                                    } else if (house_properties[level].religion == 3) {
                                        b->data.house.evolve_text_id = 22;
                                    }
                                } else if (b->data.house.barber < house_properties[level].barber) {
                                    b->data.house.evolve_text_id = 23;
                                } else if (b->data.house.health < house_properties[level].health) {
                                    if (house_properties[level].health == 1) {
                                        b->data.house.evolve_text_id = 24;
                                    } else if (b->data.house.clinic) {
                                        b->data.house.evolve_text_id = 25;
                                    } else {
                                        b->data.house.evolve_text_id = 26;
                                    }
                                } else if (b->data.house.inventory[INVENTORY_OIL] < house_properties[level].oil) {
                                    b->data.house.evolve_text_id = 27;
                                } else if (b->data.house.inventory[INVENTORY_FURNITURE] < house_properties[level].furniture) {
                                    b->data.house.evolve_text_id = 28;
                                } else if (b->data.house.inventory[INVENTORY_WINE] < house_properties[level].wine) {
                                    b->data.house.evolve_text_id = 29;
                                } else if (house_properties[level].wine > 1 && city_data.resource.wine_types_available <= 1) {
                                    b->data.house.evolve_text_id = 65;
                                } else if (level >= HOUSE_LUXURY_PALACE) { // max level!
                                    b->data.house.evolve_text_id = 60;
                                }
                                // this house will evolve if ...
                                if (b->desirability < house_properties[level].evolve_desirability) {
                                    if (b_info_context.worst_desirability_building_id) {
                                        b->data.house.evolve_text_id = 62;
                                    } else {
                                        b->data.house.evolve_text_id = 30;
                                    }
                                }
                                // water
                                if (house_properties[level + 1].water == 1 && !b->has_water_access && !b->has_well_access) {
                                    b->data.house.evolve_text_id = 31;
                                } else if (house_properties[level + 1].water == 2 && !b->has_water_access) {
                                    b->data.house.evolve_text_id = 32;
                                } else if (b->data.house.entertainment < house_properties[level + 1].entertainment) {
                                    if (!b->data.house.entertainment) {
                                        b->data.house.evolve_text_id = 33;
                                    } else if (house_properties[level + 1].entertainment < 10) {
                                        b->data.house.evolve_text_id = 34;
                                    } else if (house_properties[level + 1].entertainment < 25) {
                                        b->data.house.evolve_text_id = 35;
                                    } else if (house_properties[level + 1].entertainment < 50) {
                                        b->data.house.evolve_text_id = 36;
                                    } else if (house_properties[level + 1].entertainment < 80) {
                                        b->data.house.evolve_text_id = 37;
                                    } else {
                                        b->data.house.evolve_text_id = 38;
                                    }
                                } else if (foodtypes_available < house_properties[level + 1].food_types) {
                                    if (house_properties[level + 1].food_types == 1) {
                                        b->data.house.evolve_text_id = 39;
                                    } else if (house_properties[level + 1].food_types == 2) {
                                        b->data.house.evolve_text_id = 40;
                                    } else if (house_properties[level + 1].food_types == 3) {
                                        b->data.house.evolve_text_id = 41;
                                    }
                                } else if (b->data.house.education < house_properties[level + 1].education) {
                                    if (house_properties[level + 1].education == 1) {
                                        b->data.house.evolve_text_id = 44;
                                    } else if (house_properties[level + 1].education == 2) {
                                        if (b->data.house.school) {
                                            b->data.house.evolve_text_id = 45;
                                        } else if (b->data.house.library) {
                                            b->data.house.evolve_text_id = 46;
                                        }
                                    } else if (house_properties[level + 1].education == 3) {
                                        b->data.house.evolve_text_id = 47;
                                    }
                                } else if (b->data.house.bathhouse < house_properties[level + 1].bathhouse) {
                                    b->data.house.evolve_text_id = 48;
                                } else if (b->data.house.inventory[INVENTORY_POTTERY] < house_properties[level + 1].pottery) {
                                    b->data.house.evolve_text_id = 49;
                                } else if (b->data.house.num_gods < house_properties[level + 1].religion) {
                                    if (house_properties[level + 1].religion == 1) {
                                        b->data.house.evolve_text_id = 50;
                                    } else if (house_properties[level + 1].religion == 2) {
                                        b->data.house.evolve_text_id = 51;
                                    } else if (house_properties[level + 1].religion == 3) {
                                        b->data.house.evolve_text_id = 52;
                                    }
                                } else if (b->data.house.barber < house_properties[level + 1].barber) {
                                    b->data.house.evolve_text_id = 53;
                                } else if (b->data.house.health < house_properties[level + 1].health) {
                                    if (house_properties[level + 1].health == 1) {
                                        b->data.house.evolve_text_id = 54;
                                    } else if (b->data.house.clinic) {
                                        b->data.house.evolve_text_id = 55;
                                    } else {
                                        b->data.house.evolve_text_id = 56;
                                    }
                                } else if (b->data.house.inventory[INVENTORY_OIL] < house_properties[level + 1].oil) {
                                    b->data.house.evolve_text_id = 57;
                                } else if (b->data.house.inventory[INVENTORY_FURNITURE] < house_properties[level + 1].furniture) {
                                    b->data.house.evolve_text_id = 58;
                                } else if (b->data.house.inventory[INVENTORY_WINE] < house_properties[level + 1].wine) {
                                    b->data.house.evolve_text_id = 59;
                                } else if (house_properties[level + 1].wine > 1 && city_data.resource.wine_types_available <= 1) {
                                    b->data.house.evolve_text_id = 66;
                                }
                                // house is evolving
                                b->data.house.evolve_text_id = 61;
                                if (b->data.house.no_space_to_expand == 1) {
                                    // house would like to evolve but can't
                                    b->data.house.evolve_text_id = 64;
                                }
                            }
                            break;
                    }
                    b_info_context.has_road_access = 0;
                    switch (b->type) {
                        case BUILDING_GRANARY:
                            if (map_has_road_access_granary(b->x, b->y, 0)) {
                                b_info_context.has_road_access = 1;
                            }
                            break;
                        case BUILDING_HIPPODROME:
                            if (map_has_road_access_hippodrome(b->x, b->y, 0)) {
                                b_info_context.has_road_access = 1;
                            }
                            break;
                        case BUILDING_WAREHOUSE:
                            if (map_has_road_access(b->x, b->y, 3, 0)) {
                                b_info_context.has_road_access = 1;
                            }
                            int total_loads = 0;
                            int empty_spaces = 0;
                            struct building_t *space = b;
                            for (int i = 0; i < 8; i++) {
                                space = &all_buildings[space->next_part_building_id];
                                if (space->subtype.warehouse_resource_id) {
                                    total_loads += space->loads_stored;
                                } else {
                                    empty_spaces++;
                                }
                            }
                            if (empty_spaces > 0) {
                                b_info_context.warehouse_space_text = WAREHOUSE_ROOM;
                            } else if (total_loads < 32) {
                                b_info_context.warehouse_space_text = WAREHOUSE_SOME_ROOM;
                            } else {
                                b_info_context.warehouse_space_text = WAREHOUSE_FULL;
                            }
                            break;
                        default:
                            if (map_has_road_access(b->x, b->y, b->size, 0)) {
                                b_info_context.has_road_access = 1;
                            }
                            break;
                    }
                }
                // figures
                b_info_context.figure.selected_index = 0;
                b_info_context.figure.count = 0;
                for (int i = 0; i < 7; i++) {
                    b_info_context.figure.figure_ids[i] = 0;
                }
                static   int FIGURE_OFFSETS[] = {
                    OFFSET(0,0), OFFSET(0,-1), OFFSET(0,1), OFFSET(1,0), OFFSET(-1,0),
                    OFFSET(-1,-1), OFFSET(1,-1), OFFSET(-1,1), OFFSET(1,1)
                };
                for (int i = 0; i < 9 && b_info_context.figure.count < 7; i++) {
                    int figure_id = map_grid_is_valid_offset(tile->grid_offset + FIGURE_OFFSETS[i]) ? map_figures.items[tile->grid_offset + FIGURE_OFFSETS[i]] : 0;
                    while (figure_id > 0 && b_info_context.figure.count < 7) {
                        struct figure_t *f = &figures[figure_id];
                        if (figure_is_alive(f)) {
                            switch (f->type) {
                                case FIGURE_NONE:
                                case FIGURE_EXPLOSION:
                                case FIGURE_MAP_FLAG:
                                case FIGURE_FLOTSAM:
                                case FIGURE_ARROW:
                                case FIGURE_JAVELIN:
                                case FIGURE_BOLT:
                                case FIGURE_BALLISTA:
                                case FIGURE_FISH_GULLS:
                                case FIGURE_HIPPODROME_HORSES:
                                    break;
                                default:
                                    b_info_context.figure.figure_ids[b_info_context.figure.count++] = figure_id;
                                    f->phrase_id = 0;
                                    if (figure_properties[f->type].is_enemy_unit || figure_properties[f->type].is_caesar_legion_unit || figure_properties[f->type].is_native_unit) {
                                        f->phrase_id = -1;
                                    }
                                    int phrase_id = 0;
                                    switch (f->type) {
                                        case FIGURE_LION_TAMER:
                                            if (f->engaged_in_combat) {
                                                if (++f->phrase_sequence_exact >= 3) {
                                                    f->phrase_sequence_exact = 0;
                                                }
                                                phrase_id = 7 + f->phrase_sequence_exact;
                                            }
                                            break;
                                        case FIGURE_GLADIATOR:
                                            phrase_id = f->engaged_in_combat ? 7 : 0;
                                            break;
                                        case FIGURE_TAX_COLLECTOR:
                                            if (f->min_max_seen >= HOUSE_LARGE_CASA) {
                                                phrase_id = 7;
                                            } else if (f->min_max_seen >= HOUSE_SMALL_HOVEL) {
                                                phrase_id = 8;
                                            } else if (f->min_max_seen >= HOUSE_LARGE_TENT) {
                                                phrase_id = 9;
                                            }
                                            break;
                                        case FIGURE_MARKET_TRADER:
                                            if (f->action_state == FIGURE_ACTION_ROAMER_RETURNING) {
                                                if (building_market_get_max_food_stock(&all_buildings[f->building_id]) <= 0) {
                                                    phrase_id = 9; // run out of goods
                                                }
                                            }
                                            break;
                                        case FIGURE_MARKET_BUYER:
                                            if (f->action_state == FIGURE_ACTION_MARKET_BUYER_GOING_TO_STORAGE) {
                                                phrase_id = 7;
                                            } else if (f->action_state == FIGURE_ACTION_MARKET_BUYER_RETURNING) {
                                                phrase_id = 8;
                                            }
                                            break;
                                        case FIGURE_CART_PUSHER:
                                            if (f->action_state == FIGURE_ACTION_CARTPUSHER_INITIAL) {
                                                if (f->min_max_seen == 2) {
                                                    phrase_id = 7;
                                                } else if (f->min_max_seen == 1) {
                                                    phrase_id = 8;
                                                }
                                            } else if (f->action_state == FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_WAREHOUSE ||
                                                    f->action_state == FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_GRANARY ||
                                                    f->action_state == FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_WORKSHOP) {
                                                if (calc_maximum_distance(
                                                    f->destination_x, f->destination_y, f->source_x, f->source_y) >= 25) {
                                                    phrase_id = 9; // too far
                                                }
                                            }
                                            break;
                                        case FIGURE_WAREHOUSEMAN:
                                            if (f->action_state == FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE) {
                                                if (calc_maximum_distance(
                                                    f->destination_x, f->destination_y, f->source_x, f->source_y) >= 25) {
                                                    phrase_id = 9; // too far
                                                }
                                            }
                                            break;
                                        case FIGURE_PREFECT:
                                            if (++f->phrase_sequence_exact >= 4) {
                                                f->phrase_sequence_exact = 0;
                                            }
                                            if (f->action_state == FIGURE_ACTION_PREFECT_GOING_TO_FIRE) {
                                                phrase_id = 10;
                                            } else if (f->action_state == FIGURE_ACTION_PREFECT_AT_FIRE) {
                                                phrase_id = 11 + (f->phrase_sequence_exact % 2);
                                            } else if (f->engaged_in_combat) {
                                                phrase_id = 13 + f->phrase_sequence_exact;
                                            } else if (f->min_max_seen >= 50) {
                                                // alternate between "no sign of crime around here" and the regular city phrases
                                                if (f->phrase_sequence_exact % 2) {
                                                    phrase_id = 7;
                                                }
                                            } else if (f->min_max_seen >= 10) {
                                                phrase_id = 8;
                                            } else {
                                                phrase_id = 9;
                                            }
                                            break;
                                        case FIGURE_ENGINEER:
                                            if (f->min_max_seen >= 60) {
                                                phrase_id = 7;
                                            } else if (f->min_max_seen >= 10) {
                                                phrase_id = 8;
                                            }
                                            break;
                                        case FIGURE_PROTESTER:
                                        case FIGURE_CRIMINAL:
                                        case FIGURE_RIOTER:
                                        case FIGURE_DELIVERY_BOY:
                                        case FIGURE_MISSIONARY:
                                            if (++f->phrase_sequence_exact >= 3) {
                                                f->phrase_sequence_exact = 0;
                                            }
                                            phrase_id = 7 + f->phrase_sequence_exact;
                                            break;
                                        case FIGURE_HOMELESS:
                                        case FIGURE_IMMIGRANT:
                                            if (++f->phrase_sequence_exact >= 3) {
                                                f->phrase_sequence_exact = 0;
                                            }
                                            phrase_id = 7 + f->phrase_sequence_exact;
                                            break;
                                        case FIGURE_EMIGRANT:
                                            switch (city_data.sentiment.low_mood_cause) {
                                                case LOW_MOOD_CAUSE_NO_JOBS:
                                                    phrase_id = 7;
                                                    break;
                                                case LOW_MOOD_CAUSE_NO_FOOD:
                                                    phrase_id = 8;
                                                    break;
                                                case LOW_MOOD_CAUSE_HIGH_TAXES:
                                                    phrase_id = 9;
                                                    break;
                                                case LOW_MOOD_CAUSE_LOW_WAGES:
                                                    phrase_id = 10;
                                                    break;
                                                default:
                                                    phrase_id = 11;
                                                    break;
                                            }
                                            break;
                                        case FIGURE_TOWER_SENTRY:
                                            if (++f->phrase_sequence_exact >= 2) {
                                                f->phrase_sequence_exact = 0;
                                            }
                                            if (!city_data.figure.enemies) {
                                                phrase_id = 7 + f->phrase_sequence_exact;
                                            } else if (city_data.figure.enemies <= 10) {
                                                phrase_id = 9;
                                            } else if (city_data.figure.enemies <= 30) {
                                                phrase_id = 10;
                                            } else {
                                                phrase_id = 11;
                                            }
                                            break;
                                        case FIGURE_FORT_JAVELIN:
                                        case FIGURE_FORT_MOUNTED:
                                        case FIGURE_FORT_LEGIONARY:
                                            if (city_data.figure.enemies >= 40) {
                                                phrase_id = 11;
                                            } else if (city_data.figure.enemies > 20) {
                                                phrase_id = 10;
                                            } else if (city_data.figure.enemies) {
                                                phrase_id = 9;
                                            }
                                            break;
                                        case FIGURE_DOCKER:
                                            if (f->action_state == FIGURE_ACTION_DOCKER_IMPORT_GOING_TO_WAREHOUSE
                                                || f->action_state == FIGURE_ACTION_DOCKER_EXPORT_GOING_TO_WAREHOUSE) {
                                                if (calc_maximum_distance(f->destination_x, f->destination_y, f->source_x, f->source_y) >= 25) {
                                                    phrase_id = 9; // too far
                                                }
                                            }
                                            break;
                                        case FIGURE_TRADE_CARAVAN:
                                            phrase_id = trade_caravan_phrase(f);
                                            break;
                                        case FIGURE_TRADE_CARAVAN_DONKEY:
                                            while (f->type == FIGURE_TRADE_CARAVAN_DONKEY && f->leading_figure_id) {
                                                f = &figures[f->leading_figure_id];
                                            }
                                            phrase_id = f->type == FIGURE_TRADE_CARAVAN ? trade_caravan_phrase(f) : 0;
                                            break;
                                        case FIGURE_TRADE_SHIP:
                                            if (f->action_state == FIGURE_ACTION_TRADE_SHIP_LEAVING) {
                                                if (!trader_has_traded(f->trader_id)) {
                                                    phrase_id = 9; // no trade
                                                } else {
                                                    phrase_id = 11; // good trade
                                                }
                                            } else if (f->action_state == FIGURE_ACTION_TRADE_SHIP_MOORED) {
                                                int state = TRADE_SHIP_NONE;
                                                struct building_t *b = &all_buildings[f->destination_building_id];
                                                if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_DOCK) {
                                                    state = TRADE_SHIP_BUYING;
                                                } else {
                                                    for (int j = 0; j < 3; j++) {
                                                        struct figure_t *docker = &figures[b->data.dock.docker_ids[j]];
                                                        if (!b->data.dock.docker_ids[j] || !figure_is_alive(docker)) {
                                                            continue;
                                                        }
                                                        switch (docker->action_state) {
                                                            case FIGURE_ACTION_DOCKER_IMPORT_QUEUE:
                                                            case FIGURE_ACTION_DOCKER_IMPORT_GOING_TO_WAREHOUSE:
                                                            case FIGURE_ACTION_DOCKER_IMPORT_RETURNING:
                                                            case FIGURE_ACTION_DOCKER_IMPORT_AT_WAREHOUSE:
                                                                state = TRADE_SHIP_BUYING;
                                                                break;
                                                            case FIGURE_ACTION_DOCKER_EXPORT_QUEUE:
                                                            case FIGURE_ACTION_DOCKER_EXPORT_GOING_TO_WAREHOUSE:
                                                            case FIGURE_ACTION_DOCKER_EXPORT_RETURNING:
                                                            case FIGURE_ACTION_DOCKER_EXPORT_AT_WAREHOUSE:
                                                                state = TRADE_SHIP_SELLING;
                                                                break;
                                                        }
                                                    }
                                                }
                                                if (state == TRADE_SHIP_BUYING) {
                                                    phrase_id = 8; // buying goods
                                                } else if (state == TRADE_SHIP_SELLING) {
                                                    phrase_id = 7; // selling goods
                                                } else {
                                                    if (!trader_has_traded(f->trader_id)) {
                                                        phrase_id = 9; // no trade
                                                    } else {
                                                        phrase_id = 11; // good trade
                                                    }
                                                }
                                            } else {
                                                phrase_id = 10; // can't wait to trade
                                            }
                                    }
                                    if (phrase_id) {
                                        f->phrase_id = phrase_id;
                                    } else {
                                        f->phrase_sequence_city = 0;
                                        int god_state = GOD_STATE_NONE;
                                        int least_god_happiness = 100;
                                        for (int god = 0; god < MAX_GODS; god++) {
                                            if (city_data.religion.gods[god].happiness < least_god_happiness) {
                                                least_god_happiness = city_data.religion.gods[god].happiness;
                                            }
                                        }
                                        if (least_god_happiness < 20) {
                                            god_state = GOD_STATE_VERY_ANGRY;
                                        } else if (least_god_happiness < 40) {
                                            god_state = GOD_STATE_ANGRY;
                                        }
                                        int unemployment_pct = city_data.labor.unemployment_percentage;
                                        if (city_data.resource.food_supply_months <= 0) {
                                            f->phrase_id = 0;
                                        } else if (unemployment_pct >= 17) {
                                            f->phrase_id = 1;
                                        } else if (city_data.labor.workers_needed >= 10) {
                                            f->phrase_id = 2;
                                        } else if (city_data.culture.average_entertainment == 0) {
                                            f->phrase_id = 3;
                                        } else if (god_state == GOD_STATE_VERY_ANGRY) {
                                            f->phrase_id = 4;
                                        } else if (city_data.culture.average_entertainment <= 10) {
                                            f->phrase_id = 3;
                                        } else if (god_state == GOD_STATE_ANGRY) {
                                            f->phrase_id = 4;
                                        } else if (city_data.culture.average_entertainment <= 20) {
                                            f->phrase_id = 3;
                                        } else if (city_data.resource.food_supply_months >= 4 &&
                                                unemployment_pct <= 5 &&
                                                city_data.culture.average_health > 0 &&
                                                city_data.culture.average_education > 0) {
                                            if (city_data.population.population < 500) {
                                                f->phrase_id = 5;
                                            } else {
                                                f->phrase_id = 6;
                                            }
                                        } else if (unemployment_pct >= 10) {
                                            f->phrase_id = 1;
                                        } else {
                                            f->phrase_id = 5;
                                        }
                                    }
                                    break;
                            }
                        }
                        figure_id = f->next_figure_id_on_same_tile;
                    }
                }
                // check for legion figures
                for (int i = 0; i < 7; i++) {
                    int figure_id = b_info_context.figure.figure_ids[i];
                    if (figure_id <= 0) {
                        continue;
                    }
                    struct figure_t *f = &figures[figure_id];
                    if (f->type == FIGURE_FORT_STANDARD || figure_properties[f->type].is_player_legion_unit) {
                        b_info_context.type = BUILDING_INFO_LEGION;
                        b_info_context.formation_id = f->formation_id;
                        if (legion_formations[b_info_context.formation_id].figure_type != FIGURE_FORT_LEGIONARY) {
                            b_info_context.formation_types = 5;
                        } else if (legion_formations[b_info_context.formation_id].has_military_training) {
                            b_info_context.formation_types = 4;
                        } else {
                            b_info_context.formation_types = 3;
                        }
                        break;
                    }
                }
                // dialog size
                b_info_context.width_blocks = 29;
                switch (get_height_id()) {
                    case 1:  b_info_context.height_blocks = 16; break;
                    case 2:  b_info_context.height_blocks = 18; break;
                    case 3:  b_info_context.height_blocks = 19; break;
                    case 4:  b_info_context.height_blocks = 14; break;
                    case 5:  b_info_context.height_blocks = 23; break;
                    default:  b_info_context.height_blocks = 22; break;
                }
                // dialog placement
                int s_width = screen_data.width;
                int s_height = screen_data.height;
                b_info_context.x_offset = center_in_city(BLOCK_SIZE * b_info_context.width_blocks);
                if (s_width >= 1024 && s_height >= 768) {
                    b_info_context.x_offset = mouse_data.x - 225;
                    b_info_context.y_offset = mouse_data.y - 250;
                    int dialog_width = BLOCK_SIZE * b_info_context.width_blocks;
                    int dialog_height = BLOCK_SIZE * b_info_context.height_blocks;
                    int stub;
                    city_view_get_viewport(&stub, &stub, &width, &stub);
                    width -= MARGIN_POSITION;
                    if (b_info_context.y_offset + dialog_height > screen_data.height - MARGIN_POSITION) {
                        b_info_context.y_offset -= dialog_height;
                    }
                    b_info_context.y_offset = (b_info_context.y_offset < MIN_Y_POSITION) ? MIN_Y_POSITION : b_info_context.y_offset;
                    if (b_info_context.x_offset + dialog_width > width) {
                        b_info_context.x_offset = width - dialog_width;
                    }
                } else if (s_height >= 600 && mouse_data.y <= (s_height - 24) / 2 + 24) {
                    b_info_context.y_offset = s_height - BLOCK_SIZE * b_info_context.height_blocks - MARGIN_POSITION;
                } else {
                    b_info_context.y_offset = MIN_Y_POSITION;
                }
                window_show(&window);
            }
        } else {
            building_construction_cancel();
            window_data.refresh_on_draw = 1;
        }
    }
}

static void handle_input_build_menu(struct mouse_t *m, struct hotkeys_t *h)
{
    if (generic_buttons_handle_mouse(m, get_sidebar_x_offset_build_menu() - MENU_X_OFFSET_BUILD_MENU,
        build_menu_data.y_offset + MENU_Y_OFFSET_BUILD_MENU, build_menu_buttons, build_menu_data.num_items_to_draw, &build_menu_data.focus_button_id)) {
        return;
    }
    if (view_data.sidebar_collapsed) {
        image_buttons_handle_mouse(m, screen_data.width - SIDEBAR_COLLAPSED_WIDTH, 24, buttons_build_collapsed, sizeof(buttons_build_collapsed) / sizeof(struct image_button_t), 0);
    } else {
        image_buttons_handle_mouse(m, screen_data.width - SIDEBAR_EXPANDED_WIDTH, 24, buttons_build_expanded, sizeof(buttons_build_expanded) / sizeof(struct image_button_t), 0);
    }
    if (m->right.went_up || h->escape_pressed
    || (m->left.went_up && // click outside build menu
        (m->x < get_sidebar_x_offset_build_menu() - MENU_X_OFFSET_BUILD_MENU - MENU_CLICK_MARGIN ||
            m->x > get_sidebar_x_offset_build_menu() + MENU_CLICK_MARGIN ||
            m->y < build_menu_data.y_offset + MENU_Y_OFFSET_BUILD_MENU - MENU_CLICK_MARGIN ||
            m->y > build_menu_data.y_offset + MENU_Y_OFFSET_BUILD_MENU + MENU_CLICK_MARGIN + MENU_ITEM_HEIGHT * build_menu_data.num_items_to_draw))) {
        build_menu_data.selected_menu = MENU_NONE;
        build_menu_data.selected_submenu = MENU_NONE;
        window_city_show();
        return;
    }
}

static void draw_buttons_expanded(int x_offset)
{
    buttons_build_expanded[12].enabled = undo_data.ready && undo_data.available;
    for (int i = 0; i < BUILD_MENU_BUTTONS_COUNT; i++) {
        buttons_build_expanded[i].enabled = build_menus[i].is_enabled;
    }
    image_buttons_draw(x_offset, 24, buttons_overlays_collapse_sidebar, 2);
    image_buttons_draw(x_offset, 24, buttons_build_expanded, sizeof(buttons_build_expanded) / sizeof(struct image_button_t));
    image_buttons_draw(x_offset, 24, buttons_top_expanded, sizeof(buttons_top_expanded) / sizeof(struct image_button_t));
}

static void draw_number_of_messages(int x_offset)
{
    int messages = message_data.total_messages;
    buttons_build_expanded[13].enabled = messages > 0;
    buttons_build_expanded[14].enabled = message_data.problem_count;
    if (messages) {
        text_draw_number_centered_colored(messages, x_offset + 74, 452, 32, FONT_SMALL_PLAIN, COLOR_BLACK);
        text_draw_number_centered_colored(messages, x_offset + 73, 453, 32, FONT_SMALL_PLAIN, COLOR_WHITE);
    }
}

static void button_help_message_list(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_message_dialog_show(MESSAGE_DIALOG_MESSAGES, window_city_draw_all);
}

static void button_close_message_list(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    window_city_show();
}

static void on_scroll_message_list(void);

static struct scrollbar_type_t scrollbar_message_list = { 432, 112, 208, on_scroll_message_list, 0, 0, 0, 0, 0, 0 };

static void on_scroll_message_list(void)
{
    message_data.scroll_position = scrollbar_message_list.scroll_position;
    window_invalidate();
}

static void button_message_message_list(int param1, __attribute__((unused)) int param2)
{
    int id = message_data.current_message_id = scrollbar_message_list.scroll_position + param1;
    if (id < message_data.total_messages) {
        struct city_message_t *msg = &message_data.messages[id];
        message_data.messages[id].is_read = 1;
        window_message_dialog_show_city_message(
            city_message_get_text_id(msg->message_type),
            msg->year, msg->month, msg->param1, msg->param2,
            city_message_get_advisor(msg->message_type),
            0);
    }
}
static void button_delete_message_list(int id_to_delete, __attribute__((unused)) int param2)
{
    int id = message_data.current_message_id = scrollbar_message_list.scroll_position + id_to_delete;
    if (id < message_data.total_messages) {
        message_data.messages[id].message_type = 0;
        city_message_sort_and_compact();
        scrollbar_update_max(&scrollbar_message_list, message_data.total_messages - MAX_MESSAGES_IN_WINDOW);
        window_invalidate();
    }
}

static struct image_button_t image_button_help = {
    0, 0, 27, 27, IB_NORMAL, GROUP_CONTEXT_ICONS, 0, button_help_message_list, button_none, 0, 0, 1, 0, 0, 0
};
static struct image_button_t image_button_close_message_list = {
    0, 0, 24, 24, IB_NORMAL, GROUP_CONTEXT_ICONS, 4, button_close_message_list, button_none, 0, 0, 1, 0, 0, 0
};
static struct generic_button_t generic_buttons_messages[] = {
    {0, 0, 412, 18, button_message_message_list, button_delete_message_list, 0, 0},
    {0, 20, 412, 18, button_message_message_list, button_delete_message_list, 1, 0},
    {0, 40, 412, 18, button_message_message_list, button_delete_message_list, 2, 0},
    {0, 60, 412, 18, button_message_message_list, button_delete_message_list, 3, 0},
    {0, 80, 412, 18, button_message_message_list, button_delete_message_list, 4, 0},
    {0, 100, 412, 18, button_message_message_list, button_delete_message_list, 5, 0},
    {0, 120, 412, 18, button_message_message_list, button_delete_message_list, 6, 0},
    {0, 140, 412, 18, button_message_message_list, button_delete_message_list, 7, 0},
    {0, 160, 412, 18, button_message_message_list, button_delete_message_list, 8, 0},
    {0, 180, 412, 18, button_message_message_list, button_delete_message_list, 9, 0},
};

static void draw_background_message_list(void)
{
    window_city_draw_all();
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    message_list_data.width_blocks = 30;
    message_list_data.height_blocks = 22;
    message_list_data.x_text = 16;
    message_list_data.y_text = 112;
    message_list_data.text_width_blocks = message_list_data.width_blocks - 4;
    message_list_data.text_height_blocks = message_list_data.height_blocks - 9;
    outer_panel_draw(0, 32, message_list_data.width_blocks, message_list_data.height_blocks);
    lang_text_draw_centered(63, 0, 0, 48, BLOCK_SIZE * message_list_data.width_blocks, FONT_LARGE_BLACK);
    inner_panel_draw(message_list_data.x_text, message_list_data.y_text, message_list_data.text_width_blocks, message_list_data.text_height_blocks);

    if (message_data.total_messages > 0) {
        lang_text_draw(63, 2, message_list_data.x_text + 42, message_list_data.y_text - 12, FONT_SMALL_PLAIN);
        lang_text_draw(63, 3, message_list_data.x_text + 180, message_list_data.y_text - 12, FONT_SMALL_PLAIN);
        lang_text_draw_multiline(63, 4,
            message_list_data.x_text + 50, message_list_data.y_text + 12 + BLOCK_SIZE * message_list_data.text_height_blocks,
            BLOCK_SIZE * message_list_data.text_width_blocks - 100, FONT_NORMAL_BLACK);
    } else {
        lang_text_draw_multiline(63, 1,
            message_list_data.x_text + 16, message_list_data.y_text + 80,
            BLOCK_SIZE * message_list_data.text_width_blocks - 48, FONT_NORMAL_GREEN);
    }
    set_translation(0, 0);
}

static void draw_foreground_message_list(void)
{
    set_translation(screen_data.dialog_offset.x, screen_data.dialog_offset.y);
    image_buttons_draw(16, 32 + BLOCK_SIZE * message_list_data.height_blocks - 42, &image_button_help, 1);
    image_buttons_draw(BLOCK_SIZE * message_list_data.width_blocks - 38, 32 + BLOCK_SIZE * message_list_data.height_blocks - 36,
        &image_button_close_message_list, 1);

    int total_messages = message_data.total_messages;
    if (total_messages > 0) {
        int max = total_messages < MAX_MESSAGES_IN_WINDOW ? total_messages : MAX_MESSAGES_IN_WINDOW;
        int index = scrollbar_message_list.scroll_position;
        for (int i = 0; i < max; i++, index++) {
            struct city_message_t *msg = &message_data.messages[index];
            struct lang_message_t *lang_msg = &lang_data.message_entries[city_message_get_text_id(msg->message_type)];
            int image_offset = 0;
            if (lang_msg->message_type == MESSAGE_TYPE_DISASTER) {
                image_offset = 2;
            }
            if (msg->is_read) {
                image_draw(image_data_s.group_image_ids[GROUP_ARROW_MESSAGE_PROBLEMS] + 15 + image_offset,
                    message_list_data.x_text + 12, message_list_data.y_text + 6 + 20 * i);
            } else {
                image_draw(image_data_s.group_image_ids[GROUP_ARROW_MESSAGE_PROBLEMS] + 14 + image_offset,
                    message_list_data.x_text + 12, message_list_data.y_text + 6 + 20 * i);
            }
            int font = FONT_NORMAL_WHITE;
            if (message_list_data.focus_button_id == i + 1) {
                font = FONT_NORMAL_RED;
            }
            int width = lang_text_draw(25, msg->month, message_list_data.x_text + 42, message_list_data.y_text + 8 + 20 * i, font);
            lang_text_draw_year(msg->year,
                message_list_data.x_text + 42 + width, message_list_data.y_text + 8 + 20 * i, font);
            text_draw(
                lang_msg->title.text,
                message_list_data.x_text + 180, message_list_data.y_text + 8 + 20 * i, font, 0);
        }
        scrollbar_draw(&scrollbar_message_list);
    }

    set_translation(0, 0);
}

static void handle_input_message_list(struct mouse_t *m, struct hotkeys_t *h)
{
    if (h->show_messages) {
        window_city_show();
    }
    struct mouse_t *m_dialog = mouse_in_dialog(m);
    int old_button_id = message_list_data.focus_button_id;
    message_list_data.focus_button_id = 0;

    int button_id;
    int handled = image_buttons_handle_mouse(m_dialog, 16, 32 + BLOCK_SIZE * message_list_data.height_blocks - 42,
        &image_button_help, 1, &button_id);
    if (button_id) {
        message_list_data.focus_button_id = 11;
    }
    handled |= image_buttons_handle_mouse(m_dialog, BLOCK_SIZE * message_list_data.width_blocks - 38,
        32 + BLOCK_SIZE * message_list_data.height_blocks - 36, &image_button_close_message_list, 1, &button_id);
    if (button_id) {
        message_list_data.focus_button_id = 12;
    }
    if (scrollbar_handle_mouse(&scrollbar_message_list, m_dialog)) {
        message_list_data.focus_button_id = 13;
    }
    handled |= generic_buttons_handle_mouse(m_dialog, message_list_data.x_text, message_list_data.y_text + 4,
        generic_buttons_messages, MAX_MESSAGES_IN_WINDOW, &button_id);
    if (!message_list_data.focus_button_id) {
        message_list_data.focus_button_id = button_id;
    }
    if (button_id && old_button_id != button_id) {
        window_invalidate();
    }
    if (!handled && (m->right.went_up || h->escape_pressed)) {
        button_close_message_list(0, 0);
    }
}

static void window_message_list_show(void)
{
    struct window_type_t window = {
        WINDOW_MESSAGE_LIST,
        draw_background_message_list,
        draw_foreground_message_list,
        handle_input_message_list,
    };
    city_message_sort_and_compact();
    scrollbar_init(&scrollbar_message_list, message_data.scroll_position, message_data.total_messages - MAX_MESSAGES_IN_WINDOW);
    window_show(&window);
}