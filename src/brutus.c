#define SDL_MAIN_HANDLED
#include "SDL.h"
#include "SDL_mixer.h"

#include <direct.h>
#include <stdnoreturn.h>
#include <signal.h>
#if defined (__MINGW32__)
#include <dirent.h>
#else
#include "../ext/dirent/dirent.h"
#endif

#include <math.h>
#include <stdio.h>
#include <time.h>

typedef struct smacker_t *smacker;
typedef void (map_callback)(int x, int y, int grid_offset);
typedef void (*back_sidebar_draw_function)(void);
typedef back_sidebar_draw_function slide_finished_function;
typedef void (*front_sidebar_draw_function)(int x_offset);

#define VERSION "v1.0.0"
#define MINIMUM_RESOLUTION_X 1280
#define MINIMUM_RESOLUTION_Y 800

#define COLOR_BLACK 0x000000
#define COLOR_RED 0xff0000
#define COLOR_WHITE 0xffffff
#define COLOR_SG2_TRANSPARENT 0xf700ff
#define COLOR_TOOLTIP 0x424242
#define COLOR_SIDEBAR 0xbdb592
#define COLOR_FONT_RED COLOR_RED
#define COLOR_FONT_BLUE 0x0055ff
#define COLOR_FONT_YELLOW 0xe7e75a
#define COLOR_FONT_ORANGE 0xff5a08
#define COLOR_FONT_ORANGE_LIGHT 0xffa500
#define COLOR_FONT_LIGHT_GRAY 0xb3b3b3
#define COLOR_INSET_LIGHT 0xffffff
#define COLOR_INSET_DARK 0x848484
#define COLOR_MASK_NONE 0xffffff
#define COLOR_MASK_RED 0xff0818
#define COLOR_MASK_GREEN 0x18ff18
#define COLOR_MASK_BLUE 0x663377ff
#define COLOR_MASK_LEGION_HIGHLIGHT 0x66ff3300
#define COLOR_MINIMAP_VIEWPORT 0xe7e75a
#define COLOR_MINIMAP_DARK 0x424242
#define COLOR_MINIMAP_LIGHT 0xc6c6c6
#define COLOR_MINIMAP_SOLDIER 0xf70000
#define COLOR_MINIMAP_SELECTED_SOLDIER 0xffffff
#define COLOR_MINIMAP_ENEMY_CENTRAL 0x7b0000
#define COLOR_MINIMAP_ENEMY_NORTHERN 0x1800ff
#define COLOR_MINIMAP_ENEMY_DESERT 0x08007b
#define COLOR_MOUSE_DARK_GRAY 0x3f3f3f
#define COLOR_MOUSE_MEDIUM_GRAY 0x737373
#define COLOR_MOUSE_LIGHT_GRAY 0xb3b3b3
#define ALPHA_TRANSPARENT 0x00000000
#define ALPHA_OPAQUE 0xff000000
#define ALPHA_MASK_SEMI_TRANSPARENT 0x48000000
#define DIR_PATH_MAX 255
#define FILE_LINE_LENGTH_MAX 100
#define FILE_NAME_LENGTH_MAX 64

#define TEXT_Y_OFFSET_FROM_LABEL 4
#define LABEL_IMG_HEIGHT 20


#define SCROLLBAR_BUTTON_WIDTH 39
#define SCROLLBAR_BUTTON_HEIGHT 26
#define SCROLLBAR_DOT_HEIGHT 23

#define BUTTON_REPEAT_DELAY_TIME 75

enum {
    FONT_NORMAL_PLAIN,
    FONT_NORMAL_BLACK,
    FONT_NORMAL_WHITE,
    FONT_NORMAL_RED,
    FONT_LARGE_PLAIN,
    FONT_LARGE_BLACK,
    FONT_LARGE_BROWN,
    FONT_SMALL_PLAIN,
    FONT_NORMAL_GREEN,
    FONT_NORMAL_BROWN,
};
enum {
    WINDOW_INTRO_VIDEOS,
    WINDOW_LOGO,
    WINDOW_MAIN_MENU,
    WINDOW_CCK_SELECTION,
    WINDOW_MISSION_BRIEFING,
    WINDOW_CITY,
    WINDOW_TOP_MENU,
    WINDOW_REPLAY_MAP,
    WINDOW_FILE_DIALOG,
    WINDOW_EXIT_TO_MAIN_MENU,
    WINDOW_DISPLAY_OPTIONS,
    WINDOW_SOUND_OPTIONS,
    WINDOW_SPEED_OPTIONS,
    WINDOW_OVERLAY_MENU,
    WINDOW_SLIDING_SIDEBAR,
    WINDOW_ADVISOR_LABOR,
    WINDOW_ADVISOR_MILITARY,
    WINDOW_ADVISOR_IMPERIAL,
    WINDOW_ADVISOR_RATINGS,
    WINDOW_ADVISOR_TRADE,
    WINDOW_ADVISOR_POPULATION,
    WINDOW_ADVISOR_HEALTH,
    WINDOW_ADVISOR_EDUCATION,
    WINDOW_ADVISOR_ENTERTAINMENT,
    WINDOW_ADVISOR_RELIGION,
    WINDOW_ADVISOR_FINANCIAL,
    WINDOW_ADVISOR_CHIEF,
    WINDOW_LABOR_PRIORITY,
    WINDOW_GIFT_TO_EMPEROR,
    WINDOW_DONATE_TO_CITY,
    WINDOW_SET_SALARY,
    WINDOW_RESOURCE_SETTINGS,
    WINDOW_TRADE_PRICES,
    WINDOW_EMPIRE,
    WINDOW_HOLD_FESTIVAL,
    WINDOW_MESSAGE_DIALOG,
    WINDOW_MESSAGE_LIST,
    WINDOW_CONTEXT_INFO,
    WINDOW_GRANARY_ORDERS,
    WINDOW_WAREHOUSE_ORDERS,
    WINDOW_VICTORY_DIALOG,
    WINDOW_VICTORY_VIDEO,
    WINDOW_VICTORY_SUMMARY,
    WINDOW_DEFEAT_SUMMARY,
    WINDOW_EDITOR_NOT_FOUND,
    WINDOW_EDITOR_MAP,
    WINDOW_EDITOR_TOP_MENU,
    WINDOW_EDITOR_ATTRIBUTES,
    WINDOW_EDITOR_BRIEFING,
    WINDOW_EDITOR_STARTING_CONDITIONS,
    WINDOW_EDITOR_WIN_CRITERIA,
    WINDOW_EDITOR_ALLOWED_BUILDINGS,
    WINDOW_EDITOR_SPECIAL_EVENTS,
    WINDOW_EDITOR_REQUESTS,
    WINDOW_EDITOR_EDIT_REQUEST,
    WINDOW_EDITOR_CUSTOM_MESSAGES,
    WINDOW_EDITOR_EDIT_CUSTOM_MESSAGE_ATTRIBUTES,
    WINDOW_EDITOR_EDIT_CUSTOM_MESSAGE_TITLE,
    WINDOW_EDITOR_EDIT_CUSTOM_MESSAGE_TEXT,
    WINDOW_EDITOR_EARTHQUAKES,
    WINDOW_EDITOR_EDIT_EARTHQUAKE,
    WINDOW_EDITOR_INVASIONS,
    WINDOW_EDITOR_EDIT_INVASION,
    WINDOW_EDITOR_PRICE_CHANGES,
    WINDOW_EDITOR_EDIT_PRICE_CHANGE,
    WINDOW_EDITOR_DEMAND_CHANGES,
    WINDOW_EDITOR_EDIT_DEMAND_CHANGE,
    WINDOW_EDITOR_EMPIRE,
    WINDOW_CONFIGS,
    WINDOW_HOTKEY_CONFIGS,
    WINDOW_HOTKEY_EDITOR,
};
static FILE *fp;
static char *reusable_char_ptr;
static char reusable_char_array[DIR_PATH_MAX];
static char *short_month_names[] = {
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec",
};
static char *long_month_names[] = {
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December",
};

#define MAX_BRIEFING_LINES 26
#define TEXT_MAX_CHARS_PER_LINE 250
#define MAX_BRIEFING_LENGTH 3000
#define BRIEFING_MAX_LINE_WIDTH 950
static int text_field_active;
static int previous_text_field_active;
static int input_text_x;
static int input_text_y;
static int input_text_font;
static char input_text_string_backup[MAX_BRIEFING_LENGTH];
static char input_text_string[MAX_BRIEFING_LENGTH]; // mission briefing is currently the longest possible input string
static int input_text_current_length; // curent length in chars of the whole text
static int input_text_max_length; // max length in chars of the whole text
static int text_num_completed_lines;
static int input_text_max_lines;
static int input_text_field_line_max_width; // maximum width in pixels of any line
static int input_text_cursor_position;
static int input_text_cursor_current_line;
static int input_text_current_line_cursor_position;
static int input_text_cursor_current_x_offset;
static int input_text_numeric_only;
static int input_text_numeric_allow_negative;

static int dropdown_list_selected;

static int editor_build_menu_selected;

struct text_char_t {
    int position_in_text;
    int x_start;
    int x_end;
};

static struct {
    int num_chars;
    int line_width;
    int line_y;
    struct text_char_t chars[TEXT_MAX_CHARS_PER_LINE];
} text_lines[MAX_BRIEFING_LINES];

// settings data
enum {
    SETTINGS_FULLSCREEN,
    SETTINGS_WINDOW_WIDTH,
    SETTINGS_WINDOW_HEIGHT,
    SETTINGS_MUSIC_ENABLED,
    SETTINGS_MUSIC_VOLUME,
    SETTINGS_SPEECH_ENABLED,
    SETTINGS_SPEECH_VOLUME,
    SETTINGS_SOUND_EFFECTS_ENABLED,
    SETTINGS_SOUND_EFFECTS_VOLUME,
    SETTINGS_CITY_SOUNDS_ENABLED,
    SETTINGS_CITY_SOUNDS_VOLUME,
    SETTINGS_GAME_SPEED,
    SETTINGS_SCROLL_SPEED,
    SETTINGS_WARNINGS_ENABLED,
    SETTINGS_VICTORY_VIDEO,
    SETTINGS_LAST_ADVISOR,
    SETTINGS_SIDEBAR_EXPANDED,
    SETTINGS_MAX_ENTRIES
};
enum {
    ADVISOR_LABOR = 0,
    ADVISOR_MILITARY = 1,
    ADVISOR_IMPERIAL = 2,
    ADVISOR_RATINGS = 3,
    ADVISOR_TRADE = 4,
    ADVISOR_POPULATION = 5,
    ADVISOR_HEALTH = 6,
    ADVISOR_EDUCATION = 7,
    ADVISOR_ENTERTAINMENT = 8,
    ADVISOR_RELIGION = 9,
    ADVISOR_FINANCIAL = 10,
    ADVISOR_CHIEF = 11,
    ADVISOR_MAX_ENTRIES = 12,
};
struct config_pair_t {
    char *config_string;
    int config_value;
};
static struct config_pair_t settings[SETTINGS_MAX_ENTRIES] = {
    {"fullscreen", 0},
    {"window_width", MINIMUM_RESOLUTION_X},
    {"window_height", MINIMUM_RESOLUTION_Y},
    {"sound_effects_enabled", 1},
    {"sound_effects_volume", 50},
    {"music_enabled", 1},
    {"music_volume", 50},
    {"speech_enabled", 1},
    {"speech_volume", 50},
    {"city_sounds_enabled", 1},
    {"city_sounds_volume", 50},
    {"game_speed", 80},
    {"scroll_speed", 90},
    {"warnings_enabled", 1},
    {"victory_video_switch", 0},
    {"last_advisor", ADVISOR_CHIEF},
    {"sidebar_expanded", 1},
};

// intro videos data
static char *intro_videos_files_names[] = {
    "smk/logo.smk",
    "smk/intro.smk",
    "smk/credits.smk",
};
static int current_intro_video;

// main menu data
#define MAIN_MENU_BACKGROUND_IMG_ID 8983
static struct {
    int x_scaled;
    int y_scaled;
    int width_scaled;
    char *text;
} image_buttons_main_menu[5] = {
    {0, 0, 0, "Play scenario"},
    {0, 0, 0, "Load saved game"},
    {0, 0, 0, "Scenario editor"},
    {0, 0, 0, "Options"},
    {0, 0, 0, "Exit"}
};

// play scenario data
#define SCENARIO_FILES_MAX 128
#define MAX_SCENARIOS_SHOWN 15
static struct {
    int show_minimap;
    char selected_scenario_filename[FILE_NAME_LENGTH_MAX];
    char selected_scenario_display[FILE_NAME_LENGTH_MAX];
    struct dir_listing *scenarios;
} cck_selection_data;

// city data
#define TOP_BAR_HEIGHT 24
#define SIDEBAR_EXPANDED_WIDTH 162
static int map_center_x;
static int map_center_y;
static int sidebar_x_offset;

// top menu data
static struct {
    int offset_funds;
    int offset_population;
    int offset_date;
    int open_sub_menu;
} top_menu_data;

// file dialog data
#define MAX_FILE_DIALOG_FILES_SHOWN 19
struct file_type_data_t {
    char extension[4];
    char last_loaded_file[FILE_NAME_LENGTH_MAX];
};
static struct {
    uint32_t message_not_exist_start_time;
    int type;
    int dialog_type;
    struct dir_listing *file_list;
    struct file_type_data_t *file_data;
    char selected_file[FILE_NAME_LENGTH_MAX];
} file_dialog_data;
static struct file_type_data_t saved_game_data = { "sav", {0} };
static struct file_type_data_t file_type_scenario_data = { "map", {0} };

// overlay menu data
#define OVERLAY_NUM_SUBMENUS 8
#define OVERLAY_SUBMENUS_X_OFFSET 10
#define OVERLAY_SUBMENUS_BUTTONS_WIDTH 160
#define OVERLAY_SUBMENUS_SPACING 4
static struct {
    char *submenu_name;
    int num_items;
    char *item_names[12];
} overlay_submenus[OVERLAY_NUM_SUBMENUS] = {
    {"Normal", 0, {0}},
    {"Water", 0, {0}},
    {"Risks", 5, {"Fire", "Damage", "Crime", "Native", "Problems"}},
    {"Entertainment", 5, {"Overall", "Theater", "Amphitheater", "Colosseum", "Hippodrome"}},
    {"Education", 4, {"Overall", "Schools", "Library", "Academy"}},
    {"Health", 4, {"Barber", "Baths", "Clinics", "Hospital"}},
    {"Commerce", 3, {"Tax income", "Food stocks", "Desirability"}},
    {"Religion", 0, {0}},
};
static struct {
    int selected_submenu;
    int num_submenu_items;
} overlay_menu_data;

// editor new map data
static struct {
    int width;
    int height;
} MAP_SIZES[] = {
    {40, 40},
    {60, 60},
    {80, 80},
    {100, 100},
    {120, 120},
    {160, 160}
};

// editor attributes data
#define MAX_BRIEF_DESCRIPTION_LENGTH 32

// starting conditions data
static char *initial_rank_strings[] = {
    "Citizen",
    "Clerk",
    "Engineer",
    "Architect",
    "Quaestor",
    "Procurator",
    "Aedile",
    "Praetor",
    "Consul",
    "Proconsul",
    "Caesar",
};

// edit requests data
static int id_edit_request;

// configs data
#define MAX_PLAYER_NAME_LENGTH 24
enum {
    CONFIG_UI_SIDEBAR_INFO,
    CONFIG_UI_SHOW_INTRO_VIDEOS,
    CONFIG_UI_DISABLE_MOUSE_EDGE_SCROLLING,
    CONFIG_UI_DISABLE_RIGHT_CLICK_MAP_DRAG,
    CONFIG_UI_VISUAL_FEEDBACK_ON_DELETE,
    CONFIG_UI_HIGHLIGHT_LEGIONS,
    CONFIG_MONTHLY_AUTOSAVE,
    CONFIGS_MAX_ENTRIES
};
static char CONFIGS_FILE_PATH[DIR_PATH_MAX]; // the path to "brutus.configs" within the Brutus directory
static char configs_player_name[MAX_PLAYER_NAME_LENGTH] = "BRUTUS";
static struct config_pair_t configs[CONFIGS_MAX_ENTRIES] = {
    {"Extra information in the control panel", 1},
    {"Play intro videos", 0},
    {"Disable map scrolling on window edge", 0},
    {"Disable right click to drag the map", 0},
    {"Improve visual feedback when clearing land", 1},
    {"Highlight legion on cursor hover", 1},
    {"Monthly autosave enabled", 0},
};

// hotkey configs data
#define HOTKEY_CONFIGS_NUM_VISIBLE_ROWS 20
enum {
    HOTKEY_HEADER_ARROW_KEYS,
    HOTKEY_ARROW_UP,
    HOTKEY_ARROW_DOWN,
    HOTKEY_ARROW_LEFT,
    HOTKEY_ARROW_RIGHT,
    HOTKEY_HEADER_GLOBAL_HOTKEYS,
    HOTKEY_TOGGLE_FULLSCREEN,
    HOTKEY_RESET_WINDOW,
    HOTKEY_SAVE_SCREENSHOT,
    HOTKEY_SAVE_CITY_SCREENSHOT,
    HOTKEY_LOAD_FILE,
    HOTKEY_SAVE_FILE,
    HOTKEY_HEADER_CITY_HOTKEYS,
    HOTKEY_DECREASE_GAME_SPEED,
    HOTKEY_INCREASE_GAME_SPEED,
    HOTKEY_TOGGLE_PAUSE,
    HOTKEY_ROTATE_MAP_LEFT,
    HOTKEY_ROTATE_MAP_RIGHT,
    HOTKEY_REPLAY_MAP,
    HOTKEY_CYCLE_LEGION,
    HOTKEY_RETURN_LEGIONS_TO_FORT,
    HOTKEY_SHOW_LAST_ADVISOR,
    HOTKEY_SHOW_EMPIRE_MAP,
    HOTKEY_SHOW_MESSAGES,
    HOTKEY_GO_TO_PROBLEM,
    HOTKEY_HEADER_OVERLAYS,
    HOTKEY_SHOW_OVERLAY_WATER,
    HOTKEY_SHOW_OVERLAY_FIRE,
    HOTKEY_SHOW_OVERLAY_DAMAGE,
    HOTKEY_SHOW_OVERLAY_CRIME,
    HOTKEY_SHOW_OVERLAY_PROBLEMS,
    HOTKEY_HEADER_CITY_MAP_BOOKMARKS,
    HOTKEY_GO_TO_BOOKMARK_1,
    HOTKEY_GO_TO_BOOKMARK_2,
    HOTKEY_GO_TO_BOOKMARK_3,
    HOTKEY_GO_TO_BOOKMARK_4,
    HOTKEY_SET_BOOKMARK_1,
    HOTKEY_SET_BOOKMARK_2,
    HOTKEY_SET_BOOKMARK_3,
    HOTKEY_SET_BOOKMARK_4,
    HOTKEY_HEADER_EDITOR,
    HOTKEY_EDITOR_TOGGLE_BATTLE_INFO,
    HOTKEY_HEADER_CHEATS,
    HOTKEY_CHEAT_MONEY,
    HOTKEY_CHEAT_INVASION,
    HOTKEY_CHEAT_VICTORY,
    HOTKEY_HEADER_CONSTRUCTION_HOTKEYS,
    HOTKEY_BUILD_CLONE,
    HOTKEY_CYCLE_BUILDINGS,
    HOTKEY_CYCLE_BUILDINGS_REVERSE,
    HOTKEY_UNDO,
    HOTKEY_BUILD_VACANT_HOUSE,
    HOTKEY_BUILD_CLEAR_LAND,
    HOTKEY_BUILD_ROAD,
    HOTKEY_BUILD_RESERVOIR,
    HOTKEY_BUILD_AQUEDUCT,
    HOTKEY_BUILD_FOUNTAIN,
    HOTKEY_BUILD_WELL,
    HOTKEY_BUILD_DOCTOR,
    HOTKEY_BUILD_BATHHOUSE,
    HOTKEY_BUILD_BARBER,
    HOTKEY_BUILD_HOSPITAL,
    HOTKEY_BUILD_SMALL_TEMPLE_CERES,
    HOTKEY_BUILD_SMALL_TEMPLE_NEPTUNE,
    HOTKEY_BUILD_SMALL_TEMPLE_MERCURY,
    HOTKEY_BUILD_SMALL_TEMPLE_MARS,
    HOTKEY_BUILD_SMALL_TEMPLE_VENUS,
    HOTKEY_BUILD_LARGE_TEMPLE_CERES,
    HOTKEY_BUILD_LARGE_TEMPLE_NEPTUNE,
    HOTKEY_BUILD_LARGE_TEMPLE_MERCURY,
    HOTKEY_BUILD_LARGE_TEMPLE_MARS,
    HOTKEY_BUILD_LARGE_TEMPLE_VENUS,
    HOTKEY_BUILD_ORACLE,
    HOTKEY_BUILD_SCHOOL,
    HOTKEY_BUILD_LIBRARY,
    HOTKEY_BUILD_ACADEMY,
    HOTKEY_BUILD_MISSION_POST,
    HOTKEY_BUILD_THEATER,
    HOTKEY_BUILD_ACTOR_COLONY,
    HOTKEY_BUILD_AMPHITHEATER,
    HOTKEY_BUILD_GLADIATOR_SCHOOL,
    HOTKEY_BUILD_LION_HOUSE,
    HOTKEY_BUILD_COLOSSEUM,
    HOTKEY_BUILD_CHARIOT_MAKER,
    HOTKEY_BUILD_HIPPODROME,
    HOTKEY_BUILD_GARDENS,
    HOTKEY_BUILD_PLAZA,
    HOTKEY_BUILD_SMALL_STATUE,
    HOTKEY_BUILD_MEDIUM_STATUE,
    HOTKEY_BUILD_LARGE_STATUE,
    HOTKEY_BUILD_GOVERNORS_HOUSE,
    HOTKEY_BUILD_GOVERNORS_VILLA,
    HOTKEY_BUILD_GOVERNORS_PALACE,
    HOTKEY_BUILD_FORUM,
    HOTKEY_BUILD_SENATE,
    HOTKEY_BUILD_TRIUMPHAL_ARCH,
    HOTKEY_BUILD_ENGINEERS_POST,
    HOTKEY_BUILD_LOW_BRIDGE,
    HOTKEY_BUILD_SHIP_BRIDGE,
    HOTKEY_BUILD_SHIPYARD,
    HOTKEY_BUILD_WHARF,
    HOTKEY_BUILD_DOCK,
    HOTKEY_BUILD_PREFECTURE,
    HOTKEY_BUILD_WALL,
    HOTKEY_BUILD_TOWER,
    HOTKEY_BUILD_GATEHOUSE,
    HOTKEY_BUILD_FORT_LEGIONARIES,
    HOTKEY_BUILD_FORT_JAVELIN,
    HOTKEY_BUILD_FORT_MOUNTED,
    HOTKEY_BUILD_BARRACKS,
    HOTKEY_BUILD_MILITARY_ACADEMY,
    HOTKEY_BUILD_WHEAT_FARM,
    HOTKEY_BUILD_VEGETABLE_FARM,
    HOTKEY_BUILD_FRUIT_FARM,
    HOTKEY_BUILD_PIG_FARM,
    HOTKEY_BUILD_OLIVE_FARM,
    HOTKEY_BUILD_VINES_FARM,
    HOTKEY_BUILD_CLAY_PIT,
    HOTKEY_BUILD_TIMBER_YARD,
    HOTKEY_BUILD_MARBLE_QUARRY,
    HOTKEY_BUILD_IRON_MINE,
    HOTKEY_BUILD_OIL_WORKSHOP,
    HOTKEY_BUILD_WINE_WORKSHOP,
    HOTKEY_BUILD_POTTERY_WORKSHOP,
    HOTKEY_BUILD_FURNITURE_WORKSHOP,
    HOTKEY_BUILD_WEAPONS_WORKSHOP,
    HOTKEY_BUILD_MARKET,
    HOTKEY_BUILD_GRANARY,
    HOTKEY_BUILD_WAREHOUSE,
    HOTKEY_CONFIGS_NUMBER_ROWS
};
static char HOTKEY_CONFIGS_FILE_PATH[DIR_PATH_MAX]; // the path to "brutus.hconfigs" within the Brutus directory
static int is_key_scrolling_up;
static int is_key_scrolling_down;
static int is_key_scrolling_left;
static int is_key_scrolling_right;
struct hotkey_mapping_t {
    char *action_name;
    int is_header;
    int sdl_mods;
    int sdl_key;
};
static struct hotkey_mapping_t hotkey_mappings[HOTKEY_CONFIGS_NUMBER_ROWS] = {
    {"Arrow keys", 1, 0, 0},
    {"Up", 0, 0, 0},
    {"Down", 0, 0, 0},
    {"Left", 0, 0, 0},
    {"Right", 0, 0, 0},
    {"Global hotkeys", 1, 0, 0},
    {"Toggle fullscreen", 0, 0, 0},
    {"Reset window", 0, 0, 0},
    {"Save screenshot", 0, 0, 0},
    {"Save full city screenshot", 0, 0, 0},
    {"Load file", 0, 0, 0},
    {"Save file", 0, 0, 0},
    {"City hotkeys", 1, 0, 0},
    {"Decrease game speed", 0, 0, 0},
    {"Increase game speed", 0, 0, 0},
    {"Toggle pause", 0, 0, 0},
    {"Rotate map left", 0, 0, 0},
    {"Rotate map right", 0, 0, 0},
    {"Replay map", 0, 0, 0},
    {"Cycle through legions", 0, 0, 0},
    {"Return legions to fort", 0, 0, 0},
    {"Show last advisor", 0, 0, 0},
    {"Show empire map", 0, 0, 0},
    {"Show messages", 0, 0, 0},
    {"Go to problem", 0, 0, 0},
    {"Overlays", 1, 0, 0},
    {"Show water overlay", 0, 0, 0},
    {"Show fire overlay", 0, 0, 0},
    {"Damage overlay", 0, 0, 0},
    {"Crime overlay", 0, 0, 0},
    {"Problems overlay", 0, 0, 0},
    {"City map bookmarks", 1, 0, 0},
    {"Go to bookmark 1", 0, 0, 0},
    {"Go to bookmark 2", 0, 0, 0},
    {"Go to bookmark 3", 0, 0, 0},
    {"Go to bookmark 4", 0, 0, 0},
    {"Set bookmark 1", 0, 0, 0},
    {"Set bookmark 2", 0, 0, 0},
    {"Set bookmark 3", 0, 0, 0},
    {"Set bookmark 4", 0, 0, 0},
    {"Editor", 1, 0, 0},
    {"Toggle battle info", 0, 0, 0},
    {"Cheats", 1, 0, 0},
    {"Cheat: money", 0, 0, 0},
    {"Cheat: invasion", 0, 0, 0},
    {"Cheat: victory", 0, 0, 0},
    {"Construction hotkeys", 1, 0, 0},
    {"Clone building under cursor", 0, 0, 0},
    {"Cycle through buildings", 0, 0, 0},
    {"Cycle back through buildings", 0, 0, 0},
    {"Undo last building", 0, 0, 0},
    {"Housing", 0, 0, 0},
    {"Clear Land", 0, 0, 0},
    {"Road", 0, 0, 0},
    {"Reservoir", 0, 0, 0},
    {"Aqueduct", 0, 0, 0},
    {"Fountain", 0, 0, 0},
    {"Well", 0, 0, 0},
    {"Doctor", 0, 0, 0},
    {"Bathhouse", 0, 0, 0},
    {"Barber", 0, 0, 0},
    {"Hospital", 0, 0, 0},
    {"Small Temple: Ceres", 0, 0, 0},
    {"Small Temple: Neptune", 0, 0, 0},
    {"Small Temple: Mercury", 0, 0, 0},
    {"Small Temple: Mars", 0, 0, 0},
    {"Small Temple: Venus", 0, 0, 0},
    {"Large Temple: Ceres", 0, 0, 0},
    {"Large Temple: Neptune", 0, 0, 0},
    {"Large Temple: Mercury", 0, 0, 0},
    {"Large Temple: Mars", 0, 0, 0},
    {"Large Temple: Venus", 0, 0, 0},
    {"Oracle", 0, 0, 0},
    {"School", 0, 0, 0},
    {"Library", 0, 0, 0},
    {"Academy", 0, 0, 0},
    {"Mission Post", 0, 0, 0},
    {"Theater", 0, 0, 0},
    {"Actor Colony", 0, 0, 0},
    {"Amphitheater", 0, 0, 0},
    {"Gladiator School", 0, 0, 0},
    {"Lion House", 0, 0, 0},
    {"Colosseum", 0, 0, 0},
    {"Chariot Maker", 0, 0, 0},
    {"Hippodrome", 0, 0, 0},
    {"Gardens", 0, 0, 0},
    {"Plaza", 0, 0, 0},
    {"Small Statue", 0, 0, 0},
    {"Medium Statue", 0, 0, 0},
    {"Large Statue", 0, 0, 0},
    {"Governors House", 0, 0, 0},
    {"Governors Villa", 0, 0, 0},
    {"Governors Palace", 0, 0, 0},
    {"Forum", 0, 0, 0},
    {"Senate", 0, 0, 0},
    {"Triumphal Arch", 0, 0, 0},
    {"Engineers Post", 0, 0, 0},
    {"Low Bridge", 0, 0, 0},
    {"Ship Bridge", 0, 0, 0},
    {"Shipyard", 0, 0, 0},
    {"Wharf", 0, 0, 0},
    {"Dock", 0, 0, 0},
    {"Prefecture", 0, 0, 0},
    {"Wall", 0, 0, 0},
    {"Tower", 0, 0, 0},
    {"Gatehouse", 0, 0, 0},
    {"Fort: Legionaries", 0, 0, 0},
    {"Fort: Javelin", 0, 0, 0},
    {"Fort: Mounted", 0, 0, 0},
    {"Barracks", 0, 0, 0},
    {"Military Academy", 0, 0, 0},
    {"Wheat Farm", 0, 0, 0},
    {"Vegetable Farm", 0, 0, 0},
    {"Fruit Farm", 0, 0, 0},
    {"Pig Farm", 0, 0, 0},
    {"Olive Farm", 0, 0, 0},
    {"Vines Farm", 0, 0, 0},
    {"Clay Pit", 0, 0, 0},
    {"Timber Yard", 0, 0, 0},
    {"Marble Quarry", 0, 0, 0},
    {"Iron Mine", 0, 0, 0},
    {"Oil Workshop", 0, 0, 0},
    {"Wine Workshop", 0, 0, 0},
    {"Pottery Workshop", 0, 0, 0},
    {"Furniture Workshop", 0, 0, 0},
    {"Weapons Workshop", 0, 0, 0},
    {"Market", 0, 0, 0},
    {"Granary", 0, 0, 0},
    {"Warehouse", 0, 0, 0},
};
static struct {
    int action_index;
    int modifiers;
    int key;
} hotkey_config_window_data;

// random pool data
#define MAX_RANDOM 100
static struct {
    uint32_t iv1;
    uint32_t iv2;
    int8_t random1_7bit;
    int16_t random1_15bit;
    int8_t random2_7bit;
    int pool_index;
    int32_t pool[MAX_RANDOM];
} random_data;

// file text data
#define FILE_TEXT_ENG "c3.eng"
#define FILE_MM_ENG "c3_mm.eng"
#define FILE_EDITOR_TEXT_ENG "c3_map.eng"
#define FILE_EDITOR_MM_ENG "c3_map_mm.eng"
#define MAX_TEXT_ENTRIES 1000
#define MAX_TEXT_DATA 200000
#define MAX_MESSAGE_ENTRIES 400
#define MAX_MESSAGE_DATA 460000

// mouse cursor data
enum {
    CURSOR_ARROW = 0,
    CURSOR_SHOVEL = 1,
    CURSOR_SWORD = 2,
    CURSOR_MAX,
};
static uint32_t mouse_colors[] = {
    ALPHA_TRANSPARENT,
    ALPHA_TRANSPARENT,
    ALPHA_TRANSPARENT,
    ALPHA_OPAQUE | COLOR_BLACK,
    ALPHA_OPAQUE | COLOR_MOUSE_DARK_GRAY,
    ALPHA_OPAQUE | COLOR_MOUSE_MEDIUM_GRAY,
    ALPHA_OPAQUE | COLOR_MOUSE_LIGHT_GRAY,
    ALPHA_OPAQUE | COLOR_WHITE
};
struct cursor_t {
    int hotspot_x;
    int hotspot_y;
    int width;
    int height;
    char *data;
};
static struct cursor_t ARROW[] = {
    {
        0, 0, 13, 21,
        "#            "
        "##           "
        "#'#          "
        "#''#         "
        "#'''#        "
        "#''''#       "
        "#'''''#      "
        "#''''''#     "
        "#'''''''#    "
        "#''''''''#   "
        "#'''''''''#  "
        "#''''''''''# "
        "#''''''######"
        "#'''#''#     "
        "#''# #''#    "
        "#'#  #''#    "
        "##    #''#   "
        "#     #''#   "
        "       #''#  "
        "       #''#  "
        "        ##   "
    }
};
static struct cursor_t SWORD[] = {
    {
        0, 0, 22, 22,
        "#####                 "
        "#'''##                "
        "#''''##               "
        "#'''''##              "
        "##'''''##             "
        " ##'''''##            "
        "  ##'''''##           "
        "   ##'''''##          "
        "    ##'''''##         "
        "     ##'''''##        "
        "      ##'''''##       "
        "       ##'''''##      "
        "        ##'''''#####  "
        "         ##'''''#''#  "
        "          ##'''#'''#  "
        "           ##'#'''##  "
        "            ##'''###  "
        "            #'''##'###"
        "            #''##''''#"
        "            ######'''#"
        "                 #''##"
        "                 #### "
    },
};
static struct cursor_t SHOVEL[] = {
    {
        1, 26, 28, 28,
        "                       ##   "
        "                      ####  "
        "                     ##'### "
        "                     #'''###"
        "                     ##'''##"
        "                    ####'## "
        "                   ##'####  "
        "                  ##'##     "
        "                 ##'##      "
        "                ##'##       "
        "               ##'##        "
        "              ##'##         "
        "             ##'##          "
        "       #    ##'##           "
        "      #### ##'##            "
        "     #''####'##             "
        "    #''''##'##              "
        "   #''''##'##               "
        "  #''''#''####              "
        " #''''#'''#'##              "
        "#''''#'''#'''##             "
        "#'''''''#''''#              "
        "#''''''#''''#               "
        "#''''''''''#                "
        "#'''''''''#                 "
        "#''''''''#                  "
        " #'''''##                   "
        "  #####                     "
    },
};
struct {
    SDL_Cursor *cursors[CURSOR_MAX];
    SDL_Surface *surfaces[CURSOR_MAX];
    int current_shape;
} cursor_data;

// image data
#define MAIN_ENTRIES 10000
#define ENEMY_FILES_COUNT 11
#define ENTRY_SIZE 64
#define ENEMY_ENTRIES 801
#define ENEMY_INDEX_SIZE ENTRY_SIZE * ENEMY_ENTRIES
#define HEADER_SIZE_ENEMY_FILES 20680
#define EMPIRE_IMAGE_DATA_SIZE 8000000 // 2000w*1000h*4bytes (16bit converted to 32bit)
enum {
    CLIMATE_NORTHERN = 0,
    CLIMATE_CENTRAL = 1,
    CLIMATE_DESERT = 2,
};
static char *MAIN_GRAPHICS_SG2[] = {
    "c3_north.sg2",
    "c3.sg2",
    "c3_south.sg2"
};
static char *MAIN_GRAPHICS_555[] = {
    "c3_north.555",
    "c3.555",
    "c3_south.555"
};
static char *EDITOR_GRAPHICS_SG2[] = {
    "c3map_north.sg2",
    "c3map.sg2",
    "c3map_south.sg2"
};
static char *EDITOR_GRAPHICS_555[] = {
    "c3map_north.555",
    "c3map.555",
    "c3map_south.555"
};
static char *ENEMY_GRAPHICS_SG2[] = {
    "carthage.sg2", // used for barbarians
    "carthage.sg2",
    "celts.sg2",
    "egyptians.sg2",
    "Etruscan.sg2",
    "Gaul.sg2",
    "goths.sg2",
    "Greek.sg2",
    "North African.sg2",
    "Persians.sg2",
    "Phoenician.sg2",
};
static char *ENEMY_GRAPHICS_555[] = {
   "carthage.555", // used for barbarians
   "carthage.555",
   "celts.555",
   "egyptians.555",
   "Etruscan.555",
   "Gaul.555",
   "goths.555",
   "Greek.555",
   "North African.555",
   "Persians.555",
   "Phoenician.555",
};
struct image_t {
    int width;
    int height;
    int num_animation_sprites;
    int sprite_offset_x;
    int sprite_offset_y;
    int animation_can_reverse;
    int animation_speed_id;
    struct {
        int type;
        int is_fully_compressed;
        int is_external;
        int has_compressed_part;
        int bitmap_id;
        int offset;
        int data_length;
        int uncompressed_length;
    } draw;
};
static struct {
    int current_climate;
    int is_editor;
    uint16_t group_image_ids[300];
    char bitmaps[100][200];
    struct image_t main[MAIN_ENTRIES];
    struct image_t enemy[ENEMY_FILES_COUNT][ENEMY_ENTRIES];
    uint32_t *main_data;
    uint32_t *empire_data;
    uint32_t *enemy_data[ENEMY_FILES_COUNT];
    uint8_t *tmp_data;
} image_data_s = { .current_climate = -1 };

// sound data
#define AUDIO_RATE 22050
enum {
    SOUND_CHANNEL_SPEECH = 0,
    // user interface effects
    SOUND_CHANNEL_EFFECTS_MIN = 1,
    SOUND_CHANNEL_EFFECTS_MAX = 45,
    // city sounds (from buildings)
    SOUND_CHANNEL_CITY_MIN = 46,
    SOUND_CHANNEL_CITY_MAX = 150,
    SOUND_CHANNEL_MAX = SOUND_CHANNEL_CITY_MAX + 1
};
static Mix_Music *music_channel;
struct sound_channel_t {
    char *filename;
    Mix_Chunk *chunk;
};
static struct sound_channel_t sound_channels[SOUND_CHANNEL_MAX] = {
{"", 0}, // speech channel
{"wavs/panel1.wav", 0},
{"wavs/panel3.wav", 0},
{"wavs/icon1.wav", 0},
{"wavs/build1.wav", 0},
{"wavs/explod1.wav", 0},
{"wavs/fanfare.wav", 0},
{"wavs/fanfare2.wav", 0},
{"wavs/arrow.wav", 0},
{"wavs/arrow_hit.wav", 0},
{"wavs/axe.wav", 0},
{"wavs/ballista.wav", 0},
{"wavs/ballista_hit_ground.wav", 0},
{"wavs/ballista_hit_person.wav", 0},
{"wavs/club.wav", 0},
{"wavs/camel1.wav", 0},
{"wavs/elephant.wav", 0},
{"wavs/elephant_hit.wav", 0},
{"wavs/elephant_die.wav", 0},
{"wavs/horse.wav", 0},
{"wavs/horse2.wav", 0},
{"wavs/horse_mov.wav", 0},
{"wavs/javelin.wav", 0},
{"wavs/lion_attack.wav", 0},
{"wavs/lion_die.wav", 0},
{"wavs/horn3.wav", 0},
{"wavs/sword.wav", 0},
{"wavs/sword_swing.wav", 0},
{"wavs/sword_light.wav", 0},
{"wavs/spear_attack.wav", 0},
{"wavs/wolf_attack.wav", 0},
{"wavs/wolf_attack2.wav", 0},
{"wavs/wolf_die.wav", 0},
{"wavs/die1.wav", 0},
{"wavs/die2.wav", 0},
{"wavs/die4.wav", 0},
{"wavs/die10.wav", 0},
{"wavs/die3.wav", 0},
{"wavs/die5.wav", 0},
{"wavs/die8.wav", 0},
{"wavs/die9.wav", 0},
{"wavs/sheep_die.wav", 0},
{"wavs/zebra_die.wav", 0},
{"wavs/wolf_howl.wav", 0},
{"wavs/fire_splash.wav", 0},
{"wavs/formation_shield.wav", 0},
{"wavs/house_slum1.wav", 0}, // start of city sounds 
{"wavs/house_slum2.wav", 0},
{"wavs/house_slum3.wav", 0},
{"wavs/house_slum4.wav", 0},
{"wavs/house_poor1.wav", 0},
{"wavs/house_poor2.wav", 0},
{"wavs/house_poor3.wav", 0},
{"wavs/house_poor4.wav", 0},
{"wavs/house_mid1.wav", 0},
{"wavs/house_mid2.wav", 0},
{"wavs/house_mid3.wav", 0},
{"wavs/house_mid4.wav", 0},
{"wavs/house_good1.wav", 0},
{"wavs/house_good2.wav", 0},
{"wavs/house_good3.wav", 0},
{"wavs/house_good4.wav", 0},
{"wavs/house_posh1.wav", 0},
{"wavs/house_posh2.wav", 0},
{"wavs/house_posh3.wav", 0},
{"wavs/house_posh4.wav", 0},
{"wavs/empty_land1.wav", 0},
{"wavs/resevoir.wav", 0},
{"wavs/aquaduct.wav", 0}, // same as river.wav 
{"wavs/fountain.wav", 0},
{"wavs/well.wav", 0},
{"wavs/barber.wav", 0},
{"wavs/baths.wav", 0},
{"wavs/clinic.wav", 0},
{"wavs/hospital.wav", 0},
{"wavs/temp_farm.wav", 0},
{"wavs/temp_ship.wav", 0},
{"wavs/temple_ship.wav", 0},
{"wavs/temp_comm.wav", 0},
{"wavs/temp_war.wav", 0},
{"wavs/temple_war.wav", 0},
{"wavs/temp_love.wav", 0},
{"wavs/oracle.wav", 0},
{"wavs/school.wav", 0},
{"wavs/academy.wav", 0},
{"wavs/library.wav", 0},
{"wavs/theatre.wav", 0},
{"wavs/ampitheatre.wav", 0},
{"wavs/colloseum.wav", 0},
{"wavs/hippodrome.wav", 0},
{"wavs/glad_pit.wav", 0},
{"wavs/lion_pit.wav", 0},
{"wavs/art_pit.wav", 0},
{"wavs/char_pit.wav", 0},
{"wavs/forum.wav", 0},
{"wavs/senate.wav", 0},
{"wavs/palace.wav", 0},
{"wavs/statue.wav", 0},
{"wavs/gardens1.wav", 0}, // same as emptyland1.wav
{"wavs/gardens2.wav", 0}, // same as emptyland2.wav 
{"wavs/gardens3.wav", 0}, // same as emptyland3.wav 
{"wavs/gardens4.wav", 0}, // same as emptyland4.wav
{"wavs/shipyard.wav", 0},
{"wavs/shipyard1.wav", 0},
{"wavs/shipyard2.wav", 0},
{"wavs/dock.wav", 0},
{"wavs/dock1.wav", 0},
{"wavs/dock2.wav", 0},
{"wavs/wharf.wav", 0},
{"wavs/wharf1.wav", 0},
{"wavs/wharf2.wav", 0},
{"wavs/tower1.wav", 0},
{"wavs/tower2.wav", 0},
{"wavs/tower3.wav", 0},
{"wavs/tower4.wav", 0},
{"wavs/fort1.wav", 0},
{"wavs/fort2.wav", 0},
{"wavs/fort3.wav", 0},
{"wavs/fort4.wav", 0},
{"wavs/mil_acad.wav", 0},
{"wavs/barracks.wav", 0},
{"wavs/wheat.wav", 0},
{"wavs/wheat_farm.wav", 0},
{"wavs/veg_farm.wav", 0},
{"wavs/figs_farm.wav", 0},
{"wavs/olives_farm.wav", 0},
{"wavs/vines_farm.wav", 0},
{"wavs/meat_farm.wav", 0},
{"wavs/clay_pit.wav", 0},
{"wavs/quarry.wav", 0},
{"wavs/mine.wav", 0},
{"wavs/lumber_mill.wav", 0},
{"wavs/wine_workshop.wav", 0},
{"wavs/oil_workshop.wav", 0},
{"wavs/weap_workshop.wav", 0},
{"wavs/weapons_workshop.wav", 0},
{"wavs/furn_workshop.wav", 0},
{"wavs/furniture_workshop.wav", 0},
{"wavs/pott_workshop.wav", 0},
{"wavs/pottery_workshop.wav", 0},
{"wavs/market1.wav", 0},
{"wavs/market2.wav", 0},
{"wavs/market3.wav", 0},
{"wavs/market4.wav", 0},
{"wavs/granary.wav", 0},
{"wavs/granary1.wav", 0},
{"wavs/granary2.wav", 0},
{"wavs/warehouse.wav", 0},
{"wavs/warehouse1.wav", 0},
{"wavs/warehouse2.wav", 0},
{"wavs/burning_ruin.wav", 0},
};

#define MSG_SIZE 1000
#define BUILD_MENU_BUTTONS_COUNT 12
#define MAX_ITEMS_PER_BUILD_MENU 11
#define MAX_ITEMS_PER_SUBMENU 6
#define NO_COLUMN -1
#define SIDEBAR_COLLAPSED_WIDTH 42
#define MAX_SCENARIO_NAME 65
#define MAX_REQUESTS 45
#define MAX_EDITOR_CUSTOM_MESSAGES 40
#define MAX_CUSTOM_MESSAGE_TITLE 30
#define MAX_CUSTOM_MESSAGE_TEXT 1000
#define MAX_CUSTOM_MESSAGE_TEXT_WIDTH 758
#define MAX_CUSTOM_MESSAGE_VIDEO_TEXT 24
#define MAX_EARTHQUAKE_POINTS 8
#define MAX_EARTHQUAKES 10
#define MAX_EARTHQUAKE_BRANCHES 4
#define MAX_INVASION_POINTS 8
#define MAX_INVASIONS 45
#define ENEMY_TYPE_MAX_COUNT 20
#define MAX_PRICE_CHANGES 45
#define MAX_DEMAND_CHANGES 45
#define MAX_HERD_POINTS 8
#define MAX_FISH_POINTS 8
#define OFFSET(x,y) (x + GRID_SIZE * y)
#define BLOCK_SIZE 16
#define MAX_FORMATION_FIGURES 16
#define ROUT_MORALE_THRESHOLD 20
#define MAX_LEGIONS 6
#define WOLF_PACK_SIZE 8
#define MAX_WOLF_ROAM_DISTANCE 16
#define WOLF_PACK_ROAM_DELAY 12
#define SHEEP_HERD_SIZE 10
#define MAX_SHEEP_ROAM_DISTANCE 8
#define SHEEP_HERD_ROAM_DELAY 24
#define ZEBRA_HERD_SIZE 12
#define MAX_ZEBRA_ROAM_DISTANCE 20
#define ZEBRA_HERD_ROAM_DELAY 6
#define MAX_ENEMY_FORMATIONS 100
#define MAX_FIGURES 1000
#define MAX_RANGED_TARGETERS_PER_UNIT 4
#define MAX_MELEE_TARGETERS_PER_UNIT 4
#define MAX_MELEE_COMBATANTS_PER_UNIT 4
#define PREFECT_TARGET_ACQUISITION_RANGE 15
#define MAX_EMPIRE_OBJECTS 200
#define SPEED_CHANGE_IMMEDIATE 0
#define RESOURCE_TYPES_MAX 16
#define FOOD_TYPES_MAX 7
#define MAX_GODS 5
#define VIEW_X_MAX 165
#define VIEW_Y_MAX 325
#define TILE_WIDTH_PIXELS 60
#define TILE_HEIGHT_PIXELS 30
#define HALF_TILE_WIDTH_PIXELS 30
#define HALF_TILE_HEIGHT_PIXELS 15
#define MAX_WARNINGS 5
#define MAX_BUILDINGS 2000
#define MAX_HOUSE_TYPES 20
#define MAX_PROGRESS_WORKSHOP 400
#define MAX_PROGRESS_RAW 200
#define INFINITE 10000
#define UNITS_PER_LOAD 100
#define ONE_LOAD 100
#define X_OFFSET 232
#define GROUP 5
#define MAX_MESSAGES_IN_WINDOW 10
#define MAX_HISTORY 200
#define MAX_EDITOR_FILES 9
#define DISPLAY_TIME_MILLIS 1000
#define MAX_WIDTH 2032
#define MAX_HEIGHT 1136
#define MAX_REQUESTS_SHOWN 5
#define PEOPLE_OFFSET 330
#define COVERAGE_OFFSET 470
#define COVERAGE_WIDTH 130
#define MAX_TILES_BUILDING_PREVIEW 25
#define SLIDE_SPEED 7
#define SLIDE_ACCELERATION_MILLIS 65
#define SIDEBAR_DECELERATION_OFFSET 125
#define MAX_CITY_SOUNDS_CHANNELS 70
#define MAX_ENEMY_TYPES_PER_ARMY 3
#define MAX_BOOKMARKS 4
#define MAX_TILES_TERRAIN 8
#define MAX_PATH 500
#define MAX_QUEUE_ROUTING GRID_SIZE * GRID_SIZE
#define GUARD 50000
#define FORBIDDEN_TERRAIN_MEADOW (TERRAIN_AQUEDUCT | TERRAIN_ELEVATION | TERRAIN_ACCESS_RAMP | TERRAIN_RUBBLE | TERRAIN_ROAD | TERRAIN_BUILDING | TERRAIN_GARDEN)
#define FORBIDDEN_TERRAIN_RUBBLE (TERRAIN_AQUEDUCT | TERRAIN_ELEVATION | TERRAIN_ACCESS_RAMP | TERRAIN_ROAD | TERRAIN_BUILDING | TERRAIN_GARDEN)
#define MAX_QUEUE 1000
#define MOUSE_BORDER 5
#define TOUCH_BORDER 100
#define SCROLL_DRAG_MIN_DELTA 4
#define PRESSED_EFFECT_MILLIS 100
#define PRESSED_REPEAT_INITIAL_MILLIS 300
#define PRESSED_REPEAT_MILLIS 50
#define FOOTPRINT_WIDTH 58
#define FOOTPRINT_HEIGHT 30
#define COMPONENT(c, shift) ((c >> shift) & 0xff)
#define MIX_RB(src, dst, alpha) ((((src & 0xff00ff) * alpha + (dst & 0xff00ff) * (256 - alpha)) >> 8) & 0xff00ff)
#define MIX_G(src, dst, alpha) ((((src & 0x00ff00) * alpha + (dst & 0x00ff00) * (256 - alpha)) >> 8) & 0x00ff00)
#define MAX_LINKS 50
#define HEADER_SIZE_BMP 26
#define TILE_X_SIZE 60
#define TILE_Y_SIZE 30
#define IMAGE_HEIGHT_CHUNK TILE_Y_SIZE
#define BMP_BITS_PER_PIXEL 24
#define BMP_BYTES_PER_PIXEL (BMP_BITS_PER_PIXEL / 8)
#define SCROLL_BUTTON_WIDTH 39
#define SCROLL_DOT_SIZE 25
#define TOTAL_BUTTON_HEIGHT (2 * SCROLLBAR_BUTTON_HEIGHT + SCROLL_DOT_SIZE)
#define NUMBER_BUFFER_LENGTH 100
#define MAX_WINDOW_QUEUE 3
#define MAX_HOUSE_LEVELS 20
#define MAX_ANIM_TIMERS 51
#define UNCOMPRESSED 0x80000000
#define MAX_TICKS_PER_FRAME 20
#define MAX_DIR 4
#define MAX_UNDO_BUILDINGS 50
#define PREFECT_LEASH_RANGE 20
#define MAX_TRADERS 100
#define MAX_COVERAGE 96
#define MAX_PATH_LENGTH 500
#define MAX_ROUTES 600
#define MAX_ITEMS_PER_MENU 16
#define MAX_TILES_OFFSETS 4
#define TERRAIN_NOT_DISPLACEABLE TERRAIN_ROCK | TERRAIN_WATER | TERRAIN_BUILDING | TERRAIN_ELEVATION | TERRAIN_ACCESS_RAMP
#define MAX_ALLOWED_BUILDINGS 78
#define MAX_DEMAND_ROUTES 20
#define DEMAND_ROUTE_MAX_NAME_LENGTH 50
#define FRAME_TIME 16.67
#define HEADER_SIZE_SMACKER 104
#define MAX_TRACKS 7
#define MAX_PALETTE 256
#define FLAG_Y_INTERLACE 0x02
#define FLAG_Y_DOUBLE 0x04
#define AUDIO_MASK_RATE 0xFFFFFF
#define AUDIO_FLAG_STEREO 0x10000000
#define AUDIO_FLAG_16BIT 0x20000000
#define AUDIO_FLAG_HAS_TRACK 0x40000000
#define AUDIO_FLAG_COMPRESSED 0x80000000
#define BLOCK_MONO 0
#define BLOCK_FULL 1
#define BLOCK_SOLID 3
#define F_OK 0
#define access _access
#define TIE 10
#define CURSE_LOADS 16
#define MARS_INVASION_SMALL 16
#define MARS_INVASION_LARGE 32
#define MAX_TEXT 100
#define TIMEOUT_MS 15000
#define MAX_MESSAGES 1000
#define MAX_MESSAGE_QUEUE 20
#define MAX_MESSAGE_CATEGORIES 20
#define LABOR_CATEGORIES_COUNT 9
#define MAX_STORAGES 200
#define MAX_GRANARIES 100
#define MAX_SMALL 500
#define MAX_LARGE 2000
#define MAX_BURNING 500
#define MIN_Y_POSITION 32
#define MARGIN_POSITION 16
#define SOUND_FILENAME_MAX 32
#define FIGURE_MAX_NAME_LENGTH 64

// start enums
enum {
    TOP_MENU_NONE = 0,
    TOP_MENU_FILE = 1,
    TOP_MENU_OPTIONS = 2,
    TOP_MENU_RESETS = 3,
};

enum {
    BUILDING_NONE = 0,
    BUILDING_HOUSE_VACANT_LOT = 1,
    BUILDING_HOUSE_SMALL_TENT = 2,
    BUILDING_HOUSE_LARGE_TENT = 3,
    BUILDING_HOUSE_SMALL_SHACK = 4,
    BUILDING_HOUSE_LARGE_SHACK = 5,
    BUILDING_HOUSE_SMALL_HOVEL = 6,
    BUILDING_HOUSE_LARGE_HOVEL = 7,
    BUILDING_HOUSE_SMALL_CASA = 8,
    BUILDING_HOUSE_LARGE_CASA = 9,
    BUILDING_HOUSE_SMALL_INSULA = 10,
    BUILDING_HOUSE_MEDIUM_INSULA = 11,
    BUILDING_HOUSE_LARGE_INSULA = 12,
    BUILDING_HOUSE_GRAND_INSULA = 13,
    BUILDING_HOUSE_SMALL_VILLA = 14,
    BUILDING_HOUSE_MEDIUM_VILLA = 15,
    BUILDING_HOUSE_LARGE_VILLA = 16,
    BUILDING_HOUSE_GRAND_VILLA = 17,
    BUILDING_HOUSE_SMALL_PALACE = 18,
    BUILDING_HOUSE_MEDIUM_PALACE = 19,
    BUILDING_HOUSE_LARGE_PALACE = 20,
    BUILDING_HOUSE_LUXURY_PALACE = 21,
    BUILDING_CLEAR_LAND = 22,
    BUILDING_ROAD = 23,
    BUILDING_RESERVOIR = 24,
    BUILDING_AQUEDUCT = 25,
    BUILDING_FOUNTAIN = 26,
    BUILDING_WELL = 27,
    BUILDING_DOCTOR = 28,
    BUILDING_BATHHOUSE = 29,
    BUILDING_BARBER = 30,
    BUILDING_HOSPITAL = 31,
    BUILDING_SMALL_TEMPLE_CERES = 32,
    BUILDING_SMALL_TEMPLE_NEPTUNE = 33,
    BUILDING_SMALL_TEMPLE_MERCURY = 34,
    BUILDING_SMALL_TEMPLE_MARS = 35,
    BUILDING_SMALL_TEMPLE_VENUS = 36,
    BUILDING_LARGE_TEMPLE_CERES = 37,
    BUILDING_LARGE_TEMPLE_NEPTUNE = 38,
    BUILDING_LARGE_TEMPLE_MERCURY = 39,
    BUILDING_LARGE_TEMPLE_MARS = 40,
    BUILDING_LARGE_TEMPLE_VENUS = 41,
    BUILDING_ORACLE = 42,
    BUILDING_SCHOOL = 43,
    BUILDING_LIBRARY = 44,
    BUILDING_ACADEMY = 45,
    BUILDING_MISSION_POST = 46,
    BUILDING_THEATER = 47,
    BUILDING_ACTOR_COLONY = 48,
    BUILDING_AMPHITHEATER = 49,
    BUILDING_GLADIATOR_SCHOOL = 50,
    BUILDING_LION_HOUSE = 51,
    BUILDING_COLOSSEUM = 52,
    BUILDING_CHARIOT_MAKER = 53,
    BUILDING_HIPPODROME = 54,
    BUILDING_GARDENS = 55,
    BUILDING_PLAZA = 56,
    BUILDING_SMALL_STATUE = 57,
    BUILDING_MEDIUM_STATUE = 58,
    BUILDING_LARGE_STATUE = 59,
    BUILDING_GOVERNORS_HOUSE = 60,
    BUILDING_GOVERNORS_VILLA = 61,
    BUILDING_GOVERNORS_PALACE = 62,
    BUILDING_FORUM = 63,
    BUILDING_SENATE = 64,
    BUILDING_TRIUMPHAL_ARCH = 65,
    BUILDING_ENGINEERS_POST = 66,
    BUILDING_LOW_BRIDGE = 67,
    BUILDING_SHIP_BRIDGE = 68,
    BUILDING_SHIPYARD = 69,
    BUILDING_WHARF = 70,
    BUILDING_DOCK = 71,
    BUILDING_PREFECTURE = 72,
    BUILDING_WALL = 73,
    BUILDING_TOWER = 74,
    BUILDING_GATEHOUSE = 75,
    BUILDING_FORT_LEGIONARIES = 76,
    BUILDING_FORT_JAVELIN = 77,
    BUILDING_FORT_MOUNTED = 78,
    BUILDING_BARRACKS = 79,
    BUILDING_MILITARY_ACADEMY = 80,
    BUILDING_WHEAT_FARM = 81,
    BUILDING_VEGETABLE_FARM = 82,
    BUILDING_FRUIT_FARM = 83,
    BUILDING_PIG_FARM = 84,
    BUILDING_OLIVE_FARM = 85,
    BUILDING_VINES_FARM = 86,
    BUILDING_CLAY_PIT = 87,
    BUILDING_TIMBER_YARD = 88,
    BUILDING_MARBLE_QUARRY = 89,
    BUILDING_IRON_MINE = 90,
    BUILDING_OIL_WORKSHOP = 91,
    BUILDING_WINE_WORKSHOP = 92,
    BUILDING_POTTERY_WORKSHOP = 93,
    BUILDING_FURNITURE_WORKSHOP = 94,
    BUILDING_WEAPONS_WORKSHOP = 95,
    BUILDING_MARKET = 96,
    BUILDING_GRANARY = 97,
    BUILDING_WAREHOUSE = 98,
    BUILDING_WAREHOUSE_SPACE = 99,
    BUILDING_NATIVE_HUT = 100,
    BUILDING_NATIVE_CROPS = 101,
    BUILDING_NATIVE_MEETING = 102,
    BUILDING_FORT_GROUND = 103,
    BUILDING_BURNING_RUIN = 104,
    BUILDING_TYPE_MAX = 105
};
enum {
    HOUSE_SMALL_TENT = 0,
    HOUSE_LARGE_TENT = 1,
    HOUSE_SMALL_SHACK = 2,
    HOUSE_LARGE_SHACK = 3,
    HOUSE_SMALL_HOVEL = 4,
    HOUSE_LARGE_HOVEL = 5,
    HOUSE_SMALL_CASA = 6,
    HOUSE_LARGE_CASA = 7,
    HOUSE_SMALL_INSULA = 8,
    HOUSE_MEDIUM_INSULA = 9,
    HOUSE_LARGE_INSULA = 10,
    HOUSE_GRAND_INSULA = 11,
    HOUSE_SMALL_VILLA = 12,
    HOUSE_MEDIUM_VILLA = 13,
    HOUSE_LARGE_VILLA = 14,
    HOUSE_GRAND_VILLA = 15,
    HOUSE_SMALL_PALACE = 16,
    HOUSE_MEDIUM_PALACE = 17,
    HOUSE_LARGE_PALACE = 18,
    HOUSE_LUXURY_PALACE = 19,
};
enum {
    BUILDING_STATE_UNUSED = 0,
    BUILDING_STATE_IN_USE = 1,
    BUILDING_STATE_UNDO = 2,
    BUILDING_STATE_CREATED = 3,
    BUILDING_STATE_RUBBLE = 4,
    BUILDING_STATE_DELETED_BY_GAME = 5, // used for earthquakes, fires, house mergers
    BUILDING_STATE_DELETED_BY_PLAYER = 6
};
enum {
    BUILDING_STORAGE_STATE_ACCEPTING = 0,
    BUILDING_STORAGE_STATE_GETTING = 1,
    BUILDING_STORAGE_STATE_NOT_ACCEPTING = 2
};
enum {
    LOW_MOOD_CAUSE_NONE = 0,
    LOW_MOOD_CAUSE_NO_FOOD = 1,
    LOW_MOOD_CAUSE_NO_JOBS = 2,
    LOW_MOOD_CAUSE_HIGH_TAXES = 3,
    LOW_MOOD_CAUSE_LOW_WAGES = 4,
    LOW_MOOD_CAUSE_MANY_TENTS = 5,
};
enum {
    NO_IMMIGRATION_LOW_WAGES = 0,
    NO_IMMIGRATION_NO_JOBS = 1,
    NO_IMMIGRATION_NO_FOOD = 2,
    NO_IMMIGRATION_HIGH_TAXES = 3,
    NO_IMMIGRATION_MANY_TENTS = 4,
    NO_IMMIGRATION_LOW_MOOD = 5
};
enum {
    FESTIVAL_SMALL = 0,
    FESTIVAL_LARGE = 1,
    FESTIVAL_GRAND = 2,
};
enum {
    GOD_CERES = 0,
    GOD_NEPTUNE = 1,
    GOD_MERCURY = 2,
    GOD_MARS = 3,
    GOD_VENUS = 4
};
enum {
    TRADE_STATUS_NONE = 0,
    TRADE_STATUS_IMPORT = 1,
    TRADE_STATUS_EXPORT = 2
};
enum {
    GIFT_MODEST = 0,
    GIFT_GENEROUS = 1,
    GIFT_LAVISH = 2
};
enum {
    MESSAGE_CAT_RIOT = 0,
    MESSAGE_CAT_FIRE = 1,
    MESSAGE_CAT_COLLAPSE = 2,
    MESSAGE_CAT_RIOT_COLLAPSE = 3,
    MESSAGE_CAT_BLOCKED_DOCK = 4,
    MESSAGE_CAT_WORKERS_NEEDED = 8,
    MESSAGE_CAT_NO_WORKING_DOCK = 10,
    MESSAGE_CAT_FISHING_BLOCKED = 11,
};
enum {
    MESSAGE_ADVISOR_NONE = 0,
    MESSAGE_ADVISOR_LABOR = 1,
    MESSAGE_ADVISOR_TRADE = 2,
    MESSAGE_ADVISOR_POPULATION = 3,
    MESSAGE_ADVISOR_IMPERIAL = 4,
    MESSAGE_ADVISOR_MILITARY = 5,
    MESSAGE_ADVISOR_HEALTH = 6,
    MESSAGE_ADVISOR_RELIGION = 7,
};
enum {
    MESSAGE_POPULATION_500 = 2,
    MESSAGE_POPULATION_1000 = 3,
    MESSAGE_POPULATION_2000 = 4,
    MESSAGE_POPULATION_3000 = 5,
    MESSAGE_POPULATION_5000 = 6,
    MESSAGE_POPULATION_10000 = 7,
    MESSAGE_POPULATION_15000 = 8,
    MESSAGE_POPULATION_20000 = 9,
    MESSAGE_POPULATION_25000 = 10,
    MESSAGE_RIOT = 11,
    MESSAGE_FIRE = 12,
    MESSAGE_COLLAPSED_BUILDING = 13,
    MESSAGE_DESTROYED_BUILDING = 14,
    MESSAGE_NAVIGATION_IMPOSSIBLE = 15,
    MESSAGE_CITY_IN_DEBT = 16,
    MESSAGE_CITY_IN_DEBT_AGAIN = 17,
    MESSAGE_CITY_STILL_IN_DEBT = 18,
    MESSAGE_CAESAR_WRATH = 19,
    MESSAGE_CAESAR_ARMY_CONTINUE = 20,
    MESSAGE_CAESAR_ARMY_RETREAT = 21,
    MESSAGE_LOCAL_UPRISING = 22,
    MESSAGE_BARBARIAN_ATTACK = 23,
    MESSAGE_CAESAR_ARMY_ATTACK = 24,
    MESSAGE_DISTANT_BATTLE = 25,
    MESSAGE_ENEMIES_CLOSING = 26,
    MESSAGE_ENEMIES_AT_THE_DOOR = 27,
    MESSAGE_CAESAR_REQUESTS_GOODS = 28,
    MESSAGE_CAESAR_REQUESTS_MONEY = 29,
    MESSAGE_CAESAR_REQUESTS_ARMY = 30,
    MESSAGE_REQUEST_REMINDER = 31,
    MESSAGE_REQUEST_RECEIVED = 32,
    MESSAGE_REQUEST_REFUSED = 33,
    MESSAGE_REQUEST_REFUSED_OVERDUE = 34,
    MESSAGE_REQUEST_RECEIVED_LATE = 35,
    MESSAGE_UNEMPLOYMENT = 36,
    MESSAGE_WORKERS_NEEDED = 37,
    MESSAGE_SMALL_FESTIVAL = 38,
    MESSAGE_LARGE_FESTIVAL = 39,
    MESSAGE_GRAND_FESTIVAL = 40,
    MESSAGE_WRATH_OF_CERES = 41,
    MESSAGE_WRATH_OF_NEPTUNE_NO_SEA_TRADE = 42,
    MESSAGE_WRATH_OF_MERCURY = 43,
    MESSAGE_WRATH_OF_MARS_NO_MILITARY = 44,
    MESSAGE_WRATH_OF_VENUS = 45,
    MESSAGE_PEOPLE_DISGRUNTLED = 46,
    MESSAGE_PEOPLE_UNHAPPY = 47,
    MESSAGE_PEOPLE_ANGRY = 48,
    MESSAGE_NOT_ENOUGH_FOOD = 49,
    MESSAGE_FOOD_NOT_DELIVERED = 50,
    MESSAGE_THEFT = 52,
    MESSAGE_GODS_UNHAPPY = 55,
    MESSAGE_EARTHQUAKE = 62,
    MESSAGE_GLADIATOR_REVOLT = 63,
    MESSAGE_LAND_TRADE_DISRUPTED_SANDSTORMS = 65,
    MESSAGE_SEA_TRADE_DISRUPTED = 66,
    MESSAGE_LAND_TRADE_DISRUPTED_LANDSLIDES = 67,
    MESSAGE_ROME_RAISES_WAGES = 68,
    MESSAGE_ROME_LOWERS_WAGES = 69,
    MESSAGE_CONTAMINATED_WATER = 70,
    MESSAGE_IRON_MINE_COLLAPED = 71,
    MESSAGE_CLAY_PIT_FLOODED = 72,
    MESSAGE_GLADIATOR_REVOLT_FINISHED = 73,
    MESSAGE_INCREASED_TRADING = 74,
    MESSAGE_DECREASED_TRADING = 75,
    MESSAGE_TRADE_STOPPED = 76,
    MESSAGE_PRICE_INCREASED = 78,
    MESSAGE_PRICE_DECREASED = 79,
    MESSAGE_EMPIRE_HAS_EXPANDED = 77,
    MESSAGE_ROAD_TO_ROME_BLOCKED = 80,
    MESSAGE_WRATH_OF_NEPTUNE = 81,
    MESSAGE_WRATH_OF_MARS = 82,
    MESSAGE_DISTANT_BATTLE_LOST_NO_TROOPS = 84,
    MESSAGE_DISTANT_BATTLE_LOST_TOO_LATE = 85,
    MESSAGE_DISTANT_BATTLE_LOST_TOO_WEAK = 86,
    MESSAGE_DISTANT_BATTLE_WON = 87,
    MESSAGE_TROOPS_RETURN_FAILED = 88,
    MESSAGE_TROOPS_RETURN_VICTORIOUS = 89,
    MESSAGE_DISTANT_BATTLE_CITY_RETAKEN = 90,
    MESSAGE_CERES_IS_UPSET = 91,
    MESSAGE_NEPTUNE_IS_UPSET = 92,
    MESSAGE_MERCURY_IS_UPSET = 93,
    MESSAGE_MARS_IS_UPSET = 94,
    MESSAGE_VENUS_IS_UPSET = 95,
    MESSAGE_BLESSING_FROM_CERES = 96,
    MESSAGE_BLESSING_FROM_NEPTUNE = 97,
    MESSAGE_BLESSING_FROM_MERCURY = 98,
    MESSAGE_BLESSING_FROM_MARS = 99,
    MESSAGE_BLESSING_FROM_VENUS = 100,
    MESSAGE_GODS_WRATHFUL = 101,
    MESSAGE_HEALTH_ILLNESS = 102,
    MESSAGE_HEALTH_DISEASE = 103,
    MESSAGE_HEALTH_PESTILENCE = 104,
    MESSAGE_SPIRIT_OF_MARS = 105,
    MESSAGE_CAESAR_RESPECT_1 = 106,
    MESSAGE_CAESAR_RESPECT_2 = 107,
    MESSAGE_CAESAR_RESPECT_3 = 108,
    MESSAGE_WORKING_HIPPODROME = 109,
    MESSAGE_WORKING_COLOSSEUM = 110,
    MESSAGE_EMIGRATION = 111,
    MESSAGE_FIRED = 112,
    MESSAGE_ENEMY_ARMY_ATTACK = 114,
    MESSAGE_REQUEST_CAN_COMPLY = 115,
    MESSAGE_ROAD_TO_ROME_OBSTRUCTED = 116,
    MESSAGE_NO_WORKING_DOCK = 117,
    MESSAGE_FISHING_BOAT_BLOCKED = 118,
    MESSAGE_LOCAL_UPRISING_MARS = 121,
    MESSAGE_DISTANT_BATTLE_WON_TRIUMPHAL_ARCH_DISABLED = 122,
    MESSAGE_EDITOR_1 = 123,
    MESSAGE_EDITOR_2 = 124,
    MESSAGE_EDITOR_3 = 125,
    MESSAGE_EDITOR_4 = 126,
    MESSAGE_EDITOR_5 = 127,
    MESSAGE_EDITOR_6 = 128,
    MESSAGE_EDITOR_7 = 129,
    MESSAGE_EDITOR_8 = 130,
    MESSAGE_EDITOR_9 = 131,
    MESSAGE_EDITOR_10 = 132,
    MESSAGE_EDITOR_11 = 133,
    MESSAGE_EDITOR_12 = 134,
    MESSAGE_EDITOR_13 = 135,
    MESSAGE_EDITOR_14 = 136,
    MESSAGE_EDITOR_15 = 137,
    MESSAGE_EDITOR_16 = 138,
    MESSAGE_EDITOR_17 = 139,
    MESSAGE_EDITOR_18 = 140,
    MESSAGE_EDITOR_19 = 141,
    MESSAGE_EDITOR_20 = 142,
    MESSAGE_EDITOR_21 = 143,
    MESSAGE_EDITOR_22 = 144,
    MESSAGE_EDITOR_23 = 145,
    MESSAGE_EDITOR_24 = 146,
    MESSAGE_EDITOR_25 = 147,
    MESSAGE_EDITOR_26 = 148,
    MESSAGE_EDITOR_27 = 149,
    MESSAGE_EDITOR_28 = 150,
    MESSAGE_EDITOR_29 = 151,
    MESSAGE_EDITOR_30 = 152,
    MESSAGE_EDITOR_31 = 153,
    MESSAGE_EDITOR_32 = 154,
    MESSAGE_EDITOR_33 = 155,
    MESSAGE_EDITOR_34 = 156,
    MESSAGE_EDITOR_35 = 157,
    MESSAGE_EDITOR_36 = 158,
    MESSAGE_EDITOR_37 = 159,
    MESSAGE_EDITOR_38 = 160,
    MESSAGE_EDITOR_39 = 161,
    MESSAGE_EDITOR_40 = 162,
    MESSAGE_EDITOR_41 = 163,
    MESSAGE_EDITOR_42 = 164,
    MESSAGE_EDITOR_43 = 165,
    MESSAGE_EDITOR_44 = 166,
    MESSAGE_EDITOR_45 = 167,
};
enum {
    SELECTED_RATING_NONE = 0,
    SELECTED_RATING_CULTURE = 1,
    SELECTED_RATING_PROSPERITY = 2,
    SELECTED_RATING_PEACE = 3,
    SELECTED_RATING_FAVOR = 4
};
enum {
    WARNING_ORIENTATION = 1,
    WARNING_CLEAR_LAND_NEEDED = 2,
    WARNING_OUT_OF_MONEY = 3,
    WARNING_ONE_BUILDING_OF_TYPE = 4,
    WARNING_ROAD_ACCESS_NEEDED = 11,
    WARNING_NOT_AVAILABLE = 13,
    WARNING_NOT_AVAILABLE_YET = 14,
    WARNING_MARBLE_NEEDED_LARGE_TEMPLE = 15,
    WARNING_MARBLE_NEEDED_ORACLE = 16,
    WARNING_WORKERS_NEEDED = 17,
    WARNING_MORE_FOOD_NEEDED = 18,
    WARNING_BUILD_MARKET = 19,
    WARNING_MEADOW_NEEDED = 20,
    WARNING_WATER_NEEDED = 21,
    WARNING_ROCK_NEEDED = 22,
    WARNING_TREE_NEEDED = 23,
    WARNING_SHORE_NEEDED = 25,
    WARNING_IRON_NEEDED = 26,
    WARNING_VINES_NEEDED = 27,
    WARNING_OLIVES_NEEDED = 28,
    WARNING_CLAY_NEEDED = 29,
    WARNING_TIMBER_NEEDED = 30,
    WARNING_OPEN_TRADE_TO_IMPORT = 31,
    WARNING_TRADE_IMPORT_RESOURCE = 32,
    WARNING_BUILD_IRON_MINE = 33,
    WARNING_BUILD_VINES_FARM = 34,
    WARNING_BUILD_OLIVE_FARM = 35,
    WARNING_BUILD_CLAY_PIT = 36,
    WARNING_BUILD_TIMBER_YARD = 37,
    WARNING_WATER_PIPE_ACCESS_NEEDED = 38,
    WARNING_PLACE_RESERVOIR_NEXT_TO_WATER = 39,
    WARNING_CONNECT_TO_RESERVOIR = 40,
    WARNING_SENTRIES_NEED_WALL = 41,
    WARNING_BUILD_BARRACKS = 42,
    WARNING_WEAPONS_NEEDED = 43,
    WARNING_BUILD_ACTOR_COLONY = 44,
    WARNING_BUILD_GLADIATOR_SCHOOL = 45,
    WARNING_BUILD_LION_HOUSE = 46,
    WARNING_BUILD_CHARIOT_MAKER = 47,
    WARNING_WALL_NEEDED = 49,
    WARNING_ENEMY_NEARBY = 50,
    WARNING_LEGION_MORALE_TOO_LOW = 51,
    WARNING_MAX_LEGIONS_REACHED = 52,
    WARNING_PEOPLE_ON_BRIDGE = 55,
    WARNING_DOCK_OPEN_WATER_NEEDED = 56,
    WARNING_EDITOR_NEED_MAP_EDGE = 58,
    WARNING_EDITOR_NEED_OPEN_WATER = 59,
    WARNING_EDITOR_CANNOT_PLACE = 60,
    WARNING_HOUSE_TOO_FAR_FROM_ROAD = 62,
    WARNING_CITY_BOXED_IN = 63,
    WARNING_CITY_BOXED_IN_PEOPLE_WILL_PERISH = 64,
    WARNING_DATA_LIMIT_REACHED = 65
};
enum {
    RESOURCE_NONE = 0,
    RESOURCE_WHEAT = 1,
    RESOURCE_VEGETABLES = 2,
    RESOURCE_FRUIT = 3,
    RESOURCE_MEAT = 4,
    RESOURCE_OLIVES = 5,
    RESOURCE_VINES = 6,
    RESOURCE_CLAY = 7,
    RESOURCE_TIMBER = 8,
    RESOURCE_MARBLE = 9,
    RESOURCE_IRON = 10,
    RESOURCE_OIL = 11,
    RESOURCE_WINE = 12,
    RESOURCE_POTTERY = 13,
    RESOURCE_FURNITURE = 14,
    RESOURCE_WEAPONS = 15,
    RESOURCE_DENARII = 16,
    RESOURCE_TROOPS = 17,
};
enum {
    INVENTORY_WHEAT = 0,
    INVENTORY_VEGETABLES = 1,
    INVENTORY_FRUIT = 2,
    INVENTORY_MEAT = 3,
    INVENTORY_OIL = 4,
    INVENTORY_WINE = 5,
    INVENTORY_POTTERY = 6,
    INVENTORY_FURNITURE = 7,
    INVENTORY_MAX = 8
};
enum {
    WORKSHOP_NONE = 0,
    WORKSHOP_OLIVES_TO_OIL = 1,
    WORKSHOP_VINES_TO_WINE = 2,
    WORKSHOP_CLAY_TO_POTTERY = 3,
    WORKSHOP_TIMBER_TO_FURNITURE = 4,
    WORKSHOP_IRON_TO_WEAPONS = 5,
};
enum {
    RESOURCE_IMAGE_STORAGE = 0,
    RESOURCE_IMAGE_CART = 1,
    RESOURCE_IMAGE_FOOD_CART = 2,
    RESOURCE_IMAGE_ICON = 3
};
enum {
    IMAGE_TYPE_WITH_TRANSPARENCY = 0,
    IMAGE_TYPE_ISOMETRIC = 30
};
enum {
    TYPE_MANUAL = 0,
    TYPE_ABOUT = 1,
    TYPE_MESSAGE = 2,
    TYPE_MISSION = 3
};
enum {
    MESSAGE_TYPE_GENERAL = 0,
    MESSAGE_TYPE_DISASTER = 1,
    MESSAGE_TYPE_IMPERIAL = 2,
    MESSAGE_TYPE_EMIGRATION = 3,
    MESSAGE_TYPE_TRADE_CHANGE = 5,
    MESSAGE_TYPE_PRICE_CHANGE = 6,
    MESSAGE_TYPE_INVASION = 7
};
enum {
    SMACKER_Y_SCALE_NONE = 0,
    SMACKER_Y_SCALE_INTERLACE = 1,
    SMACKER_Y_SCALE_DOUBLE = 2
};
enum {
    SMACKER_FRAME_ERROR = 0,
    SMACKER_FRAME_OK = 1,
    SMACKER_FRAME_DONE = 2
};
enum {
    SPEED_DIRECTION_NEGATIVE = -1,
    SPEED_DIRECTION_STOPPED = 0,
    SPEED_DIRECTION_POSITIVE = 1
};
enum {
    GROUP_EDITOR_SCENARIO_IMAGE = 22,
    GROUP_EDITOR_BUILDING_CROPS = 23,
    GROUP_EDITOR_EMPIRE_MAP = 47,
    GROUP_EDITOR_SIDE_PANEL = 80,
    GROUP_EDITOR_EMPIRE_PANELS = 172,
    GROUP_EDITOR_BUILDING_NATIVE = 183,
    GROUP_EDITOR_EMPIRE_FOREIGN_CITY = 223,
    GROUP_EDITOR_TRADE_AMOUNT = 243,
};
enum {
    EMPIRE_OBJECT_ORNAMENT = 0,
    EMPIRE_OBJECT_CITY = 1,
    EMPIRE_OBJECT_BATTLE_ICON = 3,
    EMPIRE_OBJECT_LAND_TRADE_ROUTE = 4,
    EMPIRE_OBJECT_SEA_TRADE_ROUTE = 5,
    EMPIRE_OBJECT_ROMAN_ARMY = 6,
    EMPIRE_OBJECT_ENEMY_ARMY = 7,
};
enum {
    EMPIRE_CITY_DISTANT_ROMAN = 0,
    EMPIRE_CITY_OURS = 1,
    EMPIRE_CITY_TRADE = 2,
    EMPIRE_CITY_FUTURE_TRADE = 3,
    EMPIRE_CITY_DISTANT_FOREIGN = 4,
    EMPIRE_CITY_VULNERABLE_ROMAN = 5,
    EMPIRE_CITY_FUTURE_ROMAN = 6,
};
enum {
    FIGURE_NONE = 0,
    FIGURE_IMMIGRANT = 1,
    FIGURE_EMIGRANT = 2,
    FIGURE_HOMELESS = 3,
    FIGURE_PATRICIAN = 4,
    FIGURE_CART_PUSHER = 5,
    FIGURE_LABOR_SEEKER = 6,
    FIGURE_BARBER = 7,
    FIGURE_BATHHOUSE_WORKER = 8,
    FIGURE_DOCTOR = 9,
    FIGURE_SURGEON = 10,
    FIGURE_PRIEST = 11,
    FIGURE_SCHOOL_CHILD = 12,
    FIGURE_TEACHER = 13,
    FIGURE_LIBRARIAN = 14,
    FIGURE_MISSIONARY = 15,
    FIGURE_ACTOR = 16,
    FIGURE_GLADIATOR = 17,
    FIGURE_LION_TAMER = 18,
    FIGURE_CHARIOTEER = 19,
    FIGURE_HIPPODROME_HORSES = 20,
    FIGURE_TAX_COLLECTOR = 21,
    FIGURE_ENGINEER = 22,
    FIGURE_FISHING_BOAT = 23,
    FIGURE_FISH_GULLS = 24,
    FIGURE_SHIPWRECK = 25,
    FIGURE_DOCKER = 26,
    FIGURE_FLOTSAM = 27,
    FIGURE_BALLISTA = 28,
    FIGURE_BOLT = 29,
    FIGURE_TOWER_SENTRY = 30,
    FIGURE_JAVELIN = 31,
    FIGURE_PREFECT = 32,
    FIGURE_FORT_STANDARD = 33,
    FIGURE_FORT_JAVELIN = 34,
    FIGURE_FORT_MOUNTED = 35,
    FIGURE_FORT_LEGIONARY = 36,
    FIGURE_MARKET_BUYER = 37,
    FIGURE_MARKET_TRADER = 38,
    FIGURE_DELIVERY_BOY = 39,
    FIGURE_WAREHOUSEMAN = 40,
    FIGURE_PROTESTER = 41,
    FIGURE_CRIMINAL = 42,
    FIGURE_RIOTER = 43,
    FIGURE_TRADE_CARAVAN = 44,
    FIGURE_TRADE_CARAVAN_DONKEY = 45,
    FIGURE_TRADE_SHIP = 46,
    FIGURE_INDIGENOUS_NATIVE = 47,
    FIGURE_NATIVE_TRADER = 48,
    FIGURE_WOLF = 49,
    FIGURE_SHEEP = 50,
    FIGURE_ZEBRA = 51,
    FIGURE_ENEMY_GLADIATOR = 52,
    FIGURE_ENEMY_BARBARIAN_SWORDSMAN = 53,
    FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN = 54,
    FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT = 55,
    FIGURE_ENEMY_BRITON_SWORDSMAN = 56,
    FIGURE_ENEMY_BRITON_CHARIOT = 57,
    FIGURE_ENEMY_CELT_SWORDSMAN = 58,
    FIGURE_ENEMY_CELT_CHARIOT = 59,
    FIGURE_ENEMY_PICT_SWORDSMAN = 60,
    FIGURE_ENEMY_PICT_CHARIOT = 61,
    FIGURE_ENEMY_EGYPTIAN_SWORDSMAN = 62,
    FIGURE_ENEMY_EGYPTIAN_CAMEL = 63,
    FIGURE_ENEMY_ETRUSCAN_SWORDSMAN = 64,
    FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER = 65,
    FIGURE_ENEMY_SAMNITE_SWORDSMAN = 66,
    FIGURE_ENEMY_SAMNITE_SPEAR_THROWER = 67,
    FIGURE_ENEMY_GAUL_SWORDSMAN = 68,
    FIGURE_ENEMY_GAUL_AXEMAN = 69,
    FIGURE_ENEMY_HELVETIUS_SWORDSMAN = 70,
    FIGURE_ENEMY_HELVETIUS_AXEMAN = 71,
    FIGURE_ENEMY_HUN_SWORDSMAN = 72,
    FIGURE_ENEMY_HUN_MOUNTED_ARCHER = 73,
    FIGURE_ENEMY_GOTH_SWORDSMAN = 74,
    FIGURE_ENEMY_GOTH_MOUNTED_ARCHER = 75,
    FIGURE_ENEMY_VISIGOTH_SWORDSMAN = 76,
    FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER = 77,
    FIGURE_ENEMY_GREEK_SWORDSMAN = 78,
    FIGURE_ENEMY_GREEK_SPEAR_THROWER = 79,
    FIGURE_ENEMY_MACEDONIAN_SWORDSMAN = 80,
    FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER = 81,
    FIGURE_ENEMY_NUMIDIAN_SWORDSMAN = 82,
    FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER = 83,
    FIGURE_ENEMY_PERGAMUM_SWORDSMAN = 84,
    FIGURE_ENEMY_PERGAMUM_ARCHER = 85,
    FIGURE_ENEMY_IBERIAN_SWORDSMAN = 86,
    FIGURE_ENEMY_IBERIAN_SPEAR_THROWER = 87,
    FIGURE_ENEMY_JUDEAN_SWORDSMAN = 88,
    FIGURE_ENEMY_JUDEAN_SPEAR_THROWER = 89,
    FIGURE_ENEMY_SELEUCID_SWORDSMAN = 90,
    FIGURE_ENEMY_SELEUCID_SPEAR_THROWER = 91,
    FIGURE_ENEMY_CAESAR_JAVELIN = 92,
    FIGURE_ENEMY_CAESAR_MOUNTED = 93,
    FIGURE_ENEMY_CAESAR_LEGIONARY = 94,
    FIGURE_ARROW = 95,
    FIGURE_MAP_FLAG = 96,
    FIGURE_EXPLOSION = 97,
    FIGURE_TYPE_MAX = 98,
};
enum {
    ENEMY_TYPE_BARBARIAN = 0,
    ENEMY_TYPE_CARTHAGINIAN = 1,
    ENEMY_TYPE_BRITON = 2,
    ENEMY_TYPE_CELT = 3,
    ENEMY_TYPE_PICT = 4,
    ENEMY_TYPE_EGYPTIAN = 5,
    ENEMY_TYPE_ETRUSCAN = 6,
    ENEMY_TYPE_SAMNITE = 7,
    ENEMY_TYPE_GAUL = 8,
    ENEMY_TYPE_HELVETIUS = 9,
    ENEMY_TYPE_HUN = 10,
    ENEMY_TYPE_GOTH = 11,
    ENEMY_TYPE_VISIGOTH = 12,
    ENEMY_TYPE_GREEK = 13,
    ENEMY_TYPE_MACEDONIAN = 14,
    ENEMY_TYPE_NUMIDIAN = 15,
    ENEMY_TYPE_PERGAMUM = 16,
    ENEMY_TYPE_IBERIAN = 17,
    ENEMY_TYPE_JUDEAN = 18,
    ENEMY_TYPE_SELEUCID = 19,
    ENEMY_TYPE_CAESAR = 20
};
enum {
    ENEMY_IMG_TYPE_BARBARIAN = 0,
    ENEMY_IMG_TYPE_CARTHAGINIAN = 1,
    ENEMY_IMG_TYPE_CELT = 2,
    ENEMY_IMG_TYPE_EGYPTIAN = 3,
    ENEMY_IMG_TYPE_ETRUSCAN = 4,
    ENEMY_IMG_TYPE_GAUL = 5,
    ENEMY_IMG_TYPE_GOTH = 6,
    ENEMY_IMG_TYPE_GREEK = 7,
    ENEMY_IMG_TYPE_NORTH_AFRICAN = 8,
    ENEMY_IMG_TYPE_PERSIAN = 9,
    ENEMY_IMG_TYPE_PHOENICIAN = 10,
    ENEMY_IMG_TYPE_CAESAR = 11
};
enum {
    FIGURE_ACTION_IMMIGRANT_CREATED = 1,
    FIGURE_ACTION_IMMIGRANT_ARRIVING = 2,
    FIGURE_ACTION_IMMIGRANT_ENTERING_HOUSE = 3,
    FIGURE_ACTION_EMIGRANT_CREATED = 4,
    FIGURE_ACTION_EMIGRANT_EXITING_HOUSE = 5,
    FIGURE_ACTION_EMIGRANT_LEAVING = 6,
    FIGURE_ACTION_HOMELESS_CREATED = 7,
    FIGURE_ACTION_HOMELESS_GOING_TO_HOUSE = 8,
    FIGURE_ACTION_HOMELESS_ENTERING_HOUSE = 9,
    FIGURE_ACTION_HOMELESS_LEAVING = 10,
    FIGURE_ACTION_CARTPUSHER_INITIAL = 11,
    FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_WAREHOUSE = 12,
    FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_GRANARY = 13,
    FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_WORKSHOP = 14,
    FIGURE_ACTION_CARTPUSHER_AT_WAREHOUSE = 15,
    FIGURE_ACTION_CARTPUSHER_AT_GRANARY = 16,
    FIGURE_ACTION_CARTPUSHER_AT_WORKSHOP = 17,
    FIGURE_ACTION_CARTPUSHER_RETURNING = 18,
    FIGURE_ACTION_ROAMING = 19,
    FIGURE_ACTION_ROAMER_RETURNING = 20,
    FIGURE_ACTION_ENTERTAINER_AT_SCHOOL_CREATED = 21,
    FIGURE_ACTION_ENTERTAINER_EXITING_SCHOOL = 22,
    FIGURE_ACTION_ENTERTAINER_GOING_TO_VENUE = 23,
    FIGURE_ACTION_ENTERTAINER_ROAMING = 24,
    FIGURE_ACTION_ENTERTAINER_RETURNING = 25,
    FIGURE_ACTION_TAX_COLLECTOR_CREATED = 26,
    FIGURE_ACTION_TAX_COLLECTOR_ENTERING_EXITING = 27,
    FIGURE_ACTION_TAX_COLLECTOR_ROAMING = 28,
    FIGURE_ACTION_TAX_COLLECTOR_RETURNING = 29,
    FIGURE_ACTION_ENGINEER_CREATED = 30,
    FIGURE_ACTION_ENGINEER_ENTERING_EXITING = 31,
    FIGURE_ACTION_ENGINEER_ROAMING = 32,
    FIGURE_ACTION_ENGINEER_RETURNING = 33,
    FIGURE_ACTION_DOCKER_IDLING = 34,
    FIGURE_ACTION_DOCKER_IMPORT_QUEUE = 35,
    FIGURE_ACTION_DOCKER_EXPORT_QUEUE = 36,
    FIGURE_ACTION_DOCKER_IMPORT_GOING_TO_WAREHOUSE = 37,
    FIGURE_ACTION_DOCKER_EXPORT_GOING_TO_WAREHOUSE = 38,
    FIGURE_ACTION_DOCKER_EXPORT_RETURNING = 39,
    FIGURE_ACTION_DOCKER_IMPORT_RETURNING = 40,
    FIGURE_ACTION_DOCKER_IMPORT_AT_WAREHOUSE = 41,
    FIGURE_ACTION_DOCKER_EXPORT_AT_WAREHOUSE = 42,
    FIGURE_ACTION_PREFECT_CREATED = 43,
    FIGURE_ACTION_PREFECT_ENTERING_EXITING = 44,
    FIGURE_ACTION_PREFECT_ROAMING = 45,
    FIGURE_ACTION_PREFECT_RETURNING = 46,
    FIGURE_ACTION_PREFECT_GOING_TO_FIRE = 47,
    FIGURE_ACTION_PREFECT_AT_FIRE = 48,
    FIGURE_ACTION_SOLDIER_AT_REST = 49,
    FIGURE_ACTION_SOLDIER_GOING_TO_FORT = 50,
    FIGURE_ACTION_SOLDIER_RETURNING_TO_BARRACKS = 51,
    FIGURE_ACTION_SOLDIER_GOING_TO_STANDARD = 52,
    FIGURE_ACTION_SOLDIER_AT_STANDARD = 53,
    FIGURE_ACTION_SOLDIER_GOING_TO_MILITARY_ACADEMY = 54,
    FIGURE_ACTION_SOLDIER_MOPPING_UP = 55,
    FIGURE_ACTION_SOLDIER_GOING_TO_DISTANT_BATTLE = 56,
    FIGURE_ACTION_SOLDIER_RETURNING_FROM_DISTANT_BATTLE = 57,
    FIGURE_ACTION_TOWER_SENTRY_AT_REST = 58,
    FIGURE_ACTION_TOWER_SENTRY_PATROLLING = 59,
    FIGURE_ACTION_TOWER_SENTRY_RETURNING = 60,
    FIGURE_ACTION_TOWER_SENTRY_GOING_TO_TOWER = 61,
    FIGURE_ACTION_MARKET_BUYER_GOING_TO_STORAGE = 62,
    FIGURE_ACTION_MARKET_BUYER_RETURNING = 63,
    FIGURE_ACTION_WAREHOUSEMAN_CREATED = 64,
    FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE = 65,
    FIGURE_ACTION_WAREHOUSEMAN_AT_DELIVERY_BUILDING = 66,
    FIGURE_ACTION_WAREHOUSEMAN_RETURNING_EMPTY = 67,
    FIGURE_ACTION_WAREHOUSEMAN_GETTING_FOOD = 68,
    FIGURE_ACTION_WAREHOUSEMAN_AT_GRANARY = 69,
    FIGURE_ACTION_WAREHOUSEMAN_RETURNING_WITH_FOOD = 70,
    FIGURE_ACTION_WAREHOUSEMAN_GETTING_RESOURCE = 71,
    FIGURE_ACTION_WAREHOUSEMAN_AT_WAREHOUSE = 72,
    FIGURE_ACTION_WAREHOUSEMAN_RETURNING_WITH_RESOURCE = 73,
    FIGURE_ACTION_TRADE_CARAVAN_CREATED = 74,
    FIGURE_ACTION_TRADE_CARAVAN_ARRIVING = 75,
    FIGURE_ACTION_TRADE_CARAVAN_TRADING = 76,
    FIGURE_ACTION_TRADE_CARAVAN_LEAVING = 77,
    FIGURE_ACTION_TRADE_SHIP_CREATED = 78,
    FIGURE_ACTION_TRADE_SHIP_GOING_TO_DOCK = 79,
    FIGURE_ACTION_TRADE_SHIP_MOORED = 80,
    FIGURE_ACTION_TRADE_SHIP_GOING_TO_DOCK_QUEUE = 81,
    FIGURE_ACTION_TRADE_SHIP_ANCHORED = 82,
    FIGURE_ACTION_TRADE_SHIP_LEAVING = 83,
    FIGURE_ACTION_RIOTER_CREATED = 84,
    FIGURE_ACTION_RIOTER_MOVING = 85,
    FIGURE_ACTION_ENEMY_SPAWNING = 86,
    FIGURE_ACTION_ENEMY_REGROUPING = 87,
    FIGURE_ACTION_ENEMY_ADVANCING = 88,
    FIGURE_ACTION_ENEMY_ENGAGED = 89,
    FIGURE_ACTION_NATIVE_GOING_TO_MEETING_CENTER = 90,
    FIGURE_ACTION_NATIVE_RETURNING_FROM_MEETING = 91,
    FIGURE_ACTION_NATIVE_CREATED = 92,
    FIGURE_ACTION_NATIVE_ATTACKING = 93,
    FIGURE_ACTION_NATIVE_TRADER_GOING_TO_WAREHOUSE = 94,
    FIGURE_ACTION_NATIVE_TRADER_RETURNING = 95,
    FIGURE_ACTION_NATIVE_TRADER_CREATED = 96,
    FIGURE_ACTION_NATIVE_TRADER_AT_WAREHOUSE = 97,
    FIGURE_ACTION_BALLISTA_READY = 98,
    FIGURE_ACTION_FISHING_BOAT_CREATED = 99,
    FIGURE_ACTION_FISHING_BOAT_GOING_TO_FISH = 100,
    FIGURE_ACTION_FISHING_BOAT_FISHING = 101,
    FIGURE_ACTION_FISHING_BOAT_GOING_TO_WHARF = 102,
    FIGURE_ACTION_FISHING_BOAT_AT_WHARF = 103,
    FIGURE_ACTION_FISHING_BOAT_RETURNING_WITH_FISH = 104,
    FIGURE_ACTION_HERD_ANIMAL_AT_REST = 105,
    FIGURE_ACTION_HERD_ANIMAL_MOVING = 106,
    FIGURE_ACTION_HIPPODROME_HORSE_CREATED = 107,
    FIGURE_ACTION_HIPPODROME_HORSE_RACING = 108,
    FIGURE_ACTION_HIPPODROME_HORSE_DONE = 109,
    FIGURE_ACTION_FLOTSAM_CREATED = 110,
    FIGURE_ACTION_FLOTSAM_FLOATING = 111,
    FIGURE_ACTION_FLOTSAM_OFF_MAP = 112,
};
enum {
    TERRAIN_USAGE_ANY = 0,
    TERRAIN_USAGE_ROADS = 1,
    TERRAIN_USAGE_ENEMY = 2,
    TERRAIN_USAGE_PREFER_ROADS = 3,
    TERRAIN_USAGE_WALLS = 4,
    TERRAIN_USAGE_ANIMAL = 5,
};
enum {
    FORMATION_ATTACK_FOOD_CHAIN = 0,
    FORMATION_ATTACK_GOLD_STORES = 1,
    FORMATION_ATTACK_BEST_BUILDINGS = 2,
    FORMATION_ATTACK_TROOPS = 3,
    FORMATION_ATTACK_RANDOM = 4
};
enum {
    FORMATION_TORTOISE = 0,
    FORMATION_DOUBLE_LINE_1 = 1,
    FORMATION_DOUBLE_LINE_2 = 2,
    FORMATION_SINGLE_LINE_1 = 3,
    FORMATION_SINGLE_LINE_2 = 4,
    FORMATION_MOP_UP = 5,
    FORMATION_AT_REST = 6,
    FORMATION_ENEMY_MOB = 7,
    FORMATION_ENEMY_WIDE_COLUMN = 8,
    FORMATION_MAX = 9
};
enum {
    DIR_0_TOP = 0,
    DIR_1_TOP_RIGHT = 1,
    DIR_2_RIGHT = 2,
    DIR_3_BOTTOM_RIGHT = 3,
    DIR_4_BOTTOM = 4,
    DIR_5_BOTTOM_LEFT = 5,
    DIR_6_LEFT = 6,
    DIR_7_TOP_LEFT = 7,
    DIR_8_NONE = 8,
    DIR_FIGURE_AT_DESTINATION = 8,
    DIR_FIGURE_REROUTE = 9,
    DIR_FIGURE_LOST = 10,
    DIR_FIGURE_ATTACK = 11,
};
enum {
    SOUND_MUSIC = 1,
    SOUND_SPEECH = 2,
    SOUND_EFFECTS = 3,
    SOUND_CITY = 4,
};
enum {
    TRADE_SHIP_NONE = 0,
    TRADE_SHIP_BUYING = 1,
    TRADE_SHIP_SELLING = 2,
};
enum {
    MAP_FLAG_ENTRY = 1,
    MAP_FLAG_EXIT = 2,
    MAP_FLAG_EARTHQUAKE_MIN = 3,
    MAP_FLAG_EARTHQUAKE_MAX = 12,
    MAP_FLAG_INVASION_MIN = 13,
    MAP_FLAG_INVASION_MAX = 20,
    MAP_FLAG_RIVER_ENTRY = 21,
    MAP_FLAG_RIVER_EXIT = 22,
    MAP_FLAG_FISHING_MIN = 23,
    MAP_FLAG_FISHING_MAX = 30,
    MAP_FLAG_HERD_MIN = 31,
    MAP_FLAG_HERD_MAX = 38,
    MAP_FLAG_MIN = 1,
    MAP_FLAG_MAX = 39,
};
enum {
    OVERLAY_NONE = 0,
    OVERLAY_WATER = 2,
    OVERLAY_RELIGION = 4,
    OVERLAY_FIRE = 8,
    OVERLAY_DAMAGE = 9,
    OVERLAY_CRIME = 10,
    OVERLAY_ENTERTAINMENT = 11,
    OVERLAY_THEATER = 12,
    OVERLAY_AMPHITHEATER = 13,
    OVERLAY_COLOSSEUM = 14,
    OVERLAY_HIPPODROME = 15,
    OVERLAY_EDUCATION = 16,
    OVERLAY_SCHOOL = 17,
    OVERLAY_LIBRARY = 18,
    OVERLAY_ACADEMY = 19,
    OVERLAY_BARBER = 20,
    OVERLAY_BATHHOUSE = 21,
    OVERLAY_CLINIC = 22,
    OVERLAY_HOSPITAL = 23,
    OVERLAY_TAX_INCOME = 24,
    OVERLAY_FOOD_STOCKS = 25,
    OVERLAY_DESIRABILITY = 26,
    OVERLAY_WORKERS_UNUSED = 27,
    OVERLAY_NATIVE = 28,
    OVERLAY_PROBLEMS = 29
};
enum {
    CLIP_NONE,
    CLIP_LEFT,
    CLIP_RIGHT,
    CLIP_TOP,
    CLIP_BOTTOM,
    CLIP_BOTH,
    CLIP_INVISIBLE
};
enum {
    SCROLL_NONE = 0,
    SCROLL_UP = -1,
    SCROLL_DOWN = 1
};
enum {
    SCROLL_TYPE_CITY = 0,
    SCROLL_TYPE_EMPIRE = 1,
    SCROLL_TYPE_MAX = 2
};
enum {
    GRID_SIZE = 162
};
enum {
    TERRAIN_SHRUB = 1,
    TERRAIN_ROCK = 2,
    TERRAIN_WATER = 4,
    TERRAIN_BUILDING = 8,
    TERRAIN_TREE = 16,
    TERRAIN_GARDEN = 32,
    TERRAIN_ROAD = 64,
    TERRAIN_RESERVOIR_RANGE = 128,
    TERRAIN_AQUEDUCT = 256,
    TERRAIN_ELEVATION = 512,
    TERRAIN_ACCESS_RAMP = 1024,
    TERRAIN_MEADOW = 2048,
    TERRAIN_RUBBLE = 4096,
    TERRAIN_FOUNTAIN_RANGE = 8192,
    TERRAIN_WALL = 16384,
    TERRAIN_GATEHOUSE = 32768,
    // combined
    TERRAIN_WALL_OR_GATEHOUSE = TERRAIN_WALL | TERRAIN_GATEHOUSE,
    TERRAIN_NOT_CLEAR = TERRAIN_SHRUB | TERRAIN_ROCK | TERRAIN_WATER | TERRAIN_BUILDING | TERRAIN_TREE | TERRAIN_GARDEN | TERRAIN_ROAD | TERRAIN_AQUEDUCT | TERRAIN_ELEVATION | TERRAIN_ACCESS_RAMP | TERRAIN_RUBBLE | TERRAIN_WALL | TERRAIN_GATEHOUSE,
    TERRAIN_CLEARABLE = TERRAIN_SHRUB | TERRAIN_BUILDING | TERRAIN_TREE | TERRAIN_GARDEN | TERRAIN_ROAD | TERRAIN_AQUEDUCT | TERRAIN_RUBBLE | TERRAIN_WALL | TERRAIN_GATEHOUSE,
    TERRAIN_IMPASSABLE = TERRAIN_SHRUB | TERRAIN_ROCK | TERRAIN_WATER | TERRAIN_BUILDING | TERRAIN_TREE | TERRAIN_ELEVATION | TERRAIN_WALL | TERRAIN_GATEHOUSE,
    TERRAIN_ALL = 65535
};
enum {
    ROUTED_BUILDING_ROAD = 0,
    ROUTED_BUILDING_WALL = 1,
    ROUTED_BUILDING_AQUEDUCT = 2,
    ROUTED_BUILDING_AQUEDUCT_WITHOUT_GRAPHIC = 4,
};
enum {
    CITIZEN_0_ROAD = 0,
    CITIZEN_2_PASSABLE_TERRAIN = 2,
    CITIZEN_4_CLEAR_TERRAIN = 4,
    CITIZEN_N1_BLOCKED = -1,
    CITIZEN_N3_AQUEDUCT = -3,
    CITIZEN_N4_RESERVOIR_CONNECTOR = -4,

    NONCITIZEN_0_PASSABLE = 0,
    NONCITIZEN_1_BUILDING = 1,
    NONCITIZEN_2_CLEARABLE = 2,
    NONCITIZEN_3_WALL = 3,
    NONCITIZEN_4_GATEHOUSE = 4,
    NONCITIZEN_5_FORT = 5,
    NONCITIZEN_N1_BLOCKED = -1,

    WATER_0_PASSABLE = 0,
    WATER_N1_BLOCKED = -1,
    WATER_N2_MAP_EDGE = -2,
    WATER_N3_LOW_BRIDGE = -3,

    WALL_0_PASSABLE = 0,
    WALL_N1_BLOCKED = -1,
};
enum {
    EDGE_X0Y0 = 0,
    EDGE_X1Y0 = 1,
    EDGE_X2Y0 = 2,
    EDGE_X0Y1 = 8,
    EDGE_X1Y1 = 9,
    EDGE_X2Y1 = 10,
    EDGE_X0Y2 = 16,
    EDGE_X1Y2 = 17,
    EDGE_X2Y2 = 18
};
enum {
    EVENT_DISABLED = 0,
    EVENT_NOT_STARTED = 1,
    EVENT_IN_PROGRESS = 2,
    EVENT_FINISHED = 3
};
enum {
    INVASION_TYPE_LOCAL_UPRISING = 1,
    INVASION_TYPE_ENEMY_ARMY = 2,
    INVASION_TYPE_CAESAR = 3,
    INVASION_TYPE_DISTANT_BATTLE = 4,
};
enum {
    REQUEST_STATE_NORMAL = 0,
    REQUEST_STATE_OVERDUE = 1,
    REQUEST_STATE_DISPATCHED = 2,
    REQUEST_STATE_DISPATCHED_LATE = 3,
    REQUEST_STATE_IGNORED = 4,
    REQUEST_STATE_RECEIVED = 5
};
enum {
    SOUND_DIRECTION_LEFT = 0,
    SOUND_DIRECTION_CENTER = 2,
    SOUND_DIRECTION_RIGHT = 4
};
enum {
    SOUND_EFFECT_PANEL = 1,
    SOUND_EFFECT_SIDEBAR = 2,
    SOUND_EFFECT_ICON = 3,
    SOUND_EFFECT_BUILD = 4,
    SOUND_EFFECT_EXPLOSION = 5,
    SOUND_EFFECT_FANFARE = 6,
    SOUND_EFFECT_FANFARE_URGENT = 7,
    // battle effects
    SOUND_EFFECT_ARROW = 8,
    SOUND_EFFECT_ARROW_HIT = 9,
    SOUND_EFFECT_AXE = 10,
    SOUND_EFFECT_BALLISTA_SHOOT = 11,
    SOUND_EFFECT_BALLISTA_HIT_GROUND = 12,
    SOUND_EFFECT_BALLISTA_HIT_PERSON = 13,
    SOUND_EFFECT_CLUB = 14,
    SOUND_EFFECT_CAMEL = 15,
    SOUND_EFFECT_ELEPHANT = 16,
    SOUND_EFFECT_ELEPHANT_HIT = 17,
    SOUND_EFFECT_ELEPHANT_DIE = 18,
    SOUND_EFFECT_HORSE = 19,
    SOUND_EFFECT_HORSE2 = 20,
    SOUND_EFFECT_HORSE_MOVING = 21,
    SOUND_EFFECT_JAVELIN = 22,
    SOUND_EFFECT_LION_ATTACK = 23,
    SOUND_EFFECT_LION_DIE = 24,
    SOUND_EFFECT_HORN3 = 25,
    SOUND_EFFECT_SWORD = 26,
    SOUND_EFFECT_SWORD_SWING = 27,
    SOUND_EFFECT_LIGHT_SWORD = 28,
    SOUND_EFFECT_SPEAR = 29,
    SOUND_EFFECT_WOLF_ATTACK = 30,
    SOUND_EFFECT_WOLF_ATTACK_2 = 31,
    SOUND_EFFECT_WOLF_DIE = 32,
    SOUND_EFFECT_SOLDIER_DIE = 33, // 4x
    SOUND_EFFECT_CITIZEN_DIE = 37, // 4x
    SOUND_EFFECT_SHEEP_DIE = 41,
    SOUND_EFFECT_ZEBRA_DIE = 42,
    SOUND_EFFECT_WOLF_HOWL = 43,
    SOUND_EFFECT_FIRE_SPLASH = 44,
    SOUND_EFFECT_FORMATION_SHIELD = 45
};
enum {
    MENU_VACANT_HOUSE = 0,
    MENU_CLEAR_LAND = 1,
    MENU_ROAD = 2,
    MENU_WATER = 3,
    MENU_HEALTH = 4,
    MENU_TEMPLES = 5,
    MENU_EDUCATION = 6,
    MENU_ENTERTAINMENT = 7,
    MENU_ADMINISTRATION = 8,
    MENU_ENGINEERING = 9,
    MENU_SECURITY = 10,
    MENU_INDUSTRY = 11,
};
enum {
    FILE_DIALOG_SAVE = 0,
    FILE_DIALOG_LOAD = 1,
};
enum {
    FILE_TYPE_SAVED_GAME = 0,
    FILE_TYPE_SCENARIO = 1
};
enum {
    MESSAGE_DIALOG_TOP_FUNDS = 15,
    MESSAGE_DIALOG_TOP_POPULATION = 16,
    MESSAGE_DIALOG_TOP_DATE = 17,
    MESSAGE_DIALOG_OVERLAYS = 18,
    MESSAGE_DIALOG_ADVISOR_LABOR = 20,
    MESSAGE_DIALOG_ADVISOR_MILITARY = 21,
    MESSAGE_DIALOG_ADVISOR_IMPERIAL = 22,
    MESSAGE_DIALOG_ADVISOR_RATINGS = 23,
    MESSAGE_DIALOG_ADVISOR_TRADE = 24,
    MESSAGE_DIALOG_ADVISOR_POPULATION = 25,
    MESSAGE_DIALOG_ADVISOR_HEALTH = 26,
    MESSAGE_DIALOG_ADVISOR_EDUCATION = 27,
    MESSAGE_DIALOG_ADVISOR_ENTERTAINMENT = 28,
    MESSAGE_DIALOG_ADVISOR_RELIGION = 29,
    MESSAGE_DIALOG_ADVISOR_FINANCIAL = 30,
    MESSAGE_DIALOG_ADVISOR_CHIEF = 31,
    MESSAGE_DIALOG_EMPIRE_MAP = 32,
    MESSAGE_DIALOG_MESSAGES = 34,
    MESSAGE_DIALOG_INDUSTRY = 46,
    MESSAGE_DIALOG_THEFT = 251,
    MESSAGE_DIALOG_EDITOR_ABOUT = 331,
    MESSAGE_DIALOG_EDITOR_HELP = 332,
};
enum {
    SLIDE_DIRECTION_IN = 0,
    SLIDE_DIRECTION_OUT = 1
};
enum {
    IB_NORMAL = 4,
    IB_SCROLL = 6,
    IB_BUILD = 2
};
enum {
    STATUS_NOT_ENOUGH_RESOURCES = -1,
    STATUS_CONFIRM_SEND_LEGIONS = -2,
    STATUS_NO_LEGIONS_SELECTED = -3,
    STATUS_NO_LEGIONS_AVAILABLE = -4,
};
enum {
    MODE_TEXT,
    MODE_GROUP,
};
enum {
    INTERMEZZO_MISSION_BRIEFING = 0,
    INTERMEZZO_FIRED = 1,
    INTERMEZZO_WON = 2,
};
enum {
    INFO_NONE = 0,
    INFO_FUNDS = 1,
    INFO_POPULATION = 2,
    INFO_DATE = 3
};
enum {
    FIGURE_COLOR_NONE = 0,
    FIGURE_COLOR_SOLDIER = 1,
    FIGURE_COLOR_SELECTED_SOLDIER = 2,
    FIGURE_COLOR_ENEMY = 3,
    FIGURE_COLOR_WOLF = 4
};
enum {
    REFRESH_NOT_NEEDED = 0,
    REFRESH_FULL = 1,
    REFRESH_CAMERA_MOVED = 2
};
enum {
    COLUMN_TYPE_RISK,
    COLUMN_TYPE_ACCESS
};
enum {
    SIDEBAR_EXTRA_DISPLAY_NONE = 0,
    SIDEBAR_EXTRA_DISPLAY_GAME_SPEED = 1,
    SIDEBAR_EXTRA_DISPLAY_UNEMPLOYMENT = 2,
    SIDEBAR_EXTRA_DISPLAY_RATINGS = 4,
    SIDEBAR_EXTRA_DISPLAY_ALL = 7
};
enum {
    SOUND_CHANNEL_CITY_VACANT_LOT = 46, // house_slum1 and house_slum2
    SOUND_CHANNEL_CITY_HOUSE_SLUM = 48,
    SOUND_CHANNEL_CITY_HOUSE_POOR = 50,
    SOUND_CHANNEL_CITY_HOUSE_MEDIUM = 54,
    SOUND_CHANNEL_CITY_HOUSE_GOOD = 58,
    SOUND_CHANNEL_CITY_HOUSE_POSH = 62,
    SOUND_CHANNEL_CITY_EMPTY_LAND = 66,
    SOUND_CHANNEL_CITY_RESERVOIR = 67,
    SOUND_CHANNEL_CITY_AQUEDUCT = 68,
    SOUND_CHANNEL_CITY_FOUNTAIN = 69,
    SOUND_CHANNEL_CITY_WELL = 70,
    SOUND_CHANNEL_CITY_BARBER = 71,
    SOUND_CHANNEL_CITY_BATHHOUSE = 72,
    SOUND_CHANNEL_CITY_CLINIC = 73,
    SOUND_CHANNEL_CITY_HOSPITAL = 74,
    SOUND_CHANNEL_CITY_TEMPLE_CERES = 75,
    SOUND_CHANNEL_CITY_TEMPLE_NEPTUNE = 76,
    SOUND_CHANNEL_CITY_TEMPLE_MERCURY = 78,
    SOUND_CHANNEL_CITY_TEMPLE_MARS = 79,
    SOUND_CHANNEL_CITY_TEMPLE_VENUS = 81,
    SOUND_CHANNEL_CITY_ORACLE = 82,
    SOUND_CHANNEL_CITY_SCHOOL = 83,
    SOUND_CHANNEL_CITY_ACADEMY = 84,
    SOUND_CHANNEL_CITY_LIBRARY = 85,
    SOUND_CHANNEL_CITY_THEATER = 86,
    SOUND_CHANNEL_CITY_AMPHITHEATER = 87,
    SOUND_CHANNEL_CITY_COLOSSEUM = 88,
    SOUND_CHANNEL_CITY_HIPPODROME = 89,
    SOUND_CHANNEL_CITY_GLADIATOR_SCHOOL = 90,
    SOUND_CHANNEL_CITY_LION_PIT = 91,
    SOUND_CHANNEL_CITY_ACTOR_COLONY = 92,
    SOUND_CHANNEL_CITY_CHARIOT_MAKER = 93,
    SOUND_CHANNEL_CITY_FORUM = 94,
    SOUND_CHANNEL_CITY_SENATE = 95,
    SOUND_CHANNEL_CITY_PALACE = 96,
    SOUND_CHANNEL_CITY_STATUE = 97,
    SOUND_CHANNEL_CITY_GARDEN = 98,
    SOUND_CHANNEL_CITY_SHIPYARD = 102,
    SOUND_CHANNEL_CITY_DOCK = 105,
    SOUND_CHANNEL_CITY_WHARF = 108,
    SOUND_CHANNEL_CITY_TOWER = 111,
    SOUND_CHANNEL_CITY_FORT = 115,
    SOUND_CHANNEL_CITY_BARRACKS = 119,
    SOUND_CHANNEL_CITY_MILITARY_ACADEMY = 120,
    SOUND_CHANNEL_CITY_WHEAT_FARM = 121,
    SOUND_CHANNEL_CITY_VEGETABLE_FARM = 123,
    SOUND_CHANNEL_CITY_FRUIT_FARM = 124,
    SOUND_CHANNEL_CITY_OLIVE_FARM = 125,
    SOUND_CHANNEL_CITY_VINE_FARM = 126,
    SOUND_CHANNEL_CITY_PIG_FARM = 127,
    SOUND_CHANNEL_CITY_CLAY_PIT = 128,
    SOUND_CHANNEL_CITY_QUARRY = 129,
    SOUND_CHANNEL_CITY_IRON_MINE = 130,
    SOUND_CHANNEL_CITY_TIMBER_YARD = 131,
    SOUND_CHANNEL_CITY_WINE_WORKSHOP = 132,
    SOUND_CHANNEL_CITY_OIL_WORKSHOP = 133,
    SOUND_CHANNEL_CITY_WEAPONS_WORKSHOP = 134,
    SOUND_CHANNEL_CITY_FURNITURE_WORKSHOP = 136,
    SOUND_CHANNEL_CITY_POTTERY_WORKSHOP = 138,
    SOUND_CHANNEL_CITY_MARKET = 140,
    SOUND_CHANNEL_CITY_GRANARY = 144,
    SOUND_CHANNEL_CITY_WAREHOUSE = 147,
    SOUND_CHANNEL_CITY_BURNING_RUIN = 150,
};
enum {
    TRACK_NONE = 0,
    TRACK_CITY_1 = 1,
    TRACK_CITY_2 = 2,
    TRACK_CITY_3 = 3,
    TRACK_CITY_4 = 4,
    TRACK_CITY_5 = 5,
    TRACK_COMBAT_SHORT = 6,
    TRACK_COMBAT_LONG = 7,
    TRACK_INTRO = 8,
    TRACK_MAX = 9
};
enum {
    EVENT_ROME_RAISES_WAGES = 1,
    EVENT_ROME_LOWERS_WAGES = 2,
    EVENT_LAND_TRADE_DISRUPTED = 3,
    EVENT_LAND_SEA_DISRUPTED = 4,
    EVENT_CONTAMINATED_WATER = 5
};
enum {
    BIT_SIZE1 = 0x00,
    BIT_SIZE2 = 0x01,
    BIT_SIZE3 = 0x02,
    BIT_SIZE4 = 0x04,
    BIT_SIZE5 = 0x08,
    BIT_SIZES = 0x0f,
    BIT_NO_SIZES = 0xf0,
    BIT_CONSTRUCTION = 0x10,
    BIT_NO_CONSTRUCTION = 0xef,
    BIT_ALTERNATE_TERRAIN = 0x20,
    BIT_DELETED = 0x40,
    BIT_NO_DELETED = 0xbf,
    BIT_PLAZA_OR_EARTHQUAKE = 0x80,
    BIT_NO_PLAZA = 0x7f,
    BIT_NO_CONSTRUCTION_AND_DELETED = 0xaf,
    EDGE_MASK_X = 0x7,
    EDGE_MASK_Y = 0x38,
    EDGE_MASK_XY = 0x3f,
    EDGE_LEFTMOST_TILE = 0x40,
    EDGE_NO_LEFTMOST_TILE = 0xbf,
    EDGE_NATIVE_LAND = 0x80,
    EDGE_NO_NATIVE_LAND = 0x7f,
};
enum {
    CONTEXT_WATER,
    CONTEXT_WALL,
    CONTEXT_WALL_GATEHOUSE,
    CONTEXT_ELEVATION,
    CONTEXT_EARTHQUAKE,
    CONTEXT_DIRT_ROAD,
    CONTEXT_PAVED_ROAD,
    CONTEXT_AQUEDUCT,
    CONTEXT_MAX_ITEMS
};
enum {
    SYSTEM_NONE = 0,
    SYSTEM_UP = 1,
    SYSTEM_DOWN = 2,
    SYSTEM_DOUBLE_CLICK = 4
};
enum {
    FULL_CITY_SCREENSHOT = 0,
    DISPLAY_SCREENSHOT = 1
};
enum {
    DRAW_TYPE_SET,
    DRAW_TYPE_AND,
    DRAW_TYPE_NONE,
    DRAW_TYPE_BLEND,
    DRAW_TYPE_BLEND_ALPHA
};
enum {
    EVOLVE = 1,
    NONE = 0,
    DEVOLVE = -1
};
enum {
    HORSE_CREATED = 0,
    HORSE_RACING = 1,
    HORSE_FINISHED = 2
};
enum {
    DESTROYABLE_BUILDING,
    DESTROYABLE_AQUEDUCT_GARDEN,
    DESTROYABLE_WALL,
    DESTROYABLE_GATEHOUSE,
    DESTROYABLE_NONE
};
enum {
    EMPIRE_HEADER_SIZE = 1280,
    EMPIRE_DATA_SIZE = 12800
};
enum {
    MENU_NONE = 0,
    MENU_SHRUB = 1,
    MENU_ELEVATION = 2,
    MENU_ROCK = 3,
    MENU_BRUSH_SIZE = 4,
    MENU_EARTHQUAKE_POINTS = 5,
    MENU_INVASION_POINTS = 6,
    MENU_PEOPLE_POINTS = 7,
    MENU_RIVER_POINTS = 8,
    MENU_NATIVE_BUILDINGS = 9,
    MENU_ANIMAL_POINTS = 10,
};
enum {
    TOOL_NONE = 0,
    TOOL_GRASS = 1,
    TOOL_SMALL_SHRUB = 2,
    TOOL_MEDIUM_SHRUB = 3,
    TOOL_LARGE_SHRUB = 4,
    TOOL_LARGEST_SHRUB = 5,
    TOOL_WATER = 6,
    TOOL_RAISE_LAND = 7,
    TOOL_LOWER_LAND = 8,
    TOOL_ACCESS_RAMP = 9,
    TOOL_TREES = 10,
    TOOL_SMALL_ROCK = 11,
    TOOL_MEDIUM_ROCK = 12,
    TOOL_LARGE_ROCK = 13,
    TOOL_MEADOW = 14,
    TOOL_ROAD = 15,
    TOOL_EARTHQUAKE_POINT = 16,
    TOOL_INVASION_POINT = 17,
    TOOL_ENTRY_POINT = 18,
    TOOL_EXIT_POINT = 19,
    TOOL_RIVER_ENTRY_POINT = 20,
    TOOL_RIVER_EXIT_POINT = 21,
    TOOL_NATIVE_HUT = 22,
    TOOL_NATIVE_FIELD = 23,
    TOOL_NATIVE_CENTER = 24,
    TOOL_HOUSE_VACANT_LOT = 25,
    TOOL_FISHING_POINT = 26,
    TOOL_HERD_POINT = 27,
};
enum {
    RATING_CULTURE,
    RATING_PROSPERITY,
    RATING_PEACE,
    RATING_FAVOR
};
enum {
    CUSTOM_MESSAGE_ATTRIBUTES = 0,
    CUSTOM_MESSAGE_TITLE = 1,
    CUSTOM_MESSAGE_TEXT = 2,
};
enum {
    LABOR_CATEGORY_INDUSTRY_COMMERCE = 0,
    LABOR_CATEGORY_FOOD_PRODUCTION = 1,
    LABOR_CATEGORY_ENGINEERING = 2,
    LABOR_CATEGORY_WATER = 3,
    LABOR_CATEGORY_PREFECTURES = 4,
    LABOR_CATEGORY_MILITARY = 5,
    LABOR_CATEGORY_ENTERTAINMENT = 6,
    LABOR_CATEGORY_HEALTH_EDUCATION = 7,
    LABOR_CATEGORY_GOVERNANCE_RELIGION = 8
};
enum {
    WELL_NECESSARY = 0,
    WELL_UNNECESSARY_FOUNTAIN = 1,
    WELL_UNNECESSARY_NO_HOUSES = 2
};
enum {
    WAREHOUSE_ROOM = 0,
    WAREHOUSE_FULL = 1,
    WAREHOUSE_SOME_ROOM = 2
};
enum {
    WAREHOUSE_TASK_NONE = -1,
    WAREHOUSE_TASK_GETTING = 0,
    WAREHOUSE_TASK_DELIVERING = 1
};
enum {
    GRANARY_TASK_NONE = -1,
    GRANARY_TASK_GETTING = 0
};
// end enums

// start chars
static char MAPS_DIR_PATH[DIR_PATH_MAX]; // the path to the /maps folder in the Brutus directory
static char SETTINGS_FILE_PATH[DIR_PATH_MAX]; // the path to "brutus.settings" within the Brutus directory
static char SAVES_DIR_PATH[DIR_PATH_MAX]; // the path to the /saves folder in the Brutus directory
static char log_buffer[MSG_SIZE];
static char SOUND_FILE_LOSE[] = "wavs/lose_game.wav";
static char SOUND_FILE_WIN[] = "wavs/actors_great1.wav";
static char EDITOR_FILES[MAX_EDITOR_FILES][32] = {
    "c3_map.eng",
    "c3_map_mm.eng",
    "c3map.sg2",
    "c3map.555",
    "c3map_north.sg2",
    "c3map_north.555",
    "c3map_south.sg2",
    "c3map_south.555",
    "map_panels.555"
};
static char *submenu_strings[] = {
    "Menu: Small Temples",  // 0
    "Menu: Large Temples",  // 1
    "Menu: Forts", // 2
    "Menu: Farms",  // 3
    "Menu: Raw Materials",  // 4
    "Menu: Workshops"  // 5
};
static char tracks[][32] = {
    "",
    "wavs/ROME1.WAV",
    "wavs/ROME2.WAV",
    "wavs/ROME3.WAV",
    "wavs/ROME4.WAV",
    "wavs/ROME5.WAV",
    "wavs/Combat_Short.wav",
    "wavs/Combat_Long.wav",
    "wavs/setup.wav"
};
static char mp3_tracks[][32] = {
    "",
    "mp3/ROME1.mp3",
    "mp3/ROME2.mp3",
    "mp3/ROME3.mp3",
    "mp3/ROME4.mp3",
    "mp3/ROME5.mp3",
    "mp3/Combat_Short.mp3",
    "mp3/Combat_Long.mp3",
    "mp3/setup.mp3"
};
static char filename_formats[][32] = {
    "full city %Y-%m-%d %H.%M.%S.bmp",
    "city %Y-%m-%d %H.%M.%S.bmp",
};
static char CHAR_TO_FONT_IMAGE_DEFAULT[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3F, 0x40, 0x00, 0x00, 0x41, 0x00, 0x4A, 0x43, 0x44, 0x42, 0x46, 0x4E, 0x45, 0x4F, 0x4D,
    0x3E, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x48, 0x49, 0x00, 0x47, 0x00, 0x4B,
    0x00, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29,
    0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00, 0x50,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00,
};
static char *city_names[] = {
    "Roma",
    "Tarentum",
    "Capua",
    "Brundisium",
    "Mediolanum",
    "Carthago Nova",
    "Carthago",
    "Tarraco",
    "Athenae",
    "Pergamum",
    "Syracusae",
    "Toletum",
    "Tarsus",
    "Leptis Magna",
    "Tingis",
    "Corinthus",
    "Valentia",
    "Ephesus",
    "Miletus",
    "Sinope",
    "Cyrene",
    "Antiocha",
    "Heliopolis",
    "Damascus",
    "Hierosolyma",
    "Lindum",
    "Calleva",
    "Lutetia",
    "Massilia",
    "Narbo",
    "Lugdunum",
    "Caesarea",
    "Alexandria",
    "Augusta Trevorum",
    "Argentoratum",
    "Volubilis",
    "Londinium",
    "Thamugadi",
    "Sarmizegetusa",
    "Byzantium",
};
static char editor_menu_types_strings[][MAX_ITEMS_PER_MENU][19] = {
    {""},
    {"Small shrub", "Medium shrub", "Large shrub", "Largest shrub"},
    {"Raise land", "Lower land", "Access ramp"},
    {"Small rock", "Medium rock", "Large rock"},
    {"Tiny brush", "Small brush", "Medium brush", "Big brush", "Biggest brush"},
    {"Earthquake point 1", "Earthquake point 2", "Earthquake point 3", "Earthquake point 4", "Earthquake point 5", "Earthquake point 6", "Earthquake point 7", "Earthquake point 8"},
    {"Invasion point 1", "Invasion point 2", "Invasion point 3", "Invasion point 4", "Invasion point 5", "Invasion point 6", "Invasion point 7", "Invasion point 8"},
    {"Entry point", "Exit point"},
    {"River entry", "River exit"},
    {"Native hut", "Native field", "Native center", "Vacant lot"},
    {"Fishing point 1", "Fishing point 2", "Fishing point 3", "Fishing point 4", "Fishing point 5", "Fishing point 6", "Fishing point 7", "Fishing point 8",
    "Herd point 1", "Herd point 2", "Herd point 3", "Herd point 4", "Herd point 5", "Herd point 6", "Herd point 7", "Herd point 8"},
};
static char *climate_types_strings[] = {
    "Northern provinces", // 0
    "Central provinces", // 1
    "Desert provinces", // 2
};
static char *earthquakes_strings[] = {
    "Earthquake point 1", // 2
    "Earthquake point 2", // 3
    "Earthquake point 3", // 4
    "Earthquake point 4", // 5
    "Earthquake point 5", // 6
    "Earthquake point 6", // 7
    "Earthquake point 7", // 8
    "Earthquake point 8", // 9
};
static char *invasions_enemy_type_strings[] = {
    "Barbarians", // 0
    "Carthaginians", // 1
    "Britons", // 2
    "Celts", // 3
    "Picts", // 4
    "Egyptians", // 5
    "Etruscans", // 6
    "Samnites", // 7
    "Gauls", // 8
    "Helvetii", // 9
    "Huns", // 10
    "Goths", // 11
    "Visigoths", // 12
    "Graeci", // 13
    "Macedonians", // 14
    "Numidians", // 15
    "Pergamum", // 16
    "Iberians", // 17
    "Judaeans", // 18
    "Seleucids", // 19
};
static char *invasions_enemy_army_type_strings[] = {
    "No invaders", // 0
    "Local raiders", // 1
    "Enemy army", // 2
    "Caesar's legions", // 3
    "Distant battle", // 4
};
static char *invasions_entry_points[] = {
    "Entry point 1",
    "Entry point 2",
    "Entry point 3",
    "Entry point 4",
    "Entry point 5",
    "Entry point 6",
    "Entry point 7",
    "Entry point 8",
    "Random entry point",
};
static char *invasions_target_types[] = {
    "Attack food chain",
    "Attack gold stores",
    "Attack best buildings",
    "Attack troops",
    "Random attack",
};
static char route_display_names[MAX_DEMAND_ROUTES][DEMAND_ROUTE_MAX_NAME_LENGTH];
static char *resource_strings[] = {
    "No resource", // RESOURCE_NONE
    "Wheat", // RESOURCE_WHEAT
    "Vegetables", // RESOURCE_VEGETABLES
    "Fruit", // RESOURCE_FRUIT
    "Meat", // RESOURCE_MEAT
    "Olives", // RESOURCE_OLIVES
    "Vines", // RESOURCE_VINES
    "Clay", // RESOURCE_CLAY
    "Timber", // RESOURCE_TIMBER
    "Marble", // RESOURCE_MARBLE
    "Iron", // RESOURCE_IRON
    "Oil", // RESOURCE_OIL
    "Wine", // RESOURCE_WINE
    "Pottery", // RESOURCE_POTTERY
    "Furniture", // RESOURCE_FURNITURE
    "Weapons", // RESOURCE_WEAPONS
    "Denarii" // RESOURCE_DENARII
};
static char *MODEST_GIFT_STRINGS[] = {
    "A Greek manuscript",
    "Persian carpets",
    "Egyptian glassware",
    "African ivory",
};
static char *GENEROUS_GIFT_STRINGS[] = {
    "A troupe of performing slaves",
    "Arabian stallions",
    "An educated slave",
    "Gaulish bodyguards",
};
static char *LAVISH_GIFT_STRINGS[] = {
    "Cheetahs and giraffes",
    "A chest of sapphires",
    "A golden chariot",
    "A Pharaoh's burial mask",
};
static char *all_buildings_strings[] = {
    "None", // 0
    "Vacant Lot", // 1
    "Small Tent", // 2
    "Large Tent", // 3
    "Small Shack", // 4
    "Large Shack", // 5
    "Small Hovel", // 6
    "Large Hovel", // 7
    "Small Casa", // 8
    "Large Casa", // 9
    "Small Insula", // 10
    "Medium Insula", // 11
    "Large Insula", // 12
    "Grand Insula", // 13
    "Small Villa", // 14
    "Medium Villa", // 15
    "Large Villa", // 16
    "Grand Villa", // 17
    "Small Palace", // 18
    "Medium Palace", // 19
    "Large Palace", // 20
    "Luxury Palace", // 21
    "Clear Land", // 22
    "Road", // 23
    "Reservoir", // 24
    "Aqueduct", // 25
    "Fountain", // 26
    "Well", // 27
    "Doctor", // 28
    "Bathhouse", // 29
    "Barber", // 30
    "Hospital", // 31
    "Small Temple: Ceres", // 32
    "Small Temple: Neptune", // 33
    "Small Temple: Mercury", // 34
    "Small Temple: Mars", // 35
    "Small Temple: Venus", // 36
    "Large Temple: Ceres", // 37
    "Large Temple: Neptune", // 38
    "Large Temple: Mercury", // 39
    "Large Temple: Mars", // 40
    "Large Temple: Venus", // 41
    "Oracle", // 42
    "School", // 43
    "Library", // 44
    "Academy", // 45
    "Mission Post", // 46
    "Theater", // 47
    "Actor Colony", // 48
    "Amphitheater", // 49
    "Gladiator School", // 50
    "Lion House", // 51
    "Colosseum", // 52
    "Chariot Maker", // 53
    "Hippodrome", // 54
    "Gardens", // 55
    "Plaza", // 56
    "Small Statue", // 57
    "Medium Statue", // 58
    "Large Statue", // 59
    "Governors House", // 60
    "Governors Villa", // 61
    "Governors Palace", // 62
    "Forum", // 63
    "Senate", // 64
    "Triumphal Arch", // 65
    "Engineers Post", // 66
    "Low Bridge", // 67
    "Ship Bridge", // 68
    "Shipyard", // 69
    "Wharf", // 70
    "Dock", // 71
    "Prefecture", // 72
    "Wall", // 73
    "Tower", // 74
    "Gatehouse", // 75
    "Fort: Legionaries", // 76
    "Fort: Javelin", // 77
    "Fort: Mounted", // 78
    "Barracks", // 79
    "Military Academy", // 80
    "Wheat Farm", // 81
    "Vegetable Farm", // 82
    "Fruit Farm", // 83
    "Pig Farm", // 84
    "Olive Farm", // 85
    "Vines Farm", // 86
    "Clay Pit", // 87
    "Timber Yard", // 88
    "Marble Quarry", // 89
    "Iron Mine", // 90
    "Oil Workshop", // 91
    "Wine Workshop", // 92
    "Pottery Workshop", // 93
    "Furniture Workshop", // 94
    "Weapons Workshop", // 95
    "Market", // 96
    "Granary", // 97
    "Warehouse", // 98
    "Warehouse Space", // 99
    "Native Hut", // 100
    "Native Meeting", // 101
    "Native Crops", // 102
    "Fort Ground", // 103
    "Burning Ruin", // 104
};
static char *amenities_coverage_strings[] = {
    "Sparse", // 0
    "Very poor", // 1
    "Poor", // 2
    "Below average", // 3
    "Average", // 4
    "Average", // 5
    "Above average", // 6
    "Good", // 7
    "Very good", // 8
    "Excellent", // 9
    "Perfect", // 10
};
static char *citizen_names[FIGURE_MAX_NAME_LENGTH] = {
    "Antonius Licinius",
    "Arminius Aelius",
    "Brutus Antonius",
    "Cornelius Caelius",
    "Flavius Didius",
    "Gaius Cassius",
    "Germanicus Lupus",
    "Gnaeus Curtius",
    "Gregorius Furius",
    "Ericius Uletus",
    "Davius Lesterius",
    "Simus Bradibus",
    "Marcus Fabius",
    "Iason Atrebus",
    "Ovidius Porcius",
    "Pius Furtivus",
    "Publius Domitius",
    "Septimius Horatius",
    "Tiberius Iunius",
    "Timaeus Manlius",
    "Tobius Marcius",
    "Varius Papirus",
    "Antonius Servilius",
    "Arminius Sempronius",
    "Artus Sergius",
    "Berosus Terentius",
    "Brutus Tullius",
    "Calamitus Ulpius",
    "Cornelius Valerius",
    "Flavius Voluminus",
    "Gaius Aemilius",
    "Germanicus Antoninus",
    "Gnaeus Caecilius",
    "Iason Caelius",
    "Gregorius Cornelius",
    "Lucius Curtius",
    "Lycus Didius",
    "Marcus Domitius",
    "Ovidius Fabius",
    "Pius Flaminius",
    "Publius Flavius",
    "Septimius Furius",
    "Tiberius Furtivus",
    "Linnaeus Horatius",
    "Tobius Iunius",
    "Varius Livius",
    "Antonius Lucretius",
    "Arminius Lupus",
    "Marcus Lupus",
    "Septimius Lupus",
    "Atrius Manlius",
    "Berosus Marcius",
    "Cennaeus Parcerius",
    "Brutus Marius",
    "Cornelius Papirus",
    "Flavius Porcius",
    "Gaius Servilius",
    "Germanicus Sempronius",
    "Gnaeus Sergius",
    "Gregorius Terentius",
    "Lucius Tullius",
    "Pius Ulpius",
    "Ovidius Valerius",
    "Publius Volumnius",
};
static char *patrician_names[FIGURE_MAX_NAME_LENGTH] = {
    "Pompus Maximus",
    "Cornelius Marius",
    "Dracus Flavius",
    "Lexus Carus",
    "Elegus Copiosus",
    "Lascivius Avarus",
    "Disertius Vagitus",
    "Solutus Honestus",
    "Ignavus Parasitus",
    "Dominus Populus",
    "Vilis Vermiculus",
    "Cetus Immanis",
    "Garrulus Vacuus",
    "Iuglanius Cinerius",
    "Cereus Opuntius",
    "Stelarius Medius",
    "Canadensus Dicentrus",
    "Chilopsus Alnus",
    "Pedicularus Sinensus",
    "Epilobius Erechtitus",
    "Titus Gormengastus",
    "Aconitus Carmicaelus",
    "Corydalus Aureus",
    "Crescitus Amorus",
    "Gustibus Disputandus",
    "Audentus Fortunus",
    "Multus Facereus",
    "Obsequium Amicus",
    "Aereus Aedificius",
    "Vinus Veritus",
    "Profanus Vulgus",
    "Ignorabatus Ignoramus",
};
static char *female_names[FIGURE_MAX_NAME_LENGTH] = {
    "Aggripina Volumnius",
    "Annia Sturatus",
    "Aspasia Ulpius",
    "Cornelia Tullius",
    "Drusilla Terentius",
    "Lavinia Sergius",
    "Livia Servilius",
    "Lidia Sempronius",
    "Messalina Manlius",
    "Pomponia Papirius",
    "Octavia Marius",
    "Korenia Bucknerius",
    "Valencia Domitius",
    "Valeria Flaminius",
    "Vipsania Horatius",
    "Boadecia Tatusus",
    "Iulia Furius",
    "Laurenia Snedeceus",
    "Tamia Bestius",
    "Susia Betornaius",
    "Haedaea Manlius",
    "Andraea Mucarius",
    "Calpurnia Furtivus",
    "Valeria Caelius",
    "Servilia Antoninus",
    "Antonina Licinius",
    "Flaminia Calorius",
    "Horatia Cassius",
    "Aemilia Lupus",
    "Flavia Porcius",
    "Ovidia Licinius",
    "Antonia Curtius",
};
static char *tax_collector_names[FIGURE_MAX_NAME_LENGTH] = {
    "Titus Nervus",
    "Munlius Tacus",
    "Dracus Magnus",
    "Vampirus Sanguinarius",
    "Cognitius Pervulgatus",
    "Scientius Subtilius",
    "Brutus Levinius",
    "Austinius Parsonius",
    "Antonius Leieus",
    "Iulius Refundus Servius",
    "Cephalus Drosophilus",
    "Capitatus Muscus",
    "Canus Timidus",
    "Dolorius Capitus",
    "Illae Lacrimaeus",
    "Hominius Lupus",
    "Illigitimi Carborundum",
    "Dubius Agendum",
    "Lapsus Calamius",
    "Mendacum Memoreum",
    "Curiosus Malevolus",
    "Oderinus Metuanus",
    "Nimium Probatus",
    "Unus Multorum",
    "Variatus Delectus",
    "Impudensus Lenus",
    "Asclepius Asperulus",
    "Clonius Vlugarus",
    "Vitex Agnus-Castus",
    "Aesculus Glabrus",
    "Vampirus Sanguinarius",
    "Vampirus Sanguinarius",
};
static char *engineer_names[FIGURE_MAX_NAME_LENGTH] = {
    "Niallus Calagahanius",
    "Albertus Speierus",
    "Refector Defectus",
    "Henrius Cavendius",
    "Henrius Fordus",
    "Orvilius Rectus",
    "Vilburius Rectus",
    "Montgumuris Scottus",
    "Aesaec Neutonius",
    "Alvius Clarkus",
    "Alexus Tintinnabulus",
    "Tomas Edisonius",
    "Beniamus Gaulius",
    "Hanius Salumius",
    "Antonius Lirus",
    "Dicus Faenius",
    "Spidus Pipius",
    "Iosefus Calisetus",
    "Danius Grulus",
    "Laius Lirus",
    "Cathus Parus",
    "Alius Linaeus",
    "Eluis Iutnius",
    "Aralius Spinosus",
    "Solanus Carolinus",
    "Aristolus Vatsonius",
    "Erronius Humanus",
    "Ignoscius Divinius",
    "Factum Illus",
    "Fierius Infectus",
    "Refector Defectus",
    "Villius Gatesius",

};
static char *prefect_names[FIGURE_MAX_NAME_LENGTH] = {
    "Insurectus Prohibitus",
    "Tomus Rogerius",
    "Francus Lavoius",
    "Amicus Certus",
    "Petitus Placidus",
    "Famus Crescus",
    "Festinus Lentus",
    "Fiatus Justitius",
    "Roburus Securitus",
    "Melius Praevenius",
    "Furtum Facias",
    "Turbareus Circulus",
    "Semperius Paratus",
    "Vestigius Terrentius",
    "Guaiacus Angustifolius",
    "Plantagus Ovatas",
    "Euphatorius Purpurus",
    "Francius Serpicus",
    "Obscenus Hirsutus",
    "Vorfus Clingonius",
    "Aristolochus Vatsunus",
    "Rubus Idaeus",
    "Cistus Helianthemum",
    "Peganus Harmalus",
    "Acorus Calamus",
    "Rheus Curcumus",
    "Dicentrus Campsus",
    "Barnaeus Fifius",
    "Vivius Naevius",
    "Appius Sabucius",
    "Titus Norbanus",
    "Aulus Iulus",
};
static char *javelin_thrower_names[FIGURE_MAX_NAME_LENGTH] = {
    "Humungus Baculus",
    "Pilum Egerus",
    "Briaen Cunius",
    "Vindictus Bonus",
    "Defensor Fortus",
    "Saepeus Cadendus",
    "Medius Tutissimus",
    "Sanctus Simplicitus",
    "Pilum Volantus",
    "Tiberius Quintius",
    "Caius Messienus",
    "Spurius Vitruvius",
    "Decimus Tullius",
    "Sextus Fannius",
    "Domitius Amatius",
    "Marcus Herminius",
    "Flavus Cloatius",
    "Quintus Roscius",
    "Galerius Duilis",
    "Oppius Maebaerius",
    "Amulius Polus",
    "Gnaeus Vesuvius",
    "Numerius Sextilius",
    "Iulius Plautius",
    "Marcus Cominius",
    "Q. Flavus Macrinus",
    "Lucius Longus",
    "Cornelius Bruccius",
    "Africanus Carnifex",
    "Manius Popillius",
    "Asiaticus Norbanus",
    "Vibius Liburnius",
};
static char *mounted_auxiliary_names[FIGURE_MAX_NAME_LENGTH] = {
    "Milus Levus",
    "Gregorius Shepardius",
    "Consuetudinus Magnus",
    "Dictus Factus",
    "Horus Numerus",
    "Doletus Veretus",
    "Signus Vincus",
    "Magnus Voluisseus",
    "Furorus Brevus",
    "Lupus Fabulus",
    "Corporus Sanus",
    "Risus Praebuitus",
    "Cognitius Mortus",
    "Nullus Regulus",
    "Desideratus Pacemus",
    "Desideratus Bellus",
    "Praeparetus Bellus",
    "Semperus Fidelus",
    "Glorius Mundus",
    "Proprius Personus",
    "Porcus Agricolus",
    "Privatus Raienus",
    "Atticus Plotius",
    "Britannicus Modius",
    "Dalmaticus Fabricius",
    "Gallicus Galerius",
    "Germanicus Gargilius",
    "Helveticus Mummius",
    "Macedonius Rufus",
    "Numidicus Clovius",
    "Tacitus Tanicius",
    "Milus Levus",
};
static char *legionary_names[FIGURE_MAX_NAME_LENGTH] = {
    "Milus Onerosus",
    "Gomerius Pylaeus",
    "Longsuardius Picus",
    "Sergientus Iorcus",
    "Gaius Iolius",
    "Maiorus Glorius",
    "Omnius Vincitus",
    "Magnus Veritatus",
    "Ipsus Defendatus",
    "Nominus Odiosus",
    "Mortuus Timemus",
    "Nihilus Interitus",
    "Amulius Curtius",
    "Appius Drusus",
    "Aulus Flavillus",
    "Caius Porcerus",
    "Gaius Iulius Iosephus",
    "D. Iulus Fortunatus",
    "Domitius Poppaedius",
    "Flavus Flavinius",
    "G. Mallius Olympicus",
    "Galerius Iuventius",
    "Caius Corelius",
    "Gnaeus Minutius",
    "L. Roscius Florus",
    "Manius Norbanus",
    "M. Curius Dubitatus",
    "Numerius Pescennius",
    "Africanus Blandius",
    "Spartacus Epidius",
    "Vibius Otacilius",
    "Milus Onerosus",
};
static char *actor_names[FIGURE_MAX_NAME_LENGTH] = {
    "Tomus Hancus",
    "Bradlius Pittus",
    "Iacus Nicolsunius",
    "Dustinian Hofmanlius",
    "Patricus Stuartus",
    "Clintus Orientlignus",
    "Antonius Banderus",
    "Humfraeus Bogartus",
    "Robertus Rubervadus",
    "Gregorius Peccus",
    "Bellus Lugosus",
    "Borus Caerlofus",
    "Iamus Caerrus",
    "Robinus Vilaemus",
    "Silvestus Stalonius",
    "Maelus Gibsonius",
    "Allus Pacinus",
    "Burtus Renoldus",
    "Circus Duglus",
    "Paulus Novahomus",
    "Ianus Vaenus",
    "Gregorius Peccus",
    "Marlonius Brandonius",
    "Iamus Daeanus",
    "Antonius Hopcinius",
    "Ieremius Ironius",
    "Carletonus Hestonius",
    "Iamus Cagnius",
    "Iason Robardus",
    "Leonardius Decapresius",
    "Tomus Hancus",
    "Tomus Hancus",
};
static char *gladiator_names[FIGURE_MAX_NAME_LENGTH] = {
    "Enormus Gladius",
    "Spartacus",
    "Veritatus Venimus",
    "Colamus Humanitatus",
    "Saltatus Sobrius",
    "Omnius Mutantus",
    "Temporus Moreus",
    "Vibius Plinius",
    "Claudius Sacerdus",
    "T. Clovius Superbus",
    "Titus Quettius",
    "Tiberius Venidius",
    "Spurius Norbanus",
    "Sextus Trebatius",
    "Servius Servilius",
    "Q. Modius Leontius",
    "Publius Gratus",
    "P. Atius Rogatus",
    "Oppius Cluentius",
    "Numerius Naevius",
    "N. Curius Victorinus",
    "Marcus Maccius",
    "M. Duilis Romulus",
    "Manius Allectus",
    "Lucius Roscius",
    "L. Belaeus Ursus",
    "Lucius Herius",
    "Iulius Quinctilius",
    "Gnaeus Fundanus",
    "Gaius Nasennius",
    "G. Occius Tyrannus",
    "Enormus Gladius",
};
static char *lion_tamer_names[FIGURE_MAX_NAME_LENGTH] = {
    "Leo Perdomus",
    "Antonius Leieus",
    "Sigfraedus Roius",
    "Alvinius Boceriae",
    "Riccus Larsus",
    "Artesius Machentius",
    "Amulius Justus",
    "Appius Lepidus",
    "A. Valgus Leontius",
    "Aulus Labienus",
    "Caius Gabinius",
    "C. Didius Herculius",
    "Cnaeus Maecilius",
    "Decimus Equitius",
    "D. Mordanticus",
    "Leo Perdomus",
};
static char *charioteer_names[FIGURE_MAX_NAME_LENGTH] = {
    "Tomus Rogerus",
    "Auriga Celerus",
    "Denrus Canalae",
    "Erisus Nystromus",
    "Grandus Livius",
    "Alvus Mihanus",
    "Duanius Nedovius",
    "Timius Filippius",
    "Cedrus Eganus",
    "Ecclesius Salus",
    "Veritus Odius",
    "Proximus Egometus",
    "Patientius Nostrus",
    "Publius Nigilius",
    "Titus Sacerdus",
    "T. Fadius Hilarius",
};
static char *barbarian_names[FIGURE_MAX_NAME_LENGTH] = {
    "Erik the Nervous",
    "Dyffyd the Lesser",
    "Iron Rod Wielder",
    "Grudgebringer",
    "Simon Goatherder",
    "Stephen the Cruel",
    "Howard the Stern",
    "Blackbeard",
    "Night Crawler",
    "Hercules the Strong",
    "Simo the Dark",
    "Red Harvest",
    "Longbeard",
    "Kenneth the Uncaring",
    "The Master",
    "Jon Paingiver",
    "Loren Yellowhair",
    "Balkoth of Urak",
    "Dennis the Elder",
    "Dreamstalker",
    "Bloodstone",
    "Edward the Loud",
    "Chief Firebringer",
    "Wayne of Caul",
    "Dragontamer",
    "Douglas of Gon",
    "Gregory Sheepherd",
    "Strongarm",
    "Braveheart",
    "Klyfyx the Mysterious",
    "Humphrey the Timid",
    "Lancer XXVII",
};
static char *greek_names[FIGURE_MAX_NAME_LENGTH] = {
    "Tarkon Alexandros",
    "Thales Xanthippos",
    "Krios Kleisthenes",
    "Menippos Aristophenes",
    "Magnos Leonidas",
    "Stefanos Orestes",
    "Kallistos Solon",
    "Hektor Xenophenes",
    "Demetrios Theocrytos",
    "Amygdylos Lysias",
    "Kleon Leonidas",
    "Krystos Alexandros",
    "Herakles Kleisthenes",
    "Solon Orestes",
    "Alanon Xarenes",
    "Colostome Hipparkos",
    "Souvlaki Gyro",
    "Tarkon Alexandros",
    "Thales Xanthippos",
    "Krios Kleisthenes",
    "Menippos Aristophenes",
    "Magnos Leonidas",
    "Stefanos Orestes",
    "Kallistos Solon",
    "Hektor Xenophenes",
    "Demetrios Theocrytos",
    "Amygdylos Lysias",
    "Kleon Leonidas",
    "Krystos Alexandros",
    "Herakles Kleisthenes",
    "Solon Orestes",
    "Alanon Xarenes",
};
static char *egyptian_names[FIGURE_MAX_NAME_LENGTH] = {
    "Thutmose",
    "Nebmaat-Nebet",
    "Ramesses Hatshepsut",
    "Thoth Sithathor",
    "Baast Horemheb",
    "Set Meritaten",
    "Hyapatia Amenhotep",
    "Ankhtut Sithathor",
    "Sekhmet",
    "Horus Atensuthor",
    "Amun-Ra",
    "Maat-Nebmaat",
    "Hathor",
    "Thutmose",
    "Nebmaat-Nebet",
    "Ramesses Hatshepsut",
    "Thoth Sithathor",
    "Baast Horemheb",
    "Set Meritaten",
    "Hyapatia Amenhotep",
    "Ankhtut Sithathor",
    "Sekhmet",
    "Horus Atensuthor",
    "Amun-Ra",
    "Maat-Nebmaat",
    "Hathor",
    "Thutmose",
    "Nebmaat-Nebet",
    "Ramesses Hatshepsut",
    "Thoth Sithathor",
    "Baast Horemheb",
    "Set Meritaten",
};
static char *arabic_names[FIGURE_MAX_NAME_LENGTH] = {
    "Mustafa",
    "Mirjam",
    "Yusef",
    "Bashim",
    "Ishtar",
    "Ahkmed",
    "Marmaduk",
    "Mustafa",
    "Hassan",
    "Saddam",
    "Muammar",
    "Muhammed",
    "Khadaffi",
    "Saud",
    "Yassir",
    "Nasser",
    "Salman",
    "Suliman",
    "Ali Baba",
    "Bashim",
    "Ishtar",
    "Ahkmed",
    "Marmaduk",
    "Mustafa",
    "Hassan",
    "Mustafa",
    "Ali Baba",
    "Suliman",
    "Yassir",
    "Saud",
    "Yusif",
    "Bashim",
};
static char *trade_caravan_names[FIGURE_MAX_NAME_LENGTH] = {
    "Mercator Opulentus",
    "Serius Roebuccius",
    "Iordanus Marshius",
    "Crazius Eddius",
    "Daetunus Hudsonius",
    "Erneae Bacchus",
    "Vall of Mart",
    "Cae of Mart",
    "Caldorius the Cheap",
    "Bertuccius",
    "E.B. Babbagius",
    "Refundus Recetius",
    "Commercius Auctius",
    "Vendus Garrulus",
    "J.C. Penneae",
    "Mercator Opulentus",
};
static char *trade_ship_names[FIGURE_MAX_NAME_LENGTH] = {
    "Enterprise",
    "Argo Mercator",
    "Titanicus",
    "Bismarcus",
    "Lusitanius",
    "Endeavor",
    "Atlantus",
    "Drusilla Secunda",
    "Aster Livia",
    "Mercury",
    "Julia Primitiva",
    "Tridens Scientia",
    "Navigare Necesse",
    "Mecum Porto",
    "Pacta Servanda",
    "Pisces Oportet",
};
static char *legion_names[MAX_LEGIONS] = {
"Prima Legion",
"The Rabbits",
"The Snakes",
"The Fish",
"The Stallions",
"The Wolves",
};
static char *legion_morale_strings[32] = {
    "Totally distraught",
    "Terrified",
    "Extremely scared",
    "Very frightened",
    "Frightened",
    "Badly shaken",
    "Shaken",
    "Poor",
    "Quite poor",
    "Below average",
    "Average",
    "Above average",
    "Encouraged",
    "Quite daring",
    "Daring",
    "Bold",
    "Very Bold",
    "Strong",
    "Extremely strong",
    "Excellent",
    "Perfect",
};
// end chars

// start structs
struct mouse_button_t {
    int is_down; /**< mouse button is down */
    int went_down; /**< mouse button went down during this cycle */
    int went_up; /**< mouse button went up during this cycle */
    int double_click; /**< mouse double clicked during this cycle */
    int system_change;
};

struct mouse_t {
    int x; /**< Global position X */
    int y; /**< Global position Y */
    int scrolled; /**< Scroll state (up/down/none) */
    struct mouse_button_t left; /**< Left mouse button */
    struct mouse_button_t right; /**< Right mouse button */
    int is_inside_window; /**< Whether the mouse is in the window */
};
static struct mouse_t mouse_data;

struct formation_t {
    int id;
    uint8_t in_use;
    uint8_t layout;
    uint8_t figure_type;
    uint8_t num_figures;
    uint8_t max_figures;
    uint16_t figures[MAX_FORMATION_FIGURES];
    uint8_t has_military_training;
    uint8_t is_at_rest;
    uint8_t deployed_duration_months;
    uint8_t direction;
    uint8_t morale;
    uint8_t max_morale;
    uint8_t routed;
    int16_t wait_ticks_movement;
    uint16_t standard_x;
    uint16_t standard_y;
    uint16_t prev_standard_x;
    uint16_t prev_standard_y;
    uint16_t legion_standard__figure_id;
    uint16_t building_id;
    uint8_t empire_service;
    uint8_t in_distant_battle;
    uint8_t cursed_by_mars;
    uint8_t recent_fight;
    uint8_t missile_attack_timeout;
    uint16_t destination_x;
    uint16_t destination_y;
    uint16_t wolf_spawn_delay;
    uint8_t attack_priority;
};
static struct formation_t enemy_formations[MAX_ENEMY_FORMATIONS];
static struct formation_t herd_formations[MAX_HERD_POINTS];
static struct formation_t legion_formations[MAX_LEGIONS];

struct map_point_t {
    int x;
    int y;
};
static struct map_point_t bookmarks[MAX_BOOKMARKS];
static struct map_point_t CLOUD_DIRECTION[] = {
    {0, -6}, {-2, -5}, {-4, -4}, {-5, -2}, {-6, 0}, {-5, -2}, {-4, -4}, {-2, -5},
    {0, -6}, {-2, -5}, {-4, -4}, {-5, -2}, {-6, 0}, {-5, -2}, {-4, -4}, {-2, -5}
};
static struct map_point_t HORSE_DESTINATION_1[] = {
    {2, 1}, {3, 1}, {4, 1}, {5, 1}, {6, 1}, {7, 1}, {8, 1}, {9, 1}, {10, 1}, {11, 1}, {12, 2},
    {12, 3}, {11, 3}, {10, 3}, {9, 3}, {8, 3}, {7, 3}, {6, 3}, {5, 3}, {4, 3}, {3, 3}, {2, 2}
};
static struct map_point_t HORSE_DESTINATION_2[] = {
    {12, 3}, {11, 3}, {10, 3}, {9, 3}, {8, 3}, {7, 3}, {6, 3}, {5, 3}, {4, 3}, {3, 3}, {2, 2},
    {2, 1}, {3, 1}, {4, 1}, {5, 1}, {6, 1}, {7, 1}, {8, 1}, {9, 1}, {10, 1}, {11, 1}, {12, 2}
};

struct map_tile_t {
    int x;
    int y;
    int grid_offset;
};
static struct map_tile_t current_tile;

struct building_t {
    int id;
    unsigned char state;
    unsigned char size;
    unsigned char house_is_merged;
    unsigned char house_size;
    unsigned char x;
    unsigned char y;
    short grid_offset;
    short type;
    union {
        short house_level;
        short warehouse_resource_id;
        short workshop_type;
        short orientation;
        short fort_figure_type;
        short native_meeting_center_id;
    } subtype;
    unsigned short created_sequence;
    short houses_covered;
    short percentage_houses_covered;
    short house_population;
    short house_population_room;
    short house_highest_population;
    unsigned char road_access_x;
    unsigned char road_access_y;
    short figure_id;
    short figure_id2; // labor seeker or market buyer
    short immigrant_figure_id;
    short figure_id4; // tower ballista or burning ruin prefect
    unsigned char figure_spawn_delay;
    unsigned char figure_roam_direction;
    unsigned char has_water_access;
    short prev_part_building_id;
    short next_part_building_id;
    short loads_stored;
    unsigned char has_well_access;
    short num_workers;
    int8_t labor_category;
    unsigned char output_resource_id;
    unsigned char has_road_access;
    unsigned char house_criminal_active;
    short damage_risk;
    short fire_risk;
    short fire_duration;
    unsigned char fire_proof; // cannot catch fire or collapse
    unsigned char house_figure_generation_delay;
    unsigned char house_tax_coverage;
    short formation_id;
    union {
        struct {
            short queued_docker_id;
            unsigned char num_ships;
            signed char orientation;
            short docker_ids[3];
            short trade_ship_id;
        } dock;
        struct {
            short inventory[8];
            short pottery_demand;
            short furniture_demand;
            short oil_demand;
            short wine_demand;
            unsigned char fetch_inventory_id;
        } market;
        struct {
            short resource_stored[16];
        } granary;
        struct {
            short progress;
            unsigned char blessing_days_left;
            unsigned char curse_days_left;
            unsigned char has_raw_materials;
            unsigned char has_fish;
            unsigned char orientation;
            short fishing_boat_id;
        } industry;
        struct {
            unsigned char num_shows;
            unsigned char days1;
            unsigned char days2;
            unsigned char play;
        } entertainment;
        struct {
            short inventory[8];
            unsigned char theater;
            unsigned char amphitheater_actor;
            unsigned char amphitheater_gladiator;
            unsigned char colosseum_gladiator;
            unsigned char colosseum_lion;
            unsigned char hippodrome;
            unsigned char school;
            unsigned char library;
            unsigned char academy;
            unsigned char barber;
            unsigned char clinic;
            unsigned char bathhouse;
            unsigned char hospital;
            unsigned char temple_ceres;
            unsigned char temple_neptune;
            unsigned char temple_mercury;
            unsigned char temple_mars;
            unsigned char temple_venus;
            unsigned char no_space_to_expand;
            unsigned char num_foods;
            unsigned char entertainment;
            unsigned char education;
            unsigned char health;
            unsigned char num_gods;
            unsigned char devolve_delay;
            unsigned char evolve_text_id;
        } house;
    } data;
    int tax_income_or_storage;
    unsigned char house_days_without_food;
    unsigned char ruin_has_plague;
    signed char desirability;
    unsigned char is_deleted;
    unsigned char storage_id;
    union {
        signed char house_happiness;
        signed char native_anger;
    } sentiment;
    unsigned char show_on_problem_overlay;
};
static struct building_t all_buildings[MAX_BUILDINGS];

struct building_properties_t {
    uint8_t size;
    uint8_t fire_proof;
    int img_id;
    uint16_t cost;
    int8_t desirability_value;
    uint8_t desirability_step;
    int8_t desirability_step_size;
    uint8_t desirability_range;
    uint8_t n_laborers;
    int8_t labor_category;
    uint8_t sound_channel;
};
struct building_properties_t building_properties[BUILDING_TYPE_MAX] = {
    // size | fireprf | img_id | cost | des_value | des_step | des_step_siz | des_range | n_lbrs | lbr_cat | snd_ch
    {  0,     0,         0,       0,     0,          0,         0,             0,          0,      -1,        0}, // BUILDING_NONE
    {  1,     0,       2823,      10,    0,          0,         0,             0,          0,      -1,        1}, // BUILDING_HOUSE_VACANT_LOT
    {  1,     0,       2779,      0,    -3,          1,         1,             3,          0,      -1,        2}, // BUILDING_HOUSE_SMALL_TENT
    {  1,     0,       2781,      0,    -3,          1,         1,             3,          0,      -1,        2}, // BUILDING_HOUSE_LARGE_TENT
    {  1,     0,       2785,      0,    -2,          1,         1,             2,          0,      -1,        2}, // BUILDING_HOUSE_SMALL_SHACK
    {  1,     0,       2787,      0,    -2,          1,         1,             2,          0,      -1,        2}, // BUILDING_HOUSE_LARGE_SHACK
    {  1,     0,       2791,      0,    -2,          1,         1,             2,          0,      -1,        2}, // BUILDING_HOUSE_SMALL_HOVEL
    {  1,     0,       2793,      0,    -2,          1,         1,             2,          0,      -1,        2}, // BUILDING_HOUSE_LARGE_HOVEL
    {  1,     0,       2797,      0,    -1,          1,         1,             1,          0,      -1,        3}, // BUILDING_HOUSE_SMALL_CASA
    {  1,     0,       2799,      0,    -1,          1,         1,             1,          0,      -1,        3}, // BUILDING_HOUSE_LARGE_CASA
    {  1,     0,       2803,      0,     0,          1,         1,             1,          0,      -1,        3}, // BUILDING_HOUSE_SMALL_INSULA
    {  1,     0,       2805,      0,     0,          1,         1,             1,          0,      -1,        3}, // BUILDING_HOUSE_MEDIUM_INSULA
    {  2,     0,       2809,      0,     0,          0,         0,             0,          0,      -1,        4}, // BUILDING_HOUSE_LARGE_INSULA
    {  2,     0,       2811,      0,     0,          0,         0,             0,          0,      -1,        4}, // BUILDING_HOUSE_GRAND_INSULA
    {  2,     0,       2813,      0,     1,          2,        -1,             2,          0,      -1,        4}, // BUILDING_HOUSE_SMALL_VILLA
    {  2,     0,       2815,      0,     1,          2,        -1,             2,          0,      -1,        4}, // BUILDING_HOUSE_MEDIUM_VILLA
    {  3,     0,       2817,      0,     2,          2,        -2,             2,          0,      -1,        5}, // BUILDING_HOUSE_LARGE_VILLA
    {  3,     0,       2818,      0,     2,          2,        -2,             2,          0,      -1,        5}, // BUILDING_HOUSE_GRAND_VILLA
    {  3,     0,       2819,      0,     3,          2,        -1,             6,          0,      -1,        5}, // BUILDING_HOUSE_SMALL_PALACE
    {  3,     0,       2820,      0,     3,          2,        -1,             6,          0,      -1,        5}, // BUILDING_HOUSE_MEDIUM_PALACE
    {  4,     0,       2821,      0,     4,          2,        -1,             6,          0,      -1,        6}, // BUILDING_HOUSE_LARGE_PALACE
    {  4,     0,       2822,      0,     4,          2,        -1,             6,          0,      -1,        6}, // BUILDING_HOUSE_LUXURY_PALACE
    {  0,     0,         0,       2,     0,          0,         0,             0,          0,      -1,        0}, // BUILDING_CLEAR_LAND
    {  1,     0,        591,      4,     0,          0,         0,             0,          0,      -1,        0}, // BUILDING_ROAD
    {  3,     1,       2863,      80,   -6,          1,         2,             3,          0,      -1,        8}, // BUILDING_RESERVOIR
    {  1,     0,        666,      8,    -2,          1,         1,             2,          0,      -1,        9}, // BUILDING_AQUEDUCT
    {  1,     1,       2839,      15,    0,          0,         0,             0,          4,       3,        10}, // BUILDING_FOUNTAIN
    {  1,     1,       2830,      5,     0,          0,         0,             0,          0,      -1,        11}, // BUILDING_WELL
    {  1,     0,       3184,      30,    0,          0,         0,             0,          5,       7,        14}, // BUILDING_DOCTOR
    {  2,     0,       3196,      50,    4,          1,        -1,             4,          10,      7,        13}, // BUILDING_BATHHOUSE
    {  1,     0,       3183,      25,    2,          1,        -1,             2,          2,       7,        12}, // BUILDING_BARBER
    {  3,     0,       3208,      300,  -1,          2,         1,             2,          30,      7,        15}, // BUILDING_HOSPITAL
    {  2,     0,       3209,      50,    4,          2,        -1,             6,          2,       8,        16}, // BUILDING_SMALL_TEMPLE_CERES
    {  2,     0,       3211,      50,    4,          2,        -1,             6,          2,       8,        17}, // BUILDING_SMALL_TEMPLE_NEPTUNE
    {  2,     0,       3213,      50,    4,          2,        -1,             6,          2,       8,        18}, // BUILDING_SMALL_TEMPLE_MERCURY
    {  2,     0,       3215,      50,    4,          2,        -1,             6,          2,       8,        19}, // BUILDING_SMALL_TEMPLE_MARS
    {  2,     0,       3217,      50,    4,          2,        -1,             6,          2,       8,        20}, // BUILDING_SMALL_TEMPLE_VENUS
    {  3,     0,       3210,      150,   8,          2,        -1,             8,          5,       8,        16}, // BUILDING_LARGE_TEMPLE_CERES
    {  3,     0,       3212,      150,   8,          2,        -1,             8,          5,       8,        17}, // BUILDING_LARGE_TEMPLE_NEPTUNE
    {  3,     0,       3214,      150,   8,          2,        -1,             8,          5,       8,        18}, // BUILDING_LARGE_TEMPLE_MERCURY
    {  3,     0,       3216,      150,   8,          2,        -1,             8,          5,       8,        19}, // BUILDING_LARGE_TEMPLE_MARS
    {  3,     0,       3218,      150,   8,          2,        -1,             8,          5,       8,        20}, // BUILDING_LARGE_TEMPLE_VENUS
    {  2,     0,       3219,      200,   8,          2,        -1,             6,          0,       8,        21}, // BUILDING_ORACLE
    {  2,     0,       2954,      50,   -2,          1,         1,             2,          10,      7,        22}, // BUILDING_SCHOOL
    {  2,     0,       2955,      75,    4,          1,        -1,             4,          20,      7,        24}, // BUILDING_LIBRARY
    {  3,     0,       2956,      100,   4,          1,         1,             4,          30,      7,        23}, // BUILDING_ACADEMY
    {  2,     1,       3318,      100,  -3,          1,         1,             2,          20,      7,        0}, // BUILDING_MISSION_POST
    {  2,     0,       3051,      50,    2,          1,        -1,             2,          8,       6,        25}, // BUILDING_THEATER
    {  3,     0,       3119,      50,    2,          1,        -1,             2,          5,       6,        31}, // BUILDING_ACTOR_COLONY
    {  3,     0,       3039,      100,   4,          1,        -1,             4,          12,      6,        26}, // BUILDING_AMPHITHEATER
    {  3,     0,       3089,      75,   -3,          1,         1,             3,          8,       6,        29}, // BUILDING_GLADIATOR_SCHOOL
    {  3,     0,       3100,      75,   -3,          1,         1,             3,          8,       6,        30}, // BUILDING_LION_HOUSE
    {  5,     0,       3074,      500,  -3,          1,         1,             3,          25,      6,        27}, // BUILDING_COLOSSEUM
    {  3,     0,       3129,      75,   -3,          1,         1,             3,          8,       6,        32}, // BUILDING_CHARIOT_MAKER
    {  5,     0,       7780,      2500, -3,          1,         1,             3,          150,     6,        28}, // BUILDING_HIPPODROME
    {  1,     1,       3148,      12,    3,          1,        -1,             3,          0,      -1,        37}, // BUILDING_GARDENS
    {  1,     1,       3140,      15,    4,          1,        -2,             2,          0,      -1,        0}, // BUILDING_PLAZA
    {  1,     1,       3155,      12,    3,          1,        -1,             3,          0,      -1,        36}, // BUILDING_SMALL_STATUE
    {  2,     1,       3156,      60,    10,         1,        -2,             4,          0,      -1,        36}, // BUILDING_MEDIUM_STATUE
    {  3,     1,       3157,      150,   14,         2,        -2,             5,          0,      -1,        36}, // BUILDING_LARGE_STATUE
    {  3,     0,       2824,      150,   12,         2,        -2,             3,          0,      -1,        35}, // BUILDING_GOVERNORS_HOUSE
    {  4,     0,       2825,      400,   20,         2,        -3,             4,          0,      -1,        35}, // BUILDING_GOVERNORS_VILLA
    {  5,     0,       2826,      700,   28,         2,        -4,             5,          0,      -1,        35}, // BUILDING_GOVERNORS_PALACE
    {  2,     0,       3164,      75,    3,          2,        -1,             2,          6,       8,        33}, // BUILDING_FORUM
    {  5,     0,       3158,      400,   14,         2,        -1,             8,          30,      8,        34}, // BUILDING_SENATE
    {  3,     1,        821,      0,     18,         2,         3,             5,          0,      -1,        0}, // BUILDING_TRIUMPHAL_ARCH
    {  1,     1,       3281,      30,    0,          1,         1,             1,          5,       2,        0}, // BUILDING_ENGINEERS_POST
    {  1,     1,         0,       40,    0,          0,         0,             0,          0,      -1,        0}, // BUILDING_LOW_BRIDGE
    {  1,     1,         0,       100,   0,          0,         0,             0,          0,      -1,        0}, // BUILDING_SHIP_BRIDGE
    {  2,     0,       3226,      100,  -8,          2,         2,             3,          10,      0,        38}, // BUILDING_SHIPYARD
    {  2,     0,       3277,      60,   -8,          2,         2,             3,          6,       0,        40}, // BUILDING_WHARF
    {  3,     0,       3230,      100,  -8,          2,         2,             3,          12,      0,        39}, // BUILDING_DOCK
    {  1,     0,       3165,      30,   -2,          1,         1,             2,          6,       4,        0}, // BUILDING_PREFECTURE
    {  1,     0,        725,      12,    0,          0,         0,             0,          0,      -1,        0}, // BUILDING_WALL
    {  2,     1,        696,      150,  -8,          1,         2,             3,          6,       5,        41}, // BUILDING_TOWER
    {  2,     1,        697,      100,  -4,          1,         1,             3,          0,       5,        0}, // BUILDING_GATEHOUSE
    {  3,     1,       3176,      1000, -20,         2,         2,             8,          0,      -1,        0}, // BUILDING_FORT_LEGIONARIES
    {  3,     1,       3176,      1000, -20,         2,         2,             8,          0,      -1,        0}, // BUILDING_FORT_JAVELIN
    {  3,     1,       3176,      1000, -20,         2,         2,             8,          0,      -1,        0}, // BUILDING_FORT_MOUNTED
    {  3,     0,       3181,      150,  -6,          1,         1,             3,          10,      5,        44}, // BUILDING_BARRACKS
    {  3,     0,       3182,      1000, -3,          1,         1,             3,          20,      5,        43}, // BUILDING_MILITARY_ACADEMY
    {  3,     0,       2883,      40,   -2,          1,         1,             2,          10,      1,        45}, // BUILDING_WHEAT_FARM
    {  3,     0,       2883,      40,   -2,          1,         1,             2,          10,      1,        46}, // BUILDING_VEGETABLE_FARM
    {  3,     0,       2883,      40,   -2,          1,         1,             2,          10,      1,        47}, // BUILDING_FRUIT_FARM
    {  3,     0,       2883,      40,   -2,          1,         1,             2,          10,      1,        50}, // BUILDING_PIG_FARM
    {  3,     0,       2883,      40,   -2,          1,         1,             2,          10,      0,        48}, // BUILDING_OLIVE_FARM
    {  3,     0,       2883,      40,   -2,          1,         1,             2,          10,      0,        49}, // BUILDING_VINES_FARM
    {  2,     0,       2932,      40,   -3,          1,         1,             3,          10,      0,        51}, // BUILDING_CLAY_PIT
    {  2,     0,       2943,      40,   -4,          1,         1,             3,          10,      0,        54}, // BUILDING_TIMBER_YARD
    {  2,     0,       2914,      50,   -6,          1,         1,             4,          10,      0,        52}, // BUILDING_MARBLE_QUARRY
    {  2,     0,       2925,      50,   -6,          1,         1,             4,          10,      0,        53}, // BUILDING_IRON_MINE
    {  2,     0,       2970,      50,   -4,          1,         1,             2,          10,      0,        56}, // BUILDING_OIL_WORKSHOP
    {  2,     0,       2957,      45,   -1,          1,         1,             1,          10,      0,        55}, // BUILDING_WINE_WORKSHOP
    {  2,     0,       3003,      40,   -4,          1,         1,             2,          10,      0,        59}, // BUILDING_POTTERY_WORKSHOP
    {  2,     0,       2988,      40,   -4,          1,         1,             2,          10,      0,        58}, // BUILDING_FURNITURE_WORKSHOP
    {  2,     0,       2979,      50,   -4,          1,         1,             2,          10,      0,        57}, // BUILDING_WEAPONS_WORKSHOP
    {  2,     0,       2872,      40,   -2,          1,         1,             6,          5,       0,        60}, // BUILDING_MARKET
    {  3,     0,       3011,      100,  -4,          1,         2,             2,          6,       1,        61}, // BUILDING_GRANARY
    {  1,     1,       3319,      70,   -5,          2,         2,             3,          6,       0,        62}, // BUILDING_WAREHOUSE
    {  1,     1,       3319,      0,     0,          0,         0,             0,          0,      -1,        0}, // BUILDING_WAREHOUSE_SPACE
    {  1,     1,       2827,      50,    0,          0,         0,             0,          0,      -1,        0}, // BUILDING_NATIVE_HUT
    {  1,     1,       2884,      0,     0,          0,         0,             0,          0,      -1,        0}, // BUILDING_NATIVE_CROPS
    {  2,     1,       2829,      50,    0,          0,         0,             0,          0,      -1,        0}, // BUILDING_NATIVE_MEETING
    {  4,     1,       3177,      0,     0,          0,         0,             0,          0,      -1,        0}, // BUILDING_FORT_GROUND
    {  1,     1,         0,       0,    -1,          1,         1,             2,          0,      -1,        63}, // BUILDING_BURNING_RUIN
};

struct house_properties_t {
    int8_t devolve_desirability; /**< Desirability at which the house devolves */
    int8_t evolve_desirability; /**< Desirability at which the house evolves */
    uint8_t entertainment; /**< Entertainment points required */
    uint8_t water; /**< Water required: 1 = well, 2 = fountain */
    uint8_t religion; /**< Number of gods required */
    uint8_t education; /**< Education required: 1 = school or library, 2 = school and library, 3 = school, library and academy */
    uint8_t barber; /**< Barber required (boolean) */
    uint8_t bathhouse; /**< Bathhouse required (boolean) */
    uint8_t health; /**< Health required: 1 = doctor or hospital, 2 = doctor and hospital */
    uint8_t food_types; /**< Number of food types required */
    uint8_t pottery; /**< Pottery required */
    uint8_t oil; /**< Oil required */
    uint8_t furniture; /**< Furniture required */
    uint8_t wine; /**< Wine types required: 1 = any wine, 2 = two types of wine */
    uint16_t prosperity; /**< Prosperity contribution */
    uint8_t max_people; /**< Maximum people per tile (medium insula and lower) or per house (large insula and up) */
    uint8_t tax_multiplier; /**< Tax rate multiplier */
};
struct house_properties_t house_properties[MAX_HOUSE_TYPES] = {
    // dev_des | ev_des | ent | water | relg | edu | barb | bath | health | food | pott | oil | furn | wine | prosp | max_ppl | tax_mult
    { -99,      -10,      0,    0,      0,     0,    0,     0,       0,     0,     0,    0,     0,     0,     5,      5,        1},
    { -12,      -5,       0,    1,      0,     0,    0,     0,       0,     0,     0,    0,     0,     0,     10,     7,        1},
    { -7,        0,       0,    1,      0,     0,    0,     0,       0,     1,     0,    0,     0,     0,     15,     9,        1},
    { -2,        4,       0,    1,      1,     0,    0,     0,       0,     1,     0,    0,     0,     0,     20,     11,       1},
    {  2,        8,       0,    2,      1,     0,    0,     0,       0,     1,     0,    0,     0,     0,     25,     13,       2},
    {  6,        12,      10,   2,      1,     0,    0,     0,       0,     1,     0,    0,     0,     0,     30,     15,       2},
    { 10,        16,      10,   2,      1,     1,    0,     0,       0,     1,     0,    0,     0,     0,     35,     17,       2},
    { 14,        20,      10,   2,      1,     1,    0,     1,       0,     1,     1,    0,     0,     0,     45,     19,       2},
    { 18,        25,      25,   2,      1,     1,    0,     1,       0,     1,     1,    0,     0,     0,     50,     19,       3},
    { 22,        32,      25,   2,      1,     1,    0,     1,       1,     1,     1,    0,     1,     0,     58,     20,       3},
    { 29,        40,      25,   2,      1,     2,    1,     1,       1,     1,     1,    1,     1,     0,     65,     84,       3},
    { 37,        48,      35,   2,      1,     2,    1,     1,       1,     2,     1,    1,     1,     0,     80,     84,       4},
    { 45,        53,      35,   2,      2,     2,    1,     1,       1,     2,     1,    1,     1,     1,     150,    40,       9},
    { 50,        58,      40,   2,      2,     2,    1,     1,       2,     2,     1,    1,     1,     1,     180,    42,       10},
    { 55,        63,      45,   2,      2,     3,    1,     1,       2,     2,     1,    1,     1,     1,     400,    90,       11},
    { 60,        68,      50,   2,      3,     3,    1,     1,       2,     3,     1,    1,     1,     1,     600,    100,      11},
    { 65,        74,      55,   2,      3,     3,    1,     1,       2,     3,     1,    1,     1,     2,     700,    106,      12},
    { 70,        80,      60,   2,      4,     3,    1,     1,       2,     3,     1,    1,     1,     2,     900,    112,      12},
    { 76,        90,      70,   2,      4,     3,    1,     1,       2,     3,     1,    1,     1,     2,     1500,   190,      15},
    { 85,        100,     80,   2,      4,     3,    1,     1,       2,     3,     1,    1,     1,     2,     1750,   200,      16},
};

struct building_storage_t {
    int empty_all;
    int resource_state[RESOURCE_TYPES_MAX];
};

struct emperor_gift_t {
    int id;
    int cost;
};

struct god_status_t {
    int8_t happiness;
    int8_t target_happiness;
    int8_t wrath_bolts;
    int8_t blessing_done;
    int8_t small_curse_done;
    int32_t months_since_festival;
};

struct finance_overview_t {
    struct {
        int taxes;
        int exports;
        int donated;
        int total;
    } income;
    struct {
        int imports;
        int wages;
        int construction;
        int interest;
        int salary;
        int sundries;
        int tribute;
        int total;
    } expenses;
    int net_in_out;
    int balance;
};

struct house_demands_t {
    struct {
        int well;
        int fountain;
        int entertainment;
        int more_entertainment;
        int education;
        int more_education;
        int religion;
        int second_religion;
        int third_religion;
        int barber;
        int bathhouse;
        int clinic;
        int hospital;
        int food;
        int second_wine;
    } missing;
    struct {
        int school;
        int library;
        int barber;
        int bathhouse;
        int clinic;
        int religion;
    } requiring;
    int health;
    int religion;
    int education;
    int entertainment;
};

struct labor_category_data_t {
    int workers_needed;
    int workers_allocated;
    int buildings;
    int priority;
    int total_houses_covered;
};

struct city_message_t {
    int sequence;
    int message_type;
    int year;
    int month;
    int param1;
    int param2;
    int is_read;
};

struct pixel_view_coordinates_t {
    int x;
    int y;
};

struct city_data_t {
    struct {
        int16_t senate_placed;
        uint8_t senate_x;
        uint8_t senate_y;
        int16_t senate_grid_offset;
        int32_t senate_building_id;
        int32_t hippodrome_placed;
        int8_t barracks_x;
        int8_t barracks_y;
        int16_t barracks_grid_offset;
        int32_t barracks_building_id;
        int32_t barracks_placed;
        int32_t trade_center_building_id;
        int8_t triumphal_arches_available;
        int16_t working_wharfs;
        int32_t shipyard_boats_requested;
        int16_t working_docks;
        int16_t working_dock_ids[10];
        int32_t mission_post_operational;
        struct map_point_t main_native_meeting;
    } building;
    struct {
        int16_t animals;
        int32_t enemies;
        int32_t imperial_soldiers;
        int32_t rioters;
        int32_t soldiers;
    } figure;
    struct house_demands_t houses;
    struct {
        struct emperor_gift_t gifts[3];
        int32_t months_since_gift;
        int32_t gift_overdose_penalty;

        int32_t debt_state;
        int32_t months_in_debt;

        int32_t player_rank;
        int32_t salary_rank;
        int32_t salary_amount;
        int32_t donate_amount;
        int32_t personal_savings;
        struct {
            int32_t count;
            int32_t size;
            int32_t soldiers_killed;
            int32_t warnings_given;
            int32_t days_until_invasion;
            int32_t duration_day_countdown;
            int32_t retreat_message_shown;
            int16_t from_editor;
        } invasion;
    } emperor;
    struct {
        uint8_t total_legions;
        int32_t legionary_legions;
        int32_t native_attack_duration;
    } military;
    struct {
        uint8_t city;
        int8_t city_foreign_months_left;
        int8_t total_count;
        int8_t won_count;
        uint8_t enemy_strength;
        uint8_t roman_strength;
        int8_t months_until_battle;
        int8_t roman_months_to_travel_forth;
        int8_t roman_months_to_travel_back;
        int8_t enemy_months_traveled;
        int8_t roman_months_traveled;
    } distant_battle;
    struct {
        int32_t treasury;
        int32_t tax_percentage;
        int32_t estimated_tax_income;
        int32_t estimated_wages;
        struct finance_overview_t last_year;
        struct finance_overview_t this_year;
        int32_t interest_so_far;
        int32_t salary_so_far;
        int32_t wages_so_far;
        int16_t stolen_this_year;
        int16_t stolen_last_year;
        int32_t cheated_money;
        int32_t tribute_not_paid_last_year;
        int32_t tribute_not_paid_total_years;
        int32_t wage_rate_paid_this_year;
        int32_t wage_rate_paid_last_year;
    } finance;
    struct {
        int32_t taxed_plebs;
        int32_t taxed_patricians;
        int32_t untaxed_plebs;
        int32_t untaxed_patricians;
        int32_t percentage_taxed_plebs;
        int32_t percentage_taxed_patricians;
        int32_t percentage_taxed_people;
        struct {
            int32_t collected_plebs;
            int32_t collected_patricians;
            int32_t uncollected_plebs;
            int32_t uncollected_patricians;
        } yearly;
        struct {
            int32_t collected_plebs;
            int32_t collected_patricians;
            int32_t uncollected_plebs;
            int32_t uncollected_patricians;
        } monthly;
    } taxes;
    struct {
        int32_t population;
        int32_t population_last_year;
        int32_t school_age;
        int32_t academy_age;
        int32_t working_age;
        struct {
            int32_t values[2400];
            int32_t next_index;
            int32_t count;
        } monthly;
        int16_t at_age[100];
        int32_t at_level[20];

        int32_t yearly_update_requested;
        int32_t yearly_births;
        int32_t yearly_deaths;
        int32_t lost_removal;
        int32_t lost_homeless;
        int32_t lost_troop_request;
        int32_t last_change;
        int32_t total_all_years;
        int32_t total_years;
        int32_t average_per_year;
        int32_t highest_ever;
        int32_t total_capacity;
        int32_t room_in_houses;
        int32_t people_in_tents;
        int32_t people_in_tents_shacks;
        int32_t people_in_large_insula_and_above;
        int32_t people_in_villas_palaces;
        int32_t percentage_plebs;
        int32_t last_used_house_add;
        int32_t last_used_house_remove;
        int32_t graph_order;
    } population;
    struct {
        int32_t wages;
        int32_t wages_rome;
        int32_t workers_available;
        int32_t workers_employed;
        int32_t workers_unemployed;
        int32_t workers_needed;
        int32_t unemployment_percentage;
        int32_t unemployment_percentage_for_senate;
        struct labor_category_data_t categories[10];
    } labor;
    struct {
        int32_t immigration_duration;
        int32_t emigration_duration;
        int32_t immigration_amount_per_batch;
        int32_t emigration_amount_per_batch;
        int32_t immigration_queue_size;
        int32_t emigration_queue_size;
        int32_t immigrated_today;
        int32_t emigrated_today;
        int32_t refused_immigrants_today;
        int32_t no_immigration_cause;
        int32_t percentage;
        int32_t newcomers;
        int32_t emigration_message_shown;
    } migration;
    struct {
        int32_t value;
        int32_t previous_value;
        int32_t message_delay;
        int32_t low_mood_cause;
        int32_t protesters;
        int32_t criminals; // muggers+rioters
    } sentiment;
    struct {
        int32_t num_hospital_workers;
        int32_t target_value;
        int32_t value;
    } health;
    struct {
        int32_t culture;
        int32_t prosperity;
        int32_t peace;
        int32_t favor;
        struct {
            int32_t library;
        } culture_points;
        int32_t prosperity_treasury_last_year;
        int32_t prosperity_max;
        int32_t peace_destroyed_buildings;
        int32_t peace_years_of_peace;
        int32_t peace_num_criminals;
        int32_t peace_num_rioters;
        int32_t peace_riot_cause;
        int32_t favor_salary_penalty;
        int32_t favor_ignored_request_penalty;
        int32_t favor_last_year;
        int32_t favor_change; // 0 = dropping, 1 = stalling, 2 = rising
        int32_t selected;
        int32_t culture_explanation;
        int32_t prosperity_explanation;
        int32_t peace_explanation;
        int32_t favor_explanation;
    } ratings;
    struct {
        int32_t average_entertainment;
        int32_t average_religion;
        int32_t average_education;
        int32_t average_health;
        int32_t religion_coverage;
    } culture;
    struct {
        struct god_status_t gods[5];
        int32_t least_happy_god;
        int32_t angry_message_delay;
        int32_t venus_curse_active;
        int32_t neptune_double_trade_active;
        int32_t neptune_sank_ships;
        int32_t mars_spirit_power;
    } religion;
    struct {
        int32_t theater_shows;
        int32_t theater_no_shows_weighted;
        int32_t amphitheater_shows;
        int32_t amphitheater_no_shows_weighted;
        int32_t colosseum_shows;
        int32_t colosseum_no_shows_weighted;
        int32_t hippodrome_shows;
        int32_t hippodrome_no_shows_weighted;
        int32_t venue_needing_shows;
        int32_t hippodrome_has_race;
        int32_t hippodrome_message_shown;
        int32_t colosseum_message_shown;
    } entertainment;
    struct {
        int queued;
        int8_t god;
        int8_t size;
        int32_t months_to_go;
        int32_t months_since_festival;
        int32_t first_festival_effect_months;
        int32_t second_festival_effect_months;
    } festival;
    struct {
        int16_t space_in_warehouses[RESOURCE_TYPES_MAX];
        uint16_t stored_in_warehouses[RESOURCE_TYPES_MAX];
        int32_t space_in_workshops[6];
        int32_t stored_in_workshops[6];
        int16_t trade_status[RESOURCE_TYPES_MAX];
        int16_t export_over[RESOURCE_TYPES_MAX];
        int32_t stockpiled[RESOURCE_TYPES_MAX];
        int16_t mothballed[RESOURCE_TYPES_MAX];
        int32_t wine_types_available;
        int32_t food_types_available;
        int32_t food_types_eaten;
        int32_t granary_food_stored[FOOD_TYPES_MAX];
        int32_t granary_total_stored;
        int32_t food_supply_months;
        int32_t food_needed_per_month;
        int32_t food_consumed_last_month;
        int32_t food_produced_last_month;
        int32_t food_produced_this_month;
        struct {
            int operating;
            int not_operating;
            int not_operating_with_food;
            int understaffed;
        } granaries;
        int16_t last_used_warehouse;
    } resource;
    struct {
        uint8_t hit_elephant;
        uint8_t die_citizen;
        uint8_t die_soldier;
    } sound;
    struct {
        int16_t num_land_routes;
        int16_t num_sea_routes;
        int16_t land_trade_problem_duration;
        int16_t sea_trade_problem_duration;
        int32_t caravan_import_resource;
        int32_t caravan_backup_import_resource;
        int32_t docker_import_resource;
        int32_t docker_export_resource;
    } trade;
    struct {
        struct {
            int32_t id;
            int32_t size;
        } largest_road_networks[10];
    } map;
    struct {
        int32_t has_won;
        int32_t continue_months_left;
        int32_t continue_months_chosen;
        int32_t fired_message_shown;
        int32_t victory_message_shown;
    } mission;
};
static struct city_data_t city_data;

struct resource_list_t {
    int size;
    int items[RESOURCE_TYPES_MAX];
};

struct resource_img_ids_t {
    int icon_img_id;
    int editor_icon_img_id;
    int warehouse_space_img_id;
    int cart_img_id;
    int farm_field_img_id;
    int empire_icon_img_id;
    int editor_empire_icon_img_id;
};
struct resource_img_ids_t resource_images[RESOURCE_TYPES_MAX] = {
{0, 0, 0, 0, -1, 0, 0}, // RESOURCE_NONE
{1187, 1190, 3338, 8, 0, 7983, 3233}, // RESOURCE_WHEAT
{1188, 1191, 3342, 16, 5, 7984, 3234}, // RESOURCE_VEGETABLES
{1189, 1192, 3346, 24, 10, 7985, 3235}, // RESOURCE_FRUIT
{1192, 1195, 3358, 48, 25, 7988, 3238}, // RESOURCE_MEAT
{1190, 1193, 3350, 32, 15, 7986, 3236}, // RESOURCE_OLIVES
{1191, 1194, 3354, 40, 20, 7987, 3237}, // RESOURCE_VINES
{1197, 1200, 3378, 88, -1, 7993, 3243}, // RESOURCE_CLAY
{1196, 1199, 3366, 80, -1, 7992, 3242}, // RESOURCE_TIMBER
{1198, 1201, 3382, 96, -1, 7994, 3244}, // RESOURCE_MARBLE
{1195, 1198, 3370, 72, -1, 7991, 3241}, // RESOURCE_IRON
{1194, 1197, 3366, 64, -1, 7990, 3240}, // RESOURCE_OIL
{1193, 1196, 3362, 56, -1, 7989, 3239}, // RESOURCE_WINE
{1201, 1204, 3394, 120, -1, 7997, 3247}, // RESOURCE_POTTERY
{1200, 1203, 3390, 112, -1, 7996, 3246}, // RESOURCE_FURNITURE
{1199, 1202, 3386, 104, -1, 7995, 3245}, // RESOURCE_WEAPONS
};

struct trade_price_t {
    uint16_t buy;
    uint16_t sell;
};
struct trade_price_t DEFAULT_PRICES[RESOURCE_TYPES_MAX] = {
    {0, 0}, // RESOURCE_NONE
    {28, 22}, // RESOURCE_WHEAT
    {38, 30}, // RESOURCE_VEGETABLES
    {38, 30}, // RESOURCE_FRUIT
    {44, 36}, // RESOURCE_MEAT
    {42, 34}, // RESOURCE_OLIVES
    {44, 36}, // RESOURCE_VINES
    {40, 30}, // RESOURCE_CLAY
    {50, 35}, // RESOURCE_TIMBER
    {200, 140}, // RESOURCE_MARBLE
    {60, 40}, // RESOURCE_IRON
    {180, 140}, // RESOURCE_OIL
    {215, 160}, // RESOURCE_WINE
    {180, 140}, // RESOURCE_POTTERY
    {200, 150}, // RESOURCE_FURNITURE
    {250, 180}, // RESOURCE_WEAPONS
};
static struct trade_price_t trade_prices[RESOURCE_TYPES_MAX];

struct buffer_t {
    uint8_t *data; /**< Read-only: data */
    int size; /**< Read-only: size of the data */
    int index; /**< Read-only: bytes read/written so far */
    int overflow; /**< Read-only: indicates attempt to read/write beyond end of buffer */
};

struct dir_listing {
    char files[SCENARIO_FILES_MAX][FILE_NAME_LENGTH_MAX]; /**< Filenames in UTF-8 encoding */
    int num_files; /**< Number of files in the list */
    int file_overflow;
};
static struct dir_listing listing;

struct lang_message_image {
    int id; /**< ID of the image */
    int x; /**< X offset */
    int y; /**< Y offset */
};

struct lang_message_string {
    char *text; /**< Text */
    int x; /**< X offset */
    int y; /**< Y offset */
};

struct lang_message_t {
    int type;
    int message_type;
    int x;
    int y;
    int width_blocks;
    int height_blocks;
    int urgent;
    struct lang_message_image image;
    struct lang_message_string title;
    struct lang_message_string subtitle;
    struct lang_message_string video;
    struct lang_message_string content;
};

struct speed_type_t {
    double speed_difference;
    double desired_speed;
    double current_speed;
    double adjusted_current_speed;
    double cumulative_delta;
    double fine_position;
    int adjust_for_time;
    uint32_t start_time;
    uint32_t total_time;
    uint32_t last_speed_check;
};

struct empire_object_t {
    int32_t id;
    uint8_t type;
    int16_t x;
    int16_t y;
    int16_t image_id;
    struct {
        int16_t x;
        int16_t y;
        int16_t image_id;
    } expanded;
    int16_t width;
    int16_t height;
    uint8_t animation_index;
    uint8_t in_use;
    uint8_t city_type;
    uint8_t city_name_id;
    uint8_t trade_route_id;
    uint8_t trade_route_open;
    uint32_t trade_route_cost;
    int16_t trader_entry_delay;
    uint8_t is_sea_trade;
    int16_t trader_figure_ids[3];
    uint8_t resource_buy_limit[RESOURCE_TYPES_MAX];
    uint8_t resource_sell_limit[RESOURCE_TYPES_MAX];
    uint8_t resource_bought[RESOURCE_TYPES_MAX];
    uint8_t resource_sold[RESOURCE_TYPES_MAX];
    uint8_t invasion_path_id;
    uint8_t invasion_years;
    uint8_t distant_battle_travel_months;
};
static struct empire_object_t empire_objects[MAX_EMPIRE_OBJECTS];
static struct empire_object_t *selected_empire_object;

struct figure_t {
    int id;
    uint8_t in_use;
    uint8_t is_targetable;
    uint8_t is_corpse;
    uint8_t type;
    uint8_t action_state;
    uint8_t is_fleeing;
    uint8_t formation_id;
    uint8_t index_in_formation;
    uint8_t damage;
    uint8_t is_military_trained;
    uint8_t mounted_charge_ticks;
    uint8_t mounted_charge_ticks_max;
    uint16_t target_figure_id;
    uint16_t melee_targeter_ids[MAX_MELEE_TARGETERS_PER_UNIT];
    uint16_t melee_combatant_ids[MAX_MELEE_COMBATANTS_PER_UNIT];
    uint8_t num_melee_combatants;
    uint16_t ranged_targeter_ids[MAX_RANGED_TARGETERS_PER_UNIT];
    uint8_t prefect_recent_guard_duty;
    int8_t attack_direction;
    uint8_t engaged_in_combat;
    int8_t source_x;
    int8_t source_y;
    uint16_t routing_path_id;
    uint16_t routing_path_current_tile;
    uint16_t routing_path_length;
    uint8_t terrain_usage;
    uint8_t speed_multiplier;
    int8_t previous_tile_direction;
    int8_t previous_tile_x;
    int8_t previous_tile_y;
    int8_t direction;
    uint8_t progress_on_tile;
    int16_t x;
    int16_t y;
    uint16_t grid_offset;
    int8_t destination_x;
    int8_t destination_y;
    uint16_t destination_grid_offset; // only used for soldiers
    uint8_t destination_building_id;
    uint8_t figure_is_halted;
    uint8_t use_cross_country;
    uint8_t cc_direction; // 1 = x, 2 = y
    uint16_t cross_country_x; // position = 15 * x + offset on tile
    uint16_t cross_country_y; // position = 15 * y + offset on tile
    int16_t cc_delta_x;
    int16_t cc_delta_y;
    int16_t cc_delta_xy;
    uint16_t cc_destination_x;
    uint16_t cc_destination_y;
    uint8_t missile_offset;
    uint16_t roam_length;
    uint8_t roam_choose_destination;
    uint8_t roam_random_counter;
    int8_t roam_turn_direction;
    int8_t roam_ticks_until_next_turn;
    uint8_t in_building_wait_ticks;
    uint8_t height_adjusted_ticks;
    uint8_t current_height;
    uint8_t target_height;
    uint16_t next_figure_id_on_same_tile;
    uint16_t image_id;
    uint8_t image_offset;
    uint8_t attack_image_offset;
    uint8_t is_shooting;
    uint16_t cart_image_id;
    int8_t x_offset_cart;
    int8_t y_offset_cart;
    uint8_t enemy_image_group;
    int16_t wait_ticks;
    uint8_t wait_ticks_missile;
    char name[FIGURE_MAX_NAME_LENGTH];
    uint8_t is_invisible;
    uint16_t building_id; // for missiles: building_id contains the figure that shot it
    uint16_t immigrant_building_id;
    uint8_t migrant_num_people;
    uint8_t min_max_seen;
    uint8_t empire_city_id;
    uint8_t resource_id;
    uint8_t collecting_item_id; // NOT a resource ID for cartpushers! IS a resource ID for warehousemen
    uint8_t trader_id;
    uint16_t leading_figure_id;
    uint8_t trader_amount_bought;
    uint8_t loads_sold_or_carrying;
    uint8_t trade_ship_failed_dock_attempts;
    uint8_t flotsam_visible;
};
static struct figure_t figures[MAX_FIGURES];

struct figure_properties_t {
    uint8_t is_unarmed_civilian_unit;
    uint8_t is_friendly_armed_unit; // excl. player legions
    uint8_t is_player_legion_unit;
    uint8_t is_criminal_unit;
    uint8_t is_empire_trader;
    uint8_t is_native_unit;
    uint8_t is_herd_animal;
    uint8_t is_enemy_unit; // excl. Caesar legions
    uint8_t is_caesar_legion_unit;
    uint8_t melee_attack_value;
    uint8_t melee_defense_value;
    uint8_t missile_attack_value;
    uint8_t missile_defense_value;
    uint8_t missile_delay;
    uint8_t missile_type;
    uint8_t max_range;
    uint8_t max_damage;
    uint16_t max_roam_length;
    uint8_t is_boat; // 1 for boat, 2 for flotsam
    uint8_t big_img_id;
    int8_t sound_category;
};
static struct figure_properties_t figure_properties[FIGURE_TYPE_MAX] = {
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  0,   0,   0, 8,  -1},  // FIGURE_NONE = 0,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  0,   0, 13,  24},  // FIGURE_IMMIGRANT = 1,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  0,   0, 13,  23},  // FIGURE_EMIGRANT = 2,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  0,   0, 9,   21},  // FIGURE_HOMELESS = 3,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  10,  128, 0, 58,  18},  // FIGURE_PATRICIAN = 4,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  0,   0, 4,   5},  // FIGURE_CART_PUSHER = 5,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  384, 0, 13,  19},  // FIGURE_LABOR_SEEKER = 6,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  384, 0, 2,   13},  // FIGURE_BARBER = 7,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  384, 0, 3,   11},  // FIGURE_BATHHOUSE_WORKER = 8,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  384, 0, 6,   12},  // FIGURE_DOCTOR = 9,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  384, 0, 6,   12},  // FIGURE_SURGEON = 10,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  384, 0, 14,  8},  // FIGURE_PRIEST = 11,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  10,  96,  0, 5,   10},  // FIGURE_SCHOOL_CHILD = 12,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  384, 0, 52,  9},  // FIGURE_TEACHER = 13,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20,  384, 0, 52,  9},  // FIGURE_LIBRARIAN = 14,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20, 192,  0, 53,  30},  // FIGURE_MISSIONARY = 15,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  2, 512,   0, 1,   14},  // FIGURE_ACTOR = 16,
{0, 1, 0, 0, 0, 0, 0, 0, 0, 9,  2, 0,   0, 0,   0,              0,  100, 512, 0, 33,  15},  // FIGURE_GLADIATOR = 17,
{0, 1, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0,   0, 0,   0,              0,  100, 512, 0, 10,  16},  // FIGURE_LION_TAMER = 18,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20, 512,  0, 11,  17},  // FIGURE_CHARIOTEER = 19,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  0, 0,     0, 8,  -1},  // FIGURE_HIPPODROME_HORSES = 20,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20, 512,  0, 16,  3},  // FIGURE_TAX_COLLECTOR = 21,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20, 640,  0, 7,   2},  // FIGURE_ENGINEER = 22,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  0, 0,     1, 60, -1},  // FIGURE_FISHING_BOAT = 23,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  0, 0,     0, 8,  -1},  // FIGURE_FISH_GULLS = 24,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  0, 0,     1, 62, -1},  // FIGURE_SHIPWRECK = 25,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20, 0,    0, 17,  5},  // FIGURE_DOCKER = 26,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  0, 0,     2, 8,  -1},  // FIGURE_FLOTSAM = 27,
{0, 1, 0, 0, 0, 0, 0, 0, 0, 0,  0, 8,   0, 200, FIGURE_BOLT,    15, 0, 0,     0, 8,  -1},  // FIGURE_BALLISTA = 28,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 200, 0, 0,   0,              0,  0, 0,     0, 8,  -1},  // FIGURE_BOLT = 29,
{0, 1, 0, 0, 0, 0, 0, 0, 0, 6,  0, 6,   0, 50,  FIGURE_JAVELIN, 12, 50, 0,    0, 50,  1},  // FIGURE_TOWER_SENTRY = 30,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 15,  0, 0,   0,              0,  0, 0,     0, 8,  -1},  // FIGURE_JAVELIN = 31,
{0, 1, 0, 0, 0, 0, 0, 0, 0, 5,  0, 0,   0, 0,   0,              0,  50, 640,  0, 18,  0},  // FIGURE_PREFECT = 32,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  0, 0,     0, 8,  -1},  // FIGURE_FORT_STANDARD = 33,
{0, 0, 1, 0, 0, 0, 0, 0, 0, 4,  0, 4,   0, 100, FIGURE_JAVELIN, 10, 70, 0,    0, 42,  1},  // FIGURE_FORT_JAVELIN = 34,
{0, 0, 1, 0, 0, 0, 0, 0, 0, 6,  0, 0,   0, 0,   0,              0,  110, 0,   0, 26,  1},  // FIGURE_FORT_MOUNTED = 35,
{0, 0, 1, 0, 0, 0, 0, 0, 0, 10, 3, 0,   6, 0,   0,              0,  150, 0,   0, 41,  1},  // FIGURE_FORT_LEGIONARY = 36,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20, 800,  0, 12,  4},  // FIGURE_MARKET_BUYER = 37,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20, 384,  0, 12,  4},  // FIGURE_MARKET_TRADER = 38,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20, 0,    0, 38,  31},  // FIGURE_DELIVERY_BOY = 39,
{1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20, 0,    0, 4,   5},  // FIGURE_WAREHOUSEMAN = 40,
{0, 0, 0, 1, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  30, 0,    0, 15,  20},  // FIGURE_PROTESTER = 41,
{0, 0, 0, 1, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  30, 0,    0, 15,  20},  // FIGURE_CRIMINAL = 42,
{0, 0, 0, 1, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  30, 480,  0, 15,  20},  // FIGURE_RIOTER = 43,
{0, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  10, 0,    0, 25,  6},  // FIGURE_TRADE_CARAVAN = 44,
{0, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  10, 0,    0, 25,  6},  // FIGURE_TRADE_CARAVAN_DONKEY = 45,
{0, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  0, 0,     1, 8,   7},  // FIGURE_TRADE_SHIP = 46,
{0, 0, 0, 0, 0, 1, 0, 0, 0, 6,  0, 0,   0, 0,   0,              0,  40, 800,  0, 21, -1},  // FIGURE_INDIGENOUS_NATIVE = 47,
{0, 0, 0, 0, 0, 1, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  40, 0,    0, 63, -1},  // FIGURE_NATIVE_TRADER = 48,
{0, 0, 0, 0, 0, 0, 1, 0, 0, 8,  0, 0,   0, 0,   0,              0,  80, 0,    0, 55, -1},  // FIGURE_WOLF = 49,
{0, 0, 0, 0, 0, 0, 1, 0, 0, 0,  0, 0,   0, 0,   0,              0,  10, 0,    0, 54, -1},  // FIGURE_SHEEP = 50,
{0, 0, 0, 0, 0, 0, 1, 0, 0, 0,  0, 0,   0, 0,   0,              0,  20, 0,    0, 56, -1},  // FIGURE_ZEBRA = 51,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 9,  2, 0,   0, 0,   0,              0,  100, 0,   0, 33,  25},  // FIGURE_ENEMY_GLADIATOR = 52,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  1, 0,   0, 0,   0,              0,  90, 0,    0, 21,  25},  // FIGURE_ENEMY_BARBARIAN_SWORDSMAN = 53,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 12, 2, 0,   2, 0,   0,              0,  120, 0,   0, 22,  25},  // FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN = 54,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 20, 5, 0,   8, 70,  FIGURE_ARROW,   15, 200, 0,   0, 30,  25},  // FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT = 55,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 10, 1, 0,   2, 0,   0,              0,  110, 0,   0, 24,  25},  // FIGURE_ENEMY_BRITON_SWORDSMAN = 56,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 12, 4, 0,   4, 0,   0,              0,  120, 0,   0, 23,  25},  // FIGURE_ENEMY_BRITON_CHARIOT = 57,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 10, 1, 0,   2, 0,   0,              0,  110, 0,   0, 24,  25},  // FIGURE_ENEMY_CELT_SWORDSMAN = 58,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 12, 4, 0,   4, 0,   0,              0,  120, 0,   0, 23,  25},  // FIGURE_ENEMY_CELT_CHARIOT = 59,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 10, 1, 0,   2, 0,   0,              0,  110, 0,   0, 24,  25},  // FIGURE_ENEMY_PICT_SWORDSMAN = 60,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 12, 4, 0,   4, 0,   0,              0,  120, 0,   0, 23,  25},  // FIGURE_ENEMY_PICT_CHARIOT = 61,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  0, 0,   0, 0,   0,              0,  90, 0,    0, 29,  25},  // FIGURE_ENEMY_EGYPTIAN_SWORDSMAN = 62,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  1, 0,   0, 70,  FIGURE_ARROW,   15, 120, 0,   0, 28,  25},  // FIGURE_ENEMY_EGYPTIAN_CAMEL = 63,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 12, 2, 0,   2, 0,   0,              0,  120, 0,   0, 31,  25},  // FIGURE_ENEMY_ETRUSCAN_SWORDSMAN = 64,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 5,  0, 0,   0, 70,  FIGURE_JAVELIN, 10, 70, 0,    0, 32,  25},  // FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER = 65,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 12, 2, 0,   2, 0,   0,              0,  120, 0,   0, 31,  25},  // FIGURE_ENEMY_SAMNITE_SWORDSMAN = 66,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 5,  0, 0,   0, 70,  FIGURE_JAVELIN, 10, 70, 0,    0, 32,  25},  // FIGURE_ENEMY_SAMNITE_SPEAR_THROWER = 67,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 10, 1, 0,   2, 0,   0,              0,  110, 0,   0, 40,  25},  // FIGURE_ENEMY_GAUL_SWORDSMAN = 68,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 15, 2, 0,   3, 0,   0,              0,  120, 0,   0, 39,  25},  // FIGURE_ENEMY_GAUL_AXEMAN = 69,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 10, 1, 0,   2, 0,   0,              0,  110, 0,   0, 40,  25},  // FIGURE_ENEMY_HELVETIUS_SWORDSMAN = 70,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 15, 2, 0,   3, 0,   0,              0,  120, 0,   0, 39,  25},  // FIGURE_ENEMY_HELVETIUS_AXEMAN = 71,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  1, 0,   0, 0,   0,              0,  90, 0,    0, 35,  25},  // FIGURE_ENEMY_HUN_SWORDSMAN = 72,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 6,  1, 0,   0, 70,  FIGURE_ARROW,   15, 100, 0,   0, 34,  25},  // FIGURE_ENEMY_HUN_MOUNTED_ARCHER = 73,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  1, 0,   0, 0,   0,              0,  90, 0,    0, 35,  25},  // FIGURE_ENEMY_GOTH_SWORDSMAN = 74,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 6,  1, 0,   0, 70,  FIGURE_ARROW,   15, 100, 0,   0, 34,  25},  // FIGURE_ENEMY_GOTH_MOUNTED_ARCHER = 75,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  1, 0,   0, 0,   0,              0,  90, 0,    0, 35,  25},  // FIGURE_ENEMY_VISIGOTH_SWORDSMAN = 76,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 6,  1, 0,   0, 70,  FIGURE_ARROW,   15, 100, 0,   0, 34,  25},  // FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER = 77,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 12, 2, 0,   2, 0,   0,              0,  120, 0,   0, 37,  25},  // FIGURE_ENEMY_GREEK_SWORDSMAN = 78,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 5,  0, 0,   0, 70,  FIGURE_JAVELIN, 10, 70, 0,    0, 36,  25},  // FIGURE_ENEMY_GREEK_SPEAR_THROWER = 79,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 12, 2, 0,   2, 0,   0,              0,  120, 0,   0, 37,  25},  // FIGURE_ENEMY_MACEDONIAN_SWORDSMAN = 80,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 5,  0, 0,   0, 70,  FIGURE_JAVELIN, 10, 70, 0,    0, 36,  25},  // FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER = 81,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  1, 0,   0, 0,   0,              0,  90, 0,    0, 20,  25},  // FIGURE_ENEMY_NUMIDIAN_SWORDSMAN = 82,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 5,  0, 0,   0, 100, FIGURE_JAVELIN, 10, 70, 0,    0, 20,  25},  // FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER = 83,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  0, 0,   0, 0,   0,              0,  90, 0,    0, 45,  25},  // FIGURE_ENEMY_PERGAMUM_SWORDSMAN = 84,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 5,  0, 0,   0, 70,  FIGURE_ARROW,   15, 70, 0,    0, 44,  25},  // FIGURE_ENEMY_PERGAMUM_ARCHER = 85,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  0, 0,   0, 0,   0,              0,  90, 0,    0, 47,  25},  // FIGURE_ENEMY_IBERIAN_SWORDSMAN = 86,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 5,  0, 0,   0, 70,  FIGURE_JAVELIN, 10, 70, 0,    0, 46,  25},  // FIGURE_ENEMY_IBERIAN_SPEAR_THROWER = 87,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  0, 0,   0, 0,   0,              0,  90, 0,    0, 47,  25},  // FIGURE_ENEMY_JUDEAN_SWORDSMAN = 88,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 5,  0, 0,   0, 70,  FIGURE_JAVELIN, 10, 70, 0,    0, 46,  25},  // FIGURE_ENEMY_JUDEAN_SPEAR_THROWER = 89,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 7,  0, 0,   0, 0,   0,              0,  90, 0,    0, 47,  25},  // FIGURE_ENEMY_SELEUCID_SWORDSMAN = 90,
{0, 0, 0, 0, 0, 0, 0, 1, 0, 5,  0, 0,   0, 70,  FIGURE_JAVELIN, 10, 70, 0,    0, 46,  25},  // FIGURE_ENEMY_SELEUCID_SPEAR_THROWER = 91,
{0, 0, 0, 0, 0, 0, 0, 0, 1, 4,  0, 0,   0, 100, FIGURE_JAVELIN, 10, 90, 0,    0, 43,  25},  // FIGURE_ENEMY_CAESAR_JAVELIN = 92,
{0, 0, 0, 0, 0, 0, 0, 0, 1, 8,  0, 0,   0, 0,   0,              0,  100, 0,   0, 27,  25},  // FIGURE_ENEMY_CAESAR_MOUNTED = 93,
{0, 0, 0, 0, 0, 0, 0, 0, 1, 10, 3, 0,   6, 0,   0,              0,  150, 0,   0, 48,  25},  // FIGURE_ENEMY_CAESAR_LEGIONARY = 94,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 5,   0, 0,   0,              0,  0, 0,     0, 8,  -1},  // FIGURE_ARROW = 95,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  0, 0,     0, 8,  -1},  // FIGURE_MAP_FLAG = 96,
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0,   0, 0,   0,              0,  0, 0,     0, 8,  -1},  // FIGURE_EXPLOSION = 97,
};

struct set_sound_t {
    int enabled;
    int volume;
};

struct clip_info_t {
    int clip_x;
    int clip_y;
    int clipped_pixels_left;
    int clipped_pixels_right;
    int clipped_pixels_top;
    int clipped_pixels_bottom;
    int visible_pixels_x;
    int visible_pixels_y;
    int is_visible;
};
static struct clip_info_t clip;

struct font_definition_t {
    int font;
    int image_offset;
    int space_width;
    int letter_spacing;
    int line_height;
    int line_spacing;
    int (*image_y_offset)(uint8_t c, int image_height, int line_height);
};

struct generic_button_t {
    short x;
    short y;
    short width;
    short height;
    void (*left_click_handler)(int param1, int param2);
    void (*right_click_handler)(int param1, int param2);
    int parameter1;
    int parameter2;
};

struct image_button_t {
    short x_offset;
    short y_offset;
    short width;
    short height;
    short button_type;
    short image_collection;
    short image_offset;
    void (*left_click_handler)(int param1, int param2);
    void (*right_click_handler)(int param1, int param2);
    int parameter1;
    int parameter2;
    char enabled;
    // state
    char pressed;
    char focused;
    uint32_t pressed_since;
};

struct menu_item_t {
    short text_group;
    short text_number;
    void (*left_click_handler)(int param);
    int parameter;
    int hidden;
};

struct menu_bar_item_t {
    short text_group;
    struct menu_item_t *items;
    int num_items;
    short x_start;
    short x_end;
    int calculated_width_blocks;
    int calculated_height_blocks;
};

struct window_type_t {
    int id;
    void (*draw_background)(void);
    void (*draw_foreground)(void);
    void (*handle_input)(struct mouse_t *m);
};

struct grid_u8_t {
    uint8_t items[GRID_SIZE * GRID_SIZE];
};
static struct grid_u8_t aqueduct; // The aqueduct grid is used in two ways: 1) to mark water/no water 2) to store image IDs for the aqueduct (0-15). This leads to some strange results.
static struct grid_u8_t aqueduct_backup;
static struct grid_u8_t damage_grid;
static struct grid_u8_t bitfields_backup;
static struct grid_u8_t bitfields_grid;
static struct grid_u8_t edge_backup;
static struct grid_u8_t edge_grid;
static struct grid_u8_t network;
static struct grid_u8_t random;
static struct grid_u8_t rubble_type_grid;
static struct grid_u8_t sprite;
static struct grid_u8_t sprite_backup;
static struct grid_u8_t terrain_elevation;
static struct grid_u8_t water_drag;

struct grid_i8_t {
    int8_t items[GRID_SIZE * GRID_SIZE];
};
static struct grid_i8_t desirability_grid;
static struct grid_i8_t terrain_land_citizen;
static struct grid_i8_t terrain_land_noncitizen;
static struct grid_i8_t terrain_water;
static struct grid_i8_t terrain_walls;

struct grid_u16_t {
    uint16_t items[GRID_SIZE * GRID_SIZE];
};
static struct grid_u16_t buildings_grid;
static struct grid_u16_t images;
static struct grid_u16_t images_backup;
static struct grid_u16_t map_figures;
static struct grid_u16_t terrain_grid;
static struct grid_u16_t terrain_grid_backup;

struct grid_i16_t {
    int16_t items[GRID_SIZE * GRID_SIZE];
};
static struct grid_i16_t routing_distance;

struct terrain_image_t {
    int is_valid;
    int group_offset;
    int item_offset;
    int aqueduct_offset;
};

struct map_data_t {
    int width;
    int height;
    int start_offset;
    int border_size;
};
static struct map_data_t map_data;

struct request_t {
    int16_t year_offset;
    uint16_t amount;
    uint16_t years_deadline;
    uint16_t months_to_comply;
    uint8_t month;
    uint8_t resource;
    uint8_t favor;
    uint8_t state;
    uint8_t visible;
    uint8_t can_comply_dialog_shown;
};

struct editor_custom_messages_t {
    char title[MAX_CUSTOM_MESSAGE_TITLE];
    char text[MAX_CUSTOM_MESSAGE_TEXT];
    char video_file[MAX_CUSTOM_MESSAGE_VIDEO_TEXT];
    uint8_t month;
    uint8_t urgent;
    uint8_t enabled;
    uint16_t year_offset;
};

struct earthquake_t {
    uint8_t state;
    uint8_t severity;
    uint8_t month;
    uint16_t year_offset;
    uint16_t duration;
    uint16_t max_duration;
    uint8_t delay;
    uint8_t max_delay;
    uint8_t point;
    struct map_point_t branch_coordinates[MAX_EARTHQUAKE_BRANCHES];
};

struct invasion_t {
    uint16_t year_offset;
    uint16_t amount;
    uint8_t month;
    uint8_t type;
    uint8_t enemy_type;
    uint8_t from;
    uint8_t target_type;
};

struct price_change_t {
    uint16_t year_offset;
    uint8_t month;
    uint8_t resource;
    uint8_t is_rise;
    uint8_t amount;
};

struct demand_change_t {
    uint16_t year_offset;
    uint8_t month;
    uint8_t resource;
    uint8_t trade_city_id;
    uint8_t is_rise;
};

struct scenario_t {
    struct {
        uint16_t width;
        uint16_t height;
        uint16_t grid_start;
    } map;
    struct {
        uint16_t expansion_year;
        uint8_t id;
        uint8_t is_expanded;
        uint8_t distant_battle_roman_travel_months;
        uint8_t distant_battle_enemy_travel_months;
    } empire;
    char scenario_name[MAX_SCENARIO_NAME];
    char brief_description[MAX_BRIEF_DESCRIPTION_LENGTH];
    uint16_t brief_description_image_id;
    char briefing[MAX_BRIEFING_LENGTH];
    uint8_t climate;
    uint8_t player_rank;
    int16_t start_year;
    uint8_t initial_favor;
    int32_t initial_funds;
    int32_t rescue_loan;
    int32_t initial_personal_savings;
    uint8_t rome_supplies_wheat;
    uint8_t flotsam_enabled;
    int population_win_criteria;
    int culture_win_criteria;
    int prosperity_win_criteria;
    int peace_win_criteria;
    int favor_win_criteria;
    int time_limit_win_criteria;
    int survival_time_win_criteria;
    struct {
        uint8_t state;
        int8_t month;
        int16_t year_offset;
    } gladiator_revolt;
    struct {
        uint8_t sea_trade_problem;
        uint8_t land_trade_problem;
        uint8_t raise_wages;
        uint8_t lower_wages;
        uint8_t contaminated_water;
    } random_events;
    uint8_t allowed_buildings[BUILDING_TYPE_MAX];
    struct request_t requests[MAX_REQUESTS];
    struct editor_custom_messages_t editor_custom_messages[MAX_EDITOR_CUSTOM_MESSAGES];
    struct earthquake_t earthquakes[MAX_EARTHQUAKES];
    struct invasion_t invasions[MAX_INVASIONS];
    uint8_t invasion_upcoming;
    struct price_change_t price_changes[MAX_PRICE_CHANGES];
    struct demand_change_t demand_changes[MAX_DEMAND_CHANGES];
    struct map_point_t earthquake_points[MAX_EARTHQUAKE_POINTS];
    struct map_point_t invasion_points[MAX_INVASION_POINTS];
    struct map_point_t entry_point;
    struct map_point_t exit_point;
    struct map_point_t river_entry_point;
    struct map_point_t river_exit_point;
    struct map_point_t herd_points[MAX_HERD_POINTS];
    struct map_point_t fishing_points[MAX_FISH_POINTS];
    struct {
        uint32_t hut;
        uint32_t meeting;
        uint32_t crops;
        uint32_t vacant_lots;
    } native_images;
};
static struct scenario_t scenario;

struct scenario_settings_t {
    char player_name[MAX_PLAYER_NAME_LENGTH];
};
static struct scenario_settings_t scenario_settings;

struct advisor_window_type_t {
    int (*draw_background)(void);
    void (*draw_foreground)(void);
    int (*handle_mouse)(struct mouse_t *m);
};

struct submenu_t {
    int building_id;
    char *submenu_string;
    int submenu_items[MAX_ITEMS_PER_SUBMENU];
};

struct build_menu_t {
    int is_enabled;
    struct submenu_t menu_items[MAX_ITEMS_PER_BUILD_MENU];
};
static struct build_menu_t build_menus[BUILD_MENU_BUTTONS_COUNT];

struct city_overlay_t {
    int type;
    int column_type;
    int (*show_building)(struct building_t *b);
    int (*show_figure)(struct figure_t *f);
    int (*get_column_height)(struct building_t *b);
    void (*draw_custom_footprint)(int x, int y, int grid_offset);
    void (*draw_custom_top)(int x, int y, int grid_offset);
};
static struct city_overlay_t *overlay = 0;

struct pixel_coordinate_t {
    int x;
    int y;
};

struct {
    SDL_Window *window;
    SDL_Renderer *renderer;
    SDL_Texture *texture;
    SDL_Texture *cursors[CURSOR_MAX];
} SDL;

struct {
    int WIDTH;
    int HEIGHT;
} MINIMUM = { 640, 480 };

static struct {
    int position;
    struct speed_type_t slide_speed;
    int direction;
    back_sidebar_draw_function back_sidebar_draw;
    front_sidebar_draw_function front_sidebar_draw;
    slide_finished_function finished_callback;
} widget_slide_data;

struct objective_t {
    int value;
    int target;
};

static struct {
    int absolute_x;
    int absolute_y;
    int width_tiles;
    int height_tiles;
    int x_offset;
    int y_offset;
    int width;
    int height;
    uint32_t enemy_color;
    uint32_t *cache;
    struct {
        int x;
        int y;
        int grid_offset;
    } mouse;
    int refresh_requested;
    int camera_x;
    int camera_y;
} minimap_data;

static struct {
    struct map_tile_t current_tile;
    struct map_tile_t selected_tile;
    int new_start_grid_offset;
    int capture_input;
} widget_city_data;

static struct {
    uint32_t last_water_animation_time;
    int advance_water_animation;
    int image_id_water_first;
    int image_id_water_last;
    int selected_figure_id;
    int highlighted_formation;
    struct pixel_coordinate_t *selected_figure_coord;
} draw_context;

static struct {
    int absolute_x;
    int absolute_y;
    int width_tiles;
    int height_tiles;
    int x_offset;
    int y_offset;
} scenario_minimap_data;

struct tile_color_t {
    uint32_t left;
    uint32_t right;
};

struct tile_color_set_t {
    struct tile_color_t water[4];
    struct tile_color_t tree[4];
    struct tile_color_t rock[4];
    struct tile_color_t meadow[4];
    struct tile_color_t grass[8];
    struct tile_color_t road;
};

// Since the minimap tiles are only 25 color sets per climate, we just hardcode them.
// This "hack" is necessary to avoid reloading the climate graphics when selecting
// a scenario with another climate in the CCK selection screen, which is expensive.
static   struct tile_color_set_t MINIMAP_COLOR_SETS[3] = {
    // central
    {
        .water = {{0x394a7b, 0x31427b}, {0x394a7b, 0x314273}, {0x313973, 0x314273}, {0x31427b, 0x394a7b}},
        .tree = {{0x6b8431, 0x102108}, {0x103908, 0x737b29}, {0x103108, 0x526b21}, {0x737b31, 0x084a10}},
        .rock = {{0x948484, 0x635a4a}, {0xa59c94, 0xb5ada5}, {0xb5ada5, 0x8c8484}, {0x635a4a, 0xa59c94}},
        .meadow = {{0xd6bd63, 0x9c8c39}, {0x948c39, 0xd6bd63}, {0xd6bd63, 0x9c9439}, {0x848431, 0xada54a}},
        .grass = {
            {0x6b8c31, 0x6b7b29}, {0x738431, 0x6b7b29}, {0x6b7329, 0x7b8c39}, {0x527b29, 0x6b7321},
            {0x6b8431, 0x737b31}, {0x6b7b31, 0x737b29}, {0x636b18, 0x526b21}, {0x737b31, 0x737b29}
        },
        .road = {0x736b63, 0x4a3121}
    },
    // northern
    {
        .water = {{0x394a7b, 0x31427b}, {0x394a7b, 0x314273}, {0x313973, 0x314273}, {0x31427b, 0x394a7b}},
        .tree = {{0x527b31, 0x082108}, {0x083908, 0x5a7329}, {0x082908, 0x316b21}, {0x527b29, 0x084a21}},
        .rock = {{0x8c8484, 0x5a5252}, {0x9c9c94, 0xa5a5a5}, {0xa5a5a5, 0x848484}, {0x5a5252, 0x9c9c94}},
        .meadow = {{0x427318, 0x8c9442}, {0xb5ad4a, 0x738c39}, {0x8c8c39, 0x6b7b29}, {0x527331, 0x5a8442}},
        .grass = {
            {0x4a8431, 0x4a7329}, {0x527b29, 0x4a7329}, {0x526b29, 0x5a8439}, {0x397321, 0x4a6b21},
            {0x527b31, 0x5a7331}, {0x4a7329, 0x5a7329}, {0x4a6b18, 0x316b21}, {0x527b29, 0x527329}
        },
        .road = {0x736b63, 0x4a3121}
    },
    // desert
    {
        .water = {{0x4a84c6, 0x4a7bc6}, {0x4a84c6, 0x4a7bc6}, {0x4a84c6, 0x5284c6}, {0x4a7bbd, 0x4a7bc6}},
        .tree = {{0xa59c7b, 0x6b7b18}, {0x214210, 0xada573}, {0x526b21, 0xcec6a5}, {0xa59c7b, 0x316321}},
        .rock = {{0xa59494, 0x736352}, {0xa59c94, 0xb5ada5}, {0xb5ada5, 0x8c847b}, {0x736352, 0xbdada5}},
        .meadow = {{0x739c31, 0x9cbd52}, {0x7bb529, 0x63ad21}, {0x9cbd52, 0x8c944a}, {0x7ba539, 0x739c31}},
        .grass = {
            {0xbdbd9c, 0xb5b594}, {0xc6bda5, 0xbdbda5}, {0xbdbd9c, 0xc6c6ad}, {0xd6cead, 0xc6bd9c},
            {0xa59c7b, 0xbdb594}, {0xcecead, 0xb5ad94}, {0xc6c6a5, 0xdedebd}, {0xcecead, 0xd6d6b5}
        },
        .road = {0x6b5a52, 0x4a4239}
    }
};

static struct {
    struct {
        int text_id;
        int scroll_position;
    } history[200];
    int text_id;
    void (*background_callback)(void);
    int show_video;
    int x;
    int y;
    int x_text;
    int y_text;
    int text_height_blocks;
    int text_width_blocks;
} message_dialog_data;

static struct {
    int year;
    int month;
    int param1;
    int param2;
    int message_advisor;
    int use_popup;
} player_message;

static struct {
    int resource;
} resource_settings_data;

static struct {
    int width;
    int height;
} victory_video_data;

static struct {
    int category;
    int max_items;
} labor_priority_data;

static struct {
    int x_min, x_max, y_min, y_max;
    int focus_resource;
} empire_window_data;

static struct {
    int selected_menu;
    int selected_submenu;
    int num_items_to_draw;
    int y_offset;
    int focus_button_id;
} build_menu_data = { -1, -1, 0, 0, 0 };

static struct {
    SDL_AudioFormat dst_format;
    SDL_AudioStream *stream;
} custom_music;

struct city_channel_t {
    int in_use;
    int available;
    int total_views;
    int views_threshold;
    int direction_views[5];
    int channel;
    int times_played;
    uint32_t last_played_time;
    uint32_t delay_millis;
    int should_play;
};
static struct city_channel_t channels[MAX_CITY_SOUNDS_CHANNELS];

static struct {
    int current_track;
    int next_check;
} sound_data = { TRACK_NONE, 0 };

static struct {
    int pct_type[MAX_ENEMY_TYPES_PER_ARMY];
    int figure_types[MAX_ENEMY_TYPES_PER_ARMY];
    int formation_layout;
    int enemy_img_group;
} ENEMY_PROPERTIES[] = {
    {{100, 0, 0}, {FIGURE_ENEMY_BARBARIAN_SWORDSMAN, 0, 0}, FORMATION_ENEMY_MOB, ENEMY_IMG_TYPE_BARBARIAN}, // barbarian
    {{90, 10, 0}, {FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN, FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT, 0}, FORMATION_ENEMY_WIDE_COLUMN, ENEMY_IMG_TYPE_CARTHAGINIAN}, // carthaginian
    {{80, 20, 0}, {FIGURE_ENEMY_BRITON_SWORDSMAN, FIGURE_ENEMY_BRITON_CHARIOT, 0}, FORMATION_ENEMY_MOB, ENEMY_IMG_TYPE_CELT}, // briton
    {{80, 20, 0}, {FIGURE_ENEMY_CELT_SWORDSMAN, FIGURE_ENEMY_CELT_CHARIOT, 0}, FORMATION_ENEMY_MOB, ENEMY_IMG_TYPE_CELT}, // celt
    {{80, 20, 0}, {FIGURE_ENEMY_PICT_SWORDSMAN, FIGURE_ENEMY_PICT_CHARIOT, 0}, FORMATION_ENEMY_MOB, ENEMY_IMG_TYPE_CELT}, // pict
    {{80, 20, 0}, {FIGURE_ENEMY_EGYPTIAN_SWORDSMAN, FIGURE_ENEMY_EGYPTIAN_CAMEL, 0}, FORMATION_ENEMY_WIDE_COLUMN, ENEMY_IMG_TYPE_EGYPTIAN}, // egyptian
    {{50, 50, 0}, {FIGURE_ENEMY_ETRUSCAN_SWORDSMAN, FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER, 0}, FORMATION_DOUBLE_LINE_1, ENEMY_IMG_TYPE_ETRUSCAN}, // etruscan
    {{50, 50, 0}, {FIGURE_ENEMY_SAMNITE_SWORDSMAN, FIGURE_ENEMY_SAMNITE_SPEAR_THROWER, 0}, FORMATION_DOUBLE_LINE_1, ENEMY_IMG_TYPE_ETRUSCAN}, // samnite
    {{50, 50, 0}, {FIGURE_ENEMY_GAUL_SWORDSMAN, FIGURE_ENEMY_GAUL_AXEMAN, 0}, FORMATION_ENEMY_MOB, ENEMY_IMG_TYPE_GAUL}, // gaul
    {{50, 50, 0}, {FIGURE_ENEMY_HELVETIUS_SWORDSMAN, FIGURE_ENEMY_HELVETIUS_AXEMAN, 0}, FORMATION_ENEMY_MOB, ENEMY_IMG_TYPE_GAUL}, // helvetius
    {{50, 50, 0}, {FIGURE_ENEMY_HUN_SWORDSMAN, FIGURE_ENEMY_HUN_MOUNTED_ARCHER, 0}, FORMATION_ENEMY_MOB, ENEMY_IMG_TYPE_GOTH}, // hun
    {{50, 50, 0}, {FIGURE_ENEMY_GOTH_SWORDSMAN, FIGURE_ENEMY_GOTH_MOUNTED_ARCHER, 0}, FORMATION_ENEMY_MOB, ENEMY_IMG_TYPE_GOTH}, // goth
    {{50, 50, 0}, {FIGURE_ENEMY_VISIGOTH_SWORDSMAN, FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER, 0}, FORMATION_ENEMY_MOB, ENEMY_IMG_TYPE_GOTH}, // visigoth
    {{80, 20, 0}, {FIGURE_ENEMY_GREEK_SWORDSMAN, FIGURE_ENEMY_GREEK_SPEAR_THROWER, 0}, FORMATION_DOUBLE_LINE_1, ENEMY_IMG_TYPE_GREEK}, // greek
    {{80, 20, 0}, {FIGURE_ENEMY_MACEDONIAN_SWORDSMAN, FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER, 0}, FORMATION_DOUBLE_LINE_1, ENEMY_IMG_TYPE_GREEK}, // macedonian
    {{40, 60, 0}, {FIGURE_ENEMY_NUMIDIAN_SWORDSMAN, FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER, 0}, FORMATION_ENEMY_MOB, ENEMY_IMG_TYPE_NORTH_AFRICAN}, // numidian
    {{30, 70, 0}, {FIGURE_ENEMY_PERGAMUM_SWORDSMAN, FIGURE_ENEMY_PERGAMUM_ARCHER, 0}, FORMATION_TORTOISE, ENEMY_IMG_TYPE_PERSIAN}, // pergamum
    {{50, 50, 0}, {FIGURE_ENEMY_IBERIAN_SWORDSMAN, FIGURE_ENEMY_IBERIAN_SPEAR_THROWER, 0}, FORMATION_DOUBLE_LINE_1, ENEMY_IMG_TYPE_PHOENICIAN}, // iberian
    {{50, 50, 0}, {FIGURE_ENEMY_JUDEAN_SWORDSMAN, FIGURE_ENEMY_JUDEAN_SPEAR_THROWER, 0}, FORMATION_DOUBLE_LINE_1, ENEMY_IMG_TYPE_PHOENICIAN}, // judean
    {{50, 50, 0}, {FIGURE_ENEMY_SELEUCID_SWORDSMAN, FIGURE_ENEMY_SELEUCID_SPEAR_THROWER, 0}, FORMATION_DOUBLE_LINE_1, ENEMY_IMG_TYPE_PHOENICIAN}, // seleucid
    {{100, 0, 0}, {FIGURE_ENEMY_CAESAR_LEGIONARY, 0, 0}, FORMATION_TORTOISE, ENEMY_IMG_TYPE_CAESAR} // caesar
};

static struct {
    int items[MAX_QUEUE];
    int head;
    int tail;
} water_supply_queue;

static struct {
    int total_routes_calculated;
    int enemy_routes_calculated;
} stats = { 0, 0 };

static struct {
    int head;
    int tail;
    int items[MAX_QUEUE_ROUTING];
} routing_queue;

static struct {
    int items[MAX_QUEUE];
    int head;
    int tail;
} road_network_queue;

struct terrain_image_context {
    unsigned char tiles[MAX_TILES_TERRAIN];
    unsigned char offset_for_orientation[4];
    unsigned char aqueduct_offset;
    unsigned char max_item_offset;
    unsigned char current_item_offset;
};

// 0 = no match
// 1 = match
// 2 = don't care
static struct terrain_image_context terrain_images_water[48] = {
    {{1, 2, 1, 2, 1, 2, 1, 2}, {79, 79, 79, 79}, 0, 1, 0},
    {{1, 2, 1, 2, 1, 2, 0, 2}, {47, 46, 45, 44}, 0, 1, 0},
    {{0, 2, 1, 2, 1, 2, 1, 2}, {44, 47, 46, 45}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 2, 1, 2}, {45, 44, 47, 46}, 0, 1, 0},
    {{1, 2, 1, 2, 0, 2, 1, 2}, {46, 45, 44, 47}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 2, 0, 2}, {40, 42, 40, 42}, 0, 2, 0},
    {{0, 2, 1, 2, 0, 2, 1, 2}, {42, 40, 42, 40}, 0, 2, 0},
    {{1, 2, 1, 2, 0, 0, 0, 2}, {32, 28, 24, 36}, 0, 4, 0},
    {{0, 2, 1, 2, 1, 2, 0, 0}, {36, 32, 28, 24}, 0, 4, 0},
    {{0, 0, 0, 2, 1, 2, 1, 2}, {24, 36, 32, 28}, 0, 4, 0},
    {{1, 2, 0, 0, 0, 2, 1, 2}, {28, 24, 36, 32}, 0, 4, 0},
    {{1, 2, 1, 2, 0, 1, 0, 2}, {77, 76, 75, 78}, 0, 1, 0},
    {{0, 2, 1, 2, 1, 2, 0, 1}, {78, 77, 76, 75}, 0, 1, 0},
    {{0, 1, 0, 2, 1, 2, 1, 2}, {75, 78, 77, 76}, 0, 1, 0},
    {{1, 2, 0, 1, 0, 2, 1, 2}, {76, 75, 78, 77}, 0, 1, 0},
    {{1, 2, 0, 0, 0, 0, 0, 2}, {16, 12, 8, 20}, 0, 4, 0},
    {{0, 2, 1, 2, 0, 0, 0, 0}, {20, 16, 12, 8}, 0, 4, 0},
    {{0, 0, 0, 2, 1, 2, 0, 0}, {8, 20, 16, 12}, 0, 4, 0},
    {{0, 0, 0, 0, 0, 2, 1, 2}, {12, 8, 20, 16}, 0, 4, 0},
    {{1, 2, 0, 1, 0, 0, 0, 2}, {69, 66, 63, 72}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 1, 0, 0}, {72, 69, 66, 63}, 0, 1, 0},
    {{0, 0, 0, 2, 1, 2, 0, 1}, {63, 72, 69, 66}, 0, 1, 0},
    {{0, 1, 0, 0, 0, 2, 1, 2}, {66, 63, 72, 69}, 0, 1, 0},
    {{1, 2, 0, 0, 0, 1, 0, 2}, {70, 67, 64, 73}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 0, 0, 1}, {73, 70, 67, 64}, 0, 1, 0},
    {{0, 1, 0, 2, 1, 2, 0, 0}, {64, 73, 70, 67}, 0, 1, 0},
    {{0, 0, 0, 1, 0, 2, 1, 2}, {67, 64, 73, 70}, 0, 1, 0},
    {{1, 2, 0, 1, 0, 1, 0, 2}, {71, 68, 65, 74}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 1, 0, 1}, {74, 71, 68, 65}, 0, 1, 0},
    {{0, 1, 0, 2, 1, 2, 0, 1}, {65, 74, 71, 68}, 0, 1, 0},
    {{0, 1, 0, 1, 0, 2, 1, 2}, {68, 65, 74, 71}, 0, 1, 0},
    {{0, 1, 0, 1, 0, 1, 0, 1}, {62, 62, 62, 62}, 0, 1, 0},
    {{0, 1, 0, 1, 0, 1, 0, 0}, {60, 59, 58, 61}, 0, 1, 0},
    {{0, 0, 0, 1, 0, 1, 0, 1}, {61, 60, 59, 58}, 0, 1, 0},
    {{0, 1, 0, 0, 0, 1, 0, 1}, {58, 61, 60, 59}, 0, 1, 0},
    {{0, 1, 0, 1, 0, 0, 0, 1}, {59, 58, 61, 60}, 0, 1, 0},
    {{0, 1, 0, 0, 0, 1, 0, 0}, {48, 49, 48, 49}, 0, 1, 0},
    {{0, 0, 0, 1, 0, 0, 0, 1}, {49, 48, 49, 48}, 0, 1, 0},
    {{0, 1, 0, 1, 0, 0, 0, 0}, {56, 55, 54, 57}, 0, 1, 0},
    {{0, 0, 0, 1, 0, 1, 0, 0}, {57, 56, 55, 54}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 1, 0, 1}, {54, 57, 56, 55}, 0, 1, 0},
    {{0, 1, 0, 0, 0, 0, 0, 1}, {55, 54, 57, 56}, 0, 1, 0},
    {{0, 1, 0, 0, 0, 0, 0, 0}, {52, 51, 50, 53}, 0, 1, 0},
    {{0, 0, 0, 1, 0, 0, 0, 0}, {53, 52, 51, 50}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 1, 0, 0}, {50, 53, 52, 51}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 0, 0, 1}, {51, 50, 53, 52}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0}, 0, 6, 0},
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0}, 0, 0, 0},
};

static struct terrain_image_context terrain_images_wall[48] = {
    {{1, 2, 1, 2, 1, 2, 1, 2}, {26, 26, 26, 26}, 0, 1, 0},
    {{1, 2, 1, 2, 1, 2, 0, 2}, {15, 10, 5, 16}, 0, 1, 0},
    {{0, 2, 1, 2, 1, 2, 1, 2}, {16, 15, 10, 5}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 2, 1, 2}, {5, 16, 15, 10}, 0, 1, 0},
    {{1, 2, 1, 2, 0, 2, 1, 2}, {10, 5, 16, 15}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 2, 0, 2}, {1, 4, 1, 4}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 2, 1, 2}, {4, 1, 4, 1}, 0, 1, 0},
    {{1, 2, 1, 2, 0, 0, 0, 2}, {10, 7, 5, 12}, 0, 1, 0},
    {{0, 2, 1, 2, 1, 2, 0, 0}, {12, 10, 7, 5}, 0, 1, 0},
    {{0, 0, 0, 2, 1, 2, 1, 2}, {5, 12, 10, 7}, 0, 1, 0},
    {{1, 2, 0, 0, 0, 2, 1, 2}, {7, 5, 12, 10}, 0, 1, 0},
    {{1, 2, 1, 2, 0, 1, 0, 2}, {10, 22, 5, 12}, 0, 1, 0},
    {{0, 2, 1, 2, 1, 2, 0, 1}, {12, 10, 22, 5}, 0, 1, 0},
    {{0, 1, 0, 2, 1, 2, 1, 2}, {5, 12, 10, 22}, 0, 1, 0},
    {{1, 2, 0, 1, 0, 2, 1, 2}, {22, 5, 12, 10}, 0, 1, 0},
    {{1, 2, 0, 0, 0, 0, 0, 2}, {3, 2, 1, 4}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 0, 0, 0}, {4, 3, 2, 1}, 0, 1, 0},
    {{0, 0, 0, 2, 1, 2, 0, 0}, {1, 4, 3, 2}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 2, 1, 2}, {2, 1, 4, 3}, 0, 1, 0},
    {{1, 2, 0, 1, 0, 0, 0, 2}, {22, 24, 1, 4}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 1, 0, 0}, {4, 22, 24, 1}, 0, 1, 0},
    {{0, 0, 0, 2, 1, 2, 0, 1}, {1, 4, 22, 24}, 0, 1, 0},
    {{0, 1, 0, 0, 0, 2, 1, 2}, {24, 1, 4, 22}, 0, 1, 0},
    {{1, 2, 0, 0, 0, 1, 0, 2}, {25, 22, 1, 4}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 0, 0, 1}, {4, 25, 22, 1}, 0, 1, 0},
    {{0, 1, 0, 2, 1, 2, 0, 0}, {1, 4, 25, 22}, 0, 1, 0},
    {{0, 0, 0, 1, 0, 2, 1, 2}, {22, 1, 4, 25}, 0, 1, 0},
    {{1, 2, 0, 1, 0, 1, 0, 2}, {22, 22, 1, 4}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 1, 0, 1}, {4, 22, 22, 1}, 0, 1, 0},
    {{0, 1, 0, 2, 1, 2, 0, 1}, {1, 4, 22, 22}, 0, 1, 0},
    {{0, 1, 0, 1, 0, 2, 1, 2}, {22, 1, 4, 22}, 0, 1, 0},
    {{0, 1, 0, 1, 0, 1, 0, 1}, {22, 22, 22, 22}, 0, 1, 0},
    {{0, 1, 0, 1, 0, 1, 0, 0}, {22, 22, 23, 22}, 0, 1, 0},
    {{0, 0, 0, 1, 0, 1, 0, 1}, {22, 22, 22, 23}, 0, 1, 0},
    {{0, 1, 0, 0, 0, 1, 0, 1}, {23, 22, 22, 22}, 0, 1, 0},
    {{0, 1, 0, 1, 0, 0, 0, 1}, {22, 23, 22, 22}, 0, 1, 0},
    {{0, 1, 0, 0, 0, 1, 0, 0}, {17, 18, 17, 18}, 0, 1, 0},
    {{0, 0, 0, 1, 0, 0, 0, 1}, {18, 17, 18, 17}, 0, 1, 0},
    {{0, 1, 0, 1, 0, 0, 0, 0}, {22, 21, 19, 22}, 0, 1, 0},
    {{0, 0, 0, 1, 0, 1, 0, 0}, {22, 22, 21, 19}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 1, 0, 1}, {19, 22, 22, 21}, 0, 1, 0},
    {{0, 1, 0, 0, 0, 0, 0, 1}, {21, 19, 22, 22}, 0, 1, 0},
    {{0, 1, 0, 0, 0, 0, 0, 0}, {21, 20, 19, 22}, 0, 1, 0},
    {{0, 0, 0, 1, 0, 0, 0, 0}, {22, 21, 20, 19}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 1, 0, 0}, {19, 22, 21, 20}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 0, 0, 1}, {20, 19, 22, 21}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0}, 0, 0, 0},
};

static struct terrain_image_context terrain_images_wall_gatehouse[10] = {
    {{1, 2, 0, 2, 0, 2, 0, 2}, {16, 15, 10, 5}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 2, 0, 2}, {5, 16, 15, 10}, 0, 1, 0},
    {{0, 2, 0, 2, 1, 2, 0, 2}, {10, 5, 16, 15}, 0, 1, 0},
    {{0, 2, 0, 2, 0, 2, 1, 2}, {15, 10, 5, 16}, 0, 1, 0},
    {{1, 2, 1, 2, 0, 2, 0, 2}, {27, 12, 28, 22}, 0, 1, 0},
    {{0, 2, 1, 2, 1, 2, 0, 2}, {22, 27, 12, 28}, 0, 1, 0},
    {{0, 2, 0, 2, 1, 2, 1, 2}, {28, 22, 27, 12}, 0, 1, 0},
    {{1, 2, 0, 2, 0, 2, 1, 2}, {12, 28, 22, 27}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 2, 0, 2}, {31, 32, 31, 32}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 2, 1, 2}, {32, 31, 32, 31}, 0, 1, 0},
};

static struct terrain_image_context terrain_images_elevation[14] = {
    {{1, 1, 1, 1, 1, 1, 1, 1}, {44, 44, 44, 44}, 2, 1, 0},
    {{1, 1, 1, 1, 1, 0, 1, 1}, {30, 18, 28, 22}, 4, 2, 0},
    {{1, 1, 1, 1, 1, 1, 1, 0}, {22, 30, 18, 28}, 4, 2, 0},
    {{1, 0, 1, 1, 1, 1, 1, 1}, {28, 22, 30, 18}, 4, 2, 0},
    {{1, 1, 1, 0, 1, 1, 1, 1}, {18, 28, 22, 30}, 4, 2, 0},
    {{1, 1, 1, 2, 2, 2, 1, 1}, {0, 8, 12, 4}, 4, 4, 0},
    {{1, 1, 1, 1, 1, 2, 2, 2}, {4, 0, 8, 12}, 4, 4, 0},
    {{2, 2, 1, 1, 1, 1, 1, 2}, {12, 4, 0, 8}, 4, 4, 0},
    {{1, 2, 2, 2, 1, 1, 1, 1}, {8, 12, 4, 0}, 4, 4, 0},
    {{1, 1, 1, 2, 2, 2, 2, 2}, {24, 16, 26, 20}, 4, 2, 0},
    {{2, 2, 1, 1, 1, 2, 2, 2}, {20, 24, 16, 26}, 4, 2, 0},
    {{2, 2, 2, 2, 1, 1, 1, 2}, {26, 20, 24, 16}, 4, 2, 0},
    {{1, 2, 2, 2, 2, 2, 1, 1}, {16, 26, 20, 24}, 4, 2, 0},
    {{2, 2, 2, 2, 2, 2, 2, 2}, {32, 32, 32, 32}, 4, 4, 0},
};

static struct terrain_image_context terrain_images_earthquake[17] = {
    {{1, 2, 1, 2, 1, 2, 1, 2}, {29, 29, 29, 29}, 0, 1, 0},
    {{1, 2, 1, 2, 1, 2, 0, 2}, {25, 28, 27, 26}, 0, 1, 0},
    {{0, 2, 1, 2, 1, 2, 1, 2}, {26, 25, 28, 27}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 2, 1, 2}, {27, 26, 25, 28}, 0, 1, 0},
    {{1, 2, 1, 2, 0, 2, 1, 2}, {28, 27, 26, 25}, 0, 1, 0},
    {{1, 2, 1, 2, 0, 2, 0, 2}, {8, 14, 12, 10}, 0, 2, 0},
    {{0, 2, 1, 2, 1, 2, 0, 2}, {10, 8, 14, 12}, 0, 2, 0},
    {{0, 2, 0, 2, 1, 2, 1, 2}, {12, 10, 8, 14}, 0, 2, 0},
    {{1, 2, 0, 2, 0, 2, 1, 2}, {14, 12, 10, 8}, 0, 2, 0},
    {{1, 2, 0, 2, 1, 2, 0, 2}, {0, 4, 0, 4}, 0, 4, 0},
    {{0, 2, 1, 2, 0, 2, 1, 2}, {4, 0, 4, 0}, 0, 4, 0},
    {{1, 2, 0, 2, 0, 2, 0, 2}, {16, 22, 18, 20}, 0, 2, 0},
    {{0, 2, 1, 2, 0, 2, 0, 2}, {20, 16, 22, 18}, 0, 2, 0},
    {{0, 2, 0, 2, 1, 2, 0, 2}, {18, 20, 16, 22}, 0, 2, 0},
    {{0, 2, 0, 2, 0, 2, 1, 2}, {22, 18, 20, 16}, 0, 2, 0},
    {{0, 2, 0, 2, 0, 2, 0, 2}, {24, 24, 24, 24}, 0, 1, 0},
    {{2, 2, 2, 2, 2, 2, 2, 2}, {24, 24, 24, 24}, 0, 1, 0},
};

static struct terrain_image_context terrain_images_dirt_road[17] = {
    {{1, 2, 1, 2, 1, 2, 1, 2}, {17, 17, 17, 17}, 0, 1, 0},
    {{1, 2, 1, 2, 1, 2, 0, 2}, {13, 16, 15, 14}, 0, 1, 0},
    {{0, 2, 1, 2, 1, 2, 1, 2}, {14, 13, 16, 15}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 2, 1, 2}, {15, 14, 13, 16}, 0, 1, 0},
    {{1, 2, 1, 2, 0, 2, 1, 2}, {16, 15, 14, 13}, 0, 1, 0},
    {{1, 2, 1, 2, 0, 2, 0, 2}, {4, 7, 6, 5}, 0, 1, 0},
    {{0, 2, 1, 2, 1, 2, 0, 2}, {5, 4, 7, 6}, 0, 1, 0},
    {{0, 2, 0, 2, 1, 2, 1, 2}, {6, 5, 4, 7}, 0, 1, 0},
    {{1, 2, 0, 2, 0, 2, 1, 2}, {7, 6, 5, 4}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 2, 0, 2}, {0, 1, 0, 1}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 2, 1, 2}, {1, 0, 1, 0}, 0, 1, 0},
    {{1, 2, 0, 2, 0, 2, 0, 2}, {8, 11, 10, 9}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 2, 0, 2}, {9, 8, 11, 10}, 0, 1, 0},
    {{0, 2, 0, 2, 1, 2, 0, 2}, {10, 9, 8, 11}, 0, 1, 0},
    {{0, 2, 0, 2, 0, 2, 1, 2}, {11, 10, 9, 8}, 0, 1, 0},
    {{0, 2, 0, 2, 0, 2, 0, 2}, {12, 12, 12, 12}, 0, 1, 0},
    {{2, 2, 2, 2, 2, 2, 2, 2}, {12, 12, 12, 12}, 0, 1, 0},
};

static struct terrain_image_context terrain_images_paved_road[48] = {
    {{1, 0, 1, 0, 1, 0, 1, 0}, {17, 17, 17, 17}, 0, 1, 0},
    {{1, 0, 1, 0, 1, 2, 0, 2}, {13, 16, 15, 14}, 0, 1, 0},
    {{1, 1, 1, 1, 1, 2, 0, 2}, {18, 21, 20, 19}, 0, 1, 0},
    {{1, 0, 1, 1, 1, 2, 0, 2}, {26, 33, 32, 31}, 0, 1, 0},
    {{1, 1, 1, 0, 1, 2, 0, 2}, {30, 29, 28, 27}, 0, 1, 0},
    {{0, 2, 1, 0, 1, 0, 1, 2}, {14, 13, 16, 15}, 0, 1, 0},
    {{0, 2, 1, 1, 1, 1, 1, 2}, {19, 18, 21, 20}, 0, 1, 0},
    {{0, 2, 1, 0, 1, 1, 1, 2}, {31, 26, 33, 32}, 0, 1, 0},
    {{0, 2, 1, 1, 1, 0, 1, 2}, {27, 30, 29, 28}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 0, 1, 0}, {15, 14, 13, 16}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 1, 1, 1}, {20, 19, 18, 21}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 0, 1, 1}, {32, 31, 26, 33}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 1, 1, 0}, {28, 27, 30, 29}, 0, 1, 0},
    {{1, 0, 1, 2, 0, 2, 1, 0}, {16, 15, 14, 13}, 0, 1, 0},
    {{1, 1, 1, 2, 0, 2, 1, 1}, {21, 20, 19, 18}, 0, 1, 0},
    {{1, 1, 1, 2, 0, 2, 1, 0}, {33, 32, 31, 26}, 0, 1, 0},
    {{1, 0, 1, 2, 0, 2, 1, 1}, {29, 28, 27, 30}, 0, 1, 0},
    {{1, 1, 1, 2, 0, 0, 0, 2}, {22, 25, 24, 23}, 0, 1, 0},
    {{0, 2, 1, 1, 1, 2, 0, 0}, {23, 22, 25, 24}, 0, 1, 0},
    {{0, 0, 0, 2, 1, 1, 1, 2}, {24, 23, 22, 25}, 0, 1, 0},
    {{1, 2, 0, 0, 0, 2, 1, 1}, {25, 24, 23, 22}, 0, 1, 0},
    {{1, 0, 1, 0, 1, 1, 1, 1}, {34, 37, 36, 35}, 0, 1, 0},
    {{1, 1, 1, 0, 1, 0, 1, 1}, {35, 34, 37, 36}, 0, 1, 0},
    {{1, 1, 1, 1, 1, 0, 1, 0}, {36, 35, 34, 37}, 0, 1, 0},
    {{1, 0, 1, 1, 1, 1, 1, 0}, {37, 36, 35, 34}, 0, 1, 0},
    {{1, 0, 1, 0, 1, 0, 1, 1}, {38, 41, 40, 39}, 0, 1, 0},
    {{1, 1, 1, 0, 1, 0, 1, 0}, {39, 38, 41, 40}, 0, 1, 0},
    {{1, 0, 1, 1, 1, 0, 1, 0}, {40, 39, 38, 41}, 0, 1, 0},
    {{1, 0, 1, 0, 1, 1, 1, 0}, {41, 40, 39, 38}, 0, 1, 0},
    {{1, 1, 1, 1, 1, 0, 1, 1}, {42, 45, 44, 43}, 0, 1, 0},
    {{1, 1, 1, 1, 1, 1, 1, 0}, {43, 42, 45, 44}, 0, 1, 0},
    {{1, 0, 1, 1, 1, 1, 1, 1}, {44, 43, 42, 45}, 0, 1, 0},
    {{1, 1, 1, 0, 1, 1, 1, 1}, {45, 44, 43, 42}, 0, 1, 0},
    {{1, 1, 1, 0, 1, 1, 1, 0}, {46, 47, 46, 47}, 0, 1, 0},
    {{1, 0, 1, 1, 1, 0, 1, 1}, {47, 46, 47, 46}, 0, 1, 0},
    {{1, 2, 1, 2, 0, 2, 0, 2}, {4, 7, 6, 5}, 0, 1, 0},
    {{0, 2, 1, 2, 1, 2, 0, 2}, {5, 4, 7, 6}, 0, 1, 0},
    {{0, 2, 0, 2, 1, 2, 1, 2}, {6, 5, 4, 7}, 0, 1, 0},
    {{1, 2, 0, 2, 0, 2, 1, 2}, {7, 6, 5, 4}, 0, 1, 0},
    {{1, 2, 0, 2, 1, 2, 0, 2}, {0, 1, 0, 1}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 2, 1, 2}, {1, 0, 1, 0}, 0, 1, 0},
    {{1, 2, 0, 2, 0, 2, 0, 2}, {8, 11, 10, 9}, 0, 1, 0},
    {{0, 2, 1, 2, 0, 2, 0, 2}, {9, 8, 11, 10}, 0, 1, 0},
    {{0, 2, 0, 2, 1, 2, 0, 2}, {10, 9, 8, 11}, 0, 1, 0},
    {{0, 2, 0, 2, 0, 2, 1, 2}, {11, 10, 9, 8}, 0, 1, 0},
    {{0, 0, 0, 0, 0, 0, 0, 0}, {12, 12, 12, 12}, 0, 1, 0},
    {{1, 1, 1, 1, 1, 1, 1, 1}, {48, 48, 48, 48}, 0, 1, 0},
    {{2, 2, 2, 2, 2, 2, 2, 2}, {12, 12, 12, 12}, 0, 1, 0},
};

static struct terrain_image_context terrain_images_aqueduct[16] = {
    {{1, 2, 1, 2, 0, 2, 0, 2}, {4, 7, 6, 5}, 7, 1, 0},
    {{0, 2, 1, 2, 1, 2, 0, 2}, {5, 4, 7, 6}, 8, 1, 0},
    {{0, 2, 0, 2, 1, 2, 1, 2}, {6, 5, 4, 7}, 9, 1, 0},
    {{1, 2, 0, 2, 0, 2, 1, 2}, {7, 6, 5, 4}, 10, 1, 0},
    {{1, 2, 0, 2, 1, 2, 0, 2}, {2, 3, 2, 3}, 5, 1, 0},
    {{0, 2, 1, 2, 0, 2, 1, 2}, {3, 2, 3, 2}, 6, 1, 0},
    {{1, 2, 0, 2, 0, 2, 0, 2}, {2, 3, 2, 3}, 1, 1, 0},
    {{0, 2, 1, 2, 0, 2, 0, 2}, {3, 2, 3, 2}, 2, 1, 0},
    {{0, 2, 0, 2, 1, 2, 0, 2}, {2, 3, 2, 3}, 3, 1, 0},
    {{0, 2, 0, 2, 0, 2, 1, 2}, {3, 2, 3, 2}, 4, 1, 0},
    {{1, 2, 1, 2, 1, 2, 0, 2}, {10, 13, 12, 11}, 11, 1, 0},
    {{0, 2, 1, 2, 1, 2, 1, 2}, {11, 10, 13, 12}, 12, 1, 0},
    {{1, 2, 0, 2, 1, 2, 1, 2}, {12, 11, 10, 13}, 13, 1, 0},
    {{1, 2, 1, 2, 0, 2, 1, 2}, {13, 12, 11, 10}, 14, 1, 0},
    {{1, 2, 1, 2, 1, 2, 1, 2}, {14, 14, 14, 14}, 15, 1, 0},
    {{2, 2, 2, 2, 2, 2, 2, 2}, {2, 2, 2, 2}, 0, 1, 0},
};

static struct {
    struct terrain_image_context *context;
    int size;
} context_pointers[] = {
    {terrain_images_water, 48},
    {terrain_images_wall, 48},
    {terrain_images_wall_gatehouse, 10},
    {terrain_images_elevation, 14},
    {terrain_images_earthquake, 17},
    {terrain_images_dirt_road, 17},
    {terrain_images_paved_road, 48},
    {terrain_images_aqueduct, 16}
};

static struct {
    int end_grid_offset;
    int length;
    int direction;
    int direction_grid_delta;
} bridge;

struct ring_tile_t {
    int x;
    int y;
    int grid_offset;
};

static struct {
    struct ring_tile_t tiles[1080];
    int index[6][7];
} desirability_data;

static struct {
    int is_scrolling;
    int constant_input;
    struct {
        int active;
        int has_started;
        struct pixel_view_coordinates_t delta;
    } drag;
    struct {
        struct speed_type_t x;
        struct speed_type_t y;
        float modifier_x;
        float modifier_y;
    } speed;
    int x_align_direction;
    int y_align_direction;
    uint32_t last_time;
    struct {
        int active;
        int x;
        int y;
        int width;
        int height;
    } limits;
} scroll_data;

struct modifier_name_t {
    int modifier;
    char *name;
};
static struct modifier_name_t modifier_names[] = {
    {KMOD_CTRL, "Ctrl"},
    {KMOD_ALT, "Alt"},
    {KMOD_GUI, "Gui"},
    {KMOD_SHIFT, "Shift"},
    {KMOD_NONE, 0}
};

static struct {
    int capture;
    int accepted;
    int capture_numeric;
    void (*capture_numeric_callback)(int);
    char *text;
    int cursor_position;
    int length;
    int max_length;
    int allow_punctuation;
    int viewport_start;
    int viewport_end;
    int viewport_cursor_position;
    int box_width;
    int font;
} keyboard_data;

static struct {
    int is_playing;
    int is_ended;
    smacker s;
    struct {
        int width;
        int height;
        int y_scale;
        int micros_per_frame;
        uint32_t start_render_millis;
        int current_frame;
    } video;
    struct {
        int has_audio;
        int bitdepth;
        int channels;
        int rate;
    } audio;
    int restart_music;
} data_video;

static struct {
    int width;
    int height;
    int scanline_size;
    uint8_t *pixels;
} bmp_chunk;

static struct {
    int width;
    int height;
    struct {
        int x;
        int y;
    } dialog_offset;
} screen_data;

static struct {
    uint32_t *pixels;
    int width;
    int height;
} canvas;

static struct {
    int x_start;
    int x_end;
    int y_start;
    int y_end;
} clip_rectangle = { 0, 800, 0, 600 };

static struct {
    int x;
    int y;
} translation;

static struct {
    int group;
    int img_id;
    int offset;
    int num_types;
} HOUSE_IMAGE[20] = {
    {26, 2779, 0, 2}, {26, 2779, 2, 2}, {27, 2785, 0, 2}, {27, 2785, 2, 2}, {28, 2791, 0, 2}, {28, 2791, 2, 2}, {29, 2797, 0, 2}, {29, 2797, 2, 2}, {30, 2803, 0, 2}, {30, 2803, 2, 2},
    {31, 2809, 0, 2}, {31, 2809, 2, 2}, {32, 2813, 0, 2}, {32, 2813, 2, 2}, {33, 2817, 0, 1}, {33, 2817, 1, 1}, {34, 2819, 0, 1}, {34, 2819, 1, 1}, {35, 2821, 0, 1}, {35, 2821, 1, 1},
};

static struct {
    int tick; // 50 ticks in a day
    int day; // 16 days in a month
    int month; // 12 months in a year
    int year;
    int total_days;
} time_data;

static struct {
    int available;
    int ready;
    int timeout_ticks;
    int building_cost;
    int num_buildings;
    int type;
    struct building_t buildings[MAX_UNDO_BUILDINGS];
} undo_data;

static struct {
    int last_check_was_valid;
    uint32_t last_update;
} speed_data;

static struct {
    int paused;
    int current_overlay;
    int previous_overlay;
} state_data = { 0, OVERLAY_NONE, OVERLAY_NONE };

static struct {
    int x;
    int y;
    int offset;
} EXPAND_DIRECTION_DELTA[MAX_DIR] = { {0, 0, 0}, {-1, -1, -GRID_SIZE - 1}, {-1, 0, -1}, {0, -1, -GRID_SIZE} };

static struct {
    int x;
    int y;
    int inventory[INVENTORY_MAX];
    int population;
} merge_data;

static struct map_point_t SEAGULL_OFFSETS[] = {
    {0, 0}, {0, -2}, {-2, 0}, {1, 2}, {2, 0}, {-3, 1}, {4, -3}, {-2, 4}, {0, 0}
};

static struct {
    uint32_t last_update;
    int should_update;
} timers[MAX_ANIM_TIMERS];

struct file_piece_t {
    struct buffer_t buf;
};

struct scenario_state_t {
    struct buffer_t *graphic_ids;
    struct buffer_t *edge;
    struct buffer_t *terrain;
    struct buffer_t *bitfields;
    struct buffer_t *random;
    struct buffer_t *random_iv;
    struct buffer_t *camera;
    struct buffer_t *scenario;
    struct buffer_t *empire_objects;
};

static struct {
    int num_pieces;
    struct file_piece_t pieces[11];
    struct scenario_state_t state;
} scenario_data = { 0 };

struct savegame_state_t {
    struct buffer_t *image_grid;
    struct buffer_t *edge_grid;
    struct buffer_t *building_grid;
    struct buffer_t *terrain_grid;
    struct buffer_t *aqueduct_grid;
    struct buffer_t *figure_grid;
    struct buffer_t *bitfields_grid;
    struct buffer_t *sprite_grid;
    struct buffer_t *random_grid;
    struct buffer_t *desirability_grid;
    struct buffer_t *building_damage_grid;
    struct buffer_t *aqueduct_backup_grid;
    struct buffer_t *sprite_backup_grid;
    struct buffer_t *figures;
    struct buffer_t *route_figures;
    struct buffer_t *route_paths;
    struct buffer_t *legion_formations;
    struct buffer_t *herd_formations;
    struct buffer_t *enemy_formations;
    struct buffer_t *city_data;
    struct buffer_t *player_name;
    struct buffer_t *buildings;
    struct buffer_t *city_view_orientation;
    struct buffer_t *game_time;
    struct buffer_t *building_extra_highest_id_ever;
    struct buffer_t *random_iv;
    struct buffer_t *city_view_camera;
    struct buffer_t *building_count_culture1;
    struct buffer_t *city_graph_order;
    struct buffer_t *empire;
    struct buffer_t *empire_objects;
    struct buffer_t *building_count_industry;
    struct buffer_t *trade_prices;
    struct buffer_t *figure_names;
    struct buffer_t *culture_coverage;
    struct buffer_t *scenario;
    struct buffer_t *messages;
    struct buffer_t *message_extra;
    struct buffer_t *population_messages;
    struct buffer_t *message_counts;
    struct buffer_t *message_delays;
    struct buffer_t *building_list_burning_totals;
    struct buffer_t *city_sounds;
    struct buffer_t *building_extra_highest_id;
    struct buffer_t *figure_traders;
    struct buffer_t *building_list_burning;
    struct buffer_t *building_list_small;
    struct buffer_t *building_list_large;
    struct buffer_t *building_count_military;
    struct buffer_t *building_storages;
    struct buffer_t *building_count_culture2;
    struct buffer_t *building_count_support;
    struct buffer_t *building_barracks_tower_sentry;
    struct buffer_t *building_extra_sequence;
    struct buffer_t *routing_counters;
    struct buffer_t *building_count_culture3;
    struct buffer_t *building_extra_corrupt_houses;
    struct buffer_t *bookmarks;
};

static struct {
    int num_pieces;
    struct file_piece_t pieces[100];
    struct savegame_state_t state;
} savegame_data = { 0 };

struct trader {
    int32_t bought_amount;
    uint8_t bought_resources[RESOURCE_TYPES_MAX];
    int32_t sold_amount;
    uint8_t sold_resources[RESOURCE_TYPES_MAX];
};

static struct {
    struct trader traders[MAX_TRADERS];
    int next_index;
} figure_trader_data;

static struct {
    int figure_ids[MAX_ROUTES];
    uint8_t direction_paths[MAX_ROUTES][MAX_PATH_LENGTH];
} figure_route_data;

static struct {
    int32_t citizen_male;
    int32_t patrician;
    int32_t citizen_female;
    int32_t tax_collector;
    int32_t engineer;
    int32_t prefect;
    int32_t javelin_thrower;
    int32_t cavalry;
    int32_t legionary;
    int32_t actor;
    int32_t gladiator;
    int32_t lion_tamer;
    int32_t charioteer;
    int32_t barbarian;
    int32_t enemy_greek;
    int32_t enemy_egyptian;
    int32_t enemy_arabian;
    int32_t trader;
    int32_t ship;
} name_data;

static struct {
    int scroll_x;
    int scroll_y;
    struct empire_object_t *selected_object;
} empire_data;

static struct {
    int type;
    int id;
    int brush_size;
    int build_in_progress;
    int start_elevation;
    struct map_tile_t start_tile;
} tool_data = { TOOL_NONE, 0, 2, 0, 0, {0} };

static struct {
    uint32_t last_water_animation_time;
    int advance_water_animation;
    int image_id_water_first;
    int image_id_water_last;
} draw_context_water;

struct bitstream_t {
    uint8_t *data;
    int length;
    int index;
    int bit_index;
};

struct huffnode8_t {
    struct huffnode8_t *b[2];
    int is_leaf;
    uint8_t value;
};

struct hufftree8_t {
    struct huffnode8_t nodes[512];
    int size;
};

struct huffnode16_t {
    struct huffnode16_t *b[2];
    int is_leaf;
    uint16_t value;
};

struct hufftree16_t {
    struct huffnode16_t *root;
    struct hufftree8_t *low;
    struct hufftree8_t *high;
    uint16_t escape_codes[3];
    struct huffnode16_t *escape_nodes[3];
};

struct frame_data_t {
    uint32_t palette[MAX_PALETTE];
    uint8_t *video;
    uint8_t *audio[MAX_TRACKS];
    int audio_len[MAX_TRACKS];
};

struct smacker_t {
    int32_t width;
    int32_t height;
    int32_t frames;
    int32_t us_per_frame;
    int32_t flags;
    int32_t trees_size;
    int32_t audio_size[7];
    int32_t audio_rate[7];
    long frame_data_offset_in_file;
    long *frame_offsets;
    int32_t *frame_sizes;
    uint8_t *frame_types;
    struct hufftree16_t *mmap_tree;
    struct hufftree16_t *mclr_tree;
    struct hufftree16_t *full_tree;
    struct hufftree16_t *type_tree;
    struct frame_data_t frame_data;
    int32_t current_frame;
};

static struct {
    struct {
        int32_t offset;
        int32_t in_use;
    } text_entries[MAX_TEXT_ENTRIES];
    char text_data[MAX_TEXT_DATA];

    struct lang_message_t message_entries[MAX_MESSAGE_ENTRIES];
    char message_data[MAX_MESSAGE_DATA];
} lang_data;

static struct {
    struct resource_list_t resource_list;
    struct resource_list_t food_list;
} available;

static struct {
    int theater;
    int amphitheater;
    int colosseum;
    int hippodrome;
    int hospital;
    int school;
    int academy;
    int library;
    int religion[5];
    int oracle;
} culture_coverage;

struct warning {
    int in_use;
    uint32_t time;
    char text[MAX_TEXT];
};
static struct warning warnings[MAX_WARNINGS];

static struct {
    struct city_message_t messages[MAX_MESSAGES];
    int queue[20];
    int consecutive_message_delay;
    int next_message_sequence;
    int total_messages;
    int current_message_id;
    struct {
        int pop500;
        int pop1000;
        int pop2000;
        int pop3000;
        int pop5000;
        int pop10000;
        int pop15000;
        int pop20000;
        int pop25000;
    } population_shown;
    int message_count[MAX_MESSAGE_CATEGORIES];
    int message_delay[MAX_MESSAGE_CATEGORIES];
    uint32_t last_sound_time[MESSAGE_CAT_RIOT_COLLAPSE + 1];
    int problem_count;
    int problem_index;
    uint32_t problem_last_click_time;
    int scroll_position;
} message_data;

static struct {
    int screen_width;
    int screen_height;
    int sidebar_collapsed;
    int orientation;
    struct {
        struct pixel_view_coordinates_t tile;
        struct pixel_view_coordinates_t pixel;
    } camera;
    struct {
        int x;
        int y;
        int width_pixels;
        int height_pixels;
        int width_tiles;
        int height_tiles;
    } viewport;
    struct {
        int x_pixels;
        int y_pixels;
    } selected_tile;
} view_data;

static struct {
    int category;
    int workers;
} DEFAULT_PRIORITY[LABOR_CATEGORIES_COUNT] = {
    {LABOR_CATEGORY_ENGINEERING, 3},
    {LABOR_CATEGORY_WATER, 1},
    {LABOR_CATEGORY_PREFECTURES, 3},
    {LABOR_CATEGORY_MILITARY, 2},
    {LABOR_CATEGORY_FOOD_PRODUCTION, 4},
    {LABOR_CATEGORY_INDUSTRY_COMMERCE, 2},
    {LABOR_CATEGORY_ENTERTAINMENT, 1},
    {LABOR_CATEGORY_HEALTH_EDUCATION, 1},
    {LABOR_CATEGORY_GOVERNANCE_RELIGION, 1},
};
static struct {
    uint32_t figure_images[7][48 * 48];
    int focus_button_id;
} building_figures_data;
struct record {
    int active;
    int total;
};
static struct {
    struct record buildings[BUILDING_TYPE_MAX];
    struct record industry[RESOURCE_TYPES_MAX];
} count_data;
static struct {
    int building_ids[MAX_GRANARIES];
    int num_items;
    int total_storage_wheat;
    int total_storage_vegetables;
    int total_storage_fruit;
    int total_storage_meat;
} non_getting_granaries;

static struct {
    struct {
        int size;
        int items[MAX_SMALL];
    } small;
    struct {
        int size;
        int items[MAX_LARGE];
    } large;
    struct {
        int size;
        int items[MAX_BURNING];
        int total;
    } burning;
} building_list_data;

struct resource_data {
    int building_id;
    int distance;
    int num_buildings;
};

struct data_storage {
    int in_use;
    int building_id;
    struct building_storage_t storage;
};
static struct data_storage storages[MAX_STORAGES];
static struct {
    int x_start;
    int y_start;
    int x_end;
    int y_end;
} confirm;
static struct {
    int type;
    int in_progress;
    struct map_tile_t start;
    struct map_tile_t end;
    int cost_preview;
    struct {
        int meadow;
        int rock;
        int tree;
        int water;
        int wall;
    } required_terrain;
    int road_orientation;
    uint32_t road_last_update;
    int draw_as_constructing;
    int start_offset_x_view;
    int start_offset_y_view;
} construction_data;
static struct {
    int highest_id_in_use;
    int highest_id_ever;
    int created_sequence;
    int incorrect_houses;
    int unfixable_houses;
} extra = { 0, 0, 0, 0, 0 };
static struct figure_t *selected_units_list[7];
static int selected_unit_index = -1;
static int selected_units_count;
static struct formation_t *selected_legion_formation;
static struct building_t *selected_building;
// end structs

// start ints
static int reusable_int;
static int current_resolution_width;
static int current_resolution_height;
static float current_resolution_aspect_ratio;
static int map_y_max;
static int previous_window;
static int current_window;
static int current_window_image_button_pressed;
static int refresh_current_window;
static uint32_t button_last_update_time;
static int screen_center_x;
static int screen_center_y;
static int mouse_x;
static int mouse_y;
static int scrollbar_up_arrow_pressed;
static int scrollbar_down_arrow_pressed;
static int scrollbar_dot_y;
static int scrollbar_position;
static int is_dragging_scroll;
static int scrollbar_position_adjustment;
static int MISSILE_LAUNCHER_OFFSETS[128] = {
    0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
static int HERD_FORMATION_LAYOUT_POSITION_X_OFFSETS[MAX_FORMATION_FIGURES] = {
    0, 2, -1, 1, 1, -1, 3, -2, 0, -4, -1, 0, 1, 4, 2, -5
};
static int HERD_FORMATION_LAYOUT_POSITION_Y_OFFSETS[MAX_FORMATION_FIGURES] = {
    0, 1, -1, 1, 0, 1, 1, -1, 2, 0, 3, 5, 4, 0, 3, 2
};
static int ADJACENT_OFFSETS[2][4][7] = {
    {
        {OFFSET(-1, 0), OFFSET(-1, -1), OFFSET(-1, -2), OFFSET(0, -2), OFFSET(1, -2)},
        {OFFSET(0, -1), OFFSET(1, -1), OFFSET(2, -1), OFFSET(2, 0), OFFSET(2, 1)},
        {OFFSET(1, 0), OFFSET(1, 1), OFFSET(1, 2), OFFSET(0, 2), OFFSET(-1, 2)},
        {OFFSET(0, 1), OFFSET(-1, 1), OFFSET(-2, 1), OFFSET(-2, 0), OFFSET(-2, -1)}
    },
    {
        {OFFSET(-1, 0), OFFSET(-1, -1), OFFSET(-1, -2), OFFSET(-1, -3), OFFSET(0, -3),  OFFSET(1, -3), OFFSET(2, -3)},
        {OFFSET(0, -1), OFFSET(1, -1), OFFSET(2, -1), OFFSET(3, -1), OFFSET(3, 0),  OFFSET(3, 1), OFFSET(3, 2)},
        {OFFSET(1, 0), OFFSET(1, 1), OFFSET(1, 2), OFFSET(1, 3), OFFSET(0, 3),  OFFSET(-1, 3), OFFSET(-2, 3)},
        {OFFSET(0, 1), OFFSET(-1, 1), OFFSET(-2, 1), OFFSET(-3, 1), OFFSET(-3, 0),  OFFSET(-3, -1), OFFSET(-3, -2)}
    }
};
static   int X_VIEW_OFFSETS[MAX_TILES_BUILDING_PREVIEW] = {
    0,
    -30, 30, 0,
    -60, 60, -30, 30, 0,
    -90, 90, -60, 60, -30, 30, 0,
    -120, 120, -90, 90, -60, 60, -30, 30, 0
};
static   int Y_VIEW_OFFSETS[MAX_TILES_BUILDING_PREVIEW] = {
    0,
    15, 15, 30,
    30, 30, 45, 45, 60,
    45, 45, 60, 60, 75, 75, 90,
    60, 60, 75, 75, 90, 90, 105, 105, 120
};
static   int TILE_GRID_OFFSETS[4][MAX_TILES_BUILDING_PREVIEW] = {
    {OFFSET(0,0),
    OFFSET(0,1), OFFSET(1,0), OFFSET(1,1),
    OFFSET(0,2), OFFSET(2,0), OFFSET(1,2), OFFSET(2,1), OFFSET(2,2),
    OFFSET(0,3), OFFSET(3,0), OFFSET(1,3), OFFSET(3,1), OFFSET(2,3), OFFSET(3,2), OFFSET(3,3),
    OFFSET(0,4), OFFSET(4,0), OFFSET(1,4), OFFSET(4,1), OFFSET(2,4), OFFSET(4,2),
        OFFSET(3,4), OFFSET(4,3), OFFSET(4,4)},
    {OFFSET(0,0),
    OFFSET(-1,0), OFFSET(0,1), OFFSET(-1,1),
    OFFSET(-2,0), OFFSET(0,2), OFFSET(-2,1), OFFSET(-1,2), OFFSET(-2,2),
    OFFSET(-3,0), OFFSET(0,3), OFFSET(-3,1), OFFSET(-1,3), OFFSET(-3,2), OFFSET(-2,3), OFFSET(-3,3),
    OFFSET(-4,0), OFFSET(0,4), OFFSET(-4,1), OFFSET(-1,4), OFFSET(-4,2), OFFSET(-2,4),
        OFFSET(-4,3), OFFSET(-3,4), OFFSET(-4,4)},
    {OFFSET(0,0),
    OFFSET(0,-1), OFFSET(-1,0), OFFSET(-1,-1),
    OFFSET(0,-2), OFFSET(-2,0), OFFSET(-1,-2), OFFSET(-2,-1), OFFSET(-2,-2),
    OFFSET(0,-3), OFFSET(-3,0), OFFSET(-1,-3), OFFSET(-3,-1), OFFSET(-2,-3), OFFSET(-3,-2), OFFSET(-3,-3),
    OFFSET(0,-4), OFFSET(-4,0), OFFSET(-1,-4), OFFSET(-4,-1), OFFSET(-2,-4), OFFSET(-4,-2),
        OFFSET(-3,-4), OFFSET(-4,-3), OFFSET(-4,-4)},
    {OFFSET(0,0),
    OFFSET(1,0), OFFSET(0,-1), OFFSET(1,-1),
    OFFSET(2,0), OFFSET(0,-2), OFFSET(2,-1), OFFSET(1,-2), OFFSET(2,-2),
    OFFSET(3,0), OFFSET(0,-3), OFFSET(3,-1), OFFSET(1,-3), OFFSET(3,-2), OFFSET(2,-3), OFFSET(3,-3),
    OFFSET(4,0), OFFSET(0,-4), OFFSET(4,-1), OFFSET(1,-4), OFFSET(4,-2), OFFSET(2,-4),
        OFFSET(4,-3), OFFSET(3,-4), OFFSET(4,-4)},
};
static int FORT_GROUND_GRID_OFFSETS[4] = { OFFSET(3,-1), OFFSET(4,-1), OFFSET(4,0), OFFSET(3,0) };
static int FORT_GROUND_X_VIEW_OFFSETS[4] = { 120, 90, -120, -90 };
static int FORT_GROUND_Y_VIEW_OFFSETS[4] = { 30, -75, -60, 45 };
static int HIPPODROME_X_VIEW_OFFSETS[4] = { 150, 150, -150, -150 };
static int HIPPODROME_Y_VIEW_OFFSETS[4] = { 75, -75, -75, 75 };
static uint32_t ENEMY_COLOR_BY_CLIMATE[] = {
    COLOR_MINIMAP_ENEMY_CENTRAL,
    COLOR_MINIMAP_ENEMY_NORTHERN,
    COLOR_MINIMAP_ENEMY_DESERT
};
static uint32_t NOT_EXIST_MESSAGE_TIMEOUT = 500;
static int BUILDING_MENU_SUBMENU_ITEM_MAPPING[BUILD_MENU_BUTTONS_COUNT][MAX_ITEMS_PER_BUILD_MENU][MAX_ITEMS_PER_SUBMENU] = {
    { // MENU_VACANT_HOUSE
        {BUILDING_HOUSE_VACANT_LOT},
    },
    { // MENU_CLEAR_LAND
        {BUILDING_CLEAR_LAND},
    },
    { // MENU_ROAD
        {BUILDING_ROAD},
    },
    { // MENU_WATER
        {BUILDING_RESERVOIR},
        {BUILDING_AQUEDUCT},
        {BUILDING_FOUNTAIN},
        {BUILDING_WELL},
    },
    { // MENU_HEALTH
        {BUILDING_DOCTOR},
        {BUILDING_BATHHOUSE},
        {BUILDING_BARBER},
        {BUILDING_HOSPITAL},
    },
    { // MENU_TEMPLES
        {BUILDING_SMALL_TEMPLE_CERES, BUILDING_SMALL_TEMPLE_NEPTUNE, BUILDING_SMALL_TEMPLE_MERCURY, BUILDING_SMALL_TEMPLE_MARS, BUILDING_SMALL_TEMPLE_VENUS},
        {BUILDING_LARGE_TEMPLE_CERES, BUILDING_LARGE_TEMPLE_NEPTUNE, BUILDING_LARGE_TEMPLE_MERCURY, BUILDING_LARGE_TEMPLE_MARS, BUILDING_LARGE_TEMPLE_VENUS},
        {BUILDING_ORACLE},
    },
    { // MENU_EDUCATION
        {BUILDING_SCHOOL},
        {BUILDING_LIBRARY},
        {BUILDING_ACADEMY},
        {BUILDING_MISSION_POST},
    },
    { // MENU_ENTERTAINMENT
        {BUILDING_THEATER},
        {BUILDING_ACTOR_COLONY},
        {BUILDING_AMPHITHEATER},
        {BUILDING_GLADIATOR_SCHOOL},
        {BUILDING_LION_HOUSE},
        {BUILDING_COLOSSEUM},
        {BUILDING_CHARIOT_MAKER},
        {BUILDING_HIPPODROME},
    },
    { // MENU_ADMINISTRATION
        {BUILDING_GARDENS},
        {BUILDING_PLAZA},
        {BUILDING_SMALL_STATUE},
        {BUILDING_MEDIUM_STATUE},
        {BUILDING_LARGE_STATUE},
        {BUILDING_GOVERNORS_HOUSE},
        {BUILDING_GOVERNORS_VILLA},
        {BUILDING_GOVERNORS_PALACE},
        {BUILDING_FORUM},
        {BUILDING_SENATE},
        {BUILDING_TRIUMPHAL_ARCH},
    },
    { // MENU_ENGINEERING
        {BUILDING_ENGINEERS_POST},
        {BUILDING_LOW_BRIDGE},
        {BUILDING_SHIP_BRIDGE},
        {BUILDING_SHIPYARD},
        {BUILDING_WHARF},
        {BUILDING_DOCK},
    },
    { // MENU_SECURITY
        {BUILDING_PREFECTURE},
        {BUILDING_WALL},
        {BUILDING_TOWER},
        {BUILDING_GATEHOUSE},
        {BUILDING_FORT_LEGIONARIES, BUILDING_FORT_JAVELIN, BUILDING_FORT_MOUNTED},
        {BUILDING_BARRACKS},
        {BUILDING_MILITARY_ACADEMY},
    },
    { // MENU_INDUSTRY
        {BUILDING_WHEAT_FARM, BUILDING_VEGETABLE_FARM, BUILDING_FRUIT_FARM, BUILDING_PIG_FARM, BUILDING_OLIVE_FARM, BUILDING_VINES_FARM},
        {BUILDING_CLAY_PIT, BUILDING_TIMBER_YARD, BUILDING_MARBLE_QUARRY, BUILDING_IRON_MINE},
        {BUILDING_OIL_WORKSHOP, BUILDING_WINE_WORKSHOP, BUILDING_POTTERY_WORKSHOP, BUILDING_FURNITURE_WORKSHOP, BUILDING_WEAPONS_WORKSHOP},
        {BUILDING_MARKET},
        {BUILDING_GRANARY},
        {BUILDING_WAREHOUSE},
    }
};
static uint32_t last_update_time;
static int LAYOUT_OFFSETS_FROM_MAP_EDGE[][2] = {
    {4, 9}, // FORMATION_TORTOISE
    {2, 5}, // FORMATION_DOUBLE_LINE_1
    {2, 5}, // FORMATION_DOUBLE_LINE_2
    {0, 0}, // FORMATION_SINGLE_LINE_1 (not used by enemies)
    {0, 0}, // FORMATION_SINGLE_LINE_2 (not used by enemies)
    {0, 0}, // FORMATION_MOP_UP (not used by enemies)
    {0, 0}, // FORMATION_AT_REST (not used by enemies)
    {4, 11}, // FORMATION_ENEMY_MOB
    {5, 12}, // FORMATION_ENEMY_WIDE_COLUMN
};
static int LAYOUT_SPACING_BETWEEN_FORMATIONS[] = {
    3, // FORMATION_TORTOISE
    5, // FORMATION_DOUBLE_LINE_1
    5, // FORMATION_DOUBLE_LINE_2
    0, // FORMATION_SINGLE_LINE_1 (not used by enemies)
    0, // FORMATION_SINGLE_LINE_2 (not used by enemies)
    0, // FORMATION_MOP_UP (not used by enemies)
    0, // FORMATION_AT_REST (not used by enemies)
    4, // FORMATION_ENEMY_MOB
    4, // FORMATION_ENEMY_WIDE_COLUMN
};
static int RANDOM_EVENT_PROBABILITY[128] = {
    0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 3, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 2, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,
    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 4, 0, 0,
    0, 0, 3, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0
};
static int route_through_building_id;
static int aqueduct_include_construction = 0;
static int direction_path[MAX_PATH];
static int ROUTE_OFFSETS[] = { -162, 1, 162, -1, -161, 163, 161, -163 };
static int ADJACENT_OFFSETS_ROUTING[] = { -GRID_SIZE, 1, GRID_SIZE, -1 };
static int DIRECTION_DELTA[] = {
    -OFFSET(0,1), OFFSET(1,-1), 1, OFFSET(1,1), OFFSET(0,1), OFFSET(-1,1), -1, -OFFSET(1,1)
};
static int ADJACENT_OFFSETS_MAP_GRID[][21] = {
    {0},
    {OFFSET(0,-1), OFFSET(1,0), OFFSET(0,1), OFFSET(-1,0), 0},
    {OFFSET(0,-1), OFFSET(1,-1), OFFSET(2,0), OFFSET(2,1), OFFSET(1,2), OFFSET(0,2), OFFSET(-1,1), OFFSET(-1,0), 0},
    {
        OFFSET(0,-1), OFFSET(1,-1), OFFSET(2,-1),
        OFFSET(3,0), OFFSET(3,1), OFFSET(3,2),
        OFFSET(2,3), OFFSET(1,3), OFFSET(0,3),
        OFFSET(-1,2), OFFSET(-1,1), OFFSET(-1,0), 0
    },
    {
        OFFSET(0,-1), OFFSET(1,-1), OFFSET(2,-1), OFFSET(3,-1),
        OFFSET(4,0), OFFSET(4,1), OFFSET(4,2), OFFSET(4,3),
        OFFSET(3,4), OFFSET(2,4), OFFSET(1,4), OFFSET(0,4),
        OFFSET(-1,3), OFFSET(-1,2), OFFSET(-1,1), OFFSET(-1,0), 0
    },
    {
        OFFSET(0,-1), OFFSET(1,-1), OFFSET(2,-1), OFFSET(3,-1), OFFSET(4,-1),
        OFFSET(5,0), OFFSET(5,1), OFFSET(5,2), OFFSET(5,3), OFFSET(5,4),
        OFFSET(4,5), OFFSET(3,5), OFFSET(2,5), OFFSET(1,5), OFFSET(0,5),
        OFFSET(-1,4), OFFSET(-1,3), OFFSET(-1,2), OFFSET(-1,1), OFFSET(-1,0), 0
    },
};
static int FOOTPRINT_X_START_PER_HEIGHT[] = {
    28, 26, 24, 22, 20, 18, 16, 14, 12, 10, 8, 6, 4, 2, 0,
    0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28
};
static int FOOTPRINT_OFFSET_PER_HEIGHT[] = {
    0, 2, 8, 18, 32, 50, 72, 98, 128, 162, 200, 242, 288, 338, 392, 450,
    508, 562, 612, 658, 700, 738, 772, 802, 828, 850, 868, 882, 892, 898
};
static int fire_spread_direction = 0;
static int HOUSE_TILE_OFFSETS[] = {
    OFFSET(0,0), OFFSET(1,0), OFFSET(0,1), OFFSET(1,1), // 2x2
    OFFSET(2,0), OFFSET(2,1), OFFSET(2,2), OFFSET(1,2), OFFSET(0,2), // 3x3
    OFFSET(3,0), OFFSET(3,1), OFFSET(3,2), OFFSET(3,3), OFFSET(2,3), OFFSET(1,3), OFFSET(0,3) // 4x4
};
static uint32_t MILLIS_PER_TICK_PER_SPEED[] = {
    702, 502, 352, 242, 162, 112, 82, 57, 37, 22, 16
};
static uint32_t MILLIS_PER_HYPER_SPEED[] = {
    702, 16, 8, 5, 3, 2
};
static int FLOTSAM_TYPE_0[] = { 0, 1, 2, 3, 4, 4, 4, 3, 2, 1, 0, 0 };
static int FLOTSAM_TYPE_12[] = { 0, 1, 1, 2, 2, 3, 3, 4, 4, 4, 3, 2, 1, 0, 0, 1, 1, 2, 2, 1, 1, 0, 0, 0 };
static int FLOTSAM_TYPE_3[] = { 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };
static int BALLISTA_FIRING_OFFSETS[] = {
    0, 1, 2, 3, 4, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
static int CLOUD_IMAGE_OFFSETS[] = {
    0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2,
    2, 2, 2, 2, 3, 3, 3, 4, 4, 5, 6, 7
};
static int CRIMINAL_OFFSETS[] = {
    0, 0, 1, 2, 3, 4, 5, 6, 7, 7, 6, 5, 4, 3, 2, 1
};
static int CART_OFFSET_MULTIPLE_LOADS_FOOD[] = { 0, 0, 8, 16, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
static int CART_OFFSET_MULTIPLE_LOADS_NON_FOOD[] = { 0, 0, 0, 0, 0, 8, 0, 16, 24, 32, 40, 48, 56, 64, 72, 80 };
static int CART_OFFSET_8_LOADS_FOOD[] = { 0, 40, 48, 56, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
static int SHEEP_IMAGE_OFFSETS[] = {
    0,  0,  1,  1,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
    3,  3,  3,  3,  4,  4,  5,  5, -1, -1, -1, -1, -1, -1, -1, -1
};
static int TOWER_SENTRY_FIRING_OFFSETS[] = {
    0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
static int FLOTSAM_RESOURCE_IDS[] = {
    3, 1, 3, 2, 1, 3, 2, 3, 2, 1, 3, 3, 2, 3, 3, 3, 1, 2, 0, 1
};
static int FLOTSAM_WAIT_TICKS[] = {
    10, 50, 100, 130, 200, 250, 400, 430, 500, 600, 70, 750, 820, 830, 900, 980, 1010, 1030, 1200, 1300
};
static int CLOUD_TILE_OFFSETS[] = { 0, 0, 0, 1, 1, 2 };
static int CLOUD_CC_OFFSETS[] = { 0, 7, 14, 7, 14, 7 };
static int CLOUD_SPEED[] = {
    1, 2, 1, 3, 2, 1, 3, 2, 1, 1, 2, 1, 2, 1, 3, 1
};
static int FORMATION_LAYOUT_POSITION_X[FORMATION_MAX][MAX_FORMATION_FIGURES] = {
    {0, 1, 0, 1, -1, -1, 0, 1, -1, 2, 2, 2, 0, 1, -1, 2}, // FORMATION_TORTOISE
    {0, 0, -1, 1, -1, 1, -2, -2, 2, 2, -3, -3, 3, 3, -4, -4}, // FORMATION_DOUBLE_LINE_1
    {0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1}, // FORMATION_DOUBLE_LINE_2
    {0, 2, -2, 1, -1, 3, -3, 4, -4, 5, 6, -5, -6, 7, 8, -7}, // FORMATION_SINGLE_LINE_1
    {0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1}, // FORMATION_SINGLE_LINE_2
    {0, 1, 0, 1, 2, 2, 1, 0, 2, 3, 3, 3, 1, 2, 0, 3}, // FORMATION_MOP_UP
    {0, 1, 0, 1, 2, 2, 1, 0, 2, 3, 3, 3, 1, 2, 0, 3}, // FORMATION_AT_REST
    {0, -3, -1, 0, 2, 2, 3, 4, 2, 3, 0, -3, 2, -1, -3, 0}, // FORMATION_ENEMY_MOB
    {0, 2, 0, 2, -2, -2, 0, 2, -2, 4, 4, 4, 0, 2, -2, 4}, // FORMATION_ENEMY_WIDE_COLUMN
};
static int FORMATION_LAYOUT_POSITION_Y[FORMATION_MAX][MAX_FORMATION_FIGURES] = {
    {0, 0, 1, 1, 0, 1, -1, -1, -1, -1, 0, 1, 2, 2, 2, 2}, // FORMATION_TORTOISE
    {0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1}, // FORMATION_DOUBLE_LINE_1
    {0, -1, 1, 0, -1, 1, -2, -2, 2, 2, -3, -3, 3, 3, -4, -4}, // FORMATION_DOUBLE_LINE_2
    {0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1}, // FORMATION_SINGLE_LINE_1
    {0, -2, 2, -1, 1, -3, 3, -4, 4, -5, -6, 5, 6, -7, -8, 7}, // FORMATION_SINGLE_LINE_2
    {0, 0, 1, 1, 0, 1, 2, 2, 2, 0, 1, 2, 3, 3, 3, 3}, // FORMATION_MOP_UP
    {0, 0, 1, 1, 0, 1, 2, 2, 2, 0, 1, 2, 3, 3, 3, 3}, // FORMATION_AT_REST
    {0, -2, 0, 1, 0, 1, 1, 2, -2, -1, -3, 1, -1, 2, 2, -2}, // FORMATION_ENEMY_MOB
    {0, 0, 2, 2, 0, 2, -2, -2, -2, -2, 0, 2, 4, 4, 4, 4}, // FORMATION_ENEMY_WIDE_COLUMN
};
static int ENEMY_ATTACK_PRIORITY[4][30] = {
    {BUILDING_GRANARY, BUILDING_WAREHOUSE, BUILDING_MARKET,
    BUILDING_WHEAT_FARM, BUILDING_VEGETABLE_FARM, BUILDING_FRUIT_FARM, BUILDING_OLIVE_FARM, BUILDING_VINES_FARM, BUILDING_PIG_FARM, 0},
    {BUILDING_SENATE, BUILDING_FORUM, 0},
    {BUILDING_TRIUMPHAL_ARCH, BUILDING_SENATE, BUILDING_GOVERNORS_PALACE, BUILDING_GOVERNORS_VILLA, BUILDING_GOVERNORS_HOUSE,
    BUILDING_HIPPODROME, 0},
    {BUILDING_BARRACKS, BUILDING_MILITARY_ACADEMY, BUILDING_PREFECTURE, 0}
};
static int RIOTER_ATTACK_PRIORITY[100] = {
    BUILDING_GOVERNORS_PALACE, BUILDING_GOVERNORS_VILLA, BUILDING_GOVERNORS_HOUSE,
    BUILDING_SENATE, BUILDING_FORUM,
    BUILDING_HOUSE_LUXURY_PALACE, BUILDING_HOUSE_LARGE_PALACE, BUILDING_HOUSE_MEDIUM_PALACE, BUILDING_HOUSE_SMALL_PALACE,
    BUILDING_HOUSE_GRAND_VILLA, BUILDING_HOUSE_LARGE_VILLA, BUILDING_HOUSE_MEDIUM_VILLA, BUILDING_HOUSE_SMALL_VILLA,
    BUILDING_PREFECTURE,
    BUILDING_ACADEMY, BUILDING_LIBRARY,
    BUILDING_BATHHOUSE,
    BUILDING_HIPPODROME, BUILDING_COLOSSEUM, BUILDING_AMPHITHEATER, BUILDING_THEATER, BUILDING_GLADIATOR_SCHOOL, BUILDING_ACTOR_COLONY, BUILDING_CHARIOT_MAKER, BUILDING_LION_HOUSE,
    BUILDING_LARGE_TEMPLE_CERES, BUILDING_LARGE_TEMPLE_NEPTUNE, BUILDING_LARGE_TEMPLE_MERCURY, BUILDING_LARGE_TEMPLE_MARS, BUILDING_LARGE_TEMPLE_VENUS,
    BUILDING_HOSPITAL,
    BUILDING_HOUSE_GRAND_INSULA, BUILDING_HOUSE_LARGE_INSULA, BUILDING_HOUSE_MEDIUM_INSULA, BUILDING_HOUSE_SMALL_INSULA,
    BUILDING_WINE_WORKSHOP, BUILDING_OIL_WORKSHOP, BUILDING_WEAPONS_WORKSHOP, BUILDING_FURNITURE_WORKSHOP, BUILDING_POTTERY_WORKSHOP,
    BUILDING_GRANARY, BUILDING_WAREHOUSE, BUILDING_MARKET, BUILDING_DOCK,
    BUILDING_ENGINEERS_POST,
    BUILDING_HOUSE_LARGE_CASA, BUILDING_HOUSE_SMALL_CASA, BUILDING_HOUSE_LARGE_HOVEL, BUILDING_HOUSE_SMALL_HOVEL,
    BUILDING_CLAY_PIT, BUILDING_MARBLE_QUARRY, BUILDING_IRON_MINE, BUILDING_TIMBER_YARD,
    BUILDING_WHEAT_FARM, BUILDING_VEGETABLE_FARM, BUILDING_FRUIT_FARM, BUILDING_OLIVE_FARM, BUILDING_VINES_FARM, BUILDING_PIG_FARM,
    BUILDING_SMALL_TEMPLE_CERES, BUILDING_SMALL_TEMPLE_NEPTUNE, BUILDING_SMALL_TEMPLE_MERCURY, BUILDING_SMALL_TEMPLE_MARS, BUILDING_SMALL_TEMPLE_VENUS, BUILDING_ORACLE,
    BUILDING_RESERVOIR, BUILDING_FOUNTAIN, BUILDING_WELL,
    BUILDING_HOUSE_LARGE_SHACK, BUILDING_HOUSE_SMALL_SHACK, BUILDING_HOUSE_LARGE_TENT, BUILDING_HOUSE_SMALL_TENT,
    0
};
static int LAYOUT_REGROUP_DURATION[] = {
    10, // FORMATION_TORTOISE
    8, // FORMATION_DOUBLE_LINE_1
    8, // FORMATION_DOUBLE_LINE_2
    0, // FORMATION_SINGLE_LINE_1 (not used by enemies)
    0, // FORMATION_SINGLE_LINE_2 (not used by enemies)
    0, // FORMATION_MOP_UP (not used by enemies)
    0, // FORMATION_AT_REST (not used by enemies)
    5, // FORMATION_ENEMY_MOB
    9, // FORMATION_ENEMY_WIDE_COLUMN
};
static int CORPSE_IMAGE_OFFSETS[128] = {
    0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
};
static int CART_OFFSETS_X[] = { 13, 18, 12, 0, -13, -18, -13, 0 };
static int CART_OFFSETS_Y[] = { -7, -1, 7, 11, 6, -1, -7, -12 };
static int editor_active;
static int demand_routes_num_routes;
static int id_edit_earthquake;
static int id_edit_invasion;
static int id_edit_price_change;
static int id_demand_route;
static int demand_routes_route_ids[MAX_DEMAND_ROUTES];
static int custom_message_id;
static int empire_x_min;
static int empire_x_max;
static int empire_y_min;
static int empire_y_max;
static int empire_editor_show_battle_objects;
static int TILE_X_VIEW_OFFSETS[MAX_TILES_OFFSETS] = { 0, -30, 30, 0 };
static int TILE_Y_VIEW_OFFSETS[MAX_TILES_OFFSETS] = { 0, 15, 15, 30 };
static int TILE_GRID_OFFSETS_EDITOR[] = { 0, GRID_SIZE, 1, GRID_SIZE + 1 };
static int ACCESS_RAMP_TILE_OFFSETS_BY_ORIENTATION[4][6] = {
    {OFFSET(0,1), OFFSET(1,1), OFFSET(0,2), OFFSET(1,2), OFFSET(0,0), OFFSET(1,0)},
    {OFFSET(0,0), OFFSET(0,1), OFFSET(-1,0), OFFSET(-1,1), OFFSET(1,0), OFFSET(1,1)},
    {OFFSET(0,0), OFFSET(1,0), OFFSET(0,-1), OFFSET(1,-1), OFFSET(0,1), OFFSET(1,1)},
    {OFFSET(1,0), OFFSET(1,1), OFFSET(2,0), OFFSET(2,1), OFFSET(0,0), OFFSET(0,1)},
};
static uint32_t current_time;
static uint8_t BIT_MASKS[] = {
    0x00,
    0x01,
    0x03,
    0x07,
    0x0f,
    0x1f,
    0x3f,
    0x7f,
    0xff,
};
static uint8_t PALETTE_MAP[64] = {
    0x00, 0x04, 0x08, 0x0C, 0x10, 0x14, 0x18, 0x1C,
    0x20, 0x24, 0x28, 0x2C, 0x30, 0x34, 0x38, 0x3C,
    0x41, 0x45, 0x49, 0x4D, 0x51, 0x55, 0x59, 0x5D,
    0x61, 0x65, 0x69, 0x6D, 0x71, 0x75, 0x79, 0x7D,
    0x82, 0x86, 0x8A, 0x8E, 0x92, 0x96, 0x9A, 0x9E,
    0xA2, 0xA6, 0xAA, 0xAE, 0xB2, 0xB6, 0xBA, 0xBE,
    0xC3, 0xC7, 0xCB, 0xCF, 0xD3, 0xD7, 0xDB, 0xDF,
    0xE3, 0xE7, 0xEB, 0xEF, 0xF3, 0xF7, 0xFB, 0xFF
};
static int CHAIN_SIZE[64] = {
     1,    2,    3,    4,    5,    6,    7,    8,
     9,   10,   11,   12,   13,   14,   15,   16,
    17,   18,   19,   20,   21,   22,   23,   24,
    25,   26,   27,   28,   29,   30,   31,   32,
    33,   34,   35,   36,   37,   38,   39,   40,
    41,   42,   43,   44,   45,   46,   47,   48,
    49,   50,   51,   52,   53,   54,   55,   56,
    57,   58,   59,  128,  256,  512, 1024, 2048
};
static int SENTIMENT_PER_TAX_RATE[26] = {
    3, 2, 2, 2, 1, 1, 1, 0, 0, -1,
    -2, -2, -3, -3, -3, -5, -5, -5, -5, -6,
    -6, -6, -6, -6, -6, -6
};
static int BIRTHS_PER_AGE_DECENNIUM[10] = {
    0, 3, 16, 9, 2, 0, 0, 0, 0, 0
};
static int DEATHS_PER_HEALTH_PER_AGE_DECENNIUM[11][10] = {
    {20, 10, 5, 10, 20, 30, 50, 85, 100, 100},
    {15, 8, 4, 8, 16, 25, 45, 70, 90, 100},
    {10, 6, 2, 6, 12, 20, 30, 55, 80, 90},
    {5, 4, 0, 4, 8, 15, 25, 40, 65, 80},
    {3, 2, 0, 2, 6, 12, 20, 30, 50, 70},
    {2, 0, 0, 0, 4, 8, 15, 25, 40, 60},
    {1, 0, 0, 0, 2, 6, 12, 20, 30, 50},
    {0, 0, 0, 0, 0, 4, 8, 15, 20, 40},
    {0, 0, 0, 0, 0, 2, 6, 10, 15, 30},
    {0, 0, 0, 0, 0, 0, 4, 5, 10, 20},
    {0, 0, 0, 0, 0, 0, 0, 2, 5, 10}
};
static int view_to_grid_offset_lookup[VIEW_X_MAX][VIEW_Y_MAX];
static int should_play_sound = 1;
static int SALARY_FOR_RANK[11] = { 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144 };
static int has_warning = 0;
static int last_items_cleared;
static int tower_sentry_request = 0;
static int empire_editor_city_type_arrow_x;
static int empire_editor_resource_toggle_x;
static int mouse_drag_scroll_active;
static int mouse_scroll_initial_x;
static int mouse_scroll_initial_y;
static int mouse_scroll_x;
static int mouse_scroll_y;
static int festival_costs[3];
static int distant_battle_army_requested;
static int advisor_emperor_request_index;
static int game_lost;
static int last_selected_legion_index = -1;
// end ints

static FILE *log_file;

noreturn static void handler(int sig)
{
    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Oops, crashed with signal %d :(", sig);
    _exit(1);
}

static int string_length(char *str)
{
    int length = 0;
    while (*str) {
        length++;
        str++;
    }
    return length;
}

static void write_log(__attribute__((unused)) void *userdata, __attribute__((unused)) int category, SDL_LogPriority priority, const char *message)
{
    if (log_file) {
        if (priority == SDL_LOG_PRIORITY_ERROR) {
            fwrite("ERROR: ", sizeof(char), 7, log_file);
        } else {
            fwrite("INFO: ", sizeof(char), 6, log_file);
        }
        fwrite(message, sizeof(char), string_length(message), log_file);
        fwrite("\n", sizeof(char), 1, log_file);
        fflush(log_file);
    }
}

static int string_from_int(char *dst, int value, int force_plus_sign)
{
    int total_chars = 0;
    if (value >= 0) {
        if (force_plus_sign) {
            dst[0] = '+';
            dst++;
            total_chars = 1;
        }
    } else {
        dst[0] = '-';
        dst++;
        value = -value;
        total_chars = 1;
    }
    int num_digits;
    if (value < 10) {
        num_digits = 1;
    } else if (value < 100) {
        num_digits = 2;
    } else if (value < 1000) {
        num_digits = 3;
    } else if (value < 10000) {
        num_digits = 4;
    } else if (value < 100000) {
        num_digits = 5;
    } else if (value < 1000000) {
        num_digits = 6;
    } else if (value < 10000000) {
        num_digits = 7;
    } else if (value < 100000000) {
        num_digits = 8;
    } else if (value < 1000000000) {
        num_digits = 9;
    } else {
        num_digits = 0;
    }
    total_chars += num_digits;
    dst[num_digits] = 0;
    while (--num_digits >= 0) {
        dst[num_digits] = value % 10 + '0';
        value /= 10;
    }
    return total_chars;
}

static int number_to_string(char *str, int value, char prefix, char *postfix)
{
    int offset = 0;
    if (prefix) {
        str[offset++] = prefix;
    }
    offset += string_from_int(&str[offset], value, 0);
    if (postfix) {
        while (*postfix) {
            str[offset++] = *postfix;
            postfix++;
        }
    }
    str[offset] = 0;
    return offset;
}

static int font_letter_id(struct font_definition_t *def, char *str)
{
    if (!CHAR_TO_FONT_IMAGE_DEFAULT[(uint8_t) *str]) {
        return -1;
    }
    return CHAR_TO_FONT_IMAGE_DEFAULT[(uint8_t) *str] + def->image_offset - 1;
}

static struct image_t *image_letter(int letter_id)
{
    return &image_data_s.main[(editor_active ? 1442 : 1439) + letter_id];
}

static struct clip_info_t *graphics_get_clip_info(int x, int y, int width, int height)
{
    clip.clipped_pixels_left = 0;
    clip.clipped_pixels_right = 0;
    if (width <= 0
        || x + width <= clip_rectangle.x_start
        || x >= clip_rectangle.x_end) {
        clip.clip_x = CLIP_INVISIBLE;
        clip.visible_pixels_x = 0;
        return 0;
    }
    if (x < clip_rectangle.x_start) {
        // clipped on the left
        clip.clipped_pixels_left = clip_rectangle.x_start - x;
        if (x + width <= clip_rectangle.x_end) {
            clip.clip_x = CLIP_LEFT;
        } else {
            clip.clip_x = CLIP_BOTH;
            clip.clipped_pixels_right = x + width - clip_rectangle.x_end;
        }
    } else if (x + width > clip_rectangle.x_end) {
        clip.clip_x = CLIP_RIGHT;
        clip.clipped_pixels_right = x + width - clip_rectangle.x_end;
    } else {
        clip.clip_x = CLIP_NONE;
    }
    clip.visible_pixels_x = width - clip.clipped_pixels_left - clip.clipped_pixels_right;
    clip.clipped_pixels_top = 0;
    clip.clipped_pixels_bottom = 0;
    if (height <= 0
        || y + height <= clip_rectangle.y_start
        || y >= clip_rectangle.y_end) {
        clip.clip_y = CLIP_INVISIBLE;
    } else if (y < clip_rectangle.y_start) {
        // clipped on the top
        clip.clipped_pixels_top = clip_rectangle.y_start - y;
        if (y + height <= clip_rectangle.y_end) {
            clip.clip_y = CLIP_TOP;
        } else {
            clip.clip_y = CLIP_BOTH;
            clip.clipped_pixels_bottom = y + height - clip_rectangle.y_end;
        }
    } else if (y + height > clip_rectangle.y_end) {
        clip.clip_y = CLIP_BOTTOM;
        clip.clipped_pixels_bottom = y + height - clip_rectangle.y_end;
    } else {
        clip.clip_y = CLIP_NONE;
    }
    clip.visible_pixels_y = height - clip.clipped_pixels_top - clip.clipped_pixels_bottom;
    if (clip.clip_x == CLIP_INVISIBLE || clip.clip_y == CLIP_INVISIBLE) {
        clip.is_visible = 0;
    } else {
        clip.is_visible = 1;
    }
    return &clip;
}

static uint32_t *graphics_get_pixel(int x, int y)
{
    return &canvas.pixels[(translation.y + y) * canvas.width + (translation.x + x)];
}

static void draw_compressed_set(struct image_t *img, uint32_t *data, int x_offset, int y_offset, int height, uint32_t color)
{
    struct clip_info_t *clip = graphics_get_clip_info(x_offset, y_offset, img->width, height);
    if (!clip || !clip->is_visible) {
        return;
    }
    int unclipped = clip->clip_x == CLIP_NONE;

    for (int y = 0; y < height - clip->clipped_pixels_bottom; y++) {
        int x = 0;
        while (x < img->width) {
            uint32_t b = *data;
            data++;
            if (b == 255) {
                // transparent pixels to skip
                x += *data;
                data++;
            } else if (y < clip->clipped_pixels_top) {
                data += b;
                x += b;
            } else {
                data += b;
                uint32_t *dst = graphics_get_pixel(x_offset + x, y_offset + y);
                if (unclipped) {
                    x += b;
                    while (b) {
                        *dst = color;
                        dst++;
                        b--;
                    }
                } else {
                    while (b) {
                        if (x >= clip->clipped_pixels_left && x < img->width - clip->clipped_pixels_right) {
                            *dst = color;
                        }
                        dst++;
                        x++;
                        b--;
                    }
                }
            }
        }
    }
}

static void draw_compressed(struct image_t *img, uint32_t *data, int x_offset, int y_offset, int height)
{
    struct clip_info_t *clip = graphics_get_clip_info(x_offset, y_offset, img->width, height);
    if (!clip || !clip->is_visible) {
        return;
    }
    int unclipped = clip->clip_x == CLIP_NONE;

    for (int y = 0; y < height - clip->clipped_pixels_bottom; y++) {
        int x = 0;
        while (x < img->width) {
            uint32_t b = *data;
            data++;
            if (b == 255) {
                // transparent pixels to skip
                x += *data;
                data++;
            } else if (y < clip->clipped_pixels_top) {
                data += b;
                x += b;
            } else {
                // number of concrete pixels
                uint32_t *pixels = data;
                data += b;
                uint32_t *dst = graphics_get_pixel(x_offset + x, y_offset + y);
                if (unclipped) {
                    x += b;
                    memcpy(dst, pixels, b * sizeof(uint32_t));
                } else {
                    while (b) {
                        if (x >= clip->clipped_pixels_left && x < img->width - clip->clipped_pixels_right) {
                            *dst = *pixels;
                        }
                        dst++;
                        x++;
                        pixels++;
                        b--;
                    }
                }
            }
        }
    }
}

static void draw_uncompressed(struct image_t *img, uint32_t *data, int x_offset, int y_offset, uint32_t color, int type)
{
    struct clip_info_t *clip = graphics_get_clip_info(x_offset, y_offset, img->width, img->height);
    if (!clip || !clip->is_visible) {
        return;
    }
    data += img->width * clip->clipped_pixels_top;
    for (int y = clip->clipped_pixels_top; y < img->height - clip->clipped_pixels_bottom; y++) {
        data += clip->clipped_pixels_left;
        uint32_t *dst = graphics_get_pixel(x_offset + clip->clipped_pixels_left, y_offset + y);
        int x_max = img->width - clip->clipped_pixels_right;
        if (type == DRAW_TYPE_NONE) {
            if (img->draw.type == IMAGE_TYPE_WITH_TRANSPARENCY || img->draw.is_external) { // can be transparent
                for (int x = clip->clipped_pixels_left; x < x_max; x++, dst++) {
                    if (*data != COLOR_SG2_TRANSPARENT) {
                        *dst = *data;
                    }
                    data++;
                }
            } else {
                int num_pixels = x_max - clip->clipped_pixels_left;
                memcpy(dst, data, num_pixels * sizeof(uint32_t));
                data += num_pixels;
            }
        } else if (type == DRAW_TYPE_SET) {
            for (int x = clip->clipped_pixels_left; x < x_max; x++, dst++) {
                if (*data != COLOR_SG2_TRANSPARENT) {
                    *dst = color;
                }
                data++;
            }
        } else if (type == DRAW_TYPE_AND) {
            for (int x = clip->clipped_pixels_left; x < x_max; x++, dst++) {
                if (*data != COLOR_SG2_TRANSPARENT) {
                    *dst = *data & color;
                }
                data++;
            }
        } else if (type == DRAW_TYPE_BLEND) {
            for (int x = clip->clipped_pixels_left; x < x_max; x++, dst++) {
                if (*data != COLOR_SG2_TRANSPARENT) {
                    *dst &= color;
                }
                data++;
            }
        } else if (type == DRAW_TYPE_BLEND_ALPHA) {
            for (int x = clip->clipped_pixels_left; x < x_max; x++, dst++) {
                if (*data != COLOR_SG2_TRANSPARENT) {
                    uint32_t alpha = COMPONENT(*data, 24);
                    if (alpha == 255) {
                        *dst = color;
                    } else {
                        uint32_t s = color;
                        uint32_t d = *dst;
                        *dst = MIX_RB(s, d, alpha) | MIX_G(s, d, alpha);
                    }
                }
                data++;
            }
        }
        data += clip->clipped_pixels_right;
    }
}

static void image_draw_letter(int letter_id, int x, int y, uint32_t color)
{
    struct image_t *img = image_letter(letter_id);
    int image_id = (editor_active ? 1442 : 1439) + letter_id;
    uint32_t *data = &image_data_s.main_data[image_data_s.main[image_id].draw.offset];
    if (!data) {
        return;
    }

    if (img->draw.is_fully_compressed) {
        if (color) {
            draw_compressed_set(img, data, x, y, img->height, color);
        } else {
            draw_compressed(img, data, x, y, img->height);
        }
    } else {
        draw_uncompressed(img, data, x, y, color, color ? DRAW_TYPE_SET : DRAW_TYPE_NONE);
    }
}

static int image_y_offset_default(uint8_t c, int image_height, int line_height)
{
    int offset = image_height - line_height;
    if (offset < 0) {
        offset = 0;
    }
    if (c < 0x80 || c == 0xE7) {
        offset = 0;
    }
    return offset;
}

static struct font_definition_t DEFINITIONS_DEFAULT[] = {
    {FONT_NORMAL_PLAIN, 0, 6, 1, 11, 10, image_y_offset_default},
    {FONT_NORMAL_BLACK, 134, 6, 0, 11, 10, image_y_offset_default},
    {FONT_NORMAL_WHITE, 268, 6, 0, 11, 10, image_y_offset_default},
    {FONT_NORMAL_RED, 402, 6, 0, 11, 10, image_y_offset_default},
    {FONT_LARGE_PLAIN, 536, 8, 1, 23, 21, image_y_offset_default},
    {FONT_LARGE_BLACK, 670, 8, 0, 23, 21, image_y_offset_default},
    {FONT_LARGE_BROWN, 804, 8, 0, 24, 22, image_y_offset_default},
    {FONT_SMALL_PLAIN, 938, 4, 1, 9, 8, image_y_offset_default},
    {FONT_NORMAL_GREEN, 1072, 6, 0, 11, 10, image_y_offset_default},
    {FONT_NORMAL_BROWN, 1206, 6, 0, 11, 10, image_y_offset_default}
};

static int get_char_width(char c, int font)
{
    struct font_definition_t *def = &DEFINITIONS_DEFAULT[font];
    if (c == '\n' || c == '@') {
        return 0;
    } else if (c == ' ' || c == '_') {
        return def->space_width;
    } else {
        return def->letter_spacing + image_letter(CHAR_TO_FONT_IMAGE_DEFAULT[(uint8_t) c] + def->image_offset - 1)->width;
    }
}

static int text_draw(char *str, int x, int y, int font, uint32_t color)
{
    struct font_definition_t *def = &DEFINITIONS_DEFAULT[font];
    int current_x = x;
    while (*str) {
        int letter_id = font_letter_id(def, str);
        if (letter_id >= 0) {
            image_draw_letter(letter_id, current_x, y, color);
        }
        current_x += get_char_width(*str, font);
        str++;
    }
    current_x += def->space_width;
    return current_x - x;
}

static int text_draw_number_colored(int value, char prefix, char *postfix, int x_offset, int y_offset, int font, uint32_t color)
{
    char str[NUMBER_BUFFER_LENGTH];
    number_to_string(str, value, prefix, postfix);
    return text_draw(str, x_offset, y_offset, font, color);
}

static void graphics_draw_horizontal_line(int x1, int x2, int y, uint32_t color)
{
    if (y < clip_rectangle.y_start || y >= clip_rectangle.y_end) {
        return;
    }
    int x_min = x1 < x2 ? x1 : x2;
    int x_max = x1 < x2 ? x2 : x1;
    x_min = x_min < clip_rectangle.x_start ? clip_rectangle.x_start : x_min;
    x_max = x_max >= clip_rectangle.x_end ? clip_rectangle.x_end - 1 : x_max;
    uint32_t *pixel = graphics_get_pixel(x_min, y);
    uint32_t *end_pixel = pixel + (x_max - x_min);
    while (pixel <= end_pixel) {
        *pixel = color;
        ++pixel;
    }
}

static void graphics_fill_rect(int x, int y, int width, int height, uint32_t color)
{
    for (int yy = y; yy < height + y; yy++) {
        graphics_draw_horizontal_line(x, x + width - 1, yy, color);
    }
}

static void string_copy(char *src, char *dst, int maxlength)
{
    int length = 0;
    while (length < maxlength && *src) {
        *dst = *src;
        src++;
        dst++;
        length++;
    }
    if (length == maxlength) {
        dst--;
    }
    *dst = 0;
}

static void city_warning_show_custom(char *text)
{
    struct warning *w = 0;
    for (int i = 0; i < MAX_WARNINGS; i++) {
        if (!warnings[i].in_use) {
            w = &warnings[i];
            break;
        }
    }
    if (w) {
        w->in_use = 1;
        w->time = current_time;
        string_copy(text, w->text, MAX_TEXT);
    }
}

static void show_saved_notice(char *filename)
{
    char notice_text[FILE_NAME_LENGTH_MAX] = "Screenshot saved: ";
    int prefix_length = string_length("Screenshot saved: ");
    string_copy(filename, &notice_text[prefix_length], FILE_NAME_LENGTH_MAX - prefix_length);
    city_warning_show_custom(notice_text);
}

static void pixel(uint32_t input, uint8_t *r, uint8_t *g, uint8_t *b)
{
    uint32_t rr = (input & 0xff0000) >> 16;
    uint32_t gg = (input & 0x00ff00) >> 8;
    uint32_t bb = (input & 0x0000ff) >> 0;
    *r = (uint8_t) rr;
    *g = (uint8_t) gg;
    *b = (uint8_t) bb;
}

static int check_size(struct buffer_t *buf, int size)
{
    if (buf->index + size > buf->size) {
        buf->overflow = 1;
        return 0;
    }
    return 1;
}

static void buffer_write_i32(struct buffer_t *buf, int32_t value)
{
    if (check_size(buf, 4)) {
        buf->data[buf->index++] = value & 0xff;
        buf->data[buf->index++] = (value >> 8) & 0xff;
        buf->data[buf->index++] = (value >> 16) & 0xff;
        buf->data[buf->index++] = (value >> 24) & 0xff;
    }
}

static void buffer_write_i16(struct buffer_t *buf, int16_t value)
{
    if (check_size(buf, 2)) {
        buf->data[buf->index++] = value & 0xff;
        buf->data[buf->index++] = (value >> 8) & 0xff;
    }
}

static void buffer_write_i8(struct buffer_t *buf, int8_t value)
{
    if (check_size(buf, 1)) {
        buf->data[buf->index++] = value & 0xff;
    }
}

static void write_bmp_header(struct buffer_t *buf, int full_height)
{
    buffer_write_i8(buf, 'B');
    buffer_write_i8(buf, 'M');
    buffer_write_i32(buf, HEADER_SIZE_BMP + bmp_chunk.scanline_size * full_height); // file size
    buffer_write_i32(buf, 0); // reserved
    buffer_write_i32(buf, HEADER_SIZE_BMP); // data offset
    buffer_write_i32(buf, 12); // dib size
    buffer_write_i16(buf, (int16_t) bmp_chunk.width);
    buffer_write_i16(buf, (int16_t) full_height);
    buffer_write_i16(buf, 1); // planes
    buffer_write_i16(buf, BMP_BITS_PER_PIXEL);
}

static   char *generate_filename(int city_screenshot)
{
    static char filename[FILE_NAME_LENGTH_MAX];
    time_t curtime = time(0);
    struct tm *loctime = localtime(&curtime);
    strftime(filename, FILE_NAME_LENGTH_MAX, filename_formats[city_screenshot], loctime);
    return filename;
}

static void free_bmp_chunk(void)
{
    bmp_chunk.width = 0;
    bmp_chunk.height = 0;
    bmp_chunk.scanline_size = 0;
    free(bmp_chunk.pixels);
    bmp_chunk.pixels = 0;
}

static int create_bmp_chunk(int width, int height)
{
    free(bmp_chunk.pixels);
    if (!width || !height) {
        return 0;
    }
    int scanline_padding = 4 - (width * BMP_BYTES_PER_PIXEL) % 4;
    if (scanline_padding == 4) {
        scanline_padding = 0;
    }
    bmp_chunk.width = width;
    bmp_chunk.height = height;
    bmp_chunk.scanline_size = width * BMP_BYTES_PER_PIXEL + scanline_padding;
    bmp_chunk.pixels = (uint8_t *) malloc(bmp_chunk.scanline_size * height);
    if (!bmp_chunk.pixels) {
        free_bmp_chunk();
        return 0;
    }
    memset(bmp_chunk.pixels, 0, bmp_chunk.scanline_size * height);
    return 1;
}

static void buffer_init(struct buffer_t *buf, void *data, int size)
{
    buf->data = data;
    buf->size = size;
    buf->index = 0;
    buf->overflow = 0;
}

static void check_camera_boundaries(void)
{
    int x_min = (VIEW_X_MAX - map_data.width) / 2;
    int y_min = (VIEW_Y_MAX - 2 * map_data.height) / 2;
    if (view_data.camera.tile.x < x_min - 1) {
        view_data.camera.tile.x = x_min - 1;
        view_data.camera.pixel.x = 0;
    }
    if (view_data.camera.tile.x >= VIEW_X_MAX - x_min - view_data.viewport.width_tiles) {
        view_data.camera.tile.x = VIEW_X_MAX - x_min - view_data.viewport.width_tiles;
        view_data.camera.pixel.x = 0;
    }
    if (view_data.camera.tile.y < y_min - 2) {
        view_data.camera.tile.y = y_min - 1;
        view_data.camera.pixel.y = 0;
    }
    if (view_data.camera.tile.y >= ((VIEW_Y_MAX - y_min - view_data.viewport.height_tiles) & ~1)) {
        view_data.camera.tile.y = VIEW_Y_MAX - y_min - view_data.viewport.height_tiles;
        view_data.camera.pixel.y = 0;
    }
    view_data.camera.tile.y &= ~1;
}

static void city_view_set_camera_from_pixel_position(int x, int y)
{
    x = x < 0 ? 0 : x;
    y = y < 0 ? 0 : y;

    view_data.camera.tile.x = x / TILE_WIDTH_PIXELS;
    view_data.camera.tile.y = y / HALF_TILE_HEIGHT_PIXELS;
    view_data.camera.pixel.x = x % TILE_WIDTH_PIXELS;
    view_data.camera.pixel.y = y % TILE_HEIGHT_PIXELS;
    check_camera_boundaries();
}

static void graphics_set_clip_rectangle(int x, int y, int width, int height)
{
    clip_rectangle.x_start = x;
    clip_rectangle.x_end = x + width;
    clip_rectangle.y_start = y;
    clip_rectangle.y_end = y + height;
    // fix clip rectangle going over the edges of the screen
    if (translation.x + clip_rectangle.x_start < 0) {
        clip_rectangle.x_start = -translation.x;
    }
    if (translation.y + clip_rectangle.y_start < 0) {
        clip_rectangle.y_start = -translation.y;
    }
    if (translation.x + clip_rectangle.x_end > canvas.width) {
        clip_rectangle.x_end = canvas.width - translation.x;
    }
    if (translation.y + clip_rectangle.y_end > canvas.height) {
        clip_rectangle.y_end = canvas.height - translation.y;
    }
}

static void set_viewport(int x_offset, int y_offset, int width, int height)
{
    view_data.viewport.x = x_offset;
    view_data.viewport.y = y_offset;
    view_data.viewport.width_pixels = width - 2;
    view_data.viewport.height_pixels = height;
    view_data.viewport.width_tiles = width / TILE_WIDTH_PIXELS;
    view_data.viewport.height_tiles = height / HALF_TILE_HEIGHT_PIXELS;
}

static void clear_all_warnings(void)
{
    for (int i = 0; i < MAX_WARNINGS; i++) {
        warnings[i].in_use = 0;
    }
}

static void screen_set_resolution(int width, int height)
{
    screen_data.dialog_offset.x = (width - 640) / 2;
    screen_data.dialog_offset.y = (height - 480) / 2;
    canvas.pixels = (uint32_t *) malloc((size_t) width * height * sizeof(uint32_t));
    if (!canvas.pixels) {
        return;
    }
    memset(canvas.pixels, 0, (size_t) width * height * sizeof(uint32_t));
    canvas.width = width;
    canvas.height = height;
    graphics_set_clip_rectangle(0, 0, width, height);
    if (settings[SETTINGS_SIDEBAR_EXPANDED].config_value) {
        set_viewport(0, TOP_BAR_HEIGHT, sidebar_x_offset, current_resolution_height - 24);
    } else {
        set_viewport(0, TOP_BAR_HEIGHT, sidebar_x_offset, current_resolution_height - 24);
    }
    check_camera_boundaries();
    clear_all_warnings();
}

static char *build_message(char *msg, char *param_str, int param_int)
{
    int index = 0;
    index += snprintf(&log_buffer[index], MSG_SIZE - index, "%s", msg);
    if (param_str) {
        index += snprintf(&log_buffer[index], MSG_SIZE - index, "  %s", param_str);
    }
    if (param_int) {
        snprintf(&log_buffer[index], MSG_SIZE - index, "  %d", param_int);
    }
    return log_buffer;
}

static int select_legion_index_at(int grid_offset)
{
    int figure_id = map_figures.items[grid_offset];
    while (figure_id) {
        struct figure_t *f = &figures[figure_id];
        if (figure_properties[f->type].is_player_legion_unit || f->type == FIGURE_FORT_STANDARD) {
            return f->formation_id;
        }
        figure_id = f->next_figure_id_on_same_tile;
    }
    return -1;
}

static int map_grid_is_valid_offset(int grid_offset)
{
    return grid_offset >= 0 && grid_offset < GRID_SIZE * GRID_SIZE;
}

static int map_building_at(int grid_offset)
{
    return map_grid_is_valid_offset(grid_offset) ? buildings_grid.items[grid_offset] : 0;
}

static int map_terrain_is(int grid_offset, int terrain)
{
    return map_grid_is_valid_offset(grid_offset) && terrain_grid.items[grid_offset] & terrain;
}

static int map_is_bridge(int grid_offset)
{
    return map_terrain_is(grid_offset, TERRAIN_WATER) && sprite.items[grid_offset];
}

static int map_grid_delta(int x, int y)
{
    return y * GRID_SIZE + x;
}

static int get_x_bridge_tiles(int grid_offset)
{
    int tiles = 0;
    if (map_is_bridge(grid_offset + map_grid_delta(-1, 0))) {
        tiles++;
    }
    if (map_is_bridge(grid_offset + map_grid_delta(-2, 0))) {
        tiles++;
    }
    if (map_is_bridge(grid_offset + map_grid_delta(1, 0))) {
        tiles++;
    }
    if (map_is_bridge(grid_offset + map_grid_delta(2, 0))) {
        tiles++;
    }
    return tiles;
}

static int get_y_bridge_tiles(int grid_offset)
{
    int tiles = 0;
    if (map_is_bridge(grid_offset + map_grid_delta(0, -1))) {
        tiles++;
    }
    if (map_is_bridge(grid_offset + map_grid_delta(0, -2))) {
        tiles++;
    }
    if (map_is_bridge(grid_offset + map_grid_delta(0, 1))) {
        tiles++;
    }
    if (map_is_bridge(grid_offset + map_grid_delta(0, 2))) {
        tiles++;
    }
    return tiles;
}

static void map_sprite_clear_tile(int grid_offset)
{
    sprite.items[grid_offset] = 0;
}

static void map_bridge_remove(int grid_offset, int mark_deleted)
{
    if (!map_is_bridge(grid_offset)) {
        return;
    }

    int tiles_x = get_x_bridge_tiles(grid_offset);
    int tiles_y = get_y_bridge_tiles(grid_offset);

    int offset_up = tiles_x > tiles_y ? map_grid_delta(1, 0) : map_grid_delta(0, 1);
    // find lower end of the bridge
    while (map_is_bridge(grid_offset - offset_up)) {
        grid_offset -= offset_up;
    }

    if (mark_deleted) {
        bitfields_grid.items[grid_offset] |= BIT_DELETED;
    } else {
        map_sprite_clear_tile(grid_offset);
        terrain_grid.items[grid_offset] &= ~TERRAIN_ROAD;
    }
    while (map_is_bridge(grid_offset + offset_up)) {
        grid_offset += offset_up;
        if (mark_deleted) {
            bitfields_grid.items[grid_offset] |= BIT_DELETED;
        } else {
            map_sprite_clear_tile(grid_offset);
            terrain_grid.items[grid_offset] &= ~TERRAIN_ROAD;
        }
    }
}

static struct building_t *building_main(struct building_t *b)
{
    for (int guard = 0; guard < 9; guard++) {
        if (b->prev_part_building_id <= 0) {
            return b;
        }
        b = &all_buildings[b->prev_part_building_id];
    }
    return &all_buildings[0];
}

static void map_property_clear_constructing_and_deleted(void)
{
    for (int i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        bitfields_grid.items[i] &= BIT_NO_CONSTRUCTION_AND_DELETED;
    }
}

static void map_building_tiles_mark_deleting(int grid_offset)
{
    int building_id = map_building_at(grid_offset);
    if (!building_id) {
        map_bridge_remove(grid_offset, 1);
    } else {
        grid_offset = building_main(&all_buildings[building_id])->grid_offset;
    }
    bitfields_grid.items[grid_offset] |= BIT_DELETED;
}

static int city_building_ghost_mark_deleting(struct map_tile_t *tile)
{
    if (!configs[CONFIG_UI_VISUAL_FEEDBACK_ON_DELETE].config_value) {
        return 0;
    }
    int construction_type = construction_data.type;
    if (!tile->grid_offset || construction_data.draw_as_constructing ||
        scroll_data.is_scrolling || scroll_data.drag.active || construction_type != BUILDING_CLEAR_LAND) {
        return (construction_type == BUILDING_CLEAR_LAND);
    }
    if (!construction_data.in_progress) {
        map_property_clear_constructing_and_deleted();
    }
    map_building_tiles_mark_deleting(tile->grid_offset);
    return 1;
}

static void city_view_foreach_map_tile(map_callback *callback)
{
    int odd = 0;
    int y_view = view_data.camera.tile.y - 8;
    int y_graphic = view_data.viewport.y - 9 * HALF_TILE_HEIGHT_PIXELS - view_data.camera.pixel.y;
    for (int y = 0; y < view_data.viewport.height_tiles + 21; y++) {
        if (y_view >= 0 && y_view < VIEW_Y_MAX) {
            int x_graphic = -(4 * TILE_WIDTH_PIXELS) - view_data.camera.pixel.x;
            if (odd) {
                x_graphic += view_data.viewport.x - HALF_TILE_WIDTH_PIXELS;
            } else {
                x_graphic += view_data.viewport.x;
            }
            int x_view = view_data.camera.tile.x - 4;
            for (int x = 0; x < view_data.viewport.width_tiles + 7; x++) {
                if (x_view >= 0 && x_view < VIEW_X_MAX) {
                    int grid_offset = view_to_grid_offset_lookup[x_view][y_view];
                    callback(x_graphic, y_graphic, grid_offset);
                }
                x_graphic += TILE_WIDTH_PIXELS;
                x_view++;
            }
        }
        odd = 1 - odd;
        y_graphic += HALF_TILE_HEIGHT_PIXELS;
        y_view++;
    }
}

static void building_construction_record_view_position(int view_x, int view_y, int grid_offset)
{
    if (grid_offset == construction_data.start.grid_offset) {
        construction_data.start_offset_x_view = view_x;
        construction_data.start_offset_y_view = view_y;
    }
}

static int io_read_file_part_into_buffer(char *filepath, void *buffer, int size, int offset_in_file)
{
    int bytes_read = 0;
    fp = fopen(filepath, "rb");
    if (fp) {
        int seek_result = fseek(fp, offset_in_file, SEEK_SET);
        if (seek_result == 0) {
            bytes_read = (int) fread(buffer, 1, (size_t) size, fp);
        }
        fclose(fp);
    }
    return bytes_read;
}

static uint8_t buffer_read_u8(struct buffer_t *buf)
{
    if (check_size(buf, 1)) {
        return buf->data[buf->index++];
    } else {
        return 0;
    }
}

static uint32_t to_32_bit(uint16_t c)
{
    return ((c & 0x7c00) << 9) | ((c & 0x7000) << 4) |
        ((c & 0x3e0) << 6) | ((c & 0x380) << 1) |
        ((c & 0x1f) << 3) | ((c & 0x1c) >> 2);
}

static uint16_t buffer_read_u16(struct buffer_t *buf)
{
    if (check_size(buf, 2)) {
        uint8_t b0 = buf->data[buf->index++];
        uint8_t b1 = buf->data[buf->index++];
        return (uint16_t) (b0 | (b1 << 8));
    } else {
        return 0;
    }
}

static int convert_compressed(struct buffer_t *buf, int buf_length, uint32_t *dst)
{
    int dst_length = 0;
    while (buf_length > 0) {
        int control = buffer_read_u8(buf);
        if (control == 255) {
            // next byte = transparent pixels to skip
            *dst++ = 255;
            *dst++ = buffer_read_u8(buf);
            dst_length += 2;
            buf_length -= 2;
        } else {
            // control = number of concrete pixels
            *dst++ = control;
            for (int i = 0; i < control; i++) {
                *dst++ = to_32_bit(buffer_read_u16(buf));
            }
            dst_length += control + 1;
            buf_length -= control * 2 + 1;
        }
    }
    return dst_length;
}

static int convert_uncompressed(struct buffer_t *buf, int buf_length, uint32_t *dst)
{
    for (int i = 0; i < buf_length; i += 2) {
        *dst = to_32_bit(buffer_read_u16(buf));
        dst++;
    }
    return buf_length / 2;
}

static void file_change_extension(char *filename, const char *new_extension)
{
    char c;
    do {
        c = *filename;
        filename++;
    } while (c != '.' && c);
    if (c == '.') {
        filename[0] = new_extension[0];
        filename[1] = new_extension[1];
        filename[2] = new_extension[2];
        filename[3] = 0;
    }
}

static void draw_footprint_tile(uint32_t *data, int x_offset, int y_offset, uint32_t color_mask)
{
    if (!color_mask) {
        color_mask = COLOR_MASK_NONE;
    }
    struct clip_info_t *clip = graphics_get_clip_info(x_offset, y_offset, FOOTPRINT_WIDTH, FOOTPRINT_HEIGHT);
    if (!clip || !clip->is_visible) {
        return;
    }
    // If the current tile neither clipped nor color masked, just draw it normally
    if (clip->clip_y == CLIP_NONE && clip->clip_x == CLIP_NONE && color_mask == COLOR_MASK_NONE) {
        memcpy(graphics_get_pixel(x_offset + 28, y_offset + 0), &data[0], 2 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 26, y_offset + 1), &data[2], 6 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 24, y_offset + 2), &data[8], 10 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 22, y_offset + 3), &data[18], 14 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 20, y_offset + 4), &data[32], 18 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 18, y_offset + 5), &data[50], 22 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 16, y_offset + 6), &data[72], 26 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 14, y_offset + 7), &data[98], 30 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 12, y_offset + 8), &data[128], 34 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 10, y_offset + 9), &data[162], 38 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 8, y_offset + 10), &data[200], 42 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 6, y_offset + 11), &data[242], 46 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 4, y_offset + 12), &data[288], 50 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 2, y_offset + 13), &data[338], 54 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 0, y_offset + 14), &data[392], 58 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 0, y_offset + 15), &data[450], 58 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 2, y_offset + 16), &data[508], 54 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 4, y_offset + 17), &data[562], 50 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 6, y_offset + 18), &data[612], 46 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 8, y_offset + 19), &data[658], 42 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 10, y_offset + 20), &data[700], 38 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 12, y_offset + 21), &data[738], 34 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 14, y_offset + 22), &data[772], 30 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 16, y_offset + 23), &data[802], 26 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 18, y_offset + 24), &data[828], 22 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 20, y_offset + 25), &data[850], 18 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 22, y_offset + 26), &data[868], 14 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 24, y_offset + 27), &data[882], 10 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 26, y_offset + 28), &data[892], 6 * sizeof(uint32_t));
        memcpy(graphics_get_pixel(x_offset + 28, y_offset + 29), &data[898], 2 * sizeof(uint32_t));
        return;
    }
    int clip_left = clip->clip_x == CLIP_LEFT || clip->clip_x == CLIP_BOTH;
    int clip_right = clip->clip_x == CLIP_RIGHT || clip->clip_x == CLIP_BOTH;
    uint32_t *src = &data[FOOTPRINT_OFFSET_PER_HEIGHT[clip->clipped_pixels_top]];
    for (int y = clip->clipped_pixels_top; y < clip->clipped_pixels_top + clip->visible_pixels_y; y++) {
        int x_start = FOOTPRINT_X_START_PER_HEIGHT[y];
        int x_max = 58 - x_start * 2;
        int x_pixel_advance = 0;
        if (clip_left) {
            if (clip->clipped_pixels_left + clip->visible_pixels_x < x_start) {
                src += x_max;
                continue;
            }
            if (clip->clipped_pixels_left > x_start) {
                int pixels_to_reduce = clip->clipped_pixels_left - x_start;
                if (pixels_to_reduce >= x_max) {
                    src += x_max;
                    continue;
                }
                src += pixels_to_reduce;
                x_max -= pixels_to_reduce;
                x_start = clip->clipped_pixels_left;
            }
        }
        if (clip_right) {
            int clip_x = 58 - clip->clipped_pixels_right;
            if (clip_x < x_start) {
                src += x_max;
                continue;
            }
            if (x_start + x_max > clip_x) {
                int temp_x_max = clip_x - x_start;
                x_pixel_advance = x_max - temp_x_max;
                x_max = temp_x_max;
            }
        }
        uint32_t *buffer = graphics_get_pixel(x_offset + x_start, y_offset + y);
        if (color_mask == COLOR_MASK_NONE) {
            memcpy(buffer, src, x_max * sizeof(uint32_t));
            src += x_max + x_pixel_advance;
        } else {
            for (int x = 0; x < x_max; x++, buffer++, src++) {
                *buffer = *src & color_mask;
            }
            src += x_pixel_advance;
        }
    }
}

static uint32_t *tile_data(uint32_t *data, int index)
{
    return &data[900 * index];
}

static uint32_t *image_data(int id)
{
    if (id < 0 || id >= MAIN_ENTRIES) {
        return 0;
    }
    if (!image_data_s.main[id].draw.is_external) {
        return &image_data_s.main_data[image_data_s.main[id].draw.offset];
    } else if (id == 7972) {
        return image_data_s.empire_data;
    } else {
        struct image_t *img = &image_data_s.main[id];
        char filename[FILE_NAME_LENGTH_MAX] = "555/";
        string_copy(image_data_s.bitmaps[img->draw.bitmap_id], &filename[4], FILE_NAME_LENGTH_MAX - 6);
        file_change_extension(filename, "555");
        int size = io_read_file_part_into_buffer(
            &filename[4], image_data_s.tmp_data,
            img->draw.data_length, img->draw.offset - 1
        );
        if (!size) {
            // try in 555 dir
            size = io_read_file_part_into_buffer(
                filename, image_data_s.tmp_data,
                img->draw.data_length, img->draw.offset - 1
            );
            if (!size) {
                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("unable to load external image", image_data_s.bitmaps[img->draw.bitmap_id], id));
                return 0;
            }
        }
        struct buffer_t buf;
        buffer_init(&buf, image_data_s.tmp_data, size);
        uint32_t *dst = (uint32_t *) &image_data_s.tmp_data[4000000];
        // NB: isometric images are never external
        if (img->draw.is_fully_compressed) {
            convert_compressed(&buf, img->draw.data_length, dst);
        } else {
            convert_uncompressed(&buf, img->draw.data_length, dst);
        }
        return dst;
    }
}

static void draw_footprint_size1(int image_id, int x, int y, uint32_t color_mask)
{
    uint32_t *data = image_data(image_id);
    draw_footprint_tile(tile_data(data, 0), x, y, color_mask);
}

static void draw_footprint_size2(int image_id, int x, int y, uint32_t color_mask)
{
    uint32_t *data = image_data(image_id);
    int index = 0;
    draw_footprint_tile(tile_data(data, index++), x, y, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 30, y + 15, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 30, y + 15, color_mask);
    draw_footprint_tile(tile_data(data, index++), x, y + 30, color_mask);
}

static void draw_footprint_size3(int image_id, int x, int y, uint32_t color_mask)
{
    uint32_t *data = image_data(image_id);
    int index = 0;
    draw_footprint_tile(tile_data(data, index++), x, y, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 30, y + 15, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 30, y + 15, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 60, y + 30, color_mask);
    draw_footprint_tile(tile_data(data, index++), x, y + 30, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 60, y + 30, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 30, y + 45, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 30, y + 45, color_mask);
    draw_footprint_tile(tile_data(data, index++), x, y + 60, color_mask);
}

static void draw_footprint_size4(int image_id, int x, int y, uint32_t color_mask)
{
    uint32_t *data = image_data(image_id);
    int index = 0;
    draw_footprint_tile(tile_data(data, index++), x, y, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 30, y + 15, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 30, y + 15, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 60, y + 30, color_mask);
    draw_footprint_tile(tile_data(data, index++), x, y + 30, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 60, y + 30, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 90, y + 45, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 30, y + 45, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 30, y + 45, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 90, y + 45, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 60, y + 60, color_mask);
    draw_footprint_tile(tile_data(data, index++), x, y + 60, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 60, y + 60, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 30, y + 75, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 30, y + 75, color_mask);
    draw_footprint_tile(tile_data(data, index++), x, y + 90, color_mask);
}

static void draw_footprint_size5(int image_id, int x, int y, uint32_t color_mask)
{
    uint32_t *data = image_data(image_id);
    int index = 0;
    draw_footprint_tile(tile_data(data, index++), x, y, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 30, y + 15, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 30, y + 15, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 60, y + 30, color_mask);
    draw_footprint_tile(tile_data(data, index++), x, y + 30, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 60, y + 30, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 90, y + 45, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 30, y + 45, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 30, y + 45, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 90, y + 45, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 120, y + 60, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 60, y + 60, color_mask);
    draw_footprint_tile(tile_data(data, index++), x, y + 60, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 60, y + 60, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 120, y + 60, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 90, y + 75, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 30, y + 75, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 30, y + 75, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 90, y + 75, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 60, y + 90, color_mask);
    draw_footprint_tile(tile_data(data, index++), x, y + 90, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 60, y + 90, color_mask);
    draw_footprint_tile(tile_data(data, index++), x - 30, y + 105, color_mask);
    draw_footprint_tile(tile_data(data, index++), x + 30, y + 105, color_mask);
    draw_footprint_tile(tile_data(data, index++), x, y + 120, color_mask);
}

static struct image_t *image_get(int id)
{
    if (id >= 0 && id < MAIN_ENTRIES) {
        return &image_data_s.main[id];
    } else {
        return 0;
    }
}

static void image_draw_isometric_footprint_from_draw_tile(int image_id, int x, int y, uint32_t color_mask)
{
    struct image_t *img = image_get(image_id);
    if (img->draw.type != IMAGE_TYPE_ISOMETRIC) {
        return;
    }
    switch (img->width) {
        case 58:
            draw_footprint_size1(image_id, x, y, color_mask);
            break;
        case 118:
            draw_footprint_size2(image_id, x + 30, y - 15, color_mask);
            break;
        case 178:
            draw_footprint_size3(image_id, x + 60, y - 30, color_mask);
            break;
        case 238:
            draw_footprint_size4(image_id, x + 90, y - 45, color_mask);
            break;
        case 298:
            draw_footprint_size5(image_id, x + 120, y - 60, color_mask);
            break;
    }
}

static void city_view_get_viewport(int *x, int *y, int *width, int *height)
{
    *x = view_data.viewport.x;
    *y = view_data.viewport.y;
    *width = view_data.viewport.width_pixels;
    *height = view_data.viewport.height_pixels;
}

static int draw_building_as_deleted_2(struct building_t *b)
{
    b = building_main(b);
    return (b->id && (b->is_deleted || bitfields_grid.items[b->grid_offset] & BIT_DELETED));
}

static int building_is_house(int type)
{
    return type >= BUILDING_HOUSE_VACANT_LOT && type <= BUILDING_HOUSE_LUXURY_PALACE;
}

static int building_is_fort(int type)
{
    return type >= BUILDING_FORT_LEGIONARIES && type <= BUILDING_FORT_MOUNTED;
}

static void city_sounds__mark_building_view(int type, int num_workers, int direction)
{
    // mute city sounds during invasion
    if (city_data.figure.enemies || city_data.figure.imperial_soldiers) {
        return;
    }
    if (num_workers > 0
    || building_is_house(type)
    || type == BUILDING_RESERVOIR || type == BUILDING_AQUEDUCT || type == BUILDING_WELL || type == BUILDING_GARDENS
    || building_is_fort(type)) {
        int channel = building_properties[type].sound_channel;
        if (!channel) {
            return;
        }
        channels[channel].available = 1;
        ++channels[channel].total_views;
        ++channels[channel].direction_views[direction];
    }
}

static void draw_footprint_without_overlay(int x, int y, int grid_offset)
{
    building_construction_record_view_position(x, y, grid_offset);
    if (grid_offset < 0) {
        // Outside map: draw black tile
        image_draw_isometric_footprint_from_draw_tile(245, x, y, 0);
    } else if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
        // Valid grid_offset and leftmost tile -> draw
        int building_id = map_building_at(grid_offset);
        uint32_t color_mask = 0;
        if (building_id || map_terrain_is(grid_offset, TERRAIN_GARDEN) || map_terrain_is(grid_offset, TERRAIN_AQUEDUCT)) {
            int view_x, view_y, view_width, view_height;
            city_view_get_viewport(&view_x, &view_y, &view_width, &view_height);
            if (building_id) {
                struct building_t *b = &all_buildings[building_id];
                if (draw_building_as_deleted_2(b)) {
                    color_mask = COLOR_MASK_RED;
                }
                if (x < view_x + 100) {
                    city_sounds__mark_building_view(b->type, b->num_workers, SOUND_DIRECTION_LEFT);
                } else if (x > view_x + view_width - 100) {
                    city_sounds__mark_building_view(b->type, b->num_workers, SOUND_DIRECTION_RIGHT);
                } else {
                    city_sounds__mark_building_view(b->type, b->num_workers, SOUND_DIRECTION_CENTER);
                }
            } else if (map_terrain_is(grid_offset, TERRAIN_GARDEN)) {
                if (x < view_x + 100) {
                    city_sounds__mark_building_view(BUILDING_GARDENS, 0, SOUND_DIRECTION_LEFT);
                } else if (x > view_x + view_width - 100) {
                    city_sounds__mark_building_view(BUILDING_GARDENS, 0, SOUND_DIRECTION_RIGHT);
                } else {
                    city_sounds__mark_building_view(BUILDING_GARDENS, 0, SOUND_DIRECTION_CENTER);
                }
            } else if (map_terrain_is(grid_offset, TERRAIN_AQUEDUCT)) {
                if (x < view_x + 100) {
                    city_sounds__mark_building_view(BUILDING_AQUEDUCT, 0, SOUND_DIRECTION_LEFT);
                } else if (x > view_x + view_width - 100) {
                    city_sounds__mark_building_view(BUILDING_AQUEDUCT, 0, SOUND_DIRECTION_RIGHT);
                } else {
                    city_sounds__mark_building_view(BUILDING_AQUEDUCT, 0, SOUND_DIRECTION_CENTER);
                }
            }
        }
        int image_id = images.items[grid_offset];
        if (bitfields_grid.items[grid_offset] & BIT_CONSTRUCTION) {
            image_id = 548;
        }
        if (draw_context.advance_water_animation &&
            image_id >= draw_context.image_id_water_first &&
            image_id <= draw_context.image_id_water_last) {
            image_id++;
            if (image_id > draw_context.image_id_water_last) {
                image_id = draw_context.image_id_water_first;
            }
            images.items[grid_offset] = image_id;
        }
        image_draw_isometric_footprint_from_draw_tile(image_id, x, y, color_mask);
    }
}

static void city_view_foreach_valid_map_tile(map_callback *callback1, map_callback *callback2, map_callback *callback3)
{
    int odd = 0;
    int y_view = view_data.camera.tile.y - 8;
    int y_graphic = view_data.viewport.y - 9 * HALF_TILE_HEIGHT_PIXELS - view_data.camera.pixel.y;
    int x_graphic, x_view;
    for (int y = 0; y < view_data.viewport.height_tiles + 21; y++) {
        if (y_view >= 0 && y_view < VIEW_Y_MAX) {
            if (callback1) {
                x_graphic = -(4 * TILE_WIDTH_PIXELS) - view_data.camera.pixel.x;
                if (odd) {
                    x_graphic += view_data.viewport.x - HALF_TILE_WIDTH_PIXELS;
                } else {
                    x_graphic += view_data.viewport.x;
                }
                x_view = view_data.camera.tile.x - 4;
                for (int x = 0; x < view_data.viewport.width_tiles + 7; x++) {
                    if (x_view >= 0 && x_view < VIEW_X_MAX) {
                        int grid_offset = view_to_grid_offset_lookup[x_view][y_view];
                        if (grid_offset >= 0) {
                            callback1(x_graphic, y_graphic, grid_offset);
                        }
                    }
                    x_graphic += TILE_WIDTH_PIXELS;
                    x_view++;
                }
            }
            if (callback2) {
                x_graphic = -(4 * TILE_WIDTH_PIXELS) - view_data.camera.pixel.x;
                if (odd) {
                    x_graphic += view_data.viewport.x - HALF_TILE_WIDTH_PIXELS;
                } else {
                    x_graphic += view_data.viewport.x;
                }
                x_view = view_data.camera.tile.x - 4;
                for (int x = 0; x < view_data.viewport.width_tiles + 7; x++) {
                    if (x_view >= 0 && x_view < VIEW_X_MAX) {
                        int grid_offset = view_to_grid_offset_lookup[x_view][y_view];
                        if (grid_offset >= 0) {
                            callback2(x_graphic, y_graphic, grid_offset);
                        }
                    }
                    x_graphic += TILE_WIDTH_PIXELS;
                    x_view++;
                }
            }
            if (callback3) {
                x_graphic = -(4 * TILE_WIDTH_PIXELS) - view_data.camera.pixel.x;
                if (odd) {
                    x_graphic += view_data.viewport.x - HALF_TILE_WIDTH_PIXELS;
                } else {
                    x_graphic += view_data.viewport.x;
                }
                x_view = view_data.camera.tile.x - 4;
                for (int x = 0; x < view_data.viewport.width_tiles + 7; x++) {
                    if (x_view >= 0 && x_view < VIEW_X_MAX) {
                        int grid_offset = view_to_grid_offset_lookup[x_view][y_view];
                        if (grid_offset >= 0) {
                            callback3(x_graphic, y_graphic, grid_offset);
                        }
                    }
                    x_graphic += TILE_WIDTH_PIXELS;
                    x_view++;
                }
            }
        }
        odd = 1 - odd;
        y_graphic += HALF_TILE_HEIGHT_PIXELS;
        y_view++;
    }
}

static int map_property_multi_tile_size(int grid_offset)
{
    switch (bitfields_grid.items[grid_offset] & BIT_SIZES) {
        case BIT_SIZE2: return 2;
        case BIT_SIZE3: return 3;
        case BIT_SIZE4: return 4;
        case BIT_SIZE5: return 5;
        default: return 1;
    }
}

static int is_multi_tile_terrain(int grid_offset)
{
    return !map_building_at(grid_offset) && map_property_multi_tile_size(grid_offset) > 1;
}

static void draw_compressed_and(struct image_t *img, uint32_t *data, int x_offset, int y_offset, int height, uint32_t color)
{
    struct clip_info_t *clip = graphics_get_clip_info(x_offset, y_offset, img->width, height);
    if (!clip || !clip->is_visible) {
        return;
    }
    int unclipped = clip->clip_x == CLIP_NONE;

    for (int y = 0; y < height - clip->clipped_pixels_bottom; y++) {
        int x = 0;
        while (x < img->width) {
            uint32_t b = *data;
            data++;
            if (b == 255) {
                // transparent pixels to skip
                x += *data;
                data++;
            } else if (y < clip->clipped_pixels_top) {
                data += b;
                x += b;
            } else {
                // number of concrete pixels
                uint32_t *pixels = data;
                data += b;
                uint32_t *dst = graphics_get_pixel(x_offset + x, y_offset + y);
                if (unclipped) {
                    x += b;
                    while (b) {
                        *dst = *pixels & color;
                        dst++;
                        pixels++;
                        b--;
                    }
                } else {
                    while (b) {
                        if (x >= clip->clipped_pixels_left && x < img->width - clip->clipped_pixels_right) {
                            *dst = *pixels & color;
                        }
                        dst++;
                        x++;
                        pixels++;
                        b--;
                    }
                }
            }
        }
    }
}

static void image_draw_isometric_top_from_draw_tile(int image_id, int x, int y, uint32_t color_mask)
{
    struct image_t *img = image_get(image_id);
    if (img->draw.type != IMAGE_TYPE_ISOMETRIC) {
        return;
    }
    if (!img->draw.has_compressed_part) {
        return;
    }
    uint32_t *data = &image_data(image_id)[img->draw.uncompressed_length];

    int height = img->height;
    switch (img->width) {
        case 58:
            y -= img->height - 30;
            height -= 16;
            break;
        case 118:
            y -= img->height - 45;
            height -= 31;
            break;
        case 178:
            y -= img->height - 60;
            height -= 46;
            break;
        case 238:
            y -= img->height - 75;
            height -= 61;
            break;
        case 298:
            y -= img->height - 90;
            height -= 76;
            break;
    }
    if (!color_mask) {
        draw_compressed(img, data, x, y, height);
    } else {
        draw_compressed_and(img, data, x, y, height, color_mask);
    }
}

static void image_draw_masked(int image_id, int x, int y, uint32_t color_mask)
{
    struct image_t *img = image_get(image_id);
    uint32_t *data = image_data(image_id);
    if (!data) {
        return;
    }

    if (img->draw.type == IMAGE_TYPE_ISOMETRIC) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("use image_draw_isometric_footprint for isometric!", 0, image_id));
        return;
    }

    if (img->draw.is_fully_compressed) {
        if (!color_mask) {
            draw_compressed(img, data, x, y, img->height);
        } else {
            draw_compressed_and(img, data, x, y, img->height, color_mask);
        }
    } else {
        draw_uncompressed(img, data, x, y,
                              color_mask, color_mask ? DRAW_TYPE_AND : DRAW_TYPE_NONE);
    }
}

static void draw_top_without_overlay(int x, int y, int grid_offset)
{
    if (!(edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE)) {
        return;
    }
    struct building_t *b = &all_buildings[map_building_at(grid_offset)];
    int image_id = images.items[grid_offset];
    uint32_t color_mask = 0;
    if (draw_building_as_deleted_2(b) || (bitfields_grid.items[grid_offset] & BIT_DELETED && !is_multi_tile_terrain(grid_offset))) {
        color_mask = COLOR_MASK_RED;
    }
    image_draw_isometric_top_from_draw_tile(image_id, x, y, color_mask);
    // specific buildings
    if (b->type == BUILDING_SENATE) {
        // rating flags
        image_id = 3158;
        image_draw_masked(image_id + 1, x + 138, y + 44 - city_data.ratings.culture / 2, color_mask);
        image_draw_masked(image_id + 2, x + 168, y + 36 - city_data.ratings.prosperity / 2, color_mask);
        image_draw_masked(image_id + 3, x + 198, y + 27 - city_data.ratings.peace / 2, color_mask);
        image_draw_masked(image_id + 4, x + 228, y + 19 - city_data.ratings.favor / 2, color_mask);
        // unemployed
        image_id = 6489;
        int unemployment_pct = city_data.labor.unemployment_percentage_for_senate;
        if (unemployment_pct > 0) {
            image_draw_masked(image_id + 108, x + 80, y, color_mask);
        }
        if (unemployment_pct > 5) {
            image_draw_masked(image_id + 104, x + 230, y - 30, color_mask);
        }
        if (unemployment_pct > 10) {
            image_draw_masked(image_id + 107, x + 100, y + 20, color_mask);
        }
        if (unemployment_pct > 15) {
            image_draw_masked(image_id + 106, x + 235, y - 10, color_mask);
        }
        if (unemployment_pct > 20) {
            image_draw_masked(image_id + 106, x + 66, y + 20, color_mask);
        }
    }
    if (b->type == BUILDING_AMPHITHEATER && b->num_workers > 0) {
        image_draw_masked(3050, x + 36, y - 47, color_mask);
    }
    if (b->type == BUILDING_THEATER && b->num_workers > 0) {
        image_draw_masked(3073, x + 34, y - 22, color_mask);
    }
    if (b->type == BUILDING_COLOSSEUM && b->num_workers > 0) {
        image_draw_masked(3088, x + 70, y - 90, color_mask);
    }
    if (b->type == BUILDING_HIPPODROME && building_main(b)->num_workers > 0 && city_data.entertainment.hippodrome_has_race) {
        int subtype = b->subtype.orientation;
        int orientation = view_data.orientation;
        if ((subtype == 0 || subtype == 3) && city_data.population.population > 2000) {
            // first building part
            switch (orientation) {
                case DIR_0_TOP:
                    image_draw_masked(7795, x + 147, y - 72, color_mask);
                    break;
                case DIR_2_RIGHT:
                    image_draw_masked(7788, x + 58, y - 79, color_mask);
                    break;
                case DIR_4_BOTTOM:
                    image_draw_masked(7797, x + 119, y - 80, color_mask);
                    break;
                case DIR_6_LEFT:
                    image_draw_masked(7786, x, y - 72, color_mask);
            }
        } else if ((subtype == 1 || subtype == 4) && city_data.population.population > 100) {
            // middle building part
            switch (orientation) {
                case DIR_0_TOP:
                case DIR_4_BOTTOM:
                    image_draw_masked(7796, x + 122, y - 79, color_mask);
                    break;
                case DIR_2_RIGHT:
                case DIR_6_LEFT:
                    image_draw_masked(7787, x, y - 80, color_mask);
            }
        } else if ((subtype == 2 || subtype == 5) && city_data.population.population > 1000) {
            // last building part
            switch (orientation) {
                case DIR_0_TOP:
                    image_draw_masked(7797, x + 119, y - 80, color_mask);
                    break;
                case DIR_2_RIGHT:
                    image_draw_masked(7786, x, y - 72, color_mask);
                    break;
                case DIR_4_BOTTOM:
                    image_draw_masked(7795, x + 147, y - 72, color_mask);
                    break;
                case DIR_6_LEFT:
                    image_draw_masked(7788, x + 58, y - 79, color_mask);
                    break;
            }
        }
    }
    if (b->type == BUILDING_WINE_WORKSHOP) {
        if (b->loads_stored >= 2 || b->data.industry.has_raw_materials) {
            image_draw_masked(3024, x + 45, y + 23, color_mask);
        }
    }
    if (b->type == BUILDING_OIL_WORKSHOP) {
        if (b->loads_stored >= 2 || b->data.industry.has_raw_materials) {
            image_draw_masked(3025, x + 35, y + 15, color_mask);
        }
    }
    if (b->type == BUILDING_WEAPONS_WORKSHOP) {
        if (b->loads_stored >= 2 || b->data.industry.has_raw_materials) {
            image_draw_masked(3027, x + 46, y + 24, color_mask);
        }
    }
    if (b->type == BUILDING_FURNITURE_WORKSHOP) {
        if (b->loads_stored >= 2 || b->data.industry.has_raw_materials) {
            image_draw_masked(3026, x + 48, y + 19, color_mask);
        }
    }
    if (b->type == BUILDING_POTTERY_WORKSHOP) {
        if (b->loads_stored >= 2 || b->data.industry.has_raw_materials) {
            image_draw_masked(3028, x + 47, y + 24, color_mask);
        }
    }
}

static int figure_image_normalize_direction(int direction)
{
    int normalized_direction = direction - view_data.orientation;
    if (normalized_direction < 0) {
        normalized_direction += 8;
    }
    return normalized_direction;
}

static struct image_t *image_get_enemy(struct figure_t *f)
{
    if (f->image_id < ENEMY_ENTRIES) {
        return &image_data_s.enemy[f->enemy_image_group][f->image_id];
    } else {
        return 0;
    }
}

static void adjust_pixel_offset(struct figure_t *f, int *pixel_x, int *pixel_y)
{
    // determining x/y offset on tile
    int x_offset = 0;
    int y_offset = 0;
    if (f->use_cross_country) {
        int dir = view_data.orientation;
        if (dir == DIR_0_TOP || dir == DIR_4_BOTTOM) {
            int base_pixel_x = 2 * f->cross_country_x % 15 - 2 * f->cross_country_y % 15;
            int base_pixel_y = f->cross_country_x % 15 + f->cross_country_y % 15;
            x_offset = dir == DIR_0_TOP ? base_pixel_x : -base_pixel_x;
            y_offset = dir == DIR_0_TOP ? base_pixel_y : -base_pixel_y;
        } else {
            int base_pixel_x = 2 * f->cross_country_x % 15 + 2 * f->cross_country_y % 15;
            int base_pixel_y = f->cross_country_x % 15 - f->cross_country_y % 15;
            x_offset = dir == DIR_2_RIGHT ? base_pixel_x : -base_pixel_x;
            y_offset = dir == DIR_6_LEFT ? base_pixel_y : -base_pixel_y;
        }
        y_offset -= f->missile_offset;
    } else {
        int direction = figure_image_normalize_direction(f->direction);

        if (f->progress_on_tile >= 15) {
            x_offset = 0;
        } else {
            switch (direction) {
                case DIR_0_TOP:
                case DIR_2_RIGHT:
                    x_offset = 2 * f->progress_on_tile - 28;
                    break;
                case DIR_1_TOP_RIGHT:
                    x_offset = 4 * f->progress_on_tile - 56;
                    break;
                case DIR_4_BOTTOM:
                case DIR_6_LEFT:
                    x_offset = 28 - 2 * f->progress_on_tile;
                    break;
                case DIR_5_BOTTOM_LEFT:
                    x_offset = 56 - 4 * f->progress_on_tile;
                    break;
                default:
                    x_offset = 0;
                    break;
            }
        }
        if (f->progress_on_tile >= 15) {
            y_offset = 0;
        } else {
            switch (direction) {
                case DIR_0_TOP:
                case DIR_6_LEFT:
                    y_offset = 14 - f->progress_on_tile;
                    break;
                case DIR_2_RIGHT:
                case DIR_4_BOTTOM:
                    y_offset = f->progress_on_tile - 14;
                    break;
                case DIR_3_BOTTOM_RIGHT:
                    y_offset = 2 * f->progress_on_tile - 28;
                    break;
                case DIR_7_TOP_LEFT:
                    y_offset = 28 - 2 * f->progress_on_tile;
                    break;
                default:
                    y_offset = 0;
                    break;
            }
        }
        y_offset -= f->current_height;
    }
    x_offset += 29;
    y_offset += 15;
    struct image_t *img = (figure_properties[f->type].is_native_unit || (figure_properties[f->type].is_enemy_unit && f->type != FIGURE_ENEMY_GLADIATOR)) ? image_get_enemy(f) : image_get(f->image_id);
    *pixel_x += x_offset - img->sprite_offset_x;
    *pixel_y += y_offset - img->sprite_offset_y;
}

static void image_draw_blend_alpha(int image_id, int x, int y, uint32_t color)
{
    struct image_t *img = image_get(image_id);
    uint32_t *data = image_data(image_id);
    if (!data) {
        return;
    }

    if (img->draw.type == IMAGE_TYPE_ISOMETRIC) {
        return;
    }

    if (img->draw.is_fully_compressed) {
        struct clip_info_t *clip = graphics_get_clip_info(x, y, img->width, img->height);
        if (!clip || !clip->is_visible) {
            return;
        }
        uint32_t alpha = COMPONENT(color, 24);
        if (!alpha) {
            return;
        }
        if (alpha == 255) {
            draw_compressed_set(img, data, x, y, img->height, color);
            return;
        }
        uint32_t alpha_dst = 256 - alpha;
        uint32_t src_rb = (color & 0xff00ff) * alpha;
        uint32_t src_g = (color & 0x00ff00) * alpha;
        int unclipped = clip->clip_x == CLIP_NONE;
        for (int yy = 0; yy < img->height - clip->clipped_pixels_bottom; yy++) {
            int xx = 0;
            uint32_t *dst = graphics_get_pixel(x, y + yy);
            while (xx < img->width) {
                uint32_t b = *data;
                data++;
                if (b == 255) {
                    // transparent pixels to skip
                    xx += *data;
                    dst += *data;
                    data++;
                } else if (yy < clip->clipped_pixels_top) {
                    data += b;
                    xx += b;
                    dst += b;
                } else {
                    data += b;
                    if (unclipped) {
                        xx += b;
                        while (b) {
                            uint32_t d = *dst;
                            *dst = (((src_rb + (d & 0xff00ff) * alpha_dst) & 0xff00ff00) |
                                    ((src_g + (d & 0x00ff00) * alpha_dst) & 0x00ff0000)) >> 8;
                            b--;
                            dst++;
                        }
                    } else {
                        while (b) {
                            if (xx >= clip->clipped_pixels_left && xx < img->width - clip->clipped_pixels_right) {
                                uint32_t d = *dst;
                                *dst = (((src_rb + (d & 0xff00ff) * alpha_dst) & 0xff00ff00) |
                                       ((src_g + (d & 0x00ff00) * alpha_dst) & 0x00ff0000)) >> 8;
                            }
                            dst++;
                            xx++;
                            b--;
                        }
                    }
                }
            }
        }
    } else {
        draw_uncompressed(img, data, x, y, color, DRAW_TYPE_BLEND_ALPHA);
    }
}

static void image_draw(int image_id, int x, int y)
{
    struct image_t *img = image_get(image_id);
    uint32_t *data = image_data(image_id);
    if (!data) {
        return;
    }

    if (img->draw.is_fully_compressed) {
        draw_compressed(img, data, x, y, img->height);
    } else {
        draw_uncompressed(img, data, x, y, 0, DRAW_TYPE_NONE);
    }
}

static void draw_figure_with_cart(struct figure_t *f, int x, int y)
{
    if (f->y_offset_cart >= 0) {
        image_draw(f->image_id, x, y);
        image_draw(f->cart_image_id, x + f->x_offset_cart, y + f->y_offset_cart);
    } else {
        image_draw(f->cart_image_id, x + f->x_offset_cart, y + f->y_offset_cart);
        image_draw(f->image_id, x, y);
    }
}

static void draw_figure_city(struct figure_t *f, int x, int y, int highlight)
{
    if (f->cart_image_id) {
        switch (f->type) {
            case FIGURE_CART_PUSHER:
            case FIGURE_WAREHOUSEMAN:
            case FIGURE_LION_TAMER:
            case FIGURE_DOCKER:
            case FIGURE_NATIVE_TRADER:
            case FIGURE_IMMIGRANT:
            case FIGURE_EMIGRANT:
                draw_figure_with_cart(f, x, y);
                break;
            case FIGURE_HIPPODROME_HORSES:
                switch (view_data.orientation) {
                    case DIR_0_TOP:
                        x += 10;
                        if (f->wait_ticks_missile <= 10) {
                            y -= 2;
                        } else if (f->wait_ticks_missile <= 11) {
                            y -= 10;
                        } else if (f->wait_ticks_missile <= 12) {
                            y -= 18;
                        } else if (f->wait_ticks_missile <= 13) {
                            y -= 16;
                        } else if (f->wait_ticks_missile <= 20) {
                            y -= 14;
                        } else if (f->wait_ticks_missile <= 21) {
                            y -= 10;
                        } else {
                            y -= 2;
                        }
                        break;
                    case DIR_2_RIGHT:
                        x -= 10;
                        if (f->wait_ticks_missile <= 9) {
                            y -= 12;
                        } else if (f->wait_ticks_missile <= 10) {
                            y += 4;
                        } else if (f->wait_ticks_missile <= 11) {
                            x -= 5;
                            y += 2;
                        } else if (f->wait_ticks_missile <= 13) {
                            x -= 5;
                        } else if (f->wait_ticks_missile <= 20) {
                            y -= 2;
                        } else if (f->wait_ticks_missile <= 21) {
                            y -= 6;
                        } else {
                            y -= 12;
                        }
                        /* fall through */
                    case DIR_4_BOTTOM:
                        x += 20;
                        if (f->wait_ticks_missile <= 9) {
                            y += 4;
                        } else if (f->wait_ticks_missile <= 10) {
                            x += 10;
                            y += 4;
                        } else if (f->wait_ticks_missile <= 11) {
                            x += 10;
                            y -= 4;
                        } else if (f->wait_ticks_missile <= 13) {
                            y -= 6;
                        } else if (f->wait_ticks_missile <= 20) {
                            y -= 12;
                        } else if (f->wait_ticks_missile <= 21) {
                            y -= 10;
                        } else {
                            y -= 2;
                        }
                        break;
                    case DIR_6_LEFT:
                        x -= 10;
                        if (f->wait_ticks_missile <= 9) {
                            y -= 12;
                        } else if (f->wait_ticks_missile <= 10) {
                            y += 4;
                        } else if (f->wait_ticks_missile <= 11) {
                            y += 2;
                        } else if (f->wait_ticks_missile <= 13) {
                            // no change
                        } else if (f->wait_ticks_missile <= 20) {
                            y -= 2;
                        } else if (f->wait_ticks_missile <= 21) {
                            y -= 6;
                        } else {
                            y -= 12;
                        }
                        break;
                }
                draw_figure_with_cart(f, x, y);
                break;
            case FIGURE_FORT_STANDARD:
                if (!legion_formations[f->formation_id].in_distant_battle) {
                    // base
                    image_draw(f->image_id, x, y);
                    // flag
                    int flag_height = image_get(f->cart_image_id)->height;
                    image_draw(f->cart_image_id, x, y - flag_height);
                    // top icon
                    int icon_image_id = 5422 + legion_formations[f->formation_id].id;
                    image_draw(icon_image_id, x, y - image_get(icon_image_id)->height - flag_height);
                }
                break;
            case FIGURE_MAP_FLAG:
                // base
                image_draw(f->image_id, x, y);
                // flag
                image_draw(f->cart_image_id, x, y - image_get(f->cart_image_id)->height);
                // flag number
                int number = 0;
                int id = f->resource_id;
                if (id >= MAP_FLAG_EARTHQUAKE_MIN && id <= MAP_FLAG_EARTHQUAKE_MAX) {
                    number = id - MAP_FLAG_EARTHQUAKE_MIN + 1;
                } else if (id >= MAP_FLAG_INVASION_MIN && id <= MAP_FLAG_INVASION_MAX) {
                    number = id - MAP_FLAG_INVASION_MIN + 1;
                } else if (id >= MAP_FLAG_FISHING_MIN && id <= MAP_FLAG_FISHING_MAX) {
                    number = id - MAP_FLAG_FISHING_MIN + 1;
                } else if (id >= MAP_FLAG_HERD_MIN && id <= MAP_FLAG_HERD_MAX) {
                    number = id - MAP_FLAG_HERD_MIN + 1;
                }
                if (number > 0) {
                    text_draw_number_colored(number, 0, 0, x + 12, y + 7, FONT_NORMAL_PLAIN, COLOR_WHITE);
                }
                break;
            default:
                image_draw(f->image_id, x, y);
                break;
        }
    } else {
        if (figure_properties[f->type].is_native_unit || figure_properties[f->type].is_enemy_unit) {
            if (f->image_id > 0 && f->image_id < 801) {
                struct image_t *img = image_get_enemy(f);
                uint32_t *data = 0;
                int offset = image_data_s.enemy[f->enemy_image_group][f->image_id].draw.offset;
                if (offset > 0) {
                    data = &image_data_s.enemy_data[f->enemy_image_group][offset];
                }
                if (data) {
                    draw_compressed(img, data, x, y, img->height);
                }
            }
        } else {
            image_draw(f->image_id, x, y);
            if (highlight) {
                image_draw_blend_alpha(f->image_id, x, y, COLOR_MASK_LEGION_HIGHLIGHT);
            }
        }
    }
}

static void city_draw_figure(struct figure_t *f, int x, int y, int highlight)
{
    adjust_pixel_offset(f, &x, &y);
    draw_figure_city(f, x, y, highlight);
}

static void draw_figures_without_overlay(int x, int y, int grid_offset)
{
    int figure_id = map_grid_is_valid_offset(grid_offset) ? map_figures.items[grid_offset] : 0;
    while (figure_id) {
        struct figure_t *f = &figures[figure_id];
        if (figure_id == draw_context.selected_figure_id) {
            if (!f->is_invisible || f->height_adjusted_ticks) {
                adjust_pixel_offset(f, &x, &y);
                draw_figure_city(f, x, y, 0);
                draw_context.selected_figure_coord->x = x;
                draw_context.selected_figure_coord->y = y;
            }
        } else if (!f->is_invisible) {
            if (figure_properties[f->type].is_player_legion_unit && f->formation_id == draw_context.highlighted_formation) {
                city_draw_figure(f, x, y, 1);
            } else {
                city_draw_figure(f, x, y, 0);
            }

        }
        figure_id = f->next_figure_id_on_same_tile;
    }
}

static int building_is_workshop(int type)
{
    return type >= BUILDING_OIL_WORKSHOP && type <= BUILDING_WEAPONS_WORKSHOP;
}

static int calc_percentage(int value, int total)
{
    if (total) {
        int value_times_100 = 100 * value;
        return value_times_100 / total;
    } else {
        return 0;
    }
}

static int building_animation_offset(struct building_t *b, int image_id, int grid_offset)
{
    if (b->type == BUILDING_FOUNTAIN && (b->num_workers <= 0 || !b->has_water_access)) {
        return 0;
    }
    if (b->type == BUILDING_RESERVOIR && !b->has_water_access) {
        return 0;
    }
    if (building_is_workshop(b->type)) {
        if (b->loads_stored <= 0 || b->num_workers <= 0) {
            return 0;
        }
    }
    if ((b->type == BUILDING_PREFECTURE || b->type == BUILDING_ENGINEERS_POST) && b->num_workers <= 0) {
        return 0;
    }
    if (b->type == BUILDING_MARKET && b->num_workers <= 0) {
        return 0;
    }
    if (b->type == BUILDING_WAREHOUSE && b->num_workers < building_properties[b->type].n_laborers) {
        return 0;
    }
    if (b->type == BUILDING_DOCK && b->data.dock.num_ships <= 0) {
        sprite.items[grid_offset] = 1;
        return 1;
    }
    if (b->type == BUILDING_MARBLE_QUARRY && b->num_workers <= 0) {
        sprite.items[grid_offset] = 1;
        return 1;
    } else if ((b->type == BUILDING_IRON_MINE || b->type == BUILDING_CLAY_PIT ||
        b->type == BUILDING_TIMBER_YARD) && b->num_workers <= 0) {
        return 0;
    }
    if (b->type == BUILDING_GLADIATOR_SCHOOL) {
        if (b->num_workers <= 0) {
            sprite.items[grid_offset] = 1;
            return 1;
        }
    } else if (b->type >= BUILDING_THEATER && b->type <= BUILDING_CHARIOT_MAKER &&
        b->type != BUILDING_HIPPODROME && b->num_workers <= 0) {
        return 0;
    }
    if (b->type == BUILDING_GRANARY && b->num_workers < building_properties[b->type].n_laborers) {
        return 0;
    }

    struct image_t *img = image_get(image_id);
    if (!timers[img->animation_speed_id].should_update) {
        return sprite.items[grid_offset] & 0x7f;
    }
    // advance animation
    int new_sprite = 0;
    int is_reverse = 0;
    if (b->type == BUILDING_WINE_WORKSHOP) {
        // exception for wine...
        int pct_done = calc_percentage(b->data.industry.progress, 400);
        if (pct_done <= 0) {
            new_sprite = 0;
        } else if (pct_done < 4) {
            new_sprite = 1;
        } else if (pct_done < 8) {
            new_sprite = 2;
        } else if (pct_done < 12) {
            new_sprite = 3;
        } else if (pct_done < 96) {
            if (sprite.items[grid_offset] < 4) {
                new_sprite = 4;
            } else {
                new_sprite = sprite.items[grid_offset] + 1;
                if (new_sprite > 8) {
                    new_sprite = 4;
                }
            }
        } else {
            // close to done
            if (sprite.items[grid_offset] < 9) {
                new_sprite = 9;
            } else {
                new_sprite = sprite.items[grid_offset] + 1;
                if (new_sprite > 12) {
                    new_sprite = 12;
                }
            }
        }
    } else if (img->animation_can_reverse) {
        if (sprite.items[grid_offset] & 0x80) {
            is_reverse = 1;
        }
        int current_sprite = sprite.items[grid_offset] & 0x7f;
        if (is_reverse) {
            new_sprite = current_sprite - 1;
            if (new_sprite < 1) {
                new_sprite = 1;
                is_reverse = 0;
            }
        } else {
            new_sprite = current_sprite + 1;
            if (new_sprite > img->num_animation_sprites) {
                new_sprite = img->num_animation_sprites;
                is_reverse = 1;
            }
        }
    } else {
        // Absolutely normal case
        new_sprite = sprite.items[grid_offset] + 1;
        if (new_sprite > img->num_animation_sprites) {
            new_sprite = 1;
        }
    }
    sprite.items[grid_offset] = is_reverse ? new_sprite | 0x80 : new_sprite;
    return new_sprite;
}

static void city_draw_bridge_tile(int x, int y, int bridge_sprite_id, uint32_t color_mask)
{
    int image_id = 3292;
    switch (bridge_sprite_id) {
        case 1:
            image_draw_masked(image_id + 5, x, y - 20, color_mask);
            break;
        case 2:
            image_draw_masked(image_id, x - 1, y - 8, color_mask);
            break;
        case 3:
            image_draw_masked(image_id + 3, x, y - 8, color_mask);
            break;
        case 4:
            image_draw_masked(image_id + 2, x + 7, y - 20, color_mask);
            break;
        case 5:
            image_draw_masked(image_id + 4, x, y - 21, color_mask);
            break;
        case 6:
            image_draw_masked(image_id + 1, x + 5, y - 21, color_mask);
            break;
        case 7:
            image_draw_masked(image_id + 11, x - 3, y - 50, color_mask);
            break;
        case 8:
            image_draw_masked(image_id + 6, x - 1, y - 12, color_mask);
            break;
        case 9:
            image_draw_masked(image_id + 9, x - 30, y - 12, color_mask);
            break;
        case 10:
            image_draw_masked(image_id + 8, x - 23, y - 53, color_mask);
            break;
        case 11:
            image_draw_masked(image_id + 10, x, y - 37, color_mask);
            break;
        case 12:
            image_draw_masked(image_id + 7, x + 7, y - 38, color_mask);
            break;
            // Note: no nr 13
        case 14:
            image_draw_masked(image_id + 13, x, y - 38, color_mask);
            break;
        case 15:
            image_draw_masked(image_id + 12, x + 7, y - 38, color_mask);
            break;
    }
}

static void city_draw_bridge(int x, int y, int grid_offset)
{
    if (!map_terrain_is(grid_offset, TERRAIN_WATER)) {
        map_sprite_clear_tile(grid_offset);
        return;
    }
    if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
        return;
    }
    uint32_t color_mask = 0;
    if (bitfields_grid.items[grid_offset] & BIT_DELETED) {
        color_mask = COLOR_MASK_RED;
    }
    city_draw_bridge_tile(x, y, sprite.items[grid_offset], color_mask);
}

static void draw_animation_without_overlay(int x, int y, int grid_offset)
{
    int image_id = images.items[grid_offset];
    struct image_t *img = image_get(image_id);
    if (img->num_animation_sprites) {
        if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
            int building_id = map_building_at(grid_offset);
            struct building_t *b = &all_buildings[building_id];
            int color_mask = 0;
            if (draw_building_as_deleted_2(b) || bitfields_grid.items[grid_offset] & BIT_DELETED) {
                color_mask = COLOR_MASK_RED;
            }
            if (b->type == BUILDING_DOCK) {
                int num_idle = 0;
                for (int i = 0; i < 3; i++) {
                    if (b->data.dock.docker_ids[i]) {
                        struct figure_t *f = &figures[b->data.dock.docker_ids[i]];
                        if (f->action_state == FIGURE_ACTION_DOCKER_IDLING ||
                            f->action_state == FIGURE_ACTION_DOCKER_IMPORT_QUEUE) {
                            num_idle++;
                        }
                    }
                }
                if (num_idle > 0) {
                    int image_dock = images.items[grid_offset];
                    int image_dockers = 3306;
                    if (image_dock == 3230) {
                        image_dockers += 0;
                    } else if (image_dock == 3242) {
                        image_dockers += 3;
                    } else if (image_dock == 3254) {
                        image_dockers += 6;
                    } else {
                        image_dockers += 9;
                    }
                    if (num_idle == 2) {
                        image_dockers += 1;
                    } else if (num_idle == 3) {
                        image_dockers += 2;
                    }
                    struct image_t *img2 = image_get(image_dockers);
                    image_draw_masked(image_dockers, x + img2->sprite_offset_x, y + img2->sprite_offset_y, color_mask);
                }
            } else if (b->type == BUILDING_WAREHOUSE) {
                image_draw_masked(3336, x - 4, y - 42, color_mask);
                if (b->id == city_data.building.trade_center_building_id) {
                    image_draw_masked(3402, x + 19, y - 56, color_mask);
                }
            } else if (b->type == BUILDING_GRANARY) {
                image_draw_masked(3012,
                                  x + img->sprite_offset_x,
                                  y + 60 + img->sprite_offset_y - img->height,
                                  color_mask);
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 2400) {
                    image_draw_masked(3013, x + 33, y - 60, color_mask);
                }
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 1800) {
                    image_draw_masked(3014, x + 56, y - 50, color_mask);
                }
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 1200) {
                    image_draw_masked(3015, x + 91, y - 50, color_mask);
                }
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 600) {
                    image_draw_masked(3016, x + 117, y - 62, color_mask);
                }
            } else if (b->type == BUILDING_BURNING_RUIN && b->ruin_has_plague) {
                image_draw_masked(5571, x + 18, y - 32, color_mask);
            }
            int animation_offset = building_animation_offset(b, image_id, grid_offset);
            if (b->type != BUILDING_HIPPODROME && animation_offset > 0) {
                if (animation_offset > img->num_animation_sprites) {
                    animation_offset = img->num_animation_sprites;
                }
                if (b->type == BUILDING_GRANARY) {
                    image_draw_masked(image_id + animation_offset + 5, x + 77, y - 49, color_mask);
                } else {
                    int ydiff = 0;
                    switch (map_property_multi_tile_size(grid_offset)) {
                        case 1: ydiff = 30; break;
                        case 2: ydiff = 45; break;
                        case 3: ydiff = 60; break;
                        case 4: ydiff = 75; break;
                        case 5: ydiff = 90; break;
                    }
                    image_draw_masked(image_id + animation_offset,
                                      x + img->sprite_offset_x,
                                      y + ydiff + img->sprite_offset_y - img->height,
                                      color_mask);
                }
            }
        }
    } else if (sprite.items[grid_offset]) {
        city_draw_bridge(x, y, grid_offset);
    } else if (building_is_fort(all_buildings[map_building_at(grid_offset)].type)) {
        if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
            struct building_t *fort = &all_buildings[map_building_at(grid_offset)];
            int offset = 0;
            switch (fort->subtype.fort_figure_type) {
                case FIGURE_FORT_LEGIONARY: offset = 4; break;
                case FIGURE_FORT_MOUNTED: offset = 3; break;
                case FIGURE_FORT_JAVELIN: offset = 2; break;
            }
            if (offset) {
                image_draw_masked(3176 + offset, x + 81, y + 5, draw_building_as_deleted_2(fort) ? COLOR_MASK_RED : 0);
            }
        }
    } else if (all_buildings[map_building_at(grid_offset)].type == BUILDING_GATEHOUSE) {
        int xy = edge_grid.items[grid_offset] & EDGE_MASK_XY;
        int orientation = view_data.orientation;
        if ((orientation == DIR_0_TOP && xy == EDGE_X1Y1) ||
            (orientation == DIR_2_RIGHT && xy == EDGE_X0Y1) ||
            (orientation == DIR_4_BOTTOM && xy == EDGE_X0Y0) ||
            (orientation == DIR_6_LEFT && xy == EDGE_X1Y0)) {
            struct building_t *gate = &all_buildings[map_building_at(grid_offset)];
            int gatehouse_image_id = 5577;
            int color_mask = draw_building_as_deleted_2(gate) ? COLOR_MASK_RED : 0;
            if (gate->subtype.orientation == 1) {
                if (orientation == DIR_0_TOP || orientation == DIR_4_BOTTOM) {
                    image_draw_masked(gatehouse_image_id, x - 22, y - 80, color_mask);
                } else {
                    image_draw_masked(gatehouse_image_id + 1, x - 18, y - 81, color_mask);
                }
            } else if (gate->subtype.orientation == 2) {
                if (orientation == DIR_0_TOP || orientation == DIR_4_BOTTOM) {
                    image_draw_masked(gatehouse_image_id + 1, x - 18, y - 81, color_mask);
                } else {
                    image_draw_masked(gatehouse_image_id, x - 22, y - 80, color_mask);
                }
            }
        }
    }
}

static int map_grid_offset(int x, int y)
{
    return map_data.start_offset + x + y * GRID_SIZE;
}

static void city_view_get_selected_tile_pixels(int *x_pixels, int *y_pixels)
{
    *x_pixels = view_data.selected_tile.x_pixels;
    *y_pixels = view_data.selected_tile.y_pixels;
}

static int city_finance_can_afford(int cost)
{
    return -cost + city_data.finance.treasury >= -5000;
}

static void image_draw_blend(int image_id, int x, int y, uint32_t color)
{
    struct image_t *img = image_get(image_id);
    uint32_t *data = image_data(image_id);
    if (!data) {
        return;
    }

    if (img->draw.type == IMAGE_TYPE_ISOMETRIC) {
        return;
    }

    if (img->draw.is_fully_compressed) {
        struct clip_info_t *clip = graphics_get_clip_info(x, y, img->width, img->height);
        if (!clip || !clip->is_visible) {
            return;
        }
        int unclipped = clip->clip_x == CLIP_NONE;

        for (int yy = 0; yy < img->height - clip->clipped_pixels_bottom; yy++) {
            int xx = 0;
            while (xx < img->width) {
                uint32_t b = *data;
                data++;
                if (b == 255) {
                    // transparent pixels to skip
                    xx += *data;
                    data++;
                } else if (yy < clip->clipped_pixels_top) {
                    data += b;
                    xx += b;
                } else {
                    data += b;
                    uint32_t *dst = graphics_get_pixel(x + xx, y + yy);
                    if (unclipped) {
                        xx += b;
                        while (b) {
                            *dst &= color;
                            dst++;
                            b--;
                        }
                    } else {
                        while (b) {
                            if (xx >= clip->clipped_pixels_left && xx < img->width - clip->clipped_pixels_right) {
                                *dst &= color;
                            }
                            dst++;
                            xx++;
                            b--;
                        }
                    }
                }
            }
        }
    } else {
        draw_uncompressed(img, data, x, y, color, DRAW_TYPE_BLEND);
    }
}

static void draw_blocked_building_preview(int x, int y, int num_tiles, int *blocked_tiles, int completely_blocked)
{
    for (int i = 0; i < num_tiles; i++) {
        int x_offset = x + X_VIEW_OFFSETS[i];
        int y_offset = y + Y_VIEW_OFFSETS[i];
        if (completely_blocked || blocked_tiles[i]) {
            image_draw_blend(733, x_offset, y_offset, COLOR_MASK_RED);
        } else {
            image_draw_blend(733, x_offset, y_offset, COLOR_MASK_GREEN);
        }
    }
}

static void map_grid_bound_area(int *x_min, int *y_min, int *x_max, int *y_max)
{
    if (*x_min < 0) {
        *x_min = 0;
    }
    if (*y_min < 0) {
        *y_min = 0;
    }
    if (*x_max >= map_data.width) {
        *x_max = map_data.width - 1;
    }
    if (*y_max >= map_data.height) {
        *y_max = map_data.height - 1;
    }
}

static void map_grid_get_area(int x, int y, int size, int radius, int *x_min, int *y_min, int *x_max, int *y_max)
{
    *x_min = x - radius;
    *y_min = y - radius;
    *x_max = x + size + radius - 1;
    *y_max = y + size + radius - 1;
    map_grid_bound_area(x_min, y_min, x_max, y_max);
}

static int map_terrain_exists_tile_in_radius_with_type(int x, int y, int size, int radius, int terrain)
{
    int x_min, y_min, x_max, y_max;
    map_grid_get_area(x, y, size, radius, &x_min, &y_min, &x_max, &y_max);

    for (int yy = y_min; yy <= y_max; yy++) {
        for (int xx = x_min; xx <= x_max; xx++) {
            if (map_terrain_is(map_grid_offset(xx, yy), terrain)) {
                return 1;
            }
        }
    }
    return 0;
}

static int map_terrain_exist_multiple_tiles_in_radius_with_type(int x, int y, int size, int radius, int terrain, int count)
{
    int x_min, y_min, x_max, y_max;
    map_grid_get_area(x, y, size, radius, &x_min, &y_min, &x_max, &y_max);

    int tiles_found = 0;
    for (int yy = y_min; yy <= y_max; yy++) {
        for (int xx = x_min; xx <= x_max; xx++) {
            if (map_terrain_is(map_grid_offset(xx, yy), terrain)) {
                tiles_found++;
                if (tiles_found >= count) {
                    return 1;
                }
            }
        }
    }

    return 0;
}

static void set_warning(int *warning_id, int warning)
{
    if (warning_id) {
        *warning_id = warning;
    }
}

static int map_terrain_all_tiles_in_radius_are(int x, int y, int size, int radius, int terrain)
{
    int x_min, y_min, x_max, y_max;
    map_grid_get_area(x, y, size, radius, &x_min, &y_min, &x_max, &y_max);

    for (int yy = y_min; yy <= y_max; yy++) {
        for (int xx = x_min; xx <= x_max; xx++) {
            if (!map_terrain_is(map_grid_offset(xx, yy), terrain)) {
                return 0;
            }
        }
    }
    return 1;
}

static int check_building_terrain_requirements(int x, int y, int *warning_id)
{
    if (construction_data.required_terrain.meadow) {
        if (!map_terrain_exists_tile_in_radius_with_type(x, y, 3, 1, TERRAIN_MEADOW)) {
            set_warning(warning_id, WARNING_MEADOW_NEEDED);
            return 0;
        }
    } else if (construction_data.required_terrain.rock) {
        if (!map_terrain_exists_tile_in_radius_with_type(x, y, 2, 1, TERRAIN_ELEVATION)) {
            set_warning(warning_id, WARNING_ROCK_NEEDED);
            return 0;
        }
    } else if (construction_data.required_terrain.tree) {
        if (!map_terrain_exist_multiple_tiles_in_radius_with_type(x, y, 2, 1, TERRAIN_TREE | TERRAIN_SHRUB, 3)) {
            set_warning(warning_id, WARNING_TREE_NEEDED);
            return 0;
        }
    } else if (construction_data.required_terrain.water) {
        if (!map_terrain_exists_tile_in_radius_with_type(x, y, 2, 3, TERRAIN_WATER)) {
            set_warning(warning_id, WARNING_WATER_NEEDED);
            return 0;
        }
    } else if (construction_data.required_terrain.wall) {
        if (!map_terrain_all_tiles_in_radius_are(x, y, 2, 0, TERRAIN_WALL)) {
            set_warning(warning_id, WARNING_WALL_NEEDED);
            return 0;
        }
    }
    return 1;
}

static int map_orientation_for_gatehouse(int x, int y)
{
    switch (view_data.orientation) {
        case DIR_2_RIGHT: x--; break;
        case DIR_4_BOTTOM: x--; y--; break;
        case DIR_6_LEFT: y--; break;
    }
    int grid_offset = map_grid_offset(x, y);
    int num_road_tiles_within = 0;
    int road_tiles_within_flags = 0;
    // tiles within gate, flags:
    // 1  2
    // 4  8
    if (map_terrain_is(map_grid_offset(x, y), TERRAIN_ROAD)) {
        road_tiles_within_flags |= 1;
        num_road_tiles_within++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(1, 0), TERRAIN_ROAD)) {
        road_tiles_within_flags |= 2;
        num_road_tiles_within++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(0, 1), TERRAIN_ROAD)) {
        road_tiles_within_flags |= 4;
        num_road_tiles_within++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(1, 1), TERRAIN_ROAD)) {
        road_tiles_within_flags |= 8;
        num_road_tiles_within++;
    }

    if (num_road_tiles_within != 2 && num_road_tiles_within != 4) {
        return 0;
    }
    if (num_road_tiles_within == 2) {
        if (road_tiles_within_flags == 6 || road_tiles_within_flags == 9) { // diagonals
            return 0;
        }
        if (road_tiles_within_flags == 5 || road_tiles_within_flags == 10) { // top to bottom
            return 1;
        }
        if (road_tiles_within_flags == 3 || road_tiles_within_flags == 12) { // left to right
            return 2;
        }
        return 0;
    }
    // all 4 tiles are road: check adjacent roads
    int num_road_tiles_top = 0;
    int num_road_tiles_right = 0;
    int num_road_tiles_bottom = 0;
    int num_road_tiles_left = 0;
    // top
    if (map_terrain_is(grid_offset + map_grid_delta(0, -1), TERRAIN_ROAD)) {
        num_road_tiles_top++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(1, -1), TERRAIN_ROAD)) {
        num_road_tiles_top++;
    }
    // bottom
    if (map_terrain_is(grid_offset + map_grid_delta(0, 2), TERRAIN_ROAD)) {
        num_road_tiles_bottom++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(1, 2), TERRAIN_ROAD)) {
        num_road_tiles_bottom++;
    }
    // left
    if (map_terrain_is(grid_offset + map_grid_delta(-1, 0), TERRAIN_ROAD)) {
        num_road_tiles_left++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(-1, 1), TERRAIN_ROAD)) {
        num_road_tiles_left++;
    }
    // right
    if (map_terrain_is(grid_offset + map_grid_delta(2, 0), TERRAIN_ROAD)) {
        num_road_tiles_right++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(2, 1), TERRAIN_ROAD)) {
        num_road_tiles_right++;
    }
    // determine direction
    if (num_road_tiles_top || num_road_tiles_bottom) {
        if (num_road_tiles_left || num_road_tiles_right) {
            return 0;
        }
        return 1;
    } else if (num_road_tiles_left || num_road_tiles_right) {
        return 2;
    }
    return 0;
}

static int map_orientation_for_triumphal_arch(int x, int y)
{
    switch (view_data.orientation) {
        case DIR_2_RIGHT: x -= 2; break;
        case DIR_4_BOTTOM: x -= 2; y -= 2; break;
        case DIR_6_LEFT: y -= 2; break;
    }
    int num_road_tiles_top_bottom = 0;
    int num_road_tiles_left_right = 0;
    int num_blocked_tiles = 0;

    int grid_offset = map_grid_offset(x, y);
    // check corner tiles
    if (map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR)) {
        num_blocked_tiles++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(2, 0), TERRAIN_NOT_CLEAR)) {
        num_blocked_tiles++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(0, 2), TERRAIN_NOT_CLEAR)) {
        num_blocked_tiles++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(2, 2), TERRAIN_NOT_CLEAR)) {
        num_blocked_tiles++;
    }
    // road tiles top to bottom
    int top_offset = grid_offset + map_grid_delta(1, 0);
    if ((terrain_grid.items[top_offset] & TERRAIN_NOT_CLEAR) == TERRAIN_ROAD) {
        num_road_tiles_top_bottom++;
    } else if (map_terrain_is(top_offset, TERRAIN_NOT_CLEAR)) {
        num_blocked_tiles++;
    }
    int bottom_offset = grid_offset + map_grid_delta(1, 2);
    if ((terrain_grid.items[bottom_offset] & TERRAIN_NOT_CLEAR) == TERRAIN_ROAD) {
        num_road_tiles_top_bottom++;
    } else if (map_terrain_is(bottom_offset, TERRAIN_NOT_CLEAR)) {
        num_blocked_tiles++;
    }
    // road tiles left to right
    int left_offset = grid_offset + map_grid_delta(0, 1);
    if ((terrain_grid.items[left_offset] & TERRAIN_NOT_CLEAR) == TERRAIN_ROAD) {
        num_road_tiles_left_right++;
    } else if (map_terrain_is(left_offset, TERRAIN_NOT_CLEAR)) {
        num_blocked_tiles++;
    }
    int right_offset = grid_offset + map_grid_delta(2, 1);
    if ((terrain_grid.items[right_offset] & TERRAIN_NOT_CLEAR) == TERRAIN_ROAD) {
        num_road_tiles_left_right++;
    } else if (map_terrain_is(right_offset, TERRAIN_NOT_CLEAR)) {
        num_blocked_tiles++;
    }
    // center tile
    int center_offset = grid_offset + map_grid_delta(2, 1);
    if ((terrain_grid.items[center_offset] & TERRAIN_NOT_CLEAR) == TERRAIN_ROAD) {
        // do nothing
    } else if (map_terrain_is(center_offset, TERRAIN_NOT_CLEAR)) {
        num_blocked_tiles++;
    }
    // judgement time
    if (num_blocked_tiles) {
        return 0;
    }
    if (!num_road_tiles_left_right && !num_road_tiles_top_bottom) {
        return 0; // no road: can't determine direction
    }
    if (num_road_tiles_top_bottom == 2 && !num_road_tiles_left_right) {
        return 1;
    }
    if (num_road_tiles_left_right == 2 && !num_road_tiles_top_bottom) {
        return 2;
    }
    return 0;
}

static void image_draw_isometric_footprint(int image_id, int x, int y, uint32_t color_mask)
{
    struct image_t *img = image_get(image_id);
    if (img->draw.type != IMAGE_TYPE_ISOMETRIC) {
        return;
    }
    switch (img->width) {
        case 58:
            draw_footprint_size1(image_id, x, y, color_mask);
            break;
        case 118:
            draw_footprint_size2(image_id, x, y, color_mask);
            break;
        case 178:
            draw_footprint_size3(image_id, x, y, color_mask);
            break;
        case 238:
            draw_footprint_size4(image_id, x, y, color_mask);
            break;
        case 298:
            draw_footprint_size5(image_id, x, y, color_mask);
            break;
    }
}

static void image_draw_isometric_top(int image_id, int x, int y, uint32_t color_mask)
{
    struct image_t *img = image_get(image_id);
    if (img->draw.type != IMAGE_TYPE_ISOMETRIC) {
        return;
    }
    if (!img->draw.has_compressed_part) {
        return;
    }
    uint32_t *data = &image_data(image_id)[img->draw.uncompressed_length];

    int height = img->height;
    switch (img->width) {
        case 58:
            y -= img->height - 30;
            height -= 16;
            break;
        case 118:
            x -= 30;
            y -= img->height - 60;
            height -= 31;
            break;
        case 178:
            x -= 60;
            y -= img->height - 90;
            height -= 46;
            break;
        case 238:
            x -= 90;
            y -= img->height - 120;
            height -= 61;
            break;
        case 298:
            x -= 120;
            y -= img->height - 150;
            height -= 76;
            break;
    }
    if (!color_mask) {
        draw_compressed(img, data, x, y, height);
    } else {
        draw_compressed_and(img, data, x, y, height, color_mask);
    }
}

static void draw_building(int image_id, int x, int y)
{
    image_draw_isometric_footprint(image_id, x, y, COLOR_MASK_GREEN);
    image_draw_isometric_top(image_id, x, y, COLOR_MASK_GREEN);
}

static int map_can_place_road_under_aqueduct(int grid_offset)
{
    int image_id = images.items[grid_offset] - 666;
    int check_y;
    switch (image_id) {
        case 0:
        case 2:
        case 8:
        case 15:
        case 17:
        case 23:
            check_y = 1;
            break;
        case 1:
        case 3:
        case 9: case 10: case 11: case 12: case 13: case 14:
        case 16:
        case 18:
        case 24: case 25: case 26: case 27: case 28: case 29:
            check_y = 0;
            break;
        default: // not a straight aqueduct
            return 0;
    }
    if (view_data.orientation == DIR_6_LEFT || view_data.orientation == DIR_2_RIGHT) {
        check_y = !check_y;
    }
    if (check_y) {
        int dy_up = map_grid_delta(0, -1);
        int dy_down = map_grid_delta(0, 1);
        if (map_terrain_is(grid_offset + dy_up, TERRAIN_ROAD) ||
            routing_distance.items[grid_offset + dy_up] > 0) {
            return 0;
        }
        if (map_terrain_is(grid_offset + dy_down, TERRAIN_ROAD) ||
            routing_distance.items[grid_offset + dy_down] > 0) {
            return 0;
        }
    } else {
        int dx_left = map_grid_delta(-1, 0);
        int dx_right = map_grid_delta(1, 0);
        if (map_terrain_is(grid_offset + dx_left, TERRAIN_ROAD) ||
            routing_distance.items[grid_offset + dx_left] > 0) {
            return 0;
        }
        if (map_terrain_is(grid_offset + dx_right, TERRAIN_ROAD) ||
            routing_distance.items[grid_offset + dx_right] > 0) {
            return 0;
        }
    }
    return 1;
}

static int map_terrain_has_adjacent_x_with_type(int grid_offset, int terrain)
{
    if (map_terrain_is(grid_offset + map_grid_delta(0, -1), terrain) ||
        map_terrain_is(grid_offset + map_grid_delta(0, 1), terrain)) {
        return 1;
    }
    return 0;
}

static int map_terrain_has_adjacent_y_with_type(int grid_offset, int terrain)
{
    if (map_terrain_is(grid_offset + map_grid_delta(-1, 0), terrain) ||
        map_terrain_is(grid_offset + map_grid_delta(1, 0), terrain)) {
        return 1;
    }
    return 0;
}

static int building_preview_blocked(int grid_offset, int num_tiles, int *blocked_tiles, int type)
{
    int orientation_index = view_data.orientation / 2;
    int blocked = 0;
    for (int i = 0; i < num_tiles; i++) {
        int tile_offset = grid_offset + TILE_GRID_OFFSETS[orientation_index][i];
        int forbidden_terrain = terrain_grid.items[tile_offset] & TERRAIN_NOT_CLEAR;
        if (type == BUILDING_GATEHOUSE || type == BUILDING_TRIUMPHAL_ARCH) {
            forbidden_terrain &= ~TERRAIN_ROAD;
        }
        if (type == BUILDING_TOWER) {
            forbidden_terrain &= ~TERRAIN_WALL;
        }
        if (forbidden_terrain || (map_grid_is_valid_offset(tile_offset) && map_figures.items[tile_offset] > 0)) {
            blocked_tiles[i] = 1;
            blocked = 1;
        } else {
            blocked_tiles[i] = 0;
        }
    }
    return blocked;
}

static void draw_water_range_preview(int x, int y, int radius)
{
    int image_id = 733;
    for (int i = 1; i <= radius; i++) {
        for (int j = 0; j <= radius; j++) {
            image_draw_blend_alpha(image_id, x + HALF_TILE_WIDTH_PIXELS * (i + j), y - HALF_TILE_HEIGHT_PIXELS * (i - j), COLOR_MASK_BLUE);
            image_draw_blend_alpha(image_id, x + HALF_TILE_WIDTH_PIXELS * (i - j), y + HALF_TILE_HEIGHT_PIXELS * (i + j), COLOR_MASK_BLUE);
            image_draw_blend_alpha(image_id, x - HALF_TILE_WIDTH_PIXELS * (i + j), y + HALF_TILE_HEIGHT_PIXELS * (i - j), COLOR_MASK_BLUE);
            image_draw_blend_alpha(image_id, x - HALF_TILE_WIDTH_PIXELS * (i - j), y - HALF_TILE_HEIGHT_PIXELS * (i + j), COLOR_MASK_BLUE);
        }
    }
}

static int map_grid_is_inside(int x, int y, int size)
{
    return x >= 0 && x + size <= map_data.width && y >= 0 && y + size <= map_data.height;
}

static int map_terrain_exists_tile_in_area_with_type(int x, int y, int size, int terrain)
{
    for (int yy = y; yy < y + size; yy++) {
        for (int xx = x; xx < x + size; xx++) {
            if (map_grid_is_inside(xx, yy, 1) && terrain_grid.items[map_grid_offset(xx, yy)] & terrain) {
                return 1;
            }
        }
    }
    return 0;
}

static int is_road_tile_for_aqueduct(int grid_offset, int gate_orientation)
{
    int is_road = map_terrain_is(grid_offset, TERRAIN_ROAD) ? 1 : 0;
    if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
        struct building_t *b = &all_buildings[map_building_at(grid_offset)];
        if (b->type == BUILDING_GATEHOUSE) {
            if (b->subtype.orientation == gate_orientation) {
                is_road = 1;
            }
        } else if (b->type == BUILDING_GRANARY) {
            if (terrain_land_citizen.items[grid_offset] == CITIZEN_0_ROAD) {
                is_road = 1;
            }
        }
    }
    return is_road;
}

static int map_tiles_is_paved_road(int grid_offset)
{
    if (desirability_grid.items[grid_offset] > 4) {
        return 1;
    }
    if (desirability_grid.items[grid_offset] > 0 && map_terrain_is(grid_offset, TERRAIN_FOUNTAIN_RANGE)) {
        return 1;
    }
    return 0;
}

static int map_terrain_count_directly_adjacent_with_type(int grid_offset, int terrain)
{
    int count = 0;
    if (map_terrain_is(grid_offset + map_grid_delta(0, -1), terrain)) {
        count++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(1, 0), terrain)) {
        count++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(0, 1), terrain)) {
        count++;
    }
    if (map_terrain_is(grid_offset + map_grid_delta(-1, 0), terrain)) {
        count++;
    }
    return count;
}

static int map_grid_direction_delta(int direction)
{
    if (direction >= 0 && direction < 8) {
        return DIRECTION_DELTA[direction];
    } else {
        return 0;
    }
}

static struct terrain_image_t *get_image(int group, int tiles[MAX_TILES_TERRAIN])
{
    static struct terrain_image_t result;
    result.is_valid = 0;
    for (int i = 0; i < context_pointers[group].size; i++) {
        int context_matches_tiles = 1;
        for (int j = 0; j < MAX_TILES_TERRAIN; j++) {
            if (context_pointers[group].context[i].tiles[j] != 2 && tiles[j] != context_pointers[group].context[i].tiles[j]) {
                context_matches_tiles = 0;
                break;
            }
        }
        if (context_matches_tiles) {
            context_pointers[group].context[i].current_item_offset++;
            if (context_pointers[group].context[i].current_item_offset >= context_pointers[group].context[i].max_item_offset) {
                context_pointers[group].context[i].current_item_offset = 0;
            }
            result.is_valid = 1;
            result.group_offset = context_pointers[group].context[i].offset_for_orientation[view_data.orientation / 2];
            result.item_offset = context_pointers[group].context[i].current_item_offset;
            result.aqueduct_offset = context_pointers[group].context[i].aqueduct_offset;
            break;
        }
    }
    return &result;
}

static void set_terrain_reservoir(int grid_offset, int direction, int multi_tile_mask, int tiles[MAX_TILES_TERRAIN], int include_construction)
{
    int offset = grid_offset + map_grid_direction_delta(direction);
    if (map_terrain_is(offset, TERRAIN_BUILDING)) {
        struct building_t *b = &all_buildings[map_building_at(offset)];
        if (b->type == BUILDING_RESERVOIR && (edge_grid.items[offset] & EDGE_MASK_XY) == multi_tile_mask) {
            tiles[direction] = 1;
            return;
        }
    }
    int reservoir_construction_entrance = 0;
    if (!(bitfields_grid.items[offset] & BIT_CONSTRUCTION)) {
        reservoir_construction_entrance = 0;
    } else if (bitfields_grid.items[offset + map_grid_direction_delta(0)] & BIT_CONSTRUCTION && bitfields_grid.items[offset + map_grid_direction_delta(4)] & BIT_CONSTRUCTION) {
        reservoir_construction_entrance = !(bitfields_grid.items[offset + 2 * map_grid_direction_delta(0)] & BIT_CONSTRUCTION) || !(bitfields_grid.items[offset + 2 * map_grid_direction_delta(4)] & BIT_CONSTRUCTION);
    } else if (bitfields_grid.items[offset + map_grid_direction_delta(2)] & BIT_CONSTRUCTION && bitfields_grid.items[offset + map_grid_direction_delta(6)] & BIT_CONSTRUCTION) {
        reservoir_construction_entrance = !(bitfields_grid.items[offset + 2 * map_grid_direction_delta(2)] & BIT_CONSTRUCTION) || !(bitfields_grid.items[offset + 2 * map_grid_direction_delta(6)] & BIT_CONSTRUCTION);
    }
    if (include_construction && reservoir_construction_entrance) {
        tiles[direction] = 1;
    }
}

static   struct terrain_image_t *map_image_context_get_aqueduct(int grid_offset, int include_construction)
{
    int tiles[MAX_TILES_TERRAIN] = { 0,0,0,0,0,0,0,0 };
    int has_road = map_terrain_is(grid_offset, TERRAIN_ROAD) ? 1 : 0;
    for (int i = 0; i < MAX_TILES_TERRAIN; i += 2) {
        int offset = grid_offset + map_grid_direction_delta(i);
        if (map_terrain_is(offset, TERRAIN_AQUEDUCT)) {
            if (has_road) {
                if (!map_terrain_is(offset, TERRAIN_ROAD)) {
                    tiles[i] = 1;
                }
            } else {
                tiles[i] = 1;
            }
        }
    }
    set_terrain_reservoir(grid_offset, 0, EDGE_X1Y2, tiles, include_construction);
    set_terrain_reservoir(grid_offset, 2, EDGE_X0Y1, tiles, include_construction);
    set_terrain_reservoir(grid_offset, 4, EDGE_X1Y0, tiles, include_construction);
    set_terrain_reservoir(grid_offset, 6, EDGE_X2Y1, tiles, include_construction);
    return get_image(CONTEXT_AQUEDUCT, tiles);
}

static int map_bridge_get_sprite_id(int index, int length, int direction, int is_ship_bridge)
{
    if (is_ship_bridge) {
        int pillar_distance = 0;
        switch (bridge.length) {
            case 9:
            case 10:
                pillar_distance = 4;
                break;
            case 11:
            case 12:
                pillar_distance = 5;
                break;
            case 13:
            case 14:
                pillar_distance = 6;
                break;
            case 15:
            case 16:
                pillar_distance = 7;
                break;
            default:
                pillar_distance = 8;
                break;
        }
        if (index == 1 || index == length - 2) {
            // platform after ramp
            return 13;
        } else if (index == 0) {
            // ramp at start
            switch (direction) {
                case DIR_0_TOP:
                    return 7;
                case DIR_2_RIGHT:
                    return 8;
                case DIR_4_BOTTOM:
                    return 9;
                case DIR_6_LEFT:
                    return 10;
            }
        } else if (index == length - 1) {
            // ramp at end
            switch (direction) {
                case DIR_0_TOP:
                    return 9;
                case DIR_2_RIGHT:
                    return 10;
                case DIR_4_BOTTOM:
                    return 7;
                case DIR_6_LEFT:
                    return 8;
            }
        } else if (index == pillar_distance) {
            if (direction == DIR_0_TOP || direction == DIR_4_BOTTOM) {
                return 14;
            } else {
                return 15;
            }
        } else {
            // middle of the bridge
            if (direction == DIR_0_TOP || direction == DIR_4_BOTTOM) {
                return 11;
            } else {
                return 12;
            }
        }
    } else {
        if (index == 0) {
            // ramp at start
            switch (direction) {
                case DIR_0_TOP:
                    return 1;
                case DIR_2_RIGHT:
                    return 2;
                case DIR_4_BOTTOM:
                    return 3;
                case DIR_6_LEFT:
                    return 4;
            }
        } else if (index == length - 1) {
            // ramp at end
            switch (direction) {
                case DIR_0_TOP:
                    return 3;
                case DIR_2_RIGHT:
                    return 4;
                case DIR_4_BOTTOM:
                    return 1;
                case DIR_6_LEFT:
                    return 2;
            }
        } else {
            // middle part
            if (direction == DIR_0_TOP || direction == DIR_4_BOTTOM) {
                return 5;
            } else {
                return 6;
            }
        }
    }
    return 0;
}

static int blocked_land_terrain(void)
{
    return
        TERRAIN_SHRUB | TERRAIN_ROCK | TERRAIN_WATER |
        TERRAIN_BUILDING | TERRAIN_TREE | TERRAIN_GARDEN |
        TERRAIN_ROAD | TERRAIN_ELEVATION | TERRAIN_RUBBLE;
}

static int map_water_determine_orientation_size2(int x, int y, int adjust_xy, int *orientation_absolute, int *orientation_relative)
{
    if (adjust_xy == 1) {
        switch (view_data.orientation) {
            case DIR_0_TOP: break;
            case DIR_2_RIGHT: x--; break;
            case DIR_6_LEFT: y--; break;
            case DIR_4_BOTTOM: x--; y--; break;
        }
    }
    if (!map_grid_is_inside(x, y, 2)) {
        return 999;
    }

    int base_offset = map_grid_offset(x, y);
    int tile_offsets[] = { OFFSET(0,0), OFFSET(1,0), OFFSET(0,1), OFFSET(1,1) };
    int should_be_water[4][4] = { {1, 1, 0, 0}, {0, 1, 0, 1}, {0, 0, 1, 1}, {1, 0, 1, 0} };
    for (int dir = 0; dir < 4; dir++) {
        int ok_tiles = 0;
        int blocked_tiles = 0;
        for (int i = 0; i < 4; i++) {
            int grid_offset = base_offset + tile_offsets[i];
            if (should_be_water[dir][i]) {
                if (!map_terrain_is(grid_offset, TERRAIN_WATER)) {
                    break;
                }
                ok_tiles++;
                if (map_terrain_is(grid_offset, TERRAIN_ROCK | TERRAIN_ROAD)) {
                    // bridge or map edge
                    blocked_tiles++;
                }
            } else {
                if (map_terrain_is(grid_offset, TERRAIN_WATER)) {
                    break;
                }
                ok_tiles++;
                if (map_terrain_is(grid_offset, blocked_land_terrain())) {
                    blocked_tiles++;
                }
            }
        }
        // check six water tiles in front
        int tiles_to_check[4][6] = {
          {OFFSET(-1,0), OFFSET(-1,-1), OFFSET(0,-1), OFFSET(1,-1), OFFSET(2,-1), OFFSET(2,0)},
          {OFFSET(1,-1), OFFSET(2,-1), OFFSET(2,0), OFFSET(2,1), OFFSET(2,2), OFFSET(1,2)},
          {OFFSET(2,1), OFFSET(2,2), OFFSET(1,2), OFFSET(0,2), OFFSET(-1,2), OFFSET(-1,1)},
          {OFFSET(0,2), OFFSET(-1,2), OFFSET(-1,1), OFFSET(-1,0), OFFSET(-1,-1), OFFSET(0,-1)},
        };
        for (int i = 0; i < 6; i++) {
            if (!map_terrain_is(base_offset + tiles_to_check[dir][i], TERRAIN_WATER)) {
                ok_tiles = 0;
            }
        }
        if (ok_tiles == 4) {
            // water/land is OK in this orientation
            if (orientation_absolute) {
                *orientation_absolute = dir;
            }
            if (orientation_relative) {
                *orientation_relative = (4 + dir - view_data.orientation / 2) % 4;
            }
            return blocked_tiles;
        }
    }
    return 999;
}

static int map_water_determine_orientation_size3(int x, int y, int adjust_xy, int *orientation_absolute, int *orientation_relative)
{
    if (adjust_xy == 1) {
        switch (view_data.orientation) {
            case DIR_0_TOP: break;
            case DIR_2_RIGHT: x -= 2; break;
            case DIR_6_LEFT: y -= 2; break;
            case DIR_4_BOTTOM: x -= 2; y -= 2; break;
        }
    }
    if (!map_grid_is_inside(x, y, 3)) {
        return 999;
    }

    int base_offset = map_grid_offset(x, y);
    int tile_offsets[] = {
        OFFSET(0,0), OFFSET(1,0), OFFSET(2,0),
        OFFSET(0,1), OFFSET(1,1), OFFSET(2,1),
        OFFSET(0,2), OFFSET(1,2), OFFSET(2,2)
    };
    int should_be_water[4][9] = {
        {1, 1, 1, 0, 0, 0, 0, 0, 0},
        {0, 0, 1, 0, 0, 1, 0, 0, 1},
        {0, 0, 0, 0, 0, 0, 1, 1, 1},
        {1, 0, 0, 1, 0, 0, 1, 0, 0}
    };
    for (int dir = 0; dir < 4; dir++) {
        int ok_tiles = 0;
        int blocked_tiles = 0;
        for (int i = 0; i < 9; i++) {
            int grid_offset = base_offset + tile_offsets[i];
            if (should_be_water[dir][i]) {
                if (!map_terrain_is(grid_offset, TERRAIN_WATER)) {
                    break;
                }
                ok_tiles++;
                if (map_terrain_is(grid_offset, TERRAIN_ROCK | TERRAIN_ROAD)) {
                    // bridge or map edge
                    blocked_tiles++;
                }
            } else {
                if (map_terrain_is(grid_offset, TERRAIN_WATER)) {
                    break;
                }
                ok_tiles++;
                if (map_terrain_is(grid_offset, blocked_land_terrain())) {
                    blocked_tiles++;
                }
            }
        }
        // check two water tiles at the side
        int tiles_to_check[4][2] = {
          {OFFSET(-1,0), OFFSET(3,0)}, {OFFSET(2,-1), OFFSET(2,3)},
          {OFFSET(3,2), OFFSET(-1,2)}, {OFFSET(0,-1), OFFSET(0,3)}
        };
        for (int i = 0; i < 2; i++) {
            if (!map_terrain_is(base_offset + tiles_to_check[dir][i], TERRAIN_WATER)) {
                ok_tiles = 0;
            }
        }
        if (ok_tiles == 9) {
            // water/land is OK in this orientation
            if (orientation_absolute) {
                *orientation_absolute = dir;
            }
            if (orientation_relative) {
                *orientation_relative = (4 + dir - view_data.orientation / 2) % 4;
            }
            return blocked_tiles;
        }
    }
    return 999;
}

static void city_building_ghost_draw(struct map_tile_t *tile)
{
    if (!tile->grid_offset || scroll_data.is_scrolling || scroll_data.drag.active) {
        return;
    }

    if (construction_data.draw_as_constructing || construction_data.type == BUILDING_NONE || construction_data.type == BUILDING_CLEAR_LAND) {
        return;
    }
    int x, y;
    city_view_get_selected_tile_pixels(&x, &y);
    int building_size = construction_data.type == BUILDING_WAREHOUSE ? 3 : building_properties[construction_data.type].size;
    int num_tiles = building_size * building_size;
    int blocked_tiles[num_tiles];
    int orientation_index = view_data.orientation / 2;
    if (!city_finance_can_afford(building_properties[construction_data.type].cost)) {
        draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 1);
        if (construction_data.type == BUILDING_HIPPODROME) {
            int blocked_tiles2[MAX_TILES_BUILDING_PREVIEW];
            int blocked_tiles3[MAX_TILES_BUILDING_PREVIEW];
            draw_blocked_building_preview(x + HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + HIPPODROME_Y_VIEW_OFFSETS[orientation_index], num_tiles, blocked_tiles2, 1);
            draw_blocked_building_preview(x + 2 * HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + 2 * HIPPODROME_Y_VIEW_OFFSETS[orientation_index], num_tiles, blocked_tiles3, 1);
        } else if (building_is_fort(construction_data.type)) {
            int num_fort_ground_tiles = building_properties[BUILDING_FORT_GROUND].size * building_properties[BUILDING_FORT_GROUND].size;
            int blocked_tiles_ground[MAX_TILES_BUILDING_PREVIEW];
            draw_blocked_building_preview(x + FORT_GROUND_X_VIEW_OFFSETS[orientation_index], y + FORT_GROUND_Y_VIEW_OFFSETS[orientation_index], num_fort_ground_tiles, blocked_tiles_ground, 1);
        }
        return;
    }
    int x_dir_offset = 0;
    int y_dir_offset = 0;
    switch (view_data.orientation) {
        case DIR_0_TOP:
            x_dir_offset = tile->x;
            y_dir_offset = tile->y;
            break;
        case DIR_2_RIGHT:
            x_dir_offset = tile->x - building_size + 1;
            y_dir_offset = tile->y;
            break;
        case DIR_4_BOTTOM:
            x_dir_offset = tile->x - building_size + 1;
            y_dir_offset = tile->y - building_size + 1;
            break;
        case DIR_6_LEFT:
            x_dir_offset = tile->x;
            y_dir_offset = tile->y - building_size + 1;
            break;
        default:
            x_dir_offset = 0;
            y_dir_offset = 0;
    }
    if (!check_building_terrain_requirements(x_dir_offset, y_dir_offset, 0)) {
        draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 1);
        return;
    }
    int image_id = building_properties[construction_data.type].img_id;
    if (construction_data.type == BUILDING_GATEHOUSE) {
        int orientation = map_orientation_for_gatehouse(tile->x, tile->y);
        int image_offset;
        if (orientation == 2) {
            image_offset = 1;
        } else if (orientation == 1) {
            image_offset = 0;
        } else {
            image_offset = construction_data.road_orientation == 2 ? 1 : 0;
        }
        int map_orientation = view_data.orientation;
        if (map_orientation == DIR_6_LEFT || map_orientation == DIR_2_RIGHT) {
            image_offset = 1 - image_offset;
        }
        image_id += image_offset;
    } else if (construction_data.type == BUILDING_TRIUMPHAL_ARCH) {
        int orientation = map_orientation_for_triumphal_arch(tile->x, tile->y);
        int image_offset;
        if (orientation == 2) {
            image_offset = 2;
        } else if (orientation == 1) {
            image_offset = 0;
        } else {
            image_offset = construction_data.road_orientation == 2 ? 2 : 0;
        }
        int map_orientation = view_data.orientation;
        if (map_orientation == DIR_6_LEFT || map_orientation == DIR_2_RIGHT) {
            image_offset = 2 - image_offset;
        }
        image_id += image_offset;
    }
    int dir_absolute;
    int dir_relative;
    switch (construction_data.type) {
        case BUILDING_HOUSE_VACANT_LOT:
            if (map_terrain_is(tile->grid_offset, TERRAIN_NOT_CLEAR)) {
                image_draw_blend(733, x, y, COLOR_MASK_RED);
                return;
            }
            draw_building(2823, x, y);
            return;
        case BUILDING_ROAD:
            if (map_terrain_is(tile->grid_offset, TERRAIN_NOT_CLEAR)) {
                image_draw_blend(733, x, y, COLOR_MASK_RED);
                return;
            }
            if (map_terrain_is(tile->grid_offset, TERRAIN_AQUEDUCT)) {
                if (map_can_place_road_under_aqueduct(tile->grid_offset)) {
                    image_id = images.items[tile->grid_offset];
                    switch (image_id) {
                        case 2:
                            image_id += 8;
                            break;
                        case 3:
                            image_id += 9;
                            break;
                        case 17:
                            image_id += 23;
                            break;
                        case 18:
                            image_id += 24;
                            break;
                        default:
                            break;
                            draw_building(image_id, x, y);
                    }
                } else {
                    image_draw_blend(733, x, y, COLOR_MASK_RED);
                }
            } else {
                if (!map_terrain_has_adjacent_x_with_type(tile->grid_offset, TERRAIN_ROAD) &&
                    map_terrain_has_adjacent_y_with_type(tile->grid_offset, TERRAIN_ROAD)) {
                    image_id++;
                }
                draw_building(image_id, x, y);
            }
            return;
        case BUILDING_RESERVOIR:
            if (building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, construction_data.type)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                return;
            }
            // y + 30 to center mouse, 11 instead of 10 range to compensate for building size
            draw_water_range_preview(x, y + 30, 11);
            draw_building(image_id, x, y);
            if (map_terrain_exists_tile_in_area_with_type(tile->x - 1, tile->y - 1, 5, TERRAIN_WATER)) {
                struct image_t *img = image_get(image_id);
                int x_water = x - 58 + img->sprite_offset_x - 2;
                int y_water = y + img->sprite_offset_y - (img->height - 90);
                image_draw_masked(image_id + 1, x_water, y_water, COLOR_MASK_GREEN);
            }
            return;
        case BUILDING_AQUEDUCT:
            if (map_terrain_is(tile->grid_offset, TERRAIN_ROAD)) {
                int map_is_straight_road_for_aqueduct = 0;
                int road_tiles_x =
                    is_road_tile_for_aqueduct(tile->grid_offset + map_grid_delta(1, 0), 2) +
                    is_road_tile_for_aqueduct(tile->grid_offset + map_grid_delta(-1, 0), 2);
                int road_tiles_y =
                    is_road_tile_for_aqueduct(tile->grid_offset + map_grid_delta(0, -1), 1) +
                    is_road_tile_for_aqueduct(tile->grid_offset + map_grid_delta(0, 1), 1);
                if ((road_tiles_x == 2 && road_tiles_y == 0)
                || (road_tiles_y == 2 && road_tiles_x == 0)) {
                    map_is_straight_road_for_aqueduct = 1;
                }
                if (!map_is_straight_road_for_aqueduct || bitfields_grid.items[tile->grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
                    image_draw_blend(733, x, y, COLOR_MASK_RED);
                    return;
                }
            } else if (map_terrain_is(tile->grid_offset, TERRAIN_NOT_CLEAR)) {
                image_draw_blend(733, x, y, COLOR_MASK_RED);
                return;
            }
            struct terrain_image_t *terrain_img = map_image_context_get_aqueduct(tile->grid_offset, 1);
            if (map_terrain_is(tile->grid_offset, TERRAIN_ROAD)) {
                int group_offset = terrain_img->group_offset;
                if (!terrain_img->aqueduct_offset) {
                    if (map_terrain_is(tile->grid_offset + map_grid_delta(0, -1), TERRAIN_ROAD)) {
                        group_offset = 3;
                    } else {
                        group_offset = 2;
                    }
                }
                if (map_tiles_is_paved_road(tile->grid_offset)) {
                    image_id += group_offset + 13;
                } else {
                    image_id += group_offset + 21;
                }
            } else {
                image_id += terrain_img->group_offset + 15;
            }
            draw_building(image_id, x, y);
            return;
        case BUILDING_FOUNTAIN:
            if (map_terrain_is(tile->grid_offset, TERRAIN_NOT_CLEAR)) {
                image_draw_blend(733, x, y, COLOR_MASK_RED);
                return;
            }
            draw_water_range_preview(x, y, scenario.climate == CLIMATE_DESERT ? 3 : 4);
            draw_building(image_id, x, y);
            if (map_terrain_is(tile->grid_offset, TERRAIN_RESERVOIR_RANGE)) {
                struct image_t *img = image_get(image_id);
                image_draw_masked(image_id + 1, x + img->sprite_offset_x, y + img->sprite_offset_y, COLOR_MASK_GREEN);
            }
            return;
        case BUILDING_WELL:
            if (map_terrain_is(tile->grid_offset, TERRAIN_NOT_CLEAR)) {
                image_draw_blend(733, x, y, COLOR_MASK_RED);
                return;
            }
            draw_water_range_preview(x, y, 2);
            draw_building(image_id, x, y);
            return;
        case BUILDING_BATHHOUSE:
            if (building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, construction_data.type)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                return;
            }
            draw_building(image_id, x, y);
            for (int i = 0; i < num_tiles; i++) {
                if (map_terrain_is(tile->grid_offset + TILE_GRID_OFFSETS[orientation_index][i], TERRAIN_RESERVOIR_RANGE)) {
                    struct image_t *img = image_get(image_id);
                    image_draw_masked(image_id - 1, x + img->sprite_offset_x - 7, y + img->sprite_offset_y + 6, COLOR_MASK_GREEN);
                    break;
                }
            }
            return;
        case BUILDING_HIPPODROME:
        {
            int blocked_tiles2[25];
            int blocked_tiles3[25];
            if (city_data.building.hippodrome_placed) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 1);
                draw_blocked_building_preview(x + HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + HIPPODROME_Y_VIEW_OFFSETS[orientation_index], num_tiles, blocked_tiles2, 1);
                draw_blocked_building_preview(x + 2 * HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + 2 * HIPPODROME_Y_VIEW_OFFSETS[orientation_index], num_tiles, blocked_tiles3, 1);
                return;
            }
            int blocked1 = building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, construction_data.type);
            int blocked2 = building_preview_blocked(tile->grid_offset + map_grid_delta(5, 0), num_tiles, blocked_tiles2, construction_data.type);
            int blocked3 = building_preview_blocked(tile->grid_offset + map_grid_delta(10, 0), num_tiles, blocked_tiles3, construction_data.type);
            if (blocked1 || blocked2 || blocked3) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                draw_blocked_building_preview(x + HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + HIPPODROME_Y_VIEW_OFFSETS[orientation_index], num_tiles, blocked_tiles2, 0);
                draw_blocked_building_preview(x + 2 * HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + 2 * HIPPODROME_Y_VIEW_OFFSETS[orientation_index], num_tiles, blocked_tiles3, 0);
                return;
            }
            if (orientation_index == 0) {
                image_id = 7789;
                // part 1, 2, 3
                draw_building(image_id, x, y);
                draw_building(image_id + 2, x + HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + HIPPODROME_Y_VIEW_OFFSETS[orientation_index]);
                draw_building(image_id + 4, x + 2 * HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + 2 * HIPPODROME_Y_VIEW_OFFSETS[orientation_index]);
            } else if (orientation_index == 1) {
                image_id = 7780;
                // part 3, 2, 1
                draw_building(image_id, x + 2 * HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + 2 * HIPPODROME_Y_VIEW_OFFSETS[orientation_index]);
                draw_building(image_id + 2, x + HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + HIPPODROME_Y_VIEW_OFFSETS[orientation_index]);
                draw_building(image_id + 4, x, y);
            } else if (orientation_index == 2) {
                image_id = 7789;
                // part 1, 2, 3
                draw_building(image_id + 4, x, y);
                draw_building(image_id + 2, x + HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + HIPPODROME_Y_VIEW_OFFSETS[orientation_index]);
                draw_building(image_id, x + 2 * HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + 2 * HIPPODROME_Y_VIEW_OFFSETS[orientation_index]);
            } else if (orientation_index == 3) {
                image_id = 7780;
                // part 3, 2, 1
                draw_building(image_id + 4, x + 2 * HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + 2 * HIPPODROME_Y_VIEW_OFFSETS[orientation_index]);
                draw_building(image_id + 2, x + HIPPODROME_X_VIEW_OFFSETS[orientation_index], y + HIPPODROME_Y_VIEW_OFFSETS[orientation_index]);
                draw_building(image_id, x, y);
            }
            return;
        }
        case BUILDING_SENATE:
            if (city_data.building.senate_placed) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 1);
                return;
            }
            if (building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, construction_data.type)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                return;
            }
            draw_building(image_id, x, y);
            return;
        case BUILDING_TRIUMPHAL_ARCH:
            if (building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, construction_data.type)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                return;
            }
            draw_building(image_id, x, y);
            struct image_t *img = image_get(image_id + 1);
            if (image_id == 821) {
                image_draw_masked(image_id + 1, x + img->sprite_offset_x + 4, y + img->sprite_offset_y - 51, COLOR_MASK_GREEN);
            } else {
                image_draw_masked(image_id + 1, x + img->sprite_offset_x - 33, y + img->sprite_offset_y - 56, COLOR_MASK_GREEN);
            }
            return;
        case BUILDING_PLAZA:
            if (!map_terrain_is(tile->grid_offset, TERRAIN_ROAD)) {
                image_draw_blend(733, x, y, COLOR_MASK_RED);
                return;
            }
            draw_building(image_id, x, y);
            return;
        case BUILDING_LOW_BRIDGE:
        case BUILDING_SHIP_BRIDGE:
        {
            int length = 0;
            int direction = 0;
            int end_grid_offset = 0;
            int grid_offset = map_grid_offset(tile->x, tile->y);
            bridge.end_grid_offset = 0;
            bridge.direction_grid_delta = 0;
            bridge.length = 0;
            bridge.direction = 0;
            if (!map_terrain_is(grid_offset, TERRAIN_WATER)) {
                end_grid_offset = 0;
            } else if (map_terrain_is(grid_offset, TERRAIN_ROAD | TERRAIN_BUILDING)) {
                end_grid_offset = 0;
            } else if (map_terrain_count_directly_adjacent_with_type(grid_offset, TERRAIN_WATER) != 3) {
                end_grid_offset = 0;
            } else {
                if (!map_terrain_is(grid_offset + map_grid_delta(0, -1), TERRAIN_WATER)) {
                    bridge.direction_grid_delta = map_grid_delta(0, 1);
                    bridge.direction = DIR_4_BOTTOM;
                } else if (!map_terrain_is(grid_offset + map_grid_delta(1, 0), TERRAIN_WATER)) {
                    bridge.direction_grid_delta = map_grid_delta(-1, 0);
                    bridge.direction = DIR_6_LEFT;
                } else if (!map_terrain_is(grid_offset + map_grid_delta(0, 1), TERRAIN_WATER)) {
                    bridge.direction_grid_delta = map_grid_delta(0, -1);
                    bridge.direction = DIR_0_TOP;
                } else if (!map_terrain_is(grid_offset + map_grid_delta(-1, 0), TERRAIN_WATER)) {
                    bridge.direction_grid_delta = map_grid_delta(1, 0);
                    bridge.direction = DIR_2_RIGHT;
                } else {
                    end_grid_offset = 0;
                }
                if (end_grid_offset) {
                    direction = bridge.direction;
                    bridge.length = 1;
                    for (int i = 0; i < 40; i++) {
                        grid_offset += bridge.direction_grid_delta;
                        bridge.length++;
                        int next_offset = grid_offset + bridge.direction_grid_delta;
                        if (map_terrain_is(next_offset, TERRAIN_SHRUB)) {
                            break;
                        }
                        if (!map_terrain_is(next_offset, TERRAIN_WATER)) {
                            bridge.end_grid_offset = grid_offset;
                            if (map_terrain_count_directly_adjacent_with_type(grid_offset, TERRAIN_WATER) != 3) {
                                bridge.end_grid_offset = 0;
                            }
                            length = bridge.length;
                            end_grid_offset = bridge.end_grid_offset;
                        } else {
                            if (map_terrain_is(next_offset, TERRAIN_ROAD | TERRAIN_BUILDING)) {
                                break;
                            }
                            int count = 0;
                            if (map_terrain_is(grid_offset + map_grid_delta(1, -1), TERRAIN_WATER)) {
                                count++;
                            }
                            if (map_terrain_is(grid_offset + map_grid_delta(1, 1), TERRAIN_WATER)) {
                                count++;
                            }
                            if (map_terrain_is(grid_offset + map_grid_delta(-1, 1), TERRAIN_WATER)) {
                                count++;
                            }
                            if (map_terrain_is(grid_offset + map_grid_delta(-1, -1), TERRAIN_WATER)) {
                                count++;
                            }
                            if (count != 4) {
                                break;
                            }
                        }
                    }
                    // invalid bridge
                    length = bridge.length;
                }
            }
            int dir = direction - view_data.orientation;
            if (dir < 0) {
                dir += 8;
            }
            int blocked = 0;
            if (construction_data.type == BUILDING_SHIP_BRIDGE && length < 5) {
                blocked = 1;
            } else if (!end_grid_offset) {
                blocked = 1;
            }
            int x_delta, y_delta;
            switch (dir) {
                case DIR_0_TOP:
                    x_delta = 29;
                    y_delta = -15;
                    break;
                case DIR_2_RIGHT:
                    x_delta = 29;
                    y_delta = 15;
                    break;
                case DIR_4_BOTTOM:
                    x_delta = -29;
                    y_delta = 15;
                    break;
                case DIR_6_LEFT:
                    x_delta = -29;
                    y_delta = -15;
                    break;
                default:
                    return;
            }
            if (blocked) {
                image_draw_blend(733, x, y, length > 0 ? COLOR_MASK_GREEN : COLOR_MASK_RED);
                if (length > 1) {
                    image_draw_blend(733, x + x_delta * (length - 1), y + y_delta * (length - 1), COLOR_MASK_RED);
                }
                construction_data.cost_preview = 0;
            } else {
                if (dir == DIR_0_TOP || dir == DIR_6_LEFT) {
                    for (int i = length - 1; i >= 0; i--) {
                        int sprite_id = map_bridge_get_sprite_id(i, length, dir, construction_data.type == BUILDING_SHIP_BRIDGE);
                        city_draw_bridge_tile(x + x_delta * i, y + y_delta * i, sprite_id, COLOR_MASK_GREEN);
                    }
                } else {
                    for (int i = 0; i < length; i++) {
                        int sprite_id = map_bridge_get_sprite_id(i, length, dir, construction_data.type == BUILDING_SHIP_BRIDGE);
                        city_draw_bridge_tile(x + x_delta * i, y + y_delta * i, sprite_id, COLOR_MASK_GREEN);
                    }
                }
                construction_data.cost_preview = building_properties[construction_data.type].cost * length;
            }
            break;
        }
        case BUILDING_SHIPYARD:
        case BUILDING_WHARF:
            if (map_water_determine_orientation_size2(tile->x, tile->y, 1, &dir_absolute, &dir_relative)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 1);
                return;
            }
            image_id = building_properties[construction_data.type].img_id + dir_relative;
            draw_building(image_id, x, y);
            return;
        case BUILDING_DOCK:
            if (map_water_determine_orientation_size3(tile->x, tile->y, 1, &dir_absolute, &dir_relative)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 1);
                return;
            }
            switch (dir_relative) {
                case 0: image_id = 3230; break;
                case 1: image_id = 3242; break;
                case 2: image_id = 3254; break;
                default:image_id = 3266; break;
            }
            draw_building(image_id, x, y);
            return;
        case BUILDING_GATEHOUSE:
            if (building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, construction_data.type)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                return;
            }
            // update road required based on timer
            if (construction_data.road_orientation > 0) {
                if (current_time - construction_data.road_last_update > 1500) {
                    construction_data.road_last_update = current_time;
                    construction_data.road_orientation = construction_data.road_orientation == 1 ? 2 : 1;
                }
            }
            draw_building(image_id, x, y);
            return;
        case BUILDING_FORT_LEGIONARIES:
        case BUILDING_FORT_JAVELIN:
        case BUILDING_FORT_MOUNTED:
        {
            int num_fort_ground_tiles = building_properties[BUILDING_FORT_GROUND].size * building_properties[BUILDING_FORT_GROUND].size;
            int blocked_tiles_ground[MAX_TILES_BUILDING_PREVIEW];
            if (city_data.military.total_legions >= MAX_LEGIONS) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 1);
                draw_blocked_building_preview(x + FORT_GROUND_X_VIEW_OFFSETS[orientation_index], y + FORT_GROUND_Y_VIEW_OFFSETS[orientation_index], num_fort_ground_tiles, blocked_tiles_ground, 1);
                return;
            }
            int blocked1_f = building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, construction_data.type);
            int blocked2_f = building_preview_blocked(tile->grid_offset + FORT_GROUND_GRID_OFFSETS[orientation_index], num_fort_ground_tiles, blocked_tiles_ground, construction_data.type);
            if (blocked1_f || blocked2_f) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                draw_blocked_building_preview(x + FORT_GROUND_X_VIEW_OFFSETS[orientation_index], y + FORT_GROUND_Y_VIEW_OFFSETS[orientation_index], num_fort_ground_tiles, blocked_tiles_ground, 0);
                return;
            }
            if (orientation_index == 0 || orientation_index == 3) {
                draw_building(image_id, x, y);
                draw_building(image_id + 1, x + FORT_GROUND_X_VIEW_OFFSETS[orientation_index], y + FORT_GROUND_Y_VIEW_OFFSETS[orientation_index]);
            } else {
                draw_building(image_id + 1, x + FORT_GROUND_X_VIEW_OFFSETS[orientation_index], y + FORT_GROUND_Y_VIEW_OFFSETS[orientation_index]);
                draw_building(image_id, x, y);
            }
            return;
        }
        case BUILDING_BARRACKS:
            if (count_data.buildings[BUILDING_BARRACKS].total) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 1);
                return;
            }
            if (building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, construction_data.type)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                return;
            }
            draw_building(image_id, x, y);
            return;
        case BUILDING_WHEAT_FARM:
        case BUILDING_VEGETABLE_FARM:
        case BUILDING_FRUIT_FARM:
        case BUILDING_OLIVE_FARM:
        case BUILDING_VINES_FARM:
        case BUILDING_PIG_FARM:
            if (building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, construction_data.type)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                return;
            }
            draw_building(image_id, x, y);
            // fields
            for (int i = 4; i < 9; i++) {
                image_draw_isometric_footprint(image_id + 1, x + X_VIEW_OFFSETS[i], y + Y_VIEW_OFFSETS[i], COLOR_MASK_GREEN);
            }
            return;
        case BUILDING_GRANARY:
            if (building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, construction_data.type)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                return;
            }
            image_draw_isometric_footprint(image_id, x, y, COLOR_MASK_GREEN);
            struct image_t *img_granary = image_get(image_id + 1);
            image_draw_masked(image_id + 1, x + img_granary->sprite_offset_x - 32, y + img_granary->sprite_offset_y - 64, COLOR_MASK_GREEN);
            return;
        case BUILDING_WAREHOUSE:
            if (building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, construction_data.type)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                return;
            }
            draw_building(image_id, x, y);
            image_draw_masked(3336, x - 4, y - 42, COLOR_MASK_GREEN);
            for (int i = 1; i < 9; i++) {
                draw_building(3337, x + X_VIEW_OFFSETS[i], y + Y_VIEW_OFFSETS[i]);
            }
            return;
        default:
            if (building_preview_blocked(tile->grid_offset, num_tiles, blocked_tiles, construction_data.type)) {
                draw_blocked_building_preview(x, y, num_tiles, blocked_tiles, 0);
                return;
            }
            draw_building(image_id, x, y);
            return;
    }
}

static void draw_elevated_figures_without_overlay(int x, int y, int grid_offset)
{
    int figure_id = map_grid_is_valid_offset(grid_offset) ? map_figures.items[grid_offset] : 0;
    while (figure_id > 0) {
        struct figure_t *f = &figures[figure_id];
        if ((f->use_cross_country && !f->is_invisible) || f->height_adjusted_ticks) {
            city_draw_figure(f, x, y, 0);
        }
        figure_id = f->next_figure_id_on_same_tile;
    }
}

static void draw_hippodrome_ornaments(int x, int y, int grid_offset)
{
    struct image_t *img = image_get(images.items[grid_offset]);
    struct building_t *b = &all_buildings[map_building_at(grid_offset)];
    if (img->num_animation_sprites
        && edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE
        && b->type == BUILDING_HIPPODROME) {
        image_draw_masked(images.items[grid_offset] + 1,
            x + img->sprite_offset_x, y + img->sprite_offset_y - img->height + 90,
            draw_building_as_deleted_2(b) ? COLOR_MASK_RED : 0
        );
    }
}

static int should_draw_top_before_deletion_without_overlay(int grid_offset)
{
    int has_adjacent_deletion = 0;
    int size = map_property_multi_tile_size(grid_offset);
    int total_adjacent_offsets = size * 2 + 1;
    int *adjacent_offset = ADJACENT_OFFSETS[size - 1][view_data.orientation / 2];
    for (int i = 0; i < total_adjacent_offsets; ++i) {
        if ((bitfields_grid.items[grid_offset + adjacent_offset[i]] & BIT_DELETED) ||
            draw_building_as_deleted_2(&all_buildings[map_building_at(grid_offset + adjacent_offset[i])])) {
            has_adjacent_deletion = 1;
            break;
        }
    }
    return is_multi_tile_terrain(grid_offset) && has_adjacent_deletion;
}

static void deletion_draw_terrain_top_without_overlay(int x, int y, int grid_offset)
{
    if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE && should_draw_top_before_deletion_without_overlay(grid_offset)) {
        draw_top_without_overlay(x, y, grid_offset);
    }
}

static void deletion_draw_figures_animations(int x, int y, int grid_offset)
{
    if (bitfields_grid.items[grid_offset] & BIT_DELETED || draw_building_as_deleted_2(&all_buildings[map_building_at(grid_offset)])) {
        image_draw_blend(733, x, y, COLOR_MASK_RED);
    }
    if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE && !should_draw_top_before_deletion_without_overlay(grid_offset)) {
        draw_top_without_overlay(x, y, grid_offset);
    }
    draw_figures_without_overlay(x, y, grid_offset);
    draw_animation_without_overlay(x, y, grid_offset);
}

static void deletion_draw_remaining(int x, int y, int grid_offset)
{
    draw_elevated_figures_without_overlay(x, y, grid_offset);
    draw_hippodrome_ornaments(x, y, grid_offset);
}

static void city_without_overlay_draw(int selected_figure_id, struct pixel_coordinate_t *figure_coord, struct map_tile_t *tile)
{
    int highlighted_formation = -1;
    if (configs[CONFIG_UI_HIGHLIGHT_LEGIONS].config_value) {
        highlighted_formation = select_legion_index_at(tile->grid_offset);
        if (highlighted_formation > -1) {
            if (selected_legion_formation && highlighted_formation != selected_legion_formation->id) {
                highlighted_formation = -1;
            }
            if (legion_formations[highlighted_formation].in_distant_battle) {
                highlighted_formation = -1;
            }
        }
    }
    draw_context.advance_water_animation = 0;
    if (!selected_figure_id) {
        if (current_time - draw_context.last_water_animation_time > 60) {
            draw_context.last_water_animation_time = current_time;
            draw_context.advance_water_animation = 1;
        }
    }
    draw_context.image_id_water_first = 364;
    draw_context.image_id_water_last = 5 + draw_context.image_id_water_first;
    draw_context.selected_figure_id = selected_figure_id;
    draw_context.selected_figure_coord = figure_coord;
    draw_context.highlighted_formation = highlighted_formation;
    int should_mark_deleting = city_building_ghost_mark_deleting(tile);
    city_view_foreach_map_tile(draw_footprint_without_overlay);
    if (!should_mark_deleting) {
        city_view_foreach_valid_map_tile(
            draw_top_without_overlay,
            draw_figures_without_overlay,
            draw_animation_without_overlay
        );
        if (!selected_figure_id) {
            city_building_ghost_draw(tile);
        }
        city_view_foreach_valid_map_tile(
            draw_elevated_figures_without_overlay,
            draw_hippodrome_ornaments,
            0
        );
    } else {
        city_view_foreach_map_tile(deletion_draw_terrain_top_without_overlay);
        city_view_foreach_map_tile(deletion_draw_figures_animations);
        city_view_foreach_map_tile(deletion_draw_remaining);
    }
}

static void translate_clip(int dx, int dy)
{
    clip_rectangle.x_start -= dx;
    clip_rectangle.x_end -= dx;
    clip_rectangle.y_start -= dy;
    clip_rectangle.y_end -= dy;
}

static void graphics_reset_clip_rectangle(void)
{
    clip_rectangle.x_start = 0;
    clip_rectangle.x_end = canvas.width;
    clip_rectangle.y_start = 0;
    clip_rectangle.y_end = canvas.height;
    translate_clip(translation.x, translation.y);
}

static void graphics_save_screenshot(int full_city)
{
    if (full_city) {
        struct pixel_view_coordinates_t original_camera_pixels;
        original_camera_pixels.x = view_data.camera.tile.x * TILE_WIDTH_PIXELS + view_data.camera.pixel.x;
        original_camera_pixels.y = view_data.camera.tile.y * HALF_TILE_HEIGHT_PIXELS + view_data.camera.pixel.y;
        int width = screen_data.width;
        int height = screen_data.height;

        int city_width_pixels = map_data.width * TILE_X_SIZE;
        int city_height_pixels = map_data.height * TILE_Y_SIZE;

        if (!create_bmp_chunk(city_width_pixels, IMAGE_HEIGHT_CHUNK)) {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to assign memory for full city screenshot creation", 0, 0));
            return;
        }
        char *filename = generate_filename(FULL_CITY_SCREENSHOT);
        fp = fopen(filename, "wb");
        if (!fp) {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to write screenshot to:", filename, 0));
            free_bmp_chunk();
            return;
        }
        uint8_t header[HEADER_SIZE_BMP];
        struct buffer_t buf;
        buffer_init(&buf, header, HEADER_SIZE_BMP);
        write_bmp_header(&buf, city_height_pixels + TILE_Y_SIZE);
        fwrite(header, 1, HEADER_SIZE_BMP, fp);
        int new_width = city_width_pixels + (view_data.sidebar_collapsed ? 40 : 160);
        screen_set_resolution(new_width, 24 + IMAGE_HEIGHT_CHUNK);
        graphics_set_clip_rectangle(0, 24, city_width_pixels, IMAGE_HEIGHT_CHUNK);
        int base_width = (GRID_SIZE * TILE_X_SIZE - city_width_pixels) / 2 + TILE_X_SIZE;
        int max_height = (GRID_SIZE * TILE_Y_SIZE + city_height_pixels) / 2;
        int min_height = max_height - city_height_pixels - TILE_Y_SIZE;
        struct map_tile_t dummy_tile = { 0, 0, 0 };
        for (int current_height = max_height - IMAGE_HEIGHT_CHUNK; current_height >= min_height; current_height -= IMAGE_HEIGHT_CHUNK) {
            city_view_set_camera_from_pixel_position(base_width, current_height);
            city_without_overlay_draw(0, 0, &dummy_tile);
            for (int y = IMAGE_HEIGHT_CHUNK - 1; y >= 0; y--) {
                for (int x = 0; x < city_width_pixels; x++) {
                    pixel(canvas.pixels[(y + 24) * new_width + x],
                        &bmp_chunk.pixels[3 * x + 2], &bmp_chunk.pixels[3 * x + 1], &bmp_chunk.pixels[3 * x]);
                }
                fwrite(bmp_chunk.pixels, sizeof(uint8_t), bmp_chunk.scanline_size, fp);
            }
        }
        graphics_reset_clip_rectangle();
        screen_set_resolution(width, height);
        city_view_set_camera_from_pixel_position(original_camera_pixels.x, original_camera_pixels.y);
        fclose(fp);
        free_bmp_chunk();
        SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Saved full city screenshot:", filename, 0));
        show_saved_notice(filename);
    } else {
        uint8_t header[HEADER_SIZE_BMP];
        struct buffer_t buf;
        buffer_init(&buf, header, HEADER_SIZE_BMP);
        int width = screen_data.width;
        int height = screen_data.height;
        if (!create_bmp_chunk(width, 1)) {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to create memory for screenshot", 0, 0));
            return;
        }
        char *filename = generate_filename(DISPLAY_SCREENSHOT);
        fp = fopen(filename, "wb");
        if (!fp) {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to write screenshot to:", filename, 0));
            free_bmp_chunk();
            return;
        }
        write_bmp_header(&buf, height);
        fwrite(header, 1, HEADER_SIZE_BMP, fp);
        for (int y = height - 1; y >= 0; y--) {
            for (int x = 0; x < width; x++) {
                pixel(canvas.pixels[y * width + x],
                    &bmp_chunk.pixels[3 * x + 2], &bmp_chunk.pixels[3 * x + 1], &bmp_chunk.pixels[3 * x]);
            }
            fwrite(bmp_chunk.pixels, sizeof(uint8_t), bmp_chunk.scanline_size, fp);
        }
        fclose(fp);
        free_bmp_chunk();
        SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Saved screenshot:", filename, 0));
        show_saved_notice(filename);
    }
}

static int text_get_width(char *str, int font)
{
    struct font_definition_t *def = &DEFINITIONS_DEFAULT[font];
    int maxlen = 10000;
    int width = 0;
    while (*str && maxlen > 0) {
        int num_bytes = 1;
        if (*str == ' ') {
            width += def->space_width;
        } else {
            int letter_id = font_letter_id(def, str);
            if (letter_id >= 0) {
                width += def->letter_spacing + image_letter(letter_id)->width;
            }
        }
        str += num_bytes;
        maxlen -= num_bytes;
    }
    return width;
}

static void text_draw_centered(char *str, int x, int y, int box_width, int font, uint32_t color)
{
    int offset = (box_width - text_get_width(str, font)) / 2;
    if (offset < 0) {
        offset = 0;
    }
    text_draw(str, offset + x, y, font, color);
}

static Mix_Chunk *load_chunk(char *filename)
{
    if (filename[0]) {
        return Mix_LoadWAV(filename);
    } else {
        return 0;
    }
}

static int load_channel(struct sound_channel_t *channel)
{
    if (!channel->chunk && channel->filename) {
        channel->chunk = load_chunk(channel->filename);
    }
    return channel->chunk ? 1 : 0;
}

static void set_channel_volume(int channel, int volume_pct)
{
    if (sound_channels[channel].chunk) {
        Mix_VolumeChunk(sound_channels[channel].chunk, volume_pct * SDL_MIX_MAXVOLUME / 100);
    }
}

static int32_t calc_bound(int32_t value, int32_t min, int32_t max)
{
    if (value < min) {
        return min;
    } else if (value > max) {
        return max;
    } else {
        return value;
    }
}

static void add_to_terrain(int x, int y, int size, int desirability, int step, int step_size, int range)
{
    if (size > 0) {
        if (range > 6) {
            range = 6;
        }
        int tiles_within_step = 0;
        for (int distance = 1; distance <= range; distance++) {
            int partially_outside_map = 0;
            if (x - distance < -1 || x + distance + size - 1 > map_data.width) {
                partially_outside_map = 1;
            }
            if (y - distance < -1 || y + distance + size - 1 > map_data.height) {
                partially_outside_map = 1;
            }
            int base_offset = map_grid_offset(x, y);

            if (partially_outside_map) {
                for (int i = desirability_data.index[size][distance]; i < desirability_data.index[size][distance] + 4 * (size - 1) + 8 * distance; i++) {
                    struct ring_tile_t *tile = &desirability_data.tiles[i];
                    if (x + tile->x >= -1 && x <= map_data.width && y + tile->y >= -1 && y <= map_data.height) {
                        desirability_grid.items[base_offset + tile->grid_offset] += desirability;
                        // BUG: bounding on wrong tile:
                        desirability_grid.items[base_offset] = calc_bound(desirability_grid.items[base_offset], -100, 100);
                    }
                }
            } else {
                for (int i = desirability_data.index[size][distance]; i < desirability_data.index[size][distance] + 4 * (size - 1) + 8 * distance; i++) {
                    struct ring_tile_t *tile = &desirability_data.tiles[i];
                    desirability_grid.items[base_offset + tile->grid_offset] =
                        calc_bound(desirability_grid.items[base_offset + tile->grid_offset] + desirability, -100, 100);
                }
            }
            tiles_within_step++;
            if (tiles_within_step >= step) {
                desirability += step_size;
                tiles_within_step = 0;
            }
        }
    }
}

static void mark_native_land(int x, int y, int size, int radius)
{
    int x_min, y_min, x_max, y_max;
    map_grid_get_area(x, y, size, radius, &x_min, &y_min, &x_max, &y_max);
    for (int yy = y_min; yy <= y_max; yy++) {
        for (int xx = x_min; xx <= x_max; xx++) {
            edge_grid.items[map_grid_offset(xx, yy)] |= EDGE_NATIVE_LAND;
        }
    }
}

static void clear_buildings(void)
{
    undo_data.num_buildings = 0;
    memset(undo_data.buildings, 0, MAX_UNDO_BUILDINGS * sizeof(struct building_t));
}

static void decay(unsigned char *value)
{
    if (*value > 0) {
        *value = *value - 1;
    } else {
        *value = 0;
    }
}

static int check_evolve_desirability(struct building_t *house)
{
    int level = house->subtype.house_level;
    int evolve_des = house_properties[level].evolve_desirability;
    if (level >= HOUSE_LUXURY_PALACE) {
        evolve_des = 1000;
    }
    int current_des = house->desirability;
    int status;
    if (current_des <= house_properties[level].devolve_desirability) {
        status = DEVOLVE;
    } else if (current_des >= evolve_des) {
        status = EVOLVE;
    } else {
        status = NONE;
    }
    house->data.house.evolve_text_id = status; // BUG? -1 in an unsigned char?
    return status;
}

static int has_required_goods_and_services(struct building_t *house, int for_upgrade, struct house_demands_t *demands)
{
    int level = house->subtype.house_level;
    if (for_upgrade) {
        ++level;
    }
    // water
    if (!house->has_water_access) {
        if (house_properties[level].water >= 2) {
            ++demands->missing.fountain;
            return 0;
        }
        if (house_properties[level].water == 1 && !house->has_well_access) {
            ++demands->missing.well;
            return 0;
        }
    }
    // entertainment
    if (house->data.house.entertainment < house_properties[level].entertainment) {
        if (house->data.house.entertainment) {
            ++demands->missing.more_entertainment;
        } else {
            ++demands->missing.entertainment;
        }
        return 0;
    }
    // education
    if (house->data.house.education < house_properties[level].education) {
        if (house->data.house.education) {
            ++demands->missing.more_education;
        } else {
            ++demands->missing.education;
        }
        return 0;
    }
    if (house_properties[level].education == 2) {
        ++demands->requiring.school;
        ++demands->requiring.library;
    } else if (house_properties[level].education == 1) {
        ++demands->requiring.school;
    }
    // religion
    if (house->data.house.num_gods < house_properties[level].religion) {
        if (house_properties[level].religion == 1) {
            ++demands->missing.religion;
            return 0;
        } else if (house_properties[level].religion == 2) {
            ++demands->missing.second_religion;
            return 0;
        } else if (house_properties[level].religion == 3) {
            ++demands->missing.third_religion;
            return 0;
        }
    } else if (house_properties[level].religion > 0) {
        ++demands->requiring.religion;
    }
    // barber
    if (house->data.house.barber < house_properties[level].barber) {
        ++demands->missing.barber;
        return 0;
    }
    if (house_properties[level].barber == 1) {
        ++demands->requiring.barber;
    }
    // bathhouse
    if (house->data.house.bathhouse < house_properties[level].bathhouse) {
        ++demands->missing.bathhouse;
        return 0;
    }
    if (house_properties[level].bathhouse == 1) {
        ++demands->requiring.bathhouse;
    }
    // health
    if (house->data.house.health < house_properties[level].health) {
        if (house_properties[level].health < 2) {
            ++demands->missing.clinic;
        } else {
            ++demands->missing.hospital;
        }
        return 0;
    }
    if (house_properties[level].health >= 1) {
        ++demands->requiring.clinic;
    }
    // food types
    int foodtypes_available = 0;
    for (int i = INVENTORY_WHEAT; i <= INVENTORY_MEAT; i++) {
        if (house->data.house.inventory[i]) {
            foodtypes_available++;
        }
    }
    if (foodtypes_available < house_properties[level].food_types) {
        ++demands->missing.food;
        return 0;
    }
    // goods
    if (house->data.house.inventory[INVENTORY_POTTERY] < house_properties[level].pottery) {
        return 0;
    }
    if (house->data.house.inventory[INVENTORY_OIL] < house_properties[level].oil) {
        return 0;
    }
    if (house->data.house.inventory[INVENTORY_FURNITURE] < house_properties[level].furniture) {
        return 0;
    }
    int wine_required = house_properties[level].wine;
    if (wine_required && !house->data.house.inventory[INVENTORY_WINE]) {
        return 0;
    }
    if (wine_required > 1 && city_data.resource.wine_types_available <= 1) {
        ++demands->missing.second_wine;
        return 0;
    }
    return 1;
}

static int check_requirements(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_evolve_desirability(house);
    if (!has_required_goods_and_services(house, 0, demands)) {
        status = DEVOLVE;
    } else if (status == EVOLVE) {
        status = has_required_goods_and_services(house, 1, demands);
    }
    return status;
}

static void prepare_for_merge(int building_id, int num_tiles)
{
    for (int i = 0; i < INVENTORY_MAX; i++) {
        merge_data.inventory[i] = 0;
    }
    merge_data.population = 0;
    int grid_offset = map_grid_offset(merge_data.x, merge_data.y);
    for (int i = 0; i < num_tiles; i++) {
        int house_offset = grid_offset + HOUSE_TILE_OFFSETS[i];
        if (map_terrain_is(house_offset, TERRAIN_BUILDING)) {
            struct building_t *house = &all_buildings[map_building_at(house_offset)];
            if (house->id != building_id && house->house_size) {
                merge_data.population += house->house_population;
                for (int inv = 0; inv < INVENTORY_MAX; inv++) {
                    merge_data.inventory[inv] += house->data.house.inventory[inv];
                    house->house_population = 0;
                    house->state = BUILDING_STATE_DELETED_BY_GAME;
                }
            }
        }
    }
}

static int map_grid_offset_to_x(int grid_offset)
{
    return (grid_offset - map_data.start_offset) % GRID_SIZE;
}

static int map_grid_offset_to_y(int grid_offset)
{
    return (grid_offset - map_data.start_offset) / GRID_SIZE;
}

static int building_is_farm(int type)
{
    return type >= BUILDING_WHEAT_FARM && type <= BUILDING_VINES_FARM;
}

static void foreach_region_tile(int x_min, int y_min, int x_max, int y_max, void (*callback)(int x, int y, int grid_offset))
{
    map_grid_bound_area(&x_min, &y_min, &x_max, &y_max);
    int grid_offset = map_grid_offset(x_min, y_min);
    for (int yy = y_min; yy <= y_max; yy++) {
        for (int xx = x_min; xx <= x_max; xx++) {
            callback(xx, yy, grid_offset);
            ++grid_offset;
        }
        grid_offset += GRID_SIZE - (x_max - x_min + 1);
    }
}

static void fill_matches(int grid_offset, int terrain, int match_value, int no_match_value, int tiles[MAX_TILES_TERRAIN])
{
    for (int i = 0; i < MAX_TILES_TERRAIN; i++) {
        tiles[i] = map_terrain_is(grid_offset + map_grid_direction_delta(i), terrain) ? match_value : no_match_value;
    }
}

static void set_water_image(int x, int y, int grid_offset)
{
    if ((terrain_grid.items[grid_offset] & (TERRAIN_WATER | TERRAIN_BUILDING)) == TERRAIN_WATER) {
        int tiles[MAX_TILES_TERRAIN];
        fill_matches(grid_offset, TERRAIN_WATER, 0, 1, tiles);
        struct terrain_image_t *img = get_image(CONTEXT_WATER, tiles);
        int image_id = 364 + img->group_offset + img->item_offset;
        if (map_terrain_exists_tile_in_radius_with_type(x, y, 1, 2, TERRAIN_BUILDING)) {
            // fortified shore
            switch (img->group_offset) {
                case 8: image_id = 835; break;
                case 12: image_id = 836; break;
                case 16: image_id = 834; break;
                case 20: image_id = 833; break;
                case 24: image_id = 843; break;
                case 28: image_id = 841; break;
                case 32: image_id = 844; break;
                case 36: image_id = 842; break;
                case 50: image_id = 837; break;
                case 51: image_id = 839; break;
                case 52: image_id = 838; break;
                case 53: image_id = 840; break;
            }
        }
        images.items[grid_offset] = image_id;
    }
}

static void clear_current_offset(struct terrain_image_context *items, int num_items)
{
    for (int i = 0; i < num_items; i++) {
        items[i].current_item_offset = 0;
    }
}

static void update_surrounding_water_images(void)
{
    clear_current_offset(context_pointers[CONTEXT_WATER].context, context_pointers[CONTEXT_WATER].size);
    for (int y = current_tile.y - tool_data.brush_size - 1; y <= current_tile.y + tool_data.brush_size + 1; y++) {
        for (int x = current_tile.x - tool_data.brush_size - 1; x <= current_tile.x + tool_data.brush_size + 1; x++) {
            if (map_terrain_is(map_data.start_offset + x + y * GRID_SIZE, TERRAIN_WATER)) {
                set_water_image(x, y, map_data.start_offset + x + y * GRID_SIZE);
            }
        }
    }
}

static void map_tiles_set_water(int x, int y)
{
    terrain_grid.items[map_grid_offset(x, y)] |= TERRAIN_WATER;
    foreach_region_tile(x - 1, y - 1, x + 1, y + 1, set_water_image);
}

static void map_property_set_multi_tile_size(int grid_offset, int size)
{
    bitfields_grid.items[grid_offset] &= BIT_NO_SIZES;
    switch (size) {
        case 2: bitfields_grid.items[grid_offset] |= BIT_SIZE2; break;
        case 3: bitfields_grid.items[grid_offset] |= BIT_SIZE3; break;
        case 4: bitfields_grid.items[grid_offset] |= BIT_SIZE4; break;
        case 5: bitfields_grid.items[grid_offset] |= BIT_SIZE5; break;
    }
}

static void clear_empty_land_image(__attribute__((unused)) int x, __attribute__((unused)) int y, int grid_offset)
{
    if (!map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR | TERRAIN_MEADOW)) {
        images.items[grid_offset] = 0;
        map_property_set_multi_tile_size(grid_offset, 1);
        edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
    }
}

static void set_empty_land_image(int x, int y, int size, int image_id)
{
    if (!map_grid_is_inside(x, y, size)) {
        return;
    }
    int index = 0;
    for (int dy = 0; dy < size; dy++) {
        for (int dx = 0; dx < size; dx++) {
            int grid_offset = map_grid_offset(x + dx, y + dy);
            terrain_grid.items[grid_offset] &= ~TERRAIN_CLEARABLE;
            buildings_grid.items[grid_offset] = 0;
            bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
            map_property_set_multi_tile_size(grid_offset, 1);
            edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
            images.items[grid_offset] = image_id + index;
            index++;
        }
    }
}

static int is_clear(int x, int y, int size, int disallowed_terrain, int check_image)
{
    if (!map_grid_is_inside(x, y, size)) {
        return 0;
    }
    for (int dy = 0; dy < size; dy++) {
        for (int dx = 0; dx < size; dx++) {
            int grid_offset = map_grid_offset(x + dx, y + dy);
            if (map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR & disallowed_terrain)) {
                return 0;
            } else if (map_grid_is_valid_offset(grid_offset) && map_figures.items[grid_offset] > 0) {
                return 0;
            } else if (check_image && images.items[grid_offset]) {
                return 0;
            }
        }
    }
    return 1;
}

static void set_empty_land_pass1(int x, int y, int grid_offset)
{
    if (!map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR) && !images.items[grid_offset] && !(random.items[grid_offset] & 0xf0)) {
        int image_id;
        if (bitfields_grid.items[grid_offset] & BIT_ALTERNATE_TERRAIN) {
            image_id = 476;
        } else {
            image_id = 306;
        }
        set_empty_land_image(x, y, 1, image_id + (random.items[grid_offset] & 7));
    }
}

static void set_empty_land_pass2(int x, int y, int grid_offset)
{
    if (!map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR) && !images.items[grid_offset]) {
        int image_id;
        if (bitfields_grid.items[grid_offset] & BIT_ALTERNATE_TERRAIN) {
            image_id = 476;
        } else {
            image_id = 306;
        }
        if (is_clear(x, y, 4, TERRAIN_ALL, 1)) {
            set_empty_land_image(x, y, 4, image_id + 42);
        } else if (is_clear(x, y, 3, TERRAIN_ALL, 1)) {
            set_empty_land_image(x, y, 3, image_id + 24 + 9 * (random.items[grid_offset] & 1));
        } else if (is_clear(x, y, 2, TERRAIN_ALL, 1)) {
            set_empty_land_image(x, y, 2, image_id + 8 + 4 * (random.items[grid_offset] & 3));
        } else {
            set_empty_land_image(x, y, 1, image_id + (random.items[grid_offset] & 7));
        }
    }
}

static void map_tiles_update_region_empty_land(int x_min, int y_min, int x_max, int y_max)
{
    int grid_offset = 0;
    for (int y = y_min; y <= y_max; y++) {
        for (int x = x_min; x <= x_max; x++) {
            grid_offset = map_data.start_offset + x + y * GRID_SIZE;
            clear_empty_land_image(x, y, grid_offset);
        }
    }
    for (int y = y_min; y <= y_max; y++) {
        for (int x = x_min; x <= x_max; x++) {
            grid_offset = map_data.start_offset + x + y * GRID_SIZE;
            set_empty_land_pass1(x, y, grid_offset);
        }
    }
    for (int y = y_min; y <= y_max; y++) {
        for (int x = x_min; x <= x_max; x++) {
            grid_offset = map_data.start_offset + x + y * GRID_SIZE;
            set_empty_land_pass2(x, y, grid_offset);
        }
    }


}

static void set_meadow_image(int x, int y, int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_MEADOW) && !map_terrain_is(grid_offset, FORBIDDEN_TERRAIN_MEADOW)) {
        int image_id = 262;
        if (map_terrain_all_tiles_in_radius_are(x, y, 1, 2, TERRAIN_MEADOW)) {
            images.items[grid_offset] = image_id + (random.items[grid_offset] & 3) + 8;
        } else if (map_terrain_all_tiles_in_radius_are(x, y, 1, 1, TERRAIN_MEADOW)) {
            images.items[grid_offset] = image_id + (random.items[grid_offset] & 3) + 4;
        } else {
            images.items[grid_offset] = image_id + (random.items[grid_offset] & 3);
        }
        map_property_set_multi_tile_size(grid_offset, 1);
        edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
        aqueduct.items[grid_offset] = 0;
    }
}

static void update_meadow_tile(int x, int y, int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_MEADOW) && !map_terrain_is(grid_offset, FORBIDDEN_TERRAIN_MEADOW)) {
        foreach_region_tile(x - 1, y - 1, x + 1, y + 1, set_meadow_image);
    }
}

static void set_rubble_image(__attribute__((unused)) int x, __attribute__((unused)) int y, int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_RUBBLE) && !map_terrain_is(grid_offset, FORBIDDEN_TERRAIN_RUBBLE)) {
        images.items[grid_offset] = 658 + (random.items[grid_offset] & 7);
        map_property_set_multi_tile_size(grid_offset, 1);
        edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
        aqueduct.items[grid_offset] = 0;
    }
}

static void map_building_tiles_remove(int building_id, int x, int y)
{
    if (!map_grid_is_inside(x, y, 1)) {
        return;
    }
    int size;
    int base_grid_offset = map_grid_offset(x, y);
    size = map_property_multi_tile_size(base_grid_offset);
    for (int i = 0; i < size && edge_grid.items[base_grid_offset] & EDGE_MASK_X; i++) {
        base_grid_offset += map_grid_delta(-1, 0);
    }
    for (int i = 0; i < size && edge_grid.items[base_grid_offset] & EDGE_MASK_Y; i++) {
        base_grid_offset += map_grid_delta(0, -1);
    }
    x = map_grid_offset_to_x(base_grid_offset);
    y = map_grid_offset_to_y(base_grid_offset);
    if (terrain_grid.items[base_grid_offset] == TERRAIN_ROCK) {
        return;
    }
    struct building_t *b = &all_buildings[building_id];
    if (building_id && building_is_farm(b->type)) {
        size = 3;
    }
    for (int dy = 0; dy < size; dy++) {
        for (int dx = 0; dx < size; dx++) {
            int grid_offset = map_grid_offset(x + dx, y + dy);
            if (building_id && map_building_at(grid_offset) != building_id) {
                continue;
            }
            if (building_id && b->type != BUILDING_BURNING_RUIN) {
                rubble_type_grid.items[grid_offset] = b->type;
            }
            bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
            map_property_set_multi_tile_size(grid_offset, 1);
            // only keep native land marker
            edge_grid.items[grid_offset] &= EDGE_NATIVE_LAND;
            edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
            aqueduct.items[grid_offset] = 0;
            buildings_grid.items[grid_offset] = 0;
            damage_grid.items[grid_offset] = 0;
            map_sprite_clear_tile(grid_offset);
            if (map_terrain_is(grid_offset, TERRAIN_WATER)) {
                terrain_grid.items[grid_offset] = TERRAIN_WATER; // clear other flags
                map_tiles_set_water(x + dx, y + dy);
            } else {
                images.items[grid_offset] = 246 + (random.items[grid_offset] & 7);
                terrain_grid.items[grid_offset] &= ~TERRAIN_CLEARABLE;
            }
        }
    }
    map_tiles_update_region_empty_land(x, y, x + size, y + size);
    foreach_region_tile(x, y, x + size, y + size, update_meadow_tile);
    foreach_region_tile(x, y, x + size, y + size, set_rubble_image);
}

static void map_property_set_multi_tile_xy(int grid_offset, int x, int y, int is_draw_tile)
{
    if (is_draw_tile) {
        edge_grid.items[grid_offset] = (8 * y + x) | EDGE_LEFTMOST_TILE;
    } else {
        edge_grid.items[grid_offset] = 8 * y + x;
    }
}

static void map_building_tiles_add(int building_id, int x, int y, int size, int image_id, int terrain)
{
    if (!map_grid_is_inside(x, y, size)) {
        return;
    }
    int x_leftmost, y_leftmost;
    switch (view_data.orientation) {
        case DIR_0_TOP:
            x_leftmost = 0;
            y_leftmost = size - 1;
            break;
        case DIR_2_RIGHT:
            x_leftmost = y_leftmost = 0;
            break;
        case DIR_4_BOTTOM:
            x_leftmost = size - 1;
            y_leftmost = 0;
            break;
        case DIR_6_LEFT:
            x_leftmost = y_leftmost = size - 1;
            break;
        default:
            return;
    }
    for (int dy = 0; dy < size; dy++) {
        for (int dx = 0; dx < size; dx++) {
            int grid_offset = map_grid_offset(x + dx, y + dy);
            terrain_grid.items[grid_offset] &= ~TERRAIN_CLEARABLE;
            terrain_grid.items[grid_offset] |= terrain;
            buildings_grid.items[grid_offset] = building_id;
            bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
            map_property_set_multi_tile_size(grid_offset, size);
            images.items[grid_offset] = image_id;
            map_property_set_multi_tile_xy(grid_offset, dx, dy, dx == x_leftmost && dy == y_leftmost);
        }
    }
}

static void building_house_merge(struct building_t *house)
{
    if (house->house_is_merged) {
        return;
    }
    if ((random.items[house->grid_offset] & 7) >= 5) {
        return;
    }
    int num_house_tiles = 0;
    for (int i = 0; i < 4; i++) {
        int tile_offset = house->grid_offset + HOUSE_TILE_OFFSETS[i];
        if (map_terrain_is(tile_offset, TERRAIN_BUILDING)) {
            struct building_t *other_house = &all_buildings[map_building_at(tile_offset)];
            if (other_house->id == house->id) {
                num_house_tiles++;
            } else if (other_house->state == BUILDING_STATE_IN_USE && other_house->house_size &&
                    other_house->subtype.house_level == house->subtype.house_level &&
                    !other_house->house_is_merged) {
                num_house_tiles++;
            }
        }
    }
    if (num_house_tiles == 4) {
        undo_data.available = 0;
        merge_data.x = house->x + EXPAND_DIRECTION_DELTA[0].x;
        merge_data.y = house->y + EXPAND_DIRECTION_DELTA[0].y;
        prepare_for_merge(house->id, 4);
        house->size = house->house_size = 2;
        house->house_population += merge_data.population;
        for (int i = 0; i < INVENTORY_MAX; i++) {
            house->data.house.inventory[i] += merge_data.inventory[i];
        }
        int image_id = HOUSE_IMAGE[house->subtype.house_level].img_id + 4;
        if (HOUSE_IMAGE[house->subtype.house_level].offset) {
            image_id += 1;
        }
        map_building_tiles_remove(house->id, house->x, house->y);
        house->x = merge_data.x;
        house->y = merge_data.y;
        house->grid_offset = map_grid_offset(house->x, house->y);
        house->house_is_merged = 1;
        map_building_tiles_add(house->id, house->x, house->y, 2, image_id, TERRAIN_BUILDING);
    }
}

static void building_house_change_to(struct building_t *house, int type)
{
    house->type = type;
    house->subtype.house_level = house->type - BUILDING_HOUSE_SMALL_TENT;
    int image_id = HOUSE_IMAGE[house->subtype.house_level].img_id;
    if (house->house_is_merged) {
        image_id += 4;
        if (HOUSE_IMAGE[house->subtype.house_level].offset) {
            image_id += 1;
        }
    } else {
        image_id += HOUSE_IMAGE[house->subtype.house_level].offset;
        image_id += random.items[house->grid_offset] & (HOUSE_IMAGE[house->subtype.house_level].num_types - 1);
    }
    map_building_tiles_add(house->id, house->x, house->y, house->size, image_id, TERRAIN_BUILDING);
}

static int evolve_small_tent(struct building_t *house, struct house_demands_t *demands)
{
    if (house->house_population > 0) {
        building_house_merge(house);
        int status = check_requirements(house, demands);
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LARGE_TENT);
        }
    }
    return 0;
}

static int has_devolve_delay(struct building_t *house, int status)
{
    if (status == DEVOLVE && house->data.house.devolve_delay < 2) {
        house->data.house.devolve_delay++;
        return 1;
    } else {
        house->data.house.devolve_delay = 0;
        return 0;
    }
}

static int evolve_large_tent(struct building_t *house, struct house_demands_t *demands)
{
    if (house->house_population > 0) {
        building_house_merge(house);
        int status = check_requirements(house, demands);
        if (!has_devolve_delay(house, status)) {
            if (status == EVOLVE) {
                building_house_change_to(house, BUILDING_HOUSE_SMALL_SHACK);
            } else if (status == DEVOLVE) {
                building_house_change_to(house, BUILDING_HOUSE_SMALL_TENT);
            }
        }
    }
    return 0;
}

static int evolve_small_shack(struct building_t *house, struct house_demands_t *demands)
{
    building_house_merge(house);
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LARGE_SHACK);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LARGE_TENT);
        }
    }
    return 0;
}

static int evolve_large_shack(struct building_t *house, struct house_demands_t *demands)
{
    building_house_merge(house);
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_HOVEL);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_SHACK);
        }
    }
    return 0;
}

static int evolve_small_hovel(struct building_t *house, struct house_demands_t *demands)
{
    building_house_merge(house);
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LARGE_HOVEL);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LARGE_SHACK);
        }
    }
    return 0;
}

static int evolve_large_hovel(struct building_t *house, struct house_demands_t *demands)
{
    building_house_merge(house);
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_CASA);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_HOVEL);
        }
    }
    return 0;
}

static int evolve_small_casa(struct building_t *house, struct house_demands_t *demands)
{
    building_house_merge(house);
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LARGE_CASA);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LARGE_HOVEL);
        }
    }
    return 0;
}

static int evolve_large_casa(struct building_t *house, struct house_demands_t *demands)
{
    building_house_merge(house);
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_INSULA);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_CASA);
        }
    }
    return 0;
}

static int evolve_small_insula(struct building_t *house, struct house_demands_t *demands)
{
    building_house_merge(house);
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_MEDIUM_INSULA);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LARGE_CASA);
        }
    }
    return 0;
}

static   char *lang_get_string(int group, int index)
{
    char *str = &lang_data.text_data[lang_data.text_entries[group].offset];
    char prev = 0;
    while (index > 0) {
        if (!*str && (prev >= ' ' || prev == 0)) {
            --index;
        }
        prev = *str;
        ++str;
    }
    while (*str < ' ') { // skip non-printables
        ++str;
    }
    return str;
}

static void city_warning_show(int type)
{
    char *text;
    if (type == WARNING_ORIENTATION) {
        text = lang_get_string(17, view_data.orientation);
    } else {
        text = lang_get_string(19, type - 2);
    }
    city_warning_show_custom(text);
}

static struct building_t *building_create(int type, int x, int y)
{
    struct building_t *b = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        int undo_contains_building = 0;
        if (undo_data.ready && undo_data.available) {
            if (undo_data.num_buildings) {
                for (int j = 0; j < MAX_UNDO_BUILDINGS; j++) {
                    if (undo_data.buildings[j].id == i) {
                        undo_contains_building = 1;
                        break;
                    }
                }
            }
        }
        if (all_buildings[i].state == BUILDING_STATE_UNUSED && !undo_contains_building) {
            b = &all_buildings[i];
            break;
        }
    }
    if (!b) {
        city_warning_show(WARNING_DATA_LIMIT_REACHED);
        return &all_buildings[0];
    }
    memset(&(b->data), 0, sizeof(b->data));
    b->state = BUILDING_STATE_CREATED;
    b->type = type;
    b->size = building_properties[type].size;
    b->created_sequence = extra.created_sequence++;
    b->sentiment.house_happiness = 50;
    // house size
    b->house_size = 0;
    if (type >= BUILDING_HOUSE_VACANT_LOT && type <= BUILDING_HOUSE_MEDIUM_INSULA) {
        b->house_size = 1;
    } else if (type >= BUILDING_HOUSE_LARGE_INSULA && type <= BUILDING_HOUSE_MEDIUM_VILLA) {
        b->house_size = 2;
    } else if (type >= BUILDING_HOUSE_LARGE_VILLA && type <= BUILDING_HOUSE_MEDIUM_PALACE) {
        b->house_size = 3;
    } else if (type >= BUILDING_HOUSE_LARGE_PALACE && type <= BUILDING_HOUSE_LUXURY_PALACE) {
        b->house_size = 4;
    }
    // subtype
    if (building_is_house(type) && type != BUILDING_HOUSE_VACANT_LOT) {
        b->subtype.house_level = type - BUILDING_HOUSE_SMALL_TENT;
    } else {
        b->subtype.house_level = 0;
    }
    // input/output resources
    switch (type) {
        case BUILDING_WHEAT_FARM:
            b->output_resource_id = RESOURCE_WHEAT;
            break;
        case BUILDING_VEGETABLE_FARM:
            b->output_resource_id = RESOURCE_VEGETABLES;
            break;
        case BUILDING_FRUIT_FARM:
            b->output_resource_id = RESOURCE_FRUIT;
            break;
        case BUILDING_OLIVE_FARM:
            b->output_resource_id = RESOURCE_OLIVES;
            break;
        case BUILDING_VINES_FARM:
            b->output_resource_id = RESOURCE_VINES;
            break;
        case BUILDING_PIG_FARM:
            b->output_resource_id = RESOURCE_MEAT;
            break;
        case BUILDING_MARBLE_QUARRY:
            b->output_resource_id = RESOURCE_MARBLE;
            break;
        case BUILDING_IRON_MINE:
            b->output_resource_id = RESOURCE_IRON;
            break;
        case BUILDING_TIMBER_YARD:
            b->output_resource_id = RESOURCE_TIMBER;
            break;
        case BUILDING_CLAY_PIT:
            b->output_resource_id = RESOURCE_CLAY;
            break;
        case BUILDING_WINE_WORKSHOP:
            b->output_resource_id = RESOURCE_WINE;
            b->subtype.workshop_type = WORKSHOP_VINES_TO_WINE;
            break;
        case BUILDING_OIL_WORKSHOP:
            b->output_resource_id = RESOURCE_OIL;
            b->subtype.workshop_type = WORKSHOP_OLIVES_TO_OIL;
            break;
        case BUILDING_WEAPONS_WORKSHOP:
            b->output_resource_id = RESOURCE_WEAPONS;
            b->subtype.workshop_type = WORKSHOP_IRON_TO_WEAPONS;
            break;
        case BUILDING_FURNITURE_WORKSHOP:
            b->output_resource_id = RESOURCE_FURNITURE;
            b->subtype.workshop_type = WORKSHOP_TIMBER_TO_FURNITURE;
            break;
        case BUILDING_POTTERY_WORKSHOP:
            b->output_resource_id = RESOURCE_POTTERY;
            b->subtype.workshop_type = WORKSHOP_CLAY_TO_POTTERY;
            break;
        default:
            b->output_resource_id = RESOURCE_NONE;
            break;
    }
    if (type == BUILDING_GRANARY) {
        b->data.granary.resource_stored[RESOURCE_NONE] = 2400;
    }
    b->x = x;
    b->y = y;
    b->grid_offset = map_grid_offset(x, y);
    b->house_figure_generation_delay = random.items[b->grid_offset] & 0x7f;
    b->figure_roam_direction = b->house_figure_generation_delay & 6;
    b->fire_proof = building_properties[type].fire_proof;
    return b;
}

static void create_house_tile(int type, int x, int y, int image_id, int population, int *inventory)
{
    struct building_t *house = building_create(type, x, y);
    house->house_population = population;
    for (int i = 0; i < INVENTORY_MAX; i++) {
        house->data.house.inventory[i] = inventory[i];
    }
    map_building_tiles_add(house->id, house->x, house->y, 1, image_id + (random.items[house->grid_offset] & 1), TERRAIN_BUILDING);
}

static void split_size2(struct building_t *house, int new_type)
{
    int inventory_per_tile[INVENTORY_MAX];
    int inventory_remainder[INVENTORY_MAX];
    for (int i = 0; i < INVENTORY_MAX; i++) {
        inventory_per_tile[i] = house->data.house.inventory[i] / 4;
        inventory_remainder[i] = house->data.house.inventory[i] % 4;
    }
    int population_per_tile = house->house_population / 4;
    int population_remainder = house->house_population % 4;

    map_building_tiles_remove(house->id, house->x, house->y);

    // main tile
    house->type = new_type;
    house->subtype.house_level = house->type - BUILDING_HOUSE_SMALL_TENT;
    house->size = house->house_size = 1;
    house->house_is_merged = 0;
    house->house_population = population_per_tile + population_remainder;
    for (int i = 0; i < INVENTORY_MAX; i++) {
        house->data.house.inventory[i] = inventory_per_tile[i] + inventory_remainder[i];
    }

    int image_id = HOUSE_IMAGE[house->subtype.house_level].img_id + HOUSE_IMAGE[house->subtype.house_level].offset;
    map_building_tiles_add(house->id, house->x, house->y, house->size,
                           image_id + (random.items[house->grid_offset] & 1), TERRAIN_BUILDING);

    // the other tiles (new buildings)
    create_house_tile(house->type, house->x + 1, house->y, image_id, population_per_tile, inventory_per_tile);
    create_house_tile(house->type, house->x, house->y + 1, image_id, population_per_tile, inventory_per_tile);
    create_house_tile(house->type, house->x + 1, house->y + 1, image_id, population_per_tile, inventory_per_tile);
}

static void split(struct building_t *house, int num_tiles)
{
    int grid_offset = map_grid_offset(merge_data.x, merge_data.y);
    for (int i = 0; i < num_tiles; i++) {
        int tile_offset = grid_offset + HOUSE_TILE_OFFSETS[i];
        if (map_terrain_is(tile_offset, TERRAIN_BUILDING)) {
            struct building_t *other_house = &all_buildings[map_building_at(tile_offset)];
            if (other_house->id != house->id && other_house->house_size) {
                if (other_house->house_is_merged == 1) {
                    split_size2(other_house, other_house->type);
                } else if (other_house->house_size == 2) {
                    split_size2(other_house, BUILDING_HOUSE_MEDIUM_INSULA);
                } else if (other_house->house_size == 3) {
                    int inventory_per_tile[INVENTORY_MAX];
                    int inventory_remainder[INVENTORY_MAX];
                    for (int ii = 0; ii < INVENTORY_MAX; ii++) {
                        inventory_per_tile[ii] = other_house->data.house.inventory[ii] / 9;
                        inventory_remainder[ii] = other_house->data.house.inventory[ii] % 9;
                    }
                    int population_per_tile = other_house->house_population / 9;
                    int population_remainder = other_house->house_population % 9;
                    map_building_tiles_remove(other_house->id, other_house->x, other_house->y);
                    // main tile
                    other_house->type = BUILDING_HOUSE_MEDIUM_INSULA;
                    other_house->subtype.house_level = other_house->type - BUILDING_HOUSE_SMALL_TENT;
                    other_house->size = other_house->house_size = 1;
                    other_house->house_is_merged = 0;
                    other_house->house_population = population_per_tile + population_remainder;
                    for (int ii = 0; ii < INVENTORY_MAX; ii++) {
                        other_house->data.house.inventory[ii] = inventory_per_tile[ii] + inventory_remainder[ii];
                    }

                    int image_id = HOUSE_IMAGE[other_house->subtype.house_level].img_id + HOUSE_IMAGE[other_house->subtype.house_level].offset;
                    map_building_tiles_add(other_house->id, other_house->x, other_house->y, other_house->size,
                                           image_id + (random.items[other_house->grid_offset] & 1), TERRAIN_BUILDING);
                    // the other tiles (new buildings)
                    create_house_tile(other_house->type, other_house->x, other_house->y + 1, image_id, population_per_tile, inventory_per_tile);
                    create_house_tile(other_house->type, other_house->x + 1, other_house->y + 1, image_id, population_per_tile, inventory_per_tile);
                    create_house_tile(other_house->type, other_house->x + 2, other_house->y + 1, image_id, population_per_tile, inventory_per_tile);
                    create_house_tile(other_house->type, other_house->x, other_house->y + 2, image_id, population_per_tile, inventory_per_tile);
                    create_house_tile(other_house->type, other_house->x + 1, other_house->y + 2, image_id, population_per_tile, inventory_per_tile);
                    create_house_tile(other_house->type, other_house->x + 2, other_house->y + 2, image_id, population_per_tile, inventory_per_tile);
                }
            }
        }
    }
}

static int building_house_can_expand(struct building_t *house, int num_tiles)
{
    // merge with other houses
    for (int dir = 0; dir < MAX_DIR; dir++) {
        int base_offset = EXPAND_DIRECTION_DELTA[dir].offset + house->grid_offset;
        int ok_tiles = 0;
        for (int i = 0; i < num_tiles; i++) {
            int tile_offset = base_offset + HOUSE_TILE_OFFSETS[i];
            if (map_terrain_is(tile_offset, TERRAIN_BUILDING)) {
                struct building_t *other_house = &all_buildings[map_building_at(tile_offset)];
                if (other_house->id == house->id) {
                    ok_tiles++;
                } else if (other_house->state == BUILDING_STATE_IN_USE && other_house->house_size) {
                    if (other_house->subtype.house_level <= house->subtype.house_level) {
                        ok_tiles++;
                    }
                }
            }
        }
        if (ok_tiles == num_tiles) {
            merge_data.x = house->x + EXPAND_DIRECTION_DELTA[dir].x;
            merge_data.y = house->y + EXPAND_DIRECTION_DELTA[dir].y;
            return 1;
        }
    }
    // merge with houses and empty terrain
    for (int dir = 0; dir < MAX_DIR; dir++) {
        int base_offset = EXPAND_DIRECTION_DELTA[dir].offset + house->grid_offset;
        int ok_tiles = 0;
        for (int i = 0; i < num_tiles; i++) {
            int tile_offset = base_offset + HOUSE_TILE_OFFSETS[i];
            if (!map_terrain_is(tile_offset, TERRAIN_NOT_CLEAR)) {
                ok_tiles++;
            } else if (map_terrain_is(tile_offset, TERRAIN_BUILDING)) {
                struct building_t *other_house = &all_buildings[map_building_at(tile_offset)];
                if (other_house->id == house->id) {
                    ok_tiles++;
                } else if (other_house->state == BUILDING_STATE_IN_USE && other_house->house_size) {
                    if (other_house->subtype.house_level <= house->subtype.house_level) {
                        ok_tiles++;
                    }
                }
            }
        }
        if (ok_tiles == num_tiles) {
            merge_data.x = house->x + EXPAND_DIRECTION_DELTA[dir].x;
            merge_data.y = house->y + EXPAND_DIRECTION_DELTA[dir].y;
            return 1;
        }
    }
    // merge with houses, empty terrain and gardens
    for (int dir = 0; dir < MAX_DIR; dir++) {
        int base_offset = EXPAND_DIRECTION_DELTA[dir].offset + house->grid_offset;
        int ok_tiles = 0;
        for (int i = 0; i < num_tiles; i++) {
            int tile_offset = base_offset + HOUSE_TILE_OFFSETS[i];
            if (!map_terrain_is(tile_offset, TERRAIN_NOT_CLEAR)) {
                ok_tiles++;
            } else if (map_terrain_is(tile_offset, TERRAIN_BUILDING)) {
                struct building_t *other_house = &all_buildings[map_building_at(tile_offset)];
                if (other_house->id == house->id) {
                    ok_tiles++;
                } else if (other_house->state == BUILDING_STATE_IN_USE && other_house->house_size) {
                    if (other_house->subtype.house_level <= house->subtype.house_level) {
                        ok_tiles++;
                    }
                }
            } else if (map_terrain_is(tile_offset, TERRAIN_GARDEN)) {
                ok_tiles++;
            }
        }
        if (ok_tiles == num_tiles) {
            merge_data.x = house->x + EXPAND_DIRECTION_DELTA[dir].x;
            merge_data.y = house->y + EXPAND_DIRECTION_DELTA[dir].y;
            return 1;
        }
    }
    house->data.house.no_space_to_expand = 1;
    return 0;
}

static void map_tiles_update_all_gardens(void)
{
    // clear garden image
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (map_terrain_is(grid_offset, TERRAIN_GARDEN)
            && !map_terrain_is(grid_offset, TERRAIN_ELEVATION | TERRAIN_ACCESS_RAMP)) {
                images.items[grid_offset] = 0;
                map_property_set_multi_tile_size(grid_offset, 1);
                edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
            }
        }
    }
    // set garden image
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (map_terrain_is(grid_offset, TERRAIN_GARDEN)
                && !map_terrain_is(grid_offset, TERRAIN_ELEVATION | TERRAIN_ACCESS_RAMP)) {
                if (!images.items[grid_offset]) {
                    int image_id = 3148;
                    int all_terrain_in_area_is_garden = 1;
                    if (map_grid_is_inside(x, y, 2)) {
                        for (int dy = 0; dy < 2; dy++) {
                            for (int dx = 0; dx < 2; dx++) {
                                int grid_offset2 = map_grid_offset(x + dx, y + dy);
                                if ((terrain_grid.items[grid_offset2] & TERRAIN_NOT_CLEAR) != TERRAIN_GARDEN) {
                                    all_terrain_in_area_is_garden = 0;
                                    break;
                                }
                                if (images.items[grid_offset2]) {
                                    all_terrain_in_area_is_garden = 0;
                                    break;
                                }
                            }
                        }
                    }
                    if (all_terrain_in_area_is_garden) {
                        switch (random.items[grid_offset] & 3) {
                            case 0: case 1:
                                image_id += 6;
                                break;
                            case 2:
                                image_id += 5;
                                break;
                            case 3:
                                image_id += 4;
                                break;
                        }
                        map_building_tiles_add(0, x, y, 2, image_id, TERRAIN_GARDEN);
                    } else {
                        if (y & 1) {
                            switch (x & 3) {
                                case 0: case 2:
                                    image_id += 2;
                                    break;
                                case 1: case 3:
                                    image_id += 3;
                                    break;
                            }
                        } else {
                            switch (x & 3) {
                                case 1: case 3:
                                    image_id += 1;
                                    break;
                            }
                        }
                        images.items[grid_offset] = image_id;
                    }
                }
            }
        }
    }
}

static int evolve_medium_insula(struct building_t *house, struct house_demands_t *demands)
{
    building_house_merge(house);
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            if (building_house_can_expand(house, 4)) {
                undo_data.available = 0;
                house->house_is_merged = 0;
                split(house, 4);
                prepare_for_merge(house->id, 4);

                house->type = BUILDING_HOUSE_LARGE_INSULA;
                house->subtype.house_level = HOUSE_LARGE_INSULA;
                house->size = house->house_size = 2;
                house->house_population += merge_data.population;
                for (int i = 0; i < INVENTORY_MAX; i++) {
                    house->data.house.inventory[i] += merge_data.inventory[i];
                }
                int image_id = HOUSE_IMAGE[house->subtype.house_level].img_id + HOUSE_IMAGE[house->subtype.house_level].offset + (random.items[house->grid_offset] & 1);
                map_building_tiles_remove(house->id, house->x, house->y);
                house->x = merge_data.x;
                house->y = merge_data.y;
                house->grid_offset = map_grid_offset(house->x, house->y);
                map_building_tiles_add(house->id, house->x, house->y, house->size, image_id, TERRAIN_BUILDING);
                map_tiles_update_all_gardens();
                return 1;
            }
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_INSULA);
        }
    }
    return 0;
}

static int evolve_large_insula(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_GRAND_INSULA);
        } else if (status == DEVOLVE) {
            undo_data.available = 0;
            split_size2(house, BUILDING_HOUSE_MEDIUM_INSULA);
        }
    }
    return 0;
}

static int evolve_grand_insula(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_VILLA);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LARGE_INSULA);
        }
    }
    return 0;
}

static int evolve_small_villa(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_MEDIUM_VILLA);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_GRAND_INSULA);
        }
    }
    return 0;
}

static int evolve_medium_villa(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            if (building_house_can_expand(house, 9)) {
                undo_data.available = 0;
                split(house, 9);
                prepare_for_merge(house->id, 9);

                house->type = BUILDING_HOUSE_LARGE_VILLA;
                house->subtype.house_level = HOUSE_LARGE_VILLA;
                house->size = house->house_size = 3;
                house->house_population += merge_data.population;
                for (int i = 0; i < INVENTORY_MAX; i++) {
                    house->data.house.inventory[i] += merge_data.inventory[i];
                }
                int image_id = HOUSE_IMAGE[house->subtype.house_level].img_id + HOUSE_IMAGE[house->subtype.house_level].offset;
                map_building_tiles_remove(house->id, house->x, house->y);
                house->x = merge_data.x;
                house->y = merge_data.y;
                house->grid_offset = map_grid_offset(house->x, house->y);
                map_building_tiles_add(house->id, house->x, house->y, house->size, image_id, TERRAIN_BUILDING);
                map_tiles_update_all_gardens();
                return 1;
            }
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_VILLA);
        }
    }
    return 0;
}

static int evolve_large_villa(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_GRAND_VILLA);
        } else if (status == DEVOLVE) {
            undo_data.available = 0;
            int inventory_per_tile[INVENTORY_MAX];
            int inventory_remainder[INVENTORY_MAX];
            for (int i = 0; i < INVENTORY_MAX; i++) {
                inventory_per_tile[i] = house->data.house.inventory[i] / 6;
                inventory_remainder[i] = house->data.house.inventory[i] % 6;
            }
            int population_per_tile = house->house_population / 6;
            int population_remainder = house->house_population % 6;

            map_building_tiles_remove(house->id, house->x, house->y);

            // main tile
            house->type = BUILDING_HOUSE_MEDIUM_VILLA;
            house->subtype.house_level = house->type - BUILDING_HOUSE_SMALL_TENT;
            house->size = house->house_size = 2;
            house->house_is_merged = 0;
            house->house_population = population_per_tile + population_remainder;
            for (int i = 0; i < INVENTORY_MAX; i++) {
                house->data.house.inventory[i] = inventory_per_tile[i] + inventory_remainder[i];
            }

            int image_id = HOUSE_IMAGE[house->subtype.house_level].img_id + HOUSE_IMAGE[house->subtype.house_level].offset;
            map_building_tiles_add(house->id, house->x, house->y, house->size, image_id + (random.items[house->grid_offset] & 1), TERRAIN_BUILDING);

            // the other tiles (new buildings)
            image_id = HOUSE_IMAGE[HOUSE_MEDIUM_INSULA].img_id + HOUSE_IMAGE[HOUSE_MEDIUM_INSULA].offset;
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x + 2, house->y, image_id, population_per_tile, inventory_per_tile);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x + 2, house->y + 1, image_id, population_per_tile, inventory_per_tile);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x, house->y + 2, image_id, population_per_tile, inventory_per_tile);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x + 1, house->y + 2, image_id, population_per_tile, inventory_per_tile);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x + 2, house->y + 2, image_id, population_per_tile, inventory_per_tile);
        }
    }
    return 0;
}

static int evolve_grand_villa(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_PALACE);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LARGE_VILLA);
        }
    }
    return 0;
}

static int evolve_small_palace(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_MEDIUM_PALACE);
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_GRAND_VILLA);
        }
    }
    return 0;
}

static int evolve_medium_palace(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            if (building_house_can_expand(house, 16)) {
                undo_data.available = 0;
                split(house, 16);
                prepare_for_merge(house->id, 16);

                house->type = BUILDING_HOUSE_LARGE_PALACE;
                house->subtype.house_level = HOUSE_LARGE_PALACE;
                house->size = house->house_size = 4;
                house->house_population += merge_data.population;
                for (int i = 0; i < INVENTORY_MAX; i++) {
                    house->data.house.inventory[i] += merge_data.inventory[i];
                }
                int image_id = HOUSE_IMAGE[house->subtype.house_level].img_id + HOUSE_IMAGE[house->subtype.house_level].offset;
                map_building_tiles_remove(house->id, house->x, house->y);
                house->x = merge_data.x;
                house->y = merge_data.y;
                house->grid_offset = map_grid_offset(house->x, house->y);
                map_building_tiles_add(house->id, house->x, house->y, house->size, image_id, TERRAIN_BUILDING);
                map_tiles_update_all_gardens();
                return 1;
            }
        } else if (status == DEVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_SMALL_PALACE);
        }
    }
    return 0;
}

static int evolve_large_palace(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_requirements(house, demands);
    if (!has_devolve_delay(house, status)) {
        if (status == EVOLVE) {
            building_house_change_to(house, BUILDING_HOUSE_LUXURY_PALACE);
        } else if (status == DEVOLVE) {
            undo_data.available = 0;
            int inventory_per_tile[INVENTORY_MAX];
            int inventory_remainder[INVENTORY_MAX];
            for (int i = 0; i < INVENTORY_MAX; i++) {
                inventory_per_tile[i] = house->data.house.inventory[i] / 8;
                inventory_remainder[i] = house->data.house.inventory[i] % 8;
            }
            int population_per_tile = house->house_population / 8;
            int population_remainder = house->house_population % 8;

            map_building_tiles_remove(house->id, house->x, house->y);

            // main tile
            house->type = BUILDING_HOUSE_MEDIUM_PALACE;
            house->subtype.house_level = house->type - BUILDING_HOUSE_SMALL_TENT;
            house->size = house->house_size = 3;
            house->house_is_merged = 0;
            house->house_population = population_per_tile + population_remainder;
            for (int i = 0; i < INVENTORY_MAX; i++) {
                house->data.house.inventory[i] = inventory_per_tile[i] + inventory_remainder[i];
            }

            int image_id = HOUSE_IMAGE[house->subtype.house_level].img_id + HOUSE_IMAGE[house->subtype.house_level].offset;
            map_building_tiles_add(house->id, house->x, house->y, house->size, image_id, TERRAIN_BUILDING);

            // the other tiles (new buildings)
            image_id = HOUSE_IMAGE[HOUSE_MEDIUM_INSULA].img_id + HOUSE_IMAGE[HOUSE_MEDIUM_INSULA].offset;
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x + 3, house->y, image_id, population_per_tile, inventory_per_tile);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x + 3, house->y + 1, image_id, population_per_tile, inventory_per_tile);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x + 3, house->y + 2, image_id, population_per_tile, inventory_per_tile);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x, house->y + 3, image_id, population_per_tile, inventory_per_tile);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x + 1, house->y + 3, image_id, population_per_tile, inventory_per_tile);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x + 2, house->y + 3, image_id, population_per_tile, inventory_per_tile);
            create_house_tile(BUILDING_HOUSE_MEDIUM_INSULA, house->x + 3, house->y + 3, image_id, population_per_tile, inventory_per_tile);
        }
    }
    return 0;
}

static int evolve_luxury_palace(struct building_t *house, struct house_demands_t *demands)
{
    int status = check_evolve_desirability(house);
    if (!has_required_goods_and_services(house, 0, demands)) {
        status = DEVOLVE;
    }
    if (!has_devolve_delay(house, status) && status == DEVOLVE) {
        building_house_change_to(house, BUILDING_HOUSE_LARGE_PALACE);
    }
    return 0;
}

static int (*evolve_callback[])(struct building_t *, struct house_demands_t *) = {
    evolve_small_tent, evolve_large_tent, evolve_small_shack, evolve_large_shack,
    evolve_small_hovel, evolve_large_hovel, evolve_small_casa, evolve_large_casa,
    evolve_small_insula, evolve_medium_insula, evolve_large_insula, evolve_grand_insula,
    evolve_small_villa, evolve_medium_villa, evolve_large_villa, evolve_grand_villa,
    evolve_small_palace, evolve_medium_palace, evolve_large_palace, evolve_luxury_palace
};

static void consume_resource(struct building_t *b, int inventory, int amount)
{
    if (amount > 0) {
        if (amount > b->data.house.inventory[inventory]) {
            b->data.house.inventory[inventory] = 0;
        } else {
            b->data.house.inventory[inventory] -= amount;
        }
    }
}

static int map_water_get_wharf_for_new_fishing_boat(struct figure_t *boat, struct map_point_t *tile)
{
    struct building_t *wharf = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_WHARF) {
            int wharf_boat_id = b->data.industry.fishing_boat_id;
            if (!wharf_boat_id || wharf_boat_id == boat->id) {
                wharf = b;
                break;
            }
        }
    }
    if (!wharf) {
        return 0;
    }
    int dx, dy;
    switch (wharf->data.industry.orientation) {
        case 0: dx = 1; dy = -1; break;
        case 1: dx = 2; dy = 1; break;
        case 2: dx = 1; dy = 2; break;
        default: dx = -1; dy = 1; break;
    }
    tile->x = wharf->x + dx;
    tile->y = wharf->y + dy;
    return wharf->id;
}

static int building_dock_get_queue_destination(struct map_point_t *tile)
{
    if (!city_data.building.working_docks) {
        return 0;
    }
    // first queue position
    for (int i = 0; i < 10; i++) {
        int dock_id = city_data.building.working_dock_ids[i];
        if (!dock_id) continue;
        struct building_t *dock = &all_buildings[dock_id];
        int dx, dy;
        switch (dock->data.dock.orientation) {
            case 0: dx = 2; dy = -2; break;
            case 1: dx = 4; dy = 2; break;
            case 2: dx = 2; dy = 4; break;
            default: dx = -2; dy = 2; break;
        }
        tile->x = dock->x + dx;
        tile->y = dock->y + dy;
        if (!(map_grid_is_valid_offset(map_grid_offset(tile->x, tile->y)) && map_figures.items[map_grid_offset(tile->x, tile->y)] > 0)) {
            return dock_id;
        }
    }
    // second queue position
    for (int i = 0; i < 10; i++) {
        int dock_id = city_data.building.working_dock_ids[i];
        if (!dock_id) continue;
        struct building_t *dock = &all_buildings[dock_id];
        int dx, dy;
        switch (dock->data.dock.orientation) {
            case 0: dx = 2; dy = -3; break;
            case 1: dx = 5; dy = 2; break;
            case 2: dx = 2; dy = 5; break;
            default: dx = -3; dy = 2; break;
        }
        tile->x = dock->x + dx;
        tile->y = dock->y + dy;
        if (!(map_grid_is_valid_offset(map_grid_offset(tile->x, tile->y)) && map_figures.items[map_grid_offset(tile->x, tile->y)] > 0)) {
            return dock_id;
        }
    }
    return 0;
}

static int building_dock_get_free_destination(int ship_id, struct map_point_t *tile)
{
    if (!city_data.building.working_docks) {
        return 0;
    }
    int dock_id = 0;
    for (int i = 0; i < 10; i++) {
        dock_id = city_data.building.working_dock_ids[i];
        if (!dock_id) continue;
        struct building_t *dock = &all_buildings[dock_id];
        if (!dock->data.dock.trade_ship_id || dock->data.dock.trade_ship_id == ship_id) {
            break;
        }
    }
    // BUG: when 10 docks in city, always takes last one... regardless of whether it is free
    if (dock_id <= 0) {
        return 0;
    }
    struct building_t *dock = &all_buildings[dock_id];
    int dx, dy;
    switch (dock->data.dock.orientation) {
        case 0: dx = 1; dy = -1; break;
        case 1: dx = 3; dy = 1; break;
        case 2: dx = 1; dy = 3; break;
        default: dx = -1; dy = 1; break;
    }
    tile->x = dock->x + dx;
    tile->y = dock->y + dy;
    dock->data.dock.trade_ship_id = ship_id;
    return dock_id;
}

static int can_import_resource_from_trade_city(int city_id, int resource)
{
    if (!empire_objects[city_id].resource_sell_limit[resource]) {
        return 0;
    }
    if (city_data.resource.trade_status[resource] != TRADE_STATUS_IMPORT) {
        return 0;
    }
    if (empire_objects[city_id].resource_sold[resource] >= empire_objects[city_id].resource_sell_limit[resource]) {
        return 0;
    }
    int in_stock = city_data.resource.stored_in_warehouses[resource];
    int max_in_stock = 0;
    int finished_good = RESOURCE_NONE;
    switch (resource) {
        // food and finished materials
        case RESOURCE_WHEAT:
        case RESOURCE_VEGETABLES:
        case RESOURCE_FRUIT:
        case RESOURCE_MEAT:
        case RESOURCE_POTTERY:
        case RESOURCE_FURNITURE:
        case RESOURCE_OIL:
        case RESOURCE_WINE:
            if (city_data.population.population < 2000) {
                max_in_stock = 10;
            } else if (city_data.population.population < 4000) {
                max_in_stock = 20;
            } else if (city_data.population.population < 6000) {
                max_in_stock = 30;
            } else {
                max_in_stock = 40;
            }
            break;
        case RESOURCE_MARBLE:
        case RESOURCE_WEAPONS:
            max_in_stock = 10;
            break;

        case RESOURCE_CLAY:
            finished_good = RESOURCE_POTTERY;
            break;
        case RESOURCE_TIMBER:
            finished_good = RESOURCE_FURNITURE;
            break;
        case RESOURCE_OLIVES:
            finished_good = RESOURCE_OIL;
            break;
        case RESOURCE_VINES:
            finished_good = RESOURCE_WINE;
            break;
        case RESOURCE_IRON:
            finished_good = RESOURCE_WEAPONS;
            break;
    }
    if (finished_good) {
        max_in_stock = 2 + 2 * count_data.industry[finished_good].active;
    }
    return in_stock < max_in_stock ? 1 : 0;
}

static int can_export_resource_to_trade_city(int city_id, int resource)
{
    if (city_id && empire_objects[city_id].resource_bought[resource] >= empire_objects[city_id].resource_buy_limit[resource]) {
        // quota reached
        return 0;
    }
    if (city_data.resource.stored_in_warehouses[resource] <= city_data.resource.export_over[resource]) {
        // stocks too low
        return 0;
    }
    if (city_id == 0 || empire_objects[city_id].resource_buy_limit[resource]) {
        return city_data.resource.trade_status[resource] == TRADE_STATUS_EXPORT;
    } else {
        return 0;
    }
}

static int get_delta(int value1, int value2)
{
    if (value1 <= value2) {
        return value2 - value1;
    } else {
        return value1 - value2;
    }
}

static int calc_maximum_distance(int x1, int y1, int x2, int y2)
{
    int distance_x = get_delta(x1, x2);
    int distance_y = get_delta(y1, y2);
    if (distance_x >= distance_y) {
        return distance_x;
    } else {
        return distance_y;
    }
}

static int city_trade_next_caravan_import_resource(void)
{
    city_data.trade.caravan_import_resource++;
    if (city_data.trade.caravan_import_resource >= RESOURCE_TYPES_MAX) {
        city_data.trade.caravan_import_resource = RESOURCE_WHEAT;
    }
    return city_data.trade.caravan_import_resource;
}

static void find_minimum_road_tile(int x, int y, int size, int *min_value, int *min_grid_offset)
{
    int base_offset = map_grid_offset(x, y);
    for (int *tile_delta = ADJACENT_OFFSETS_MAP_GRID[size]; *tile_delta; tile_delta++) {
        int grid_offset = base_offset + *tile_delta;
        if (!map_terrain_is(grid_offset, TERRAIN_BUILDING) ||
            all_buildings[map_building_at(grid_offset)].type != BUILDING_GATEHOUSE) {
            if (map_terrain_is(grid_offset, TERRAIN_ROAD)) {
                int road_index = 11;
                for (int n = 0; n < 10; n++) {
                    if (city_data.map.largest_road_networks[n].id == network.items[grid_offset]) {
                        road_index = n;
                    }
                }
                if (road_index < *min_value) {
                    *min_value = road_index;
                    *min_grid_offset = grid_offset;
                }
            }
        }
    }
}

static int map_has_road_access(int x, int y, int size, struct map_point_t *road)
{
    int min_value = 12;
    int min_grid_offset = map_grid_offset(x, y);
    find_minimum_road_tile(x, y, size, &min_value, &min_grid_offset);
    if (min_value < 12) {
        if (road) {
            road->x = map_grid_offset_to_x(min_grid_offset);
            road->y = map_grid_offset_to_y(min_grid_offset);
        }
        return 1;
    }
    return 0;
}

static int get_closest_warehouse(struct figure_t *f, int x, int y, int city_id, struct map_point_t *warehouse)
{
    int exportable[RESOURCE_TYPES_MAX];
    int importable[RESOURCE_TYPES_MAX];
    exportable[RESOURCE_NONE] = 0;
    importable[RESOURCE_NONE] = 0;
    for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
        exportable[r] = can_export_resource_to_trade_city(city_id, r);
        if (f->trader_amount_bought >= 8) {
            exportable[r] = 0;
        }
        if (city_id) {
            importable[r] = can_import_resource_from_trade_city(city_id, r);
        } else { // Don't import goods from native traders
            importable[r] = 0;
        }
        if (f->loads_sold_or_carrying >= 8) {
            importable[r] = 0;
        }
    }
    int num_importable = 0;
    for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
        if (importable[r]) {
            num_importable++;
        }
    }
    int min_distance = 10000;
    struct building_t *min_building = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_WAREHOUSE) {
            continue;
        }
        if (!b->has_road_access) {
            continue;
        }
        struct building_storage_t *s = &storages[b->storage_id].storage;
        int num_imports_for_warehouse = 0;
        for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
            if (s->resource_state[r] != BUILDING_STORAGE_STATE_NOT_ACCEPTING
                && can_import_resource_from_trade_city(city_id, r)) {
                num_imports_for_warehouse++;
            }
        }
        int distance_penalty = 32;
        struct building_t *space = b;
        for (int space_cnt = 0; space_cnt < 8; space_cnt++) {
            space = &all_buildings[space->next_part_building_id];
            if (space->id && exportable[space->subtype.warehouse_resource_id]) {
                distance_penalty -= 4;
            }
            if (num_importable && num_imports_for_warehouse && !s->empty_all) {
                for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                    int import_resource = city_trade_next_caravan_import_resource();
                    if (s->resource_state[import_resource] != BUILDING_STORAGE_STATE_NOT_ACCEPTING) {
                        break;
                    }
                }
                int resource = city_data.trade.caravan_import_resource;
                if (s->resource_state[resource] != BUILDING_STORAGE_STATE_NOT_ACCEPTING) {
                    if (space->subtype.warehouse_resource_id == RESOURCE_NONE) {
                        distance_penalty -= 16;
                    }
                    if (space->id && importable[space->subtype.warehouse_resource_id] && space->loads_stored < 4 &&
                        space->subtype.warehouse_resource_id == resource) {
                        distance_penalty -= 8;
                    }
                }
            }
        }
        if (distance_penalty < 32) {
            int distance = calc_maximum_distance(b->x, b->y, x, y);
            distance += distance_penalty;
            if (distance < min_distance) {
                min_distance = distance;
                min_building = b;
            }
        }
    }
    if (!min_building) {
        return 0;
    }
    if (min_building->has_road_access == 1) {
        warehouse->x = min_building->x;
        warehouse->y = min_building->y;
    } else if (!map_has_road_access(min_building->x, min_building->y, 3, warehouse)) {
        return 0;
    }
    return min_building->id;
}

static void go_to_next_warehouse(struct figure_t *f, int x_src, int y_src)
{
    struct map_point_t dst;
    int warehouse_id = get_closest_warehouse(f, x_src, y_src, f->empire_city_id, &dst);
    if (warehouse_id) {
        f->destination_building_id = warehouse_id;
        f->action_state = FIGURE_ACTION_TRADE_CARAVAN_ARRIVING;
        f->destination_x = dst.x;
        f->destination_y = dst.y;
    } else {
        f->action_state = FIGURE_ACTION_TRADE_CARAVAN_LEAVING;
        f->destination_x = scenario.exit_point.x;
        f->destination_y = scenario.exit_point.y;
    }
}

static void city_resource_remove_from_warehouse(int resource, int amount)
{
    city_data.resource.space_in_warehouses[resource] += amount;
    city_data.resource.stored_in_warehouses[resource] -= amount;
}

static void city_finance_process_export(int price)
{
    city_data.finance.treasury += price;
    city_data.finance.this_year.income.exports += price;
    if (city_data.religion.neptune_double_trade_active) {
        city_data.finance.treasury += price;
        city_data.finance.this_year.income.exports += price;
    }
}

static int resource_image_offset(int resource, int type)
{
    if (resource == RESOURCE_MEAT && scenario.allowed_buildings[BUILDING_WHARF]) {
        switch (type) {
            case RESOURCE_IMAGE_STORAGE: return 40;
            case RESOURCE_IMAGE_CART: return 648;
            case RESOURCE_IMAGE_FOOD_CART: return 8;
            case RESOURCE_IMAGE_ICON: return 11;
            default: return 0;
        }
    } else {
        return 0;
    }
}

static void building_warehouse_space_set_image(struct building_t *space, int resource)
{
    int image_id;
    if (space->loads_stored <= 0) {
        image_id = 3337;
    } else {
        image_id = resource_images[resource].warehouse_space_img_id +
            resource_image_offset(resource, RESOURCE_IMAGE_STORAGE) +
            space->loads_stored - 1;
    }
    images.items[space->grid_offset] = image_id;
}

static int trader_get_buy_resource(int warehouse_id, int city_id)
{
    struct building_t *warehouse = &all_buildings[warehouse_id];
    if (warehouse->type != BUILDING_WAREHOUSE) {
        return RESOURCE_NONE;
    }
    struct building_t *space = warehouse;
    for (int i = 0; i < 8; i++) {
        space = &all_buildings[space->next_part_building_id];
        if (space->id <= 0) {
            continue;
        }
        int resource = space->subtype.warehouse_resource_id;
        if (space->loads_stored > 0 && can_export_resource_to_trade_city(city_id, resource)) {
            // update stocks
            city_resource_remove_from_warehouse(resource, 1);
            space->loads_stored--;
            if (space->loads_stored <= 0) {
                space->subtype.warehouse_resource_id = RESOURCE_NONE;
            }
            // update finances
            city_finance_process_export(trade_prices[resource].sell);

            // update graphics
            building_warehouse_space_set_image(space, resource);
            return resource;
        }
    }
    return 0;
}

static void figure_route_remove(struct figure_t *f)
{
    if (f->routing_path_id > 0) {
        if (figure_route_data.figure_ids[f->routing_path_id] == f->id) {
            figure_route_data.figure_ids[f->routing_path_id] = 0;
        }
        f->routing_path_id = 0;
    }
}

static int terrain_is_road_like(int grid_offset)
{
    return map_terrain_is(grid_offset, TERRAIN_ROAD | TERRAIN_ACCESS_RAMP) ? 1 : 0;
}

static int get_adjacent_road_tile_for_roaming(int grid_offset)
{
    int is_road = terrain_is_road_like(grid_offset);
    if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
        struct building_t *b = &all_buildings[map_building_at(grid_offset)];
        if (b->type == BUILDING_GATEHOUSE) {
            is_road = 0;
        } else if (b->type == BUILDING_GRANARY) {
            if (terrain_land_citizen.items[grid_offset] == CITIZEN_0_ROAD) {
                is_road = 1;
            }
        }
    }
    return is_road;
}

static int map_get_diagonal_road_tiles_for_roaming(int grid_offset, int *road_tiles)
{
    road_tiles[1] = terrain_is_road_like(grid_offset + map_grid_delta(1, -1));
    road_tiles[3] = terrain_is_road_like(grid_offset + map_grid_delta(1, 1));
    road_tiles[5] = terrain_is_road_like(grid_offset + map_grid_delta(-1, 1));
    road_tiles[7] = terrain_is_road_like(grid_offset + map_grid_delta(-1, -1));

    int max_stretch = 0;
    int stretch = 0;
    for (int i = 0; i < 16; i++) {
        if (road_tiles[i % 8]) {
            stretch++;
            if (stretch > max_stretch) {
                max_stretch = stretch;
            }
        } else {
            stretch = 0;
        }
    }
    return max_stretch;
}

static int calc_general_direction(int x_from, int y_from, int x_to, int y_to)
{
    if (x_from < x_to) {
        if (y_from > y_to) {
            return DIR_1_TOP_RIGHT;
        } else if (y_from == y_to) {
            return DIR_2_RIGHT;
        } else if (y_from < y_to) {
            return DIR_3_BOTTOM_RIGHT;
        }
    } else if (x_from == x_to) {
        if (y_from > y_to) {
            return DIR_0_TOP;
        } else if (y_from < y_to) {
            return DIR_4_BOTTOM;
        }
    } else if (x_from > x_to) {
        if (y_from > y_to) {
            return DIR_7_TOP_LEFT;
        } else if (y_from == y_to) {
            return DIR_6_LEFT;
        } else if (y_from < y_to) {
            return DIR_5_BOTTOM_LEFT;
        }
    }
    return DIR_8_NONE;
}

static void roam_set_direction(struct figure_t *f)
{
    int grid_offset = map_grid_offset(f->x, f->y);
    int direction = calc_general_direction(f->x, f->y, f->destination_x, f->destination_y);
    if (direction >= 8) {
        direction = 0;
    }
    int road_offset_dir1 = 0;
    int road_dir1 = 0;
    for (int i = 0, dir = direction; i < 8; i++) {
        if (dir % 2 == 0 && map_terrain_is(grid_offset + map_grid_direction_delta(dir), TERRAIN_ROAD)) {
            road_dir1 = dir;
            break;
        }
        dir++;
        if (dir > 7) dir = 0;
        road_offset_dir1++;
    }
    int road_offset_dir2 = 0;
    int road_dir2 = 0;
    for (int i = 0, dir = direction; i < 8; i++) {
        if (dir % 2 == 0 && map_terrain_is(grid_offset + map_grid_direction_delta(dir), TERRAIN_ROAD)) {
            road_dir2 = dir;
            break;
        }
        dir--;
        if (dir < 0) dir = 7;
        road_offset_dir2++;
    }
    if (road_offset_dir1 <= road_offset_dir2) {
        f->direction = road_dir1;
        f->roam_turn_direction = 2;
    } else {
        f->direction = road_dir2;
        f->roam_turn_direction = -2;
    }
    f->roam_ticks_until_next_turn = 5;
}

static void adjust_tile_in_direction(int direction, int *x, int *y, int *grid_offset)
{
    switch (direction) {
        case DIR_0_TOP:
            --*y;
            break;
        case DIR_1_TOP_RIGHT:
            ++*x;
            --*y;
            break;
        case DIR_2_RIGHT:
            ++*x;
            break;
        case DIR_3_BOTTOM_RIGHT:
            ++*x;
            ++*y;
            break;
        case DIR_4_BOTTOM:
            ++*y;
            break;
        case DIR_5_BOTTOM_LEFT:
            --*x;
            ++*y;
            break;
        case DIR_6_LEFT:
            --*x;
            break;
        case DIR_7_TOP_LEFT:
            --*x;
            --*y;
            break;
    }
    *grid_offset += map_grid_direction_delta(direction);
}

static int map_routing_get_path(uint8_t *path, int src_x, int src_y, int dst_x, int dst_y, int num_directions)
{
    int dst_grid_offset = map_grid_offset(dst_x, dst_y);
    int distance = routing_distance.items[dst_grid_offset];
    if (distance <= 0 || distance >= 998) {
        return 0;
    }
    int num_tiles = 0;
    int last_direction = -1;
    int x = dst_x;
    int y = dst_y;
    int grid_offset = dst_grid_offset;
    int step = num_directions == 8 ? 1 : 2;
    while (distance > 1) {
        distance = routing_distance.items[grid_offset];
        int direction = -1;
        int general_direction = calc_general_direction(x, y, src_x, src_y);
        for (int d = 0; d < 8; d += step) {
            if (d != last_direction) {
                int next_offset = grid_offset + map_grid_direction_delta(d);
                int next_distance = routing_distance.items[next_offset];
                if (next_distance) {
                    if (next_distance < distance) {
                        distance = next_distance;
                        direction = d;
                    } else if (next_distance == distance && (d == general_direction || direction == -1)) {
                        distance = next_distance;
                        direction = d;
                    }
                }
            }
        }
        if (direction == -1) {
            return 0;
        }
        adjust_tile_in_direction(direction, &x, &y, &grid_offset);
        int forward_direction = (direction + 4) % 8;
        direction_path[num_tiles++] = forward_direction;
        last_direction = forward_direction;
        if (num_tiles >= MAX_PATH) {
            return 0;
        }
    }
    for (int i = 0; i < num_tiles; i++) {
        path[i] = direction_path[num_tiles - i - 1];
    }
    return num_tiles;
}

static int map_routing_get_path_on_water(uint8_t *path, int dst_x, int dst_y, int is_flotsam)
{
    int rand = random_data.random1_7bit & 3;
    int dst_grid_offset = map_grid_offset(dst_x, dst_y);
    int distance = routing_distance.items[dst_grid_offset];
    if (distance <= 0 || distance >= 998) {
        return 0;
    }
    int num_tiles = 0;
    int last_direction = -1;
    int x = dst_x;
    int y = dst_y;
    int grid_offset = dst_grid_offset;
    while (distance > 1) {
        int current_rand = rand;
        distance = routing_distance.items[grid_offset];
        if (is_flotsam) {
            current_rand = random.items[grid_offset] & 3;
        }
        int direction = -1;
        for (int d = 0; d < 8; d++) {
            if (d != last_direction) {
                int next_offset = grid_offset + map_grid_direction_delta(d);
                int next_distance = routing_distance.items[next_offset];
                if (next_distance) {
                    if (next_distance < distance) {
                        distance = next_distance;
                        direction = d;
                    } else if (next_distance == distance && rand == current_rand) {
                        // allow flotsam to wander
                        distance = next_distance;
                        direction = d;
                    }
                }
            }
        }
        if (direction == -1) {
            return 0;
        }
        adjust_tile_in_direction(direction, &x, &y, &grid_offset);
        int forward_direction = (direction + 4) % 8;
        direction_path[num_tiles++] = forward_direction;
        last_direction = forward_direction;
        if (num_tiles >= MAX_PATH) {
            return 0;
        }
    }
    for (int i = 0; i < num_tiles; i++) {
        path[i] = direction_path[num_tiles - i - 1];
    }
    return num_tiles;
}

static void enqueue(int next_offset, int dist)
{
    routing_distance.items[next_offset] = dist;
    routing_queue.items[routing_queue.tail++] = next_offset;
    if (routing_queue.tail >= MAX_QUEUE_ROUTING) {
        routing_queue.tail = 0;
    }
}

static void callback_travel_citizen_land(int next_offset, int dist)
{
    if (terrain_land_citizen.items[next_offset] >= 0) {
        enqueue(next_offset, dist);
    }
}

static int valid_offset(int grid_offset)
{
    return map_grid_is_valid_offset(grid_offset) && routing_distance.items[grid_offset] == 0;
}

static void route_queue(int source, int dest, void (*callback)(int next_offset, int dist))
{
    memset(routing_distance.items, 0, GRID_SIZE * GRID_SIZE * sizeof(int16_t));
    routing_queue.head = routing_queue.tail = 0;
    enqueue(source, 1);
    while (routing_queue.head != routing_queue.tail) {
        int offset = routing_queue.items[routing_queue.head];
        if (offset == dest) {
            break;
        }
        int dist = 1 + routing_distance.items[offset];
        for (int i = 0; i < 4; i++) {
            if (valid_offset(offset + ROUTE_OFFSETS[i])) {
                callback(offset + ROUTE_OFFSETS[i], dist);
            }
        }
        if (++routing_queue.head >= MAX_QUEUE_ROUTING) {
            routing_queue.head = 0;
        }
    }
}

static int map_routing_citizen_can_travel_over_land(int src_x, int src_y, int dst_x, int dst_y)
{
    int src_offset = map_grid_offset(src_x, src_y);
    int dst_offset = map_grid_offset(dst_x, dst_y);
    ++stats.total_routes_calculated;
    route_queue(src_offset, dst_offset, callback_travel_citizen_land);
    return routing_distance.items[dst_offset] != 0;
}

static void callback_travel_walls(int next_offset, int dist)
{
    if (terrain_walls.items[next_offset] >= WALL_0_PASSABLE &&
        terrain_walls.items[next_offset] <= 2) {
        enqueue(next_offset, dist);
    }
}

static void callback_travel_citizen_road_garden(int next_offset, int dist)
{
    if (terrain_land_citizen.items[next_offset] >= CITIZEN_0_ROAD &&
        terrain_land_citizen.items[next_offset] <= CITIZEN_2_PASSABLE_TERRAIN) {
        enqueue(next_offset, dist);
    }
}

static int map_routing_citizen_can_travel_over_road_garden(int src_x, int src_y, int dst_x, int dst_y)
{
    int src_offset = map_grid_offset(src_x, src_y);
    int dst_offset = map_grid_offset(dst_x, dst_y);
    ++stats.total_routes_calculated;
    route_queue(src_offset, dst_offset, callback_travel_citizen_road_garden);
    return routing_distance.items[dst_offset] != 0;
}

static void labor_seeker_coverage(__attribute__((unused)) struct building_t *b)
{}

static void theater_coverage(struct building_t *b)
{
    b->data.house.theater = MAX_COVERAGE;
}

static void amphitheater_coverage(struct building_t *b, int shows)
{
    b->data.house.amphitheater_actor = MAX_COVERAGE;
    if (shows == 2) {
        b->data.house.amphitheater_gladiator = MAX_COVERAGE;
    }
}

static void colosseum_coverage(struct building_t *b, int shows)
{
    b->data.house.colosseum_gladiator = MAX_COVERAGE;
    if (shows == 2) {
        b->data.house.colosseum_lion = MAX_COVERAGE;
    }
}

static void hippodrome_coverage(struct building_t *b)
{
    b->data.house.hippodrome = MAX_COVERAGE;
}

static void bathhouse_coverage(struct building_t *b)
{
    b->data.house.bathhouse = MAX_COVERAGE;
}

static void religion_coverage_ceres(struct building_t *b)
{
    b->data.house.temple_ceres = MAX_COVERAGE;
}

static void religion_coverage_neptune(struct building_t *b)
{
    b->data.house.temple_neptune = MAX_COVERAGE;
}

static void religion_coverage_mercury(struct building_t *b)
{
    b->data.house.temple_mercury = MAX_COVERAGE;
}

static void religion_coverage_mars(struct building_t *b)
{
    b->data.house.temple_mars = MAX_COVERAGE;
}

static void religion_coverage_venus(struct building_t *b)
{
    b->data.house.temple_venus = MAX_COVERAGE;
}

static void school_coverage(struct building_t *b)
{
    b->data.house.school = MAX_COVERAGE;
}

static void academy_coverage(struct building_t *b)
{
    b->data.house.academy = MAX_COVERAGE;
}

static void library_coverage(struct building_t *b)
{
    b->data.house.library = MAX_COVERAGE;
}

static void barber_coverage(struct building_t *b)
{
    b->data.house.barber = MAX_COVERAGE;
}

static void clinic_coverage(struct building_t *b)
{
    b->data.house.clinic = MAX_COVERAGE;
}

static void hospital_coverage(struct building_t *b)
{
    b->data.house.hospital = MAX_COVERAGE;
}

static int provide_service(int x, int y, int *data, void (*callback)(struct building_t *, int *))
{
    int serviced = 0;
    int x_min, y_min, x_max, y_max;
    map_grid_get_area(x, y, 1, 2, &x_min, &y_min, &x_max, &y_max);
    for (int yy = y_min; yy <= y_max; yy++) {
        for (int xx = x_min; xx <= x_max; xx++) {
            int grid_offset = map_grid_offset(xx, yy);
            int building_id = map_building_at(grid_offset);
            if (building_id) {
                struct building_t *b = &all_buildings[building_id];
                callback(b, data);
                if (b->house_size && b->house_population > 0) {
                    serviced++;
                }
            }
        }
    }
    return serviced;
}

static void engineer_coverage(struct building_t *b, int *max_damage_seen)
{
    if (b->type == BUILDING_HIPPODROME) {
        b = building_main(b);
    }
    if (b->damage_risk > *max_damage_seen) {
        *max_damage_seen = b->damage_risk;
    }
    b->damage_risk = 0;
}

static int provide_culture(int x, int y, void (*callback)(struct building_t *))
{
    int serviced = 0;
    int x_min, y_min, x_max, y_max;
    map_grid_get_area(x, y, 1, 2, &x_min, &y_min, &x_max, &y_max);
    for (int yy = y_min; yy <= y_max; yy++) {
        for (int xx = x_min; xx <= x_max; xx++) {
            int grid_offset = map_grid_offset(xx, yy);
            int building_id = map_building_at(grid_offset);
            if (building_id) {
                struct building_t *b = &all_buildings[building_id];
                if (b->house_size && b->house_population > 0) {
                    callback(b);
                    serviced++;
                }
            }
        }
    }
    return serviced;
}

static int provide_entertainment(int x, int y, int shows, void (*callback)(struct building_t *, int))
{
    int serviced = 0;
    int x_min, y_min, x_max, y_max;
    map_grid_get_area(x, y, 1, 2, &x_min, &y_min, &x_max, &y_max);
    for (int yy = y_min; yy <= y_max; yy++) {
        for (int xx = x_min; xx <= x_max; xx++) {
            int grid_offset = map_grid_offset(xx, yy);
            int building_id = map_building_at(grid_offset);
            if (building_id) {
                struct building_t *b = &all_buildings[building_id];
                if (b->house_size && b->house_population > 0) {
                    callback(b, shows);
                    serviced++;
                }
            }
        }
    }
    return serviced;
}

static void tax_collector_coverage(struct building_t *b, int *max_tax_multiplier)
{
    if (b->house_size && b->house_population > 0) {
        if (house_properties[b->subtype.house_level].tax_multiplier > *max_tax_multiplier) {
            *max_tax_multiplier = house_properties[b->subtype.house_level].tax_multiplier;
        }
        b->house_tax_coverage = 50;
    }
}

static void prefect_coverage(struct building_t *b, int *min_happiness_seen)
{
    if (b->type == BUILDING_HIPPODROME) {
        b = building_main(b);
    }
    b->fire_risk = 0;
    if (b->sentiment.house_happiness < *min_happiness_seen) {
        *min_happiness_seen = b->sentiment.house_happiness;
    }
}

static void distribute_good(struct building_t *b, struct building_t *market, int stock_wanted, int inventory_resource)
{
    int amount_wanted = stock_wanted - b->data.house.inventory[inventory_resource];
    if (market->data.market.inventory[inventory_resource] > 0 && amount_wanted > 0) {
        if (amount_wanted <= market->data.market.inventory[inventory_resource]) {
            b->data.house.inventory[inventory_resource] += amount_wanted;
            market->data.market.inventory[inventory_resource] -= amount_wanted;
        } else {
            b->data.house.inventory[inventory_resource] += market->data.market.inventory[inventory_resource];
            market->data.market.inventory[inventory_resource] = 0;
        }
    }
}

static int city_message_get_text_id(int message_type)
{
    if (message_type > 50) {
        return message_type + 199;
    } else {
        return message_type + 99;
    }
}

static void play_sound_effect(int effect)
{
    if (!settings[SETTINGS_SOUND_EFFECTS_ENABLED].config_value) {
        return;
    }
    if (sound_channels[effect].chunk && Mix_Playing(effect)) {
        return;
    }
    struct sound_channel_t *ch = &sound_channels[effect];
    if (load_channel(ch)) {
        set_channel_volume(effect, settings[SETTINGS_SOUND_EFFECTS_VOLUME].config_value);
        Mix_PlayChannel(effect, ch->chunk, 0);
    }
}

static void play_sound(int text_id)
{
    if (lang_data.message_entries[text_id].urgent == 1) {
        play_sound_effect(SOUND_EFFECT_FANFARE_URGENT);
    } else {
        play_sound_effect(SOUND_EFFECT_FANFARE);
    }
}

static void prepend_dir_to_path(char *dir_to_prepend, char *filepath, char *resulting_string)
{
    size_t dir_len = string_length(dir_to_prepend) + 1;
    string_copy(dir_to_prepend, resulting_string, DIR_PATH_MAX);
    resulting_string[dir_len - 1] = '\\';
    string_copy(filepath, &resulting_string[dir_len], DIR_PATH_MAX - dir_len - 1);
}

static int file_exists(char *dir, char *filename)
{
    if (dir) {
        static char filepath_to_save[DIR_PATH_MAX];
        filepath_to_save[DIR_PATH_MAX - 1] = 0;
        prepend_dir_to_path(dir, filename, filepath_to_save);
        if (access(filepath_to_save, F_OK) == 0) {
            return 1;
        } else {
            return 0;
        }
    } else {
        if (access(filename, F_OK) == 0) {
            return 1;
        } else {
            return 0;
        }
    }
}

static int string_to_int(char *str)
{
    static int multipliers[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000 };
    char *ptr = str;
    int negative = 0;
    int num_chars = 0;
    if (*ptr == '-') {
        negative = 1;
        ptr++;
    }
    while (*ptr >= '0' && *ptr <= '9') {
        num_chars++;
        ptr++;
    }

    if (num_chars > 8) {
        return 0;
    }
    ptr = str;
    if (*ptr == '-') {
        ptr++;
    }
    int result = 0;
    while (num_chars) {
        --num_chars;
        result += multipliers[num_chars] * (*ptr - '0');
        ptr++;
    }
    if (negative) {
        result = -result;
    }
    return result;
}

static void outer_panel_draw(int x, int y, int width_blocks, int height_blocks)
{
    int image_base = editor_active ? 1208 : 1205;
    int image_id;
    int image_y = 0;
    int y_add = 0;
    for (int yy = 0; yy < height_blocks; yy++) {
        int image_x = 0;
        for (int xx = 0; xx < width_blocks; xx++) {
            if (yy == 0) {
                if (xx == 0) {
                    image_id = 0;
                } else if (xx < width_blocks - 1) {
                    image_id = 1 + image_x++;
                } else {
                    image_id = 11;
                }
                y_add = 0;
            } else if (yy < height_blocks - 1) {
                if (xx == 0) {
                    image_id = 12 + image_y;
                } else if (xx < width_blocks - 1) {
                    image_id = 13 + image_y + image_x++;
                } else {
                    image_id = 23 + image_y;
                }
                y_add = 12;
            } else {
                if (xx == 0) {
                    image_id = 132;
                } else if (xx < width_blocks - 1) {
                    image_id = 133 + image_x++;
                } else {
                    image_id = 143;
                }
                y_add = 0;
            }
            image_draw(image_base + image_id, x + BLOCK_SIZE * xx, y + BLOCK_SIZE * yy);
            if (image_x >= 10) {
                image_x = 0;
            }
        }
        image_y += y_add;
        if (image_y >= 120) {
            image_y = 0;
        }
    }
}

static void graphics_draw_vertical_line(int x, int y1, int y2, uint32_t color)
{
    if (x < clip_rectangle.x_start || x >= clip_rectangle.x_end) {
        return;
    }
    int y_min = y1 < y2 ? y1 : y2;
    int y_max = y1 < y2 ? y2 : y1;
    y_min = y_min < clip_rectangle.y_start ? clip_rectangle.y_start : y_min;
    y_max = y_max >= clip_rectangle.y_end ? clip_rectangle.y_end - 1 : y_max;
    uint32_t *pixel = graphics_get_pixel(x, y_min);
    uint32_t *end_pixel = pixel + ((y_max - y_min) * canvas.width);
    while (pixel <= end_pixel) {
        *pixel = color;
        pixel += canvas.width;
    }
}

static void graphics_draw_rect(int x, int y, int width, int height, uint32_t color)
{
    graphics_draw_horizontal_line(x, x + width - 1, y, color);
    graphics_draw_horizontal_line(x, x + width - 1, y + height - 1, color);
    graphics_draw_vertical_line(x, y, y + height - 1, color);
    graphics_draw_vertical_line(x + width - 1, y, y + height - 1, color);
}

static void inner_panel_draw(int x, int y, int width_blocks, int height_blocks)
{
    int image_base = editor_active ? 1352 : 1349;
    int image_y = 0;
    int y_add = 0;
    for (int yy = 0; yy < height_blocks; yy++) {
        int image_x = 0;
        for (int xx = 0; xx < width_blocks; xx++) {
            int image_id;
            if (yy == 0) {
                if (xx == 0) {
                    image_id = 0;
                } else if (xx < width_blocks - 1) {
                    image_id = 1 + image_x++;
                } else {
                    image_id = 6;
                }
                y_add = 0;
            } else if (yy < height_blocks - 1) {
                if (xx == 0) {
                    image_id = 7 + image_y;
                } else if (xx < width_blocks - 1) {
                    image_id = 8 + image_y + image_x++;
                } else {
                    image_id = 13 + image_y;
                }
                y_add = 7;
            } else {
                if (xx == 0) {
                    image_id = 42;
                } else if (xx < width_blocks - 1) {
                    image_id = 43 + image_x++;
                } else {
                    image_id = 48;
                }
                y_add = 0;
            }
            image_draw(image_base + image_id, x + BLOCK_SIZE * xx, y + BLOCK_SIZE * yy);
            if (image_x >= 5) {
                image_x = 0;
            }
        }
        image_y += y_add;
        if (image_y >= 35) {
            image_y = 0;
        }
    }
}

static int text_draw_number(int value, char prefix, char *postfix, int x_offset, int y_offset, int font)
{
    char str[NUMBER_BUFFER_LENGTH];
    number_to_string(str, value, prefix, postfix);
    return text_draw(str, x_offset, y_offset, font, 0);
}

static int lang_text_draw(int group, int number, int x_offset, int y_offset, int font)
{
    char *str = lang_get_string(group, number);
    return text_draw(str, x_offset, y_offset, font, 0);
}

static int text_draw_year(int year, int x_offset, int y_offset, int font)
{
    int width = 0;
    if (year >= 0) {
        width += text_draw_number(year, ' ', " ", x_offset + width, y_offset, font);
        width += text_draw("AD", x_offset + width, y_offset, font, COLOR_BLACK);
    } else {
        width += text_draw_number(-year, ' ', " ", x_offset + width, y_offset, font);
        width += text_draw("BC", x_offset + width, y_offset, font, COLOR_BLACK);
    }
    return width;
}

static int lang_text_draw_amount(int group, int number, int amount, int x_offset, int y_offset, int font)
{
    int amount_offset = 1;
    if (amount == 1 || amount == -1) {
        amount_offset = 0;
    }
    int desc_offset_x;
    if (amount >= 0) {
        desc_offset_x = text_draw_number(amount, ' ', " ", x_offset, y_offset, font);
    } else {
        desc_offset_x = text_draw_number(-amount, '-', " ", x_offset, y_offset, font);
    }
    return desc_offset_x + lang_text_draw(group, number + amount_offset, x_offset + desc_offset_x, y_offset, font);
}

static inline void *clear_malloc(size_t s)
{
    void *buf = malloc(s);
    if (buf) {
        memset(buf, 0, s);
    }
    return buf;
}

static int32_t read_i32(uint8_t *data)
{
    return (int32_t) (data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24));
}

static struct bitstream_t *bitstream_init(struct bitstream_t *bs, uint8_t *data, int len)
{
    bs->data = data;
    bs->length = len;
    bs->index = 0;
    bs->bit_index = 0;
    return bs;
}

static int read_bit(struct bitstream_t *bs)
{
    if (bs->index >= bs->length) {
        return 0;
    }
    int result = bs->data[bs->index] & (1 << bs->bit_index);
    if (++bs->bit_index >= 8) {
        bs->index++;
        bs->bit_index = 0;
    }
    return result ? 1 : 0;
}

static inline uint8_t read_byte(struct bitstream_t *bs)
{
    if (bs->bit_index == 0) {
        // special case: on exact byte boundary
        if (bs->index < bs->length) {
            return bs->data[bs->index++];
        } else {
            return 0;
        }
    }
    if (bs->index + 1 >= bs->length) {
        return 0;
    }
    uint8_t value = bs->data[bs->index] >> bs->bit_index;
    bs->index++;
    value |= (bs->data[bs->index] & BIT_MASKS[bs->bit_index]) << (8 - bs->bit_index);
    return value;
}

static struct huffnode8_t *build_tree8_nodes(struct bitstream_t *bs, struct hufftree8_t *tree)
{
    struct huffnode8_t *node = &tree->nodes[tree->size++];
    if (read_bit(bs)) {
        node->is_leaf = 0;
        node->b[0] = build_tree8_nodes(bs, tree);
        node->b[1] = build_tree8_nodes(bs, tree);
    } else {
        node->is_leaf = 1;
        node->value = read_byte(bs);
    }
    return node;
}

static struct hufftree8_t *create_tree8(struct bitstream_t *bs)
{
    if (read_bit(bs)) {
        struct hufftree8_t *tree = (struct hufftree8_t *) clear_malloc(sizeof(struct hufftree8_t));
        if (!tree) {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: no memory for 8-bit tree", 0, 0));
            return 0;
        }
        build_tree8_nodes(bs, tree);
        if (read_bit(bs) != 0) {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: 8-bit tree not closed", 0, 0));
            free(tree);
            return 0;
        }
        return tree;
    } else {
        SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: WARN: no 8-bit tree found", 0, 0));
        return 0;
    }
}

static uint8_t lookup_tree8(struct bitstream_t *bs, struct hufftree8_t *tree)
{
    struct huffnode8_t *node = &tree->nodes[0];
    while (!node->is_leaf) {
        node = node->b[read_bit(bs)];
    }
    return node->value;
}

static void reset_escape16(struct hufftree16_t *tree)
{
    if (tree) {
        for (int i = 0; i < 3; i++) {
            tree->escape_nodes[i]->value = 0;
        }
    }
}

static uint16_t lookup_tree16(struct bitstream_t *bs, struct hufftree16_t *tree)
{
    if (!tree) {
        return 0;
    }
    struct huffnode16_t *node = tree->root;
    while (!node->is_leaf) {
        node = node->b[read_bit(bs)];
    }

    uint16_t value = node->value;
    if (value != tree->escape_nodes[0]->value) {
        tree->escape_nodes[2]->value = tree->escape_nodes[1]->value;
        tree->escape_nodes[1]->value = tree->escape_nodes[0]->value;
        tree->escape_nodes[0]->value = value;
    }
    return value;
}

static int decode_frame(smacker s)
{
    int frame_id = s->current_frame;
    if (frame_id >= s->frames) {
        return SMACKER_FRAME_DONE;
    }
    if (fseek(fp, s->frame_data_offset_in_file + s->frame_offsets[frame_id], SEEK_SET) != 0) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: unable to seek to frame data", 0, frame_id));
        return SMACKER_FRAME_ERROR;
    }
    int frame_size = s->frame_sizes[frame_id];
    uint8_t *frame_data = (uint8_t *) clear_malloc(frame_size);
    if (!frame_data) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: no memory for frame data", 0, frame_id));
        return SMACKER_FRAME_ERROR;
    }
    if (fread(frame_data, 1, frame_size, fp) != (unsigned) frame_size) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: unable to read data for frame", 0, frame_id));
        free(frame_data);
        return SMACKER_FRAME_ERROR;
    }
    uint8_t frame_type = s->frame_types[frame_id];
    int data_index = 0;
    if (frame_type & 0x01) {
        int palette_size = frame_data[0] * 4;
        uint8_t *data = &frame_data[1];
        uint32_t new_palette[MAX_PALETTE];
        int index = 0;
        int color_index = 0;
        while (index < palette_size - 1 && color_index < MAX_PALETTE) {
            if (data[index] & 0x80) {
                // Copy from same position in previous palette
                int num_entries = 1 + (data[index] & 0x7f);
                if (num_entries + color_index > MAX_PALETTE) {
                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: invalid palette data", 0, 0));
                    free(frame_data);
                    return SMACKER_FRAME_ERROR;
                }
                memcpy(&new_palette[color_index], &s->frame_data.palette[color_index], sizeof(int32_t) * num_entries);
                color_index += num_entries;
                index++;
            } else if (data[index] & 0x40) {
                // Copy from 'offset' position in previous palette
                int num_entries = 1 + (data[index] & 0x3f);
                int offset = data[index + 1];
                if (num_entries + color_index > MAX_PALETTE || num_entries + offset > MAX_PALETTE) {
                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: invalid palette data", 0, 0));
                    free(frame_data);
                    return SMACKER_FRAME_ERROR;
                }
                memcpy(&new_palette[color_index], &s->frame_data.palette[offset], sizeof(int32_t) * num_entries);
                color_index += num_entries;
                index += 2;
            } else {
                // Literal color
                new_palette[color_index] =
                    (PALETTE_MAP[data[index] & 0x3f] << 16) |
                    (PALETTE_MAP[data[index + 1] & 0x3f] << 8) |
                    (PALETTE_MAP[data[index + 2] & 0x3f]);
                color_index++;
                index += 3;
            }
        }
        memcpy(s->frame_data.palette, new_palette, sizeof(uint32_t) * MAX_PALETTE);
        data_index += palette_size;
    }
    for (int i = 0; i < MAX_TRACKS; i++) {
        if (frame_type & (1 << (i + 1))) {
            int track_length = read_i32(&frame_data[data_index]);
            uint8_t *data = &frame_data[data_index + 4];
            if ((s->audio_rate[i] & AUDIO_FLAG_COMPRESSED) == 0) {
                // Uncompressed data, just copy and return
                memcpy(s->frame_data.audio[i], data, track_length - 4);
                s->frame_data.audio_len[i] = track_length - 4;
            } else {
                int32_t uncompressed_length = read_i32(data);
                struct bitstream_t bstream;
                struct bitstream_t *bs = bitstream_init(&bstream, &data[4], track_length - 4 - 4);
                if (!read_bit(bs)) {
                    s->frame_data.audio_len[i] = 0;
                } else {
                    int is_stereo = read_bit(bs);
                    int is_16bit = read_bit(bs);
                    int header_is_stereo = (s->audio_rate[i] & AUDIO_FLAG_STEREO) ? 1 : 0;
                    int header_is_16bit = (s->audio_rate[i] & AUDIO_FLAG_16BIT) ? 1 : 0;
                    if (is_stereo != header_is_stereo) {
                        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: stereo flag in frame does not match header", 0, 0));
                    } else if (is_16bit != header_is_16bit) {
                        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: 16-bit flag in frame does not match header", 0, 0));
                    } else {
                        int channels = is_stereo ? 2 : 1;
                        int rate_bytes = is_16bit ? 2 : 1;
                        int num_trees = channels * rate_bytes;
                        struct hufftree8_t *trees[4];
                        for (int j = 0; j < num_trees; j++) {
                            trees[j] = create_tree8(bs);
                            if (!trees[j]) {
                                for (int k = 0; k < j; k++) {
                                    free(trees[k]);
                                }
                                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: unable to read audio huffman trees", 0, 0));
                                break;
                            }
                        }
                        if (is_16bit) {
                            uint16_t *audio_data = (uint16_t *) s->frame_data.audio[i];
                            int index = 0;
                            for (int c = 0; c < channels; c++) {
                                // Base of channels is reversed
                                audio_data[channels - c - 1] = read_byte(bs) << 8 | read_byte(bs);
                            }
                            index = channels;
                            while (index < uncompressed_length / 2) {
                                for (int c = 0; c < channels; c++) {
                                    uint16_t value = lookup_tree8(bs, trees[c * 2]);
                                    value |= lookup_tree8(bs, trees[c * 2 + 1]) << 8;
                                    audio_data[index] = value + audio_data[index - channels];
                                    index++;
                                }
                            }
                            s->frame_data.audio_len[i] = index * 2;
                        } else {
                            uint8_t *audio_data = s->frame_data.audio[i];
                            int index = 0;
                            for (int c = 0; c < channels; c++) {
                                // Base of channels is reversed
                                audio_data[channels - c - 1] = read_byte(bs);
                            }
                            index = channels;
                            while (index < uncompressed_length) {
                                for (int c = 0; c < channels; c++) {
                                    audio_data[index] = lookup_tree8(bs, trees[c]) + audio_data[index - channels];
                                    index++;
                                }
                            }
                            s->frame_data.audio_len[i] = index;
                        }
                    }
                }
            }
            data_index += track_length;
        } else {
            s->frame_data.audio_len[i] = 0;
        }
    }
    reset_escape16(s->mclr_tree);
    reset_escape16(s->mmap_tree);
    reset_escape16(s->full_tree);
    reset_escape16(s->type_tree);
    struct bitstream_t bstream;
    struct bitstream_t *bs = bitstream_init(&bstream, &frame_data[data_index], s->frame_sizes[frame_id] - data_index);
    uint8_t *video = s->frame_data.video;
    int block_type = 0;
    int chain = 0;
    uint8_t solid_color = 0;
    for (int row = 0; row < s->height; row += 4) {
        for (int col = 0; col < s->width; col += 4) {
            if (chain <= 0) {
                uint16_t type = lookup_tree16(bs, s->type_tree);
                block_type = type & 0x03;
                chain = CHAIN_SIZE[(type >> 2) & 0x3f];
                solid_color = type >> 8;
            }
            if (block_type == BLOCK_MONO) {
                uint16_t colors = lookup_tree16(bs, s->mclr_tree);
                uint8_t color1 = colors & 0xff;
                uint8_t color2 = colors >> 8;
                uint16_t map = lookup_tree16(bs, s->mmap_tree);
                for (int y = 0; y < 4; y++) {
                    uint8_t *pixel = &video[(row + y) * s->width + col];
                    pixel[0] = (map & 1) ? color2 : color1;
                    pixel[1] = (map & 2) ? color2 : color1;
                    pixel[2] = (map & 4) ? color2 : color1;
                    pixel[3] = (map & 8) ? color2 : color1;
                    map >>= 4;
                }
            } else if (block_type == BLOCK_FULL) {
                for (int y = 0; y < 4; y++) {
                    uint8_t *pixel = &video[(row + y) * s->width + col];
                    uint16_t colors = lookup_tree16(bs, s->full_tree);
                    pixel[2] = colors & 0xff;
                    pixel[3] = colors >> 8;
                    colors = lookup_tree16(bs, s->full_tree);
                    pixel[0] = colors & 0xff;
                    pixel[1] = colors >> 8;
                }
            } else if (block_type == BLOCK_SOLID) {
                for (int y = 0; y < 4; y++) {
                    uint8_t *pixel = &video[(row + y) * s->width + col];
                    pixel[0] = pixel[1] = pixel[2] = pixel[3] = solid_color;
                }
            }
            chain--;
        }
    }
    free(frame_data);
    return SMACKER_FRAME_OK;
}

static void free_node16(struct huffnode16_t *node)
{
    if (!node) {
        return;
    }
    if (!node->is_leaf) {
        free_node16(node->b[0]);
        free_node16(node->b[1]);
    }
    free(node);
}

static void free_tree16(struct hufftree16_t *tree)
{
    if (!tree) {
        return;
    }
    for (int i = 0; i < 3; i++) {
        if (tree->escape_nodes[i]) {
            if (!tree->escape_nodes[i]->is_leaf) {
                // Free manually allocated node because it's not in the tree
                free(tree->escape_nodes[i]);
            }
        }
    }
    free_node16(tree->root);
    free(tree->low);
    free(tree->high);
    free(tree);
}

static void smacker_close(smacker s)
{
    fclose(fp);
    free(s->frame_offsets);
    free(s->frame_sizes);
    free(s->frame_types);
    free_tree16(s->mclr_tree);
    free_tree16(s->mmap_tree);
    free_tree16(s->full_tree);
    free_tree16(s->type_tree);
    for (int i = 0; i < MAX_TRACKS; i++) {
        free(s->frame_data.audio[i]);
    }
    free(s->frame_data.video);
    free(s);
}

static void close_smk(void)
{
    if (data_video.s) {
        smacker_close(data_video.s);
        data_video.s = 0;
    }
}

static void free_custom_audio_stream(void)
{
    if (custom_music.stream) {
        SDL_FreeAudioStream(custom_music.stream);
        custom_music.stream = 0;
    }
    return;
}

static int city_figures_total_invading_enemies(void)
{
    return city_data.figure.imperial_soldiers + city_data.figure.enemies;
}

static void stop_music(void)
{
    if (music_channel) {
        Mix_HaltMusic();
        Mix_FreeMusic(music_channel);
        music_channel = 0;
    }
    sound_data.current_track = TRACK_NONE;
    sound_data.next_check = 0;
}

static int play_music(char *filename, int volume_pct)
{
    stop_music();
    if (!filename) {
        return 0;
    }
    music_channel = Mix_LoadMUS(filename);
    if (!music_channel) {
        SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION,
            "Error opening music file '%s'. Reason: %s", filename, Mix_GetError());
    } else {
        if (Mix_PlayMusic(music_channel, -1) == -1) {
            music_channel = 0;
            SDL_LogWarn(SDL_LOG_CATEGORY_APPLICATION,
                "Error playing music file '%s'. Reason: %s", filename, Mix_GetError());
        } else {
            Mix_VolumeMusic(volume_pct * SDL_MIX_MAXVOLUME / 100);
        }
    }
    return music_channel ? 1 : 0;
}

static void play_track(int track)
{
    stop_music();
    if (track <= TRACK_NONE || track >= TRACK_MAX) {
        return;
    }
    if (!play_music(mp3_tracks[track], settings[SETTINGS_MUSIC_VOLUME].config_value)) {
        play_music(tracks[track], settings[SETTINGS_MUSIC_VOLUME].config_value);
    }
    sound_data.current_track = track;
}

static void update_music(int force)
{
    if (sound_data.next_check && !force) {
        --sound_data.next_check;
        return;
    }
    if (!settings[SETTINGS_MUSIC_ENABLED].config_value) {
        return;
    }
    int track;
    int total_enemies = city_figures_total_invading_enemies();
    if (total_enemies >= 32) {
        track = TRACK_COMBAT_LONG;
    } else if (total_enemies > 0) {
        track = TRACK_COMBAT_SHORT;
    } else if (city_data.population.population < 1000) {
        track = TRACK_CITY_1;
    } else if (city_data.population.population < 2000) {
        track = TRACK_CITY_2;
    } else if (city_data.population.population < 5000) {
        track = TRACK_CITY_3;
    } else if (city_data.population.population < 7000) {
        track = TRACK_CITY_4;
    } else {
        track = TRACK_CITY_5;
    }

    if (track == sound_data.current_track) {
        return;
    }
    play_track(track);
    sound_data.next_check = 10;
}

static void end_video(void)
{
    Mix_HookMusic(0, 0);
    free_custom_audio_stream();
    if (data_video.restart_music) {
        update_music(1);
    }
}

static void write_custom_music_data(unsigned char *audio_data, int len)
{
    if (!audio_data || len <= 0 || custom_music.stream == 0) {
        return;
    }
    SDL_AudioStreamPut(custom_music.stream, audio_data, len);
}

static int get_next_frame(void)
{
    if (!data_video.s) {
        return 0;
    }
    uint32_t now_millis = SDL_GetTicks64();
    int frame_no = (now_millis - data_video.video.start_render_millis) * 1000 / data_video.video.micros_per_frame;
    int draw_frame = data_video.video.current_frame == 0;
    while (frame_no > data_video.video.current_frame) {
        data_video.s->current_frame++;
        if (decode_frame(data_video.s) != SMACKER_FRAME_OK) {
            close_smk();
            data_video.is_ended = 1;
            data_video.is_playing = 0;
            end_video();
            return 0;
        }
        data_video.video.current_frame++;
        draw_frame = 1;

        if (data_video.audio.has_audio) {
            int audio_len = data_video.s->frame_data.audio_len[0];
            if (audio_len > 0) {
                write_custom_music_data(data_video.s->frame_data.audio[0], audio_len);
            }
        }
    }
    return draw_frame;
}

static void video_stop(void)
{
    if (data_video.is_playing) {
        if (!data_video.is_ended) {
            end_video();
        }
        close_smk();
        data_video.is_playing = 0;
    }
}

static void cleanup_message_dialog(void)
{
    if (message_dialog_data.show_video) {
        video_stop();
        message_dialog_data.show_video = 0;
    }
    player_message.message_advisor = 0;
}

static void image_draw_scaled(int image_id, int x, int y, int width, int height)
{
    struct image_t *img = image_get(image_id);
    double scale_w = width / (double) img->width;
    double scale_h = height / (double) img->height;
    double scale = scale_w > scale_h ? scale_w : scale_h;
    if (x == 0 && y == 0 && scale <= 1.0f) { // fullscreen crop
        image_draw(image_id, (width - img->width) / 2, (height - img->height) / 2);
    } else {
        int x_offset = x + (int) ((width - img->width * scale) / 2);
        int y_offset = y + (int) ((height - img->height * scale) / 2);
        uint32_t *data = image_data(image_id);
        if (!data || img->draw.type == IMAGE_TYPE_ISOMETRIC || img->draw.is_fully_compressed || !scale) {
            return;
        }
        int adjusted_width = (int) (img->width * scale);
        int adjusted_height = (int) (img->height * scale);
        struct clip_info_t *clip = graphics_get_clip_info(x_offset, y_offset, adjusted_width, adjusted_height);
        if (clip && clip->is_visible) {
            for (int yy = clip->clipped_pixels_top; yy < adjusted_height - clip->clipped_pixels_bottom; yy++) {
                uint32_t *dst = graphics_get_pixel(x_offset + clip->clipped_pixels_left, y_offset + yy);
                int x_max = adjusted_width - clip->clipped_pixels_right;
                int image_y_offset = (int) (yy / scale) * img->width;
                for (int xx = clip->clipped_pixels_left; xx < x_max; xx++, dst++) {
                    uint32_t pixel = data[(int) (image_y_offset + xx / scale)];
                    if (pixel != COLOR_SG2_TRANSPARENT) {
                        *dst = pixel;
                    }
                }
            }
        }
    }
}

static void window_message_dialog_show(int text_id, void (*background_callback)(void));

static void button_none(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{}

static void speed_clear(struct speed_type_t *speed)
{
    speed->cumulative_delta = 0.0;
    speed->fine_position = 0.0;
    speed->desired_speed = 0.0;
    speed->current_speed = 0.0;
    speed->speed_difference = 0.0;
    speed->start_time = 0;
    speed->total_time = 0;
    speed->last_speed_check = current_time;
}

static double adjust_speed_for_frame_time(double delta, int adjust_for_time, uint32_t last_time)
{
    return adjust_for_time ? ((delta / (double) (current_time - last_time)) * FRAME_TIME) : delta;
}

static void speed_set_target(struct speed_type_t *speed, double new_speed, uint32_t total_time, int adjust_for_time)
{
    speed->adjust_for_time = adjust_for_time;
    if (new_speed == speed->desired_speed) {
        return;
    }
    if (total_time == SPEED_CHANGE_IMMEDIATE) {
        speed->desired_speed = new_speed;
        speed->current_speed = new_speed;
        speed->total_time = total_time;
        if (!adjust_for_time && current_time - speed->last_speed_check > 0) {
            speed->adjusted_current_speed = adjust_speed_for_frame_time(new_speed, 1, speed->last_speed_check);
        } else {
            speed->adjusted_current_speed = new_speed;
        }
        return;
    }
    speed->cumulative_delta = 0.0;
    speed->fine_position = 0.0;
    double base_speed = adjust_for_time ? speed->adjusted_current_speed : speed->current_speed;
    speed->speed_difference = base_speed - new_speed;
    speed->desired_speed = new_speed;
    speed->start_time = current_time;
    speed->total_time = total_time;
}

static void city_view_toggle_sidebar(void)
{
    if (view_data.sidebar_collapsed) {
        view_data.sidebar_collapsed = 0;
        set_viewport(0, 24, view_data.screen_width - 160, view_data.screen_height - 24);
    } else {
        view_data.sidebar_collapsed = 1;
        set_viewport(0, 24, view_data.screen_width - 40, view_data.screen_height - 24);
    }
    check_camera_boundaries();
}

static void stop_text_input(void)
{
    text_field_active = 0;
    input_text_numeric_only = 0;
    input_text_numeric_allow_negative = 0;
    SDL_StopTextInput();
    refresh_current_window = 1;
}

static void change_window(int window_id)
{
    previous_window = current_window;
    current_window = window_id;
    current_window_image_button_pressed = 0;
    stop_text_input();
}

static void show_city_window(void)
{
    change_window(WINDOW_CITY);
    selected_legion_formation = 0;
}

static void slide_finished(void)
{
    city_view_toggle_sidebar();
    show_city_window();
}

static void set_city_clip_rectangle(void)
{
    int x, y, width, height;
    city_view_get_viewport(&x, &y, &width, &height);
    graphics_set_clip_rectangle(x, y, width, height);
}

static int show_building_fire_crime(struct building_t *b)
{
    return b->type == BUILDING_PREFECTURE || b->type == BUILDING_BURNING_RUIN;
}

static int show_figure_fire(struct figure_t *f)
{
    return f->type == FIGURE_PREFECT;
}

static int get_column_height_fire(struct building_t *b)
{
    return b->fire_risk > 0 ? b->fire_risk / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_fire(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_FIRE,
        COLUMN_TYPE_RISK,
        show_building_fire_crime,
        show_figure_fire,
        get_column_height_fire,
        0,
        0
    };
    return &overlay;
}

static int show_figure_crime(struct figure_t *f)
{
    return f->type == FIGURE_PREFECT || f->type == FIGURE_PROTESTER || f->type == FIGURE_CRIMINAL || f->type == FIGURE_RIOTER;
}

static int get_column_height_crime(struct building_t *b)
{
    if (b->house_size) {
        int happiness = b->sentiment.house_happiness;
        if (happiness <= 0) {
            return 10;
        } else if (happiness <= 10) {
            return 8;
        } else if (happiness <= 20) {
            return 6;
        } else if (happiness <= 30) {
            return 4;
        } else if (happiness <= 40) {
            return 2;
        } else if (happiness < 50) {
            return 1;
        }
    }
    return NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_crime(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_CRIME,
        COLUMN_TYPE_RISK,
        show_building_fire_crime,
        show_figure_crime,
        get_column_height_crime,
        0,
        0
    };
    return &overlay;
}

static int show_building_damage(struct building_t *b)
{
    return b->type == BUILDING_ENGINEERS_POST;
}

static int show_figure_damage(struct figure_t *f)
{
    return f->type == FIGURE_ENGINEER;
}

static int get_column_height_damage(struct building_t *b)
{
    return b->damage_risk > 0 ? b->damage_risk / 20 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_damage(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_DAMAGE,
        COLUMN_TYPE_RISK,
        show_building_damage,
        show_figure_damage,
        get_column_height_damage,
        0,
        0
    };
    return &overlay;
}

static int show_building_problems(struct building_t *b)
{
    return b->show_on_problem_overlay;
}

static int show_figure_problems(struct figure_t *f)
{
    if (f->type == FIGURE_LABOR_SEEKER) {
        return all_buildings[f->building_id].show_on_problem_overlay;
    } else if (f->type == FIGURE_CART_PUSHER) {
        return f->action_state == FIGURE_ACTION_CARTPUSHER_INITIAL || f->min_max_seen;
    } else {
        return 0;
    }
}

static int get_column_height_none(__attribute__((unused))   struct building_t *b)
{
    return NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_problems(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_PROBLEMS,
        COLUMN_TYPE_RISK,
        show_building_problems,
        show_figure_problems,
        get_column_height_none,
        0,
        0
    };
    return &overlay;
}

static int show_building_native(struct building_t *b)
{
    return b->type == BUILDING_NATIVE_HUT || b->type == BUILDING_NATIVE_MEETING || b->type == BUILDING_MISSION_POST;
}

static int show_figure_native(struct figure_t *f)
{
    return f->type == FIGURE_INDIGENOUS_NATIVE || f->type == FIGURE_MISSIONARY;
}

static int terrain_on_native_overlay(void)
{
    return
        TERRAIN_SHRUB | TERRAIN_ROCK | TERRAIN_WATER | TERRAIN_TREE |
        TERRAIN_GARDEN | TERRAIN_ELEVATION | TERRAIN_ACCESS_RAMP | TERRAIN_RUBBLE;
}

static int is_drawable_farmhouse(int grid_offset, int map_orientation)
{
    if (!(edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE)) {
        return 0;
    }
    int xy = edge_grid.items[grid_offset] & EDGE_MASK_XY;
    if (map_orientation == DIR_0_TOP && xy == EDGE_X0Y1) {
        return 1;
    }
    if (map_orientation == DIR_2_RIGHT && xy == EDGE_X0Y0) {
        return 1;
    }
    if (map_orientation == DIR_4_BOTTOM && xy == EDGE_X1Y0) {
        return 1;
    }
    if (map_orientation == DIR_2_RIGHT && xy == EDGE_X1Y1) {
        return 1;
    }
    return 0;
}

static int is_drawable_farm_corner(int grid_offset)
{
    if (!(edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE)) {
        return 0;
    }

    int map_orientation = view_data.orientation;
    int xy = edge_grid.items[grid_offset] & EDGE_MASK_XY;
    if (map_orientation == DIR_0_TOP && xy == EDGE_X0Y2) {
        return 1;
    } else if (map_orientation == DIR_2_RIGHT && xy == EDGE_X0Y0) {
        return 1;
    } else if (map_orientation == DIR_4_BOTTOM && xy == EDGE_X2Y0) {
        return 1;
    } else if (map_orientation == DIR_6_LEFT && xy == EDGE_X2Y2) {
        return 1;
    }
    return 0;
}

static void city_with_overlay_draw_building_footprint(int x, int y, int grid_offset, int image_offset)
{
    int building_id = map_building_at(grid_offset);
    if (!building_id) {
        return;
    }
    struct building_t *b = &all_buildings[building_id];
    if (overlay->show_building(b)) {
        if (building_is_farm(b->type)) {
            if (is_drawable_farmhouse(grid_offset, view_data.orientation)) {
                image_draw_isometric_footprint_from_draw_tile(images.items[grid_offset], x, y, 0);
            } else if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
                image_draw_isometric_footprint_from_draw_tile(images.items[grid_offset], x, y, 0);
            }
        } else {
            image_draw_isometric_footprint_from_draw_tile(images.items[grid_offset], x, y, 0);
        }
    } else {
        int draw = 1;
        if (b->size == 3 && building_is_farm(b->type)) {
            draw = is_drawable_farm_corner(grid_offset);
        }
        if (draw) {
            int image_base = 548 + image_offset;
            if (b->house_size) {
                image_base += 4;
            }
            if (b->size == 1) {
                image_draw_isometric_footprint_from_draw_tile(image_base, x, y, 0);
            } else if (b->size == 2) {
                int x_tile_offset[] = { 30, 0, 60, 30 };
                int y_tile_offset[] = { -15, 0, 0, 15 };
                for (int i = 0; i < 4; i++) {
                    image_draw_isometric_footprint_from_draw_tile(image_base + i,
                        x + x_tile_offset[i], y + y_tile_offset[i], 0);
                }
            } else if (b->size == 3) {
                int image_tile_offset[] = { 0, 1, 2, 1, 3, 2, 3, 3, 3 };
                int x_tile_offset[] = { 60, 30, 90, 0, 60, 120, 30, 90, 60 };
                int y_tile_offset[] = { -30, -15, -15, 0, 0, 0, 15, 15, 30 };
                for (int i = 0; i < 9; i++) {
                    image_draw_isometric_footprint_from_draw_tile(image_base + image_tile_offset[i],
                        x + x_tile_offset[i], y + y_tile_offset[i], 0);
                }
            } else if (b->size == 4) {
                int image_tile_offset[] = { 0, 1, 2, 1, 3, 2, 1, 3, 3, 2, 3, 3, 3, 3, 3, 3 };
                int x_tile_offset[] = {
                  90,
                  60, 120,
                  30, 90, 150,
                  0, 60, 120, 180,
                  30, 90, 150,
                  60, 120,
                  90
                };
                int y_tile_offset[] = {
                  -45,
                  -30, -30,
                  -15, -15, -15,
                  0, 0, 0, 0,
                  15, 15, 15,
                  30, 30,
                  45
                };
                for (int i = 0; i < 16; i++) {
                    image_draw_isometric_footprint_from_draw_tile(image_base + image_tile_offset[i],
                        x + x_tile_offset[i], y + y_tile_offset[i], 0);
                }
            } else if (b->size == 5) {
                int image_tile_offset[] = { 0, 1, 2, 1, 3, 2, 1, 3, 3, 2, 1, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };
                int x_tile_offset[] = {
                  120,
                  90, 150,
                  60, 120, 180,
                  30, 90, 150, 210,
                  0, 60, 120, 180, 240,
                  30, 90, 150, 210,
                  60, 120, 180,
                  90, 150,
                  120
                };
                int y_tile_offset[] = {
                  -60,
                  -45, -45,
                  -30, -30, -30,
                  -15, -15, -15, -15,
                  0, 0, 0, 0, 0,
                  15, 15, 15, 15,
                  30, 30, 30,
                  45, 45,
                  60
                };
                for (int i = 0; i < 25; i++) {
                    image_draw_isometric_footprint_from_draw_tile(image_base + image_tile_offset[i],
                        x + x_tile_offset[i], y + y_tile_offset[i], 0);
                }
            }
        }
    }
}

static void draw_footprint_native(int x, int y, int grid_offset)
{
    if (!(edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE)) {
        return;
    }
    if (map_terrain_is(grid_offset, terrain_on_native_overlay())) {
        if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
            city_with_overlay_draw_building_footprint(x, y, grid_offset, 0);
        } else {
            image_draw_isometric_footprint_from_draw_tile(images.items[grid_offset], x, y, 0);
        }
    } else if (map_terrain_is(grid_offset, TERRAIN_AQUEDUCT | TERRAIN_WALL)) {
        // display grass
        int image_id = 306 + (random.items[grid_offset] & 7);
        image_draw_isometric_footprint_from_draw_tile(image_id, x, y, 0);
    } else if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
        city_with_overlay_draw_building_footprint(x, y, grid_offset, 0);
    } else {
        if (edge_grid.items[grid_offset] & EDGE_NATIVE_LAND) {
            image_draw_isometric_footprint_from_draw_tile(582, x, y, 0);
        } else {
            image_draw_isometric_footprint_from_draw_tile(images.items[grid_offset], x, y, 0);
        }
    }
}

static int is_problem_cartpusher(int figure_id)
{
    if (figure_id) {
        struct figure_t *fig = &figures[figure_id];
        return fig->action_state == FIGURE_ACTION_CARTPUSHER_INITIAL && fig->min_max_seen;
    } else {
        return 0;
    }
}

static int draw_building_as_deleted_1(struct building_t *b)
{
    if (!configs[CONFIG_UI_VISUAL_FEEDBACK_ON_DELETE].config_value) {
        return 0;
    }
    b = building_main(b);
    return b->id && (b->is_deleted || bitfields_grid.items[b->grid_offset] & BIT_DELETED);
}

static void city_with_overlay_draw_building_top(int x, int y, int grid_offset)
{
    struct building_t *b = &all_buildings[map_building_at(grid_offset)];
    if (overlay->type == OVERLAY_PROBLEMS) {
        if (!b->house_size) {
            if (b->type == BUILDING_FOUNTAIN || b->type == BUILDING_BATHHOUSE) {
                if (!b->has_water_access) {
                    b->show_on_problem_overlay = 1;
                }
            } else if (b->type >= BUILDING_WHEAT_FARM && b->type <= BUILDING_CLAY_PIT) {
                if (is_problem_cartpusher(b->figure_id)) {
                    b->show_on_problem_overlay = 1;
                }
            } else if (building_is_workshop(b->type)) {
                if (is_problem_cartpusher(b->figure_id)) {
                    b->show_on_problem_overlay = 1;
                } else if (b->loads_stored <= 0) {
                    b->show_on_problem_overlay = 1;
                }
            }
        }
    }
    if (overlay->show_building(b)) {
        uint32_t color_mask = draw_building_as_deleted_1(b) ? COLOR_MASK_RED : 0;
        if (building_is_farm(b->type)) {
            if (is_drawable_farmhouse(grid_offset, view_data.orientation)) {
                image_draw_isometric_top_from_draw_tile(images.items[grid_offset], x, y, color_mask);
            } else if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
                image_draw_isometric_top_from_draw_tile(images.items[grid_offset], x, y, color_mask);
            }
            return;
        } else if (b->type == BUILDING_GRANARY) {
            struct image_t *img = image_get(images.items[grid_offset]);
            image_draw(3012, x + img->sprite_offset_x, y + img->sprite_offset_y - 30 - (img->height - 90));
            if (b->data.granary.resource_stored[RESOURCE_NONE] < 2400) {
                image_draw(3013, x + 33, y - 60);
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 1800) {
                    image_draw(3014, x + 56, y - 50);
                }
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 1200) {
                    image_draw(3015, x + 91, y - 50);
                }
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 600) {
                    image_draw(3016, x + 117, y - 62);
                }
            }
        } else if (b->type == BUILDING_WAREHOUSE) {
            image_draw(3336, x - 4, y - 42);
        }
        if (!building_is_farm(b->type)) {
            image_draw_isometric_top_from_draw_tile(images.items[grid_offset], x, y, color_mask);
        }
    } else {
        int column_height = overlay->get_column_height(b);
        if (column_height != NO_COLUMN) {
            int draw = 1;
            if (building_is_farm(b->type)) {
                draw = is_drawable_farm_corner(grid_offset);
            }
            if (draw) {
                int image_id = 5362;
                if (overlay->column_type == COLUMN_TYPE_RISK) {
                    image_id += 9;
                }
                if (column_height > 10) {
                    column_height = 10;
                }
                int capital_height = image_get(image_id)->height;
                // base
                image_draw(image_id + 2, x + 9, y - 8);
                if (column_height) {
                    // column
                    for (int i = 1; i < column_height; i++) {
                        image_draw(image_id + 1, x + 17, y - 8 - 10 * i + 13);
                    }
                    // capital
                    image_draw(image_id, x + 5, y - 8 - capital_height - 10 * (column_height - 1) + 13);
                }
            }
        }
    }
}

static void draw_top_native(int x, int y, int grid_offset)
{
    if (!(edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE)) {
        return;
    }
    if (map_terrain_is(grid_offset, terrain_on_native_overlay())) {
        if (!map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
            uint32_t color_mask = 0;
            if (bitfields_grid.items[grid_offset] & BIT_DELETED && map_property_multi_tile_size(grid_offset) == 1) {
                color_mask = COLOR_MASK_RED;
            }
            image_draw_isometric_top_from_draw_tile(images.items[grid_offset], x, y, color_mask);
        }
    } else if (map_building_at(grid_offset)) {
        city_with_overlay_draw_building_top(x, y, grid_offset);
    }
}

static int show_building_entertainment(struct building_t *b)
{
    return
        b->type == BUILDING_ACTOR_COLONY || b->type == BUILDING_THEATER ||
        b->type == BUILDING_GLADIATOR_SCHOOL || b->type == BUILDING_AMPHITHEATER ||
        b->type == BUILDING_LION_HOUSE || b->type == BUILDING_COLOSSEUM ||
        b->type == BUILDING_CHARIOT_MAKER || b->type == BUILDING_HIPPODROME;
}

static int show_figure_entertainment(struct figure_t *f)
{
    return f->type == FIGURE_ACTOR || f->type == FIGURE_GLADIATOR ||
        f->type == FIGURE_LION_TAMER || f->type == FIGURE_CHARIOTEER;
}

static int get_column_height_entertainment(struct building_t *b)
{
    return b->house_size && b->data.house.entertainment ? b->data.house.entertainment / 10 : NO_COLUMN;
}


static   struct city_overlay_t *city_overlay_for_entertainment(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_ENTERTAINMENT,
        COLUMN_TYPE_ACCESS,
        show_building_entertainment,
        show_figure_entertainment,
        get_column_height_entertainment,
        0,
        0
    };
    return &overlay;
}

static int show_building_theater(struct building_t *b)
{
    return b->type == BUILDING_ACTOR_COLONY || b->type == BUILDING_THEATER;
}

static struct building_t *get_entertainment_building(struct figure_t *f)
{
    if (f->action_state == FIGURE_ACTION_ENTERTAINER_ROAMING ||
        f->action_state == FIGURE_ACTION_ENTERTAINER_RETURNING) {
        return &all_buildings[f->building_id];
    } else { // going to venue
        return &all_buildings[f->destination_building_id];
    }
}

static int show_figure_theater(struct figure_t *f)
{
    if (f->type == FIGURE_ACTOR) {
        return get_entertainment_building(f)->type == BUILDING_THEATER;
    }
    return 0;
}

static int get_column_height_theater(struct building_t *b)
{
    return b->house_size && b->data.house.theater ? b->data.house.theater / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_theater(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_THEATER,
        COLUMN_TYPE_ACCESS,
        show_building_theater,
        show_figure_theater,
        get_column_height_theater,
        0,
        0
    };
    return &overlay;
}

static int show_building_amphitheater(struct building_t *b)
{
    return b->type == BUILDING_ACTOR_COLONY
        || b->type == BUILDING_GLADIATOR_SCHOOL
        || b->type == BUILDING_AMPHITHEATER;
}

static int show_figure_amphitheater(struct figure_t *f)
{
    if (f->type == FIGURE_ACTOR || f->type == FIGURE_GLADIATOR) {
        return get_entertainment_building(f)->type == BUILDING_AMPHITHEATER;
    }
    return 0;
}

static int get_column_height_amphitheater(struct building_t *b)
{
    return b->house_size && b->data.house.amphitheater_actor ? b->data.house.amphitheater_actor / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_amphitheater(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_AMPHITHEATER,
        COLUMN_TYPE_ACCESS,
        show_building_amphitheater,
        show_figure_amphitheater,
        get_column_height_amphitheater,
        0,
        0
    };
    return &overlay;
}

static int show_building_colosseum(struct building_t *b)
{
    return b->type == BUILDING_GLADIATOR_SCHOOL || b->type == BUILDING_LION_HOUSE || b->type == BUILDING_COLOSSEUM;
}

static int show_figure_colosseum(struct figure_t *f)
{
    if (f->type == FIGURE_GLADIATOR) {
        return get_entertainment_building(f)->type == BUILDING_COLOSSEUM;
    } else if (f->type == FIGURE_LION_TAMER) {
        return 1;
    }
    return 0;
}

static int get_column_height_colosseum(struct building_t *b)
{
    return b->house_size && b->data.house.colosseum_gladiator ? b->data.house.colosseum_gladiator / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_colosseum(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_COLOSSEUM,
        COLUMN_TYPE_ACCESS,
        show_building_colosseum,
        show_figure_colosseum,
        get_column_height_colosseum,
        0,
        0
    };
    return &overlay;
}

static int show_building_hippodrome(struct building_t *b)
{
    return b->type == BUILDING_CHARIOT_MAKER || b->type == BUILDING_HIPPODROME;
}

static int show_figure_hippodrome(struct figure_t *f)
{
    return f->type == FIGURE_CHARIOTEER;
}

static int get_column_height_hippodrome(struct building_t *b)
{
    return b->house_size && b->data.house.hippodrome ? b->data.house.hippodrome / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_hippodrome(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_HIPPODROME,
        COLUMN_TYPE_ACCESS,
        show_building_hippodrome,
        show_figure_hippodrome,
        get_column_height_hippodrome,
        0,
        0
    };
    return &overlay;
}

static int show_building_education(struct building_t *b)
{
    return b->type == BUILDING_SCHOOL || b->type == BUILDING_LIBRARY || b->type == BUILDING_ACADEMY;
}

static int show_figure_education(struct figure_t *f)
{
    return f->type == FIGURE_SCHOOL_CHILD || f->type == FIGURE_LIBRARIAN || f->type == FIGURE_TEACHER;
}

static int get_column_height_education(struct building_t *b)
{
    return b->house_size && b->data.house.education ? b->data.house.education * 3 - 1 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_education(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_EDUCATION,
        COLUMN_TYPE_ACCESS,
        show_building_education,
        show_figure_education,
        get_column_height_education,
        0,
        0
    };
    return &overlay;
}

static int show_building_school(struct building_t *b)
{
    return b->type == BUILDING_SCHOOL;
}

static int show_figure_school(struct figure_t *f)
{
    return f->type == FIGURE_SCHOOL_CHILD;
}

static int get_column_height_school(struct building_t *b)
{
    return b->house_size && b->data.house.school ? b->data.house.school / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_school(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_SCHOOL,
        COLUMN_TYPE_ACCESS,
        show_building_school,
        show_figure_school,
        get_column_height_school,
        0,
        0
    };
    return &overlay;
}

static int show_building_library(struct building_t *b)
{
    return b->type == BUILDING_LIBRARY;
}

static int show_figure_library(struct figure_t *f)
{
    return f->type == FIGURE_LIBRARIAN;
}

static int get_column_height_library(struct building_t *b)
{
    return b->house_size && b->data.house.library ? b->data.house.library / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_library(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_LIBRARY,
        COLUMN_TYPE_ACCESS,
        show_building_library,
        show_figure_library,
        get_column_height_library,
        0,
        0
    };
    return &overlay;
}

static int show_building_academy(struct building_t *b)
{
    return b->type == BUILDING_ACADEMY;
}

static int show_figure_academy(struct figure_t *f)
{
    return f->type == FIGURE_TEACHER;
}

static int get_column_height_academy(struct building_t *b)
{
    return b->house_size && b->data.house.academy ? b->data.house.academy / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_academy(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_ACADEMY,
        COLUMN_TYPE_ACCESS,
        show_building_academy,
        show_figure_academy,
        get_column_height_academy,
        0,
        0
    };
    return &overlay;
}

static int show_building_barber(struct building_t *b)
{
    return b->type == BUILDING_BARBER;
}

static int show_figure_barber(struct figure_t *f)
{
    return f->type == FIGURE_BARBER;
}

static int get_column_height_barber(struct building_t *b)
{
    return b->house_size && b->data.house.barber ? b->data.house.barber / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_barber(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_BARBER,
        COLUMN_TYPE_ACCESS,
        show_building_barber,
        show_figure_barber,
        get_column_height_barber,
        0,
        0
    };
    return &overlay;
}

static int show_building_bathhouse(struct building_t *b)
{
    return b->type == BUILDING_BATHHOUSE;
}

static int show_figure_bathhouse(struct figure_t *f)
{
    return f->type == FIGURE_BATHHOUSE_WORKER;
}

static int get_column_height_bathhouse(struct building_t *b)
{
    return b->house_size && b->data.house.bathhouse ? b->data.house.bathhouse / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_bathhouse(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_BATHHOUSE,
        COLUMN_TYPE_ACCESS,
        show_building_bathhouse,
        show_figure_bathhouse,
        get_column_height_bathhouse,
        0,
        0
    };
    return &overlay;
}

static int show_building_clinic(struct building_t *b)
{
    return b->type == BUILDING_DOCTOR;
}

static int show_figure_clinic(struct figure_t *f)
{
    return f->type == FIGURE_DOCTOR;
}

static int get_column_height_clinic(struct building_t *b)
{
    return b->house_size && b->data.house.clinic ? b->data.house.clinic / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_clinic(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_CLINIC,
        COLUMN_TYPE_ACCESS,
        show_building_clinic,
        show_figure_clinic,
        get_column_height_clinic,
        0,
        0
    };
    return &overlay;
}

static int show_building_hospital(struct building_t *b)
{
    return b->type == BUILDING_HOSPITAL;
}

static int show_figure_hospital(struct figure_t *f)
{
    return f->type == FIGURE_SURGEON;
}

static int get_column_height_hospital(struct building_t *b)
{
    return b->house_size && b->data.house.hospital ? b->data.house.hospital / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_hospital(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_HOSPITAL,
        COLUMN_TYPE_ACCESS,
        show_building_hospital,
        show_figure_hospital,
        get_column_height_hospital,
        0,
        0
    };
    return &overlay;
}

static int show_building_religion(struct building_t *b)
{
    return
        b->type == BUILDING_ORACLE || b->type == BUILDING_SMALL_TEMPLE_CERES ||
        b->type == BUILDING_SMALL_TEMPLE_NEPTUNE || b->type == BUILDING_SMALL_TEMPLE_MERCURY ||
        b->type == BUILDING_SMALL_TEMPLE_MARS || b->type == BUILDING_SMALL_TEMPLE_VENUS ||
        b->type == BUILDING_LARGE_TEMPLE_CERES || b->type == BUILDING_LARGE_TEMPLE_NEPTUNE ||
        b->type == BUILDING_LARGE_TEMPLE_MERCURY || b->type == BUILDING_LARGE_TEMPLE_MARS ||
        b->type == BUILDING_LARGE_TEMPLE_VENUS;
}

static int show_figure_religion(struct figure_t *f)
{
    return f->type == FIGURE_PRIEST;
}

static int get_column_height_religion(struct building_t *b)
{
    return b->house_size && b->data.house.num_gods ? b->data.house.num_gods * 17 / 10 : NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_religion(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_RELIGION,
        COLUMN_TYPE_ACCESS,
        show_building_religion,
        show_figure_religion,
        get_column_height_religion,
        0,
        0
    };
    return &overlay;
}

static int show_building_tax_income(struct building_t *b)
{
    return b->type == BUILDING_FORUM || b->type == BUILDING_SENATE;
}

static int show_figure_tax_income(struct figure_t *f)
{
    return f->type == FIGURE_TAX_COLLECTOR;
}

static int calc_adjust_with_percentage(int value, int percentage)
{
    return percentage * value / 100;
}

static int get_column_height_tax_income(struct building_t *b)
{
    if (b->house_size) {
        int pct = calc_adjust_with_percentage(b->tax_income_or_storage / 2, city_data.finance.tax_percentage);
        if (pct > 0) {
            return pct / 25;
        }
    }
    return NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_tax_income(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_TAX_INCOME,
        COLUMN_TYPE_ACCESS,
        show_building_tax_income,
        show_figure_tax_income,
        get_column_height_tax_income,
        0,
        0
    };
    return &overlay;
}

static int show_building_food_stocks(struct building_t *b)
{
    return b->type == BUILDING_MARKET || b->type == BUILDING_WHARF || b->type == BUILDING_GRANARY;
}

static int resource_is_food(int resource)
{
    return resource == RESOURCE_WHEAT || resource == RESOURCE_VEGETABLES ||
        resource == RESOURCE_FRUIT || resource == RESOURCE_MEAT;
}

static int show_figure_food_stocks(struct figure_t *f)
{
    if (f->type == FIGURE_MARKET_BUYER || f->type == FIGURE_MARKET_TRADER ||
        f->type == FIGURE_DELIVERY_BOY || f->type == FIGURE_FISHING_BOAT) {
        return 1;
    } else if (f->type == FIGURE_CART_PUSHER) {
        return resource_is_food(f->resource_id);
    }
    return 0;
}

static int get_column_height_food_stocks(struct building_t *b)
{
    if (b->house_size && house_properties[b->subtype.house_level].food_types) {
        int pop = b->house_population;
        int stocks = 0;
        for (int i = INVENTORY_WHEAT; i <= INVENTORY_MEAT; i++) {
            stocks += b->data.house.inventory[i];
        }
        int pct_stocks = calc_percentage(stocks, pop);
        if (pct_stocks <= 0) {
            return 10;
        } else if (pct_stocks < 100) {
            return 5;
        } else if (pct_stocks <= 200) {
            return 1;
        }
    }
    return NO_COLUMN;
}

static   struct city_overlay_t *city_overlay_for_food_stocks(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_FOOD_STOCKS,
        COLUMN_TYPE_RISK,
        show_building_food_stocks,
        show_figure_food_stocks,
        get_column_height_food_stocks,
        0,
        0
    };
    return &overlay;
}

static int show_building_water(struct building_t *b)
{
    return b->type == BUILDING_WELL || b->type == BUILDING_FOUNTAIN || b->type == BUILDING_RESERVOIR;
}

static int show_figure_none(__attribute__((unused))   struct figure_t *f)
{
    return 0;
}

static int terrain_on_water_overlay(void)
{
    return
        TERRAIN_SHRUB | TERRAIN_ROCK | TERRAIN_WATER | TERRAIN_TREE |
        TERRAIN_GARDEN | TERRAIN_ROAD | TERRAIN_AQUEDUCT | TERRAIN_ELEVATION |
        TERRAIN_ACCESS_RAMP | TERRAIN_RUBBLE;
}

static void draw_footprint_water(int x, int y, int grid_offset)
{
    if (!(edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE)) {
        return;
    }
    if (map_terrain_is(grid_offset, terrain_on_water_overlay())) {
        if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
            city_with_overlay_draw_building_footprint(x, y, grid_offset, 0);
        } else {
            image_draw_isometric_footprint_from_draw_tile(images.items[grid_offset], x, y, 0);
        }
    } else if (map_terrain_is(grid_offset, TERRAIN_WALL)) {
        // display grass
        int image_id = 306 + (random.items[grid_offset] & 7);
        image_draw_isometric_footprint_from_draw_tile(image_id, x, y, 0);
    } else if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
        struct building_t *b = &all_buildings[map_building_at(grid_offset)];
        int terrain = terrain_grid.items[grid_offset];
        if (b->id && (b->has_well_access || (b->house_size && b->has_water_access))) {
            terrain |= TERRAIN_FOUNTAIN_RANGE;
        }
        int image_offset;
        switch (terrain & (TERRAIN_RESERVOIR_RANGE | TERRAIN_FOUNTAIN_RANGE)) {
            case TERRAIN_RESERVOIR_RANGE | TERRAIN_FOUNTAIN_RANGE:
                image_offset = 24;
                break;
            case TERRAIN_RESERVOIR_RANGE:
                image_offset = 8;
                break;
            case TERRAIN_FOUNTAIN_RANGE:
                image_offset = 16;
                break;
            default:
                image_offset = 0;
                break;
        }
        city_with_overlay_draw_building_footprint(x, y, grid_offset, image_offset);
    } else {
        int image_id = 548;
        switch (terrain_grid.items[grid_offset] & (TERRAIN_RESERVOIR_RANGE | TERRAIN_FOUNTAIN_RANGE)) {
            case TERRAIN_RESERVOIR_RANGE | TERRAIN_FOUNTAIN_RANGE:
                image_id += 27;
                break;
            case TERRAIN_RESERVOIR_RANGE:
                image_id += 11;
                break;
            case TERRAIN_FOUNTAIN_RANGE:
                image_id += 19;
                break;
            default:
                image_id = images.items[grid_offset];
                break;
        }
        image_draw_isometric_footprint_from_draw_tile(image_id, x, y, 0);
    }
}

static void draw_top_water(int x, int y, int grid_offset)
{
    if (!(edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE)) {
        return;
    }
    if (map_terrain_is(grid_offset, terrain_on_water_overlay())) {
        if (!map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
            uint32_t color_mask = 0;
            if (bitfields_grid.items[grid_offset] & BIT_DELETED && map_property_multi_tile_size(grid_offset) == 1) {
                color_mask = COLOR_MASK_RED;
            }
            image_draw_isometric_top_from_draw_tile(images.items[grid_offset], x, y, color_mask);
        }
    } else if (map_building_at(grid_offset)) {
        city_with_overlay_draw_building_top(x, y, grid_offset);
    }
}

static   struct city_overlay_t *city_overlay_for_water(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_WATER,
        COLUMN_TYPE_ACCESS,
        show_building_water,
        show_figure_none,
        get_column_height_none,
        draw_footprint_water,
        draw_top_water
    };
    return &overlay;
}

static int show_building_desirability(__attribute__((unused))   struct building_t *b)
{
    return 0;
}

static int terrain_on_desirability_overlay(void)
{
    return
        TERRAIN_SHRUB | TERRAIN_ROCK | TERRAIN_WATER |
        TERRAIN_TREE | TERRAIN_GARDEN | TERRAIN_ROAD |
        TERRAIN_ELEVATION | TERRAIN_ACCESS_RAMP | TERRAIN_RUBBLE;
}

static int has_deleted_building(int grid_offset)
{
    if (!configs[CONFIG_UI_VISUAL_FEEDBACK_ON_DELETE].config_value) {
        return 0;
    }
    struct building_t *b = &all_buildings[map_building_at(grid_offset)];
    b = building_main(b);
    return b->id && (b->is_deleted || bitfields_grid.items[b->grid_offset] & BIT_DELETED);
}

static int get_desirability_image_offset(int desirability)
{
    if (desirability < -10) {
        return 0;
    } else if (desirability < -5) {
        return 1;
    } else if (desirability < 0) {
        return 2;
    } else if (desirability == 1) {
        return 3;
    } else if (desirability < 5) {
        return 4;
    } else if (desirability < 10) {
        return 5;
    } else if (desirability < 15) {
        return 6;
    } else if (desirability < 20) {
        return 7;
    } else if (desirability < 25) {
        return 8;
    } else {
        return 9;
    }
}

static void draw_footprint_desirability(int x, int y, int grid_offset)
{
    uint32_t color_mask = bitfields_grid.items[grid_offset] & BIT_DELETED ? COLOR_MASK_RED : 0;
    if (map_terrain_is(grid_offset, terrain_on_desirability_overlay())
        && !map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
        // display normal tile
        if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
            image_draw_isometric_footprint_from_draw_tile(images.items[grid_offset], x, y, color_mask);
        }
    } else if (map_terrain_is(grid_offset, TERRAIN_AQUEDUCT | TERRAIN_WALL)) {
        // display empty land/grass
        int image_id = 306 + (random.items[grid_offset] & 7);
        image_draw_isometric_footprint_from_draw_tile(image_id, x, y, color_mask);
    } else if (map_terrain_is(grid_offset, TERRAIN_BUILDING) || desirability_grid.items[grid_offset]) {
        if (has_deleted_building(grid_offset)) {
            color_mask = COLOR_MASK_RED;
        }
        int offset = get_desirability_image_offset(desirability_grid.items[grid_offset]);
        image_draw_isometric_footprint_from_draw_tile(581 + offset, x, y, color_mask);
    } else {
        image_draw_isometric_footprint_from_draw_tile(images.items[grid_offset], x, y, color_mask);
    }
}

static void draw_top_desirability(int x, int y, int grid_offset)
{
    uint32_t color_mask = bitfields_grid.items[grid_offset] & BIT_DELETED ? COLOR_MASK_RED : 0;
    if (map_terrain_is(grid_offset, terrain_on_desirability_overlay())
        && !map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
        // display normal tile
        if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
            image_draw_isometric_top_from_draw_tile(images.items[grid_offset], x, y, color_mask);
        }
    } else if (map_terrain_is(grid_offset, TERRAIN_AQUEDUCT | TERRAIN_WALL)) {
        // grass, no top needed
    } else if (map_terrain_is(grid_offset, TERRAIN_BUILDING) || desirability_grid.items[grid_offset]) {
        if (has_deleted_building(grid_offset)) {
            color_mask = COLOR_MASK_RED;
        }
        int offset = get_desirability_image_offset(desirability_grid.items[grid_offset]);
        image_draw_isometric_top_from_draw_tile(581 + offset, x, y, color_mask);
    } else {
        image_draw_isometric_top_from_draw_tile(images.items[grid_offset], x, y, color_mask);
    }
}

static   struct city_overlay_t *city_overlay_for_desirability(void)
{
    static struct city_overlay_t overlay = {
        OVERLAY_DESIRABILITY,
        COLUMN_TYPE_ACCESS,
        show_building_desirability,
        show_figure_none,
        get_column_height_none,
        draw_footprint_desirability,
        draw_top_desirability
    };
    return &overlay;
}

static int select_city_overlay(void)
{
    if (!overlay || overlay->type != state_data.current_overlay) {
        overlay = 0;
        switch (state_data.current_overlay) {
            case OVERLAY_FIRE:
                overlay = city_overlay_for_fire();
                break;
            case OVERLAY_CRIME:
                overlay = city_overlay_for_crime();
                break;
            case OVERLAY_DAMAGE:
                overlay = city_overlay_for_damage();
                break;
            case OVERLAY_PROBLEMS:
                overlay = city_overlay_for_problems();
                break;
            case OVERLAY_NATIVE:
                overlay->type = OVERLAY_NATIVE;
                overlay->column_type = COLUMN_TYPE_RISK;
                overlay->show_building = show_building_native;
                overlay->show_figure = show_figure_native;
                overlay->get_column_height = get_column_height_none;
                overlay->draw_custom_footprint = draw_footprint_native;
                overlay->draw_custom_top = draw_top_native;
                break;
            case OVERLAY_ENTERTAINMENT:
                overlay = city_overlay_for_entertainment();
                break;
            case OVERLAY_THEATER:
                overlay = city_overlay_for_theater();
                break;
            case OVERLAY_AMPHITHEATER:
                overlay = city_overlay_for_amphitheater();
                break;
            case OVERLAY_COLOSSEUM:
                overlay = city_overlay_for_colosseum();
                break;
            case OVERLAY_HIPPODROME:
                overlay = city_overlay_for_hippodrome();
                break;
            case OVERLAY_EDUCATION:
                overlay = city_overlay_for_education();
                break;
            case OVERLAY_SCHOOL:
                overlay = city_overlay_for_school();
                break;
            case OVERLAY_LIBRARY:
                overlay = city_overlay_for_library();
                break;
            case OVERLAY_ACADEMY:
                overlay = city_overlay_for_academy();
                break;
            case OVERLAY_BARBER:
                overlay = city_overlay_for_barber();
                break;
            case OVERLAY_BATHHOUSE:
                overlay = city_overlay_for_bathhouse();
                break;
            case OVERLAY_CLINIC:
                overlay = city_overlay_for_clinic();
                break;
            case OVERLAY_HOSPITAL:
                overlay = city_overlay_for_hospital();
                break;
            case OVERLAY_RELIGION:
                overlay = city_overlay_for_religion();
                break;
            case OVERLAY_TAX_INCOME:
                overlay = city_overlay_for_tax_income();
                break;
            case OVERLAY_FOOD_STOCKS:
                overlay = city_overlay_for_food_stocks();
                break;
            case OVERLAY_WATER:
                overlay = city_overlay_for_water();
                break;
            case OVERLAY_DESIRABILITY:
                overlay = city_overlay_for_desirability();
                break;
            default:
                break;
        }
    }
    return overlay != 0;
}

static void draw_footprint_with_overlay(int x, int y, int grid_offset)
{
    building_construction_record_view_position(x, y, grid_offset);
    if (grid_offset < 0) {
        // Outside map: draw black tile
        image_draw_isometric_footprint_from_draw_tile(245, x, y, 0);
    } else if (overlay->draw_custom_footprint) {
        overlay->draw_custom_footprint(x, y, grid_offset);
    } else if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
        if (terrain_grid.items[grid_offset] & (TERRAIN_AQUEDUCT | TERRAIN_WALL)) {
            // display grass
            int image_id = 306 + (random.items[grid_offset] & 7);
            image_draw_isometric_footprint_from_draw_tile(image_id, x, y, 0);
        } else if ((terrain_grid.items[grid_offset] & TERRAIN_ROAD) && !(terrain_grid.items[grid_offset] & TERRAIN_BUILDING)) {
            image_draw_isometric_footprint_from_draw_tile(images.items[grid_offset], x, y, 0);
        } else if (terrain_grid.items[grid_offset] & TERRAIN_BUILDING) {
            city_with_overlay_draw_building_footprint(x, y, grid_offset, 0);
        } else {
            image_draw_isometric_footprint_from_draw_tile(images.items[grid_offset], x, y, 0);
        }
    }
}

static void draw_figures_with_overlay(int x, int y, int grid_offset)
{
    int figure_id = map_grid_is_valid_offset(grid_offset) ? map_figures.items[grid_offset] : 0;
    while (figure_id) {
        struct figure_t *f = &figures[figure_id];
        if (!f->is_invisible && overlay->show_figure(f)) {
            city_draw_figure(f, x, y, 0);
        }
        figure_id = f->next_figure_id_on_same_tile;
    }
}

static void draw_top_with_overlay(int x, int y, int grid_offset)
{
    if (overlay->draw_custom_top) {
        overlay->draw_custom_top(x, y, grid_offset);
    } else if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
        if (!map_terrain_is(grid_offset, TERRAIN_WALL | TERRAIN_AQUEDUCT | TERRAIN_ROAD)) {
            if (map_terrain_is(grid_offset, TERRAIN_BUILDING) && map_building_at(grid_offset)) {
                city_with_overlay_draw_building_top(x, y, grid_offset);
            } else if (!map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
                uint32_t color_mask = 0;
                if (bitfields_grid.items[grid_offset] & BIT_DELETED && !is_multi_tile_terrain(grid_offset)) {
                    color_mask = COLOR_MASK_RED;
                }
                // terrain
                image_draw_isometric_top_from_draw_tile(images.items[grid_offset], x, y, color_mask);
            }
        }
    }
}

static void draw_animation_with_overlay(int x, int y, int grid_offset)
{
    int draw = 0;
    if (map_building_at(grid_offset)) {
        int btype = all_buildings[map_building_at(grid_offset)].type;
        switch (overlay->type) {
            case OVERLAY_FIRE:
            case OVERLAY_CRIME:
                if (btype == BUILDING_PREFECTURE || btype == BUILDING_BURNING_RUIN) {
                    draw = 1;
                }
                break;
            case OVERLAY_DAMAGE:
                if (btype == BUILDING_ENGINEERS_POST) {
                    draw = 1;
                }
                break;
            case OVERLAY_WATER:
                if (btype == BUILDING_RESERVOIR || btype == BUILDING_FOUNTAIN) {
                    draw = 1;
                }
                break;
            case OVERLAY_FOOD_STOCKS:
                if (btype == BUILDING_MARKET || btype == BUILDING_GRANARY) {
                    draw = 1;
                }
                break;
        }
    }

    struct image_t *img = image_get(images.items[grid_offset]);
    if (img->num_animation_sprites && draw) {
        if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
            struct building_t *b = &all_buildings[map_building_at(grid_offset)];
            int color_mask = draw_building_as_deleted_1(b) ? COLOR_MASK_RED : 0;
            if (b->type == BUILDING_GRANARY) {
                image_draw_masked(3012, x + img->sprite_offset_x, y + 60 + img->sprite_offset_y - img->height, color_mask);
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 2400) {
                    image_draw_masked(3013, x + 33, y - 60, color_mask);
                }
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 1800) {
                    image_draw_masked(3014, x + 56, y - 50, color_mask);
                }
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 1200) {
                    image_draw_masked(3015, x + 91, y - 50, color_mask);
                }
                if (b->data.granary.resource_stored[RESOURCE_NONE] < 600) {
                    image_draw_masked(3016, x + 117, y - 62, color_mask);
                }
            } else {
                int animation_offset = building_animation_offset(b, images.items[grid_offset], grid_offset);
                if (animation_offset > 0) {
                    if (animation_offset > img->num_animation_sprites) {
                        animation_offset = img->num_animation_sprites;
                    }
                    int ydiff = 0;
                    switch (map_property_multi_tile_size(grid_offset)) {
                        case 1: ydiff = 30; break;
                        case 2: ydiff = 45; break;
                        case 3: ydiff = 60; break;
                        case 4: ydiff = 75; break;
                        case 5: ydiff = 90; break;
                    }
                    image_draw_masked(images.items[grid_offset] + animation_offset,
                                      x + img->sprite_offset_x,
                                      y + ydiff + img->sprite_offset_y - img->height,
                                      color_mask);
                }
            }
        }
    } else if (map_is_bridge(grid_offset)) {
        city_draw_bridge(x, y, grid_offset);
    }
}

static void draw_elevated_figures_with_overlay(int x, int y, int grid_offset)
{
    int figure_id = map_grid_is_valid_offset(grid_offset) ? map_figures.items[grid_offset] : 0;
    while (figure_id > 0) {
        struct figure_t *f = &figures[figure_id];
        if (((f->use_cross_country && !f->is_invisible) || f->height_adjusted_ticks) && overlay->show_figure(f)) {
            city_draw_figure(f, x, y, 0);
        }
        figure_id = f->next_figure_id_on_same_tile;
    }
}

static int should_draw_top_before_deletion_with_overlay(int grid_offset)
{
    int has_adjacent_deletion = 0;
    int size = map_property_multi_tile_size(grid_offset);
    int total_adjacent_offsets = size * 2 + 1;
    int *adjacent_offset = ADJACENT_OFFSETS[size - 1][view_data.orientation / 2];
    for (int i = 0; i < total_adjacent_offsets; ++i) {
        if ((bitfields_grid.items[grid_offset + adjacent_offset[i]] & BIT_DELETED) || draw_building_as_deleted_1(&all_buildings[map_building_at(grid_offset + adjacent_offset[i])])) {
            has_adjacent_deletion = 1;
            break;
        }
    }
    return is_multi_tile_terrain(grid_offset) && has_adjacent_deletion;
}

static void deletion_draw_terrain_top_with_overlay(int x, int y, int grid_offset)
{
    if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE && should_draw_top_before_deletion_with_overlay(grid_offset)) {
        draw_top_with_overlay(x, y, grid_offset);
    }
}

static void deletion_draw_animations(int x, int y, int grid_offset)
{
    if (bitfields_grid.items[grid_offset] & BIT_DELETED || draw_building_as_deleted_1(&all_buildings[map_building_at(grid_offset)])) {
        image_draw_blend(733, x, y, COLOR_MASK_RED);
    }
    if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE && !should_draw_top_before_deletion_with_overlay(grid_offset)) {
        draw_top_with_overlay(x, y, grid_offset);
    }
    draw_animation_with_overlay(x, y, grid_offset);
}

static void widget_city_draw(void)
{
    set_city_clip_rectangle();
    if (state_data.current_overlay && select_city_overlay()) {
        int should_mark_deleting = city_building_ghost_mark_deleting(&widget_city_data.current_tile);
        city_view_foreach_map_tile(draw_footprint_with_overlay);
        if (!should_mark_deleting) {
            city_view_foreach_valid_map_tile(
                draw_figures_with_overlay,
                draw_top_with_overlay,
                draw_animation_with_overlay
            );
            city_building_ghost_draw(&widget_city_data.current_tile);
            city_view_foreach_map_tile(draw_elevated_figures_with_overlay);
        } else {
            city_view_foreach_map_tile(draw_figures_with_overlay);
            city_view_foreach_map_tile(deletion_draw_terrain_top_with_overlay);
            city_view_foreach_map_tile(deletion_draw_animations);
            city_view_foreach_map_tile(draw_elevated_figures_with_overlay);
        }
    } else {
        city_without_overlay_draw(0, 0, &widget_city_data.current_tile);
    }
    graphics_reset_clip_rectangle();
}

static double adjust_speed_for_elapsed_time(double delta, int adjust_for_time, uint32_t last_time)
{
    return adjust_for_time ? (delta / FRAME_TIME) * (current_time - last_time) : delta;
}

static int speed_get_delta(struct speed_type_t *speed)
{
    if (speed->adjust_for_time && speed->last_speed_check == current_time) {
        return 0;
    }
    double delta;
    uint32_t elapsed = current_time - speed->start_time;
    double desired = 0.0;
    desired = adjust_speed_for_elapsed_time(speed->desired_speed, speed->adjust_for_time, speed->last_speed_check);
    if (speed->total_time == SPEED_CHANGE_IMMEDIATE) {
        delta = desired;
    } else if (speed->current_speed == speed->desired_speed || elapsed > speed->total_time * 4) {
        delta = desired;
        speed->current_speed = speed->desired_speed;
        speed->adjusted_current_speed = speed->desired_speed;
    } else {
        if (elapsed == 0) {
            delta = adjust_speed_for_elapsed_time(
                speed->current_speed, speed->adjust_for_time, speed->last_speed_check);
        } else {
            double full_delta = speed->speed_difference * (speed->total_time / FRAME_TIME);
            double exponent = exp(-((int) elapsed) / (double) speed->total_time);
            delta = full_delta - full_delta * exponent - speed->cumulative_delta;
            speed->cumulative_delta += delta;
            delta += desired;
            speed->current_speed = adjust_speed_for_frame_time(delta, speed->adjust_for_time, speed->last_speed_check);
            speed->adjusted_current_speed = speed->current_speed;
        }
    }
    speed->last_speed_check = current_time;
    int delta_rounded = (int) delta;
    speed->fine_position += delta - delta_rounded;
    int extra_position = (int) speed->fine_position;
    speed->fine_position -= extra_position;
    return delta_rounded + extra_position;
}

static void set_cursor_shape(int shape)
{
    cursor_data.current_shape = shape;
    SDL_SetCursor(cursor_data.cursors[shape]);
}

static void building_construction_set_type(int type)
{
    construction_data.type = type;
    construction_data.in_progress = 0;
    construction_data.start.x = 0;
    construction_data.start.y = 0;
    construction_data.end.x = 0;
    construction_data.end.y = 0;
    construction_data.cost_preview = 0;
    if (type != BUILDING_NONE) {
        construction_data.required_terrain.wall = 0;
        construction_data.required_terrain.water = 0;
        construction_data.required_terrain.tree = 0;
        construction_data.required_terrain.rock = 0;
        construction_data.required_terrain.meadow = 0;
        construction_data.road_orientation = 0;
        construction_data.road_last_update = current_time;
        construction_data.start.grid_offset = 0;
        switch (type) {
            case BUILDING_CLEAR_LAND:
                set_cursor_shape(CURSOR_SHOVEL);
                break;
            case BUILDING_WHEAT_FARM:
            case BUILDING_VEGETABLE_FARM:
            case BUILDING_FRUIT_FARM:
            case BUILDING_OLIVE_FARM:
            case BUILDING_VINES_FARM:
            case BUILDING_PIG_FARM:
                construction_data.required_terrain.meadow = 1;
                break;
            case BUILDING_MARBLE_QUARRY:
            case BUILDING_IRON_MINE:
                construction_data.required_terrain.rock = 1;
                break;
            case BUILDING_TIMBER_YARD:
                construction_data.required_terrain.tree = 1;
                break;
            case BUILDING_CLAY_PIT:
                construction_data.required_terrain.water = 1;
                break;
            case BUILDING_GATEHOUSE:
            case BUILDING_TRIUMPHAL_ARCH:
                construction_data.road_orientation = 1;
                break;
            case BUILDING_TOWER:
                construction_data.required_terrain.wall = 1;
                break;
            default:
                break;
        }
    }
}

static void draw_top_menu_bar(void)
{
    for (int i = 0; i * 24 < current_resolution_width; i++) {
        image_draw(871 + i % 8, i * 24, 0);
    }
    text_draw("File", 10, 6, FONT_NORMAL_GREEN, COLOR_BLACK);
    text_draw("Options", 78, 6, FONT_NORMAL_GREEN, COLOR_BLACK);
    if (editor_active) {
        text_draw("Resets", 179, 6, FONT_NORMAL_GREEN, COLOR_BLACK);
    }
}

static int string_equals(char *a, char *b)
{
    while (*a && *b && *a == *b) {
        ++a;
        ++b;
    }
    if (*a == 0 && *b == 0) {
        return 1;
    } else {
        return 0;
    }
}

static int file_has_extension(char *filename, char *extension)
{
    if (!extension || !*extension) {
        return 1;
    }
    char c;
    do {
        c = *filename;
        filename++;
    } while (c != '.' && c);
    if (!c) {
        filename--;
    }
    return string_equals(filename, extension);
}

static void file_append_extension(char *filename, char *extension)
{
    char c;
    do {
        c = *filename;
        filename++;
    } while (c);
    filename--;
    filename[0] = '.';
    filename[1] = extension[0];
    filename[2] = extension[1];
    filename[3] = extension[2];
    filename[4] = 0;
}

static void city_data_init(void)
{
    memset(&city_data, 0, sizeof(struct city_data_t));
    city_data.sentiment.value = 60;
    city_data.health.target_value = 50;
    city_data.health.value = 50;
    city_data.labor.wages_rome = 30;
    city_data.labor.wages = 30;
    city_data.finance.tax_percentage = 7;
    city_data.trade.caravan_import_resource = RESOURCE_WHEAT;
    city_data.trade.caravan_backup_import_resource = RESOURCE_WHEAT;
    city_data.population.monthly.next_index = 0;
    city_data.population.monthly.count = 0;
    city_data.festival.queued = 0;
    city_data.festival.months_since_festival = 1;
    city_data.emperor.gifts[GIFT_MODEST].cost = 0;
    city_data.emperor.gifts[GIFT_GENEROUS].cost = 0;
    city_data.emperor.gifts[GIFT_LAVISH].cost = 0;
    for (int i = 0; i < MAX_GODS; i++) {
        city_data.religion.gods[i].target_happiness = 50;
        city_data.religion.gods[i].happiness = 50;
        city_data.religion.gods[i].wrath_bolts = 0;
        city_data.religion.gods[i].blessing_done = 0;
        city_data.religion.gods[i].small_curse_done = 0;
        city_data.religion.gods[i].months_since_festival = 0;
    }
    city_data.religion.angry_message_delay = 0;
}

static void city_message_init_problem_areas(void)
{
    message_data.problem_count = 0;
    message_data.problem_index = 0;
    message_data.problem_last_click_time = current_time;
}

static void city_message_init_scenario(void)
{
    for (int i = 0; i < MAX_MESSAGES; i++) {
        message_data.messages[i].message_type = 0;
    }
    for (int i = 0; i < MAX_MESSAGE_QUEUE; i++) {
        message_data.queue[i] = 0;
    }
    message_data.consecutive_message_delay = 0;
    message_data.next_message_sequence = 0;
    message_data.total_messages = 0;
    message_data.current_message_id = -1;
    for (int i = 0; i < MAX_MESSAGE_CATEGORIES; i++) {
        message_data.message_count[i] = 0;
        message_data.message_delay[i] = 0;
    }
    // population
    message_data.population_shown.pop500 = 0;
    message_data.population_shown.pop1000 = 0;
    message_data.population_shown.pop2000 = 0;
    message_data.population_shown.pop3000 = 0;
    message_data.population_shown.pop5000 = 0;
    message_data.population_shown.pop10000 = 0;
    message_data.population_shown.pop15000 = 0;
    message_data.population_shown.pop20000 = 0;
    message_data.population_shown.pop25000 = 0;

    for (int i = 0; i <= MESSAGE_CAT_RIOT_COLLAPSE; i++) {
        message_data.last_sound_time[i] = 0;
    }
    city_message_init_problem_areas();
}

static void city_view_set_camera(int x, int y)
{
    view_data.camera.tile.x = x;
    view_data.camera.tile.y = y;
    check_camera_boundaries();
}

static void random_generate_next(void)
{
    random_data.pool[random_data.pool_index++] = random_data.random1_7bit;
    if (random_data.pool_index >= MAX_RANDOM) {
        random_data.pool_index = 0;
    }
    for (int i = 0; i < 31; i++) {
        unsigned int r1 = (((random_data.iv1 & 0x10) >> 4) ^ random_data.iv1) & 1;
        unsigned int r2 = (((random_data.iv2 & 0x10) >> 4) ^ random_data.iv2) & 1;
        random_data.iv1 = random_data.iv1 >> 1;
        random_data.iv2 = random_data.iv2 >> 1;
        if (r1) {
            random_data.iv1 |= 0x40000000;
        }
        if (r2) {
            random_data.iv2 |= 0x40000000;
        }
    }
    random_data.random1_7bit = random_data.iv1 & 0x7f;
    random_data.random1_15bit = random_data.iv1 & 0x7fff;
    random_data.random2_7bit = random_data.iv2 & 0x7f;
}

static void game_state_init(void)
{
    city_view_set_camera(76, 152);
    random_data.pool_index = 0;
    for (int i = 0; i < MAX_RANDOM; i++) {
        random_generate_next();
    }
    clear_all_warnings();
}

static void game_animation_init(void)
{
    for (int i = 0; i < MAX_ANIM_TIMERS; i++) {
        timers[i].last_update = 0;
        timers[i].should_update = 0;
    }
}

static void initialize_city_sounds(void)
{
    last_update_time = current_time;
    memset(channels, 0, MAX_CITY_SOUNDS_CHANNELS * sizeof(struct city_channel_t));
    for (int i = 0; i < MAX_CITY_SOUNDS_CHANNELS; i++) {
        channels[i].last_played_time = last_update_time;
    }
    for (int i = 1; i < MAX_CITY_SOUNDS_CHANNELS; i++) {
        channels[i].in_use = 1;
        channels[i].views_threshold = 200;
        channels[i].delay_millis = 1000;
    }
    channels[1].channel = SOUND_CHANNEL_CITY_VACANT_LOT;
    channels[2].channel = SOUND_CHANNEL_CITY_HOUSE_SLUM;
    channels[3].channel = SOUND_CHANNEL_CITY_HOUSE_POOR;
    channels[4].channel = SOUND_CHANNEL_CITY_HOUSE_MEDIUM;
    channels[5].channel = SOUND_CHANNEL_CITY_HOUSE_GOOD;
    channels[6].channel = SOUND_CHANNEL_CITY_HOUSE_POSH;
    channels[7].channel = SOUND_CHANNEL_CITY_EMPTY_LAND;
    channels[8].channel = SOUND_CHANNEL_CITY_RESERVOIR;
    channels[9].channel = SOUND_CHANNEL_CITY_AQUEDUCT;
    channels[10].channel = SOUND_CHANNEL_CITY_FOUNTAIN;
    channels[11].channel = SOUND_CHANNEL_CITY_WELL;
    channels[12].channel = SOUND_CHANNEL_CITY_BARBER;
    channels[13].channel = SOUND_CHANNEL_CITY_BATHHOUSE;
    channels[14].channel = SOUND_CHANNEL_CITY_CLINIC;
    channels[15].channel = SOUND_CHANNEL_CITY_HOSPITAL;
    channels[16].channel = SOUND_CHANNEL_CITY_TEMPLE_CERES;
    channels[17].channel = SOUND_CHANNEL_CITY_TEMPLE_NEPTUNE;
    channels[18].channel = SOUND_CHANNEL_CITY_TEMPLE_MERCURY;
    channels[19].channel = SOUND_CHANNEL_CITY_TEMPLE_MARS;
    channels[20].channel = SOUND_CHANNEL_CITY_TEMPLE_VENUS;
    channels[21].channel = SOUND_CHANNEL_CITY_ORACLE;
    channels[22].channel = SOUND_CHANNEL_CITY_SCHOOL;
    channels[23].channel = SOUND_CHANNEL_CITY_ACADEMY;
    channels[24].channel = SOUND_CHANNEL_CITY_LIBRARY;
    channels[25].channel = SOUND_CHANNEL_CITY_THEATER;
    channels[26].channel = SOUND_CHANNEL_CITY_AMPHITHEATER;
    channels[27].channel = SOUND_CHANNEL_CITY_COLOSSEUM;
    channels[28].channel = SOUND_CHANNEL_CITY_HIPPODROME;
    channels[29].channel = SOUND_CHANNEL_CITY_GLADIATOR_SCHOOL;
    channels[30].channel = SOUND_CHANNEL_CITY_LION_PIT;
    channels[31].channel = SOUND_CHANNEL_CITY_ACTOR_COLONY;
    channels[32].channel = SOUND_CHANNEL_CITY_CHARIOT_MAKER;
    channels[33].channel = SOUND_CHANNEL_CITY_FORUM;
    channels[34].channel = SOUND_CHANNEL_CITY_SENATE;
    channels[35].channel = SOUND_CHANNEL_CITY_PALACE;
    channels[36].channel = SOUND_CHANNEL_CITY_STATUE;
    channels[37].channel = SOUND_CHANNEL_CITY_GARDEN;
    channels[38].channel = SOUND_CHANNEL_CITY_SHIPYARD;
    channels[39].channel = SOUND_CHANNEL_CITY_DOCK;
    channels[40].channel = SOUND_CHANNEL_CITY_WHARF;
    channels[41].channel = SOUND_CHANNEL_CITY_TOWER;
    channels[42].channel = SOUND_CHANNEL_CITY_FORT;
    channels[43].channel = SOUND_CHANNEL_CITY_MILITARY_ACADEMY;
    channels[44].channel = SOUND_CHANNEL_CITY_BARRACKS;
    channels[45].channel = SOUND_CHANNEL_CITY_WHEAT_FARM;
    channels[46].channel = SOUND_CHANNEL_CITY_VEGETABLE_FARM;
    channels[47].channel = SOUND_CHANNEL_CITY_FRUIT_FARM;
    channels[48].channel = SOUND_CHANNEL_CITY_OLIVE_FARM;
    channels[49].channel = SOUND_CHANNEL_CITY_VINE_FARM;
    channels[50].channel = SOUND_CHANNEL_CITY_PIG_FARM;
    channels[51].channel = SOUND_CHANNEL_CITY_CLAY_PIT;
    channels[52].channel = SOUND_CHANNEL_CITY_QUARRY;
    channels[53].channel = SOUND_CHANNEL_CITY_IRON_MINE;
    channels[54].channel = SOUND_CHANNEL_CITY_TIMBER_YARD;
    channels[55].channel = SOUND_CHANNEL_CITY_WINE_WORKSHOP;
    channels[56].channel = SOUND_CHANNEL_CITY_OIL_WORKSHOP;
    channels[57].channel = SOUND_CHANNEL_CITY_WEAPONS_WORKSHOP;
    channels[58].channel = SOUND_CHANNEL_CITY_FURNITURE_WORKSHOP;
    channels[59].channel = SOUND_CHANNEL_CITY_POTTERY_WORKSHOP;
    channels[60].channel = SOUND_CHANNEL_CITY_MARKET;
    channels[61].channel = SOUND_CHANNEL_CITY_GRANARY;
    channels[62].channel = SOUND_CHANNEL_CITY_WAREHOUSE;
    channels[63].channel = SOUND_CHANNEL_CITY_BURNING_RUIN;
}

static void building_clear_all(void)
{
    for (int i = 0; i < MAX_BUILDINGS; i++) {
        memset(&all_buildings[i], 0, sizeof(struct building_t));
        all_buildings[i].id = i;
    }
    extra.highest_id_in_use = 0;
    extra.highest_id_ever = 0;
    extra.created_sequence = 0;
    extra.incorrect_houses = 0;
    extra.unfixable_houses = 0;
}

static void figure_init_scenario(void)
{
    for (int i = 0; i < MAX_FIGURES; i++) {
        memset(&figures[i], 0, sizeof(struct figure_t));
        figures[i].id = i;
    }
}

static int32_t init_name(void)
{
    random_generate_next();
    return random_data.random1_7bit & 0xf;
}

static void figure_name_init(void)
{
    name_data.citizen_male = init_name();
    name_data.patrician = init_name();
    name_data.citizen_female = init_name();
    name_data.tax_collector = init_name();
    name_data.engineer = init_name();
    name_data.prefect = init_name();
    name_data.javelin_thrower = init_name();
    name_data.cavalry = init_name();
    name_data.legionary = init_name();
    name_data.actor = init_name();
    name_data.gladiator = init_name();
    name_data.lion_tamer = init_name();
    name_data.charioteer = init_name();
    name_data.barbarian = init_name();
    name_data.enemy_greek = init_name();
    name_data.enemy_egyptian = init_name();
    name_data.enemy_arabian = init_name();
    name_data.trader = init_name();
    name_data.ship = init_name();
}

static void reset_all_formations(void)
{
    selected_legion_formation = 0;
    for (int i = 0; i < MAX_LEGIONS; i++) {
        memset(&legion_formations[i], 0, sizeof(struct formation_t));
        legion_formations[i].id = i;
    }
    for (int i = 0; i < MAX_HERD_POINTS; i++) {
        memset(&herd_formations[i], 0, sizeof(struct formation_t));
        herd_formations[i].id = i;
    }
    for (int i = 0; i < MAX_ENEMY_FORMATIONS; i++) {
        memset(&enemy_formations[i], 0, sizeof(struct formation_t));
        enemy_formations[i].id = i;
    }
}

static void figure_route_clear_all(void)
{
    for (int i = 0; i < MAX_ROUTES; i++) {
        figure_route_data.figure_ids[i] = 0;
        for (int j = 0; j < MAX_PATH_LENGTH; j++) {
            figure_route_data.direction_paths[i][j] = 0;
        }
    }
}

static void game_time_init(int year)
{
    time_data.tick = 0;
    time_data.day = 0;
    time_data.month = 0;
    time_data.total_days = 0;
    time_data.year = year;
}

static void map_building_clear(void)
{
    memset(buildings_grid.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
    memset(damage_grid.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memset(rubble_type_grid.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
}

static void map_property_clear(void)
{
    memset(bitfields_grid.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memset(edge_grid.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
}

static void map_random_init(void)
{
    int grid_offset = 0;
    for (int y = 0; y < GRID_SIZE; y++) {
        for (int x = 0; x < GRID_SIZE; x++, grid_offset++) {
            random_generate_next();
            random.items[grid_offset] = (uint8_t) random_data.random1_15bit;
        }
    }
}

static void buffer_reset(struct buffer_t *buf)
{
    buf->index = 0;
    buf->overflow = 0;
}

static void init_file_piece(struct file_piece_t *piece, int size)
{
    void *data = malloc(size);
    if (data) {
        memset(data, 0, size);
        buffer_init(&piece->buf, data, size);
    }
}

static struct buffer_t *create_scenario_piece(int size)
{
    struct file_piece_t *piece = &scenario_data.pieces[scenario_data.num_pieces++];
    init_file_piece(piece, size);
    return &piece->buf;
}

static void init_scenario_data(void)
{
    if (scenario_data.num_pieces > 0) {
        for (int i = 0; i < scenario_data.num_pieces; i++) {
            buffer_reset(&scenario_data.pieces[i].buf);
        }
        return;
    }
    struct scenario_state_t *state = &scenario_data.state;
    state->graphic_ids = create_scenario_piece(52488);
    state->edge = create_scenario_piece(26244);
    state->terrain = create_scenario_piece(78732);
    state->bitfields = create_scenario_piece(26244);
    state->random = create_scenario_piece(26244);
    state->random_iv = create_scenario_piece(8);
    state->camera = create_scenario_piece(8);
    state->scenario = create_scenario_piece(52425);
    state->empire_objects = create_scenario_piece(20600);
}

static void map_image_load_state(struct buffer_t *buf)
{
    for (int i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        images.items[i] = buffer_read_u16(buf);
    }
}

static int buffer_read_raw(struct buffer_t *buf, void *value, int max_size)
{
    int size = buf->size - buf->index;
    if (size > max_size) {
        size = max_size;
    }
    memcpy(value, &buf->data[buf->index], size);
    buf->index += size;
    return size;
}

static void map_terrain_load_state(struct buffer_t *buf)
{
    for (int i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        terrain_grid.items[i] = buffer_read_u16(buf);
    }
    buffer_read_raw(buf, terrain_elevation.items, GRID_SIZE * GRID_SIZE);
}

static void map_property_load_state(struct buffer_t *bitfields, struct buffer_t *edge)
{
    buffer_read_raw(bitfields, bitfields_grid.items, GRID_SIZE * GRID_SIZE);
    buffer_read_raw(edge, edge_grid.items, GRID_SIZE * GRID_SIZE);
}

static int32_t buffer_read_i32(struct buffer_t *buf)
{
    if (check_size(buf, 4)) {
        uint8_t b0 = buf->data[buf->index++];
        uint8_t b1 = buf->data[buf->index++];
        uint8_t b2 = buf->data[buf->index++];
        uint8_t b3 = buf->data[buf->index++];
        return (int32_t) (b0 | (b1 << 8) | (b2 << 16) | (b3 << 24));
    } else {
        return 0;
    }
}

static void city_view_load_scenario_state(struct buffer_t *camera)
{
    view_data.camera.tile.x = buffer_read_i32(camera);
    view_data.camera.tile.y = buffer_read_i32(camera);
}

static uint32_t buffer_read_u32(struct buffer_t *buf)
{
    if (check_size(buf, 4)) {
        uint8_t b0 = buf->data[buf->index++];
        uint8_t b1 = buf->data[buf->index++];
        uint8_t b2 = buf->data[buf->index++];
        uint8_t b3 = buf->data[buf->index++];
        return (uint32_t) (b0 | (b1 << 8) | (b2 << 16) | (b3 << 24));
    } else {
        return 0;
    }
}

static void random_load_state(struct buffer_t *buf)
{
    random_data.iv1 = buffer_read_u32(buf);
    random_data.iv2 = buffer_read_u32(buf);
}

static int8_t buffer_read_i8(struct buffer_t *buf)
{
    if (check_size(buf, 1)) {
        return (int8_t) buf->data[buf->index++];
    } else {
        return 0;
    }
}

static int16_t buffer_read_i16(struct buffer_t *buf)
{
    if (check_size(buf, 2)) {
        uint8_t b0 = buf->data[buf->index++];
        uint8_t b1 = buf->data[buf->index++];
        return (int16_t) (b0 | (b1 << 8));
    } else {
        return 0;
    }
}

static void scenario_load_state(struct buffer_t *buf)
{
    scenario.map.width = buffer_read_u16(buf);
    scenario.map.height = buffer_read_u16(buf);
    scenario.map.grid_start = buffer_read_u16(buf);
    scenario.empire.id = buffer_read_u8(buf);
    scenario.empire.is_expanded = buffer_read_u8(buf);
    scenario.empire.expansion_year = buffer_read_u16(buf);
    scenario.empire.distant_battle_roman_travel_months = buffer_read_u8(buf);
    scenario.empire.distant_battle_enemy_travel_months = buffer_read_u8(buf);
    // Map name
    buffer_read_raw(buf, scenario.scenario_name, MAX_SCENARIO_NAME);
    // Brief description
    buffer_read_raw(buf, scenario.brief_description, MAX_BRIEF_DESCRIPTION_LENGTH);
    scenario.brief_description_image_id = buffer_read_u16(buf);
    // Scenario description
    buffer_read_raw(buf, scenario.briefing, MAX_BRIEFING_LENGTH);
    // Terrain set
    scenario.climate = buffer_read_u8(buf);
    // Starting conditions
    scenario.player_rank = buffer_read_u8(buf);
    scenario.start_year = buffer_read_i16(buf);
    scenario.initial_favor = buffer_read_u8(buf);
    scenario.initial_funds = buffer_read_i32(buf);
    scenario.rescue_loan = buffer_read_i32(buf);
    scenario.initial_personal_savings = buffer_read_i32(buf);
    scenario.rome_supplies_wheat = buffer_read_u8(buf);
    scenario.flotsam_enabled = buffer_read_u8(buf);
    // Win criteria
    scenario.population_win_criteria = buffer_read_i32(buf);
    scenario.culture_win_criteria = buffer_read_i16(buf);
    scenario.prosperity_win_criteria = buffer_read_i16(buf);
    scenario.peace_win_criteria = buffer_read_i16(buf);
    scenario.favor_win_criteria = buffer_read_i16(buf);
    scenario.time_limit_win_criteria = buffer_read_i16(buf);
    scenario.survival_time_win_criteria = buffer_read_i16(buf);
    // Buildings allowed
    for (int i = 0; i < BUILDING_TYPE_MAX; i++) {
        scenario.allowed_buildings[i] = buffer_read_u8(buf);
    }
    // Special events
    scenario.gladiator_revolt.state = buffer_read_u8(buf);
    scenario.gladiator_revolt.month = buffer_read_i8(buf);
    scenario.gladiator_revolt.year_offset = buffer_read_i16(buf);
    // random events
    scenario.random_events.sea_trade_problem = buffer_read_u8(buf);
    scenario.random_events.land_trade_problem = buffer_read_u8(buf);
    scenario.random_events.raise_wages = buffer_read_u8(buf);
    scenario.random_events.lower_wages = buffer_read_u8(buf);
    scenario.random_events.contaminated_water = buffer_read_u8(buf);
    // Requests
    for (int i = 0; i < MAX_REQUESTS; i++) {
        scenario.requests[i].year_offset = buffer_read_i16(buf);
        scenario.requests[i].month = buffer_read_u8(buf);
        scenario.requests[i].amount = buffer_read_u16(buf);
        scenario.requests[i].resource = buffer_read_u8(buf);
        scenario.requests[i].years_deadline = buffer_read_u16(buf);
        scenario.requests[i].favor = buffer_read_u8(buf);
        scenario.requests[i].state = buffer_read_u8(buf);
        scenario.requests[i].visible = buffer_read_u8(buf);
        scenario.requests[i].months_to_comply = buffer_read_u16(buf);
        scenario.requests[i].can_comply_dialog_shown = buffer_read_u8(buf);
    }
    // Custom messages
    for (int i = 0; i < MAX_EDITOR_CUSTOM_MESSAGES; i++) {
        scenario.editor_custom_messages[i].year_offset = buffer_read_u16(buf);
        scenario.editor_custom_messages[i].month = buffer_read_u8(buf);
        scenario.editor_custom_messages[i].urgent = buffer_read_u8(buf);
        scenario.editor_custom_messages[i].enabled = buffer_read_u8(buf);
        buffer_read_raw(buf, scenario.editor_custom_messages[i].title, MAX_CUSTOM_MESSAGE_TITLE);
        buffer_read_raw(buf, scenario.editor_custom_messages[i].text, MAX_CUSTOM_MESSAGE_TEXT);
        buffer_read_raw(buf, scenario.editor_custom_messages[i].video_file, MAX_CUSTOM_MESSAGE_VIDEO_TEXT);
    }
    // Earthquakes
    for (int i = 0; i < MAX_EARTHQUAKES; i++) {
        scenario.earthquakes[i].state = buffer_read_u8(buf);
        scenario.earthquakes[i].severity = buffer_read_u8(buf);
        scenario.earthquakes[i].month = buffer_read_u8(buf);
        scenario.earthquakes[i].year_offset = buffer_read_u16(buf);
        scenario.earthquakes[i].duration = buffer_read_u16(buf);
        scenario.earthquakes[i].max_duration = buffer_read_u16(buf);
        scenario.earthquakes[i].delay = buffer_read_u8(buf);
        scenario.earthquakes[i].max_delay = buffer_read_u8(buf);
        scenario.earthquakes[i].point = buffer_read_u8(buf);
        for (int j = 0; j < MAX_EARTHQUAKE_BRANCHES; j++) {
            scenario.earthquakes[i].branch_coordinates[j].x = buffer_read_i32(buf);
            scenario.earthquakes[i].branch_coordinates[j].y = buffer_read_i32(buf);
        }
    }
    // Invasions
    for (int i = 0; i < MAX_INVASIONS; i++) {
        scenario.invasions[i].year_offset = buffer_read_u16(buf);
        scenario.invasions[i].month = buffer_read_u8(buf);
        scenario.invasions[i].amount = buffer_read_u16(buf);
        scenario.invasions[i].type = buffer_read_u8(buf);
        scenario.invasions[i].enemy_type = buffer_read_u8(buf);
        scenario.invasions[i].from = buffer_read_u8(buf);
        scenario.invasions[i].target_type = buffer_read_u8(buf);
    }
    scenario.invasion_upcoming = buffer_read_u8(buf);
    // Price changes
    for (int i = 0; i < MAX_PRICE_CHANGES; i++) {
        scenario.price_changes[i].year_offset = buffer_read_u16(buf);
        scenario.price_changes[i].month = buffer_read_u8(buf);
        scenario.price_changes[i].resource = buffer_read_u8(buf);
        scenario.price_changes[i].is_rise = buffer_read_u8(buf);
        scenario.price_changes[i].amount = buffer_read_u8(buf);
    }
    // Demand changes
    for (int i = 0; i < MAX_DEMAND_CHANGES; i++) {
        scenario.demand_changes[i].year_offset = buffer_read_u16(buf);
        scenario.demand_changes[i].month = buffer_read_u8(buf);
        scenario.demand_changes[i].resource = buffer_read_u8(buf);
        scenario.demand_changes[i].trade_city_id = buffer_read_u8(buf);
        scenario.demand_changes[i].is_rise = buffer_read_u8(buf);
    }
    // Earthquake points
    for (int i = 0; i < MAX_EARTHQUAKE_POINTS; i++) {
        scenario.earthquake_points[i].x = buffer_read_i16(buf);
        scenario.earthquake_points[i].y = buffer_read_i16(buf);
    }
    // Invasion points
    for (int i = 0; i < MAX_INVASION_POINTS; i++) {
        scenario.invasion_points[i].x = buffer_read_i16(buf);
        scenario.invasion_points[i].y = buffer_read_i16(buf);
    }
    // Entry/exit points
    scenario.entry_point.x = buffer_read_i16(buf);
    scenario.entry_point.y = buffer_read_i16(buf);
    scenario.exit_point.x = buffer_read_i16(buf);
    scenario.exit_point.y = buffer_read_i16(buf);
    // River entry/exit points
    scenario.river_entry_point.x = buffer_read_i16(buf);
    scenario.river_entry_point.y = buffer_read_i16(buf);
    scenario.river_exit_point.x = buffer_read_i16(buf);
    scenario.river_exit_point.y = buffer_read_i16(buf);
    // Native buildings
    scenario.native_images.hut = buffer_read_u32(buf);
    scenario.native_images.meeting = buffer_read_u32(buf);
    scenario.native_images.crops = buffer_read_u32(buf);
    scenario.native_images.vacant_lots = buffer_read_u32(buf);
    // Fishing points
    for (int i = 0; i < MAX_FISH_POINTS; i++) {
        scenario.fishing_points[i].x = buffer_read_i16(buf);
        scenario.fishing_points[i].y = buffer_read_i16(buf);
    }
    // Herd points
    for (int i = 0; i < MAX_HERD_POINTS; i++) {
        scenario.herd_points[i].x = buffer_read_i16(buf);
        scenario.herd_points[i].y = buffer_read_i16(buf);
    }
}

static void load_empire(struct buffer_t *buf)
{
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        empire_objects[i].id = i;
        empire_objects[i].type = buffer_read_u8(buf);
        empire_objects[i].x = buffer_read_i16(buf);
        empire_objects[i].y = buffer_read_i16(buf);
        empire_objects[i].image_id = buffer_read_i16(buf);
        if (!editor_active && empire_objects[i].image_id) { // equate editor graphics with main
            if (scenario.empire.id == 27 || scenario.empire.id == 32 || scenario.empire.id == 35 || scenario.empire.id == 38) {
                empire_objects[i].image_id += 4746;
            } else {
                empire_objects[i].image_id += 4750;
            }
        }
        empire_objects[i].expanded.x = buffer_read_i16(buf);
        empire_objects[i].expanded.y = buffer_read_i16(buf);
        empire_objects[i].expanded.image_id = buffer_read_i16(buf);
        empire_objects[i].width = buffer_read_i16(buf);
        empire_objects[i].height = buffer_read_i16(buf);
        empire_objects[i].animation_index = buffer_read_u8(buf);
        empire_objects[i].in_use = buffer_read_u8(buf);
        empire_objects[i].city_type = buffer_read_u8(buf);
        empire_objects[i].city_name_id = buffer_read_u8(buf);
        empire_objects[i].trade_route_id = buffer_read_u8(buf);
        empire_objects[i].trade_route_open = buffer_read_u8(buf);
        empire_objects[i].trade_route_cost = buffer_read_u32(buf);
        empire_objects[i].trader_entry_delay = buffer_read_i16(buf);
        empire_objects[i].is_sea_trade = buffer_read_u8(buf);
        for (int f = 0; f < 3; f++) {
            empire_objects[i].trader_figure_ids[f] = buffer_read_i16(buf);
        }
        for (int r = 0; r < RESOURCE_TYPES_MAX; r++) {
            empire_objects[i].resource_buy_limit[r] = buffer_read_u8(buf);
            empire_objects[i].resource_sell_limit[r] = buffer_read_u8(buf);
            empire_objects[i].resource_bought[r] = buffer_read_u8(buf);
            empire_objects[i].resource_sold[r] = buffer_read_u8(buf);
        }
        empire_objects[i].invasion_path_id = buffer_read_u8(buf);
        empire_objects[i].invasion_years = buffer_read_u8(buf);
        empire_objects[i].distant_battle_travel_months = buffer_read_u8(buf);
    }
}

static int game_file_io_read_scenario(char *dir, char *filename)
{
    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Loading scenario", filename, 0));
    init_scenario_data();
    static char dir_prepended_filepath[DIR_PATH_MAX];
    prepend_dir_to_path(dir, filename, dir_prepended_filepath);
    fp = fopen(dir_prepended_filepath, "rb");
    if (!fp) {
        return 0;
    }
    for (int i = 0; i < scenario_data.num_pieces; i++) {
        size_t read_size = fread(scenario_data.pieces[i].buf.data, 1, scenario_data.pieces[i].buf.size, fp);
        if (read_size != (unsigned) scenario_data.pieces[i].buf.size) {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to load scenario", filename, 0));
            fclose(fp);
            return 0;
        }
    }
    fclose(fp);
    map_image_load_state(scenario_data.state.graphic_ids);
    map_terrain_load_state(scenario_data.state.terrain);
    map_property_load_state(scenario_data.state.bitfields, scenario_data.state.edge);
    buffer_read_raw(scenario_data.state.random, random.items, GRID_SIZE * GRID_SIZE);
    city_view_load_scenario_state(scenario_data.state.camera);
    random_load_state(scenario_data.state.random_iv);
    scenario_load_state(scenario_data.state.scenario);
    load_empire(scenario_data.state.empire_objects);
    return 1;
}

static void calculate_lookup(void)
{
    for (int y = 0; y < VIEW_Y_MAX; y++) {
        for (int x = 0; x < VIEW_X_MAX; x++) {
            view_to_grid_offset_lookup[x][y] = -1;
        }
    }
    int y_view_start;
    int y_view_skip;
    int y_view_step;
    int x_view_start;
    int x_view_skip;
    int x_view_step;
    switch (view_data.orientation) {
        default:
        case DIR_0_TOP:
            x_view_start = VIEW_X_MAX - 1;
            x_view_skip = -1;
            x_view_step = 1;
            y_view_start = 1;
            y_view_skip = 1;
            y_view_step = 1;
            break;
        case DIR_2_RIGHT:
            x_view_start = 3;
            x_view_skip = 1;
            x_view_step = 1;
            y_view_start = VIEW_X_MAX - 3;
            y_view_skip = 1;
            y_view_step = -1;
            break;
        case DIR_4_BOTTOM:
            x_view_start = VIEW_X_MAX - 1;
            x_view_skip = 1;
            x_view_step = -1;
            y_view_start = VIEW_Y_MAX - 2;
            y_view_skip = -1;
            y_view_step = -1;
            break;
        case DIR_6_LEFT:
            x_view_start = VIEW_Y_MAX;
            x_view_skip = -1;
            x_view_step = -1;
            y_view_start = VIEW_X_MAX - 3;
            y_view_skip = -1;
            y_view_step = 1;
            break;
    }

    for (int y = 0; y < GRID_SIZE; y++) {
        int x_view = x_view_start;
        int y_view = y_view_start;
        for (int x = 0; x < GRID_SIZE; x++) {
            int grid_offset = x + GRID_SIZE * y;
            if (images.items[grid_offset] < 6) {
                view_to_grid_offset_lookup[x_view / 2][y_view] = -1;
            } else {
                view_to_grid_offset_lookup[x_view / 2][y_view] = grid_offset;
            }
            x_view += x_view_step;
            y_view += y_view_step;
        }
        x_view_start += x_view_skip;
        y_view_start += y_view_skip;
    }
}

static void city_view_reset_orientation(void)
{
    view_data.orientation = 0;
    calculate_lookup();
}

static int game_file_load_scenario_data(char *scenario_file)
{
    if (!game_file_io_read_scenario(MAPS_DIR_PATH, scenario_file)) {
        return 0;
    }
    city_view_reset_orientation();
    return 1;
}

static void file_remove_extension(char *filename)
{
    uint8_t c;
    do {
        c = *filename;
        filename++;
    } while (c != '.' && c);
    if (c == '.') {
        filename--;
        *filename = 0;
    }
}

static void map_grid_init(int width, int height, int start_offset)
{
    map_data.width = width;
    map_data.height = height;
    map_data.start_offset = start_offset;
    map_data.border_size = GRID_SIZE - scenario.map.width;
}

static void set_elevation_image(int x, int y, int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_ACCESS_RAMP) && !images.items[grid_offset]) {
        int image_offset = -1;
        if (map_grid_is_inside(x, y, 1)) {
            static   int offsets[4][6] = {
                {OFFSET(0,1), OFFSET(1,1), OFFSET(0,0), OFFSET(1,0), OFFSET(0,2), OFFSET(1,2)},
                {OFFSET(0,0), OFFSET(0,1), OFFSET(1,0), OFFSET(1,1), OFFSET(-1,0), OFFSET(-1,1)},
                {OFFSET(0,0), OFFSET(1,0), OFFSET(0,1), OFFSET(1,1), OFFSET(0,-1), OFFSET(1,-1)},
                {OFFSET(1,0), OFFSET(1,1), OFFSET(0,0), OFFSET(0,1), OFFSET(2,0), OFFSET(2,1)},
            };
            int base_offset = map_grid_offset(x, y);
            for (int dir = 0; dir < 4; dir++) {
                int right_tiles = 0;
                int height = -1;
                for (int i = 0; i < 6; i++) {
                    int grid_offset2 = base_offset + offsets[dir][i];
                    if (i < 2) { // 2nd row
                        if (map_terrain_is(grid_offset2, TERRAIN_ELEVATION)) {
                            right_tiles++;
                        }
                        height = terrain_elevation.items[grid_offset2];
                    } else if (i < 4) { // 1st row
                        if (map_terrain_is(grid_offset2, TERRAIN_ACCESS_RAMP) &&
                            terrain_elevation.items[grid_offset2] < height) {
                            right_tiles++;
                        }
                    } else { // higher row beyond access ramp
                        if (map_terrain_is(grid_offset2, TERRAIN_ELEVATION)) {
                            if (terrain_elevation.items[grid_offset2] != height) {
                                right_tiles++;
                            }
                        } else if (terrain_elevation.items[grid_offset2] >= height) {
                            right_tiles++;
                        }
                    }
                }
                if (right_tiles == 6) {
                    image_offset = dir;
                    break;
                }
            }
            if (image_offset > -1) {
                switch (view_data.orientation) {
                    case DIR_0_TOP: break;
                    case DIR_6_LEFT: image_offset += 1; break;
                    case DIR_4_BOTTOM: image_offset += 2; break;
                    case DIR_2_RIGHT: image_offset += 3; break;
                }
                if (image_offset >= 4) {
                    image_offset -= 4;
                }
            }
        }
        if (image_offset < 0) {
            // invalid map: remove access ramp
            terrain_grid.items[grid_offset] &= ~TERRAIN_ACCESS_RAMP;
            map_property_set_multi_tile_size(grid_offset, 1);
            edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
            if (terrain_elevation.items[grid_offset]) {
                terrain_grid.items[grid_offset] |= TERRAIN_ELEVATION;
            } else {
                terrain_grid.items[grid_offset] &= ~TERRAIN_ELEVATION;
                images.items[grid_offset] = 306 + (random.items[grid_offset] & 7);
            }
        } else {
            map_building_tiles_add(0, x, y, 2, 845 + image_offset, TERRAIN_ACCESS_RAMP);
        }
    }
    if (terrain_elevation.items[grid_offset] && !map_terrain_is(grid_offset, TERRAIN_ACCESS_RAMP) && !map_terrain_is(grid_offset, TERRAIN_WATER) && !map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
        int tiles[MAX_TILES_TERRAIN];
        for (int i = 0; i < MAX_TILES_TERRAIN; i++) {
            tiles[i] = terrain_elevation.items[grid_offset + map_grid_direction_delta(i)] >= terrain_elevation.items[grid_offset] ? 1 : 0;
        }
        struct terrain_image_t *img = get_image(CONTEXT_ELEVATION, tiles);
        if (img->group_offset == 44) {
            terrain_grid.items[grid_offset] &= ~TERRAIN_ELEVATION;
            map_property_set_multi_tile_xy(grid_offset, 0, 0, 1);
        } else {
            map_property_set_multi_tile_xy(grid_offset, 0, 0, 1);
            terrain_grid.items[grid_offset] |= TERRAIN_ELEVATION;
            images.items[grid_offset] = 201 + img->group_offset + img->item_offset;
        }
    }
}

static void map_tiles_update_all_elevation(void)
{
    for (int y = 0; y <= map_data.width - 2; y++) {
        for (int x = 0; x <= map_data.width - 2; x++) {
            if (map_terrain_is(map_data.start_offset + x + y * GRID_SIZE, TERRAIN_ACCESS_RAMP)) {
                images.items[map_data.start_offset + x + y * GRID_SIZE] = 0;
            }
        }
    }
    for (int y = 0; y <= map_data.width - 2; y++) {
        for (int x = 0; x <= map_data.width - 2; x++) {
            set_elevation_image(x, y, map_data.start_offset + x + y * GRID_SIZE);
        }
    }
}

static void set_earthquake_image(__attribute__((unused)) int x, __attribute__((unused)) int y, int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_ROCK) && bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
        int tiles[MAX_TILES_TERRAIN];
        for (int i = 0; i < MAX_TILES_TERRAIN; i++) {
            int offset = grid_offset + map_grid_direction_delta(i);
            tiles[i] = (map_terrain_is(offset, TERRAIN_ROCK) && bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) ? 1 : 0;
        }
        struct terrain_image_t *img = get_image(CONTEXT_EARTHQUAKE, tiles);
        if (img->is_valid) {
            images.items[grid_offset] = 444 + img->group_offset + img->item_offset;
        } else {
            images.items[grid_offset] = 444;
        }
        map_property_set_multi_tile_size(grid_offset, 1);
        edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
    }
}

static void map_tiles_update_all_earthquake(void)
{
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (map_terrain_is(grid_offset, TERRAIN_ROCK) && bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
                terrain_grid.items[grid_offset] |= TERRAIN_ROCK;
                bitfields_grid.items[grid_offset] |= BIT_PLAZA_OR_EARTHQUAKE;
                foreach_region_tile(x - 1, y - 1, x + 1, y + 1, set_earthquake_image);
            }
        }
    }
}

static void map_tiles_add_entry_exit_flags(void)
{
    int entry_orientation;
    if (scenario.entry_point.x == 0) {
        entry_orientation = DIR_2_RIGHT;
    } else if (scenario.entry_point.x == map_data.width - 1) {
        entry_orientation = DIR_6_LEFT;
    } else if (scenario.entry_point.y == 0) {
        entry_orientation = DIR_0_TOP;
    } else if (scenario.entry_point.y == map_data.height - 1) {
        entry_orientation = DIR_4_BOTTOM;
    } else {
        entry_orientation = -1;
    }
    if (entry_orientation >= 0) {
        int grid_offset = map_grid_offset(scenario.entry_point.x, scenario.entry_point.y);
        terrain_grid.items[grid_offset] |= TERRAIN_ROCK;
        int orientation = (view_data.orientation + entry_orientation) % 8;
        images.items[grid_offset] = 863 + orientation / 2;
    }
    int exit_orientation;
    if (scenario.exit_point.x == 0) {
        exit_orientation = DIR_2_RIGHT;
    } else if (scenario.exit_point.x == map_data.width - 1) {
        exit_orientation = DIR_6_LEFT;
    } else if (scenario.exit_point.y == 0) {
        exit_orientation = DIR_0_TOP;
    } else if (scenario.exit_point.y == map_data.height - 1) {
        exit_orientation = DIR_4_BOTTOM;
    } else {
        exit_orientation = -1;
    }
    if (exit_orientation >= 0) {
        int grid_offset = map_grid_offset(scenario.exit_point.x, scenario.exit_point.y);
        terrain_grid.items[grid_offset] |= TERRAIN_ROCK;
        int orientation = (view_data.orientation + exit_orientation) % 8;
        images.items[grid_offset] = 867 + orientation / 2;
    }
}

static void map_tiles_update_all_empty_land(void)
{
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            clear_empty_land_image(x, y, grid_offset);
        }
    }
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            set_empty_land_pass1(x, y, grid_offset);
        }
    }
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            set_empty_land_pass2(x, y, grid_offset);
        }
    }
}

static void set_aqueduct_image(int grid_offset, int is_road, struct terrain_image_t *img)
{
    int group_offset = img->group_offset;
    if (is_road) {
        if (!img->aqueduct_offset || (group_offset != 2 && group_offset != 3)) {
            if (map_terrain_is(grid_offset + map_grid_delta(0, -1), TERRAIN_ROAD)) {
                group_offset = 3;
            } else {
                group_offset = 2;
            }
        }
        if (map_tiles_is_paved_road(grid_offset)) {
            group_offset -= 2;
        } else {
            group_offset += 6;
        }
    }
    int image_aqueduct = 666;
    int water_offset;
    if (images.items[grid_offset] >= image_aqueduct && images.items[grid_offset] < image_aqueduct + 15) {
        water_offset = 0;
    } else {
        water_offset = 15;
    }
    images.items[grid_offset] = image_aqueduct + water_offset + group_offset;
    map_property_set_multi_tile_size(grid_offset, 1);
    edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
}

static void set_tiles_road(int grid_offset, int tiles[MAX_TILES_TERRAIN])
{
    fill_matches(grid_offset, TERRAIN_ROAD, 1, 0, tiles);
    for (int i = 0; i < MAX_TILES_TERRAIN; i += 2) {
        int offset = grid_offset + map_grid_direction_delta(i);
        if (map_terrain_is(offset, TERRAIN_GATEHOUSE)) {
            struct building_t *b = &all_buildings[map_building_at(offset)];
            if (b->type == BUILDING_GATEHOUSE &&
                b->subtype.orientation == 1 + ((i / 2) & 1)) { // 1,2,1,2
                tiles[i] = 1;
            }
        } else if (map_terrain_is(offset, TERRAIN_ACCESS_RAMP)) {
            tiles[i] = 1;
        } else if (map_terrain_is(offset, TERRAIN_BUILDING)) {
            struct building_t *b = &all_buildings[map_building_at(offset)];
            if (b->type == BUILDING_GRANARY) {
                tiles[i] = (offset == b->grid_offset + map_grid_delta(1, 0)) ? 1 : 0;
                tiles[i] |= (offset == b->grid_offset + map_grid_delta(0, 1)) ? 1 : 0;
                tiles[i] |= (offset == b->grid_offset + map_grid_delta(2, 1)) ? 1 : 0;
                tiles[i] |= (offset == b->grid_offset + map_grid_delta(1, 2)) ? 1 : 0;
            }
        }
    }
}

static void set_road_image(__attribute__((unused)) int x, __attribute__((unused)) int y, int grid_offset)
{
    if (!map_terrain_is(grid_offset, TERRAIN_ROAD) ||
        map_terrain_is(grid_offset, TERRAIN_WATER | TERRAIN_BUILDING)) {
        return;
    }
    if (map_terrain_is(grid_offset, TERRAIN_AQUEDUCT)) {
        set_aqueduct_image(grid_offset, 1, map_image_context_get_aqueduct(grid_offset, 0));
        return;
    }
    if (bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
        return;
    }
    if (map_tiles_is_paved_road(grid_offset)) {
        int tiles[MAX_TILES_TERRAIN];
        set_tiles_road(grid_offset, tiles);
        struct terrain_image_t *img = get_image(CONTEXT_PAVED_ROAD, tiles);
        images.items[grid_offset] = 591 + img->group_offset + img->item_offset;
    } else {
        int tiles[MAX_TILES_TERRAIN];
        set_tiles_road(grid_offset, tiles);
        struct terrain_image_t *img = get_image(CONTEXT_DIRT_ROAD, tiles);
        images.items[grid_offset] = 591 + img->group_offset + img->item_offset + 49;
    }
    map_property_set_multi_tile_size(grid_offset, 1);
    edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
}

static void map_tiles_update_all_roads(void)
{
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            set_road_image(x, y, grid_offset);
        }
    }
}

static int is_tile_plaza(int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_ROAD) &&
        bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE &&
        !map_terrain_is(grid_offset, TERRAIN_WATER | TERRAIN_BUILDING) &&
        !images.items[grid_offset]) {
        return 1;
    }
    return 0;
}

static void map_tiles_update_all_plazas(void)
{
    // remove plaza below building
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (map_terrain_is(grid_offset, TERRAIN_ROAD)
                && bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
                if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
                    bitfields_grid.items[grid_offset] &= BIT_NO_PLAZA;
                }
            }
        }
    }
    // clear plaza image
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (map_terrain_is(grid_offset, TERRAIN_ROAD)
                && bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
                images.items[grid_offset] = 0;
                map_property_set_multi_tile_size(grid_offset, 1);
                edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
            }
        }
    }
    // set plaza image
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (map_terrain_is(grid_offset, TERRAIN_ROAD)
                && bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE
                && !images.items[grid_offset]) {
                int image_id = 3140;
                if (is_tile_plaza(grid_offset + map_grid_delta(1, 0))
                && is_tile_plaza(grid_offset + map_grid_delta(0, 1))
                && is_tile_plaza(grid_offset + map_grid_delta(1, 1))) {
                    if (random.items[grid_offset] & 1) {
                        image_id += 7;
                    } else {
                        image_id += 6;
                    }
                    map_building_tiles_add(0, x, y, 2, image_id, TERRAIN_ROAD);
                } else {
                    // single tile plaza
                    switch ((x & 1) + (y & 1)) {
                        case 2: image_id += 1; break;
                        case 1: image_id += 2; break;
                    }
                    images.items[grid_offset] = image_id;
                }
            }
        }
    }
}

static int get_gatehouse_building_id(int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_GATEHOUSE)) {
        return map_building_at(grid_offset);
    }
    return 0;
}

static int get_gatehouse_position(int grid_offset, int direction, int building_id)
{
    int result = 0;
    if (direction == DIR_0_TOP) {
        if (map_terrain_is(grid_offset + map_grid_delta(1, -1), TERRAIN_GATEHOUSE) &&
                map_building_at(grid_offset + map_grid_delta(1, -1)) == building_id) {
            result = 1;
            if (!map_terrain_is(grid_offset + map_grid_delta(1, 0), TERRAIN_WALL)) {
                result = 0;
            }
            if (map_terrain_is(grid_offset + map_grid_delta(-1, 0), TERRAIN_WALL) &&
                map_terrain_is(grid_offset + map_grid_delta(-1, 1), TERRAIN_WALL)) {
                result = 2;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(0, 1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(1, 1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
        } else if (map_terrain_is(grid_offset + map_grid_delta(-1, -1), TERRAIN_GATEHOUSE) &&
                map_building_at(grid_offset + map_grid_delta(-1, -1)) == building_id) {
            result = 3;
            if (!map_terrain_is(grid_offset + map_grid_delta(-1, 0), TERRAIN_WALL)) {
                result = 0;
            }
            if (map_terrain_is(grid_offset + map_grid_delta(1, 0), TERRAIN_WALL) &&
                map_terrain_is(grid_offset + map_grid_delta(1, 1), TERRAIN_WALL)) {
                result = 4;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(0, 1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(-1, 1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
        }
    } else if (direction == DIR_6_LEFT) {
        if (map_terrain_is(grid_offset + map_grid_delta(-1, 1), TERRAIN_GATEHOUSE) &&
                map_building_at(grid_offset + map_grid_delta(-1, 1)) == building_id) {
            result = 1;
            if (!map_terrain_is(grid_offset + map_grid_delta(0, 1), TERRAIN_WALL)) {
                result = 0;
            }
            if (map_terrain_is(grid_offset + map_grid_delta(0, -1), TERRAIN_WALL) &&
                map_terrain_is(grid_offset + map_grid_delta(1, -1), TERRAIN_WALL)) {
                result = 2;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(1, 0), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(1, 1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
        } else if (map_terrain_is(grid_offset + map_grid_delta(-1, -1), TERRAIN_GATEHOUSE) &&
                map_building_at(grid_offset + map_grid_delta(-1, -1)) == building_id) {
            result = 3;
            if (!map_terrain_is(grid_offset + map_grid_delta(0, -1), TERRAIN_WALL)) {
                result = 0;
            }
            if (map_terrain_is(grid_offset + map_grid_delta(0, 1), TERRAIN_WALL) &&
                map_terrain_is(grid_offset + map_grid_delta(1, 1), TERRAIN_WALL)) {
                result = 4;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(1, 0), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(1, -1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
        }
    } else if (direction == DIR_4_BOTTOM) {
        if (map_terrain_is(grid_offset + map_grid_delta(1, 1), TERRAIN_GATEHOUSE) &&
                map_building_at(grid_offset + map_grid_delta(1, 1)) == building_id) {
            result = 1;
            if (!map_terrain_is(grid_offset + map_grid_delta(1, 0), TERRAIN_WALL)) {
                result = 0;
            }
            if (map_terrain_is(grid_offset + map_grid_delta(-1, 0), TERRAIN_WALL) &&
                map_terrain_is(grid_offset + map_grid_delta(-1, -1), TERRAIN_WALL)) {
                result = 2;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(0, -1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(1, -1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
        } else if (map_terrain_is(grid_offset + map_grid_delta(-1, 1), TERRAIN_GATEHOUSE) &&
                map_building_at(grid_offset + map_grid_delta(-1, 1)) == building_id) {
            result = 3;
            if (!map_terrain_is(grid_offset + map_grid_delta(-1, 0), TERRAIN_WALL)) {
                result = 0;
            }
            if (map_terrain_is(grid_offset + map_grid_delta(1, 0), TERRAIN_WALL) &&
                map_terrain_is(grid_offset + map_grid_delta(1, -1), TERRAIN_WALL)) {
                result = 4;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(0, -1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(-1, -1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
        }
    } else if (direction == DIR_2_RIGHT) {
        if (map_terrain_is(grid_offset + map_grid_delta(1, 1), TERRAIN_GATEHOUSE) &&
                map_building_at(grid_offset + map_grid_delta(1, 1)) == building_id) {
            result = 1;
            if (!map_terrain_is(grid_offset + map_grid_delta(0, 1), TERRAIN_WALL)) {
                result = 0;
            }
            if (map_terrain_is(grid_offset + map_grid_delta(0, -1), TERRAIN_WALL) &&
                map_terrain_is(grid_offset + map_grid_delta(-1, -1), TERRAIN_WALL)) {
                result = 2;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(-1, 0), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(-1, 1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
        } else if (map_terrain_is(grid_offset + map_grid_delta(1, -1), TERRAIN_GATEHOUSE) &&
                map_building_at(grid_offset + map_grid_delta(1, -1)) == building_id) {
            result = 3;
            if (!map_terrain_is(grid_offset + map_grid_delta(0, -1), TERRAIN_WALL)) {
                result = 0;
            }
            if (map_terrain_is(grid_offset + map_grid_delta(0, 1), TERRAIN_WALL) &&
                map_terrain_is(grid_offset + map_grid_delta(-1, 1), TERRAIN_WALL)) {
                result = 4;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(-1, 0), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
            if (!map_terrain_is(grid_offset + map_grid_delta(-1, -1), TERRAIN_WALL_OR_GATEHOUSE)) {
                result = 0;
            }
        }
    }
    return result;
}

static void set_wall_image(__attribute__((unused)) int x, __attribute__((unused)) int y, int grid_offset)
{
    if (!map_terrain_is(grid_offset, TERRAIN_WALL) ||
        map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
        return;
    }
    int tiles[MAX_TILES_TERRAIN];
    fill_matches(grid_offset, TERRAIN_WALL, 0, 1, tiles);
    struct terrain_image_t *img = get_image(CONTEXT_WALL, tiles);
    images.items[grid_offset] = 699 + img->group_offset + img->item_offset;
    map_property_set_multi_tile_size(grid_offset, 1);
    edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
    if (map_terrain_count_directly_adjacent_with_type(grid_offset, TERRAIN_GATEHOUSE) > 0) {
        for (int i = 0; i < MAX_TILES_TERRAIN; i += 2) {
            tiles[i] = map_terrain_is(grid_offset + map_grid_direction_delta(i), TERRAIN_WALL_OR_GATEHOUSE) ? 1 : 0;
        }
        img = get_image(CONTEXT_WALL_GATEHOUSE, tiles);
        if (img->is_valid) {
            images.items[grid_offset] = 699 + img->group_offset + img->item_offset;
        } else {
            int gatehouse_up = get_gatehouse_building_id(grid_offset + map_grid_delta(0, -1));
            int gatehouse_left = get_gatehouse_building_id(grid_offset + map_grid_delta(-1, 0));
            int gatehouse_down = get_gatehouse_building_id(grid_offset + map_grid_delta(0, 1));
            int gatehouse_right = get_gatehouse_building_id(grid_offset + map_grid_delta(1, 0));
            int image_offset = 0;
            int map_orientation = view_data.orientation;
            if (map_orientation == DIR_0_TOP) {
                if (gatehouse_up && !gatehouse_left) {
                    int pos = get_gatehouse_position(grid_offset, DIR_0_TOP, gatehouse_up);
                    if (pos > 0) {
                        if (pos <= 2) {
                            image_offset = 29;
                        } else if (pos == 3) {
                            image_offset = 31;
                        } else {
                            image_offset = 33;
                        }
                    }
                } else if (gatehouse_left && !gatehouse_up) {
                    int pos = get_gatehouse_position(grid_offset, DIR_6_LEFT, gatehouse_left);
                    if (pos > 0) {
                        if (pos <= 2) {
                            image_offset = 30;
                        } else if (pos == 3) {
                            image_offset = 32;
                        } else {
                            image_offset = 33;
                        }
                    }
                }
            } else if (map_orientation == DIR_2_RIGHT) {
                if (gatehouse_up && !gatehouse_right) {
                    int pos = get_gatehouse_position(grid_offset, DIR_0_TOP, gatehouse_up);
                    if (pos > 0) {
                        if (pos == 1) {
                            image_offset = 32;
                        } else if (pos == 2) {
                            image_offset = 33;
                        } else {
                            image_offset = 30;
                        }
                    }
                } else if (gatehouse_right && !gatehouse_up) {
                    int pos = get_gatehouse_position(grid_offset, DIR_2_RIGHT, gatehouse_right);
                    if (pos > 0) {
                        if (pos <= 2) {
                            image_offset = 29;
                        } else if (pos == 3) {
                            image_offset = 31;
                        } else {
                            image_offset = 33;
                        }
                    }
                }
            } else if (map_orientation == DIR_4_BOTTOM) {
                if (gatehouse_down && !gatehouse_right) {
                    int pos = get_gatehouse_position(grid_offset, DIR_4_BOTTOM, gatehouse_down);
                    if (pos > 0) {
                        if (pos == 1) {
                            image_offset = 31;
                        } else if (pos == 2) {
                            image_offset = 33;
                        } else {
                            image_offset = 29;
                        }
                    }
                } else if (gatehouse_right && !gatehouse_down) {
                    int pos = get_gatehouse_position(grid_offset, DIR_2_RIGHT, gatehouse_right);
                    if (pos > 0) {
                        if (pos == 1) {
                            image_offset = 32;
                        } else if (pos == 2) {
                            image_offset = 33;
                        } else {
                            image_offset = 30;
                        }
                    }
                }
            } else if (map_orientation == DIR_6_LEFT) {
                if (gatehouse_down && !gatehouse_left) {
                    int pos = get_gatehouse_position(grid_offset, DIR_4_BOTTOM, gatehouse_down);
                    if (pos > 0) {
                        if (pos <= 2) {
                            image_offset = 30;
                        } else if (pos == 3) {
                            image_offset = 32;
                        } else {
                            image_offset = 33;
                        }
                    }
                } else if (gatehouse_left && !gatehouse_down) {
                    int pos = get_gatehouse_position(grid_offset, DIR_6_LEFT, gatehouse_left);
                    if (pos > 0) {
                        if (pos == 1) {
                            image_offset = 31;
                        } else if (pos == 2) {
                            image_offset = 33;
                        } else {
                            image_offset = 29;
                        }
                    }
                }
            }
            if (image_offset) {
                images.items[grid_offset] = 699 + image_offset;
            }
        }
    }
}

static void map_tiles_update_all_walls(void)
{
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            set_wall_image(x, y, grid_offset);
        }
    }
}

static void update_aqueduct_tile(__attribute__((unused)) int x, __attribute__((unused)) int y, int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_AQUEDUCT) && aqueduct.items[grid_offset] <= 15) {
        struct terrain_image_t *img = map_image_context_get_aqueduct(grid_offset, aqueduct_include_construction);
        int is_road = map_terrain_is(grid_offset, TERRAIN_ROAD);
        if (is_road) {
            bitfields_grid.items[grid_offset] &= BIT_NO_PLAZA;
        }
        set_aqueduct_image(grid_offset, is_road, img);
        aqueduct.items[grid_offset] = img->aqueduct_offset;
    }
}

static void map_tiles_update_all_aqueducts(int include_construction)
{
    aqueduct_include_construction = include_construction;
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            update_aqueduct_tile(x, y, grid_offset);
        }
    }
    aqueduct_include_construction = 0;
}

static void building_list_small_add(int building_id)
{
    building_list_data.small.items[building_list_data.small.size++] = building_id;
    if (building_list_data.small.size >= MAX_SMALL) {
        building_list_data.small.size = MAX_SMALL - 1;
    }
}

static void city_view_init(void)
{
    calculate_lookup();
    check_camera_boundaries();
    minimap_data.refresh_requested = 1;
}

static void map_figure_add(struct figure_t *f)
{
    if (!map_grid_is_valid_offset(f->grid_offset)) {
        return;
    }
    f->next_figure_id_on_same_tile = 0;

    if (map_figures.items[f->grid_offset]) {
        struct figure_t *next = &figures[map_figures.items[f->grid_offset]];
        while (next->next_figure_id_on_same_tile) {
            next = &figures[next->next_figure_id_on_same_tile];
        }
        next->next_figure_id_on_same_tile = f->id;
    } else {
        map_figures.items[f->grid_offset] = f->id;
    }
}

static struct figure_t *figure_create(int type, int x, int y, int dir)
{
    int id = 0;
    for (int i = 1; i < MAX_FIGURES; i++) {
        if (!figures[i].in_use) {
            id = i;
            break;
        }
    }
    if (!id) {
        return &figures[0];
    }
    struct figure_t *f = &figures[id];
    f->in_use = 1;
    f->type = type;
    f->speed_multiplier = 1;
    f->direction = dir;
    f->source_x = f->destination_x = f->previous_tile_x = f->x = x;
    f->source_y = f->destination_y = f->previous_tile_y = f->y = y;
    f->grid_offset = map_grid_offset(x, y);
    f->cross_country_x = 15 * x;
    f->cross_country_y = 15 * y;
    f->progress_on_tile = 15;
    switch (f->type) {
        case FIGURE_TAX_COLLECTOR:
            string_copy(tax_collector_names[rand() % 32], f->name, FIGURE_MAX_NAME_LENGTH);
            break;
        case FIGURE_ENGINEER:
            string_copy(engineer_names[rand() % 32], f->name, FIGURE_MAX_NAME_LENGTH);
            break;
        case FIGURE_PREFECT:
            string_copy(prefect_names[rand() % 32], f->name, FIGURE_MAX_NAME_LENGTH);
            break;
        case FIGURE_TOWER_SENTRY:
        case FIGURE_FORT_JAVELIN:
        case FIGURE_ENEMY_CAESAR_JAVELIN:
            string_copy(javelin_thrower_names[rand() % 32], f->name, FIGURE_MAX_NAME_LENGTH);
            break;
        case FIGURE_ACTOR:
            string_copy(actor_names[rand() % 32], f->name, FIGURE_MAX_NAME_LENGTH);
            break;
        case FIGURE_GLADIATOR:
            string_copy(gladiator_names[rand() % 32], f->name, FIGURE_MAX_NAME_LENGTH);
            break;
        case FIGURE_LION_TAMER:
            string_copy(lion_tamer_names[rand() % 16], f->name, FIGURE_MAX_NAME_LENGTH);
            break;
        case FIGURE_CHARIOTEER:
            string_copy(charioteer_names[rand() % 16], f->name, FIGURE_MAX_NAME_LENGTH);
            break;
        case FIGURE_TRADE_CARAVAN:
        case FIGURE_TRADE_CARAVAN_DONKEY:
            string_copy(trade_caravan_names[rand() % 16], f->name, FIGURE_MAX_NAME_LENGTH);
            break;
        case FIGURE_TRADE_SHIP:
        case FIGURE_FISHING_BOAT:
            string_copy(trade_ship_names[rand() % 16], f->name, FIGURE_MAX_NAME_LENGTH);
            break;
        case FIGURE_MARKET_TRADER:
        case FIGURE_MARKET_BUYER:
        case FIGURE_BATHHOUSE_WORKER:
            string_copy(female_names[rand() % 32], f->name, FIGURE_MAX_NAME_LENGTH);
            break;
        case FIGURE_PRIEST:
        case FIGURE_TEACHER:
        case FIGURE_MISSIONARY:
        case FIGURE_LIBRARIAN:
        case FIGURE_DOCTOR:
        case FIGURE_SURGEON:
        case FIGURE_PATRICIAN:
            string_copy(patrician_names[rand() % 32], f->name, FIGURE_MAX_NAME_LENGTH);
            break;
        case FIGURE_FORT_MOUNTED:
        case FIGURE_ENEMY_CAESAR_MOUNTED:
            string_copy(mounted_auxiliary_names[rand() % 32], f->name, FIGURE_MAX_NAME_LENGTH);
            break;
        case FIGURE_FORT_LEGIONARY:
        case FIGURE_ENEMY_CAESAR_LEGIONARY:
            string_copy(legionary_names[rand() % 32], f->name, FIGURE_MAX_NAME_LENGTH);
            break;
        case FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN:
        case FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT:
        case FIGURE_ENEMY_NUMIDIAN_SWORDSMAN:
        case FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER:
        case FIGURE_ENEMY_PERGAMUM_SWORDSMAN:
        case FIGURE_ENEMY_PERGAMUM_ARCHER:
            string_copy(arabic_names[rand() % 32], f->name, FIGURE_MAX_NAME_LENGTH);
            break;
        case FIGURE_ENEMY_EGYPTIAN_SWORDSMAN:
        case FIGURE_ENEMY_EGYPTIAN_CAMEL:
            string_copy(egyptian_names[rand() % 32], f->name, FIGURE_MAX_NAME_LENGTH);
            break;
        case FIGURE_ENEMY_GREEK_SWORDSMAN:
        case FIGURE_ENEMY_GREEK_SPEAR_THROWER:
        case FIGURE_ENEMY_MACEDONIAN_SWORDSMAN:
        case FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER:
            string_copy(greek_names[rand() % 32], f->name, FIGURE_MAX_NAME_LENGTH);
            break;
        case FIGURE_INDIGENOUS_NATIVE:
        case FIGURE_NATIVE_TRADER:
        case FIGURE_ENEMY_BARBARIAN_SWORDSMAN:
        case FIGURE_ENEMY_BRITON_SWORDSMAN:
        case FIGURE_ENEMY_BRITON_CHARIOT:
        case FIGURE_ENEMY_CELT_SWORDSMAN:
        case FIGURE_ENEMY_CELT_CHARIOT:
        case FIGURE_ENEMY_PICT_SWORDSMAN:
        case FIGURE_ENEMY_PICT_CHARIOT:
        case FIGURE_ENEMY_GAUL_SWORDSMAN:
        case FIGURE_ENEMY_GAUL_AXEMAN:
        case FIGURE_ENEMY_HELVETIUS_SWORDSMAN:
        case FIGURE_ENEMY_HELVETIUS_AXEMAN:
        case FIGURE_ENEMY_HUN_SWORDSMAN:
        case FIGURE_ENEMY_HUN_MOUNTED_ARCHER:
        case FIGURE_ENEMY_GOTH_SWORDSMAN:
        case FIGURE_ENEMY_GOTH_MOUNTED_ARCHER:
        case FIGURE_ENEMY_VISIGOTH_SWORDSMAN:
        case FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER:
        case FIGURE_ENEMY_IBERIAN_SWORDSMAN:
        case FIGURE_ENEMY_IBERIAN_SPEAR_THROWER:
        case FIGURE_ENEMY_JUDEAN_SWORDSMAN:
        case FIGURE_ENEMY_JUDEAN_SPEAR_THROWER:
        case FIGURE_ENEMY_SELEUCID_SWORDSMAN:
        case FIGURE_ENEMY_SELEUCID_SPEAR_THROWER:
            string_copy(barbarian_names[rand() % 32], f->name, FIGURE_MAX_NAME_LENGTH);
            break;
        case FIGURE_SCHOOL_CHILD:
        case FIGURE_DELIVERY_BOY:
        case FIGURE_BARBER:
        default:
            string_copy(citizen_names[rand() % 64], f->name, FIGURE_MAX_NAME_LENGTH);
            break;
    }
    map_figure_add(f);
    if (type == FIGURE_TRADE_CARAVAN || type == FIGURE_TRADE_SHIP) {
        int trader_id = figure_trader_data.next_index++;
        if (figure_trader_data.next_index >= MAX_TRADERS) {
            figure_trader_data.next_index = 0;
        }
        memset(&figure_trader_data.traders[trader_id], 0, sizeof(struct trader));
        f->trader_id = trader_id;
    }
    return f;
}

static void figure_movement_set_cross_country_direction(struct figure_t *f, int x_src, int y_src, int x_dst, int y_dst, int is_missile)
{
    // all x/y are in 1/15th of a tile
    f->cc_destination_x = x_dst;
    f->cc_destination_y = y_dst;
    f->cc_delta_x = (x_src > x_dst) ? (x_src - x_dst) : (x_dst - x_src);
    f->cc_delta_y = (y_src > y_dst) ? (y_src - y_dst) : (y_dst - y_src);
    if (f->cc_delta_x < f->cc_delta_y) {
        f->cc_delta_xy = 2 * f->cc_delta_x - f->cc_delta_y;
    } else if (f->cc_delta_y < f->cc_delta_x) {
        f->cc_delta_xy = 2 * f->cc_delta_y - f->cc_delta_x;
    } else { // equal
        f->cc_delta_xy = 0;
    }
    if (is_missile) {
        int dx = x_src > x_dst ? x_src - x_dst : x_dst - x_src;
        int dy = y_src > y_dst ? y_src - y_dst : y_dst - y_src;
        int percentage;
        if (dx > dy) {
            percentage = calc_percentage(dx, dy);
        } else if (dx == dy) {
            percentage = 100;
        } else {
            percentage = -calc_percentage(dy, dx);
        }
        if (x_src == x_dst) {
            if (y_src < y_dst) {
                f->direction = 8;
            } else {
                f->direction = 0;
            }
        } else if (x_src > x_dst) {
            if (y_src == y_dst) {
                f->direction = 12;
            } else if (y_src > y_dst) {
                if (percentage >= 500) {
                    f->direction = 12;
                } else if (percentage >= 200) {
                    f->direction = 13;
                } else if (percentage > -200) {
                    f->direction = 14;
                } else if (percentage > -500) {
                    f->direction = 15;
                } else {
                    f->direction = 0;
                }
            } else {
                if (percentage >= 500) {
                    f->direction = 12;
                } else if (percentage >= 200) {
                    f->direction = 11;
                } else if (percentage > -200) {
                    f->direction = 10;
                } else if (percentage > -500) {
                    f->direction = 9;
                } else {
                    f->direction = 8;
                }
            }
        } else { // x_from < x_to
            if (y_src == y_dst) {
                f->direction = 4;
            } else if (y_src > y_dst) {
                if (percentage >= 500) {
                    f->direction = 4;
                } else if (percentage >= 200) {
                    f->direction = 3;
                } else if (percentage > -200) {
                    f->direction = 2;
                } else if (percentage > -500) {
                    f->direction = 1;
                } else {
                    f->direction = 0;
                }
            } else {
                if (percentage >= 500) {
                    f->direction = 4;
                } else if (percentage >= 200) {
                    f->direction = 5;
                } else if (percentage > -200) {
                    f->direction = 6;
                } else if (percentage > -500) {
                    f->direction = 7;
                } else {
                    f->direction = 8;
                }
            }
        }
    } else {
        f->direction = calc_general_direction(x_src, y_src, x_dst, y_dst);
        if (f->cc_delta_y > 2 * f->cc_delta_x) {
            switch (f->direction) {
                case DIR_1_TOP_RIGHT: case DIR_7_TOP_LEFT: f->direction = DIR_0_TOP; break;
                case DIR_3_BOTTOM_RIGHT: case DIR_5_BOTTOM_LEFT: f->direction = DIR_4_BOTTOM; break;
            }
        }
        if (f->cc_delta_x > 2 * f->cc_delta_y) {
            switch (f->direction) {
                case DIR_1_TOP_RIGHT: case DIR_3_BOTTOM_RIGHT: f->direction = DIR_2_RIGHT; break;
                case DIR_5_BOTTOM_LEFT: case DIR_7_TOP_LEFT: f->direction = DIR_6_LEFT; break;
            }
        }
    }
    if (f->cc_delta_x >= f->cc_delta_y) {
        f->cc_direction = 1;
    } else {
        f->cc_direction = 2;
    }
}

static void add_figure_to_formation(struct figure_t *f, struct formation_t *m)
{
    for (int i = 0; i < m->max_figures; i++) {
        if (!m->figures[i]) {
            m->figures[i] = f->id;
            m->num_figures++;
            f->index_in_formation = i;
            return;
        }
    }
}

static int figure_is_alive(struct figure_t *f)
{
    return f->in_use && !f->is_corpse;
}

static void map_figure_delete(struct figure_t *f)
{
    if (!map_grid_is_valid_offset(f->grid_offset) || !map_figures.items[f->grid_offset]) {
        f->next_figure_id_on_same_tile = 0;
        return;
    }

    if (map_figures.items[f->grid_offset] == f->id) {
        map_figures.items[f->grid_offset] = f->next_figure_id_on_same_tile;
    } else {
        struct figure_t *prev = &figures[map_figures.items[f->grid_offset]];
        while (prev->id && prev->next_figure_id_on_same_tile != f->id) {
            prev = &figures[prev->next_figure_id_on_same_tile];
        }
        prev->next_figure_id_on_same_tile = f->next_figure_id_on_same_tile;
    }
    f->next_figure_id_on_same_tile = 0;
}

static void figure_delete(struct figure_t *f)
{
    struct building_t *b = &all_buildings[f->building_id];
    switch (f->type) {
        case FIGURE_LABOR_SEEKER:
        case FIGURE_MARKET_BUYER:
            if (f->building_id) {
                b->figure_id2 = 0;
            }
            break;
        case FIGURE_BALLISTA:
            b->figure_id4 = 0;
            break;
        case FIGURE_DOCKER:
            for (int i = 0; i < 3; i++) {
                if (b->data.dock.docker_ids[i] == f->id) {
                    b->data.dock.docker_ids[i] = 0;
                }
            }
            break;
        default:
            if (f->building_id) {
                b->figure_id = 0;
            }
            break;
    }
    if (f->empire_city_id) {
        // remove trader
        for (int i = 0; i < 3; i++) {
            if (empire_objects[f->empire_city_id].trader_figure_ids[i] == f->id) {
                empire_objects[f->empire_city_id].trader_figure_ids[i] = 0;
            }
        }
    }
    if (f->immigrant_building_id) {
        b->immigrant_figure_id = 0;
    }
    struct formation_t *m = 0;
    // adjust unit-related counters
    if (figure_properties[f->type].is_player_legion_unit) {
        m = &legion_formations[f->formation_id];
        city_data.figure.soldiers--;
        if (f->type == FIGURE_FORT_LEGIONARY) {
            city_data.military.legionary_legions--;
        }
    } else if (f->type == FIGURE_RIOTER) {
        city_data.figure.rioters--;
    } else if (figure_properties[f->type].is_herd_animal) {
        m = &herd_formations[f->formation_id];
        city_data.figure.animals--;
    } else if (figure_properties[f->type].is_enemy_unit) {
        m = &enemy_formations[f->formation_id];
        city_data.figure.enemies--;
    } else if (figure_properties[f->type].is_caesar_legion_unit) {
        m = &enemy_formations[f->formation_id];
        city_data.figure.imperial_soldiers--;
        city_data.emperor.invasion.soldiers_killed++;
    }
    if (m) {  // refresh unit formation indexes and formation figures number
        for (int i = 0; i < m->num_figures; i++) {
            m->figures[i] = 0;
        }
        m->num_figures = 0;
        for (int i = 1; i < MAX_FIGURES; i++) {
            struct figure_t *unit = &figures[i];
            if (figure_is_alive(unit) && unit->type == m->figure_type && unit->formation_id == m->id) {
                for (int j = 0; j < m->max_figures; j++) {
                    if (!m->figures[j]) {
                        m->figures[j] = unit->id;
                        m->num_figures++;
                        unit->index_in_formation = j;
                        break;
                    }
                }
            }
        }
        if (!m->num_figures) { // non-legion formation empty, clear it
            if (figure_properties[f->type].is_herd_animal || figure_properties[f->type].is_enemy_unit || figure_properties[f->type].is_caesar_legion_unit) {
                memset(m, 0, sizeof(struct formation_t));
                m->id = f->formation_id;
            }
        }
    }
    figure_route_remove(f);
    map_figure_delete(f);
    int figure_id = f->id;
    memset(f, 0, sizeof(struct figure_t));
    f->id = figure_id;
}

static void figure_create_flotsam(void)
{
    if (scenario.river_entry_point.x == -1 || scenario.river_entry_point.y == -1 || scenario.river_exit_point.x == -1 || scenario.river_exit_point.y == -1 || !scenario.flotsam_enabled) {
        return;
    }
    for (int i = 1; i < MAX_FIGURES; i++) {
        struct figure_t *f = &figures[i];
        if (figure_is_alive(f) && f->type == FIGURE_FLOTSAM) {
            figure_delete(f);
        }
    }

    for (int i = 0; i < 20; i++) {
        struct figure_t *f = figure_create(FIGURE_FLOTSAM, scenario.river_entry_point.x, scenario.river_entry_point.y, DIR_0_TOP);
        f->terrain_usage = TERRAIN_USAGE_ANY;
        f->action_state = FIGURE_ACTION_FLOTSAM_CREATED;
        f->resource_id = FLOTSAM_RESOURCE_IDS[i];
        f->wait_ticks = FLOTSAM_WAIT_TICKS[i];
    }
}

static void map_routing_update_land_citizen(void)
{
    memset(terrain_land_citizen.items, -1, GRID_SIZE * GRID_SIZE * sizeof(int8_t));
    int grid_offset = map_data.start_offset;
    for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (terrain_grid.items[grid_offset] & TERRAIN_ROAD) {
                terrain_land_citizen.items[grid_offset] = CITIZEN_0_ROAD;
            } else if (terrain_grid.items[grid_offset] & (TERRAIN_RUBBLE | TERRAIN_ACCESS_RAMP | TERRAIN_GARDEN)) {
                terrain_land_citizen.items[grid_offset] = CITIZEN_2_PASSABLE_TERRAIN;
            } else if (terrain_grid.items[grid_offset] & (TERRAIN_BUILDING | TERRAIN_GATEHOUSE)) {
                if (!map_building_at(grid_offset)) {
                    // shouldn't happen
                    terrain_land_noncitizen.items[grid_offset] = CITIZEN_4_CLEAR_TERRAIN; // BUG: should be citizen?
                    terrain_grid.items[grid_offset] &= ~TERRAIN_BUILDING;
                    images.items[grid_offset] = (random.items[grid_offset] & 7) + 306;
                    edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
                    map_property_set_multi_tile_size(grid_offset, 1);
                    continue;
                }
                struct building_t *b = &all_buildings[map_building_at(grid_offset)];
                switch (b->type) {
                    case BUILDING_WAREHOUSE:
                    case BUILDING_GATEHOUSE:
                        terrain_land_citizen.items[grid_offset] = CITIZEN_0_ROAD;
                        break;
                    case BUILDING_FORT_GROUND:
                        terrain_land_citizen.items[grid_offset] = CITIZEN_2_PASSABLE_TERRAIN;
                        break;
                    case BUILDING_TRIUMPHAL_ARCH:
                        if (b->subtype.orientation == 3) {
                            switch (edge_grid.items[grid_offset] & EDGE_MASK_XY) {
                                case EDGE_X0Y1:
                                case EDGE_X1Y1:
                                case EDGE_X2Y1:
                                    terrain_land_citizen.items[grid_offset] = CITIZEN_0_ROAD;
                                    break;
                            }
                        } else {
                            switch (edge_grid.items[grid_offset] & EDGE_MASK_XY) {
                                case EDGE_X1Y0:
                                case EDGE_X1Y1:
                                case EDGE_X1Y2:
                                    terrain_land_citizen.items[grid_offset] = CITIZEN_0_ROAD;
                                    break;
                            }
                        }
                        break;
                    case BUILDING_GRANARY:
                        switch (edge_grid.items[grid_offset] & EDGE_MASK_XY) {
                            case EDGE_X1Y0:
                            case EDGE_X0Y1:
                            case EDGE_X1Y1:
                            case EDGE_X2Y1:
                            case EDGE_X1Y2:
                                terrain_land_citizen.items[grid_offset] = CITIZEN_0_ROAD;
                                break;
                        }
                        break;
                    case BUILDING_RESERVOIR:
                        switch (edge_grid.items[grid_offset] & EDGE_MASK_XY) {
                            case EDGE_X1Y0:
                            case EDGE_X0Y1:
                            case EDGE_X2Y1:
                            case EDGE_X1Y2:
                                terrain_land_citizen.items[grid_offset] = CITIZEN_N4_RESERVOIR_CONNECTOR; // aqueduct connect points
                                break;
                        }
                        break;
                    default:
                        terrain_land_citizen.items[grid_offset] = CITIZEN_N1_BLOCKED;
                        break;
                }
            } else if (terrain_grid.items[grid_offset] & TERRAIN_AQUEDUCT) {
                int image_id = images.items[grid_offset] - 666;
                if (image_id <= 3) {
                    terrain_land_citizen.items[grid_offset] = CITIZEN_N3_AQUEDUCT;
                } else if (image_id <= 7) {
                    terrain_land_citizen.items[grid_offset] = CITIZEN_N1_BLOCKED;
                } else if (image_id <= 9) {
                    terrain_land_citizen.items[grid_offset] = CITIZEN_N3_AQUEDUCT;
                } else if (image_id <= 14) {
                    terrain_land_citizen.items[grid_offset] = CITIZEN_N1_BLOCKED;
                } else if (image_id <= 18) {
                    terrain_land_citizen.items[grid_offset] = CITIZEN_N3_AQUEDUCT;
                } else if (image_id <= 22) {
                    terrain_land_citizen.items[grid_offset] = CITIZEN_N1_BLOCKED;
                } else if (image_id <= 24) {
                    terrain_land_citizen.items[grid_offset] = CITIZEN_N3_AQUEDUCT;
                } else {
                    terrain_land_citizen.items[grid_offset] = CITIZEN_N1_BLOCKED;
                }
            } else if (terrain_grid.items[grid_offset] & TERRAIN_NOT_CLEAR) {
                terrain_land_citizen.items[grid_offset] = CITIZEN_N1_BLOCKED;
            } else {
                terrain_land_citizen.items[grid_offset] = CITIZEN_4_CLEAR_TERRAIN;
            }
        }
    }
}

static void map_routing_update_land(void)
{
    map_routing_update_land_citizen();
    memset(terrain_land_noncitizen.items, -1, GRID_SIZE * GRID_SIZE * sizeof(int8_t));
    int grid_offset = map_data.start_offset;
    for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (terrain_grid.items[grid_offset] & TERRAIN_GATEHOUSE) {
                terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_4_GATEHOUSE;
            } else if (terrain_grid.items[grid_offset] & TERRAIN_ROAD) {
                terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_0_PASSABLE;
            } else if (terrain_grid.items[grid_offset] & (TERRAIN_GARDEN | TERRAIN_ACCESS_RAMP | TERRAIN_RUBBLE)) {
                terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_2_CLEARABLE;
            } else if (terrain_grid.items[grid_offset] & TERRAIN_BUILDING) {
                switch (all_buildings[map_building_at(grid_offset)].type) {
                    case BUILDING_WAREHOUSE:
                    case BUILDING_FORT_GROUND:
                        terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_0_PASSABLE;
                        break;
                    case BUILDING_BURNING_RUIN:
                    case BUILDING_NATIVE_HUT:
                    case BUILDING_NATIVE_MEETING:
                    case BUILDING_NATIVE_CROPS:
                        terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_N1_BLOCKED;
                        break;
                    case BUILDING_FORT_LEGIONARIES:
                    case BUILDING_FORT_JAVELIN:
                    case BUILDING_FORT_MOUNTED:
                        terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_5_FORT;
                        break;
                    case BUILDING_GRANARY:
                        switch (edge_grid.items[grid_offset] & EDGE_MASK_XY) {
                            case EDGE_X1Y0:
                            case EDGE_X0Y1:
                            case EDGE_X1Y1:
                            case EDGE_X2Y1:
                            case EDGE_X1Y2:
                                terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_0_PASSABLE;
                                break;
                        }
                        break;
                    default:
                        terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_1_BUILDING;
                        break;
                }
            } else if (terrain_grid.items[grid_offset] & TERRAIN_AQUEDUCT) {
                terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_2_CLEARABLE;
            } else if (terrain_grid.items[grid_offset] & TERRAIN_WALL) {
                terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_3_WALL;
            } else if (terrain_grid.items[grid_offset] & TERRAIN_NOT_CLEAR) {
                terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_N1_BLOCKED;
            } else {
                terrain_land_noncitizen.items[grid_offset] = NONCITIZEN_0_PASSABLE;
            }
        }
    }
}

static void map_routing_update_water(void)
{
    memset(terrain_water.items, -1, GRID_SIZE * GRID_SIZE * sizeof(int8_t));
    int grid_offset = map_data.start_offset;
    for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (map_terrain_is(grid_offset, TERRAIN_WATER)
            && map_terrain_is(grid_offset + map_grid_delta(0, -1), TERRAIN_WATER)
            && map_terrain_is(grid_offset + map_grid_delta(-1, 0), TERRAIN_WATER)
            && map_terrain_is(grid_offset + map_grid_delta(1, 0), TERRAIN_WATER)
            && map_terrain_is(grid_offset + map_grid_delta(0, 1), TERRAIN_WATER)) {
                if (x > 0 && x < map_data.width - 1 &&
                    y > 0 && y < map_data.height - 1) {
                    switch (sprite.items[grid_offset]) {
                        case 5:
                        case 6: // low bridge middle section
                            terrain_water.items[grid_offset] = WATER_N3_LOW_BRIDGE;
                            break;
                        case 13: // ship bridge pillar
                            terrain_water.items[grid_offset] = WATER_N1_BLOCKED;
                            break;
                        default:
                            terrain_water.items[grid_offset] = WATER_0_PASSABLE;
                            break;
                    }
                } else {
                    terrain_water.items[grid_offset] = WATER_N2_MAP_EDGE;
                }
            } else {
                terrain_water.items[grid_offset] = WATER_N1_BLOCKED;
            }
        }
    }
}

static int is_wall_tile(int grid_offset)
{
    return map_terrain_is(grid_offset, TERRAIN_WALL_OR_GATEHOUSE) ? 1 : 0;
}

static void map_routing_update_walls(void)
{
    memset(terrain_walls.items, -1, GRID_SIZE * GRID_SIZE * sizeof(int8_t));
    int grid_offset = map_data.start_offset;
    for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (map_terrain_is(grid_offset, TERRAIN_WALL)) {
                int adjacent_wall_tiles = 0;
                switch (view_data.orientation) {
                    case DIR_0_TOP:
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(0, 1));
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(1, 1));
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(1, 0));
                        break;
                    case DIR_2_RIGHT:
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(0, 1));
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(-1, 1));
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(-1, 0));
                        break;
                    case DIR_4_BOTTOM:
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(0, -1));
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(-1, -1));
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(-1, 0));
                        break;
                    case DIR_6_LEFT:
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(0, -1));
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(1, -1));
                        adjacent_wall_tiles += is_wall_tile(grid_offset + map_grid_delta(1, 0));
                        break;
                }
                if (adjacent_wall_tiles == 3) {
                    terrain_walls.items[grid_offset] = WALL_0_PASSABLE;
                } else {
                    terrain_walls.items[grid_offset] = WALL_N1_BLOCKED;
                }
            } else if (map_terrain_is(grid_offset, TERRAIN_GATEHOUSE)) {
                terrain_walls.items[grid_offset] = WALL_0_PASSABLE;
            } else {
                terrain_walls.items[grid_offset] = WALL_N1_BLOCKED;
            }
        }
    }
}

static void map_routing_update_all(void)
{
    map_routing_update_land();
    map_routing_update_water();
    map_routing_update_walls();
}

static void set_message_parameters(struct lang_message_t *m, char *title, char *text, int urgent, int message_type)
{
    m->type = TYPE_MESSAGE;
    m->message_type = message_type;
    m->x = 0;
    m->y = 0;
    m->width_blocks = 30;
    m->height_blocks = 20;
    m->title.x = 0;
    m->title.y = 0;
    m->urgent = urgent;
    m->title.text = title;
    m->content.text = text;
}

static void city_military_determine_distant_battle_city(void)
{
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        if (empire_objects[i].in_use && empire_objects[i].city_type == EMPIRE_CITY_VULNERABLE_ROMAN) {
            city_data.distant_battle.city = i;
        }
    }
}

static int read_file_into_buffer(char *filepath, void *buffer, int is_binary)
{
    if (is_binary) {
        fp = fopen(filepath, "rb");
    } else {
        fp = fopen(filepath, "r");
    }
    if (fp) {
        fseek(fp, 0, SEEK_END);
        long size = ftell(fp);
        fseek(fp, 0, SEEK_SET);
        int bytes_read = (int) fread(buffer, 1, (size_t) size, fp);
        fclose(fp);
        return bytes_read;
    }
    return 0;
}

static void read_index(struct buffer_t *buf, struct image_t *images, int size)
{
    for (int i = 0; i < size; i++) {
        images[i].draw.offset = buffer_read_i32(buf);
        images[i].draw.data_length = buffer_read_i32(buf);
        images[i].draw.uncompressed_length = buffer_read_i32(buf);
        buf->index += 8;
        images[i].width = buffer_read_u16(buf);
        images[i].height = buffer_read_u16(buf);
        buf->index += 6;
        images[i].num_animation_sprites = buffer_read_u16(buf);
        buf->index += 2;
        images[i].sprite_offset_x = buffer_read_i16(buf);
        images[i].sprite_offset_y = buffer_read_i16(buf);
        buf->index += 10;
        images[i].animation_can_reverse = buffer_read_i8(buf);
        buf->index += 1;
        images[i].draw.type = buffer_read_u8(buf);
        images[i].draw.is_fully_compressed = buffer_read_i8(buf);
        images[i].draw.is_external = buffer_read_i8(buf);
        images[i].draw.has_compressed_part = buffer_read_i8(buf);
        buf->index += 2;
        images[i].draw.bitmap_id = buffer_read_u8(buf);
        buf->index += 1;
        images[i].animation_speed_id = buffer_read_u8(buf);
        buf->index += 5;
    }
    int offset = 4;
    for (int i = 1; i < size; i++) {
        struct image_t *img = &images[i];
        if (img->draw.is_external) {
            if (!img->draw.offset) {
                img->draw.offset = 1;
            }
        } else {
            img->draw.offset = offset;
            offset += img->draw.data_length;
        }
    }
}

static void convert_images(struct image_t *images, int size, struct buffer_t *buf, uint32_t *dst)
{
    uint32_t *start_dst = dst;
    dst++; // make sure img->offset > 0
    for (int i = 0; i < size; i++) {
        struct image_t *img = &images[i];
        if (img->draw.is_external) {
            continue;
        }
        buf->index = img->draw.offset;
        int img_offset = (int) (dst - start_dst);
        if (img->draw.is_fully_compressed) {
            dst += convert_compressed(buf, img->draw.data_length, dst);
        } else if (img->draw.has_compressed_part) { // isometric tile
            dst += convert_uncompressed(buf, img->draw.uncompressed_length, dst);
            dst += convert_compressed(buf, img->draw.data_length - img->draw.uncompressed_length, dst);
        } else {
            dst += convert_uncompressed(buf, img->draw.data_length, dst);
        }
        img->draw.offset = img_offset;
        img->draw.uncompressed_length /= 2;
    }
}

static int load_main_graphics(int climate_id, int is_editor)
{
    if (climate_id == image_data_s.current_climate && is_editor == image_data_s.is_editor) {
        return 1;
    }
    char *filename_bmp = is_editor ? EDITOR_GRAPHICS_555[climate_id] : MAIN_GRAPHICS_555[climate_id];
    char *filename_idx = is_editor ? EDITOR_GRAPHICS_SG2[climate_id] : MAIN_GRAPHICS_SG2[climate_id];
    if (read_file_into_buffer(filename_idx, image_data_s.tmp_data, 1) != 660680) {
        return 0;
    }
    struct buffer_t buf;
    buffer_init(&buf, image_data_s.tmp_data, HEADER_SIZE_ENEMY_FILES);
    buf.index += 80; // header integers
    for (int i = 0; i < 300; i++) {
        image_data_s.group_image_ids[i] = buffer_read_u16(&buf);
    }
    buffer_read_raw(&buf, image_data_s.bitmaps, 20000);
    buffer_init(&buf, &image_data_s.tmp_data[HEADER_SIZE_ENEMY_FILES], ENTRY_SIZE * MAIN_ENTRIES);
    read_index(&buf, image_data_s.main, MAIN_ENTRIES);
    int data_size = read_file_into_buffer(filename_bmp, image_data_s.tmp_data, 1);
    if (!data_size) {
        return 0;
    }
    image_data_s.main_data = (uint32_t *) malloc(30000000);
    if (!image_data_s.main_data) {
        exit(2);
    }
    buffer_init(&buf, image_data_s.tmp_data, data_size);
    convert_images(image_data_s.main, MAIN_ENTRIES, &buf, image_data_s.main_data);
    image_data_s.current_climate = climate_id;
    image_data_s.is_editor = is_editor;
    return 1;
}

static void city_data_init_scenario(void)
{
    city_data.finance.treasury = scenario.initial_funds;
    city_data.finance.last_year.balance = city_data.finance.treasury;
}

static void city_emperor_set_salary_rank(int player_rank)
{
    city_data.emperor.salary_rank = player_rank;
    city_data.emperor.salary_amount = SALARY_FOR_RANK[player_rank];
}

static void map_submenu_items(int menu_index, int submenu_index, int submenu_string_index)
{
    build_menus[menu_index].menu_items[submenu_index].submenu_string = submenu_strings[submenu_string_index];
    for (int k = 0; k < MAX_ITEMS_PER_SUBMENU; k++) {
        if (scenario.allowed_buildings[BUILDING_MENU_SUBMENU_ITEM_MAPPING[menu_index][submenu_index][k]]) {
            build_menus[menu_index].is_enabled = 1;
            build_menus[menu_index].menu_items[submenu_index].building_id = -1; // submenu is enabled (negative number to avoid conflict with actual building types)
            build_menus[menu_index].menu_items[submenu_index].submenu_items[k] = BUILDING_MENU_SUBMENU_ITEM_MAPPING[menu_index][submenu_index][k];
        }
    }
}

static void map_building_menu_items(void)
{
    // reset values so as to not carry over between maps
    for (int i = 0; i < BUILD_MENU_BUTTONS_COUNT; i++) {
        memset(&build_menus[i], 0, sizeof(struct build_menu_t));
    }
    for (int i = 0; i < BUILD_MENU_BUTTONS_COUNT; i++) {
        for (int j = 0; j < MAX_ITEMS_PER_BUILD_MENU; j++) {
            if (i == 5 && j == 0) { // small temples
                map_submenu_items(i, j, 0);
            } else if (i == 5 && j == 1) { // large temples
                map_submenu_items(i, j, 1);
            } else if (i == 10 && j == 4) { // forts
                map_submenu_items(i, j, 2);
            } else if (i == 11 && j == 0) { // farms
                map_submenu_items(i, j, 3);
            } else if (i == 11 && j == 1) { // raw materials
                map_submenu_items(i, j, 4);
            } else if (i == 11 && j == 2) { // workshops
                map_submenu_items(i, j, 5);
            } else {
                if (scenario.allowed_buildings[BUILDING_MENU_SUBMENU_ITEM_MAPPING[i][j][0]] && BUILDING_MENU_SUBMENU_ITEM_MAPPING[i][j][0] != BUILDING_TRIUMPHAL_ARCH) {
                    build_menus[i].is_enabled = 1;
                    build_menus[i].menu_items[j].building_id = BUILDING_MENU_SUBMENU_ITEM_MAPPING[i][j][0];
                }
            }
        }
    }
}

static void building_construction_clear_type(void)
{
    set_cursor_shape(CURSOR_ARROW);
    construction_data.cost_preview = 0;
    construction_data.type = BUILDING_NONE;
}

static int game_file_start_scenario(char *scenario_selected)
{
    // assume scenario can be passed in with or without .map extension
    char scenario_file[FILE_NAME_LENGTH_MAX];
    string_copy(scenario_selected, scenario_file, FILE_NAME_LENGTH_MAX - 1);
    if (!file_has_extension(scenario_file, "map")) {
        file_append_extension(scenario_file, "map");

    }
    if (!file_exists(MAPS_DIR_PATH, scenario_file)) {
        return 0;
    }
    for (int i = 0; i < MAX_BOOKMARKS; i++) {
        bookmarks[i].x = -1;
        bookmarks[i].y = -1;
    }
    building_construction_clear_type();
    city_data_init();
    city_message_init_scenario();
    game_state_init();
    game_animation_init();
    initialize_city_sounds();
    building_clear_all();
    memset(storages, 0, MAX_STORAGES * sizeof(struct data_storage));
    figure_init_scenario();
    figure_name_init();
    reset_all_formations();
    figure_route_clear_all();
    game_time_init(2098);
    memset(images.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
    map_building_clear();
    memset(terrain_grid.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
    memset(aqueduct.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memset(map_figures.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
    map_property_clear();
    memset(sprite.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memset(random.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memset(desirability_grid.items, 0, GRID_SIZE * GRID_SIZE * sizeof(int8_t));
    memset(terrain_elevation.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memset(network.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    for (int i = 0; i < CONTEXT_MAX_ITEMS; i++) {
        clear_current_offset(context_pointers[i].context, context_pointers[i].size);
    }
    map_random_init();
    if (!game_file_load_scenario_data(scenario_file)) {
        return 0;
    }
    // reset trade prices
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        trade_prices[i] = DEFAULT_PRICES[i];
    }
    if (file_has_extension(scenario_file, "map")) {
        file_remove_extension(scenario_file);
    }
    string_copy(scenario_file, scenario.scenario_name, MAX_SCENARIO_NAME);
    map_grid_init(scenario.map.width, scenario.map.height, scenario.map.grid_start);
    map_tiles_update_all_elevation();
    map_tiles_update_all_earthquake();
    map_tiles_add_entry_exit_flags();
    map_tiles_update_all_empty_land();
    map_tiles_update_all_roads();
    map_tiles_update_all_plazas();
    map_tiles_update_all_walls();
    map_tiles_update_all_aqueducts(0);
    int meeting_center_set = 0;
    int native_image = 2827;
    int grid_offset = map_data.start_offset;
    for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (!map_terrain_is(grid_offset, TERRAIN_BUILDING) || map_building_at(grid_offset)) {
                continue;
            }
            int random_bit = random.items[grid_offset] & 1;
            int type;
            if (images.items[grid_offset] == scenario.native_images.hut) {
                type = BUILDING_NATIVE_HUT;
                images.items[grid_offset] = native_image;
            } else if (images.items[grid_offset] == scenario.native_images.hut + 1) {
                type = BUILDING_NATIVE_HUT;
                images.items[grid_offset] = native_image + 1;
            } else if (images.items[grid_offset] == scenario.native_images.meeting) {
                type = BUILDING_NATIVE_MEETING;
                images.items[grid_offset] = native_image + 2;
                images.items[grid_offset + map_grid_delta(1, 0)] = native_image + 2;
                images.items[grid_offset + map_grid_delta(0, 1)] = native_image + 2;
                images.items[grid_offset + map_grid_delta(1, 1)] = native_image + 2;
            } else if (images.items[grid_offset] == scenario.native_images.crops) {
                type = BUILDING_NATIVE_CROPS;
                images.items[grid_offset] = 2884 + random_bit;
            } else if (images.items[grid_offset] == 2823) {
                type = BUILDING_HOUSE_VACANT_LOT;
                images.items[grid_offset] = 2823;
            } else { //unknown building
                map_building_tiles_remove(0, x, y);
                continue;
            }
            struct building_t *b = building_create(type, x, y);
            buildings_grid.items[grid_offset] = b->id;
            b->state = BUILDING_STATE_IN_USE;
            switch (type) {
                case BUILDING_NATIVE_CROPS:
                    b->data.industry.progress = random_bit;
                    break;
                case BUILDING_NATIVE_MEETING:
                    b->sentiment.native_anger = 100;
                    buildings_grid.items[grid_offset + map_grid_delta(1, 0)] = b->id;
                    buildings_grid.items[grid_offset + map_grid_delta(0, 1)] = b->id;
                    buildings_grid.items[grid_offset + map_grid_delta(1, 1)] = b->id;
                    mark_native_land(b->x, b->y, 2, 6);
                    if (!meeting_center_set) {
                        city_data.building.main_native_meeting.x = b->x;
                        city_data.building.main_native_meeting.y = b->y;
                    }
                    break;
                case BUILDING_NATIVE_HUT:
                    b->sentiment.native_anger = 100;
                    b->figure_spawn_delay = random_bit;
                    mark_native_land(b->x, b->y, 1, 3);
                    break;
                case BUILDING_HOUSE_VACANT_LOT:
                    buildings_grid.items[grid_offset] = b->id;
                    break;
            }
        }
    }
    // gather list of meeting centers
    building_list_data.small.size = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_NATIVE_MEETING) {
            building_list_small_add(i);
        }
    }
    if (building_list_data.small.size <= 0) {
        // determine closest meeting center for hut
        for (int i = 1; i < MAX_BUILDINGS; i++) {
            struct building_t *b = &all_buildings[i];
            if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_NATIVE_HUT) {
                int min_dist = 1000;
                int min_meeting_id = 0;
                for (int n = 0; n < building_list_data.small.size; n++) {
                    struct building_t *meeting = &all_buildings[building_list_data.small.items[n]];
                    int dist = calc_maximum_distance(b->x, b->y, meeting->x, meeting->y);
                    if (dist < min_dist) {
                        min_dist = dist;
                        min_meeting_id = building_list_data.small.items[n];
                    }
                }
                b->subtype.native_meeting_center_id = min_meeting_id;
            }
        }
    }
    city_view_init();
    for (int i = 0; i < MAX_FISH_POINTS; i++) {
        if (scenario.fishing_points[i].x > 0) {
            random_generate_next();
            struct figure_t *fish = figure_create(FIGURE_FISH_GULLS, scenario.fishing_points[i].x, scenario.fishing_points[i].y, DIR_0_TOP);
            fish->terrain_usage = TERRAIN_USAGE_ANY;
            fish->image_offset = random_data.random1_7bit & 0x1f;
            fish->progress_on_tile = random_data.random1_7bit & 7;
            figure_movement_set_cross_country_direction(fish,
                fish->cross_country_x, fish->cross_country_y,
                15 * fish->destination_x, 15 * fish->destination_y, 0);
        }
    }
    for (int i = 0; i < MAX_HERD_POINTS; i++) {
        if (scenario.herd_points[i].x > -1) {
            int herd_type = FIGURE_NONE;
            int num_animals = 0;
            switch (scenario.climate) {
                case CLIMATE_NORTHERN:
                    herd_type = FIGURE_WOLF;
                    num_animals = WOLF_PACK_SIZE;
                    break;
                case CLIMATE_CENTRAL:
                    herd_type = FIGURE_SHEEP;
                    num_animals = SHEEP_HERD_SIZE;
                    break;
                case CLIMATE_DESERT:
                    herd_type = FIGURE_ZEBRA;
                    num_animals = ZEBRA_HERD_SIZE;
                    break;
                default:
                    break;
            }
            // create herd formation
            struct formation_t *m = &herd_formations[i];
            m->in_use = 1;
            m->figure_type = herd_type;
            m->max_figures = num_animals;
            m->wait_ticks_movement = 24;
            // create animal figures and assign to formation
            for (int fig = 0; fig < num_animals; fig++) {
                struct figure_t *f = figure_create(herd_type,
                    scenario.herd_points[i].x + HERD_FORMATION_LAYOUT_POSITION_X_OFFSETS[fig],
                    scenario.herd_points[i].y + HERD_FORMATION_LAYOUT_POSITION_Y_OFFSETS[fig],
                    DIR_0_TOP);
                f->is_targetable = 1;
                f->terrain_usage = TERRAIN_USAGE_ANIMAL;
                f->action_state = FIGURE_ACTION_HERD_ANIMAL_AT_REST;
                f->formation_id = m->id;
                add_figure_to_formation(f, m);
                city_data.figure.animals++;
            }
        }
    }
    figure_create_flotsam();
    map_routing_update_all();
    if (scenario.entry_point.x == -1 || scenario.entry_point.y == -1) {
        scenario.entry_point.x = scenario.map.width - 1;
        scenario.entry_point.y = scenario.map.height / 2;
    }
    if (scenario.exit_point.x == -1 || scenario.exit_point.y == -1) {
        scenario.exit_point.x = scenario.entry_point.x;
        scenario.exit_point.y = scenario.entry_point.y;
    }
    game_time_init(scenario.start_year);
    int i = 321;
    while (i < MAX_MESSAGE_ENTRIES) {
        if (!lang_data.message_entries[i].content.text) {
            break;
        }
        i++;
    }
    if (i >= MAX_MESSAGE_ENTRIES) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Message entry max exceeded", "", 0));
        return 0;
    }
    // distant battle won but triumphal arch disabled from the editor
    set_message_parameters(&lang_data.message_entries[i], "Roman city saved", "Your relief force defeated the invading barbarians. Caesar is pleased.", 0, MESSAGE_TYPE_GENERAL);
    lang_data.message_entries[i].video.text = "smk/army_win.smk";
    i += 1;
    // editor custom messages
    for (int j = 0; j < MAX_EDITOR_CUSTOM_MESSAGES; j++) {
        if (scenario.editor_custom_messages[j].enabled) {
            lang_data.message_entries[i].type = TYPE_MESSAGE;
            lang_data.message_entries[i].message_type = MESSAGE_TYPE_GENERAL;
            lang_data.message_entries[i].x = 0;
            lang_data.message_entries[i].y = 0;
            lang_data.message_entries[i].width_blocks = 30;
            lang_data.message_entries[i].height_blocks = 20;
            lang_data.message_entries[i].title.x = 0;
            lang_data.message_entries[i].title.y = 0;
            lang_data.message_entries[i].urgent = scenario.editor_custom_messages[j].urgent;
            lang_data.message_entries[i].title.text = scenario.editor_custom_messages[j].title;
            lang_data.message_entries[i].content.text = scenario.editor_custom_messages[j].text;
            lang_data.message_entries[i].video.text = scenario.editor_custom_messages[j].video_file;
            i += 1;
        }
    }
    memset(&figure_trader_data, 0, sizeof(figure_trader_data));
    city_military_determine_distant_battle_city();
    load_main_graphics(scenario.climate, 0);
    city_data_init_scenario();
    state_data.paused = 0;
    string_copy(configs_player_name, scenario_settings.player_name, MAX_PLAYER_NAME_LENGTH);
    city_data.ratings.favor = scenario.initial_favor;
    city_data.emperor.personal_savings = scenario.initial_personal_savings;
    city_data.emperor.player_rank = scenario.player_rank;
    city_emperor_set_salary_rank(city_data.emperor.player_rank);
    map_building_menu_items();
    city_message_init_scenario();
    return 1;
}

static int text_draw_multiline(char *str, int x_offset, int y_offset, int box_width, int font, uint32_t color)
{
    int line_height = DEFINITIONS_DEFAULT[font].line_height;
    if (line_height < 11) {
        line_height = 11;
    }
    int has_more_characters = 1;
    int guard = 0;
    int y = y_offset;
    while (has_more_characters) {
        char tmp_line_text[200] = { 0 };
        if (++guard >= 100) {
            break;
        }
        int current_width = 0;
        int line_index = 0;
        while (has_more_characters && current_width < box_width) {
            int word_num_chars;
            struct font_definition_t *def = &DEFINITIONS_DEFAULT[font];
            int width = 0;
            int guard2 = 0;
            int word_char_seen = 0;
            int num_chars = 0;
            char *str_ptr = str;
            while (*str_ptr && ++guard2 < 200) {
                if (*str_ptr == ' ' || *str_ptr == '\n') {
                    if (word_char_seen) {
                        break;
                    }
                    width += def->space_width;
                } else if (*str_ptr == '$') {
                    if (word_char_seen) {
                        break;
                    }
                } else if (*str_ptr > ' ') {
                    // normal char
                    int letter_id = font_letter_id(def, str_ptr);
                    if (letter_id >= 0) {
                        width += image_letter(letter_id)->width + def->letter_spacing;
                    }
                    word_char_seen = 1;
                }
                str_ptr++;
                num_chars++;
            }
            word_num_chars = num_chars;
            current_width += width;
            if (current_width >= box_width) {
                if (current_width == 0) {
                    has_more_characters = 0;
                }
            } else {
                for (int i = 0; i < word_num_chars; i++) {
                    if (line_index == 0 && *str <= ' ') {
                        str++; // skip whitespace at start of line
                    } else {
                        tmp_line_text[line_index++] = *str++;
                    }
                }
                if (!*str) {
                    has_more_characters = 0;
                } else if (*str == '\n') {
                    str++;
                    break;
                }
            }
        }
        text_draw(tmp_line_text, x_offset, y, font, color);
        y += line_height + 5;
    }
    return y - y_offset;
}

static int lang_text_draw_multiline(int group, int number, int x_offset, int y_offset, int box_width, int font)
{
    char *str = lang_get_string(group, number);
    return text_draw_multiline(str, x_offset, y_offset, box_width, font, 0);
}

static void draw_image_button(int button_base_img_id, int button_x, int button_y, int button_width, int button_height, int button_press_id)
{
    if (current_window_image_button_pressed == button_press_id) {
        image_draw(button_base_img_id + 2, button_x, button_y);
    } else if (!is_dragging_scroll && mouse_x >= button_x && mouse_x < button_x + button_width && mouse_y >= button_y && mouse_y < button_y + button_height) {
        image_draw(button_base_img_id + 1, button_x, button_y);
    } else {
        image_draw(button_base_img_id, button_x, button_y);
    }
}

static struct buffer_t *create_savegame_piece(int size)
{
    struct file_piece_t *piece = &savegame_data.pieces[savegame_data.num_pieces++];
    init_file_piece(piece, size);
    return &piece->buf;
}

static void init_savegame_data(void)
{
    if (savegame_data.num_pieces > 0) {
        for (int i = 0; i < savegame_data.num_pieces; i++) {
            buffer_reset(&savegame_data.pieces[i].buf);
        }
        return;
    }
    struct savegame_state_t *state = &savegame_data.state;
    state->image_grid = create_savegame_piece(52488);
    state->edge_grid = create_savegame_piece(26244);
    state->building_grid = create_savegame_piece(52488);
    state->terrain_grid = create_savegame_piece(78732);
    state->aqueduct_grid = create_savegame_piece(26244);
    state->figure_grid = create_savegame_piece(52488);
    state->bitfields_grid = create_savegame_piece(26244);
    state->sprite_grid = create_savegame_piece(26244);
    state->random_grid = create_savegame_piece(26244);
    state->desirability_grid = create_savegame_piece(26244);
    state->building_damage_grid = create_savegame_piece(26244);
    state->aqueduct_backup_grid = create_savegame_piece(26244);
    state->sprite_backup_grid = create_savegame_piece(26244);
    state->figures = create_savegame_piece(180000);
    state->route_figures = create_savegame_piece(1200);
    state->route_paths = create_savegame_piece(300000);
    state->legion_formations = create_savegame_piece(420);
    state->herd_formations = create_savegame_piece(560);
    state->enemy_formations = create_savegame_piece(7000);
    state->city_data = create_savegame_piece(11551);
    state->player_name = create_savegame_piece(24);
    state->buildings = create_savegame_piece(154000);
    state->city_view_orientation = create_savegame_piece(4);
    state->game_time = create_savegame_piece(20);
    state->building_extra_highest_id_ever = create_savegame_piece(4);
    state->random_iv = create_savegame_piece(8);
    state->city_view_camera = create_savegame_piece(8);
    state->building_count_culture1 = create_savegame_piece(132);
    state->city_graph_order = create_savegame_piece(4);
    state->empire = create_savegame_piece(8);
    state->empire_objects = create_savegame_piece(20600);
    state->building_count_industry = create_savegame_piece(128);
    state->trade_prices = create_savegame_piece(64);
    state->figure_names = create_savegame_piece(76);
    state->culture_coverage = create_savegame_piece(56);
    state->scenario = create_savegame_piece(52425);
    state->messages = create_savegame_piece(14000);
    state->message_extra = create_savegame_piece(12);
    state->population_messages = create_savegame_piece(9);
    state->message_counts = create_savegame_piece(80);
    state->message_delays = create_savegame_piece(80);
    state->building_list_burning_totals = create_savegame_piece(8);
    state->city_sounds = create_savegame_piece(3920);
    state->building_extra_highest_id = create_savegame_piece(4);
    state->figure_traders = create_savegame_piece(4004);
    state->building_list_burning = create_savegame_piece(1000);
    state->building_list_small = create_savegame_piece(1000);
    state->building_list_large = create_savegame_piece(4000);
    state->building_count_military = create_savegame_piece(16);
    state->building_storages = create_savegame_piece(4400);
    state->building_count_culture2 = create_savegame_piece(32);
    state->building_count_support = create_savegame_piece(24);
    state->building_barracks_tower_sentry = create_savegame_piece(4);
    state->building_extra_sequence = create_savegame_piece(4);
    state->routing_counters = create_savegame_piece(8);
    state->building_count_culture3 = create_savegame_piece(40);
    state->building_extra_corrupt_houses = create_savegame_piece(8);
    state->bookmarks = create_savegame_piece(32);
}

static void buffer_write_raw(struct buffer_t *buf, void *value, int size)
{
    if (check_size(buf, size)) {
        memcpy(&buf->data[buf->index], value, size);
        buf->index += size;
    }
}

static void buffer_write_u16(struct buffer_t *buf, uint16_t value)
{
    if (check_size(buf, 2)) {
        buf->data[buf->index++] = value & 0xff;
        buf->data[buf->index++] = (value >> 8) & 0xff;
    }
}

static void map_image_save_state(struct buffer_t *buf)
{
    for (int i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        buffer_write_u16(buf, images.items[i]);
    }
}

static int is_industry_type(struct building_t *b)
{
    return b->output_resource_id || b->type == BUILDING_NATIVE_CROPS
        || b->type == BUILDING_SHIPYARD || b->type == BUILDING_WHARF;
}

static void map_terrain_save_state(struct buffer_t *buf)
{
    for (int i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        buffer_write_u16(buf, terrain_grid.items[i]);
    }
    buffer_write_raw(buf, terrain_elevation.items, GRID_SIZE * GRID_SIZE);
}

static void map_property_save_state(struct buffer_t *bitfields, struct buffer_t *edge)
{
    buffer_write_raw(bitfields, bitfields_grid.items, GRID_SIZE * GRID_SIZE);
    buffer_write_raw(edge, edge_grid.items, GRID_SIZE * GRID_SIZE);
}

static void buffer_write_u8(struct buffer_t *buf, uint8_t value)
{
    if (check_size(buf, 1)) {
        buf->data[buf->index++] = value;
    }
}

static void formation_save_state(struct buffer_t *buf, struct formation_t *m)
{
    buffer_write_u8(buf, m->in_use);
    buffer_write_u8(buf, m->layout);
    buffer_write_u8(buf, m->figure_type);
    buffer_write_u8(buf, m->num_figures);
    buffer_write_u8(buf, m->max_figures);
    for (int fig = 0; fig < MAX_FORMATION_FIGURES; fig++) {
        buffer_write_u16(buf, m->figures[fig]);
    }
    buffer_write_u8(buf, m->has_military_training);
    buffer_write_u8(buf, m->is_at_rest);
    buffer_write_u8(buf, m->deployed_duration_months);
    buffer_write_u8(buf, m->direction);
    buffer_write_u8(buf, m->morale);
    buffer_write_u8(buf, m->max_morale);
    buffer_write_u8(buf, m->routed);
    buffer_write_i16(buf, m->wait_ticks_movement);
    buffer_write_u16(buf, m->standard_x);
    buffer_write_u16(buf, m->standard_y);
    buffer_write_u16(buf, m->prev_standard_x);
    buffer_write_u16(buf, m->prev_standard_y);
    buffer_write_u16(buf, m->legion_standard__figure_id);
    buffer_write_u16(buf, m->building_id);
    buffer_write_u8(buf, m->empire_service);
    buffer_write_u8(buf, m->in_distant_battle);
    buffer_write_u8(buf, m->cursed_by_mars);
    buffer_write_u8(buf, m->recent_fight);
    buffer_write_u8(buf, m->missile_attack_timeout);
    buffer_write_u16(buf, m->destination_x);
    buffer_write_u16(buf, m->destination_y);
    buffer_write_u16(buf, m->wolf_spawn_delay);
    buffer_write_u8(buf, m->attack_priority);
}

static void buffer_write_u32(struct buffer_t *buf, uint32_t value)
{
    if (check_size(buf, 4)) {
        buf->data[buf->index++] = value & 0xff;
        buf->data[buf->index++] = (value >> 8) & 0xff;
        buf->data[buf->index++] = (value >> 16) & 0xff;
        buf->data[buf->index++] = (value >> 24) & 0xff;
    }
}

static void random_save_state(struct buffer_t *buf)
{
    buffer_write_u32(buf, random_data.iv1);
    buffer_write_u32(buf, random_data.iv2);
}

static void empire_object_save_state(struct buffer_t *buf)
{
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        // initialize extra fields
        if (empire_objects[i].in_use && empire_objects[i].type == EMPIRE_OBJECT_CITY) {
            // determine trade route type
            for (int j = 0; j < MAX_EMPIRE_OBJECTS; j++) {
                if (empire_objects[j].type == EMPIRE_OBJECT_SEA_TRADE_ROUTE
                && empire_objects[j].in_use
                && empire_objects[j].trade_route_id == empire_objects[i].trade_route_id) {
                    empire_objects[i].is_sea_trade = 1;
                }
            }
            empire_objects[i].trader_entry_delay = empire_objects[i].is_sea_trade ? 30 : 4;
        }
        buffer_write_u8(buf, empire_objects[i].type);
        buffer_write_i16(buf, empire_objects[i].x);
        buffer_write_i16(buf, empire_objects[i].y);
        buffer_write_i16(buf, empire_objects[i].image_id);
        buffer_write_i16(buf, empire_objects[i].expanded.x);
        buffer_write_i16(buf, empire_objects[i].expanded.y);
        buffer_write_i16(buf, empire_objects[i].expanded.image_id);
        buffer_write_i16(buf, empire_objects[i].width);
        buffer_write_i16(buf, empire_objects[i].height);
        buffer_write_u8(buf, empire_objects[i].animation_index);
        buffer_write_u8(buf, empire_objects[i].in_use);
        buffer_write_u8(buf, empire_objects[i].city_type);
        buffer_write_u8(buf, empire_objects[i].city_name_id);
        buffer_write_u8(buf, empire_objects[i].trade_route_id);
        buffer_write_u8(buf, empire_objects[i].trade_route_open);
        buffer_write_u32(buf, empire_objects[i].trade_route_cost);
        buffer_write_i16(buf, empire_objects[i].trader_entry_delay);
        buffer_write_u8(buf, empire_objects[i].is_sea_trade);
        for (int f = 0; f < 3; f++) {
            buffer_write_i16(buf, empire_objects[i].trader_figure_ids[f]);
        }
        for (int r = 0; r < RESOURCE_TYPES_MAX; r++) {
            buffer_write_u8(buf, empire_objects[i].resource_buy_limit[r]);
            buffer_write_u8(buf, empire_objects[i].resource_sell_limit[r]);
            buffer_write_u8(buf, empire_objects[i].resource_bought[r]);
            buffer_write_u8(buf, empire_objects[i].resource_sold[r]);
        }
        buffer_write_u8(buf, empire_objects[i].invasion_path_id);
        buffer_write_u8(buf, empire_objects[i].invasion_years);
        buffer_write_u8(buf, empire_objects[i].distant_battle_travel_months);
    }
}

static void scenario_save_state(struct buffer_t *buf)
{
    buffer_write_u16(buf, scenario.map.width);
    buffer_write_u16(buf, scenario.map.height);
    buffer_write_u16(buf, scenario.map.grid_start);
    buffer_write_u8(buf, scenario.empire.id);
    buffer_write_u8(buf, scenario.empire.is_expanded);
    buffer_write_u16(buf, scenario.empire.expansion_year);
    buffer_write_u8(buf, scenario.empire.distant_battle_roman_travel_months);
    buffer_write_u8(buf, scenario.empire.distant_battle_enemy_travel_months);
    // Map name
    buffer_write_raw(buf, scenario.scenario_name, MAX_SCENARIO_NAME);
    // Brief description
    buffer_write_raw(buf, scenario.brief_description, MAX_BRIEF_DESCRIPTION_LENGTH);
    buffer_write_u16(buf, scenario.brief_description_image_id);
    // Scenario description
    buffer_write_raw(buf, scenario.briefing, MAX_BRIEFING_LENGTH);
    // Terrain set
    buffer_write_u8(buf, scenario.climate);
    // Starting conditions
    buffer_write_u8(buf, scenario.player_rank);
    buffer_write_i16(buf, scenario.start_year);
    buffer_write_u8(buf, scenario.initial_favor);
    buffer_write_i32(buf, scenario.initial_funds);
    buffer_write_i32(buf, scenario.rescue_loan);
    buffer_write_i32(buf, scenario.initial_personal_savings);
    buffer_write_u8(buf, scenario.rome_supplies_wheat);
    buffer_write_u8(buf, scenario.flotsam_enabled);
    // Win criteria
    buffer_write_i32(buf, scenario.population_win_criteria);
    buffer_write_i16(buf, scenario.culture_win_criteria);
    buffer_write_i16(buf, scenario.prosperity_win_criteria);
    buffer_write_i16(buf, scenario.peace_win_criteria);
    buffer_write_i16(buf, scenario.favor_win_criteria);
    buffer_write_i16(buf, scenario.time_limit_win_criteria);
    buffer_write_i16(buf, scenario.survival_time_win_criteria);
    // Buildings allowed
    for (int i = 0; i < BUILDING_TYPE_MAX; i++) {
        buffer_write_u8(buf, scenario.allowed_buildings[i]);
    }
    // Special events
    buffer_write_u8(buf, scenario.gladiator_revolt.state);
    buffer_write_i8(buf, scenario.gladiator_revolt.month);
    buffer_write_i16(buf, scenario.gladiator_revolt.year_offset);
    // random events
    buffer_write_u8(buf, scenario.random_events.sea_trade_problem);
    buffer_write_u8(buf, scenario.random_events.land_trade_problem);
    buffer_write_u8(buf, scenario.random_events.raise_wages);
    buffer_write_u8(buf, scenario.random_events.lower_wages);
    buffer_write_u8(buf, scenario.random_events.contaminated_water);
    // Requests
    for (int i = 0; i < MAX_REQUESTS; i++) {
        buffer_write_i16(buf, scenario.requests[i].year_offset);
        buffer_write_u8(buf, scenario.requests[i].month);
        buffer_write_u16(buf, scenario.requests[i].amount);
        buffer_write_u8(buf, scenario.requests[i].resource);
        buffer_write_u16(buf, scenario.requests[i].years_deadline);
        buffer_write_u8(buf, scenario.requests[i].favor);
        buffer_write_u8(buf, scenario.requests[i].state);
        buffer_write_u8(buf, scenario.requests[i].visible);
        buffer_write_u16(buf, scenario.requests[i].months_to_comply);
        buffer_write_u8(buf, scenario.requests[i].can_comply_dialog_shown);
    }
    // Custom messages
    for (int i = 0; i < MAX_EDITOR_CUSTOM_MESSAGES; i++) {
        buffer_write_u16(buf, scenario.editor_custom_messages[i].year_offset);
        buffer_write_u8(buf, scenario.editor_custom_messages[i].month);
        buffer_write_u8(buf, scenario.editor_custom_messages[i].urgent);
        buffer_write_u8(buf, scenario.editor_custom_messages[i].enabled);
        buffer_write_raw(buf, scenario.editor_custom_messages[i].title, MAX_CUSTOM_MESSAGE_TITLE);
        buffer_write_raw(buf, scenario.editor_custom_messages[i].text, MAX_CUSTOM_MESSAGE_TEXT);
        buffer_write_raw(buf, scenario.editor_custom_messages[i].video_file, MAX_CUSTOM_MESSAGE_VIDEO_TEXT);
    }
    // Earthquakes
    for (int i = 0; i < MAX_EARTHQUAKES; i++) {
        // link earthquake events to corresponding map points; leave a gap at the epicenter to prevent total map block-off and allow for more interesting building patterns
        scenario.earthquakes[i].branch_coordinates[0].x = scenario.earthquake_points[scenario.earthquakes[i].point].x;
        scenario.earthquakes[i].branch_coordinates[0].y = scenario.earthquake_points[scenario.earthquakes[i].point].y - 2;
        scenario.earthquakes[i].branch_coordinates[1].x = scenario.earthquake_points[scenario.earthquakes[i].point].x + 2;
        scenario.earthquakes[i].branch_coordinates[1].y = scenario.earthquake_points[scenario.earthquakes[i].point].y;
        scenario.earthquakes[i].branch_coordinates[2].x = scenario.earthquake_points[scenario.earthquakes[i].point].x;
        scenario.earthquakes[i].branch_coordinates[2].y = scenario.earthquake_points[scenario.earthquakes[i].point].y + 2;
        scenario.earthquakes[i].branch_coordinates[3].x = scenario.earthquake_points[scenario.earthquakes[i].point].x - 2;
        scenario.earthquakes[i].branch_coordinates[3].y = scenario.earthquake_points[scenario.earthquakes[i].point].y;
        buffer_write_u8(buf, scenario.earthquakes[i].state);
        buffer_write_u8(buf, scenario.earthquakes[i].severity);
        buffer_write_u8(buf, scenario.earthquakes[i].month);
        buffer_write_u16(buf, scenario.earthquakes[i].year_offset);
        buffer_write_u16(buf, scenario.earthquakes[i].duration);
        buffer_write_u16(buf, scenario.earthquakes[i].max_duration);
        buffer_write_u8(buf, scenario.earthquakes[i].delay);
        buffer_write_u8(buf, scenario.earthquakes[i].max_delay);
        buffer_write_u8(buf, scenario.earthquakes[i].point);
        for (int j = 0; j < MAX_EARTHQUAKE_BRANCHES; j++) {
            buffer_write_i32(buf, scenario.earthquakes[i].branch_coordinates[j].x);
            buffer_write_i32(buf, scenario.earthquakes[i].branch_coordinates[j].y);
        }
    }
    // Invasions
    for (int i = 0; i < MAX_INVASIONS; i++) {
        buffer_write_u16(buf, scenario.invasions[i].year_offset);
        buffer_write_u8(buf, scenario.invasions[i].month);
        buffer_write_u16(buf, scenario.invasions[i].amount);
        buffer_write_u8(buf, scenario.invasions[i].type);
        buffer_write_u8(buf, scenario.invasions[i].enemy_type);
        buffer_write_u8(buf, scenario.invasions[i].from);
        buffer_write_u8(buf, scenario.invasions[i].target_type);
    }
    buffer_write_u8(buf, scenario.invasion_upcoming);
    // Price changes
    for (int i = 0; i < MAX_PRICE_CHANGES; i++) {
        buffer_write_u16(buf, scenario.price_changes[i].year_offset);
        buffer_write_u8(buf, scenario.price_changes[i].month);
        buffer_write_u8(buf, scenario.price_changes[i].resource);
        buffer_write_u8(buf, scenario.price_changes[i].is_rise);
        buffer_write_u8(buf, scenario.price_changes[i].amount);
    }
    // Demand changes
    for (int i = 0; i < MAX_DEMAND_CHANGES; i++) {
        buffer_write_u16(buf, scenario.demand_changes[i].year_offset);
        buffer_write_u8(buf, scenario.demand_changes[i].month);
        buffer_write_u8(buf, scenario.demand_changes[i].resource);
        buffer_write_u8(buf, scenario.demand_changes[i].trade_city_id);
        buffer_write_u8(buf, scenario.demand_changes[i].is_rise);
    }
    // Earthquake points
    for (int i = 0; i < MAX_EARTHQUAKE_POINTS; i++) {
        buffer_write_i16(buf, scenario.earthquake_points[i].x);
        buffer_write_i16(buf, scenario.earthquake_points[i].y);
    }
    // Invasion points
    for (int i = 0; i < MAX_INVASION_POINTS; i++) {
        buffer_write_i16(buf, scenario.invasion_points[i].x);
        buffer_write_i16(buf, scenario.invasion_points[i].y);
    }
    // Entry/exit points
    buffer_write_i16(buf, scenario.entry_point.x);
    buffer_write_i16(buf, scenario.entry_point.y);
    buffer_write_i16(buf, scenario.exit_point.x);
    buffer_write_i16(buf, scenario.exit_point.y);
    // River entry/exit points
    buffer_write_i16(buf, scenario.river_entry_point.x);
    buffer_write_i16(buf, scenario.river_entry_point.y);
    buffer_write_i16(buf, scenario.river_exit_point.x);
    buffer_write_i16(buf, scenario.river_exit_point.y);
    // Buildings
    buffer_write_u32(buf, scenario.native_images.hut);
    buffer_write_u32(buf, scenario.native_images.meeting);
    buffer_write_u32(buf, scenario.native_images.crops);
    buffer_write_u32(buf, scenario.native_images.vacant_lots);
    // Fishing points
    for (int i = 0; i < MAX_FISH_POINTS; i++) {
        buffer_write_i16(buf, scenario.fishing_points[i].x);
        buffer_write_i16(buf, scenario.fishing_points[i].y);
    }
    // Herd points
    for (int i = 0; i < MAX_HERD_POINTS; i++) {
        buffer_write_i16(buf, scenario.herd_points[i].x);
        buffer_write_i16(buf, scenario.herd_points[i].y);
    }
}

static int game_file_io_write_saved_game(char *dir, char *filename)
{
    init_savegame_data();
    SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Saving game", filename, 0));
    buffer_write_raw(savegame_data.state.player_name, scenario_settings.player_name, MAX_PLAYER_NAME_LENGTH);
    map_image_save_state(savegame_data.state.image_grid);
    for (int i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        buffer_write_u16(savegame_data.state.building_grid, buildings_grid.items[i]);
    }
    buffer_write_raw(savegame_data.state.building_damage_grid, damage_grid.items, GRID_SIZE * GRID_SIZE);
    map_terrain_save_state(savegame_data.state.terrain_grid);
    buffer_write_raw(savegame_data.state.aqueduct_grid, aqueduct.items, GRID_SIZE * GRID_SIZE);
    buffer_write_raw(savegame_data.state.aqueduct_backup_grid, aqueduct_backup.items, GRID_SIZE * GRID_SIZE);
    for (int i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
        buffer_write_u16(savegame_data.state.figure_grid, map_figures.items[i]);
    }
    buffer_write_raw(savegame_data.state.sprite_grid, sprite.items, GRID_SIZE * GRID_SIZE);
    buffer_write_raw(savegame_data.state.sprite_backup_grid, sprite_backup.items, GRID_SIZE * GRID_SIZE);
    map_property_save_state(savegame_data.state.bitfields_grid, savegame_data.state.edge_grid);
    buffer_write_raw(savegame_data.state.random_grid, random.items, GRID_SIZE * GRID_SIZE);
    buffer_write_raw(savegame_data.state.desirability_grid, desirability_grid.items, GRID_SIZE * GRID_SIZE);
    for (int i = 0; i < MAX_FIGURES; i++) {
        buffer_write_u8(savegame_data.state.figures, figures[i].in_use);
        buffer_write_u8(savegame_data.state.figures, figures[i].is_targetable);
        buffer_write_u8(savegame_data.state.figures, figures[i].is_corpse);
        buffer_write_u8(savegame_data.state.figures, figures[i].type);
        buffer_write_u8(savegame_data.state.figures, figures[i].action_state);
        buffer_write_u8(savegame_data.state.figures, figures[i].is_fleeing);
        buffer_write_u8(savegame_data.state.figures, figures[i].formation_id);
        buffer_write_u8(savegame_data.state.figures, figures[i].index_in_formation);
        buffer_write_u8(savegame_data.state.figures, figures[i].damage);
        buffer_write_u8(savegame_data.state.figures, figures[i].is_military_trained);
        buffer_write_u8(savegame_data.state.figures, figures[i].mounted_charge_ticks);
        buffer_write_u8(savegame_data.state.figures, figures[i].mounted_charge_ticks_max);
        buffer_write_u16(savegame_data.state.figures, figures[i].target_figure_id);
        for (int j = 0; j < MAX_MELEE_TARGETERS_PER_UNIT; j++) {
            buffer_write_u16(savegame_data.state.figures, figures[j].melee_targeter_ids[j]);
        }
        for (int j = 0; j < MAX_MELEE_COMBATANTS_PER_UNIT; j++) {
            buffer_write_u16(savegame_data.state.figures, figures[j].melee_combatant_ids[j]);
        }
        buffer_write_u8(savegame_data.state.figures, figures[i].num_melee_combatants);
        for (int j = 0; j < MAX_RANGED_TARGETERS_PER_UNIT; j++) {
            buffer_write_u16(savegame_data.state.figures, figures[j].ranged_targeter_ids[j]);
        }
        buffer_write_u8(savegame_data.state.figures, figures[i].prefect_recent_guard_duty);
        buffer_write_i8(savegame_data.state.figures, figures[i].attack_direction);
        buffer_write_u8(savegame_data.state.figures, figures[i].engaged_in_combat);
        buffer_write_i8(savegame_data.state.figures, figures[i].source_x);
        buffer_write_i8(savegame_data.state.figures, figures[i].source_y);
        buffer_write_u16(savegame_data.state.figures, figures[i].routing_path_id);
        buffer_write_u16(savegame_data.state.figures, figures[i].routing_path_current_tile);
        buffer_write_u16(savegame_data.state.figures, figures[i].routing_path_length);
        buffer_write_u8(savegame_data.state.figures, figures[i].terrain_usage);
        buffer_write_u8(savegame_data.state.figures, figures[i].speed_multiplier);
        buffer_write_i8(savegame_data.state.figures, figures[i].previous_tile_direction);
        buffer_write_i8(savegame_data.state.figures, figures[i].previous_tile_x);
        buffer_write_i8(savegame_data.state.figures, figures[i].previous_tile_y);
        buffer_write_i8(savegame_data.state.figures, figures[i].direction);
        buffer_write_u8(savegame_data.state.figures, figures[i].progress_on_tile);
        buffer_write_i16(savegame_data.state.figures, figures[i].x);
        buffer_write_i16(savegame_data.state.figures, figures[i].y);
        buffer_write_u16(savegame_data.state.figures, figures[i].grid_offset);
        buffer_write_i16(savegame_data.state.figures, figures[i].destination_x);
        buffer_write_i16(savegame_data.state.figures, figures[i].destination_y);
        buffer_write_u16(savegame_data.state.figures, figures[i].destination_grid_offset);
        buffer_write_u16(savegame_data.state.figures, figures[i].destination_building_id);
        buffer_write_u8(savegame_data.state.figures, figures[i].figure_is_halted);
        buffer_write_u8(savegame_data.state.figures, figures[i].use_cross_country);
        buffer_write_u8(savegame_data.state.figures, figures[i].cc_direction);
        buffer_write_u16(savegame_data.state.figures, figures[i].cross_country_x);
        buffer_write_u16(savegame_data.state.figures, figures[i].cross_country_y);
        buffer_write_i16(savegame_data.state.figures, figures[i].cc_delta_x);
        buffer_write_i16(savegame_data.state.figures, figures[i].cc_delta_y);
        buffer_write_i16(savegame_data.state.figures, figures[i].cc_delta_xy);
        buffer_write_u16(savegame_data.state.figures, figures[i].cc_destination_x);
        buffer_write_u16(savegame_data.state.figures, figures[i].cc_destination_y);
        buffer_write_u8(savegame_data.state.figures, figures[i].missile_offset);
        buffer_write_u16(savegame_data.state.figures, figures[i].roam_length);
        buffer_write_u8(savegame_data.state.figures, figures[i].roam_choose_destination);
        buffer_write_u8(savegame_data.state.figures, figures[i].roam_random_counter);
        buffer_write_i8(savegame_data.state.figures, figures[i].roam_turn_direction);
        buffer_write_i8(savegame_data.state.figures, figures[i].roam_ticks_until_next_turn);
        buffer_write_u8(savegame_data.state.figures, figures[i].in_building_wait_ticks);
        buffer_write_u8(savegame_data.state.figures, figures[i].height_adjusted_ticks);
        buffer_write_u8(savegame_data.state.figures, figures[i].current_height);
        buffer_write_u8(savegame_data.state.figures, figures[i].target_height);
        buffer_write_u16(savegame_data.state.figures, figures[i].next_figure_id_on_same_tile);
        buffer_write_u16(savegame_data.state.figures, figures[i].image_id);
        buffer_write_u8(savegame_data.state.figures, figures[i].image_offset);
        buffer_write_u8(savegame_data.state.figures, figures[i].attack_image_offset);
        buffer_write_u8(savegame_data.state.figures, figures[i].is_shooting);
        buffer_write_u16(savegame_data.state.figures, figures[i].cart_image_id);
        buffer_write_i8(savegame_data.state.figures, figures[i].x_offset_cart);
        buffer_write_i8(savegame_data.state.figures, figures[i].y_offset_cart);
        buffer_write_u8(savegame_data.state.figures, figures[i].enemy_image_group);
        buffer_write_i16(savegame_data.state.figures, figures[i].wait_ticks);
        buffer_write_u8(savegame_data.state.figures, figures[i].wait_ticks_missile);
        buffer_write_raw(savegame_data.state.figures, figures[i].name, FIGURE_MAX_NAME_LENGTH);
        buffer_write_u8(savegame_data.state.figures, figures[i].is_invisible);
        buffer_write_u16(savegame_data.state.figures, figures[i].building_id);
        buffer_write_u16(savegame_data.state.figures, figures[i].immigrant_building_id);
        buffer_write_u8(savegame_data.state.figures, figures[i].migrant_num_people);
        buffer_write_u8(savegame_data.state.figures, figures[i].min_max_seen);
        buffer_write_u8(savegame_data.state.figures, figures[i].empire_city_id);
        buffer_write_u8(savegame_data.state.figures, figures[i].resource_id);
        buffer_write_u8(savegame_data.state.figures, figures[i].collecting_item_id);
        buffer_write_u8(savegame_data.state.figures, figures[i].trader_id);
        buffer_write_u16(savegame_data.state.figures, figures[i].leading_figure_id);
        buffer_write_u8(savegame_data.state.figures, figures[i].trader_amount_bought);
        buffer_write_u8(savegame_data.state.figures, figures[i].loads_sold_or_carrying);
        buffer_write_u8(savegame_data.state.figures, figures[i].trade_ship_failed_dock_attempts);
        buffer_write_u8(savegame_data.state.figures, figures[i].flotsam_visible);
    }
    for (int i = 0; i < MAX_ROUTES; i++) {
        buffer_write_i16(savegame_data.state.route_figures, figure_route_data.figure_ids[i]);
        buffer_write_raw(savegame_data.state.route_paths, figure_route_data.direction_paths[i], MAX_PATH_LENGTH);
    }
    for (int i = 0; i < MAX_LEGIONS; i++) {
        formation_save_state(savegame_data.state.legion_formations, &legion_formations[i]);
    }
    for (int i = 0; i < MAX_HERD_POINTS; i++) {
        formation_save_state(savegame_data.state.herd_formations, &herd_formations[i]);
    }
    for (int i = 0; i < MAX_ENEMY_FORMATIONS; i++) {
        formation_save_state(savegame_data.state.enemy_formations, &enemy_formations[i]);
    }
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.tax_percentage);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.treasury);
    buffer_write_i32(savegame_data.state.city_data, city_data.sentiment.value);
    buffer_write_i32(savegame_data.state.city_data, city_data.health.target_value);
    buffer_write_i32(savegame_data.state.city_data, city_data.health.value);
    buffer_write_i32(savegame_data.state.city_data, city_data.health.num_hospital_workers);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.population);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.population_last_year);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.school_age);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.academy_age);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.total_capacity);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.room_in_houses);
    for (int i = 0; i < 2400; i++) {
        buffer_write_i32(savegame_data.state.city_data, city_data.population.monthly.values[i]);
    }
    buffer_write_i32(savegame_data.state.city_data, city_data.population.monthly.next_index);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.monthly.count);
    for (int i = 0; i < 100; i++) {
        buffer_write_i16(savegame_data.state.city_data, city_data.population.at_age[i]);
    }
    for (int i = 0; i < 20; i++) {
        buffer_write_i32(savegame_data.state.city_data, city_data.population.at_level[i]);
    }
    buffer_write_i32(savegame_data.state.city_data, city_data.population.yearly_births);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.yearly_deaths);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.lost_removal);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.immigration_amount_per_batch);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.emigration_amount_per_batch);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.emigration_queue_size);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.immigration_queue_size);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.lost_homeless);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.last_change);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.average_per_year);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.total_all_years);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.people_in_tents_shacks);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.people_in_villas_palaces);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.total_years);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.yearly_update_requested);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.last_used_house_add);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.last_used_house_remove);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.immigrated_today);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.emigrated_today);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.refused_immigrants_today);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.percentage);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.immigration_duration);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.emigration_duration);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.newcomers);
    buffer_write_i16(savegame_data.state.city_data, city_data.resource.last_used_warehouse);
    buffer_write_u8(savegame_data.state.city_data, city_data.building.senate_x);
    buffer_write_u8(savegame_data.state.city_data, city_data.building.senate_y);
    buffer_write_i16(savegame_data.state.city_data, city_data.building.senate_grid_offset);
    buffer_write_i32(savegame_data.state.city_data, city_data.building.senate_building_id);
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        buffer_write_i16(savegame_data.state.city_data, city_data.resource.space_in_warehouses[i]);
    }
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        buffer_write_u16(savegame_data.state.city_data, city_data.resource.stored_in_warehouses[i]);
    }
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        buffer_write_i16(savegame_data.state.city_data, city_data.resource.trade_status[i]);
    }
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        buffer_write_i16(savegame_data.state.city_data, city_data.resource.export_over[i]);
    }
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        buffer_write_i16(savegame_data.state.city_data, city_data.resource.mothballed[i]);
    }
    for (int i = 0; i < FOOD_TYPES_MAX; i++) {
        buffer_write_i32(savegame_data.state.city_data, city_data.resource.granary_food_stored[i]);
    }
    for (int i = 0; i < 6; i++) {
        buffer_write_i32(savegame_data.state.city_data, city_data.resource.stored_in_workshops[i]);
    }
    for (int i = 0; i < 6; i++) {
        buffer_write_i32(savegame_data.state.city_data, city_data.resource.space_in_workshops[i]);
    }
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.granary_total_stored);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.food_types_available);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.food_types_eaten);
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        buffer_write_i32(savegame_data.state.city_data, city_data.resource.stockpiled[i]);
    }
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.food_supply_months);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.granaries.operating);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.percentage_plebs);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.working_age);
    buffer_write_i32(savegame_data.state.city_data, city_data.labor.workers_available);
    for (int i = 0; i < 10; i++) {
        buffer_write_i32(savegame_data.state.city_data, city_data.labor.categories[i].workers_needed);
        buffer_write_i32(savegame_data.state.city_data, city_data.labor.categories[i].workers_allocated);
        buffer_write_i32(savegame_data.state.city_data, city_data.labor.categories[i].total_houses_covered);
        buffer_write_i32(savegame_data.state.city_data, city_data.labor.categories[i].buildings);
        buffer_write_i32(savegame_data.state.city_data, city_data.labor.categories[i].priority);
    }
    buffer_write_i32(savegame_data.state.city_data, city_data.labor.workers_employed);
    buffer_write_i32(savegame_data.state.city_data, city_data.labor.workers_unemployed);
    buffer_write_i32(savegame_data.state.city_data, city_data.labor.unemployment_percentage);
    buffer_write_i32(savegame_data.state.city_data, city_data.labor.unemployment_percentage_for_senate);
    buffer_write_i32(savegame_data.state.city_data, city_data.labor.workers_needed);
    buffer_write_i32(savegame_data.state.city_data, city_data.labor.wages);
    buffer_write_i32(savegame_data.state.city_data, city_data.labor.wages_rome);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.wages_so_far);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.expenses.wages);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.expenses.wages);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.taxed_plebs);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.taxed_patricians);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.untaxed_plebs);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.untaxed_patricians);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.percentage_taxed_plebs);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.percentage_taxed_patricians);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.percentage_taxed_people);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.yearly.collected_plebs);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.yearly.collected_patricians);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.yearly.uncollected_plebs);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.yearly.uncollected_patricians);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.income.taxes);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.income.taxes);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.monthly.collected_plebs);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.monthly.uncollected_plebs);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.monthly.collected_patricians);
    buffer_write_i32(savegame_data.state.city_data, city_data.taxes.monthly.uncollected_patricians);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.income.exports);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.income.exports);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.expenses.imports);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.expenses.imports);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.interest_so_far);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.expenses.interest);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.expenses.interest);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.expenses.sundries);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.expenses.sundries);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.expenses.construction);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.expenses.construction);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.expenses.salary);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.expenses.salary);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.salary_amount);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.salary_rank);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.salary_so_far);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.income.total);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.income.total);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.expenses.total);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.expenses.total);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.net_in_out);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.net_in_out);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.balance);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.balance);
    buffer_write_i32(savegame_data.state.city_data, city_data.trade.caravan_import_resource);
    buffer_write_i32(savegame_data.state.city_data, city_data.trade.caravan_backup_import_resource);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.culture);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.prosperity);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.peace);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.favor);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.prosperity_treasury_last_year);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.peace_num_criminals);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.peace_num_rioters);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.fountain);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.well);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.more_entertainment);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.more_education);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.education);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.requiring.school);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.requiring.library);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.barber);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.bathhouse);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.food);
    buffer_write_i32(savegame_data.state.city_data, city_data.building.hippodrome_placed);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.clinic);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.hospital);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.requiring.barber);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.requiring.bathhouse);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.requiring.clinic);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.religion);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.second_religion);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.third_religion);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.requiring.religion);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.theater_shows);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.theater_no_shows_weighted);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.amphitheater_shows);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.amphitheater_no_shows_weighted);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.colosseum_shows);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.colosseum_no_shows_weighted);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.hippodrome_shows);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.hippodrome_no_shows_weighted);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.venue_needing_shows);
    buffer_write_i32(savegame_data.state.city_data, city_data.culture.average_entertainment);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.entertainment);
    buffer_write_i32(savegame_data.state.city_data, city_data.festival.months_since_festival);
    for (int i = 0; i < MAX_GODS; i++) {
        buffer_write_i8(savegame_data.state.city_data, city_data.religion.gods[i].target_happiness);
    }
    for (int i = 0; i < MAX_GODS; i++) {
        buffer_write_i8(savegame_data.state.city_data, city_data.religion.gods[i].happiness);
    }
    for (int i = 0; i < MAX_GODS; i++) {
        buffer_write_i8(savegame_data.state.city_data, city_data.religion.gods[i].wrath_bolts);
    }
    for (int i = 0; i < MAX_GODS; i++) {
        buffer_write_i8(savegame_data.state.city_data, city_data.religion.gods[i].blessing_done);
    }
    for (int i = 0; i < MAX_GODS; i++) {
        buffer_write_i8(savegame_data.state.city_data, city_data.religion.gods[i].small_curse_done);
    }
    for (int i = 0; i < MAX_GODS; i++) {
        buffer_write_i32(savegame_data.state.city_data, city_data.religion.gods[i].months_since_festival);
    }
    buffer_write_i32(savegame_data.state.city_data, city_data.religion.least_happy_god);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.no_immigration_cause);
    buffer_write_i32(savegame_data.state.city_data, city_data.sentiment.protesters);
    buffer_write_i32(savegame_data.state.city_data, city_data.sentiment.criminals);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.health);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.religion);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.education);
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.entertainment);
    buffer_write_i32(savegame_data.state.city_data, city_data.figure.rioters);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.selected);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.culture_explanation);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.prosperity_explanation);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.peace_explanation);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.favor_explanation);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.player_rank);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.personal_savings);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.income.donated);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.income.donated);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.donate_amount);
    for (int i = 0; i < 10; i++) {
        buffer_write_i16(savegame_data.state.city_data, city_data.building.working_dock_ids[i]);
    }
    buffer_write_i16(savegame_data.state.city_data, city_data.figure.animals);
    buffer_write_i16(savegame_data.state.city_data, city_data.trade.num_sea_routes);
    buffer_write_i16(savegame_data.state.city_data, city_data.trade.num_land_routes);
    buffer_write_i16(savegame_data.state.city_data, city_data.trade.sea_trade_problem_duration);
    buffer_write_i16(savegame_data.state.city_data, city_data.trade.land_trade_problem_duration);
    buffer_write_i16(savegame_data.state.city_data, city_data.building.working_docks);
    buffer_write_i16(savegame_data.state.city_data, city_data.building.senate_placed);
    buffer_write_i16(savegame_data.state.city_data, city_data.building.working_wharfs);
    buffer_write_i16(savegame_data.state.city_data, city_data.finance.stolen_this_year);
    buffer_write_i16(savegame_data.state.city_data, city_data.finance.stolen_last_year);
    buffer_write_i32(savegame_data.state.city_data, city_data.trade.docker_import_resource);
    buffer_write_i32(savegame_data.state.city_data, city_data.trade.docker_export_resource);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.debt_state);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.months_in_debt);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.cheated_money);
    buffer_write_i8(savegame_data.state.city_data, city_data.building.barracks_x);
    buffer_write_i8(savegame_data.state.city_data, city_data.building.barracks_y);
    buffer_write_i16(savegame_data.state.city_data, city_data.building.barracks_grid_offset);
    buffer_write_i32(savegame_data.state.city_data, city_data.building.barracks_building_id);
    buffer_write_i32(savegame_data.state.city_data, city_data.building.barracks_placed);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.lost_troop_request);
    buffer_write_i32(savegame_data.state.city_data, city_data.mission.has_won);
    buffer_write_i32(savegame_data.state.city_data, city_data.mission.continue_months_left);
    buffer_write_i32(savegame_data.state.city_data, city_data.mission.continue_months_chosen);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.wage_rate_paid_this_year);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.this_year.expenses.tribute);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.last_year.expenses.tribute);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.tribute_not_paid_last_year);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.tribute_not_paid_total_years);
    buffer_write_i8(savegame_data.state.city_data, city_data.festival.queued);
    buffer_write_i8(savegame_data.state.city_data, city_data.festival.god);
    buffer_write_i8(savegame_data.state.city_data, city_data.festival.size);
    buffer_write_i32(savegame_data.state.city_data, city_data.festival.months_to_go);
    buffer_write_i32(savegame_data.state.city_data, city_data.culture.average_religion);
    buffer_write_i32(savegame_data.state.city_data, city_data.culture.average_education);
    buffer_write_i32(savegame_data.state.city_data, city_data.culture.average_health);
    buffer_write_i32(savegame_data.state.city_data, city_data.culture.religion_coverage);
    buffer_write_i32(savegame_data.state.city_data, city_data.festival.first_festival_effect_months);
    buffer_write_i32(savegame_data.state.city_data, city_data.festival.second_festival_effect_months);
    buffer_write_i32(savegame_data.state.city_data, city_data.sentiment.previous_value);
    buffer_write_i32(savegame_data.state.city_data, city_data.sentiment.message_delay);
    buffer_write_i32(savegame_data.state.city_data, city_data.sentiment.low_mood_cause);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.months_since_gift);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.gift_overdose_penalty);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.gifts[GIFT_MODEST].id);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.gifts[GIFT_GENEROUS].id);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.gifts[GIFT_LAVISH].id);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.gifts[GIFT_MODEST].cost);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.gifts[GIFT_GENEROUS].cost);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.gifts[GIFT_LAVISH].cost);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.favor_salary_penalty);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.favor_ignored_request_penalty);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.favor_last_year);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.favor_change);
    buffer_write_i32(savegame_data.state.city_data, city_data.military.native_attack_duration);
    buffer_write_i32(savegame_data.state.city_data, city_data.building.mission_post_operational);
    buffer_write_i32(savegame_data.state.city_data, city_data.building.main_native_meeting.x);
    buffer_write_i32(savegame_data.state.city_data, city_data.building.main_native_meeting.y);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.wage_rate_paid_last_year);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.food_needed_per_month);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.granaries.understaffed);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.granaries.not_operating);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.granaries.not_operating_with_food);
    buffer_write_i32(savegame_data.state.city_data, city_data.religion.venus_curse_active);
    buffer_write_i32(savegame_data.state.city_data, city_data.religion.neptune_double_trade_active);
    buffer_write_i32(savegame_data.state.city_data, city_data.religion.mars_spirit_power);
    buffer_write_i32(savegame_data.state.city_data, city_data.religion.angry_message_delay);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.food_consumed_last_month);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.food_produced_last_month);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.food_produced_this_month);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.peace_riot_cause);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.estimated_tax_income);
    buffer_write_i32(savegame_data.state.city_data, city_data.building.shipyard_boats_requested);
    buffer_write_i32(savegame_data.state.city_data, city_data.figure.enemies);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.people_in_tents);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.people_in_large_insula_and_above);
    buffer_write_i32(savegame_data.state.city_data, city_data.figure.imperial_soldiers);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.invasion.duration_day_countdown);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.invasion.warnings_given);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.invasion.days_until_invasion);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.invasion.retreat_message_shown);
    buffer_write_i16(savegame_data.state.city_data, city_data.emperor.invasion.from_editor);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.peace_destroyed_buildings);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.peace_years_of_peace);
    buffer_write_u8(savegame_data.state.city_data, city_data.distant_battle.city);
    buffer_write_u8(savegame_data.state.city_data, city_data.distant_battle.enemy_strength);
    buffer_write_u8(savegame_data.state.city_data, city_data.distant_battle.roman_strength);
    buffer_write_i8(savegame_data.state.city_data, city_data.distant_battle.months_until_battle);
    buffer_write_i8(savegame_data.state.city_data, city_data.distant_battle.roman_months_to_travel_back);
    buffer_write_i8(savegame_data.state.city_data, city_data.distant_battle.roman_months_to_travel_forth);
    buffer_write_i8(savegame_data.state.city_data, city_data.distant_battle.city_foreign_months_left);
    buffer_write_i8(savegame_data.state.city_data, city_data.building.triumphal_arches_available);
    buffer_write_i8(savegame_data.state.city_data, city_data.distant_battle.total_count);
    buffer_write_i8(savegame_data.state.city_data, city_data.distant_battle.won_count);
    buffer_write_i8(savegame_data.state.city_data, city_data.distant_battle.enemy_months_traveled);
    buffer_write_i8(savegame_data.state.city_data, city_data.distant_battle.roman_months_traveled);
    buffer_write_u8(savegame_data.state.city_data, city_data.military.total_legions);
    buffer_write_u8(savegame_data.state.city_data, city_data.sound.die_citizen);
    buffer_write_u8(savegame_data.state.city_data, city_data.sound.die_soldier);
    buffer_write_i32(savegame_data.state.city_data, city_data.building.trade_center_building_id);
    buffer_write_i32(savegame_data.state.city_data, city_data.figure.soldiers);
    buffer_write_u8(savegame_data.state.city_data, city_data.sound.hit_elephant);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.invasion.count);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.invasion.size);
    buffer_write_i32(savegame_data.state.city_data, city_data.emperor.invasion.soldiers_killed);
    buffer_write_i32(savegame_data.state.city_data, city_data.military.legionary_legions);
    buffer_write_i32(savegame_data.state.city_data, city_data.population.highest_ever);
    buffer_write_i32(savegame_data.state.city_data, city_data.finance.estimated_wages);
    buffer_write_i32(savegame_data.state.city_data, city_data.resource.wine_types_available);
    buffer_write_i32(savegame_data.state.city_data, city_data.ratings.prosperity_max);
    for (int i = 0; i < 10; i++) {
        buffer_write_i32(savegame_data.state.city_data, city_data.map.largest_road_networks[i].id);
        buffer_write_i32(savegame_data.state.city_data, city_data.map.largest_road_networks[i].size);
    }
    buffer_write_i32(savegame_data.state.city_data, city_data.houses.missing.second_wine);
    buffer_write_i32(savegame_data.state.city_data, city_data.religion.neptune_sank_ships);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.hippodrome_has_race);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.hippodrome_message_shown);
    buffer_write_i32(savegame_data.state.city_data, city_data.entertainment.colosseum_message_shown);
    buffer_write_i32(savegame_data.state.city_data, city_data.migration.emigration_message_shown);
    buffer_write_i32(savegame_data.state.city_data, city_data.mission.fired_message_shown);
    buffer_write_i32(savegame_data.state.city_data, city_data.mission.victory_message_shown);
    buffer_write_i32(savegame_data.state.city_graph_order, city_data.population.graph_order);
    for (int i = 0; i < MAX_BUILDINGS; i++) {
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].state);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].size);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].house_is_merged);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].house_size);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].x);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].y);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].grid_offset);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].type);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].subtype.house_level); // which union field we use does not matter
        buffer_write_u16(savegame_data.state.buildings, all_buildings[i].created_sequence);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].houses_covered);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].percentage_houses_covered);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].house_population);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].house_population_room);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].house_highest_population);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].road_access_x);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].road_access_y);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].figure_id);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].figure_id2);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].immigrant_figure_id);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].figure_id4);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].figure_spawn_delay);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].figure_roam_direction);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].has_water_access);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].prev_part_building_id);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].next_part_building_id);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].loads_stored);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].has_well_access);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].num_workers);
        buffer_write_i8(savegame_data.state.buildings, all_buildings[i].labor_category);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].output_resource_id);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].has_road_access);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].house_criminal_active);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].damage_risk);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].fire_risk);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].fire_duration);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].fire_proof);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].house_figure_generation_delay);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].house_tax_coverage);
        buffer_write_i16(savegame_data.state.buildings, all_buildings[i].formation_id);
        if (building_is_house(all_buildings[i].type)) {
            for (int j = 0; j < INVENTORY_MAX; j++) {
                buffer_write_i16(savegame_data.state.buildings, all_buildings[j].data.house.inventory[j]);
            }
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.theater);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.amphitheater_actor);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.amphitheater_gladiator);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.colosseum_gladiator);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.colosseum_lion);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.hippodrome);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.school);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.library);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.academy);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.barber);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.clinic);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.bathhouse);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.hospital);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.temple_ceres);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.temple_neptune);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.temple_mercury);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.temple_mars);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.temple_venus);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.no_space_to_expand);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.num_foods);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.entertainment);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.education);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.health);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.num_gods);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.devolve_delay);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.house.evolve_text_id);
        } else if (all_buildings[i].type == BUILDING_MARKET) {
            for (int j = 0; j < INVENTORY_MAX; j++) {
                buffer_write_i16(savegame_data.state.buildings, all_buildings[j].data.market.inventory[j]);
            }
            buffer_write_i16(savegame_data.state.buildings, all_buildings[i].data.market.pottery_demand);
            buffer_write_i16(savegame_data.state.buildings, all_buildings[i].data.market.furniture_demand);
            buffer_write_i16(savegame_data.state.buildings, all_buildings[i].data.market.oil_demand);
            buffer_write_i16(savegame_data.state.buildings, all_buildings[i].data.market.wine_demand);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.market.fetch_inventory_id);
        } else if (all_buildings[i].type == BUILDING_GRANARY) {
            for (int j = 0; j < RESOURCE_TYPES_MAX; j++) {
                buffer_write_i16(savegame_data.state.buildings, all_buildings[j].data.granary.resource_stored[j]);
            }
        } else if (all_buildings[i].type == BUILDING_DOCK) {
            buffer_write_i16(savegame_data.state.buildings, all_buildings[i].data.dock.queued_docker_id);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.dock.num_ships);
            buffer_write_i8(savegame_data.state.buildings, all_buildings[i].data.dock.orientation);
            for (int j = 0; j < 3; j++) {
                buffer_write_i16(savegame_data.state.buildings, all_buildings[j].data.dock.docker_ids[j]);
            }
            buffer_write_i16(savegame_data.state.buildings, all_buildings[i].data.dock.trade_ship_id);
        } else if (is_industry_type(&all_buildings[i])) {
            buffer_write_i16(savegame_data.state.buildings, all_buildings[i].data.industry.progress);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.industry.has_fish);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.industry.blessing_days_left);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.industry.orientation);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.industry.has_raw_materials);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.industry.curse_days_left);
            buffer_write_i16(savegame_data.state.buildings, all_buildings[i].data.industry.fishing_boat_id);
        } else {
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.entertainment.num_shows);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.entertainment.days1);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.entertainment.days2);
            buffer_write_u8(savegame_data.state.buildings, all_buildings[i].data.entertainment.play);
        }
        buffer_write_i32(savegame_data.state.buildings, all_buildings[i].tax_income_or_storage);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].house_days_without_food);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].ruin_has_plague);
        buffer_write_i8(savegame_data.state.buildings, all_buildings[i].desirability);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].is_deleted);
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].storage_id);
        buffer_write_i8(savegame_data.state.buildings, all_buildings[i].sentiment.house_happiness); // which union field we use does not matter
        buffer_write_u8(savegame_data.state.buildings, all_buildings[i].show_on_problem_overlay);
    }
    buffer_write_i32(savegame_data.state.building_extra_highest_id, extra.highest_id_in_use);
    buffer_write_i32(savegame_data.state.building_extra_highest_id_ever, extra.highest_id_ever);
    buffer_write_i32(savegame_data.state.building_extra_sequence, extra.created_sequence);
    buffer_write_i32(savegame_data.state.building_extra_corrupt_houses, extra.incorrect_houses);
    buffer_write_i32(savegame_data.state.building_extra_corrupt_houses, extra.unfixable_houses);
    buffer_write_i32(savegame_data.state.building_barracks_tower_sentry, tower_sentry_request);
    buffer_write_i32(savegame_data.state.city_view_orientation, view_data.orientation);
    buffer_write_i32(savegame_data.state.city_view_camera, view_data.camera.tile.x);
    buffer_write_i32(savegame_data.state.city_view_camera, view_data.camera.tile.y);
    buffer_write_i32(savegame_data.state.game_time, time_data.tick);
    buffer_write_i32(savegame_data.state.game_time, time_data.day);
    buffer_write_i32(savegame_data.state.game_time, time_data.month);
    buffer_write_i32(savegame_data.state.game_time, time_data.year);
    buffer_write_i32(savegame_data.state.game_time, time_data.total_days);
    random_save_state(savegame_data.state.random_iv);
    // industry
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        buffer_write_i32(savegame_data.state.building_count_industry, count_data.industry[i].total);
    }
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        buffer_write_i32(savegame_data.state.building_count_industry, count_data.industry[i].active);
    }
    // culture 1
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_THEATER].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_THEATER].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_AMPHITHEATER].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_AMPHITHEATER].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_COLOSSEUM].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_COLOSSEUM].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_HIPPODROME].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_HIPPODROME].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_SCHOOL].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_SCHOOL].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_LIBRARY].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_LIBRARY].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_ACADEMY].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_ACADEMY].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_BARBER].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_BARBER].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_BATHHOUSE].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_BATHHOUSE].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_DOCTOR].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_DOCTOR].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_HOSPITAL].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_HOSPITAL].active);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_SMALL_TEMPLE_CERES].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_SMALL_TEMPLE_NEPTUNE].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_SMALL_TEMPLE_MERCURY].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_SMALL_TEMPLE_MARS].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_SMALL_TEMPLE_VENUS].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_LARGE_TEMPLE_CERES].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_LARGE_TEMPLE_NEPTUNE].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_LARGE_TEMPLE_MERCURY].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_LARGE_TEMPLE_MARS].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_LARGE_TEMPLE_VENUS].total);
    buffer_write_i32(savegame_data.state.building_count_culture1, count_data.buildings[BUILDING_ORACLE].total);
    // culture 2
    buffer_write_i32(savegame_data.state.building_count_culture2, count_data.buildings[BUILDING_ACTOR_COLONY].total);
    buffer_write_i32(savegame_data.state.building_count_culture2, count_data.buildings[BUILDING_ACTOR_COLONY].active);
    buffer_write_i32(savegame_data.state.building_count_culture2, count_data.buildings[BUILDING_GLADIATOR_SCHOOL].total);
    buffer_write_i32(savegame_data.state.building_count_culture2, count_data.buildings[BUILDING_GLADIATOR_SCHOOL].active);
    buffer_write_i32(savegame_data.state.building_count_culture2, count_data.buildings[BUILDING_LION_HOUSE].total);
    buffer_write_i32(savegame_data.state.building_count_culture2, count_data.buildings[BUILDING_LION_HOUSE].active);
    buffer_write_i32(savegame_data.state.building_count_culture2, count_data.buildings[BUILDING_CHARIOT_MAKER].total);
    buffer_write_i32(savegame_data.state.building_count_culture2, count_data.buildings[BUILDING_CHARIOT_MAKER].active);
    // culture 3
    buffer_write_i32(savegame_data.state.building_count_culture3, count_data.buildings[BUILDING_SMALL_TEMPLE_CERES].active);
    buffer_write_i32(savegame_data.state.building_count_culture3, count_data.buildings[BUILDING_SMALL_TEMPLE_NEPTUNE].active);
    buffer_write_i32(savegame_data.state.building_count_culture3, count_data.buildings[BUILDING_SMALL_TEMPLE_MERCURY].active);
    buffer_write_i32(savegame_data.state.building_count_culture3, count_data.buildings[BUILDING_SMALL_TEMPLE_MARS].active);
    buffer_write_i32(savegame_data.state.building_count_culture3, count_data.buildings[BUILDING_SMALL_TEMPLE_VENUS].active);
    buffer_write_i32(savegame_data.state.building_count_culture3, count_data.buildings[BUILDING_LARGE_TEMPLE_CERES].active);
    buffer_write_i32(savegame_data.state.building_count_culture3, count_data.buildings[BUILDING_LARGE_TEMPLE_NEPTUNE].active);
    buffer_write_i32(savegame_data.state.building_count_culture3, count_data.buildings[BUILDING_LARGE_TEMPLE_MERCURY].active);
    buffer_write_i32(savegame_data.state.building_count_culture3, count_data.buildings[BUILDING_LARGE_TEMPLE_MARS].active);
    buffer_write_i32(savegame_data.state.building_count_culture3, count_data.buildings[BUILDING_LARGE_TEMPLE_VENUS].active);
    // military
    buffer_write_i32(savegame_data.state.building_count_military, count_data.buildings[BUILDING_MILITARY_ACADEMY].total);
    buffer_write_i32(savegame_data.state.building_count_military, count_data.buildings[BUILDING_MILITARY_ACADEMY].active);
    buffer_write_i32(savegame_data.state.building_count_military, count_data.buildings[BUILDING_BARRACKS].total);
    buffer_write_i32(savegame_data.state.building_count_military, count_data.buildings[BUILDING_BARRACKS].active);
    // support
    buffer_write_i32(savegame_data.state.building_count_support, count_data.buildings[BUILDING_MARKET].total);
    buffer_write_i32(savegame_data.state.building_count_support, count_data.buildings[BUILDING_MARKET].active);
    buffer_write_i32(savegame_data.state.building_count_support, count_data.buildings[BUILDING_RESERVOIR].total);
    buffer_write_i32(savegame_data.state.building_count_support, count_data.buildings[BUILDING_RESERVOIR].active);
    buffer_write_i32(savegame_data.state.building_count_support, count_data.buildings[BUILDING_FOUNTAIN].total);
    buffer_write_i32(savegame_data.state.building_count_support, count_data.buildings[BUILDING_FOUNTAIN].active);
    buffer_write_i32(savegame_data.state.empire, empire_data.scroll_x);
    buffer_write_i32(savegame_data.state.empire, empire_data.scroll_y);
    empire_object_save_state(savegame_data.state.empire_objects);
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        buffer_write_u16(savegame_data.state.trade_prices, trade_prices[i].buy);
        buffer_write_u16(savegame_data.state.trade_prices, trade_prices[i].sell);
    }
    buffer_write_i32(savegame_data.state.figure_names, name_data.citizen_male);
    buffer_write_i32(savegame_data.state.figure_names, name_data.patrician);
    buffer_write_i32(savegame_data.state.figure_names, name_data.citizen_female);
    buffer_write_i32(savegame_data.state.figure_names, name_data.tax_collector);
    buffer_write_i32(savegame_data.state.figure_names, name_data.engineer);
    buffer_write_i32(savegame_data.state.figure_names, name_data.prefect);
    buffer_write_i32(savegame_data.state.figure_names, name_data.javelin_thrower);
    buffer_write_i32(savegame_data.state.figure_names, name_data.cavalry);
    buffer_write_i32(savegame_data.state.figure_names, name_data.legionary);
    buffer_write_i32(savegame_data.state.figure_names, name_data.actor);
    buffer_write_i32(savegame_data.state.figure_names, name_data.gladiator);
    buffer_write_i32(savegame_data.state.figure_names, name_data.lion_tamer);
    buffer_write_i32(savegame_data.state.figure_names, name_data.charioteer);
    buffer_write_i32(savegame_data.state.figure_names, name_data.barbarian);
    buffer_write_i32(savegame_data.state.figure_names, name_data.enemy_greek);
    buffer_write_i32(savegame_data.state.figure_names, name_data.enemy_egyptian);
    buffer_write_i32(savegame_data.state.figure_names, name_data.enemy_arabian);
    buffer_write_i32(savegame_data.state.figure_names, name_data.trader);
    buffer_write_i32(savegame_data.state.figure_names, name_data.ship);
    buffer_write_i32(savegame_data.state.culture_coverage, culture_coverage.theater);
    buffer_write_i32(savegame_data.state.culture_coverage, culture_coverage.amphitheater);
    buffer_write_i32(savegame_data.state.culture_coverage, culture_coverage.colosseum);
    buffer_write_i32(savegame_data.state.culture_coverage, culture_coverage.hippodrome);
    for (int i = GOD_CERES; i <= GOD_VENUS; i++) {
        buffer_write_i32(savegame_data.state.culture_coverage, culture_coverage.religion[i]);
    }
    buffer_write_i32(savegame_data.state.culture_coverage, culture_coverage.oracle);
    buffer_write_i32(savegame_data.state.culture_coverage, culture_coverage.school);
    buffer_write_i32(savegame_data.state.culture_coverage, culture_coverage.library);
    buffer_write_i32(savegame_data.state.culture_coverage, culture_coverage.academy);
    buffer_write_i32(savegame_data.state.culture_coverage, culture_coverage.hospital);
    scenario_save_state(savegame_data.state.scenario);
    for (int i = 0; i < MAX_MESSAGES; i++) {
        struct city_message_t *msg = &message_data.messages[i];
        buffer_write_i32(savegame_data.state.messages, msg->param1);
        buffer_write_i16(savegame_data.state.messages, msg->year);
        buffer_write_i16(savegame_data.state.messages, msg->param2);
        buffer_write_i16(savegame_data.state.messages, msg->message_type);
        buffer_write_i16(savegame_data.state.messages, msg->sequence);
        buffer_write_u8(savegame_data.state.messages, msg->is_read);
        buffer_write_u8(savegame_data.state.messages, msg->month);
    }

    buffer_write_i32(savegame_data.state.message_extra, message_data.next_message_sequence);
    buffer_write_i32(savegame_data.state.message_extra, message_data.total_messages);
    buffer_write_i32(savegame_data.state.message_extra, message_data.current_message_id);

    for (int i = 0; i < MAX_MESSAGE_CATEGORIES; i++) {
        buffer_write_i32(savegame_data.state.message_counts, message_data.message_count[i]);
        buffer_write_i32(savegame_data.state.message_delays, message_data.message_delay[i]);
    }
    // population
    buffer_write_u8(savegame_data.state.population_messages, message_data.population_shown.pop500);
    buffer_write_u8(savegame_data.state.population_messages, message_data.population_shown.pop1000);
    buffer_write_u8(savegame_data.state.population_messages, message_data.population_shown.pop2000);
    buffer_write_u8(savegame_data.state.population_messages, message_data.population_shown.pop3000);
    buffer_write_u8(savegame_data.state.population_messages, message_data.population_shown.pop5000);
    buffer_write_u8(savegame_data.state.population_messages, message_data.population_shown.pop10000);
    buffer_write_u8(savegame_data.state.population_messages, message_data.population_shown.pop15000);
    buffer_write_u8(savegame_data.state.population_messages, message_data.population_shown.pop20000);
    buffer_write_u8(savegame_data.state.population_messages, message_data.population_shown.pop25000);
    for (int i = 0; i < MAX_CITY_SOUNDS_CHANNELS; i++) {
        struct city_channel_t *ch = &channels[i];
        buffer_write_i32(savegame_data.state.city_sounds, ch->available);
        buffer_write_i32(savegame_data.state.city_sounds, ch->total_views);
        buffer_write_i32(savegame_data.state.city_sounds, ch->views_threshold);
        for (int d = 0; d < 5; d++) {
            buffer_write_i32(savegame_data.state.city_sounds, ch->direction_views[d]);
        }
        buffer_write_i32(savegame_data.state.city_sounds, ch->channel);
        buffer_write_i32(savegame_data.state.city_sounds, ch->in_use);
        buffer_write_i32(savegame_data.state.city_sounds, ch->times_played);
        buffer_write_u32(savegame_data.state.city_sounds, ch->last_played_time);
        buffer_write_u32(savegame_data.state.city_sounds, ch->delay_millis);
        buffer_write_i32(savegame_data.state.city_sounds, ch->should_play);
    }
    for (int i = 0; i < MAX_TRADERS; i++) {
        struct trader *t = &figure_trader_data.traders[i];
        buffer_write_i32(savegame_data.state.figure_traders, t->bought_amount);
        buffer_write_i32(savegame_data.state.figure_traders, t->sold_amount);
        for (int r = 0; r < RESOURCE_TYPES_MAX; r++) {
            buffer_write_u8(savegame_data.state.figure_traders, t->bought_resources[r]);
        }
        for (int r = 0; r < RESOURCE_TYPES_MAX; r++) {
            buffer_write_u8(savegame_data.state.figure_traders, t->sold_resources[r]);
        }
    }
    buffer_write_i32(savegame_data.state.figure_traders, figure_trader_data.next_index);
    for (int i = 0; i < MAX_SMALL; i++) {
        buffer_write_i16(savegame_data.state.building_list_small, building_list_data.small.items[i]);
    }
    for (int i = 0; i < MAX_LARGE; i++) {
        buffer_write_i16(savegame_data.state.building_list_large, building_list_data.large.items[i]);
    }
    for (int i = 0; i < MAX_BURNING; i++) {
        buffer_write_i16(savegame_data.state.building_list_burning, building_list_data.burning.items[i]);
    }
    buffer_write_i32(savegame_data.state.building_list_burning_totals, building_list_data.burning.total);
    buffer_write_i32(savegame_data.state.building_list_burning_totals, building_list_data.burning.size);
    for (int i = 0; i < MAX_STORAGES; i++) {
        buffer_write_i32(savegame_data.state.building_storages, storages[i].building_id);
        buffer_write_u8(savegame_data.state.building_storages, (uint8_t) storages[i].in_use);
        buffer_write_u8(savegame_data.state.building_storages, (uint8_t) storages[i].storage.empty_all);
        for (int r = 0; r < RESOURCE_TYPES_MAX; r++) {
            buffer_write_u8(savegame_data.state.building_storages, storages[i].storage.resource_state[r]);
        }
    }
    buffer_write_i32(savegame_data.state.routing_counters, stats.enemy_routes_calculated);
    buffer_write_i32(savegame_data.state.routing_counters, stats.total_routes_calculated);
    for (int i = 0; i < MAX_BOOKMARKS; i++) {
        buffer_write_i32(savegame_data.state.bookmarks, bookmarks[i].x);
        buffer_write_i32(savegame_data.state.bookmarks, bookmarks[i].y);
    }

    static char dir_prepended_filepath[DIR_PATH_MAX];
    prepend_dir_to_path(dir, filename, dir_prepended_filepath);

    fp = fopen(dir_prepended_filepath, "wb");
    if (!fp) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to save game", 0, 0));
        return 0;
    }
    for (int i = 0; i < savegame_data.num_pieces; i++) {
        struct file_piece_t *piece = &savegame_data.pieces[i];
        fwrite(piece->buf.data, 1, piece->buf.size, fp);
    }
    fclose(fp);
    return 1;
}

static void formation_load_state(struct buffer_t *buf, struct formation_t *m)
{
    m->in_use = buffer_read_u8(buf);
    m->layout = buffer_read_u8(buf);
    m->figure_type = buffer_read_u8(buf);
    m->num_figures = buffer_read_u8(buf);
    m->max_figures = buffer_read_u8(buf);
    for (int fig = 0; fig < MAX_FORMATION_FIGURES; fig++) {
        m->figures[fig] = buffer_read_u16(buf);
    }
    m->has_military_training = buffer_read_u8(buf);
    m->is_at_rest = buffer_read_u8(buf);
    m->deployed_duration_months = buffer_read_u8(buf);
    m->direction = buffer_read_u8(buf);
    m->morale = buffer_read_u8(buf);
    m->max_morale = buffer_read_u8(buf);
    m->routed = buffer_read_u8(buf);
    m->wait_ticks_movement = buffer_read_i16(buf);
    m->standard_x = buffer_read_u16(buf);
    m->standard_y = buffer_read_u16(buf);
    m->prev_standard_x = buffer_read_u16(buf);
    m->prev_standard_y = buffer_read_u16(buf);
    m->legion_standard__figure_id = buffer_read_u16(buf);
    m->building_id = buffer_read_u16(buf);
    m->empire_service = buffer_read_u8(buf);
    m->in_distant_battle = buffer_read_u8(buf);
    m->cursed_by_mars = buffer_read_u8(buf);
    m->recent_fight = buffer_read_u8(buf);
    m->missile_attack_timeout = buffer_read_u8(buf);
    m->destination_x = buffer_read_u16(buf);
    m->destination_y = buffer_read_u16(buf);
    m->wolf_spawn_delay = buffer_read_u16(buf);
    m->attack_priority = buffer_read_u8(buf);
}

static int empire_object_init_distant_battle_travel_months(int object_type)
{
    int month = 0;
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        if (empire_objects[i].in_use && empire_objects[i].type == object_type) {
            month++;
            empire_objects[i].distant_battle_travel_months = month;
        }
    }
    return month;
}

static void add_road(int grid_offset)
{
    if (!map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR)) {
        terrain_grid.items[grid_offset] |= TERRAIN_ROAD;
    }
}

static void map_terrain_add_gatehouse_roads(int x, int y, int orientation)
{
    // roads under gatehouse
    terrain_grid.items[map_grid_offset(x, y)] |= TERRAIN_ROAD;
    terrain_grid.items[map_grid_offset(x + 1, y)] |= TERRAIN_ROAD;
    terrain_grid.items[map_grid_offset(x, y + 1)] |= TERRAIN_ROAD;
    terrain_grid.items[map_grid_offset(x + 1, y + 1)] |= TERRAIN_ROAD;

    // free roads before/after gate
    if (orientation == 1) {
        add_road(map_grid_offset(x, y - 1));
        add_road(map_grid_offset(x + 1, y - 1));
        add_road(map_grid_offset(x, y + 2));
        add_road(map_grid_offset(x + 1, y + 2));
    } else if (orientation == 2) {
        add_road(map_grid_offset(x - 1, y));
        add_road(map_grid_offset(x - 1, y + 1));
        add_road(map_grid_offset(x + 2, y));
        add_road(map_grid_offset(x + 2, y + 1));
    }
}

static void map_terrain_add_triumphal_arch_roads(int x, int y, int orientation)
{
    if (orientation == 1) {
        // road in the middle
        terrain_grid.items[map_grid_offset(x + 1, y)] |= TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 1, y + 1)] |= TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 1, y + 2)] |= TERRAIN_ROAD;
        // no roads on other tiles
        terrain_grid.items[map_grid_offset(x, y)] &= ~TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x, y + 1)] &= ~TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x, y + 2)] &= ~TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 2, y)] &= ~TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 2, y + 1)] &= ~TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 2, y + 2)] &= ~TERRAIN_ROAD;
    } else if (orientation == 2) {
        // road in the middle
        terrain_grid.items[map_grid_offset(x, y + 1)] |= TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 1, y + 1)] |= TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 2, y + 1)] |= TERRAIN_ROAD;
        // no roads on other tiles
        terrain_grid.items[map_grid_offset(x, y)] &= ~TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 1, y)] &= ~TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 2, y)] &= ~TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x, y + 2)] &= ~TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 1, y + 2)] &= ~TERRAIN_ROAD;
        terrain_grid.items[map_grid_offset(x + 2, y + 2)] &= ~TERRAIN_ROAD;
    }
}

static void map_water_add_building(int building_id, int x, int y, int size, int image_id)
{
    if (!map_grid_is_inside(x, y, size)) {
        return;
    }
    struct map_point_t leftmost;
    switch (view_data.orientation) {
        case DIR_0_TOP:
            leftmost.x = 0;
            leftmost.y = size - 1;
            break;
        case DIR_2_RIGHT:
            leftmost.x = leftmost.y = 0;
            break;
        case DIR_4_BOTTOM:
            leftmost.x = size - 1;
            leftmost.y = 0;
            break;
        case DIR_6_LEFT:
            leftmost.x = leftmost.y = size - 1;
            break;
        default:
            return;
    }
    for (int dy = 0; dy < size; dy++) {
        for (int dx = 0; dx < size; dx++) {
            int grid_offset = map_grid_offset(x + dx, y + dy);
            terrain_grid.items[grid_offset] |= TERRAIN_BUILDING;
            if (!map_terrain_is(grid_offset, TERRAIN_WATER)) {
                terrain_grid.items[grid_offset] &= ~TERRAIN_CLEARABLE;
                terrain_grid.items[grid_offset] |= TERRAIN_BUILDING;
            }
            buildings_grid.items[grid_offset] = building_id;
            bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
            map_property_set_multi_tile_size(grid_offset, size);
            images.items[grid_offset] = image_id;
            map_property_set_multi_tile_xy(grid_offset, dx, dy,
                dx == leftmost.x && dy == leftmost.y);
        }
    }
}

static void map_orientation_update_buildings(void)
{
    int map_orientation = view_data.orientation;
    int orientation_is_top_bottom = map_orientation == DIR_0_TOP || map_orientation == DIR_4_BOTTOM;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_UNUSED || b->state == BUILDING_STATE_DELETED_BY_GAME) {
            continue;
        }
        int image_id;
        int image_offset;
        switch (b->type) {
            case BUILDING_GATEHOUSE:
                if (b->subtype.orientation == 1) {
                    if (orientation_is_top_bottom) {
                        image_id = 697;
                    } else {
                        image_id = 698;
                    }
                } else {
                    if (orientation_is_top_bottom) {
                        image_id = 698;
                    } else {
                        image_id = 697;
                    }
                }
                map_building_tiles_add(i, b->x, b->y, b->size, image_id, TERRAIN_GATEHOUSE | TERRAIN_BUILDING);
                map_terrain_add_gatehouse_roads(b->x, b->y, 0);
                break;
            case BUILDING_TRIUMPHAL_ARCH:
                if (b->subtype.orientation == 1) {
                    if (orientation_is_top_bottom) {
                        image_id = 821;
                    } else {
                        image_id = 823;
                    }
                } else {
                    if (orientation_is_top_bottom) {
                        image_id = 823;
                    } else {
                        image_id = 821;
                    }
                }
                map_building_tiles_add(i, b->x, b->y, b->size, image_id, TERRAIN_BUILDING);
                map_terrain_add_triumphal_arch_roads(b->x, b->y, b->subtype.orientation);
                break;
            case BUILDING_HIPPODROME:
                if (map_orientation == DIR_0_TOP) {
                    image_id = 7789;
                    switch (b->subtype.orientation) {
                        case 0: case 3: image_id += 0; break;
                        case 1: case 4: image_id += 2; break;
                        case 2: case 5: image_id += 4; break;
                    }
                } else if (map_orientation == DIR_4_BOTTOM) {
                    image_id = 7789;
                    switch (b->subtype.orientation) {
                        case 0: case 3: image_id += 4; break;
                        case 1: case 4: image_id += 2; break;
                        case 2: case 5: image_id += 0; break;
                    }
                } else if (map_orientation == DIR_6_LEFT) {
                    image_id = 7780;
                    switch (b->subtype.orientation) {
                        case 0: case 3: image_id += 0; break;
                        case 1: case 4: image_id += 2; break;
                        case 2: case 5: image_id += 4; break;
                    }
                } else { // DIR_2_RIGHT
                    image_id = 7780;
                    switch (b->subtype.orientation) {
                        case 0: case 3: image_id += 4; break;
                        case 1: case 4: image_id += 2; break;
                        case 2: case 5: image_id += 0; break;
                    }
                }
                map_building_tiles_add(i, b->x, b->y, b->size, image_id, TERRAIN_BUILDING);
                break;
            case BUILDING_SHIPYARD:
                image_offset = (4 + b->data.industry.orientation - map_orientation / 2) % 4;
                image_id = 3226 + image_offset;
                map_water_add_building(i, b->x, b->y, 2, image_id);
                break;
            case BUILDING_WHARF:
                image_offset = (4 + b->data.industry.orientation - map_orientation / 2) % 4;
                image_id = 3277 + image_offset;
                map_water_add_building(i, b->x, b->y, 2, image_id);
                break;
            case BUILDING_DOCK:
                image_offset = (4 + b->data.dock.orientation - map_orientation / 2) % 4;
                switch (image_offset) {
                    case 0: image_id = 3230; break;
                    case 1: image_id = 3242; break;
                    case 2: image_id = 3254; break;
                    default:image_id = 3266; break;
                }
                map_water_add_building(i, b->x, b->y, 3, image_id);
                break;
        }
    }
}

static int map_routing_citizen_is_passable(int grid_offset)
{
    return terrain_land_citizen.items[grid_offset] == CITIZEN_0_ROAD ||
        terrain_land_citizen.items[grid_offset] == CITIZEN_2_PASSABLE_TERRAIN;
}

static void map_road_network_update(void)
{
    for (int i = 0; i < 10; i++) {
        city_data.map.largest_road_networks[i].id = 0;
        city_data.map.largest_road_networks[i].size = 0;
    }
    memset(network.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    int network_id = 1;
    int grid_offset = map_data.start_offset;
    for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (map_terrain_is(grid_offset, TERRAIN_ROAD) && !network.items[grid_offset]) {
                memset(&road_network_queue, 0, sizeof(road_network_queue));
                int guard = 0;
                int next_offset;
                int size = 1;
                do {
                    if (++guard >= GRID_SIZE * GRID_SIZE) {
                        break;
                    }
                    network.items[grid_offset] = network_id;
                    next_offset = -1;
                    for (int i = 0; i < 4; i++) {
                        int new_offset = grid_offset + ADJACENT_OFFSETS_ROUTING[i];
                        if (map_routing_citizen_is_passable(new_offset) && !network.items[new_offset]) {
                            if (terrain_land_citizen.items[new_offset] == CITIZEN_0_ROAD || map_terrain_is(new_offset, TERRAIN_ACCESS_RAMP)) {
                                network.items[new_offset] = network_id;
                                size++;
                                if (next_offset == -1) {
                                    next_offset = new_offset;
                                } else {
                                    road_network_queue.items[road_network_queue.tail++] = new_offset;
                                    if (road_network_queue.tail >= MAX_QUEUE) {
                                        road_network_queue.tail = 0;
                                    }
                                }
                            }
                        }
                    }
                    if (next_offset == -1) {
                        if (road_network_queue.head == road_network_queue.tail) {
                            break;
                        }
                        next_offset = road_network_queue.items[road_network_queue.head++];
                        if (road_network_queue.head >= MAX_QUEUE) {
                            road_network_queue.head = 0;
                        }
                    }
                    grid_offset = next_offset;
                } while (next_offset > -1);
                for (int n = 0; n < 10; n++) {
                    if (size > city_data.map.largest_road_networks[n].size) {
                        // move everyone down
                        for (int m = 9; m > n; m--) {
                            city_data.map.largest_road_networks[m].id = city_data.map.largest_road_networks[m - 1].id;
                            city_data.map.largest_road_networks[m].size = city_data.map.largest_road_networks[m - 1].size;
                        }
                        city_data.map.largest_road_networks[n].id = network_id;
                        city_data.map.largest_road_networks[n].size = size;
                        break;
                    }
                }
                network_id++;
            }
        }
    }
}

static void building_granaries_calculate_stocks(void)
{
    non_getting_granaries.num_items = 0;
    for (int i = 0; i < MAX_GRANARIES; i++) {
        non_getting_granaries.building_ids[i] = 0;
    }
    non_getting_granaries.total_storage_wheat = 0;
    non_getting_granaries.total_storage_vegetables = 0;
    non_getting_granaries.total_storage_fruit = 0;
    non_getting_granaries.total_storage_meat = 0;

    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_GRANARY) {
            continue;
        }
        if (!b->has_road_access) {
            continue;
        }
        struct building_storage_t *s = &storages[b->storage_id].storage;
        int total_non_getting = 0;
        if (s->resource_state[RESOURCE_WHEAT] != BUILDING_STORAGE_STATE_GETTING) {
            total_non_getting += b->data.granary.resource_stored[RESOURCE_WHEAT];
            non_getting_granaries.total_storage_wheat += b->data.granary.resource_stored[RESOURCE_WHEAT];
        }
        if (s->resource_state[RESOURCE_VEGETABLES] != BUILDING_STORAGE_STATE_GETTING) {
            total_non_getting += b->data.granary.resource_stored[RESOURCE_VEGETABLES];
            non_getting_granaries.total_storage_vegetables += b->data.granary.resource_stored[RESOURCE_VEGETABLES];
        }
        if (s->resource_state[RESOURCE_FRUIT] != BUILDING_STORAGE_STATE_GETTING) {
            total_non_getting += b->data.granary.resource_stored[RESOURCE_FRUIT];
            non_getting_granaries.total_storage_fruit += b->data.granary.resource_stored[RESOURCE_FRUIT];
        }
        if (s->resource_state[RESOURCE_MEAT] != BUILDING_STORAGE_STATE_GETTING) {
            total_non_getting += b->data.granary.resource_stored[RESOURCE_MEAT];
            non_getting_granaries.total_storage_meat += b->data.granary.resource_stored[RESOURCE_MEAT];
        }
        if (total_non_getting > MAX_GRANARIES) {
            non_getting_granaries.building_ids[non_getting_granaries.num_items] = i;
            if (non_getting_granaries.num_items < MAX_GRANARIES - 2) {
                non_getting_granaries.num_items++;
            }
        }
    }
}

static void game_state_reset_overlay(void)
{
    state_data.current_overlay = OVERLAY_NONE;
    state_data.previous_overlay = OVERLAY_NONE;
}

static int building_storage_create(void)
{
    for (int i = 1; i < MAX_STORAGES; i++) {
        if (!storages[i].in_use) {
            memset(&storages[i], 0, sizeof(struct data_storage));
            storages[i].in_use = 1;
            return i;
        }
    }
    return 0;
}

static void building_storage_reset_building_ids(void)
{
    for (int i = 1; i < MAX_STORAGES; i++) {
        storages[i].building_id = 0;
    }

    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_UNUSED) {
            continue;
        }
        if (b->type == BUILDING_GRANARY || b->type == BUILDING_WAREHOUSE) {
            if (b->storage_id) {
                if (storages[b->storage_id].building_id) {
                    // storage is already connected to a building: corrupt, create new
                    b->storage_id = building_storage_create();
                } else {
                    storages[b->storage_id].building_id = i;
                }
            }
        }
    }
}

static struct dir_listing *dir_list_files(char *extension)
{
    memset(listing.files, 0, sizeof(listing.files));
    listing.num_files = 0;
    listing.file_overflow = 0;
    DIR *dir = 0;
    struct dirent *file_info;
    if (string_equals(extension, "map")) {
        dir = opendir(MAPS_DIR_PATH);
    } else if (string_equals(extension, "sav")) {
        dir = opendir(SAVES_DIR_PATH);
    }
    if (dir) {
        while ((file_info = readdir(dir)) != 0) {
            if (listing.num_files >= SCENARIO_FILES_MAX) {
                listing.file_overflow = 1;
                return &listing;
            }
            if (file_has_extension(file_info->d_name, extension)) {
                if (string_length(file_info->d_name) < FILE_NAME_LENGTH_MAX) {
                    string_copy(file_info->d_name, listing.files[listing.num_files], FILE_NAME_LENGTH_MAX);
                    listing.num_files++;
                }
            }
        }
        closedir(dir);
    }
    return &listing;
}

static void city_view_get_camera(int *x, int *y)
{
    *x = view_data.camera.tile.x;
    *y = view_data.camera.tile.y;
}

static void city_view_get_viewport_size_tiles(int *width, int *height)
{
    *width = view_data.viewport.width_tiles;
    *height = view_data.viewport.height_tiles;
}

static void set_bounds_minimap(int x_offset, int y_offset, int width, int height)
{
    minimap_data.width_tiles = width / 2;
    minimap_data.height_tiles = height;
    minimap_data.x_offset = x_offset;
    minimap_data.y_offset = y_offset;
    minimap_data.width = width;
    minimap_data.height = height;
    minimap_data.absolute_x = (VIEW_X_MAX - minimap_data.width_tiles) / 2;
    minimap_data.absolute_y = (VIEW_Y_MAX - minimap_data.height_tiles) / 2;

    city_view_get_camera(&minimap_data.camera_x, &minimap_data.camera_y);
    int view_width_tiles, view_height_tiles;
    city_view_get_viewport_size_tiles(&view_width_tiles, &view_height_tiles);

    if ((map_data.width - minimap_data.width_tiles) / 2 > 0) {
        if (minimap_data.camera_x < minimap_data.absolute_x) {
            minimap_data.absolute_x = minimap_data.camera_x;
        } else if (minimap_data.camera_x > minimap_data.width_tiles + minimap_data.absolute_x - view_width_tiles) {
            minimap_data.absolute_x = view_width_tiles + minimap_data.camera_x - minimap_data.width_tiles;
        }
    }
    if ((2 * map_data.height - minimap_data.height_tiles) / 2 > 0) {
        if (minimap_data.camera_y < minimap_data.absolute_y) {
            minimap_data.absolute_y = minimap_data.camera_y;
        } else if (minimap_data.camera_y > minimap_data.height_tiles + minimap_data.absolute_y - view_height_tiles) {
            minimap_data.absolute_y = view_height_tiles + minimap_data.camera_y - minimap_data.height_tiles;
        }
    }
    // ensure even height
    minimap_data.absolute_y &= ~1;
}

static void city_view_foreach_minimap_tile(int x_offset, int y_offset, int absolute_x, int absolute_y, int width_tiles, int height_tiles, map_callback *callback)
{
    int odd = 0;
    int y_abs = absolute_y - 4;
    int y_view = y_offset - 4;
    for (int y_rel = -4; y_rel < height_tiles + 4; y_rel++, y_abs++, y_view++) {
        int x_view;
        if (odd) {
            x_view = x_offset - 9;
            odd = 0;
        } else {
            x_view = x_offset - 8;
            odd = 1;
        }
        int x_abs = absolute_x - 4;
        for (int x_rel = -4; x_rel < width_tiles; x_rel++, x_abs++, x_view += 2) {
            if (x_abs >= 0 && x_abs < VIEW_X_MAX && y_abs >= 0 && y_abs < VIEW_Y_MAX) {
                callback(x_view, y_view, view_to_grid_offset_lookup[x_abs][y_abs]);
            }
        }
    }
}

static void draw_minimap_tile(int x_view, int y_view, int grid_offset)
{
    if (grid_offset < 0) {
        image_draw(editor_active ? 3144 : 7837, x_view, y_view);
        return;
    }
    int color_type = FIGURE_COLOR_NONE;
    if (map_figures.items[grid_offset] > 0) {
        int figure_id = map_figures.items[grid_offset];
        while (figure_id) {
            struct figure_t *f = &figures[figure_id];
            if (figure_properties[f->type].is_player_legion_unit && selected_legion_formation) {
                color_type = selected_legion_formation->id == f->formation_id ? FIGURE_COLOR_SELECTED_SOLDIER : FIGURE_COLOR_SOLDIER;
                break;
            } else if (figure_properties[f->type].is_enemy_unit || figure_properties[f->type].is_caesar_legion_unit || (figure_properties[f->type].is_native_unit && f->action_state == FIGURE_ACTION_NATIVE_ATTACKING)) {
                color_type = FIGURE_COLOR_ENEMY;
                break;
            } else if (f->type == FIGURE_WOLF) {
                color_type = FIGURE_COLOR_WOLF;
                break;
            }
            figure_id = f->next_figure_id_on_same_tile;
        }
    }
    if (color_type) {
        uint32_t color = COLOR_BLACK;
        if (color_type == FIGURE_COLOR_SOLDIER) {
            color = COLOR_MINIMAP_SOLDIER;
        } else if (color_type == FIGURE_COLOR_SELECTED_SOLDIER) {
            color = COLOR_MINIMAP_SELECTED_SOLDIER;
        } else if (color_type == FIGURE_COLOR_ENEMY) {
            color = minimap_data.enemy_color;
        }
        graphics_draw_horizontal_line(x_view, x_view + 1, y_view, color);
        return;
    }
    int terrain = terrain_grid.items[grid_offset];
    // exception for fort ground: display as empty land
    if (terrain & TERRAIN_BUILDING) {
        if (all_buildings[map_building_at(grid_offset)].type == BUILDING_FORT_GROUND) {
            terrain = 0;
        }
    }
    if (terrain & TERRAIN_BUILDING) {
        if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
            int image_id;
            struct building_t *b = &all_buildings[map_building_at(grid_offset)];
            if (b->house_size) {
                image_id = editor_active ? 3132 : 7825;
            } else if (b->type == BUILDING_RESERVOIR) {
                image_id = editor_active ? 3141 : 7834;
            } else {
                image_id = editor_active ? 3136 : 7829;
            }
            switch (map_property_multi_tile_size(grid_offset)) {
                case 1: image_draw(image_id, x_view, y_view); break;
                case 2: image_draw(image_id + 1, x_view, y_view - 1); break;
                case 3: image_draw(image_id + 2, x_view, y_view - 2); break;
                case 4: image_draw(image_id + 3, x_view, y_view - 3); break;
                case 5: image_draw(image_id + 4, x_view, y_view - 4); break;
            }
        }
    } else {
        int rand = random.items[grid_offset];
        int image_id;
        if (terrain & TERRAIN_ROAD) {
            image_id = editor_active ? 3131 : 7824;
        } else if (terrain & TERRAIN_WATER) {
            image_id = (editor_active ? 3113 : 7806) + (rand & 3);
        } else if (terrain & (TERRAIN_TREE | TERRAIN_SHRUB)) {
            image_id = (editor_active ? 3132 : 7810) + (rand & 3);
        } else if (terrain & (TERRAIN_ROCK | TERRAIN_ELEVATION)) {
            image_id = (editor_active ? 3123 : 7816) + (rand & 3);
        } else if (terrain & TERRAIN_AQUEDUCT) {
            image_id = editor_active ? 3142 : 7835;
        } else if (terrain & TERRAIN_WALL) {
            image_id = editor_active ? 3141 : 7834;
        } else if (terrain & TERRAIN_MEADOW) {
            image_id = (editor_active ? 3127 : 7820) + (rand & 3);
        } else {
            image_id = (editor_active ? 3105 : 7798) + (rand & 7);
        }
        image_draw(image_id, x_view, y_view);
    }
}

static void graphics_save_to_buffer(int x, int y, int width, int height, uint32_t *buffer)
{
    struct clip_info_t *current_clip = graphics_get_clip_info(x, y, width, height);
    if (!current_clip->is_visible) {
        return;
    }
    int min_x = x + current_clip->clipped_pixels_left;
    int min_dy = current_clip->clipped_pixels_top;
    int max_dy = height - current_clip->clipped_pixels_bottom;
    for (int dy = min_dy; dy < max_dy; dy++) {
        memcpy(&buffer[dy * width], graphics_get_pixel(min_x, y + dy),
            sizeof(uint32_t) * current_clip->visible_pixels_x);
    }
}

static void draw_viewport_rectangle(void)
{
    int camera_x, camera_y;
    int camera_pixels_x;
    city_view_get_camera(&camera_x, &camera_y);
    camera_pixels_x = view_data.camera.pixel.x;
    int view_width_tiles, view_height_tiles;
    city_view_get_viewport_size_tiles(&view_width_tiles, &view_height_tiles);

    int x_offset = minimap_data.x_offset + 2 * (camera_x - minimap_data.absolute_x) - 2 + camera_pixels_x / 30;
    if (x_offset < minimap_data.x_offset) {
        x_offset = minimap_data.x_offset;
    }
    if (x_offset + 2 * view_width_tiles + 4 > minimap_data.x_offset + minimap_data.width_tiles) {
        x_offset -= 2;
    }
    int y_offset = minimap_data.y_offset + camera_y - minimap_data.absolute_y + 2;
    graphics_draw_rect(x_offset, y_offset,
        view_width_tiles * 2 + 4,
        view_height_tiles - 4,
        COLOR_MINIMAP_VIEWPORT);
}

static void draw_minimap(void)
{
    graphics_set_clip_rectangle(minimap_data.x_offset, minimap_data.y_offset, minimap_data.width, minimap_data.height);
    city_view_foreach_minimap_tile(minimap_data.x_offset, minimap_data.y_offset,
                               minimap_data.absolute_x, minimap_data.absolute_y,
                               minimap_data.width_tiles, minimap_data.height_tiles,
                               draw_minimap_tile);
    graphics_save_to_buffer(minimap_data.x_offset, minimap_data.y_offset, minimap_data.width, minimap_data.height, minimap_data.cache);
    draw_viewport_rectangle();
    graphics_reset_clip_rectangle();
}

static void draw_uncached(int x_offset, int y_offset, int width, int height)
{
    minimap_data.enemy_color = ENEMY_COLOR_BY_CLIMATE[scenario.climate];
    if (width != minimap_data.width || height != minimap_data.height) {
        free(minimap_data.cache);
        minimap_data.cache = (uint32_t *) malloc(sizeof(uint32_t) * width * height);
    }
    set_bounds_minimap(x_offset, y_offset, width, height);
    draw_minimap();
}

static void graphics_draw_from_buffer(int x, int y, int width, int height, uint32_t *buffer)
{
    struct clip_info_t *current_clip = graphics_get_clip_info(x, y, width, height);
    if (!current_clip->is_visible) {
        return;
    }
    int min_x = x + current_clip->clipped_pixels_left;
    int min_dy = current_clip->clipped_pixels_top;
    int max_dy = height - current_clip->clipped_pixels_bottom;
    for (int dy = min_dy; dy < max_dy; dy++) {
        memcpy(graphics_get_pixel(min_x, y + dy), &buffer[dy * width],
            sizeof(uint32_t) * current_clip->visible_pixels_x);
    }
}

static void widget_minimap_draw(int x_offset, int y_offset, int width, int height, int force)
{
    int refresh_type = REFRESH_NOT_NEEDED;
    if (minimap_data.refresh_requested || force) {
        minimap_data.refresh_requested = 0;
        refresh_type = REFRESH_FULL;
    } else {
        int new_x, new_y;
        city_view_get_camera(&new_x, &new_y);
        if (minimap_data.camera_x != new_x || minimap_data.camera_y != new_y) {
            refresh_type = REFRESH_CAMERA_MOVED;
        }
    }
    if (refresh_type) {
        if (refresh_type == REFRESH_FULL) {
            draw_uncached(x_offset, y_offset, width, height);
        } else {
            if (width != minimap_data.width || height != minimap_data.height || x_offset != minimap_data.x_offset) {
                draw_uncached(x_offset, y_offset, width, height);
            } else {
                int old_absolute_x = minimap_data.absolute_x;
                int old_absolute_y = minimap_data.absolute_y;
                set_bounds_minimap(x_offset, y_offset, width, height);
                if (minimap_data.absolute_x != old_absolute_x || minimap_data.absolute_y != old_absolute_y) {
                    draw_minimap();
                } else {
                    graphics_set_clip_rectangle(x_offset, y_offset, width, height);
                    graphics_draw_from_buffer(x_offset, y_offset, minimap_data.width, minimap_data.height, minimap_data.cache);
                    draw_viewport_rectangle();
                    graphics_reset_clip_rectangle();
                }
            }
        }
        graphics_draw_horizontal_line(x_offset - 1, x_offset - 1 + width, y_offset - 1, COLOR_MINIMAP_DARK);
        graphics_draw_vertical_line(x_offset - 1, y_offset, y_offset + height, COLOR_MINIMAP_DARK);
        graphics_draw_vertical_line(x_offset - 1 + width, y_offset, y_offset + height, COLOR_MINIMAP_LIGHT);
    }
}

static void enforce_scroll_boundaries_empire(void)
{
    if (empire_data.scroll_x < 0) {
        empire_data.scroll_x = 0;
    } else if (empire_data.scroll_x > 2032 - (empire_x_max - empire_x_min)) {
        empire_data.scroll_x = 2032 - (empire_x_max - empire_x_min);
    }
    if (empire_data.scroll_y < 0) {
        empire_data.scroll_y = 0;
    } else if (empire_data.scroll_y > 1168 - (empire_y_max - empire_y_min)) {
        empire_data.scroll_y = 1168 - (empire_y_max - empire_y_min);
    }
}

static void empire_load(void)
{
    char raw_data[EMPIRE_DATA_SIZE];
    char *filename = "c32.emp";
    // read header with scroll positions
    if (!io_read_file_part_into_buffer(filename, raw_data, 4, 32 * scenario.empire.id)) {
        memset(raw_data, 0, 4);
    }
    struct buffer_t buf;
    buffer_init(&buf, raw_data, 4);
    if (scenario.empire.id) { // the default empire map seems to have incorrect coordinates for our city (same as state 1)
        empire_data.scroll_x = buffer_read_i16(&buf);
        empire_data.scroll_y = buffer_read_i16(&buf);
        enforce_scroll_boundaries_empire();
    }
    // read data section with objects
    int offset = EMPIRE_HEADER_SIZE + EMPIRE_DATA_SIZE * scenario.empire.id;
    int read_size = io_read_file_part_into_buffer(filename, raw_data, EMPIRE_DATA_SIZE, offset);
    if (read_size != EMPIRE_DATA_SIZE) {
        // load empty empire when loading fails
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to load empire data from file", filename, 0));
        memset(raw_data, 0, EMPIRE_DATA_SIZE);
    }
    buffer_init(&buf, raw_data, EMPIRE_DATA_SIZE);
    // load initial state
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        empire_objects[i].id = i;
        empire_objects[i].type = buffer_read_u8(&buf);
        empire_objects[i].in_use = buffer_read_u8(&buf);
        empire_objects[i].animation_index = buffer_read_u8(&buf);
        buf.index += 1;
        empire_objects[i].x = buffer_read_i16(&buf);
        empire_objects[i].y = buffer_read_i16(&buf);
        empire_objects[i].width = buffer_read_i16(&buf);
        empire_objects[i].height = buffer_read_i16(&buf);
        empire_objects[i].image_id = buffer_read_i16(&buf);
        if (empire_objects[i].image_id) { // equate editor graphics with main
            if (scenario.empire.id == 27 || scenario.empire.id == 32 || scenario.empire.id == 35 || scenario.empire.id == 38) {
                empire_objects[i].image_id -= 4746;
            } else {
                empire_objects[i].image_id -= 4750;
            }
        }
        empire_objects[i].expanded.image_id = buffer_read_i16(&buf);
        if (empire_objects[i].expanded.image_id) {
            if (scenario.empire.id == 27 || scenario.empire.id == 32 || scenario.empire.id == 35 || scenario.empire.id == 38) {
                empire_objects[i].expanded.image_id -= 4746;
            } else {
                empire_objects[i].expanded.image_id -= 4750;
            }
        }
        buf.index += 1;
        empire_objects[i].distant_battle_travel_months = buffer_read_u8(&buf);
        buf.index += 2;
        empire_objects[i].expanded.x = buffer_read_i16(&buf);
        empire_objects[i].expanded.y = buffer_read_i16(&buf);
        empire_objects[i].city_type = buffer_read_u8(&buf);
        empire_objects[i].city_name_id = buffer_read_u8(&buf);
        empire_objects[i].trade_route_id = buffer_read_u8(&buf);
        empire_objects[i].trade_route_open = buffer_read_u8(&buf);
        empire_objects[i].trade_route_cost = buffer_read_i16(&buf);
        buf.index += 10; // resource to sell
        buf.index += 2;
        buf.index += 8; // resource to buy
        empire_objects[i].invasion_path_id = buffer_read_u8(&buf);
        empire_objects[i].invasion_years = buffer_read_u8(&buf);
        buf.index += 6; // resource quantities (trade40, trade25, trade15)
        buf.index += 6;
    }
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        if (empire_objects[i].in_use
        && (empire_objects[i].city_type == EMPIRE_CITY_TRADE || empire_objects[i].city_type == EMPIRE_CITY_FUTURE_TRADE)) {
        }
        for (int r = 0; r < RESOURCE_TYPES_MAX; r++) {
            empire_objects[i].resource_buy_limit[r] = 0;
            empire_objects[i].resource_sell_limit[r] = 0;
        }
    }
}

static void set_resources_sell_our_city(void)
{
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        if (empire_objects[i].in_use && empire_objects[i].type == EMPIRE_OBJECT_CITY && empire_objects[i].city_type == EMPIRE_CITY_OURS) {
            for (int resource = RESOURCE_WHEAT; resource < RESOURCE_TYPES_MAX; resource++) {
                if (resource == RESOURCE_MEAT) {
                    empire_objects[i].resource_sell_limit[resource] = (scenario.allowed_buildings[BUILDING_WHARF] || scenario.allowed_buildings[BUILDING_PIG_FARM]) ? 1 : 0;
                } else {
                    empire_objects[i].resource_sell_limit[resource] = scenario.allowed_buildings[resource + BUILDING_WHEAT_FARM - 1] ? 1 : 0;
                }
            }
            break;
        }
    }
}

static void switch_empire_state(int value)
{
    if (scenario.empire.id == 39 && value == 1) {
        scenario.empire.id = 0;
    } else if (scenario.empire.id == 0 && value == -1) {
        scenario.empire.id = 39;
    } else {
        scenario.empire.id += value;
    }
    empire_load();
    set_resources_sell_our_city();
    empire_data.scroll_x = 0;
    empire_data.scroll_y = 0;
    // reset demand changes to prevent possible city/resource mixups
    for (int i = 0; i < MAX_DEMAND_CHANGES; i++) {
        scenario.demand_changes[i].trade_city_id = 0;
    }
    refresh_current_window = 1;
}

static void set_city_type(void)
{
    if (selected_empire_object->city_type == EMPIRE_CITY_DISTANT_ROMAN) {
        selected_empire_object->city_type = EMPIRE_CITY_TRADE;
    } else if (selected_empire_object->city_type == EMPIRE_CITY_TRADE) {
        selected_empire_object->city_type = EMPIRE_CITY_FUTURE_TRADE;
    } else {
        selected_empire_object->city_type = EMPIRE_CITY_DISTANT_ROMAN;
    }
    // fix graphics for city sprite and flag color when changing city types
    if (selected_empire_object->city_type == EMPIRE_CITY_TRADE || selected_empire_object->city_type == EMPIRE_CITY_FUTURE_TRADE) {
        selected_empire_object->image_id = 8010;
        selected_empire_object->expanded.image_id = 8010;
    } else if (selected_empire_object->city_type == EMPIRE_CITY_DISTANT_ROMAN) {
        selected_empire_object->image_id = 8017;
        selected_empire_object->expanded.image_id = 8017;
    }
    refresh_current_window = 1;
}

static void draw_shadowed_number(int value, int x, int y, uint32_t color)
{
    text_draw_number_colored(value, 0, 0, x + 1, y - 1, FONT_SMALL_PLAIN, COLOR_BLACK);
    text_draw_number_colored(value, 0, 0, x, y, FONT_SMALL_PLAIN, color);
}

static void draw_resource_trade_city(int resource, int trade_max, int x_offset, int y_offset)
{
    int image_id = resource_images[resource].editor_empire_icon_img_id + resource_image_offset(resource, RESOURCE_IMAGE_ICON);
    switch (trade_max) {
        case 15:
            image_draw(image_id, x_offset, y_offset);
            image_draw(3250, x_offset + 17, y_offset);
            break;
        case 25:
            image_draw(image_id, x_offset, y_offset);
            image_draw(3251, x_offset + 13, y_offset);
            break;
        case 40:
            image_draw(image_id, x_offset, y_offset);
            image_draw(3252, x_offset + 11, y_offset);
            break;
        default:
            image_draw(image_id, x_offset, y_offset);
    }
}

static void button_border_draw(int x, int y, int width_pixels, int height_pixels, int highlighted)
{
    int width_blocks = width_pixels / BLOCK_SIZE;
    if (width_pixels % BLOCK_SIZE) {
        width_blocks++;
    }
    int height_blocks = height_pixels / BLOCK_SIZE;
    if (height_pixels % BLOCK_SIZE) {
        height_blocks++;
    }
    int last_block_offset_x = BLOCK_SIZE * width_blocks - width_pixels;
    int last_block_offset_y = BLOCK_SIZE * height_blocks - height_pixels;
    int image_id = editor_active ? 1420 : 1417;
    if (highlighted) {
        image_id += 8;
    }
    for (int yy = 0; yy < height_blocks; yy++) {
        int draw_offset_y = y + BLOCK_SIZE * yy;
        for (int xx = 0; xx < width_blocks; xx++) {
            int draw_offset_x = x + BLOCK_SIZE * xx;
            if (yy == 0) {
                if (xx == 0) {
                    image_draw(image_id, draw_offset_x, draw_offset_y);
                } else if (xx < width_blocks - 1) {
                    image_draw(image_id + 1, draw_offset_x, draw_offset_y);
                } else {
                    image_draw(image_id + 2, draw_offset_x - last_block_offset_x, draw_offset_y);
                }
            } else if (yy < height_blocks - 1) {
                if (xx == 0) {
                    image_draw(image_id + 7, draw_offset_x, draw_offset_y);
                } else if (xx >= width_blocks - 1) {
                    image_draw(image_id + 3, draw_offset_x - last_block_offset_x, draw_offset_y);
                }
            } else {
                if (xx == 0) {
                    image_draw(image_id + 6, draw_offset_x, draw_offset_y - last_block_offset_y);
                } else if (xx < width_blocks - 1) {
                    image_draw(image_id + 5, draw_offset_x, draw_offset_y - last_block_offset_y);
                } else {
                    image_draw(image_id + 4, draw_offset_x - last_block_offset_x, draw_offset_y - last_block_offset_y);
                }
            }
        }
    }
}

static void text_draw_number_centered(int value, int x_offset, int y_offset, int box_width, int font)
{
    char str[NUMBER_BUFFER_LENGTH];
    number_to_string(str, value, 0, 0);
    text_draw_centered(str, x_offset, y_offset, box_width, font, 0);
}

static void draw_arrow_button(int arrow_button_base_img_id, int arrow_button_x, int arrow_button_y, int arrow_button_id)
{
    if (current_window_image_button_pressed == arrow_button_id) {
        image_draw(arrow_button_base_img_id + 1, arrow_button_x, arrow_button_y);
    } else {
        image_draw(arrow_button_base_img_id, arrow_button_x, arrow_button_y);
    }
}

static int concatenate_numbers(int x, int y)
{
    int power = 10;
    while (y >= power)
        power *= 10;
    return x * power + y;
}

static void draw_text(char *text, int font, uint32_t color)
{
    int letter_id = -1;
    int image_id = 0;
    for (int i = 0; i <= text_num_completed_lines; i++) {
        for (int j = 0; j < text_lines[i].num_chars; j++) {
            if (text[text_lines[i].chars[j].position_in_text] == '@') {
                int chars_to_skip = 0;
                for (int k = 1; k < 5 && j + k < text_lines[i].num_chars; k++) {
                    if (text[text_lines[i].chars[j + k].position_in_text] >= '0' && text[text_lines[i].chars[j + k].position_in_text] <= '9') {
                        image_id = concatenate_numbers(image_id, text[text_lines[i].chars[j + k].position_in_text] - '0');
                        chars_to_skip++;
                    }
                }
                if (image_id) {
                    image_draw(image_id, text_lines[i].chars[j].x_start, text_lines[i].line_y - 3); // images taken from c3map files; y - 3 to align with top of cursor
                    image_id = 0;
                }
                j += chars_to_skip; // skips the numbers after '@'
                continue; // skips the '@'
            }
            if (!CHAR_TO_FONT_IMAGE_DEFAULT[(uint8_t) text[text_lines[i].chars[j].position_in_text]]) {
                letter_id = -1;
            } else {
                letter_id = CHAR_TO_FONT_IMAGE_DEFAULT[(uint8_t) text[text_lines[i].chars[j].position_in_text]] + DEFINITIONS_DEFAULT[font].image_offset - 1;
            }
            if (letter_id > 0) {
                image_draw_letter(letter_id, text_lines[i].chars[j].x_start, text_lines[i].line_y, color);
            }
        }
    }
}

static void draw_input_field(int width, int height)
{
    inner_panel_draw(input_text_x - 10, input_text_y - 10, width, height);
    draw_text(input_text_string, input_text_font, COLOR_BLACK);
    if (text_field_active) { // draw cursor
        for (int yy = text_lines[input_text_cursor_current_line].line_y - 3; yy < text_lines[input_text_cursor_current_line].line_y + DEFINITIONS_DEFAULT[input_text_font].line_height + 3; yy++) { // cursor height is line height + 6px
            graphics_draw_horizontal_line(input_text_x + input_text_cursor_current_x_offset, input_text_x + 1 + input_text_cursor_current_x_offset, yy, COLOR_WHITE); // line width is 1
        }
    }
}

static void draw_trade_city_info_editor_empire(void)
{
    // draw arrow button for city type switching
    draw_arrow_button(21, empire_editor_city_type_arrow_x, empire_y_max - 108, 3);
    // draw "Buys" and the resources to buy
    text_draw("Buys:", empire_editor_city_type_arrow_x + 56, empire_y_max - 103, FONT_NORMAL_GREEN, COLOR_BLACK);
    empire_editor_resource_toggle_x = empire_editor_city_type_arrow_x + 112;
    for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
        if (selected_empire_object->resource_buy_limit[r]) {
            draw_resource_trade_city(r, selected_empire_object->resource_buy_limit[r], empire_editor_resource_toggle_x + 32 * (r - 1), empire_y_max - 108);
        } else {
            image_draw_blend(871, empire_editor_resource_toggle_x + 32 * (r - 1), empire_y_max - 108, COLOR_MOUSE_DARK_GRAY);
        }
    }
    // draw "Sells" and the resources to sell
    text_draw("Sells:", empire_editor_city_type_arrow_x + 56, empire_y_max - 63, FONT_NORMAL_GREEN, COLOR_BLACK);
    for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
        if (selected_empire_object->resource_sell_limit[r]) {
            draw_resource_trade_city(r, selected_empire_object->resource_sell_limit[r], empire_editor_resource_toggle_x + 32 * (r - 1), empire_y_max - 68);
        } else {
            image_draw_blend(871, empire_editor_resource_toggle_x + 32 * (r - 1), empire_y_max - 68, COLOR_MOUSE_DARK_GRAY);
        }
    }
    // draw the trade route cost
    text_draw("Trade route open cost:", empire_editor_resource_toggle_x + 500, empire_y_max - 103, FONT_NORMAL_GREEN, 0);
    if (mouse_x >= empire_editor_resource_toggle_x + 683 && mouse_x < empire_editor_resource_toggle_x + 747
    && mouse_y >= empire_y_max - 108 && mouse_y < empire_y_max - 84) {
        button_border_draw(empire_editor_resource_toggle_x + 683, empire_y_max - 108, 64, 24, 1);
    } else {
        button_border_draw(empire_editor_resource_toggle_x + 683, empire_y_max - 108, 64, 24, 0);
    }
    text_draw_number_centered(selected_empire_object->trade_route_cost, empire_editor_resource_toggle_x + 683, empire_y_max - 102, 64, FONT_NORMAL_GREEN);
    if (text_field_active == 1) {
        draw_input_field(4, 2);
    }
}

static struct empire_object_t *get_trade_city_by_trade_route(int trade_route_id)
{
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        if (empire_objects[i].in_use
        && (empire_objects[i].city_type == EMPIRE_CITY_TRADE || empire_objects[i].city_type == EMPIRE_CITY_FUTURE_TRADE)
        && empire_objects[i].trade_route_id == trade_route_id) {
            return &empire_objects[i];
        }
    }
    return 0;
}

static int empire_object_update_animation(struct empire_object_t *obj, int image_id)
{
    if (obj->animation_index <= 0) {
        obj->animation_index = 1;
    }
    struct image_t *img = image_get(image_id);
    if (!timers[img->animation_speed_id].should_update) {
        return obj->animation_index;
    }
    if (img->animation_can_reverse) {
        int is_reverse = 0;
        if (obj->animation_index & 0x80) {
            is_reverse = 1;
        }
        int current_sprite = obj->animation_index & 0x7f;
        if (is_reverse) {
            obj->animation_index = current_sprite - 1;
            if (obj->animation_index < 1) {
                obj->animation_index = 1;
                is_reverse = 0;
            }
        } else {
            obj->animation_index = current_sprite + 1;
            if (obj->animation_index > img->num_animation_sprites) {
                obj->animation_index = img->num_animation_sprites;
                is_reverse = 1;
            }
        }
        if (is_reverse) {
            obj->animation_index = obj->animation_index | 0x80;
        }
    } else {
        // Absolutely normal case
        obj->animation_index++;
        if (obj->animation_index > img->num_animation_sprites) {
            obj->animation_index = 1;
        }
    }
    return obj->animation_index;
}

static void graphics_draw_inset_rect(int x, int y, int width, int height)
{
    graphics_draw_horizontal_line(x, x + width - 1, y, COLOR_INSET_DARK);
    graphics_draw_vertical_line(x + width - 1, y, y + height - 1, COLOR_INSET_LIGHT);
    graphics_draw_horizontal_line(x, x + width - 1, y + height - 1, COLOR_INSET_LIGHT);
    graphics_draw_vertical_line(x, y, y + height - 1, COLOR_INSET_DARK);
}

static void select_empire_object(int x, int y)
{
    int min_dist = 10000;
    struct empire_object_t *obj = 0;
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        int obj_x, obj_y;
        if (scenario.empire.is_expanded) {
            obj_x = empire_objects[i].expanded.x;
            obj_y = empire_objects[i].expanded.y;
        } else {
            obj_x = empire_objects[i].x;
            obj_y = empire_objects[i].y;
        }
        if ((empire_objects[i].type == EMPIRE_OBJECT_CITY && obj_x - 10 < x && obj_x + empire_objects[i].width + 6 >= x && obj_y <= y && obj_y + empire_objects[i].height + 16 > y)
        || (editor_active && empire_objects[i].type == EMPIRE_OBJECT_ORNAMENT && empire_objects[i].in_use && empire_objects[i].image_id == 3323 && obj_x - 6 < x && obj_x + empire_objects[i].width + 6 >= x && obj_y - 6 <= y && obj_y + empire_objects[i].height + 6 > y)) {
            int dist = calc_maximum_distance(x, y, obj_x + empire_objects[i].width / 2, obj_y + empire_objects[i].height / 2);
            if (dist < min_dist) {
                min_dist = dist;
                obj = &empire_objects[i];
            }
        }
    }
    selected_empire_object = obj;
}

static int can_place_building_editor(struct map_tile_t *tile, int num_tiles, int *blocked_tiles)
{
    int blocked = 0;
    for (int i = 0; i < num_tiles; i++) {
        int tile_offset = tile->grid_offset + TILE_GRID_OFFSETS_EDITOR[i];
        if ((terrain_grid.items[tile_offset] & TERRAIN_NOT_CLEAR) || (map_grid_is_valid_offset(tile_offset) && map_figures.items[tile_offset] > 0)) {
            blocked = 1;
            if (blocked_tiles) blocked_tiles[i] = 1;
        } else {
            if (blocked_tiles) blocked_tiles[i] = 0;
        }
    }
    return !blocked;
}

static void draw_flat_tile(int x, int y, uint32_t color_mask)
{
    if (color_mask == COLOR_MASK_GREEN && scenario.climate != CLIMATE_DESERT) {
        image_draw_blend_alpha(733, x, y, ALPHA_MASK_SEMI_TRANSPARENT | color_mask);
    } else {
        image_draw_blend(733, x, y, color_mask);
    }
}

static void draw_partially_blocked(int x, int y, int num_tiles, int *blocked_tiles)
{
    for (int i = 0; i < num_tiles; i++) {
        int x_offset = x + TILE_X_VIEW_OFFSETS[i];
        int y_offset = y + TILE_Y_VIEW_OFFSETS[i];
        if (blocked_tiles[i]) {
            draw_flat_tile(x_offset, y_offset, COLOR_MASK_RED);
        } else {
            draw_flat_tile(x_offset, y_offset, COLOR_MASK_GREEN);
        }
    }
}

static void draw_building_image(int image_id, int x, int y)
{
    image_draw_isometric_footprint(image_id, x, y, COLOR_MASK_GREEN);
    image_draw_isometric_top(image_id, x, y, COLOR_MASK_GREEN);
}

static void draw_building_editor(struct map_tile_t *tile, int x_view, int y_view, int type)
{
    int num_tiles = building_properties[type].size * building_properties[type].size;
    int blocked_tiles[MAX_TILES_OFFSETS];
    int blocked = !can_place_building_editor(tile, num_tiles, blocked_tiles);
    if (blocked) {
        draw_partially_blocked(x_view, y_view, num_tiles, blocked_tiles);
    } else if (tool_data.build_in_progress) {
        int image_id = 548;
        for (int i = 0; i < num_tiles; i++) {
            int x_offset = x_view + TILE_X_VIEW_OFFSETS[i];
            int y_offset = y_view + TILE_Y_VIEW_OFFSETS[i];
            image_draw_isometric_footprint(image_id, x_offset, y_offset, 0);
        }
    } else {
        if (type == BUILDING_NATIVE_HUT) {
            draw_building_image(2830, x_view, y_view);
        } else if (type == BUILDING_NATIVE_CROPS) {
            draw_building_image(2833, x_view, y_view);
        } else if (type == BUILDING_NATIVE_MEETING) {
            draw_building_image(2832, x_view, y_view);
        } else if (type == BUILDING_HOUSE_VACANT_LOT) {
            draw_building_image(2826, x_view, y_view);
        }
    }
}

static int is_clear_terrain(struct map_tile_t *tile, int *warning)
{
    int result = !map_terrain_is(tile->grid_offset, TERRAIN_NOT_CLEAR ^ TERRAIN_ROAD);
    if (!result && warning) {
        *warning = WARNING_EDITOR_CANNOT_PLACE;
    }
    return result;
}

static int is_edge(struct map_tile_t *tile, int *warning)
{
    int result = tile->x == 0 || tile->y == 0 || tile->x == map_data.width - 1 || tile->y == map_data.height - 1;
    if (!result && warning) {
        *warning = WARNING_EDITOR_NEED_MAP_EDGE;
    }
    return result;
}

static int can_place_flag_editor(int type, struct map_tile_t *tile, int *warning)
{
    switch (type) {
        case TOOL_ENTRY_POINT:
        case TOOL_EXIT_POINT:
        case TOOL_INVASION_POINT:
            return is_clear_terrain(tile, warning) && is_edge(tile, warning);
        case TOOL_EARTHQUAKE_POINT:
        case TOOL_HERD_POINT:
            return is_clear_terrain(tile, warning);
        case TOOL_FISHING_POINT:
        {
            int is_water = map_terrain_is(tile->grid_offset, TERRAIN_WATER);
            if (!is_water && warning) {
                *warning = WARNING_EDITOR_NEED_OPEN_WATER;
            }
            return is_water;
        }
        case TOOL_RIVER_ENTRY_POINT:
        case TOOL_RIVER_EXIT_POINT:
        {
            int is_deep_water = map_terrain_is(tile->grid_offset, TERRAIN_WATER) && map_terrain_count_directly_adjacent_with_type(tile->grid_offset, TERRAIN_WATER) == 4;
            if (!is_deep_water && warning) {
                *warning = WARNING_EDITOR_NEED_OPEN_WATER;
            }
            return is_edge(tile, warning) && is_deep_water;
        }
        default:
            return 0;
    }
}

static int can_place_access_ramp_editor(struct map_tile_t *tile, int *orientation_index)
{
    if (!map_grid_is_inside(tile->x, tile->y, 2)) {
        return 0;
    }
    for (int orientation = 0; orientation < 4; orientation++) {
        int right_tiles = 0;
        int top_elevation = 0;
        for (int index = 0; index < 6; index++) {
            int tile_offset = tile->grid_offset + ACCESS_RAMP_TILE_OFFSETS_BY_ORIENTATION[orientation][index];
            int elevation = terrain_elevation.items[tile_offset];
            if (index < 2) {
                if (map_terrain_is(tile_offset, TERRAIN_ELEVATION)) {
                    right_tiles++;
                }
                top_elevation = elevation;
            } else if (index < 4) {
                if (map_terrain_is(tile_offset, TERRAIN_ELEVATION)) {
                    if (elevation != top_elevation) {
                        right_tiles++;
                    }
                } else if (elevation >= top_elevation) {
                    right_tiles++;
                }
            } else {
                if (elevation < top_elevation) {
                    right_tiles++;
                }
            }
        }
        if (right_tiles == 6) {
            if (orientation_index) {
                *orientation_index = orientation;
            }
            return 1;
        }
    }
    return 0;
}

static void update_city_view_coords(int x, int y, struct map_tile_t *tile)
{
    struct pixel_view_coordinates_t view;
    if (x < view_data.viewport.x ||
            x >= view_data.viewport.x + view_data.viewport.width_pixels ||
            y < view_data.viewport.y ||
            y >= view_data.viewport.y + view_data.viewport.height_pixels) {
        tile->grid_offset = tile->x = tile->y = 0;
    } else {
        x += view_data.camera.pixel.x;
        y += view_data.camera.pixel.y;
        int odd = ((x - view_data.viewport.x) / HALF_TILE_WIDTH_PIXELS + (y - view_data.viewport.y) / HALF_TILE_HEIGHT_PIXELS) & 1;
        int x_is_odd = ((x - view_data.viewport.x) / HALF_TILE_WIDTH_PIXELS) & 1;
        int y_is_odd = ((y - view_data.viewport.y) / HALF_TILE_HEIGHT_PIXELS) & 1;
        int x_mod = ((x - view_data.viewport.x) % HALF_TILE_WIDTH_PIXELS) / 2;
        int y_mod = (y - view_data.viewport.y) % HALF_TILE_HEIGHT_PIXELS;
        int x_view_offset = (x - view_data.viewport.x) / TILE_WIDTH_PIXELS;
        int y_view_offset = (y - view_data.viewport.y) / HALF_TILE_HEIGHT_PIXELS;
        if (odd) {
            if (x_mod + y_mod >= HALF_TILE_HEIGHT_PIXELS - 1) {
                y_view_offset++;
                if (x_is_odd && !y_is_odd) {
                    x_view_offset++;
                }
            }
        } else {
            if (y_mod > x_mod) {
                y_view_offset++;
            } else if (x_is_odd && y_is_odd) {
                x_view_offset++;
            }
        }
        view.x = view_data.camera.tile.x + x_view_offset;
        view.y = view_data.camera.tile.y + y_view_offset;
        int grid_offset = view_to_grid_offset_lookup[view.x][view.y];
        tile->grid_offset = grid_offset < 0 ? 0 : grid_offset;
        x_view_offset = view.x - view_data.camera.tile.x;
        y_view_offset = view.y - view_data.camera.tile.y;
        view_data.selected_tile.x_pixels = view_data.viewport.x + TILE_WIDTH_PIXELS * x_view_offset - view_data.camera.pixel.x;
        if (y_view_offset & 1) {
            view_data.selected_tile.x_pixels -= HALF_TILE_WIDTH_PIXELS;
        }
        view_data.selected_tile.y_pixels = view_data.viewport.y + HALF_TILE_HEIGHT_PIXELS * y_view_offset - HALF_TILE_HEIGHT_PIXELS - view_data.camera.pixel.y;
        tile->x = map_grid_offset_to_x(tile->grid_offset);
        tile->y = map_grid_offset_to_y(tile->grid_offset);
    }
}

static void draw_elevation_brush_tiles(void)
{
    for (int dy = -1; dy < 2; dy++) {
        for (int dx = -1; dx < 2; dx++) {
            draw_flat_tile(view_data.selected_tile.x_pixels + (dx - dy) * 30, view_data.selected_tile.y_pixels + (dx + dy) * 15, COLOR_MASK_GREEN);
        }
    }
}

static void draw_brush_tiles(int brush_draw_criteria)
{
    for (int dy = -tool_data.brush_size; dy <= tool_data.brush_size; dy++) {
        for (int dx = -tool_data.brush_size; dx <= tool_data.brush_size; dx++) {
            if (abs(dx) + abs(dy) <= tool_data.brush_size) {
                if (terrain_grid.items[map_data.start_offset + current_tile.x + dx + (current_tile.y + dy) * GRID_SIZE] & brush_draw_criteria) {
                    draw_flat_tile(view_data.selected_tile.x_pixels + (dx - dy) * 30, view_data.selected_tile.y_pixels + (dx + dy) * 15, COLOR_MASK_RED);
                } else {
                    draw_flat_tile(view_data.selected_tile.x_pixels + (dx - dy) * 30, view_data.selected_tile.y_pixels + (dx + dy) * 15, COLOR_MASK_GREEN);
                }
            }
        }
    }
}

static void draw_editor_map(void)
{
    graphics_set_clip_rectangle(0, TOP_BAR_HEIGHT, sidebar_x_offset, current_resolution_height);
    draw_context_water.advance_water_animation = 0;
    if (current_time - draw_context_water.last_water_animation_time > 60) {
        draw_context_water.last_water_animation_time = current_time;
        draw_context_water.advance_water_animation = 1;
    }
    draw_context_water.image_id_water_first = 364;
    draw_context_water.image_id_water_last = 369; // 371 is the last?
    // draw ground tiles
    int odd = 0;
    int x_view = 0;
    int y_view = view_data.camera.tile.y - 8;
    int x_graphic = 0;
    int y_graphic = view_data.viewport.y - 9 * HALF_TILE_HEIGHT_PIXELS - view_data.camera.pixel.y;
    for (int y = 0; y < view_data.viewport.height_tiles + 21; y++) {
        if (y_view >= 0 && y_view < VIEW_Y_MAX) {
            x_graphic = -(4 * TILE_WIDTH_PIXELS) - view_data.camera.pixel.x;
            if (odd) {
                x_graphic += view_data.viewport.x - HALF_TILE_WIDTH_PIXELS;
            } else {
                x_graphic += view_data.viewport.x;
            }
            x_view = view_data.camera.tile.x - 4;
            for (int x = 0; x < view_data.viewport.width_tiles + 7; x++) {
                if (x_view >= 0 && x_view < VIEW_X_MAX) {
                    if (view_to_grid_offset_lookup[x_view][y_view] < 0) {
                        // Outside map: draw black tile
                        image_draw_isometric_footprint_from_draw_tile(245, x_graphic, y_graphic, 0);
                    } else {
                        if (edge_grid.items[view_to_grid_offset_lookup[x_view][y_view]] & EDGE_LEFTMOST_TILE) {
                            // Valid grid_offset and leftmost tile -> draw
                            int image_id = images.items[view_to_grid_offset_lookup[x_view][y_view]];
                            if (draw_context_water.advance_water_animation &&
                                image_id >= draw_context_water.image_id_water_first &&
                                image_id <= draw_context_water.image_id_water_last) {
                                image_id++;
                                if (image_id > draw_context_water.image_id_water_last) {
                                    image_id = draw_context_water.image_id_water_first;
                                }
                                images.items[view_to_grid_offset_lookup[x_view][y_view]] = image_id;
                            }
                            image_draw_isometric_footprint_from_draw_tile(image_id, x_graphic, y_graphic, 0);
                        }
                        int figure_id = map_grid_is_valid_offset(view_to_grid_offset_lookup[x_view][y_view]) ? map_figures.items[view_to_grid_offset_lookup[x_view][y_view]] : 0;
                        while (figure_id) {
                            struct figure_t *f = &figures[figure_id];
                            city_draw_figure(f, x_graphic, y_graphic, 0);
                            figure_id = f->next_figure_id_on_same_tile;
                        }
                    }
                }
                x_graphic += TILE_WIDTH_PIXELS;
                x_view++;
            }
            x_graphic = -(4 * TILE_WIDTH_PIXELS) - view_data.camera.pixel.x;
            if (odd) {
                x_graphic += view_data.viewport.x - HALF_TILE_WIDTH_PIXELS;
            } else {
                x_graphic += view_data.viewport.x;
            }
            x_view = view_data.camera.tile.x - 4;
            for (int x = 0; x < view_data.viewport.width_tiles + 7; x++) {
                if (x_view >= 0 && x_view < VIEW_X_MAX) {
                    int grid_offset = view_to_grid_offset_lookup[x_view][y_view];
                    if (grid_offset >= 0) {
                        if (!(edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE)) {
                            break;
                        }
                        int image_id = images.items[grid_offset];
                        uint32_t color_mask = 0;
                        image_draw_isometric_top_from_draw_tile(image_id, x_graphic, y_graphic, color_mask);
                    }
                }
                x_graphic += TILE_WIDTH_PIXELS;
                x_view++;
            }
        }
        odd = 1 - odd;
        y_graphic += HALF_TILE_HEIGHT_PIXELS;
        y_view++;
    }
    update_city_view_coords(mouse_x, mouse_y, &current_tile);
    // draw editor tool
    if (current_tile.grid_offset && !scroll_data.drag.active) {
        switch (tool_data.type) {
            case TOOL_NATIVE_HUT:
                draw_building_editor(&current_tile, view_data.selected_tile.x_pixels, view_data.selected_tile.y_pixels, BUILDING_NATIVE_HUT);
                break;
            case TOOL_NATIVE_FIELD:
                draw_building_editor(&current_tile, view_data.selected_tile.x_pixels, view_data.selected_tile.y_pixels, BUILDING_NATIVE_CROPS);
                break;
            case TOOL_NATIVE_CENTER:
                draw_building_editor(&current_tile, view_data.selected_tile.x_pixels, view_data.selected_tile.y_pixels, BUILDING_NATIVE_MEETING);
                break;
            case TOOL_HOUSE_VACANT_LOT:
                draw_building_editor(&current_tile, view_data.selected_tile.x_pixels, view_data.selected_tile.y_pixels, BUILDING_HOUSE_VACANT_LOT);
                break;
            case TOOL_EARTHQUAKE_POINT:
            case TOOL_ENTRY_POINT:
            case TOOL_EXIT_POINT:
            case TOOL_RIVER_ENTRY_POINT:
            case TOOL_RIVER_EXIT_POINT:
            case TOOL_INVASION_POINT:
            case TOOL_FISHING_POINT:
            case TOOL_HERD_POINT:
                draw_flat_tile(view_data.selected_tile.x_pixels, view_data.selected_tile.y_pixels, can_place_flag_editor(tool_data.type, &current_tile, 0) ? COLOR_MASK_GREEN : COLOR_MASK_RED);
                break;
            case TOOL_ACCESS_RAMP:
            {
                int orientation;
                if (can_place_access_ramp_editor(&current_tile, &orientation)) {
                    draw_building_image(845 + orientation, view_data.selected_tile.x_pixels, view_data.selected_tile.y_pixels);
                } else {
                    int blocked[4] = { 1, 1, 1, 1 };
                    draw_partially_blocked(view_data.selected_tile.x_pixels, view_data.selected_tile.y_pixels, 4, blocked);
                }
                break;
            }
            case TOOL_GRASS:
                draw_brush_tiles(TERRAIN_ELEVATION | TERRAIN_ACCESS_RAMP);
                break;
            case TOOL_SMALL_SHRUB:
            case TOOL_MEDIUM_SHRUB:
            case TOOL_LARGE_SHRUB:
            case TOOL_LARGEST_SHRUB:
            case TOOL_WATER:
            case TOOL_TREES:
            case TOOL_SMALL_ROCK:
            case TOOL_MEDIUM_ROCK:
            case TOOL_LARGE_ROCK:
            case TOOL_MEADOW:
                draw_brush_tiles(TERRAIN_NOT_DISPLACEABLE);
                break;
            case TOOL_RAISE_LAND:
            case TOOL_LOWER_LAND:
                draw_elevation_brush_tiles();
                break;
            case TOOL_ROAD:
            {
                int blocked = 0;
                int image_id = 0;
                if (map_terrain_is(current_tile.grid_offset, TERRAIN_NOT_CLEAR)) {
                    blocked = 1;
                } else {
                    image_id = 591;
                    if (!map_terrain_has_adjacent_x_with_type(current_tile.grid_offset, TERRAIN_ROAD) &&
                        map_terrain_has_adjacent_y_with_type(current_tile.grid_offset, TERRAIN_ROAD)) {
                        image_id++;
                    }
                }
                if (blocked) {
                    draw_flat_tile(view_data.selected_tile.x_pixels, view_data.selected_tile.y_pixels, COLOR_MASK_RED);
                } else {
                    draw_building_image(image_id, view_data.selected_tile.x_pixels, view_data.selected_tile.y_pixels);
                }
                break;
            }
        }
    }
    graphics_reset_clip_rectangle();
}

static void toggle_fullscreen(void)
{
    if (settings[SETTINGS_FULLSCREEN].config_value) {
        SDL_SetWindowSize(SDL.window, settings[SETTINGS_WINDOW_WIDTH].config_value, settings[SETTINGS_WINDOW_HEIGHT].config_value);
        SDL_SetWindowFullscreen(SDL.window, 0);
        settings[SETTINGS_FULLSCREEN].config_value = 0;
    } else {
        SDL_SetWindowFullscreen(SDL.window, SDL_WINDOW_FULLSCREEN_DESKTOP);
        SDL_SetWindowDisplayMode(SDL.window, 0);
        settings[SETTINGS_FULLSCREEN].config_value = 1;
    }
}

static void reset_screen(void)
{
    if (SDL_GetWindowFlags(SDL.window) & SDL_WINDOW_MAXIMIZED) {
        SDL_RestoreWindow(SDL.window);
    }
    SDL_SetWindowFullscreen(SDL.window, 0);
    SDL_SetWindowSize(SDL.window, MINIMUM_RESOLUTION_X, MINIMUM_RESOLUTION_Y);
    SDL_SetWindowPosition(SDL.window, SDL_WINDOWPOS_CENTERED_DISPLAY(0), SDL_WINDOWPOS_CENTERED_DISPLAY(0));
    settings[SETTINGS_FULLSCREEN].config_value = 0;
}

static void stop_sound_channel(int channel)
{
    struct sound_channel_t *ch = &sound_channels[channel];
    if (ch->chunk) {
        Mix_HaltChannel(channel);
        Mix_FreeChunk(ch->chunk);
        ch->chunk = 0;
    }
}

static int text_draw_percentage(int value, int x_offset, int y_offset, int font)
{
    char str[NUMBER_BUFFER_LENGTH];
    number_to_string(str, value, '@', "%");
    return text_draw(str, x_offset, y_offset, font, 0);
}

static int building_construction_is_updatable(void)
{
    switch (construction_data.type) {
        case BUILDING_HOUSE_VACANT_LOT:
        case BUILDING_CLEAR_LAND:
        case BUILDING_ROAD:
        case BUILDING_GARDENS:
        case BUILDING_PLAZA:
        case BUILDING_WALL:
            return 1;
        default:
            return 0;
    }
}

static void map_property_restore(void)
{
    memcpy(bitfields_grid.items, bitfields_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memcpy(edge_grid.items, edge_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
}

static void restore_map_images(void)
{
    for (int y = 0; y < map_data.height; y++) {
        for (int x = 0; x < map_data.width; x++) {
            int grid_offset = map_grid_offset(x, y);
            if (!map_building_at(grid_offset)) {
                images.items[grid_offset] = images_backup.items[grid_offset];
            }
        }
    }
}

static void game_undo_restore_map(int include_properties)
{
    memcpy(terrain_grid.items, terrain_grid_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
    memcpy(aqueduct.items, aqueduct_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    if (include_properties) {
        map_property_restore();
    }
    restore_map_images();
}

static void building_construction_cancel(void)
{
    map_property_clear_constructing_and_deleted();
    if (construction_data.in_progress && building_construction_is_updatable()) {
        game_undo_restore_map(1);
        construction_data.in_progress = 0;
        construction_data.cost_preview = 0;
    } else {
        building_construction_clear_type();
    }
}

static void clear_map_data(void)
{
    memset(images.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
    map_building_clear();
    memset(terrain_grid.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
    memset(aqueduct.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memset(map_figures.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
    map_property_clear();
    memset(sprite.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memset(random.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memset(desirability_grid.items, 0, GRID_SIZE * GRID_SIZE * sizeof(int8_t));
    memset(terrain_elevation.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memset(network.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    for (int i = 0; i < CONTEXT_MAX_ITEMS; i++) {
        clear_current_offset(context_pointers[i].context, context_pointers[i].size);
    }
    int y_start = (GRID_SIZE - map_data.height) / 2;
    int x_start = (GRID_SIZE - map_data.width) / 2;
    for (int y = 0; y < GRID_SIZE; y++) {
        int y_outside_map = y < y_start || y >= y_start + map_data.height;
        for (int x = 0; x < GRID_SIZE; x++) {
            if (y_outside_map || x < x_start || x >= x_start + map_data.width) {
                terrain_grid.items[x + GRID_SIZE * y] = TERRAIN_SHRUB | TERRAIN_WATER;
            }
        }
    }
    map_random_init();
    for (int y = 0; y < map_data.height; y++) {
        for (int x = 0; x < map_data.width; x++) {
            int grid_offset = map_grid_offset(x, y);
            if (random.items[grid_offset] & 1) {
                bitfields_grid.items[grid_offset] |= BIT_ALTERNATE_TERRAIN;
            }
        }
    }
}

static void prepare_map_for_editing(int map_is_new)
{
    load_main_graphics(scenario.climate, 1);
    if (map_is_new) {
        empire_load();
        set_resources_sell_our_city();
    }
    figure_init_scenario();
    for (int id = MAP_FLAG_MIN; id < MAP_FLAG_MAX; id++) {
        figure_create(FIGURE_MAP_FLAG, -1, -1, 0)->resource_id = id;
    }
    figure_create_flotsam();
    map_tiles_update_all_elevation();
    map_tiles_update_all_earthquake();
    map_tiles_update_all_empty_land();
    map_tiles_update_all_roads();
    map_tiles_update_all_plazas();
    map_tiles_update_all_walls();
    map_tiles_update_all_aqueducts(0);
    int native_image = 2830;
    int grid_offset = map_data.start_offset;
    for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            if (!map_terrain_is(grid_offset, TERRAIN_BUILDING) || map_building_at(grid_offset)) {
                continue;
            }
            int type;
            if (images.items[grid_offset] == scenario.native_images.hut) {
                type = BUILDING_NATIVE_HUT;
                images.items[grid_offset] = native_image;
            } else if (images.items[grid_offset] == scenario.native_images.hut + 1) {
                type = BUILDING_NATIVE_HUT;
                images.items[grid_offset] = native_image + 1;
            } else if (images.items[grid_offset] == scenario.native_images.meeting) {
                type = BUILDING_NATIVE_MEETING;
                images.items[grid_offset] = native_image + 2;
                images.items[grid_offset + map_grid_delta(1, 0)] = native_image + 2;
                images.items[grid_offset + map_grid_delta(0, 1)] = native_image + 2;
                images.items[grid_offset + map_grid_delta(1, 1)] = native_image + 2;
            } else if (images.items[grid_offset] == scenario.native_images.crops) {
                type = BUILDING_NATIVE_CROPS;
                images.items[grid_offset] = 2833;
            } else if (images.items[grid_offset] == 2826) {
                type = BUILDING_HOUSE_VACANT_LOT;
                images.items[grid_offset] = 2826;
            } else { //unknown building
                map_building_tiles_remove(0, x, y);
                continue;
            }
            struct building_t *b = building_create(type, x, y);
            b->state = BUILDING_STATE_IN_USE;
            buildings_grid.items[grid_offset] = b->id;
            if (type == BUILDING_NATIVE_MEETING) {
                buildings_grid.items[grid_offset + map_grid_delta(1, 0)] = b->id;
                buildings_grid.items[grid_offset + map_grid_delta(0, 1)] = b->id;
                buildings_grid.items[grid_offset + map_grid_delta(1, 1)] = b->id;
            }
        }
    }
    map_routing_update_all();
    city_view_init();
    state_data.paused = 0;
}

static void button_ok_cancel(void)
{
    if (input_text_string[0]) {
        string_copy(input_text_string, file_dialog_data.selected_file, FILE_NAME_LENGTH_MAX);
        if (file_dialog_data.type == FILE_TYPE_SCENARIO) {
            strcat(file_dialog_data.selected_file, ".map");
        } else if (file_dialog_data.type == FILE_TYPE_SAVED_GAME) {
            strcat(file_dialog_data.selected_file, ".sav");
        }
    }
    if (file_dialog_data.type == FILE_TYPE_SAVED_GAME) {
        if (file_dialog_data.dialog_type != FILE_DIALOG_SAVE && !file_exists(SAVES_DIR_PATH, file_dialog_data.selected_file)) {
            file_dialog_data.message_not_exist_start_time = current_time;
            return;
        }
        if (file_dialog_data.dialog_type == FILE_DIALOG_SAVE) {
            game_file_io_write_saved_game(SAVES_DIR_PATH, file_dialog_data.selected_file);
            show_city_window();
        } else if (file_dialog_data.dialog_type == FILE_DIALOG_LOAD) {
            game_state_init();
            init_savegame_data();
            SDL_LogInfo(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Loading saved game", file_dialog_data.selected_file, 0));
            static char dir_prepended_filepath[DIR_PATH_MAX];
            prepend_dir_to_path(SAVES_DIR_PATH, file_dialog_data.selected_file, dir_prepended_filepath);
            fp = fopen(dir_prepended_filepath, "rb");
            if (!fp) {
                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to load game", 0, 0));
                file_dialog_data.message_not_exist_start_time = current_time;
                return;
            }
            int result = 0;
            for (int i = 0; i < savegame_data.num_pieces; i++) {
                struct file_piece_t *piece = &savegame_data.pieces[i];
                result = fread(piece->buf.data, 1, piece->buf.size, fp) == (unsigned) piece->buf.size;
                // The last piece may be smaller than buf.size
                if (!result && i != (savegame_data.num_pieces - 1)) {
                    SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to load game", 0, 0));
                    fclose(fp);
                    file_dialog_data.message_not_exist_start_time = current_time;
                    return;
                }
            }
            fclose(fp);
            buffer_read_raw(savegame_data.state.player_name, scenario_settings.player_name, MAX_PLAYER_NAME_LENGTH);
            map_image_load_state(savegame_data.state.image_grid);
            for (int i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                buildings_grid.items[i] = buffer_read_u16(savegame_data.state.building_grid);
            }
            buffer_read_raw(savegame_data.state.building_damage_grid, damage_grid.items, GRID_SIZE * GRID_SIZE);
            map_terrain_load_state(savegame_data.state.terrain_grid);
            buffer_read_raw(savegame_data.state.aqueduct_grid, aqueduct.items, GRID_SIZE * GRID_SIZE);
            buffer_read_raw(savegame_data.state.aqueduct_backup_grid, aqueduct_backup.items, GRID_SIZE * GRID_SIZE);
            for (int i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                map_figures.items[i] = buffer_read_u16(savegame_data.state.figure_grid);
            }
            buffer_read_raw(savegame_data.state.sprite_grid, sprite.items, GRID_SIZE * GRID_SIZE);
            buffer_read_raw(savegame_data.state.sprite_backup_grid, sprite_backup.items, GRID_SIZE * GRID_SIZE);
            map_property_load_state(savegame_data.state.bitfields_grid, savegame_data.state.edge_grid);
            buffer_read_raw(savegame_data.state.random_grid, random.items, GRID_SIZE * GRID_SIZE);
            buffer_read_raw(savegame_data.state.desirability_grid, desirability_grid.items, GRID_SIZE * GRID_SIZE);
            for (int i = 0; i < MAX_FIGURES; i++) {
                figures[i].in_use = buffer_read_u8(savegame_data.state.figures);
                figures[i].is_targetable = buffer_read_u8(savegame_data.state.figures);
                figures[i].is_corpse = buffer_read_u8(savegame_data.state.figures);
                figures[i].type = buffer_read_u8(savegame_data.state.figures);
                figures[i].action_state = buffer_read_u8(savegame_data.state.figures);
                figures[i].is_fleeing = buffer_read_u8(savegame_data.state.figures);
                figures[i].formation_id = buffer_read_u8(savegame_data.state.figures);
                figures[i].index_in_formation = buffer_read_u8(savegame_data.state.figures);
                figures[i].damage = buffer_read_u8(savegame_data.state.figures);
                figures[i].is_military_trained = buffer_read_u8(savegame_data.state.figures);
                figures[i].mounted_charge_ticks = buffer_read_u8(savegame_data.state.figures);
                figures[i].mounted_charge_ticks_max = buffer_read_u8(savegame_data.state.figures);
                figures[i].target_figure_id = buffer_read_u16(savegame_data.state.figures);
                for (int j = 0; j < MAX_MELEE_TARGETERS_PER_UNIT; j++) {
                    figures[j].melee_targeter_ids[j] = buffer_read_u16(savegame_data.state.figures);
                }
                for (int j = 0; j < MAX_MELEE_COMBATANTS_PER_UNIT; j++) {
                    figures[j].melee_combatant_ids[j] = buffer_read_u16(savegame_data.state.figures);
                }
                figures[i].num_melee_combatants = buffer_read_u8(savegame_data.state.figures);
                for (int j = 0; j < MAX_RANGED_TARGETERS_PER_UNIT; j++) {
                    figures[j].ranged_targeter_ids[j] = buffer_read_u16(savegame_data.state.figures);
                }
                figures[i].prefect_recent_guard_duty = buffer_read_u8(savegame_data.state.figures);
                figures[i].attack_direction = buffer_read_i8(savegame_data.state.figures);
                figures[i].engaged_in_combat = buffer_read_u8(savegame_data.state.figures);
                figures[i].source_x = buffer_read_i8(savegame_data.state.figures);
                figures[i].source_y = buffer_read_i8(savegame_data.state.figures);
                figures[i].routing_path_id = buffer_read_u16(savegame_data.state.figures);
                figures[i].routing_path_current_tile = buffer_read_u16(savegame_data.state.figures);
                figures[i].routing_path_length = buffer_read_u16(savegame_data.state.figures);
                figures[i].terrain_usage = buffer_read_u8(savegame_data.state.figures);
                figures[i].speed_multiplier = buffer_read_u8(savegame_data.state.figures);
                figures[i].previous_tile_direction = buffer_read_i8(savegame_data.state.figures);
                figures[i].previous_tile_x = buffer_read_i8(savegame_data.state.figures);
                figures[i].previous_tile_y = buffer_read_i8(savegame_data.state.figures);
                figures[i].direction = buffer_read_i8(savegame_data.state.figures);
                figures[i].progress_on_tile = buffer_read_u8(savegame_data.state.figures);
                figures[i].x = buffer_read_i16(savegame_data.state.figures);
                figures[i].y = buffer_read_i16(savegame_data.state.figures);
                figures[i].grid_offset = buffer_read_u16(savegame_data.state.figures);
                figures[i].destination_x = buffer_read_i16(savegame_data.state.figures);
                figures[i].destination_y = buffer_read_i16(savegame_data.state.figures);
                figures[i].destination_grid_offset = buffer_read_u16(savegame_data.state.figures);
                figures[i].destination_building_id = buffer_read_u16(savegame_data.state.figures);
                figures[i].figure_is_halted = buffer_read_u8(savegame_data.state.figures);
                figures[i].use_cross_country = buffer_read_u8(savegame_data.state.figures);
                figures[i].cc_direction = buffer_read_u8(savegame_data.state.figures);
                figures[i].cross_country_x = buffer_read_u16(savegame_data.state.figures);
                figures[i].cross_country_y = buffer_read_u16(savegame_data.state.figures);
                figures[i].cc_delta_x = buffer_read_i16(savegame_data.state.figures);
                figures[i].cc_delta_y = buffer_read_i16(savegame_data.state.figures);
                figures[i].cc_delta_xy = buffer_read_i16(savegame_data.state.figures);
                figures[i].cc_destination_x = buffer_read_u16(savegame_data.state.figures);
                figures[i].cc_destination_y = buffer_read_u16(savegame_data.state.figures);
                figures[i].missile_offset = buffer_read_u8(savegame_data.state.figures);
                figures[i].roam_length = buffer_read_u16(savegame_data.state.figures);
                figures[i].roam_choose_destination = buffer_read_u8(savegame_data.state.figures);
                figures[i].roam_random_counter = buffer_read_u8(savegame_data.state.figures);
                figures[i].roam_turn_direction = buffer_read_i8(savegame_data.state.figures);
                figures[i].roam_ticks_until_next_turn = buffer_read_i8(savegame_data.state.figures);
                figures[i].in_building_wait_ticks = buffer_read_u8(savegame_data.state.figures);
                figures[i].height_adjusted_ticks = buffer_read_u8(savegame_data.state.figures);
                figures[i].current_height = buffer_read_u8(savegame_data.state.figures);
                figures[i].target_height = buffer_read_u8(savegame_data.state.figures);
                figures[i].next_figure_id_on_same_tile = buffer_read_u16(savegame_data.state.figures);
                figures[i].image_id = buffer_read_u16(savegame_data.state.figures);
                figures[i].image_offset = buffer_read_u8(savegame_data.state.figures);
                figures[i].attack_image_offset = buffer_read_u8(savegame_data.state.figures);
                figures[i].is_shooting = buffer_read_u8(savegame_data.state.figures);
                figures[i].cart_image_id = buffer_read_u16(savegame_data.state.figures);
                figures[i].x_offset_cart = buffer_read_i8(savegame_data.state.figures);
                figures[i].y_offset_cart = buffer_read_i8(savegame_data.state.figures);
                figures[i].enemy_image_group = buffer_read_u8(savegame_data.state.figures);
                figures[i].wait_ticks = buffer_read_i16(savegame_data.state.figures);
                figures[i].wait_ticks_missile = buffer_read_u8(savegame_data.state.figures);
                buffer_read_raw(savegame_data.state.figures, figures[i].name, FIGURE_MAX_NAME_LENGTH);
                figures[i].is_invisible = buffer_read_u8(savegame_data.state.figures);
                figures[i].building_id = buffer_read_u16(savegame_data.state.figures);
                figures[i].immigrant_building_id = buffer_read_u16(savegame_data.state.figures);
                figures[i].migrant_num_people = buffer_read_u8(savegame_data.state.figures);
                figures[i].min_max_seen = buffer_read_u8(savegame_data.state.figures);
                figures[i].empire_city_id = buffer_read_u8(savegame_data.state.figures);
                figures[i].resource_id = buffer_read_u8(savegame_data.state.figures);
                figures[i].collecting_item_id = buffer_read_u8(savegame_data.state.figures);
                figures[i].trader_id = buffer_read_u8(savegame_data.state.figures);
                figures[i].leading_figure_id = buffer_read_u16(savegame_data.state.figures);
                figures[i].trader_amount_bought = buffer_read_u8(savegame_data.state.figures);
                figures[i].loads_sold_or_carrying = buffer_read_u8(savegame_data.state.figures);
                figures[i].trade_ship_failed_dock_attempts = buffer_read_u8(savegame_data.state.figures);
                figures[i].flotsam_visible = buffer_read_u8(savegame_data.state.figures);
                figures[i].id = i;
            }
            for (int i = 0; i < MAX_ROUTES; i++) {
                figure_route_data.figure_ids[i] = buffer_read_i16(savegame_data.state.route_figures);
                buffer_read_raw(savegame_data.state.route_paths, figure_route_data.direction_paths[i], MAX_PATH_LENGTH);
            }
            selected_legion_formation = 0;
            for (int i = 0; i < MAX_LEGIONS; i++) {
                legion_formations[i].id = i;
                formation_load_state(savegame_data.state.legion_formations, &legion_formations[i]);
            }
            for (int i = 0; i < MAX_HERD_POINTS; i++) {
                herd_formations[i].id = i;
                formation_load_state(savegame_data.state.herd_formations, &herd_formations[i]);
            }
            for (int i = 0; i < MAX_ENEMY_FORMATIONS; i++) {
                enemy_formations[i].id = i;
                formation_load_state(savegame_data.state.enemy_formations, &enemy_formations[i]);
            }
            city_data.finance.tax_percentage = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.treasury = buffer_read_i32(savegame_data.state.city_data);
            city_data.sentiment.value = buffer_read_i32(savegame_data.state.city_data);
            city_data.health.target_value = buffer_read_i32(savegame_data.state.city_data);
            city_data.health.value = buffer_read_i32(savegame_data.state.city_data);
            city_data.health.num_hospital_workers = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.population = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.population_last_year = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.school_age = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.academy_age = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.total_capacity = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.room_in_houses = buffer_read_i32(savegame_data.state.city_data);
            for (int i = 0; i < 2400; i++) {
                city_data.population.monthly.values[i] = buffer_read_i32(savegame_data.state.city_data);
            }
            city_data.population.monthly.next_index = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.monthly.count = buffer_read_i32(savegame_data.state.city_data);
            for (int i = 0; i < 100; i++) {
                city_data.population.at_age[i] = buffer_read_i16(savegame_data.state.city_data);
            }
            for (int i = 0; i < 20; i++) {
                city_data.population.at_level[i] = buffer_read_i32(savegame_data.state.city_data);
            }
            city_data.population.yearly_births = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.yearly_deaths = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.lost_removal = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.immigration_amount_per_batch = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.emigration_amount_per_batch = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.emigration_queue_size = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.immigration_queue_size = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.lost_homeless = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.last_change = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.average_per_year = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.total_all_years = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.people_in_tents_shacks = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.people_in_villas_palaces = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.total_years = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.yearly_update_requested = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.last_used_house_add = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.last_used_house_remove = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.immigrated_today = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.emigrated_today = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.refused_immigrants_today = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.percentage = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.immigration_duration = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.emigration_duration = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.newcomers = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.last_used_warehouse = buffer_read_i16(savegame_data.state.city_data);
            city_data.building.senate_x = buffer_read_u8(savegame_data.state.city_data);
            city_data.building.senate_y = buffer_read_u8(savegame_data.state.city_data);
            city_data.building.senate_grid_offset = buffer_read_i16(savegame_data.state.city_data);
            city_data.building.senate_building_id = buffer_read_i32(savegame_data.state.city_data);
            for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
                city_data.resource.space_in_warehouses[i] = buffer_read_i16(savegame_data.state.city_data);
            }
            for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
                city_data.resource.stored_in_warehouses[i] = buffer_read_u16(savegame_data.state.city_data);
            }
            for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
                city_data.resource.trade_status[i] = buffer_read_i16(savegame_data.state.city_data);
            }
            for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
                city_data.resource.export_over[i] = buffer_read_i16(savegame_data.state.city_data);
            }
            for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
                city_data.resource.mothballed[i] = buffer_read_i16(savegame_data.state.city_data);
            }
            for (int i = 0; i < FOOD_TYPES_MAX; i++) {
                city_data.resource.granary_food_stored[i] = buffer_read_i32(savegame_data.state.city_data);
            }
            for (int i = 0; i < 6; i++) {
                city_data.resource.stored_in_workshops[i] = buffer_read_i32(savegame_data.state.city_data);
            }
            for (int i = 0; i < 6; i++) {
                city_data.resource.space_in_workshops[i] = buffer_read_i32(savegame_data.state.city_data);
            }
            city_data.resource.granary_total_stored = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.food_types_available = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.food_types_eaten = buffer_read_i32(savegame_data.state.city_data);
            for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
                city_data.resource.stockpiled[i] = buffer_read_i32(savegame_data.state.city_data);
            }
            city_data.resource.food_supply_months = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.granaries.operating = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.percentage_plebs = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.working_age = buffer_read_i32(savegame_data.state.city_data);
            city_data.labor.workers_available = buffer_read_i32(savegame_data.state.city_data);
            for (int i = 0; i < 10; i++) {
                city_data.labor.categories[i].workers_needed = buffer_read_i32(savegame_data.state.city_data);
                city_data.labor.categories[i].workers_allocated = buffer_read_i32(savegame_data.state.city_data);
                city_data.labor.categories[i].total_houses_covered = buffer_read_i32(savegame_data.state.city_data);
                city_data.labor.categories[i].buildings = buffer_read_i32(savegame_data.state.city_data);
                city_data.labor.categories[i].priority = buffer_read_i32(savegame_data.state.city_data);
            }
            city_data.labor.workers_employed = buffer_read_i32(savegame_data.state.city_data);
            city_data.labor.workers_unemployed = buffer_read_i32(savegame_data.state.city_data);
            city_data.labor.unemployment_percentage = buffer_read_i32(savegame_data.state.city_data);
            city_data.labor.unemployment_percentage_for_senate = buffer_read_i32(savegame_data.state.city_data);
            city_data.labor.workers_needed = buffer_read_i32(savegame_data.state.city_data);
            city_data.labor.wages = buffer_read_i32(savegame_data.state.city_data);
            city_data.labor.wages_rome = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.wages_so_far = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.expenses.wages = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.expenses.wages = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.taxed_plebs = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.taxed_patricians = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.untaxed_plebs = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.untaxed_patricians = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.percentage_taxed_plebs = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.percentage_taxed_patricians = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.percentage_taxed_people = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.yearly.collected_plebs = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.yearly.collected_patricians = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.yearly.uncollected_plebs = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.yearly.uncollected_patricians = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.income.taxes = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.income.taxes = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.monthly.collected_plebs = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.monthly.uncollected_plebs = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.monthly.collected_patricians = buffer_read_i32(savegame_data.state.city_data);
            city_data.taxes.monthly.uncollected_patricians = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.income.exports = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.income.exports = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.expenses.imports = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.expenses.imports = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.interest_so_far = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.expenses.interest = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.expenses.interest = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.expenses.sundries = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.expenses.sundries = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.expenses.construction = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.expenses.construction = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.expenses.salary = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.expenses.salary = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.salary_amount = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.salary_rank = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.salary_so_far = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.income.total = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.income.total = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.expenses.total = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.expenses.total = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.net_in_out = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.net_in_out = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.balance = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.balance = buffer_read_i32(savegame_data.state.city_data);
            city_data.trade.caravan_import_resource = buffer_read_i32(savegame_data.state.city_data);
            city_data.trade.caravan_backup_import_resource = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.culture = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.prosperity = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.peace = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.favor = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.prosperity_treasury_last_year = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.peace_num_criminals = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.peace_num_rioters = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.fountain = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.well = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.more_entertainment = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.more_education = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.education = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.requiring.school = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.requiring.library = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.barber = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.bathhouse = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.food = buffer_read_i32(savegame_data.state.city_data);
            city_data.building.hippodrome_placed = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.clinic = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.hospital = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.requiring.barber = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.requiring.bathhouse = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.requiring.clinic = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.religion = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.second_religion = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.third_religion = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.requiring.religion = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.theater_shows = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.theater_no_shows_weighted = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.amphitheater_shows = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.amphitheater_no_shows_weighted = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.colosseum_shows = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.colosseum_no_shows_weighted = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.hippodrome_shows = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.hippodrome_no_shows_weighted = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.venue_needing_shows = buffer_read_i32(savegame_data.state.city_data);
            city_data.culture.average_entertainment = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.missing.entertainment = buffer_read_i32(savegame_data.state.city_data);
            city_data.festival.months_since_festival = buffer_read_i32(savegame_data.state.city_data);
            for (int i = 0; i < MAX_GODS; i++) {
                city_data.religion.gods[i].target_happiness = buffer_read_i8(savegame_data.state.city_data);
            }
            for (int i = 0; i < MAX_GODS; i++) {
                city_data.religion.gods[i].happiness = buffer_read_i8(savegame_data.state.city_data);
            }
            for (int i = 0; i < MAX_GODS; i++) {
                city_data.religion.gods[i].wrath_bolts = buffer_read_i8(savegame_data.state.city_data);
            }
            for (int i = 0; i < MAX_GODS; i++) {
                city_data.religion.gods[i].blessing_done = buffer_read_i8(savegame_data.state.city_data);
            }
            for (int i = 0; i < MAX_GODS; i++) {
                city_data.religion.gods[i].small_curse_done = buffer_read_i8(savegame_data.state.city_data);
            }
            for (int i = 0; i < MAX_GODS; i++) {
                city_data.religion.gods[i].months_since_festival = buffer_read_i32(savegame_data.state.city_data);
            }
            city_data.religion.least_happy_god = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.no_immigration_cause = buffer_read_i32(savegame_data.state.city_data);
            city_data.sentiment.protesters = buffer_read_i32(savegame_data.state.city_data);
            city_data.sentiment.criminals = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.health = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.religion = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.education = buffer_read_i32(savegame_data.state.city_data);
            city_data.houses.entertainment = buffer_read_i32(savegame_data.state.city_data);
            city_data.figure.rioters = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.selected = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.culture_explanation = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.prosperity_explanation = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.peace_explanation = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.favor_explanation = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.player_rank = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.personal_savings = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.income.donated = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.income.donated = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.donate_amount = buffer_read_i32(savegame_data.state.city_data);
            for (int i = 0; i < 10; i++) {
                city_data.building.working_dock_ids[i] = buffer_read_i16(savegame_data.state.city_data);
            }
            city_data.figure.animals = buffer_read_i16(savegame_data.state.city_data);
            city_data.trade.num_sea_routes = buffer_read_i16(savegame_data.state.city_data);
            city_data.trade.num_land_routes = buffer_read_i16(savegame_data.state.city_data);
            city_data.trade.sea_trade_problem_duration = buffer_read_i16(savegame_data.state.city_data);
            city_data.trade.land_trade_problem_duration = buffer_read_i16(savegame_data.state.city_data);
            city_data.building.working_docks = buffer_read_i16(savegame_data.state.city_data);
            city_data.building.senate_placed = buffer_read_i16(savegame_data.state.city_data);
            city_data.building.working_wharfs = buffer_read_i16(savegame_data.state.city_data);
            city_data.finance.stolen_this_year = buffer_read_i16(savegame_data.state.city_data);
            city_data.finance.stolen_last_year = buffer_read_i16(savegame_data.state.city_data);
            city_data.trade.docker_import_resource = buffer_read_i32(savegame_data.state.city_data);
            city_data.trade.docker_export_resource = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.debt_state = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.months_in_debt = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.cheated_money = buffer_read_i32(savegame_data.state.city_data);
            city_data.building.barracks_x = buffer_read_i8(savegame_data.state.city_data);
            city_data.building.barracks_y = buffer_read_i8(savegame_data.state.city_data);
            city_data.building.barracks_grid_offset = buffer_read_i16(savegame_data.state.city_data);
            city_data.building.barracks_building_id = buffer_read_i32(savegame_data.state.city_data);
            city_data.building.barracks_placed = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.lost_troop_request = buffer_read_i32(savegame_data.state.city_data);
            city_data.mission.has_won = buffer_read_i32(savegame_data.state.city_data);
            city_data.mission.continue_months_left = buffer_read_i32(savegame_data.state.city_data);
            city_data.mission.continue_months_chosen = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.wage_rate_paid_this_year = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.this_year.expenses.tribute = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.last_year.expenses.tribute = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.tribute_not_paid_last_year = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.tribute_not_paid_total_years = buffer_read_i32(savegame_data.state.city_data);
            city_data.festival.queued = buffer_read_i8(savegame_data.state.city_data);
            city_data.festival.god = buffer_read_i8(savegame_data.state.city_data);
            city_data.festival.size = buffer_read_i8(savegame_data.state.city_data);
            city_data.festival.months_to_go = buffer_read_i32(savegame_data.state.city_data);
            city_data.culture.average_religion = buffer_read_i32(savegame_data.state.city_data);
            city_data.culture.average_education = buffer_read_i32(savegame_data.state.city_data);
            city_data.culture.average_health = buffer_read_i32(savegame_data.state.city_data);
            city_data.culture.religion_coverage = buffer_read_i32(savegame_data.state.city_data);
            city_data.festival.first_festival_effect_months = buffer_read_i32(savegame_data.state.city_data);
            city_data.festival.second_festival_effect_months = buffer_read_i32(savegame_data.state.city_data);
            city_data.sentiment.previous_value = buffer_read_i32(savegame_data.state.city_data);
            city_data.sentiment.message_delay = buffer_read_i32(savegame_data.state.city_data);
            city_data.sentiment.low_mood_cause = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.months_since_gift = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.gift_overdose_penalty = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.gifts[GIFT_MODEST].id = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.gifts[GIFT_GENEROUS].id = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.gifts[GIFT_LAVISH].id = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.gifts[GIFT_MODEST].cost = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.gifts[GIFT_GENEROUS].cost = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.gifts[GIFT_LAVISH].cost = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.favor_salary_penalty = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.favor_ignored_request_penalty = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.favor_last_year = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.favor_change = buffer_read_i32(savegame_data.state.city_data);
            city_data.military.native_attack_duration = buffer_read_i32(savegame_data.state.city_data);
            city_data.building.mission_post_operational = buffer_read_i32(savegame_data.state.city_data);
            city_data.building.main_native_meeting.x = buffer_read_i32(savegame_data.state.city_data);
            city_data.building.main_native_meeting.y = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.wage_rate_paid_last_year = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.food_needed_per_month = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.granaries.understaffed = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.granaries.not_operating = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.granaries.not_operating_with_food = buffer_read_i32(savegame_data.state.city_data);
            city_data.religion.venus_curse_active = buffer_read_i32(savegame_data.state.city_data);
            city_data.religion.neptune_double_trade_active = buffer_read_i32(savegame_data.state.city_data);
            city_data.religion.mars_spirit_power = buffer_read_i32(savegame_data.state.city_data);
            city_data.religion.angry_message_delay = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.food_consumed_last_month = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.food_produced_last_month = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.food_produced_this_month = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.peace_riot_cause = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.estimated_tax_income = buffer_read_i32(savegame_data.state.city_data);
            city_data.building.shipyard_boats_requested = buffer_read_i32(savegame_data.state.city_data);
            city_data.figure.enemies = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.people_in_tents = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.people_in_large_insula_and_above = buffer_read_i32(savegame_data.state.city_data);
            city_data.figure.imperial_soldiers = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.invasion.duration_day_countdown = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.invasion.warnings_given = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.invasion.days_until_invasion = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.invasion.retreat_message_shown = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.invasion.from_editor = buffer_read_i16(savegame_data.state.city_data);
            city_data.ratings.peace_destroyed_buildings = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.peace_years_of_peace = buffer_read_i32(savegame_data.state.city_data);
            city_data.distant_battle.city = buffer_read_u8(savegame_data.state.city_data);
            city_data.distant_battle.enemy_strength = buffer_read_u8(savegame_data.state.city_data);
            city_data.distant_battle.roman_strength = buffer_read_u8(savegame_data.state.city_data);
            city_data.distant_battle.months_until_battle = buffer_read_i8(savegame_data.state.city_data);
            city_data.distant_battle.roman_months_to_travel_back = buffer_read_i8(savegame_data.state.city_data);
            city_data.distant_battle.roman_months_to_travel_forth = buffer_read_i8(savegame_data.state.city_data);
            city_data.distant_battle.city_foreign_months_left = buffer_read_i8(savegame_data.state.city_data);
            city_data.building.triumphal_arches_available = buffer_read_i8(savegame_data.state.city_data);
            city_data.distant_battle.total_count = buffer_read_i8(savegame_data.state.city_data);
            city_data.distant_battle.won_count = buffer_read_i8(savegame_data.state.city_data);
            city_data.distant_battle.enemy_months_traveled = buffer_read_i8(savegame_data.state.city_data);
            city_data.distant_battle.roman_months_traveled = buffer_read_i8(savegame_data.state.city_data);
            city_data.military.total_legions = buffer_read_u8(savegame_data.state.city_data);
            city_data.sound.die_citizen = buffer_read_u8(savegame_data.state.city_data);
            city_data.sound.die_soldier = buffer_read_u8(savegame_data.state.city_data);
            city_data.building.trade_center_building_id = buffer_read_i32(savegame_data.state.city_data);
            city_data.figure.soldiers = buffer_read_i32(savegame_data.state.city_data);
            city_data.sound.hit_elephant = buffer_read_u8(savegame_data.state.city_data);
            city_data.emperor.invasion.count = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.invasion.size = buffer_read_i32(savegame_data.state.city_data);
            city_data.emperor.invasion.soldiers_killed = buffer_read_i32(savegame_data.state.city_data);
            city_data.military.legionary_legions = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.highest_ever = buffer_read_i32(savegame_data.state.city_data);
            city_data.finance.estimated_wages = buffer_read_i32(savegame_data.state.city_data);
            city_data.resource.wine_types_available = buffer_read_i32(savegame_data.state.city_data);
            city_data.ratings.prosperity_max = buffer_read_i32(savegame_data.state.city_data);
            for (int i = 0; i < 10; i++) {
                city_data.map.largest_road_networks[i].id = buffer_read_i32(savegame_data.state.city_data);
                city_data.map.largest_road_networks[i].size = buffer_read_i32(savegame_data.state.city_data);
            }
            city_data.houses.missing.second_wine = buffer_read_i32(savegame_data.state.city_data);
            city_data.religion.neptune_sank_ships = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.hippodrome_has_race = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.hippodrome_message_shown = buffer_read_i32(savegame_data.state.city_data);
            city_data.entertainment.colosseum_message_shown = buffer_read_i32(savegame_data.state.city_data);
            city_data.migration.emigration_message_shown = buffer_read_i32(savegame_data.state.city_data);
            city_data.mission.fired_message_shown = buffer_read_i32(savegame_data.state.city_data);
            city_data.mission.victory_message_shown = buffer_read_i32(savegame_data.state.city_data);
            city_data.population.graph_order = buffer_read_i32(savegame_data.state.city_graph_order);
            for (int i = 0; i < MAX_BUILDINGS; i++) {
                all_buildings[i].state = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].size = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].house_is_merged = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].house_size = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].x = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].y = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].grid_offset = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].type = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].subtype.house_level = buffer_read_i16(savegame_data.state.buildings); // which union field we use does not matter
                all_buildings[i].created_sequence = buffer_read_u16(savegame_data.state.buildings);
                all_buildings[i].houses_covered = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].percentage_houses_covered = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].house_population = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].house_population_room = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].house_highest_population = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].road_access_x = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].road_access_y = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].figure_id = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].figure_id2 = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].immigrant_figure_id = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].figure_id4 = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].figure_spawn_delay = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].figure_roam_direction = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].has_water_access = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].prev_part_building_id = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].next_part_building_id = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].loads_stored = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].has_well_access = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].num_workers = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].labor_category = buffer_read_i8(savegame_data.state.buildings);
                all_buildings[i].output_resource_id = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].has_road_access = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].house_criminal_active = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].damage_risk = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].fire_risk = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].fire_duration = buffer_read_i16(savegame_data.state.buildings);
                all_buildings[i].fire_proof = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].house_figure_generation_delay = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].house_tax_coverage = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].formation_id = buffer_read_i16(savegame_data.state.buildings);
                if (building_is_house(all_buildings[i].type)) {
                    for (int j = 0; j < INVENTORY_MAX; j++) {
                        all_buildings[j].data.house.inventory[j] = buffer_read_i16(savegame_data.state.buildings);
                    }
                    all_buildings[i].data.house.theater = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.amphitheater_actor = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.amphitheater_gladiator = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.colosseum_gladiator = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.colosseum_lion = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.hippodrome = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.school = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.library = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.academy = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.barber = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.clinic = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.bathhouse = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.hospital = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.temple_ceres = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.temple_neptune = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.temple_mercury = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.temple_mars = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.temple_venus = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.no_space_to_expand = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.num_foods = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.entertainment = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.education = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.health = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.num_gods = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.devolve_delay = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.house.evolve_text_id = buffer_read_u8(savegame_data.state.buildings);
                } else if (all_buildings[i].type == BUILDING_MARKET) {
                    for (int j = 0; j < INVENTORY_MAX; j++) {
                        all_buildings[j].data.market.inventory[j] = buffer_read_i16(savegame_data.state.buildings);
                    }
                    all_buildings[i].data.market.pottery_demand = buffer_read_i16(savegame_data.state.buildings);
                    all_buildings[i].data.market.furniture_demand = buffer_read_i16(savegame_data.state.buildings);
                    all_buildings[i].data.market.oil_demand = buffer_read_i16(savegame_data.state.buildings);
                    all_buildings[i].data.market.wine_demand = buffer_read_i16(savegame_data.state.buildings);
                    all_buildings[i].data.market.fetch_inventory_id = buffer_read_u8(savegame_data.state.buildings);
                } else if (all_buildings[i].type == BUILDING_GRANARY) {
                    for (int j = 0; j < RESOURCE_TYPES_MAX; j++) {
                        all_buildings[j].data.granary.resource_stored[j] = buffer_read_i16(savegame_data.state.buildings);
                    }
                } else if (all_buildings[i].type == BUILDING_DOCK) {
                    all_buildings[i].data.dock.queued_docker_id = buffer_read_i16(savegame_data.state.buildings);
                    all_buildings[i].data.dock.num_ships = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.dock.orientation = buffer_read_i8(savegame_data.state.buildings);
                    for (int j = 0; j < 3; j++) {
                        all_buildings[j].data.dock.docker_ids[j] = buffer_read_i16(savegame_data.state.buildings);
                    }
                    all_buildings[i].data.dock.trade_ship_id = buffer_read_i16(savegame_data.state.buildings);
                } else if (is_industry_type(&all_buildings[i])) {
                    all_buildings[i].data.industry.progress = buffer_read_i16(savegame_data.state.buildings);
                    all_buildings[i].data.industry.has_fish = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.industry.blessing_days_left = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.industry.orientation = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.industry.has_raw_materials = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.industry.curse_days_left = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.industry.fishing_boat_id = buffer_read_i16(savegame_data.state.buildings);
                } else {
                    all_buildings[i].data.entertainment.num_shows = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.entertainment.days1 = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.entertainment.days2 = buffer_read_u8(savegame_data.state.buildings);
                    all_buildings[i].data.entertainment.play = buffer_read_u8(savegame_data.state.buildings);
                }
                all_buildings[i].tax_income_or_storage = buffer_read_i32(savegame_data.state.buildings);
                all_buildings[i].house_days_without_food = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].ruin_has_plague = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].desirability = buffer_read_i8(savegame_data.state.buildings);
                all_buildings[i].is_deleted = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].storage_id = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].sentiment.house_happiness = buffer_read_i8(savegame_data.state.buildings); // which union field we use does not matter
                all_buildings[i].show_on_problem_overlay = buffer_read_u8(savegame_data.state.buildings);
                all_buildings[i].id = i;
            }
            extra.highest_id_in_use = buffer_read_i32(savegame_data.state.building_extra_highest_id);
            extra.highest_id_ever = buffer_read_i32(savegame_data.state.building_extra_highest_id_ever);
            extra.created_sequence = buffer_read_i32(savegame_data.state.building_extra_sequence);
            extra.incorrect_houses = buffer_read_i32(savegame_data.state.building_extra_corrupt_houses);
            extra.unfixable_houses = buffer_read_i32(savegame_data.state.building_extra_corrupt_houses);
            tower_sentry_request = buffer_read_i32(savegame_data.state.building_barracks_tower_sentry);
            view_data.orientation = buffer_read_i32(savegame_data.state.city_view_orientation);
            city_view_load_scenario_state(savegame_data.state.city_view_camera);
            if (view_data.orientation >= 0 && view_data.orientation <= 6) {
                // ensure even number
                view_data.orientation = 2 * (view_data.orientation / 2);
            } else {
                view_data.orientation = 0;
            }
            time_data.tick = buffer_read_i32(savegame_data.state.game_time);
            time_data.day = buffer_read_i32(savegame_data.state.game_time);
            time_data.month = buffer_read_i32(savegame_data.state.game_time);
            time_data.year = buffer_read_i32(savegame_data.state.game_time);
            time_data.total_days = buffer_read_i32(savegame_data.state.game_time);
            random_load_state(savegame_data.state.random_iv);
            // industry
            for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
                count_data.industry[i].total = buffer_read_i32(savegame_data.state.building_count_industry);
            }
            for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
                count_data.industry[i].active = buffer_read_i32(savegame_data.state.building_count_industry);
            }
            // culture 1
            count_data.buildings[BUILDING_THEATER].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_THEATER].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_AMPHITHEATER].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_AMPHITHEATER].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_COLOSSEUM].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_COLOSSEUM].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_HIPPODROME].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_HIPPODROME].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_SCHOOL].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_SCHOOL].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_LIBRARY].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_LIBRARY].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_ACADEMY].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_ACADEMY].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_BARBER].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_BARBER].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_BATHHOUSE].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_BATHHOUSE].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_DOCTOR].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_DOCTOR].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_HOSPITAL].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_HOSPITAL].active = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_SMALL_TEMPLE_CERES].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_SMALL_TEMPLE_NEPTUNE].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_SMALL_TEMPLE_MERCURY].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_SMALL_TEMPLE_MARS].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_SMALL_TEMPLE_VENUS].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_LARGE_TEMPLE_CERES].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_LARGE_TEMPLE_NEPTUNE].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_LARGE_TEMPLE_MERCURY].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_LARGE_TEMPLE_MARS].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_LARGE_TEMPLE_VENUS].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            count_data.buildings[BUILDING_ORACLE].total = buffer_read_i32(savegame_data.state.building_count_culture1);
            // culture 2
            count_data.buildings[BUILDING_ACTOR_COLONY].total = buffer_read_i32(savegame_data.state.building_count_culture2);
            count_data.buildings[BUILDING_ACTOR_COLONY].active = buffer_read_i32(savegame_data.state.building_count_culture2);
            count_data.buildings[BUILDING_GLADIATOR_SCHOOL].total = buffer_read_i32(savegame_data.state.building_count_culture2);
            count_data.buildings[BUILDING_GLADIATOR_SCHOOL].active = buffer_read_i32(savegame_data.state.building_count_culture2);
            count_data.buildings[BUILDING_LION_HOUSE].total = buffer_read_i32(savegame_data.state.building_count_culture2);
            count_data.buildings[BUILDING_LION_HOUSE].active = buffer_read_i32(savegame_data.state.building_count_culture2);
            count_data.buildings[BUILDING_CHARIOT_MAKER].total = buffer_read_i32(savegame_data.state.building_count_culture2);
            count_data.buildings[BUILDING_CHARIOT_MAKER].active = buffer_read_i32(savegame_data.state.building_count_culture2);
            // culture 3
            count_data.buildings[BUILDING_SMALL_TEMPLE_CERES].active = buffer_read_i32(savegame_data.state.building_count_culture3);
            count_data.buildings[BUILDING_SMALL_TEMPLE_NEPTUNE].active = buffer_read_i32(savegame_data.state.building_count_culture3);
            count_data.buildings[BUILDING_SMALL_TEMPLE_MERCURY].active = buffer_read_i32(savegame_data.state.building_count_culture3);
            count_data.buildings[BUILDING_SMALL_TEMPLE_MARS].active = buffer_read_i32(savegame_data.state.building_count_culture3);
            count_data.buildings[BUILDING_SMALL_TEMPLE_VENUS].active = buffer_read_i32(savegame_data.state.building_count_culture3);
            count_data.buildings[BUILDING_LARGE_TEMPLE_CERES].active = buffer_read_i32(savegame_data.state.building_count_culture3);
            count_data.buildings[BUILDING_LARGE_TEMPLE_NEPTUNE].active = buffer_read_i32(savegame_data.state.building_count_culture3);
            count_data.buildings[BUILDING_LARGE_TEMPLE_MERCURY].active = buffer_read_i32(savegame_data.state.building_count_culture3);
            count_data.buildings[BUILDING_LARGE_TEMPLE_MARS].active = buffer_read_i32(savegame_data.state.building_count_culture3);
            count_data.buildings[BUILDING_LARGE_TEMPLE_VENUS].active = buffer_read_i32(savegame_data.state.building_count_culture3);
            // military
            count_data.buildings[BUILDING_MILITARY_ACADEMY].total = buffer_read_i32(savegame_data.state.building_count_military);
            count_data.buildings[BUILDING_MILITARY_ACADEMY].active = buffer_read_i32(savegame_data.state.building_count_military);
            count_data.buildings[BUILDING_BARRACKS].total = buffer_read_i32(savegame_data.state.building_count_military);
            count_data.buildings[BUILDING_BARRACKS].active = buffer_read_i32(savegame_data.state.building_count_military);
            // support
            count_data.buildings[BUILDING_MARKET].total = buffer_read_i32(savegame_data.state.building_count_support);
            count_data.buildings[BUILDING_MARKET].active = buffer_read_i32(savegame_data.state.building_count_support);
            count_data.buildings[BUILDING_RESERVOIR].total = buffer_read_i32(savegame_data.state.building_count_support);
            count_data.buildings[BUILDING_RESERVOIR].active = buffer_read_i32(savegame_data.state.building_count_support);
            count_data.buildings[BUILDING_FOUNTAIN].total = buffer_read_i32(savegame_data.state.building_count_support);
            count_data.buildings[BUILDING_FOUNTAIN].active = buffer_read_i32(savegame_data.state.building_count_support);
            empire_data.scroll_x = buffer_read_i32(savegame_data.state.empire);
            empire_data.scroll_y = buffer_read_i32(savegame_data.state.empire);
            load_empire(savegame_data.state.empire_objects);
            for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
                trade_prices[i].buy = buffer_read_u16(savegame_data.state.trade_prices);
                trade_prices[i].sell = buffer_read_u16(savegame_data.state.trade_prices);
            }
            name_data.citizen_male = buffer_read_i32(savegame_data.state.figure_names);
            name_data.patrician = buffer_read_i32(savegame_data.state.figure_names);
            name_data.citizen_female = buffer_read_i32(savegame_data.state.figure_names);
            name_data.tax_collector = buffer_read_i32(savegame_data.state.figure_names);
            name_data.engineer = buffer_read_i32(savegame_data.state.figure_names);
            name_data.prefect = buffer_read_i32(savegame_data.state.figure_names);
            name_data.javelin_thrower = buffer_read_i32(savegame_data.state.figure_names);
            name_data.cavalry = buffer_read_i32(savegame_data.state.figure_names);
            name_data.legionary = buffer_read_i32(savegame_data.state.figure_names);
            name_data.actor = buffer_read_i32(savegame_data.state.figure_names);
            name_data.gladiator = buffer_read_i32(savegame_data.state.figure_names);
            name_data.lion_tamer = buffer_read_i32(savegame_data.state.figure_names);
            name_data.charioteer = buffer_read_i32(savegame_data.state.figure_names);
            name_data.barbarian = buffer_read_i32(savegame_data.state.figure_names);
            name_data.enemy_greek = buffer_read_i32(savegame_data.state.figure_names);
            name_data.enemy_egyptian = buffer_read_i32(savegame_data.state.figure_names);
            name_data.enemy_arabian = buffer_read_i32(savegame_data.state.figure_names);
            name_data.trader = buffer_read_i32(savegame_data.state.figure_names);
            name_data.ship = buffer_read_i32(savegame_data.state.figure_names);
            culture_coverage.theater = buffer_read_i32(savegame_data.state.culture_coverage);
            culture_coverage.amphitheater = buffer_read_i32(savegame_data.state.culture_coverage);
            culture_coverage.colosseum = buffer_read_i32(savegame_data.state.culture_coverage);
            culture_coverage.hippodrome = buffer_read_i32(savegame_data.state.culture_coverage);
            for (int i = GOD_CERES; i <= GOD_VENUS; i++) {
                culture_coverage.religion[i] = buffer_read_i32(savegame_data.state.culture_coverage);
            }
            culture_coverage.oracle = buffer_read_i32(savegame_data.state.culture_coverage);
            culture_coverage.school = buffer_read_i32(savegame_data.state.culture_coverage);
            culture_coverage.library = buffer_read_i32(savegame_data.state.culture_coverage);
            culture_coverage.academy = buffer_read_i32(savegame_data.state.culture_coverage);
            culture_coverage.hospital = buffer_read_i32(savegame_data.state.culture_coverage);
            scenario_load_state(savegame_data.state.scenario);
            for (int i = 0; i < MAX_MESSAGES; i++) {
                struct city_message_t *msg = &message_data.messages[i];
                msg->param1 = buffer_read_i32(savegame_data.state.messages);
                msg->year = buffer_read_i16(savegame_data.state.messages);
                msg->param2 = buffer_read_i16(savegame_data.state.messages);
                msg->message_type = buffer_read_i16(savegame_data.state.messages);
                msg->sequence = buffer_read_i16(savegame_data.state.messages);
                msg->is_read = buffer_read_u8(savegame_data.state.messages);
                msg->month = buffer_read_u8(savegame_data.state.messages);
            }

            message_data.next_message_sequence = buffer_read_i32(savegame_data.state.message_extra);
            message_data.total_messages = buffer_read_i32(savegame_data.state.message_extra);
            message_data.current_message_id = buffer_read_i32(savegame_data.state.message_extra);

            for (int i = 0; i < MAX_MESSAGE_CATEGORIES; i++) {
                message_data.message_count[i] = buffer_read_i32(savegame_data.state.message_counts);
                message_data.message_delay[i] = buffer_read_i32(savegame_data.state.message_delays);
            }
            // population
            message_data.population_shown.pop500 = buffer_read_u8(savegame_data.state.population_messages);
            message_data.population_shown.pop1000 = buffer_read_u8(savegame_data.state.population_messages);
            message_data.population_shown.pop2000 = buffer_read_u8(savegame_data.state.population_messages);
            message_data.population_shown.pop3000 = buffer_read_u8(savegame_data.state.population_messages);
            message_data.population_shown.pop5000 = buffer_read_u8(savegame_data.state.population_messages);
            message_data.population_shown.pop10000 = buffer_read_u8(savegame_data.state.population_messages);
            message_data.population_shown.pop15000 = buffer_read_u8(savegame_data.state.population_messages);
            message_data.population_shown.pop20000 = buffer_read_u8(savegame_data.state.population_messages);
            message_data.population_shown.pop25000 = buffer_read_u8(savegame_data.state.population_messages);
            for (int i = 0; i < MAX_CITY_SOUNDS_CHANNELS; i++) {
                struct city_channel_t *ch = &channels[i];
                ch->available = buffer_read_i32(savegame_data.state.city_sounds);
                ch->total_views = buffer_read_i32(savegame_data.state.city_sounds);
                ch->views_threshold = buffer_read_i32(savegame_data.state.city_sounds);
                for (int d = 0; d < 5; d++) {
                    ch->direction_views[d] = buffer_read_i32(savegame_data.state.city_sounds);
                }
                ch->channel = buffer_read_i32(savegame_data.state.city_sounds);
                ch->in_use = buffer_read_i32(savegame_data.state.city_sounds);
                ch->times_played = buffer_read_i32(savegame_data.state.city_sounds);
                ch->last_played_time = buffer_read_u32(savegame_data.state.city_sounds);
                ch->delay_millis = buffer_read_u32(savegame_data.state.city_sounds);
                ch->should_play = buffer_read_i32(savegame_data.state.city_sounds);
            }
            for (int i = 0; i < MAX_TRADERS; i++) {
                struct trader *t = &figure_trader_data.traders[i];
                t->bought_amount = buffer_read_i32(savegame_data.state.figure_traders);
                t->sold_amount = buffer_read_i32(savegame_data.state.figure_traders);
                for (int r = 0; r < RESOURCE_TYPES_MAX; r++) {
                    t->bought_resources[r] = buffer_read_u8(savegame_data.state.figure_traders);
                }
                for (int r = 0; r < RESOURCE_TYPES_MAX; r++) {
                    t->sold_resources[r] = buffer_read_u8(savegame_data.state.figure_traders);
                }
            }
            figure_trader_data.next_index = buffer_read_i32(savegame_data.state.figure_traders);
            for (int i = 0; i < MAX_SMALL; i++) {
                building_list_data.small.items[i] = buffer_read_i16(savegame_data.state.building_list_small);
            }
            for (int i = 0; i < MAX_LARGE; i++) {
                building_list_data.large.items[i] = buffer_read_i16(savegame_data.state.building_list_large);
            }
            for (int i = 0; i < MAX_BURNING; i++) {
                building_list_data.burning.items[i] = buffer_read_i16(savegame_data.state.building_list_burning);
            }
            building_list_data.burning.total = buffer_read_i32(savegame_data.state.building_list_burning_totals);
            building_list_data.burning.size = buffer_read_i32(savegame_data.state.building_list_burning_totals);



            for (int i = 0; i < MAX_STORAGES; i++) {
                storages[i].building_id = buffer_read_i32(savegame_data.state.building_storages);
                storages[i].in_use = buffer_read_u8(savegame_data.state.building_storages);
                storages[i].storage.empty_all = buffer_read_u8(savegame_data.state.building_storages);
                for (int r = 0; r < RESOURCE_TYPES_MAX; r++) {
                    storages[i].storage.resource_state[r] = buffer_read_u8(savegame_data.state.building_storages);
                }
            }
            stats.enemy_routes_calculated = buffer_read_i32(savegame_data.state.routing_counters);
            stats.total_routes_calculated = buffer_read_i32(savegame_data.state.routing_counters);
            for (int i = 0; i < MAX_BOOKMARKS; i++) {
                bookmarks[i].x = buffer_read_i32(savegame_data.state.bookmarks);
                bookmarks[i].y = buffer_read_i32(savegame_data.state.bookmarks);
            }
            scenario.empire.distant_battle_roman_travel_months = empire_object_init_distant_battle_travel_months(EMPIRE_OBJECT_ROMAN_ARMY);
            scenario.empire.distant_battle_enemy_travel_months = empire_object_init_distant_battle_travel_months(EMPIRE_OBJECT_ENEMY_ARMY);
            map_grid_init(scenario.map.width, scenario.map.height, scenario.map.grid_start);
            city_view_init();
            map_routing_update_all();
            map_orientation_update_buildings();
            for (int i = 0; i < MAX_ROUTES; i++) {
                int figure_id = figure_route_data.figure_ids[i];
                if (figure_id > 0 && figure_id < MAX_FIGURES) {
                    struct figure_t *f = &figures[figure_id];
                    if (!figure_is_alive(f) || f->routing_path_id != i) {
                        figure_route_data.figure_ids[i] = 0;
                    }
                }
            }
            map_road_network_update();
            building_granaries_calculate_stocks();
            map_building_menu_items();
            city_message_init_problem_areas();
            initialize_city_sounds();
            building_construction_clear_type();
            undo_data.available = 0;
            game_state_reset_overlay();
            load_main_graphics(scenario.climate, 0);
            city_military_determine_distant_battle_city();
            for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
                for (int x = 0; x < map_data.width; x++, grid_offset++) {
                    int base_image = 3148;
                    if (images.items[grid_offset] >= base_image && images.items[grid_offset] <= base_image + 6) {
                        terrain_grid.items[grid_offset] |= TERRAIN_GARDEN;
                        bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
                        aqueduct.items[grid_offset] = 0;
                    }
                }
            }
            message_data.scroll_position = 0;
            state_data.paused = 0;
            building_storage_reset_building_ids();
            update_music(1);
            show_city_window();
        }
    } else if (file_dialog_data.type == FILE_TYPE_SCENARIO) {
        if (file_dialog_data.dialog_type != FILE_DIALOG_SAVE && !file_exists(MAPS_DIR_PATH, file_dialog_data.selected_file)) {
            file_dialog_data.message_not_exist_start_time = current_time;
            return;
        }
        if (file_dialog_data.dialog_type == FILE_DIALOG_SAVE) {
            scenario.native_images.hut = 2830;
            scenario.native_images.meeting = 2832;
            scenario.native_images.crops = 2833;
            scenario.empire.distant_battle_roman_travel_months = empire_object_init_distant_battle_travel_months(EMPIRE_OBJECT_ROMAN_ARMY);
            scenario.empire.distant_battle_enemy_travel_months = empire_object_init_distant_battle_travel_months(EMPIRE_OBJECT_ENEMY_ARMY);
            SDL_Log("Saving scenario %s", file_dialog_data.selected_file);
            init_scenario_data();
            map_image_save_state(scenario_data.state.graphic_ids);
            map_terrain_save_state(scenario_data.state.terrain);
            map_property_save_state(scenario_data.state.bitfields, scenario_data.state.edge);
            buffer_write_raw(scenario_data.state.random, random.items, GRID_SIZE * GRID_SIZE);
            buffer_write_i32(scenario_data.state.camera, view_data.camera.tile.x);
            buffer_write_i32(scenario_data.state.camera, view_data.camera.tile.y);
            random_save_state(scenario_data.state.random_iv);
            scenario_save_state(scenario_data.state.scenario);
            empire_object_save_state(scenario_data.state.empire_objects);
            static char dir_prepended_filepath[DIR_PATH_MAX];
            prepend_dir_to_path(MAPS_DIR_PATH, file_dialog_data.selected_file, dir_prepended_filepath);
            fp = fopen(dir_prepended_filepath, "wb");
            if (!fp) {
                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Unable to save scenario", 0, 0));
                fclose(fp);
                return;
            }
            for (int i = 0; i < scenario_data.num_pieces; i++) {
                fwrite(scenario_data.pieces[i].buf.data, 1, scenario_data.pieces[i].buf.size, fp);
            }
            fclose(fp);
            change_window(WINDOW_EDITOR_MAP);
        } else if (file_dialog_data.dialog_type == FILE_DIALOG_LOAD) {
            clear_map_data();
            if (game_file_io_read_scenario(MAPS_DIR_PATH, file_dialog_data.selected_file)) {
                map_grid_init(scenario.map.width, scenario.map.height, scenario.map.grid_start);
                prepare_map_for_editing(0);
                change_window(WINDOW_EDITOR_MAP);
            } else {
                file_dialog_data.message_not_exist_start_time = current_time;
                return;
            }
        }
    }
    play_sound_effect(SOUND_EFFECT_ICON);
}

static void scroll_scrollbar_step(int step, int scrollbar_y, int scrollbar_height, int scrollbar_position_max)
{
    if (scrollbar_position + step >= 0 && scrollbar_position + step <= scrollbar_position_max) {
        scrollbar_position += step;
    }
    if (step < 0 && !scrollbar_position) {
        scrollbar_dot_y = scrollbar_y;
        scrollbar_position_adjustment = 0;
    } else if (scrollbar_position == scrollbar_position_max) {
        scrollbar_dot_y = scrollbar_y + scrollbar_height - SCROLLBAR_DOT_HEIGHT;
        scrollbar_position_adjustment = 0;
    } else {
        int step_pixels = step * ((scrollbar_height - SCROLLBAR_DOT_HEIGHT) / scrollbar_position_max);
        scrollbar_position_adjustment += ((scrollbar_height - SCROLLBAR_DOT_HEIGHT) % scrollbar_position_max);
        if (scrollbar_position_adjustment >= scrollbar_height - SCROLLBAR_DOT_HEIGHT) {
            step_pixels *= 2;
            scrollbar_position_adjustment -= scrollbar_height - SCROLLBAR_DOT_HEIGHT;
        }
        if (scrollbar_dot_y + step_pixels >= scrollbar_y && scrollbar_dot_y + step_pixels <= scrollbar_y + scrollbar_height - SCROLLBAR_DOT_HEIGHT) {
            scrollbar_dot_y += step_pixels;
        }
    }
    refresh_current_window = 1;
}

static void drag_scrollbar_mouse(int mouse_y, int scrollbar_y, int scrollbar_height, int scrollbar_position_max)
{
    if (mouse_y >= scrollbar_y + SCROLLBAR_DOT_HEIGHT / 2
    && mouse_y <= scrollbar_y + scrollbar_height - SCROLLBAR_DOT_HEIGHT / 2) {
        scrollbar_dot_y = mouse_y - SCROLLBAR_DOT_HEIGHT / 2;
        scrollbar_position = (float) (scrollbar_dot_y - scrollbar_y) / (scrollbar_height - SCROLLBAR_DOT_HEIGHT) * scrollbar_position_max;
    }
    refresh_current_window = 1;
}

static void draw_scrollbar(int scrollbar_x, int scrollbar_y, int scrollbar_height, int scrollbar_position_max) // scrollbar_y is where the actual scroll (not the top button) begins
{
    // up arrow button
    if (!is_dragging_scroll
    && mouse_x >= scrollbar_x && mouse_x < scrollbar_x + SCROLLBAR_BUTTON_WIDTH
    && mouse_y >= scrollbar_y - SCROLLBAR_BUTTON_HEIGHT && mouse_y < scrollbar_y) {
        if (scrollbar_up_arrow_pressed) {
            if (current_time > button_last_update_time + BUTTON_REPEAT_DELAY_TIME) {
                button_last_update_time = current_time;
                scroll_scrollbar_step(-1, scrollbar_y, scrollbar_height, scrollbar_position_max);
            }
            image_draw(editor_active ? 1122 : 1119, scrollbar_x, scrollbar_y - SCROLLBAR_BUTTON_HEIGHT);
        } else {
            image_draw(editor_active ? 1121 : 1118, scrollbar_x, scrollbar_y - SCROLLBAR_BUTTON_HEIGHT);
        }
    } else {
        image_draw(editor_active ? 1120 : 1117, scrollbar_x, scrollbar_y - SCROLLBAR_BUTTON_HEIGHT);
    }
    // down arrow button
    if (!is_dragging_scroll
    && mouse_x >= scrollbar_x && mouse_x < scrollbar_x + SCROLLBAR_BUTTON_WIDTH
    && mouse_y >= scrollbar_y + scrollbar_height && mouse_y < scrollbar_y + scrollbar_height + SCROLLBAR_BUTTON_HEIGHT) {
        if (scrollbar_down_arrow_pressed) {
            if (current_time > button_last_update_time + BUTTON_REPEAT_DELAY_TIME) {
                button_last_update_time = current_time;
                scroll_scrollbar_step(1, scrollbar_y, scrollbar_height, scrollbar_position_max);
            }
            image_draw(editor_active ? 1126 : 1123, scrollbar_x, scrollbar_y + scrollbar_height);
        } else {
            image_draw(editor_active ? 1125 : 1122, scrollbar_x, scrollbar_y + scrollbar_height);
        }
    } else {
        image_draw(editor_active ? 1124 : 1121, scrollbar_x, scrollbar_y + scrollbar_height);
    }
    // draw dot
    image_draw(931, scrollbar_x + 7, scrollbar_dot_y);
}

static int get_letter_width(char *str, struct font_definition_t *def, int *num_bytes)
{
    *num_bytes = 1;
    if (*str == ' ') {
        return def->space_width;
    }
    int letter_id = font_letter_id(def, str);
    if (letter_id >= 0) {
        return def->letter_spacing + image_letter(letter_id)->width;
    } else {
        return 0;
    }
}

static unsigned int text_get_max_length_for_width(char *str, int length, int font, unsigned int requested_width, int invert)
{
    struct font_definition_t *def = &DEFINITIONS_DEFAULT[font];
    if (!length) {
        length = string_length(str);
    }
    if (invert) {
        unsigned int maxlen = length;
        unsigned int width = 0;
        char *s = str;
        while (maxlen) {
            int num_bytes;
            width += get_letter_width(s, def, &num_bytes);
            s += num_bytes;
            maxlen -= num_bytes;
        }

        maxlen = length;
        while (maxlen && width > requested_width) {
            int num_bytes;
            width -= get_letter_width(str, def, &num_bytes);
            str += num_bytes;
            maxlen -= num_bytes;
        }
        return maxlen;
    } else {
        unsigned int maxlen = length;
        unsigned int width = 0;
        while (maxlen) {
            int num_bytes;
            width += get_letter_width(str, def, &num_bytes);
            if (width > requested_width) {
                break;
            }
            str += num_bytes;
            maxlen -= num_bytes;
        }
        return length - maxlen;
    }
}

static void set_viewport_to_start(void)
{
    keyboard_data.viewport_start = 0;
    keyboard_data.viewport_end = text_get_max_length_for_width(keyboard_data.text, keyboard_data.length, keyboard_data.font, keyboard_data.box_width, 0);
}

static void set_viewport_to_end(void)
{
    keyboard_data.viewport_end = keyboard_data.length;
    int maxlen = text_get_max_length_for_width(keyboard_data.text, keyboard_data.length, keyboard_data.font, keyboard_data.box_width, 1);
    keyboard_data.viewport_start = keyboard_data.length - maxlen;
}

static void update_viewport(int has_changed)
{
    int is_within_viewport = keyboard_data.cursor_position >= keyboard_data.viewport_start && keyboard_data.cursor_position <= keyboard_data.viewport_end;
    if (!has_changed && is_within_viewport) {
        // no update necessary
    } else if (keyboard_data.cursor_position == 0) {
        set_viewport_to_start();
    } else if (keyboard_data.cursor_position == keyboard_data.length) {
        set_viewport_to_end();
    } else {
        // first check if we can keep the viewport
        int new_start = keyboard_data.viewport_start;
        int new_end = text_get_max_length_for_width(keyboard_data.text, keyboard_data.length - new_start, keyboard_data.font, keyboard_data.box_width, 0);
        if (keyboard_data.cursor_position < new_start && keyboard_data.cursor_position >= new_end && new_start + new_end >= keyboard_data.length) {
            if (keyboard_data.cursor_position <= keyboard_data.viewport_cursor_position) {
                // move toward start
                int maxlen = text_get_max_length_for_width(
                    keyboard_data.text + keyboard_data.cursor_position,
                    keyboard_data.length - keyboard_data.cursor_position,
                    keyboard_data.font, keyboard_data.box_width, 0);
                if (keyboard_data.cursor_position + maxlen < keyboard_data.length) {
                    keyboard_data.viewport_start = keyboard_data.cursor_position;
                    keyboard_data.viewport_end = keyboard_data.cursor_position + maxlen;
                } else {
                    // all remaining text fits: set to end
                    set_viewport_to_end();
                }
            } else {
                // move toward end
                int viewport_length = keyboard_data.cursor_position + 1;
                int maxlen = text_get_max_length_for_width(
                    keyboard_data.text, viewport_length, keyboard_data.font, keyboard_data.box_width, 1);
                if (maxlen < viewport_length) {
                    keyboard_data.viewport_start = viewport_length - maxlen;
                    keyboard_data.viewport_end = viewport_length;
                } else {
                    // all remaining text fits: set to start
                    set_viewport_to_start();
                }
            }
        }
    }
    keyboard_data.viewport_cursor_position = keyboard_data.cursor_position;
}

static void init_scrollbar(int scrollbar_y)
{
    scrollbar_dot_y = scrollbar_y;
    scrollbar_position = 0;
    scrollbar_position_adjustment = 0;
}

static void show_file_dialog_window(int type, int dialog_type)
{
    input_text_string[0] = '\0';
    change_window(WINDOW_FILE_DIALOG);
    init_scrollbar(screen_center_y - 112);
    file_dialog_data.type = type;
    file_dialog_data.file_data = type == FILE_TYPE_SCENARIO ? &file_type_scenario_data : &saved_game_data;
    file_dialog_data.dialog_type = dialog_type;
    file_dialog_data.message_not_exist_start_time = 0;
    file_dialog_data.file_list = dir_list_files(file_dialog_data.file_data->extension);
    string_copy(file_dialog_data.file_list->files[0], file_dialog_data.selected_file, FILE_NAME_LENGTH_MAX - 1);
}

static void play_intro_music(void)
{
    if (settings[SETTINGS_MUSIC_ENABLED].config_value) {
        play_track(TRACK_INTRO);
    }
}

static void scale_main_menu_buttons(void)
{
    for (int i = 0; i < 5; i++) {
        image_buttons_main_menu[i].width_scaled = current_resolution_width / 4;
        image_buttons_main_menu[i].x_scaled = (current_resolution_width - image_buttons_main_menu[i].width_scaled) / 2;
        image_buttons_main_menu[i].y_scaled = (current_resolution_height - 5 * 25) / 2 + i * 35;
    }
}

static void show_main_menu_window(int restart_music)
{
    if (restart_music) {
        play_intro_music();
    }
    scale_main_menu_buttons();
    change_window(WINDOW_MAIN_MENU);
}

static void text_draw_month_year_max_width(int month, int year, int x_offset, int y_offset, int box_width, int font, uint32_t color)
{
    int month_width = text_get_width(short_month_names[month], font);
    int ad_bc_width = text_get_width(year ? "AD" : "BC", font);
    int space_width = DEFINITIONS_DEFAULT[font].space_width;
    int negative_padding = 0;
    // assume 3 digits in the year times 11 pixels plus letter spacing = approx 35px
    int total_width = month_width + ad_bc_width + 35 + 2 * space_width;
    if (total_width > box_width) {
        // take the overflow and divide it by two since we have two places to correct: after month, and after year
        negative_padding = (box_width - total_width) / 2;
        if (negative_padding < -2 * (space_width - 2)) {
            negative_padding = -2 * (space_width - 2);
        }
    }
    int width = negative_padding + text_draw(short_month_names[month], x_offset, y_offset, font, color);
    if (year >= 0) {
        width += negative_padding + text_draw_number_colored(year, ' ', " ", x_offset + width, y_offset, font, color);
        text_draw("AD", x_offset + width, y_offset, font, color);
    } else {
        width += negative_padding + text_draw_number_colored(-year, ' ', " ", x_offset + width, y_offset, font, color);
        text_draw("BC", x_offset + width, y_offset, font, color);
    }
}

static void draw_sidebar_ornaments(int y)
{
    for (int i = 0; i < current_resolution_height / 285; i++) { // 285 is ornament panel height
        image_draw(890, sidebar_x_offset, y + 285 * i);
    }
}

static void window_city_draw_background(void)
{
    draw_top_menu_bar();
    image_draw(885, 480, 0); // funds panel
    image_draw(885, 624, 0); // population panel
    image_draw(885, 840, 0); // time panel
    uint32_t treasure_color = COLOR_WHITE;
    if (city_data.finance.treasury < 0) {
        treasure_color = COLOR_FONT_RED;
    }
    int width = text_draw("Dn", 495, 5, FONT_NORMAL_PLAIN, treasure_color);
    text_draw_number_colored(city_data.finance.treasury, ' ', "", 501 + width, 5, FONT_NORMAL_PLAIN, treasure_color);
    width = text_draw("Pop", 645, 5, FONT_NORMAL_PLAIN, COLOR_WHITE);
    text_draw_number_colored(city_data.population.population, ' ', "", 651 + width, 5, FONT_NORMAL_PLAIN, COLOR_WHITE);
    text_draw_month_year_max_width(time_data.month, time_data.year, 850, 5, 110, FONT_NORMAL_PLAIN, COLOR_FONT_YELLOW);
    if (settings[SETTINGS_SIDEBAR_EXPANDED].config_value) {
        image_draw(887, sidebar_x_offset, 24); // draw sidebar buttons panel
        if (configs[CONFIG_UI_SIDEBAR_INFO].config_value) {
            inner_panel_draw(sidebar_x_offset, 474, 10, 19);
            text_draw("Game speed", sidebar_x_offset + 8, 486, FONT_NORMAL_WHITE, COLOR_BLACK);
            draw_arrow_button(15, sidebar_x_offset + 8, 502, 23);
            draw_arrow_button(17, sidebar_x_offset + 32, 502, 24);
            text_draw_percentage(settings[SETTINGS_GAME_SPEED].config_value, sidebar_x_offset + 64, 508, FONT_NORMAL_PLAIN);
            text_draw("Unemployment", sidebar_x_offset + 8, 534, FONT_NORMAL_WHITE, COLOR_BLACK);
            width = text_draw_percentage(city_data.labor.unemployment_percentage, sidebar_x_offset + 16, 550, FONT_NORMAL_PLAIN);
            text_draw_number(city_data.labor.workers_unemployed, '(', ")", sidebar_x_offset + 18 + width, 550, FONT_NORMAL_PLAIN);
            text_draw("Culture", sidebar_x_offset + 8, 574, FONT_NORMAL_WHITE, COLOR_BLACK);
            width = text_draw_number(city_data.ratings.culture, 0, 0, sidebar_x_offset + 16, 590, FONT_NORMAL_PLAIN);
            text_draw_number(scenario.culture_win_criteria, '(', ")", sidebar_x_offset + 18 + width, 590, FONT_NORMAL_PLAIN);
            text_draw("Prosperity", sidebar_x_offset + 8, 614, FONT_NORMAL_WHITE, COLOR_BLACK);
            width = text_draw_number(city_data.ratings.prosperity, 0, 0, sidebar_x_offset + 16, 630, FONT_NORMAL_PLAIN);
            text_draw_number(scenario.prosperity_win_criteria, '(', ")", sidebar_x_offset + 18 + width, 630, FONT_NORMAL_PLAIN);
            text_draw("Peace", sidebar_x_offset + 8, 654, FONT_NORMAL_WHITE, COLOR_BLACK);
            width = text_draw_number(city_data.ratings.peace, 0, 0, sidebar_x_offset + 16, 670, FONT_NORMAL_PLAIN);
            text_draw_number(scenario.peace_win_criteria, '(', ")", sidebar_x_offset + 18 + width, 670, FONT_NORMAL_PLAIN);
            text_draw("Favor", sidebar_x_offset + 8, 694, FONT_NORMAL_WHITE, COLOR_BLACK);
            width = text_draw_number(city_data.ratings.favor, 0, 0, sidebar_x_offset + 16, 710, FONT_NORMAL_PLAIN);
            text_draw_number(scenario.favor_win_criteria, '(', ")", sidebar_x_offset + 18 + width, 710, FONT_NORMAL_PLAIN);
            text_draw("Population", sidebar_x_offset + 8, 734, FONT_NORMAL_WHITE, COLOR_BLACK);
            width = text_draw_number(city_data.population.population, 0, 0, sidebar_x_offset + 16, 750, FONT_NORMAL_PLAIN);
            text_draw_number(scenario.population_win_criteria, '(', ")", sidebar_x_offset + 18 + width, 750, FONT_NORMAL_PLAIN);
            draw_sidebar_ornaments(778); // 24 top bar height + 450 sidebar buttons panel height + 19*16 extra panel height
        } else {
            draw_sidebar_ornaments(474); // 24 top bar height + 450 sidebar buttons panel height
        }
        switch (build_menu_data.selected_menu) {
            case MENU_VACANT_HOUSE:
                image_draw(7737, sidebar_x_offset + 6, 239);
                break;
            case MENU_CLEAR_LAND:
                if (scenario.climate == CLIMATE_DESERT) {
                    image_draw(7772, sidebar_x_offset + 6, 239);
                } else {
                    image_draw(7748, sidebar_x_offset + 6, 239);
                }
                break;
            case MENU_ROAD:
                if (scenario.climate == CLIMATE_DESERT) {
                    image_draw(7773, sidebar_x_offset + 6, 239);
                } else {
                    image_draw(7747, sidebar_x_offset + 6, 239);
                }
                break;
            case MENU_WATER:
                if (scenario.climate == CLIMATE_DESERT) {
                    image_draw(7774, sidebar_x_offset + 6, 239);
                } else {
                    image_draw(7740, sidebar_x_offset + 6, 239);
                }
                break;
            case MENU_HEALTH:
                image_draw(7742, sidebar_x_offset + 6, 239);
                break;
            case MENU_TEMPLES:
                image_draw(7738, sidebar_x_offset + 6, 239);
                break;
            case MENU_EDUCATION:
                image_draw(7743, sidebar_x_offset + 6, 239);
                break;
            case MENU_ENTERTAINMENT:
                image_draw(7741, sidebar_x_offset + 6, 239);
                break;
            case MENU_ADMINISTRATION:
                image_draw(7739, sidebar_x_offset + 6, 239);
                break;
            case MENU_ENGINEERING:
                image_draw(7744, sidebar_x_offset + 6, 239);
                break;
            case MENU_SECURITY:
                if (scenario.climate == CLIMATE_DESERT) {
                    image_draw(7775, sidebar_x_offset + 6, 239);
                } else {
                    image_draw(7745, sidebar_x_offset + 6, 239);
                }
                break;
            case MENU_INDUSTRY:
                image_draw(7746, sidebar_x_offset + 6, 239);
                break;
            default:
                image_draw(7749, sidebar_x_offset + 6, 239);
                break;
        }
    } else {
        image_draw(886, sidebar_x_offset, 24); // draw sidebar buttons panel
        for (int i = 0; i < current_resolution_height / 285; i++) { // 285 is ornament panel height
            image_draw(891, sidebar_x_offset, 474 + 285 * i); // draw narrow sidebar ornament panel(s)
        }
    }
}

static void draw_overlay_text(int x_offset)
{
    switch (state_data.current_overlay) {
        case 1:
            text_draw_centered("Risks", x_offset, 32, 117, FONT_NORMAL_GREEN, COLOR_BLACK);
            break;
        case 2:

            break;
        case 3:

            break;
        case 4:

            break;
        case 5:

            break;
        case 6:

            break;
        case 7:

            break;
        case 8:

            break;
        case 9:

            break;
        case 10:

            break;
        case 11:

            break;
        case 12:

            break;
        case 13:

            break;
        case 14:

            break;
        case 15:

            break;
        case 16:

            break;
        case 17:

            break;
        case 18:

            break;
        case 19:

            break;
        case 20:

            break;
        case 21:

            break;
        case 22:

            break;
        case 23:

            break;
        case 24:

            break;
        case 25:

            break;
        case 26:

            break;
        case 27:

            break;
        case 28:

            break;
        case 29:

            break;
        default:
            text_draw_centered("Overlays", x_offset, 32, 117, FONT_NORMAL_GREEN, COLOR_BLACK);
            break;

    }
}

static void decrease_game_speed(void)
{
    if (settings[SETTINGS_GAME_SPEED].config_value > 100) {
        settings[SETTINGS_GAME_SPEED].config_value -= 100;
    } else {
        settings[SETTINGS_GAME_SPEED].config_value = calc_bound(settings[SETTINGS_GAME_SPEED].config_value - 10, 10, 100);
    }
}

static void increase_game_speed(void)
{
    if (settings[SETTINGS_GAME_SPEED].config_value >= 100) {
        if (settings[SETTINGS_GAME_SPEED].config_value < 500) {
            settings[SETTINGS_GAME_SPEED].config_value += 100;
        }
    } else {
        settings[SETTINGS_GAME_SPEED].config_value = calc_bound(settings[SETTINGS_GAME_SPEED].config_value + 10, 10, 100);
    }
}

static void show_message_popup(int message_id);

static void update_sound_direction(void)
{
    for (int i = 0; i < MAX_CITY_SOUNDS_CHANNELS; i++) {
        for (int d = 0; d < 5; d++) {
            channels[i].direction_views[d] = 0;
        }
        channels[i].total_views /= 2;
    }
}

static void scroll_map_left(void)
{
    while (view_data.camera.pixel.x < 0) {
        view_data.camera.tile.x--;
        view_data.camera.pixel.x += TILE_WIDTH_PIXELS;
    }
    check_camera_boundaries();
    update_sound_direction();
}

static void scroll_map_right(void)
{
    while (view_data.camera.pixel.x >= TILE_WIDTH_PIXELS) {
        view_data.camera.tile.x++;
        view_data.camera.pixel.x -= TILE_WIDTH_PIXELS;
    }
    check_camera_boundaries();
    update_sound_direction();
}

static void scroll_map_up(void)
{
    while (view_data.camera.pixel.y < 0) {
        view_data.camera.tile.y -= 2;
        view_data.camera.pixel.y += TILE_HEIGHT_PIXELS;
    }
    check_camera_boundaries();
    update_sound_direction();
}

static void scroll_map_down(void)
{
    while (view_data.camera.pixel.y >= TILE_HEIGHT_PIXELS) {
        view_data.camera.tile.y += 2;
        view_data.camera.pixel.y -= TILE_HEIGHT_PIXELS;
    }
    check_camera_boundaries();
    update_sound_direction();
}

static void scroll_map(void)
{
    if (mouse_drag_scroll_active) {
        if (mouse_scroll_x - mouse_scroll_initial_x < 0) {
            view_data.camera.pixel.x -= pow(abs((mouse_scroll_x - mouse_scroll_initial_x) / 25), 1.25);
            scroll_map_left();
        } else if (mouse_scroll_x - mouse_scroll_initial_x > 0) {
            view_data.camera.pixel.x += pow(abs((mouse_scroll_x - mouse_scroll_initial_x) / 25), 1.25);
            scroll_map_right();
        }
        if (mouse_scroll_y - mouse_scroll_initial_y < 0) {
            view_data.camera.pixel.y -= pow(abs((mouse_scroll_y - mouse_scroll_initial_y) / 25), 1.25);
            scroll_map_up();
        } else if (mouse_scroll_y - mouse_scroll_initial_y > 0) {
            view_data.camera.pixel.y += pow(abs((mouse_scroll_y - mouse_scroll_initial_y) / 25), 1.25);
            scroll_map_down();
        }
    } else if (!configs[CONFIG_UI_DISABLE_MOUSE_EDGE_SCROLLING].config_value) {
        if (mouse_x < 5) {
            view_data.camera.pixel.x -= settings[SETTINGS_SCROLL_SPEED].config_value / 5;
            scroll_map_left();
        }
        if (mouse_x > current_resolution_width - 5) {
            view_data.camera.pixel.x += settings[SETTINGS_SCROLL_SPEED].config_value / 5;
            scroll_map_right();
        }
        if (mouse_y < 5) {
            view_data.camera.pixel.y -= settings[SETTINGS_SCROLL_SPEED].config_value / 5;
            scroll_map_up();
        }
        if (mouse_y > current_resolution_height - 5) {
            view_data.camera.pixel.y += settings[SETTINGS_SCROLL_SPEED].config_value / 5;
            scroll_map_down();
        }
    }
    if ((is_key_scrolling_left || is_key_scrolling_right || is_key_scrolling_up || is_key_scrolling_down)) {
        if (is_key_scrolling_left) {
            view_data.camera.pixel.x -= settings[SETTINGS_SCROLL_SPEED].config_value / 5;
            scroll_map_left();
        }
        if (is_key_scrolling_right) {
            view_data.camera.pixel.x += settings[SETTINGS_SCROLL_SPEED].config_value / 5;
            scroll_map_right();
        }
        if (is_key_scrolling_up) {
            view_data.camera.pixel.y -= settings[SETTINGS_SCROLL_SPEED].config_value / 5;
            scroll_map_up();
        }
        if (is_key_scrolling_down) {
            view_data.camera.pixel.y += settings[SETTINGS_SCROLL_SPEED].config_value / 5;
            scroll_map_down();
        }
    }
}

static void draw_foreground_city(void)
{
    if (settings[SETTINGS_SIDEBAR_EXPANDED].config_value) {
        draw_image_button(1104, sidebar_x_offset + 4, 27, 117, 25, -1); // overlay button
        draw_overlay_text(sidebar_x_offset + 4);
        draw_image_button(967, sidebar_x_offset + 127, 29, 31, 20, 1); // sidebar slide button
        draw_image_button(949, sidebar_x_offset + 7, 180, 71, 23, 2); // advisors button
        draw_image_button(952, sidebar_x_offset + 84, 180, 71, 23, 3); // empire button
        draw_image_button(955, sidebar_x_offset + 7, 209, 33, 22, 4); // mission briefing button
        draw_image_button(958, sidebar_x_offset + 46, 209, 33, 22, 5); // rotation reset button
        draw_image_button(961, sidebar_x_offset + 84, 209, 33, 22, 6); // rotate left button
        draw_image_button(964, sidebar_x_offset + 123, 209, 33, 22, 7); // rotate right button
        // draw build menu
        if (build_menus[MENU_VACANT_HOUSE].is_enabled) {
            draw_image_button(993, sidebar_x_offset + 13, 301, 39, 26, 8); // vacant lot
        } else {
            image_draw(996, sidebar_x_offset + 13, 301);
        }
        if (build_menus[MENU_CLEAR_LAND].is_enabled) {
            draw_image_button(1001, sidebar_x_offset + 63, 301, 39, 26, 9); // clear land
        } else {
            image_draw(1004, sidebar_x_offset + 63, 301);
        }
        if (build_menus[MENU_ROAD].is_enabled) {
            draw_image_button(1005, sidebar_x_offset + 113, 301, 39, 26, 10); // road
        } else {
            image_draw(1008, sidebar_x_offset + 113, 301);
        }
        if (build_menus[MENU_WATER].is_enabled) {
            draw_image_button(997, sidebar_x_offset + 13, 337, 39, 26, 11); // water
        } else {
            image_draw(1000, sidebar_x_offset + 13, 337);
        }
        if (build_menus[MENU_HEALTH].is_enabled) {
            draw_image_button(1033, sidebar_x_offset + 63, 337, 39, 26, 12); // health
        } else {
            image_draw(1036, sidebar_x_offset + 63, 337);
        }
        if (build_menus[MENU_TEMPLES].is_enabled) {
            draw_image_button(1021, sidebar_x_offset + 113, 337, 39, 26, 13); // religion
        } else {
            image_draw(1024, sidebar_x_offset + 113, 337);
        }
        if (build_menus[MENU_EDUCATION].is_enabled) {
            draw_image_button(1017, sidebar_x_offset + 13, 373, 39, 26, 14); // education
        } else {
            image_draw(1020, sidebar_x_offset + 13, 373);
        }
        if (build_menus[MENU_ENTERTAINMENT].is_enabled) {
            draw_image_button(1013, sidebar_x_offset + 63, 373, 39, 26, 15); // entertainment
        } else {
            image_draw(1016, sidebar_x_offset + 63, 373);
        }
        if (build_menus[MENU_ADMINISTRATION].is_enabled) {
            draw_image_button(1009, sidebar_x_offset + 113, 373, 39, 26, 16); // administrative
        } else {
            image_draw(1012, sidebar_x_offset + 113, 373);
        }
        if (build_menus[MENU_ENGINEERING].is_enabled) {
            draw_image_button(1037, sidebar_x_offset + 13, 409, 39, 26, 17); // engineering
        } else {
            image_draw(1040, sidebar_x_offset + 13, 409);
        }
        if (build_menus[MENU_SECURITY].is_enabled) {
            draw_image_button(1029, sidebar_x_offset + 63, 409, 39, 26, 18); // security
        } else {
            image_draw(1032, sidebar_x_offset + 63, 409);
        }
        if (build_menus[MENU_INDUSTRY].is_enabled) {
            draw_image_button(1025, sidebar_x_offset + 113, 409, 39, 26, 19); // industry
        } else {
            image_draw(1028, sidebar_x_offset + 113, 409);
        }
        if (undo_data.ready && undo_data.available) {
            draw_image_button(1041, sidebar_x_offset + 13, 445, 39, 26, 20); // undo
        } else {
            image_draw(1044, sidebar_x_offset + 13, 445);
        }
        draw_image_button(985, sidebar_x_offset + 63, 445, 39, 26, 21); // messages
        if (message_data.total_messages) {
            text_draw_number_colored(message_data.total_messages, 0, 0, sidebar_x_offset + 89, 453, FONT_SMALL_PLAIN, COLOR_BLACK);
            text_draw_number_colored(message_data.total_messages, 0, 0, sidebar_x_offset + 88, 452, FONT_SMALL_PLAIN, COLOR_WHITE);
        }
        if (message_data.problem_count) {
            draw_image_button(989, sidebar_x_offset + 113, 445, 39, 26, 22); // go to problem
        } else {
            image_draw(992, sidebar_x_offset + 113, 445);
        }
    } else {
        // int x_offset = sidebar_x_offset;
    }
    scroll_map();
    widget_city_draw();
    update_city_view_coords(mouse_x, mouse_y, &widget_city_data.current_tile);
    widget_minimap_draw(sidebar_x_offset + 8, 59, 146, 111, 1);


    // }
    // if (current_window == WINDOW_CITY) {
    //     if (scenario.time_limit_win_criteria && !city_data.mission.has_won) {
    //         int remaining_months;
    //         if (scenario.start_year + scenario.time_limit_win_criteria <= time_data.year + 1) {
    //             remaining_months = 12 - time_data.month;
    //         } else {
    //             remaining_months = 12 - time_data.month + 12 * (scenario.start_year + scenario.time_limit_win_criteria - time_data.year - 1);
    //         }
    //         label_draw(1, 25, 15, 1);
    //         int width = lang_text_draw(6, 2, 6, 29, FONT_NORMAL_BLACK);
    //         text_draw_number(remaining_months, ' ', 0, 6 + width, 29, FONT_NORMAL_BLACK);
    //     } else if (scenario.survival_time_win_criteria && !city_data.mission.has_won) {
    //         int remaining_months;
    //         if (scenario.start_year + scenario.survival_time_win_criteria <= time_data.year + 1) {
    //             remaining_months = 12 - time_data.month;
    //         } else {
    //             remaining_months = 12 - time_data.month + 12 * (scenario.start_year + scenario.survival_time_win_criteria - time_data.year - 1);
    //         }
    //         label_draw(1, 25, 15, 1);
    //         int width = lang_text_draw(6, 3, 6, 29, FONT_NORMAL_BLACK);
    //         text_draw_number(remaining_months, ' ', 0, 6 + width, 29, FONT_NORMAL_BLACK);
    //     }
    //     if (state_data.paused) {
    //         int x_offset = center_in_city(448);
    //         outer_panel_draw(x_offset, 40, 28, 3);
    //         text_draw_centered("Game paused", x_offset, 58, 448, FONT_NORMAL_BLACK, COLOR_BLACK);
    //     }
    // }
    // if (!scroll_data.is_scrolling && !scroll_data.drag.active) {
    //     int size_x, size_y;
    //     int cost = construction_data.cost_preview;
    //     int has_size;
    //     if (!building_construction_is_updatable() || !construction_data.in_progress || (construction_data.type != BUILDING_CLEAR_LAND && !construction_data.cost_preview)) {
    //         has_size = 0;
    //     } else {
    //         size_x = construction_data.end.x - construction_data.start.x;
    //         size_y = construction_data.end.y - construction_data.start.y;
    //         if (size_x < 0) {
    //             size_x = -size_x;
    //         }
    //         if (size_y < 0) {
    //             size_y = -size_y;
    //         }
    //         size_x++;
    //         size_y++;
    //         has_size = 1;
    //     }
    //     if (cost && has_size) {
    //         set_city_clip_rectangle();
    //         int x, y;
    //         city_view_get_selected_tile_pixels(&x, &y);
    //         uint32_t color;
    //         if (cost <= city_data.finance.treasury) {
    //             // Color blind friendly
    //             color = scenario.climate == CLIMATE_DESERT ? COLOR_FONT_ORANGE : COLOR_FONT_ORANGE_LIGHT;
    //         } else {
    //             color = COLOR_FONT_RED;
    //         }
    //         text_draw_number_colored(cost, '@', " ", x + 58 + 1, y + 1, FONT_NORMAL_PLAIN, COLOR_BLACK);
    //         text_draw_number_colored(cost, '@', " ", x + 58, y, FONT_NORMAL_PLAIN, color);
    //         int width = -text_get_width("  ", FONT_SMALL_PLAIN);
    //         width += text_draw_number_colored(size_x, '@', "x", x - 15 + 1, y + 25 + 1, FONT_SMALL_PLAIN, COLOR_BLACK);
    //         text_draw_number_colored(size_x, '@', "x", x - 15, y + 25, FONT_SMALL_PLAIN, COLOR_FONT_YELLOW);
    //         text_draw_number_colored(size_y, '@', " ", x - 15 + width + 1, y + 25 + 1, FONT_SMALL_PLAIN, COLOR_BLACK);
    //         text_draw_number_colored(size_y, '@', " ", x - 15 + width, y + 25, FONT_SMALL_PLAIN, COLOR_FONT_YELLOW);
    //         graphics_reset_clip_rectangle();
    //     }
    // }
    // if (current_window == WINDOW_CITY) {
    //     if (message_data.consecutive_message_delay > 0) {
    //         message_data.consecutive_message_delay--;
    //         return;
    //     }
    //     int sequence = 0;
    //     for (int i = 0; i < MAX_MESSAGE_QUEUE; i++) {
    //         if (message_data.queue[i]) {
    //             sequence = message_data.queue[i];
    //             message_data.queue[i] = 0;
    //             break;
    //         }
    //     }
    //     if (sequence == 0) {
    //         return;
    //     }
    //     int message_id = -1;
    //     for (int i = 0; i < 999; i++) {
    //         if (!message_data.messages[i].message_type) {
    //             return;
    //         }
    //         if (message_data.messages[i].sequence == sequence) {
    //             message_id = i;
    //             break;
    //         }
    //     }
    //     if (message_id >= 0) {
    //         show_message_popup(message_id);
    //     }
    // }
}

static int get_center_grid_offset(void)
{
    int x_center = view_data.camera.tile.x + view_data.viewport.width_tiles / 2;
    int y_center = view_data.camera.tile.y + view_data.viewport.height_tiles / 2;
    return view_to_grid_offset_lookup[x_center][y_center];
}

static void city_view_grid_offset_to_xy_view(int grid_offset, int *x_view, int *y_view)
{
    *x_view = *y_view = 0;
    for (int y = 0; y < VIEW_Y_MAX; y++) {
        for (int x = 0; x < VIEW_X_MAX; x++) {
            if (view_to_grid_offset_lookup[x][y] == grid_offset) {
                *x_view = x;
                *y_view = y;
                return;
            }
        }
    }
}

static void city_view_rotate_left(void)
{
    int center_grid_offset = get_center_grid_offset();
    view_data.orientation += 2;
    if (view_data.orientation > 6) {
        view_data.orientation = DIR_0_TOP;
    }
    calculate_lookup();
    if (center_grid_offset >= 0) {
        int x, y;
        city_view_grid_offset_to_xy_view(center_grid_offset, &x, &y);
        view_data.camera.tile.x = x - view_data.viewport.width_tiles / 2;
        view_data.camera.tile.y = y - view_data.viewport.height_tiles / 2;
    }
    check_camera_boundaries();
}

static void update_water_tile(int x, int y, int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_WATER) && !map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
        foreach_region_tile(x - 1, y - 1, x + 1, y + 1, set_water_image);
    }
}

static void map_tiles_update_all_water(void)
{
    for (int y = 0, grid_offset = map_data.start_offset; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            update_water_tile(x, y, grid_offset);
        }
    }
}

static int map_routing_wall_tile_in_radius(int x, int y, int radius, int *x_wall, int *y_wall)
{
    for (int i = 1; i <= radius; i++) {
        int wall_tile_in_radius = 0;
        int size = 1;
        int x_min, y_min, x_max, y_max;
        map_grid_get_area(x, y, size, i, &x_min, &y_min, &x_max, &y_max);
        for (int yy = y_min; yy <= y_max; yy++) {
            for (int xx = x_min; xx <= x_max; xx++) {
                if (terrain_walls.items[map_grid_offset(xx, yy)] == WALL_0_PASSABLE) {
                    *x_wall = xx;
                    *y_wall = yy;
                    wall_tile_in_radius = 1;
                    break;
                }
            }
        }
        if (wall_tile_in_radius) {
            return 1;
        }
    }
    return 0;
}

static void figure_tower_sentry_reroute(void)
{
    for (int i = 1; i < MAX_FIGURES; i++) {
        struct figure_t *f = &figures[i];
        if (f->type != FIGURE_TOWER_SENTRY || terrain_walls.items[f->grid_offset] == WALL_0_PASSABLE) {
            continue;
        }
        // tower sentry got off wall due to rotation
        int x_tile, y_tile;
        if (map_routing_wall_tile_in_radius(f->x, f->y, 2, &x_tile, &y_tile)) {
            figure_route_remove(f);
            f->progress_on_tile = 0;
            map_figure_delete(f);
            f->previous_tile_x = f->x = x_tile;
            f->previous_tile_y = f->y = y_tile;
            f->cross_country_x = 15 * x_tile;
            f->cross_country_y = 15 * y_tile;
            f->grid_offset = map_grid_offset(x_tile, y_tile);
            map_figure_add(f);
            f->action_state = FIGURE_ACTION_TOWER_SENTRY_RETURNING;
            f->destination_x = f->source_x;
            f->destination_y = f->source_y;
        } else {
            // Teleport back to tower
            map_figure_delete(f);
            struct building_t *b = &all_buildings[f->building_id];
            f->source_x = f->x = b->x;
            f->source_y = f->y = b->y;
            f->grid_offset = map_grid_offset(f->x, f->y);
            map_figure_add(f);
            f->action_state = FIGURE_ACTION_TOWER_SENTRY_AT_REST;
            figure_route_remove(f);
        }
    }
}

static void set_horse_destination(struct figure_t *f, int state)
{
    struct building_t *b = &all_buildings[f->building_id];
    int orientation = view_data.orientation;
    if (state == HORSE_CREATED) {
        map_figure_delete(f);
        if (orientation == DIR_0_TOP || orientation == DIR_6_LEFT) {
            f->destination_x = b->x + HORSE_DESTINATION_1[f->wait_ticks_missile].x;
            f->destination_y = b->y + HORSE_DESTINATION_1[f->wait_ticks_missile].y;
        } else {
            f->destination_x = b->x + HORSE_DESTINATION_2[f->wait_ticks_missile].x;
            f->destination_y = b->y + HORSE_DESTINATION_2[f->wait_ticks_missile].y;
        }
        if (f->resource_id == 1) {
            f->destination_y++;
        }
        f->x = f->destination_x;
        f->y = f->destination_y;
        f->cross_country_x = 15 * f->x;
        f->cross_country_y = 15 * f->y;
        f->grid_offset = map_grid_offset(f->x, f->y);
        map_figure_add(f);
    } else if (state == HORSE_RACING) {
        if (orientation == DIR_0_TOP || orientation == DIR_6_LEFT) {
            f->destination_x = b->x + HORSE_DESTINATION_1[f->wait_ticks_missile].x;
            f->destination_y = b->y + HORSE_DESTINATION_1[f->wait_ticks_missile].y;
        } else {
            f->destination_x = b->x + HORSE_DESTINATION_2[f->wait_ticks_missile].x;
            f->destination_y = b->y + HORSE_DESTINATION_2[f->wait_ticks_missile].y;
        }
    } else if (state == HORSE_FINISHED) {
        if (orientation == DIR_0_TOP || orientation == DIR_6_LEFT) {
            if (f->resource_id) {
                f->destination_x = b->x + 1;
                f->destination_y = b->y + 2;
            } else {
                f->destination_x = b->x + 1;
                f->destination_y = b->y + 1;
            }
        } else {
            if (f->resource_id) {
                f->destination_x = b->x + 12;
                f->destination_y = b->y + 3;
            } else {
                f->destination_x = b->x + 12;
                f->destination_y = b->y + 2;
            }
        }
    }
}

static void map_orientation_change(int counter_clockwise)
{
    undo_data.available = 0;
    int orientation = view_data.orientation;
    int grid_offset = map_data.start_offset;
    for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset++) {
            int size = map_property_multi_tile_size(grid_offset);
            if (size == 1) {
                edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
                continue;
            }
            edge_grid.items[grid_offset] &= ~EDGE_LEFTMOST_TILE;
            int dx = orientation == DIR_4_BOTTOM || orientation == DIR_6_LEFT ? size - 1 : 0;
            int dy = orientation == DIR_0_TOP || orientation == DIR_6_LEFT ? size - 1 : 0;
            if ((edge_grid.items[grid_offset] & EDGE_MASK_XY) == 8 * dy + dx) {
                edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
            }
        }
    }
    map_tiles_update_all_elevation();
    map_tiles_update_all_water();
    map_tiles_update_all_earthquake();
    map_tiles_update_all_gardens();
    map_tiles_add_entry_exit_flags();
    map_tiles_update_all_empty_land();
    for (int y = 0, grid_offset2 = map_data.start_offset; y < map_data.height; y++, grid_offset2 += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset2++) {
            set_rubble_image(x, y, grid_offset2);
        }
    }
    map_tiles_update_all_roads();
    map_tiles_update_all_plazas();
    map_tiles_update_all_walls();
    map_tiles_update_all_aqueducts(0);
    map_orientation_update_buildings();
    int grid_offset3 = map_data.start_offset;
    for (int y = 0; y < map_data.height; y++, grid_offset3 += map_data.border_size) {
        for (int x = 0; x < map_data.width; x++, grid_offset3++) {
            if (map_is_bridge(grid_offset3)) {
                int new_value;
                switch (sprite.items[grid_offset3]) {
                    case 1: new_value = counter_clockwise ? 2 : 4; break;
                    case 2: new_value = counter_clockwise ? 3 : 1; break;
                    case 3: new_value = counter_clockwise ? 4 : 2; break;
                    case 4: new_value = counter_clockwise ? 1 : 3; break;
                    case 5: new_value = 6; break;
                    case 6: new_value = 5; break;
                    case 7: new_value = counter_clockwise ? 8 : 10; break;
                    case 8: new_value = counter_clockwise ? 9 : 7; break;
                    case 9: new_value = counter_clockwise ? 10 : 8; break;
                    case 10: new_value = counter_clockwise ? 7 : 9; break;
                    case 11: new_value = 12; break;
                    case 12: new_value = 11; break;
                    case 13: new_value = 13; break;
                    case 14: new_value = 15; break;
                    case 15: new_value = 14; break;
                    default: new_value = sprite.items[grid_offset3];
                }
                sprite.items[grid_offset3] = new_value;
            }
        }
    }
    map_routing_update_walls();
    figure_tower_sentry_reroute();
    if (city_data.entertainment.hippodrome_has_race) {
        for (int i = 1; i < MAX_FIGURES; i++) {
            struct figure_t *f = &figures[i];
            if (figure_is_alive(f) && f->type == FIGURE_HIPPODROME_HORSES) {
                f->wait_ticks_missile = 0;
                set_horse_destination(f, HORSE_CREATED);
            }
        }
    }
}

static void game_orientation_rotate_left(void)
{
    city_view_rotate_left();
    map_orientation_change(0);
    minimap_data.refresh_requested = 1;
    city_warning_show(WARNING_ORIENTATION);
}

static void city_view_rotate_right(void)
{
    int center_grid_offset = get_center_grid_offset();

    view_data.orientation -= 2;
    if (view_data.orientation < 0) {
        view_data.orientation = DIR_6_LEFT;
    }
    calculate_lookup();
    if (center_grid_offset >= 0) {
        int x, y;
        city_view_grid_offset_to_xy_view(center_grid_offset, &x, &y);
        view_data.camera.tile.x = x - view_data.viewport.width_tiles / 2;
        view_data.camera.tile.y = y - view_data.viewport.height_tiles / 2;
    }
    check_camera_boundaries();
}

static void game_orientation_rotate_right(void)
{
    city_view_rotate_right();
    map_orientation_change(1);
    minimap_data.refresh_requested = 1;
    city_warning_show(WARNING_ORIENTATION);
}

static void callback_calc_distance(int next_offset, int dist)
{
    if (terrain_land_citizen.items[next_offset] >= CITIZEN_0_ROAD) {
        enqueue(next_offset, dist);
    }
}

static void map_routing_calculate_distances(int x, int y)
{
    ++stats.total_routes_calculated;
    route_queue(map_grid_offset(x, y), -1, callback_calc_distance);
}

static void update_legion_standard_map_location(struct formation_t *legion_formation)
{
    struct figure_t *standard = &figures[legion_formation->legion_standard__figure_id];
    map_figure_delete(standard);
    standard->grid_offset = map_grid_offset(legion_formation->standard_x, legion_formation->standard_y);
    map_figure_add(standard);
}

static void return_legion_formation_home(struct formation_t *m)
{
    map_routing_calculate_distances(m->standard_x, m->standard_y);
    m->standard_x = all_buildings[m->building_id].x + 3;
    m->standard_y = all_buildings[m->building_id].y - 1;
    update_legion_standard_map_location(m);
    for (int i = 0; i < MAX_FORMATION_FIGURES && m->figures[i]; i++) {
        struct figure_t *f = &figures[m->figures[i]];
        f->action_state = FIGURE_ACTION_SOLDIER_GOING_TO_FORT;
        figure_route_remove(f);
    }
    selected_legion_formation = 0;
    cursor_data.current_shape = CURSOR_ARROW;
    SDL_SetCursor(cursor_data.cursors[CURSOR_ARROW]);
}

static void city_message_sort_and_compact(void)
{
    for (int i = 0; i < MAX_MESSAGES; i++) {
        for (int a = 0; a < MAX_MESSAGES - 1; a++) {
            int swap = 0;
            if (message_data.messages[a].message_type) {
                if (message_data.messages[a].sequence < message_data.messages[a + 1].sequence) {
                    if (message_data.messages[a + 1].message_type) {
                        swap = 1;
                    }
                }
            } else if (message_data.messages[a + 1].message_type) {
                swap = 1;
            }
            if (swap) {
                struct city_message_t tmp_message = message_data.messages[a];
                message_data.messages[a] = message_data.messages[a + 1];
                message_data.messages[a + 1] = tmp_message;
            }
        }
    }
    message_data.total_messages = 0;
    for (int i = 0; i < MAX_MESSAGES; i++) {
        if (message_data.messages[i].message_type) {
            message_data.total_messages++;
        }
    }
}

static void city_view_go_to_grid_offset(int grid_offset)
{
    int x, y;
    city_view_grid_offset_to_xy_view(grid_offset, &x, &y);
    view_data.camera.tile.x = x - view_data.viewport.width_tiles / 2;
    view_data.camera.tile.y = y - view_data.viewport.height_tiles / 2;
    view_data.camera.tile.y &= ~1;
    check_camera_boundaries();
}

static void close_build_menu(void)
{
    build_menu_data.selected_menu = -1;
    build_menu_data.selected_submenu = -1;
    current_window_image_button_pressed = 0;
}

static void button_go_to_problem(void)
{
    close_build_menu();
    if (current_time - message_data.problem_last_click_time > 3000) {
        message_data.problem_index = 0;
    }
    message_data.problem_last_click_time = current_time;
    city_message_sort_and_compact();
    message_data.problem_count = 0;
    for (int i = 0; i < 999; i++) {
        struct city_message_t *msg = &message_data.messages[i];
        if (msg->message_type && msg->year >= time_data.year - 1) {
            struct lang_message_t *lang_msg = &lang_data.message_entries[city_message_get_text_id(msg->message_type)];
            int lang_msg_type = lang_msg->message_type;
            if (lang_msg_type == MESSAGE_TYPE_DISASTER || lang_msg_type == MESSAGE_TYPE_INVASION) {
                message_data.problem_count++;
            }
        }
    }
    if (message_data.problem_count <= 0) {
        message_data.problem_index = 0;
        // window_invalidate();
        return;
    }
    if (message_data.problem_index >= message_data.problem_count) {
        message_data.problem_index = 0;
    }
    int index = 0;
    int current_year = time_data.year;
    for (int i = 0; i < 999; i++) {
        struct city_message_t *msg = &message_data.messages[i];
        if (msg->message_type && msg->year >= current_year - 1) {
            int text_id = city_message_get_text_id(msg->message_type);
            int lang_msg_type = lang_data.message_entries[text_id].message_type;
            if (lang_msg_type == MESSAGE_TYPE_DISASTER || lang_msg_type == MESSAGE_TYPE_INVASION) {
                index++;
                if (message_data.problem_index < index) {
                    message_data.problem_index++;
                    city_view_go_to_grid_offset(msg->param2);
                    show_city_window();
                }
            }
        }
    }
}

static void set_construction_building_type(int type)
{
    building_construction_cancel();
    building_construction_set_type(type);
}

static void city_finance_process_construction(int cost)
{
    city_data.finance.treasury -= cost;
    city_data.finance.this_year.expenses.construction += cost;
}

static void set_crop_tile(int building_id, int x, int y, int dx, int dy, int crop_image_id, int growth)
{
    int grid_offset = map_grid_offset(x + dx, y + dy);
    terrain_grid.items[grid_offset] &= ~TERRAIN_CLEARABLE;
    terrain_grid.items[grid_offset] |= TERRAIN_BUILDING;
    buildings_grid.items[grid_offset] = building_id;
    bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
    map_property_set_multi_tile_xy(grid_offset, dx, dy, 1);
    images.items[grid_offset] = crop_image_id + (growth < 4 ? growth : 4);
}

static void map_building_tiles_add_farm(int building_id, int x, int y, int crop_image_id, int progress)
{
    if (!map_grid_is_inside(x, y, 3)) {
        return;
    }
    // farmhouse
    int x_leftmost, y_leftmost;
    switch (view_data.orientation) {
        case DIR_0_TOP:
            x_leftmost = 0;
            y_leftmost = 1;
            break;
        case DIR_2_RIGHT:
            x_leftmost = 0;
            y_leftmost = 0;
            break;
        case DIR_4_BOTTOM:
            x_leftmost = 1;
            y_leftmost = 0;
            break;
        case DIR_6_LEFT:
            x_leftmost = 1;
            y_leftmost = 1;
            break;
        default:
            return;
    }
    for (int dy = 0; dy < 2; dy++) {
        for (int dx = 0; dx < 2; dx++) {
            int grid_offset = map_grid_offset(x + dx, y + dy);
            terrain_grid.items[grid_offset] &= ~TERRAIN_CLEARABLE;
            terrain_grid.items[grid_offset] |= TERRAIN_BUILDING;
            buildings_grid.items[grid_offset] = building_id;
            bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
            map_property_set_multi_tile_size(grid_offset, 2);
            images.items[grid_offset] = 2883;
            map_property_set_multi_tile_xy(grid_offset, dx, dy,
                dx == x_leftmost && dy == y_leftmost);
        }
    }
    // crop tile 1
    int growth = progress / 10;
    set_crop_tile(building_id, x, y, 0, 2, crop_image_id, growth);

    // crop tile 2
    growth -= 4;
    if (growth < 0) {
        growth = 0;
    }
    set_crop_tile(building_id, x, y, 1, 2, crop_image_id, growth);

    // crop tile 3
    growth -= 4;
    if (growth < 0) {
        growth = 0;
    }
    set_crop_tile(building_id, x, y, 2, 2, crop_image_id, growth);

    // crop tile 4
    growth -= 4;
    if (growth < 0) {
        growth = 0;
    }
    set_crop_tile(building_id, x, y, 2, 1, crop_image_id, growth);

    // crop tile 5
    growth -= 4;
    if (growth < 0) {
        growth = 0;
    }
    set_crop_tile(building_id, x, y, 2, 0, crop_image_id, growth);
}

static void city_resource_add_to_warehouse(int resource, int amount)
{
    city_data.resource.space_in_warehouses[resource] -= amount;
    city_data.resource.stored_in_warehouses[resource] += amount;
}

static int building_warehouse_add_resource(struct building_t *b, int resource)
{
    if (b->id <= 0) {
        return 0;
    }
    // check building itself
    int find_space = 0;
    if (b->subtype.warehouse_resource_id && b->subtype.warehouse_resource_id != resource) {
        find_space = 1;
    } else if (b->loads_stored >= 4) {
        find_space = 1;
    } else if (b->type == BUILDING_WAREHOUSE) {
        find_space = 1;
    }
    if (find_space) {
        int space_found = 0;
        struct building_t *space = building_main(b);
        for (int i = 0; i < 8; i++) {
            space = &all_buildings[space->next_part_building_id];
            if (!space->id) {
                return 0;
            }
            if (!space->subtype.warehouse_resource_id || space->subtype.warehouse_resource_id == resource) {
                if (space->loads_stored < 4) {
                    space_found = 1;
                    b = space;
                    break;
                }
            }
        }
        if (!space_found) {
            return 0;
        }
    }
    city_resource_add_to_warehouse(resource, 1);
    b->subtype.warehouse_resource_id = resource;
    b->loads_stored++;
    building_warehouse_space_set_image(b, resource);
    return 1;
}

static void set_destination__closest_building_of_type(int closest_to__building_id, int closest_building_of_type__type, struct map_point_t *closest_building_of_type__road_tile)
{
    int min_distance = 10000;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_IN_USE && b->type == closest_building_of_type__type && b->num_workers >= building_properties[closest_building_of_type__type].n_laborers) {
            struct building_t *closest_to__building = &all_buildings[closest_to__building_id];
            int dist = calc_maximum_distance(closest_to__building->x, closest_to__building->y, b->x, b->y);
            if (dist < min_distance) {
                if (map_has_road_access(b->x, b->y, b->size, closest_building_of_type__road_tile)) {
                    min_distance = dist;
                }
            }
        }
    }
}

static void building_clear_related_data(struct building_t *b)
{
    if (b->storage_id) {
        storages[b->storage_id].in_use = 0;
        b->storage_id = 0;
    }
    if (b->type == BUILDING_SENATE) {
        if (b->grid_offset == city_data.building.senate_grid_offset) {
            city_data.building.senate_grid_offset = 0;
            city_data.building.senate_x = 0;
            city_data.building.senate_y = 0;
            city_data.building.senate_placed = 0;
        }
    }
    if (b->type == BUILDING_DOCK) {
        city_data.building.working_docks--;
    }
    if (b->type == BUILDING_BARRACKS) {
        if (b->grid_offset == city_data.building.barracks_grid_offset) {
            city_data.building.barracks_grid_offset = 0;
            city_data.building.barracks_x = 0;
            city_data.building.barracks_y = 0;
            city_data.building.barracks_placed = 0;
        }
    }
    if (building_is_fort(b->type)) {
        city_data.military.total_legions--;
        struct formation_t *m = &legion_formations[b->formation_id];
        if (m->in_use) {
            for (int i = 0; i < m->num_figures; i++) {
                struct figure_t *f = &figures[m->figures[i]];
                struct map_point_t nearest_barracks_road_tile = { 0 };
                set_destination__closest_building_of_type(b->id, BUILDING_BARRACKS, &nearest_barracks_road_tile);
                figure_route_remove(f);
                if (nearest_barracks_road_tile.x) {
                    f->destination_x = nearest_barracks_road_tile.x;
                    f->destination_y = nearest_barracks_road_tile.y;
                } else {
                    f->destination_x = scenario.exit_point.x;
                    f->destination_y = scenario.exit_point.y;
                }
                f->action_state = FIGURE_ACTION_SOLDIER_RETURNING_TO_BARRACKS;
            }
            map_figure_delete(&figures[m->legion_standard__figure_id]);
            memset(&legion_formations[b->formation_id], 0, sizeof(struct formation_t));
            m->id = b->formation_id;
        }
    }
    if (b->type == BUILDING_HIPPODROME) {
        city_data.building.hippodrome_placed = 0;
    }
}

static void building_delete(struct building_t *b)
{
    building_clear_related_data(b);
    int id = b->id;
    memset(b, 0, sizeof(struct building_t));
    b->id = id;
}

static void remove_from_census(int num_people)
{
    int index = 0;
    int empty_buckets = 0;
    // remove people randomly up to age 63
    while (num_people > 0 && empty_buckets < 100) {
        int age = random_data.pool[(random_data.pool_index + index) % MAX_RANDOM] & 0x3f;
        index++;
        if (city_data.population.at_age[age] <= 0) {
            empty_buckets++;
        } else {
            city_data.population.at_age[age]--;
            num_people--;
            empty_buckets = 0;
        }
    }
    // if random didn't work: remove from age 10 and up
    empty_buckets = 0;
    int age = 10;
    while (num_people > 0 && empty_buckets < 100) {
        if (city_data.population.at_age[age] <= 0) {
            empty_buckets++;
        } else {
            city_data.population.at_age[age]--;
            num_people--;
            empty_buckets = 0;
        }
        age++;
        if (age >= 100) {
            age = 0;
        }
    }
}

static void recalculate_population(void)
{
    city_data.population.population = 0;
    for (int i = 0; i < 100; i++) {
        city_data.population.population += city_data.population.at_age[i];
    }
    if (city_data.population.population > city_data.population.highest_ever) {
        city_data.population.highest_ever = city_data.population.population;
    }
}

static void city_population_remove_home_removed(int num_people)
{
    city_data.population.lost_removal += num_people;
    remove_from_census(num_people);
    recalculate_population();
}

static void destroy_on_fire(struct building_t *b, int plagued)
{
    undo_data.available = 0;
    b->fire_risk = 0;
    b->damage_risk = 0;
    if (b->house_size && b->house_population) {
        city_population_remove_home_removed(b->house_population);
    }
    int was_tent = b->house_size && b->subtype.house_level <= HOUSE_LARGE_TENT;
    b->house_population = 0;
    b->house_size = 0;
    b->output_resource_id = 0;
    building_clear_related_data(b);

    int waterside_building = 0;
    if (b->type == BUILDING_DOCK || b->type == BUILDING_WHARF || b->type == BUILDING_SHIPYARD) {
        waterside_building = 1;
    }
    int num_tiles;
    if (b->size >= 2 && b->size <= 5) {
        num_tiles = b->size * b->size;
    } else {
        num_tiles = 0;
    }
    map_building_tiles_remove(b->id, b->x, b->y);
    if (map_terrain_is(b->grid_offset, TERRAIN_WATER)) {
        b->state = BUILDING_STATE_DELETED_BY_GAME;
    } else {
        b->type = BUILDING_BURNING_RUIN;
        b->figure_id4 = 0;
        b->tax_income_or_storage = 0;
        b->fire_duration = (b->house_figure_generation_delay & 7) + 1;
        b->fire_proof = 1;
        b->size = 1;
        b->ruin_has_plague = plagued;
        memset(&b->data, 0, 42);
        int image_id;
        if (was_tent) {
            image_id = 734;
        } else {
            image_id = 743 + 9 * (random.items[b->grid_offset] & 3);
        }
        map_building_tiles_add(b->id, b->x, b->y, 1, image_id, TERRAIN_BUILDING);
    }
    static   int x_tiles[] = {
        0, 1, 1, 0, 2, 2, 2, 1, 0, 3, 3, 3, 3, 2, 1, 0, 4, 4, 4, 4, 4, 3, 2, 1, 0, 5, 5, 5, 5, 5, 5, 4, 3, 2, 1, 0
    };
    static   int y_tiles[] = {
        0, 0, 1, 1, 0, 1, 2, 2, 2, 0, 1, 2, 3, 3, 3, 3, 0, 1, 2, 3, 4, 4, 4, 4, 4, 0, 1, 2, 3, 4, 5, 5, 5, 5, 5, 5
    };
    for (int tile = 1; tile < num_tiles; tile++) {
        int x = x_tiles[tile] + b->x;
        int y = y_tiles[tile] + b->y;
        if (map_terrain_is(map_grid_offset(x, y), TERRAIN_WATER)) {
            continue;
        }
        struct building_t *ruin = building_create(BUILDING_BURNING_RUIN, x, y);
        int image_id;
        if (was_tent) {
            image_id = 734;
        } else {
            image_id = 743 + 9 * (random.items[ruin->grid_offset] & 3);
        }
        map_building_tiles_add(ruin->id, ruin->x, ruin->y, 1, image_id, TERRAIN_BUILDING);
        ruin->fire_duration = (ruin->house_figure_generation_delay & 7) + 1;
        ruin->figure_id4 = 0;
        ruin->fire_proof = 1;
        ruin->ruin_has_plague = plagued;
    }
    if (waterside_building) {
        map_routing_update_water();
    }
}

static void building_update_state(void)
{
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_CREATED) {
            b->state = BUILDING_STATE_IN_USE;
        }
        if (b->state != BUILDING_STATE_IN_USE || !b->house_size) {
            if (b->state == BUILDING_STATE_UNDO || b->state == BUILDING_STATE_DELETED_BY_PLAYER) {
                if (b->type == BUILDING_TOWER || b->type == BUILDING_GATEHOUSE) {
                    map_tiles_update_all_walls();
                    map_tiles_update_all_roads();
                } else if (b->type == BUILDING_RESERVOIR) {
                    map_tiles_update_all_aqueducts(0);
                } else if (b->type == BUILDING_GRANARY) {
                    map_tiles_update_all_roads();
                }
                map_building_tiles_remove(i, b->x, b->y);
                map_routing_update_land();
                building_delete(b);
            } else if (b->state == BUILDING_STATE_RUBBLE) {
                if (b->house_size) {
                    city_population_remove_home_removed(b->house_population);
                }
                building_delete(b);
            } else if (b->state == BUILDING_STATE_DELETED_BY_GAME) {
                building_delete(b);
            }
        }
        if (b->type == BUILDING_TIMBER_YARD && !map_terrain_exist_multiple_tiles_in_radius_with_type(b->x, b->y, 2, 1, TERRAIN_TREE | TERRAIN_SHRUB, 3)) {
            destroy_on_fire(b, 1);
        }
    }
}

static void game_undo_perform(void)
{
    if (!undo_data.ready || !undo_data.available) {
        return;
    }
    undo_data.available = 0;
    city_finance_process_construction(-undo_data.building_cost);
    if (undo_data.type == BUILDING_CLEAR_LAND) {
        for (int i = 0; i < undo_data.num_buildings; i++) {
            if (undo_data.buildings[i].id) {
                struct building_t *b = &all_buildings[undo_data.buildings[i].id];
                memcpy(b, &undo_data.buildings[i], sizeof(struct building_t));
                if (b->type == BUILDING_WAREHOUSE || b->type == BUILDING_GRANARY) {
                    if (storages[b->storage_id].in_use) {
                        building_storage_reset_building_ids();
                    } else {
                        storages[b->storage_id].in_use = 1;
                    }
                }
                if (b->id) {
                    if (building_is_farm(b->type)) {
                        int image_offset;
                        switch (b->type) {
                            default:
                            case BUILDING_WHEAT_FARM: image_offset = 0; break;
                            case BUILDING_VEGETABLE_FARM: image_offset = 5; break;
                            case BUILDING_FRUIT_FARM: image_offset = 10; break;
                            case BUILDING_OLIVE_FARM: image_offset = 15; break;
                            case BUILDING_VINES_FARM: image_offset = 20; break;
                            case BUILDING_PIG_FARM: image_offset = 25; break;
                        }
                        map_building_tiles_add_farm(b->id, b->x, b->y, 2884 + image_offset, 0);
                    } else {
                        int size = b->size;
                        if (building_is_house(b->type) && b->house_is_merged) {
                            size = 2;
                        }
                        map_building_tiles_add(b->id, b->x, b->y, size, 0, 0);
                        if (b->type == BUILDING_WHARF) {
                            b->data.industry.fishing_boat_id = 0;
                        }
                    }
                    b->state = BUILDING_STATE_IN_USE;
                }
            }
        }
        memcpy(terrain_grid.items, terrain_grid_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
        memcpy(aqueduct.items, aqueduct_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
        memcpy(sprite.items, sprite_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
        memcpy(images.items, images_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
        map_property_restore();
        map_property_clear_constructing_and_deleted();
    } else if (undo_data.type == BUILDING_AQUEDUCT || undo_data.type == BUILDING_ROAD ||
            undo_data.type == BUILDING_WALL) {
        memcpy(terrain_grid.items, terrain_grid_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
        memcpy(aqueduct.items, aqueduct_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
        restore_map_images();
    } else if (undo_data.type == BUILDING_LOW_BRIDGE || undo_data.type == BUILDING_SHIP_BRIDGE) {
        memcpy(terrain_grid.items, terrain_grid_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
        memcpy(sprite.items, sprite_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
        restore_map_images();
    } else if (undo_data.type == BUILDING_PLAZA || undo_data.type == BUILDING_GARDENS) {
        memcpy(terrain_grid.items, terrain_grid_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
        memcpy(aqueduct.items, aqueduct_backup.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
        map_property_restore();
        restore_map_images();
    } else if (undo_data.num_buildings) {
        for (int i = 0; i < undo_data.num_buildings; i++) {
            if (undo_data.buildings[i].id) {
                struct building_t *b = &all_buildings[undo_data.buildings[i].id];
                if (b->type == BUILDING_ORACLE || (b->type >= BUILDING_LARGE_TEMPLE_CERES && b->type <= BUILDING_LARGE_TEMPLE_VENUS)) {
                    int building_id = city_data.resource.last_used_warehouse;
                    for (int j = 1; j < MAX_BUILDINGS; j++) {
                        building_id++;
                        if (building_id >= MAX_BUILDINGS) {
                            building_id = 1;
                        }
                        struct building_t *bb = &all_buildings[building_id];
                        if (bb->state == BUILDING_STATE_IN_USE && bb->type == BUILDING_WAREHOUSE) {
                            city_data.resource.last_used_warehouse = building_id;
                            building_warehouse_add_resource(b, RESOURCE_MARBLE);
                            building_warehouse_add_resource(b, RESOURCE_MARBLE);
                            break;
                        }
                    }
                }
                b->state = BUILDING_STATE_UNDO;
                building_update_state();
            }
        }
    }
    map_routing_update_land();
    map_routing_update_walls();
    undo_data.num_buildings = 0;
}

static void game_state_set_overlay(int overlay)
{
    if (overlay == OVERLAY_NONE) {
        state_data.previous_overlay = state_data.current_overlay;
    } else {
        state_data.previous_overlay = OVERLAY_NONE;
    }
    state_data.current_overlay = overlay;
}

static void city_message_post(int use_popup, int message_type, int param1, int param2)
{
    for (int i = 0; i < MAX_MESSAGES; i++) {
        if (!message_data.messages[i].message_type) {
            message_data.current_message_id = i;
            break;
        }
    }
    if (message_data.current_message_id < 0) {
        return;
    }
    message_data.total_messages++;
    message_data.messages[message_data.current_message_id].message_type = message_type;
    message_data.messages[message_data.current_message_id].is_read = 0;
    message_data.messages[message_data.current_message_id].year = time_data.year;
    message_data.messages[message_data.current_message_id].month = time_data.month;
    message_data.messages[message_data.current_message_id].param1 = param1;
    message_data.messages[message_data.current_message_id].param2 = param2;
    message_data.messages[message_data.current_message_id].sequence = message_data.next_message_sequence++;
    int text_id = city_message_get_text_id(message_type);
    int lang_msg_type = lang_data.message_entries[text_id].message_type;
    if (lang_msg_type == MESSAGE_TYPE_DISASTER || lang_msg_type == MESSAGE_TYPE_INVASION) {
        message_data.problem_count = 1;
        // window_invalidate();
    }
    if (use_popup && current_window == WINDOW_CITY) {
        show_message_popup(message_data.current_message_id);
    } else if (use_popup) {
        // add to queue to be processed when player returns to city
        for (int i = 0; i < MAX_MESSAGE_QUEUE; i++) {
            if (!message_data.queue[i]) {
                message_data.queue[i] = message_data.messages[message_data.current_message_id].sequence;
                break;
            }
        }
    } else if (should_play_sound) {
        play_sound(text_id);
    }
    should_play_sound = 1;
}

static void map_building_tiles_set_rubble(int building_id, int x, int y, int size)
{
    if (!map_grid_is_inside(x, y, size)) {
        return;
    }
    struct building_t *b = &all_buildings[building_id];
    for (int dy = 0; dy < size; dy++) {
        for (int dx = 0; dx < size; dx++) {
            int grid_offset = map_grid_offset(x + dx, y + dy);
            if (map_building_at(grid_offset) != building_id) {
                continue;
            }
            if (building_id && all_buildings[map_building_at(grid_offset)].type != BUILDING_BURNING_RUIN) {
                rubble_type_grid.items[grid_offset] = b->type;
            } else if (!building_id && terrain_grid.items[grid_offset] & TERRAIN_WALL) {
                rubble_type_grid.items[grid_offset] = BUILDING_WALL;
            }
            bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
            map_property_set_multi_tile_size(grid_offset, 1);
            aqueduct.items[grid_offset] = 0;
            buildings_grid.items[grid_offset] = 0;
            damage_grid.items[grid_offset] = 0;
            map_sprite_clear_tile(grid_offset);
            map_property_set_multi_tile_xy(grid_offset, 0, 0, 1);
            if (map_terrain_is(grid_offset, TERRAIN_WATER)) {
                terrain_grid.items[grid_offset] = TERRAIN_WATER; // clear other flags
                map_tiles_set_water(x + dx, y + dy);
            } else {
                terrain_grid.items[grid_offset] &= ~TERRAIN_CLEARABLE;
                terrain_grid.items[grid_offset] |= TERRAIN_RUBBLE;
                images.items[grid_offset] = 658 + (random.items[grid_offset] & 7);
            }
        }
    }
}

static void figure_create_explosion_cloud(int x, int y, int size)
{
    int tile_offset = CLOUD_TILE_OFFSETS[size];
    int cc_offset = CLOUD_CC_OFFSETS[size];
    for (int i = 0; i < 16; i++) {
        struct figure_t *f = figure_create(FIGURE_EXPLOSION,
            x + tile_offset, y + tile_offset, DIR_0_TOP);
        if (f->id) {
            f->cross_country_x += cc_offset;
            f->cross_country_y += cc_offset;
            f->destination_x += CLOUD_DIRECTION[i].x;
            f->destination_y += CLOUD_DIRECTION[i].y;
            figure_movement_set_cross_country_direction(f,
                f->cross_country_x, f->cross_country_y,
                15 * f->destination_x + cc_offset,
                15 * f->destination_y + cc_offset, 0);
            f->speed_multiplier = CLOUD_SPEED[i];
        }
    }
}

static void destroy_linked_parts(struct building_t *b, int on_fire)
{
    struct building_t *part = b;
    for (int i = 0; i < 9; i++) {
        if (part->prev_part_building_id <= 0) {
            break;
        }
        int part_id = part->prev_part_building_id;
        part = &all_buildings[part_id];
        if (on_fire) {
            destroy_on_fire(part, 0);
        } else {
            map_building_tiles_set_rubble(part_id, part->x, part->y, part->size);
            part->state = BUILDING_STATE_RUBBLE;
        }
    }
    part = b;
    for (int i = 0; i < 9; i++) {
        part = &all_buildings[part->next_part_building_id];
        if (part->id <= 0) {
            break;
        }
        if (on_fire) {
            destroy_on_fire(part, 0);
        } else {
            map_building_tiles_set_rubble(part->id, part->x, part->y, part->size);
            part->state = BUILDING_STATE_RUBBLE;
        }
    }
    // Unlink the buildings to prevent corrupting the building table
    part = building_main(b);
    for (int i = 0; i < 9 && part->id > 0; i++) {
        struct building_t *next_part = &all_buildings[part->next_part_building_id];
        part->next_part_building_id = 0;
        part->prev_part_building_id = 0;
        part = next_part;
    }
}

static void building_destroy_by_collapse(struct building_t *b)
{
    b->state = BUILDING_STATE_RUBBLE;
    map_building_tiles_set_rubble(b->id, b->x, b->y, b->size);
    figure_create_explosion_cloud(b->x, b->y, b->size);
    destroy_linked_parts(b, 0);
    play_sound_effect(SOUND_EFFECT_EXPLOSION);
}

static void building_destroy_by_enemy(int x, int y, int grid_offset)
{
    int building_id = map_building_at(grid_offset);
    if (building_id > 0) {
        struct building_t *b = &all_buildings[building_id];
        if (b->state == BUILDING_STATE_IN_USE) {
            switch (b->type) {
                case BUILDING_HOUSE_SMALL_TENT:
                case BUILDING_HOUSE_LARGE_TENT:
                case BUILDING_PREFECTURE:
                case BUILDING_ENGINEERS_POST:
                case BUILDING_WELL:
                case BUILDING_GATEHOUSE:
                case BUILDING_TOWER:
                    break;
                default:
                    city_data.ratings.peace_destroyed_buildings++;
                    break;
            }
            if (city_data.ratings.peace_destroyed_buildings >= 12) {
                city_data.ratings.peace_destroyed_buildings = 12;
            }
            building_destroy_by_collapse(b);
        }
    } else {
        if (map_terrain_is(grid_offset, TERRAIN_WALL)) {
            for (int i = 0; i < MAX_FIGURES; i++) {
                struct figure_t *f = &figures[i];
                if (figure_is_alive(f) && f->type == FIGURE_TOWER_SENTRY) {
                    if (calc_maximum_distance(f->x, f->y, x, y) <= 1) {
                        figure_delete(f);
                    }
                }
            }
        }
        map_building_tiles_set_rubble(0, x, y, 1);
    }
    figure_tower_sentry_reroute();
    foreach_region_tile(x - 1, y - 1, x + 3 - 2, y + 3 - 2, set_wall_image);
    foreach_region_tile(x - 3, y - 3, x + 3, y + 3, update_aqueduct_tile);
    map_routing_update_land();
    map_routing_update_walls();
}

static int terrain_at_offset_clear(int grid_offset)
{
    if (map_terrain_is(grid_offset, TERRAIN_SHRUB | TERRAIN_ROCK | TERRAIN_TREE | TERRAIN_ELEVATION)
    || (map_terrain_is(grid_offset, TERRAIN_WATER) && !map_terrain_is(grid_offset, TERRAIN_ROAD))) {
        return 0;
    } else {
        if (map_terrain_is(grid_offset, TERRAIN_BUILDING | TERRAIN_AQUEDUCT | TERRAIN_GATEHOUSE | TERRAIN_WALL)) {
            building_destroy_by_enemy(map_grid_offset_to_x(grid_offset), map_grid_offset_to_y(grid_offset), grid_offset);
        }
        return 1;
    }
}

static int find_closest_clear_x_offset(int x, int y)
{
    for (int j = x; j < scenario.map.width; j++) {
        int grid_offset = map_grid_offset(j, y);
        if (terrain_at_offset_clear(grid_offset)) {
            return j;
        } else {
            continue;
        }
    }
    for (int j = x; j < scenario.map.width; j--) {
        int grid_offset = map_grid_offset(j, y);
        if (terrain_at_offset_clear(grid_offset)) {
            return j;
        } else {
            continue;
        }
    }
    return -1;
}

static void create_enemy_formation(int figure_type, int enemy_type, int x, int y, int figures_amount_to_spawn, int orientation, int formation_index, int enemy_attack_priority)
{
    for (int i = 0; i < MAX_ENEMY_FORMATIONS; i++) {
        if (!enemy_formations[i].in_use) {
            struct formation_t *m = &enemy_formations[i];
            m->in_use = 1;
            m->figure_type = figure_type;
            m->layout = ENEMY_PROPERTIES[enemy_type].formation_layout;
            if (ENEMY_PROPERTIES[enemy_type].formation_layout == FORMATION_DOUBLE_LINE_1) {
                if (orientation == DIR_2_RIGHT || orientation == DIR_6_LEFT) {
                    m->layout = FORMATION_DOUBLE_LINE_2;
                }
            }
            m->max_figures = figures_amount_to_spawn;
            m->attack_priority = enemy_attack_priority;
            switch (enemy_type) {
                case ENEMY_TYPE_BARBARIAN:
                case ENEMY_TYPE_BRITON:
                case ENEMY_TYPE_CELT:
                case ENEMY_TYPE_PICT:
                case ENEMY_TYPE_GAUL:
                case ENEMY_TYPE_HELVETIUS:
                case ENEMY_TYPE_HUN:
                case ENEMY_TYPE_GOTH:
                case ENEMY_TYPE_VISIGOTH:
                case ENEMY_TYPE_NUMIDIAN:
                    m->max_morale = 80;
                    break;
                case ENEMY_TYPE_CARTHAGINIAN:
                case ENEMY_TYPE_GREEK:
                case ENEMY_TYPE_MACEDONIAN:
                    m->max_morale = 90;
                    break;
                case ENEMY_TYPE_PERGAMUM:
                case ENEMY_TYPE_IBERIAN:
                case ENEMY_TYPE_JUDEAN:
                case ENEMY_TYPE_SELEUCID:
                case ENEMY_TYPE_EGYPTIAN:
                case ENEMY_TYPE_ETRUSCAN:
                case ENEMY_TYPE_SAMNITE:
                    m->max_morale = 70;
                    break;
                case ENEMY_TYPE_CAESAR:
                    m->max_morale = 100;
                    break;
            }
            m->morale = m->max_morale;
            if (orientation == DIR_0_TOP) {
                if (formation_index % 2) {
                    m->destination_x = x;
                    m->destination_y = y - LAYOUT_OFFSETS_FROM_MAP_EDGE[m->layout][1];
                } else {
                    m->destination_x = x;
                    m->destination_y = y - LAYOUT_OFFSETS_FROM_MAP_EDGE[m->layout][0];
                }
            } else if (orientation == DIR_4_BOTTOM) {
                if (formation_index % 2) {
                    m->destination_x = x;
                    m->destination_y = y + LAYOUT_OFFSETS_FROM_MAP_EDGE[m->layout][1];
                } else {
                    m->destination_x = x;
                    m->destination_y = y + LAYOUT_OFFSETS_FROM_MAP_EDGE[m->layout][0];
                }
            } else if (orientation == DIR_2_RIGHT) {
                if (formation_index % 2) {
                    m->destination_x = x + LAYOUT_OFFSETS_FROM_MAP_EDGE[m->layout][1];
                    m->destination_y = y;
                } else {
                    m->destination_x = x + LAYOUT_OFFSETS_FROM_MAP_EDGE[m->layout][0];
                    m->destination_y = y;
                }
            } else if (orientation == DIR_6_LEFT) {
                if (formation_index % 2) {
                    m->destination_x = x - LAYOUT_OFFSETS_FROM_MAP_EDGE[m->layout][1];
                    m->destination_y = y;
                } else {
                    m->destination_x = x - LAYOUT_OFFSETS_FROM_MAP_EDGE[m->layout][0];
                    m->destination_y = y;
                }
            }

            for (int fig = 0; fig < figures_amount_to_spawn; fig++) {
                struct figure_t *f = figure_create(figure_type, x, y, orientation);
                f->is_targetable = 1;
                f->action_state = FIGURE_ACTION_ENEMY_SPAWNING;
                f->formation_id = m->id;
                f->enemy_image_group = ENEMY_PROPERTIES[enemy_type].enemy_img_group;
                if (formation_index) {
                    f->wait_ticks = 50 * formation_index + 15 * fig + 300;
                } else { // first formation is "scouting party"
                    f->wait_ticks = 15 * fig + 10;
                }

                f->terrain_usage = TERRAIN_USAGE_ENEMY;
                f->is_invisible = 1;
                switch (figure_type) {
                    case FIGURE_ENEMY_BARBARIAN_SWORDSMAN:
                    case FIGURE_ENEMY_HUN_SWORDSMAN:
                    case FIGURE_ENEMY_GOTH_SWORDSMAN:
                    case FIGURE_ENEMY_VISIGOTH_SWORDSMAN:
                    case FIGURE_ENEMY_NUMIDIAN_SWORDSMAN:
                    case FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER:
                        f->speed_multiplier = 2;
                        break;
                    case FIGURE_ENEMY_BRITON_CHARIOT:
                    case FIGURE_ENEMY_CELT_CHARIOT:
                    case FIGURE_ENEMY_PICT_CHARIOT:
                        f->speed_multiplier = 3;
                        f->mounted_charge_ticks = 8;
                        f->mounted_charge_ticks_max = 8;
                        break;
                    case FIGURE_ENEMY_HUN_MOUNTED_ARCHER:
                    case FIGURE_ENEMY_GOTH_MOUNTED_ARCHER:
                    case FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER:
                        f->speed_multiplier = 3;
                        break;
                    default:
                        break;
                }
                add_figure_to_formation(f, m);
                if (enemy_type == ENEMY_TYPE_CAESAR) {
                    city_data.figure.imperial_soldiers++;
                } else {
                    city_data.figure.enemies++;
                }
            }
            break;
        }
    }
}

static int find_closest_clear_y_offset(int x, int y)
{
    for (int j = y; j < scenario.map.height; j++) {
        int grid_offset = map_grid_offset(x, j);
        if (terrain_at_offset_clear(grid_offset)) {
            return j;
        } else {
            continue;
        }
    }
    for (int j = y; j < scenario.map.height; j--) {
        int grid_offset = map_grid_offset(x, j);
        if (terrain_at_offset_clear(grid_offset)) {
            return j;
        } else {
            continue;
        }
    }
    return -1;
}

static int start_invasion(int enemy_type, int amount, int invasion_point, int enemy_attack_priority)
{
    if (amount <= 0) {
        return -1;
    }
    int x, y;
    // determine invasion point
    if (enemy_type == ENEMY_TYPE_CAESAR) {
        x = scenario.entry_point.x;
        y = scenario.entry_point.y;
    } else {
        int invasion_flags_placed = 0;
        for (int i = 0; i < MAX_INVASION_POINTS; i++) {
            if (scenario.invasion_points[i].x != -1) {
                invasion_flags_placed++;
            }
        }
        if (invasion_point == MAX_INVASION_POINTS) { // random
            if (invasion_flags_placed) {
                // one or more, not necessarily sequential
                int rnd_point = rand() % MAX_INVASION_POINTS;
                x = scenario.invasion_points[rnd_point].x;
                y = scenario.invasion_points[rnd_point].y;
                while (x == -1) {
                    if (rnd_point < MAX_INVASION_POINTS - 1) {
                        rnd_point++;
                    } else {
                        rnd_point = 0;
                    }
                    x = scenario.invasion_points[rnd_point].x;
                    y = scenario.invasion_points[rnd_point].y;
                }
            } else {
                // no invasion flags placed
                x = scenario.exit_point.x;
                y = scenario.exit_point.y;
            }
        } else {
            x = scenario.invasion_points[invasion_point].x;
            y = scenario.invasion_points[invasion_point].y;
        }
    }
    // determine orientation
    int orientation = DIR_0_TOP;
    if (y == 0) {
        orientation = DIR_4_BOTTOM;
    } else if (x == 0) {
        orientation = DIR_2_RIGHT;
    } else if (x >= scenario.map.width - 1) {
        orientation = DIR_6_LEFT;
    }
    int enemy_count_per_type[MAX_ENEMY_TYPES_PER_ARMY];
    for (int i = 0; i < MAX_ENEMY_TYPES_PER_ARMY; i++) {
        enemy_count_per_type[i] = calc_adjust_with_percentage(amount, ENEMY_PROPERTIES[enemy_type].pct_type[i]);
    }
    enemy_count_per_type[0] += amount - (enemy_count_per_type[0] + enemy_count_per_type[1] + enemy_count_per_type[2]); // assign leftovers to first type
    int formation_index = 0;
    for (int i = 0; i < MAX_ENEMY_TYPES_PER_ARMY; i++) {
        while (enemy_count_per_type[i]) {
            int figures_amount_to_spawn = enemy_count_per_type[i] >= MAX_FORMATION_FIGURES ? MAX_FORMATION_FIGURES : enemy_count_per_type[i];
            // determine spawn point for each formation
            if (orientation == DIR_0_TOP || orientation == DIR_4_BOTTOM) {
                int x_offseted = -1;
                if (x >= scenario.map.width / 2) {
                    if (formation_index % 2) {
                        x_offseted = find_closest_clear_x_offset(x - LAYOUT_SPACING_BETWEEN_FORMATIONS[ENEMY_PROPERTIES[enemy_type].formation_layout] * formation_index, y);
                    } else {
                        x_offseted = find_closest_clear_x_offset(x - LAYOUT_SPACING_BETWEEN_FORMATIONS[ENEMY_PROPERTIES[enemy_type].formation_layout] * (formation_index + 1), y);
                    }
                } else {
                    if (formation_index % 2) {
                        x_offseted = find_closest_clear_x_offset(x + LAYOUT_SPACING_BETWEEN_FORMATIONS[ENEMY_PROPERTIES[enemy_type].formation_layout] * formation_index, y);
                    } else {
                        x_offseted = find_closest_clear_x_offset(x + LAYOUT_SPACING_BETWEEN_FORMATIONS[ENEMY_PROPERTIES[enemy_type].formation_layout] * (formation_index + 1), y);
                    }
                }
                if (x_offseted > -1) {
                    create_enemy_formation(ENEMY_PROPERTIES[enemy_type].figure_types[i], enemy_type, x_offseted, y, figures_amount_to_spawn, orientation, formation_index, enemy_attack_priority);
                    enemy_count_per_type[i] -= figures_amount_to_spawn;
                    formation_index++;
                }
            } else { // left/right
                int y_offseted = -1;
                if (y >= scenario.map.height / 2) {
                    if (formation_index % 2) {
                        y_offseted = find_closest_clear_y_offset(x, y - LAYOUT_SPACING_BETWEEN_FORMATIONS[ENEMY_PROPERTIES[enemy_type].formation_layout] * formation_index);
                    } else {
                        y_offseted = find_closest_clear_y_offset(x, y - LAYOUT_SPACING_BETWEEN_FORMATIONS[ENEMY_PROPERTIES[enemy_type].formation_layout] * (formation_index + 1));
                    }
                } else {
                    if (formation_index % 2) {
                        y_offseted = find_closest_clear_y_offset(x, y + LAYOUT_SPACING_BETWEEN_FORMATIONS[ENEMY_PROPERTIES[enemy_type].formation_layout] * formation_index);
                    } else {
                        y_offseted = find_closest_clear_y_offset(x, y + LAYOUT_SPACING_BETWEEN_FORMATIONS[ENEMY_PROPERTIES[enemy_type].formation_layout] * (formation_index + 1));
                    }
                }
                if (y_offseted > -1) {
                    create_enemy_formation(ENEMY_PROPERTIES[enemy_type].figure_types[i], enemy_type, x, y_offseted, figures_amount_to_spawn, orientation, formation_index, enemy_attack_priority);
                    enemy_count_per_type[i] -= figures_amount_to_spawn;
                    formation_index++;
                }
            }
        }
    }
    return map_grid_offset(x, y);
}

static void draw_top_menu_submenu(int x, int submenu_width, int num_entries)
{
    for (int i = 0; i < num_entries; i++) {
        int image_y = 0;
        for (int yy = 0; yy < num_entries + 1; yy++) {
            int image_x = 0;
            for (int xx = 0; xx < submenu_width; xx++) {
                image_draw(1221 + image_y + image_x, x + BLOCK_SIZE * xx, TOP_BAR_HEIGHT + BLOCK_SIZE * yy);
                image_x++;
                if (image_x >= 10) {
                    image_x = 0;
                }
            }
            image_y += 12;
            if (image_y >= 120) {
                image_y = 0;
            }
        }
    }
}

static void window_city_draw_all(void)
{
    window_city_draw_background();
    draw_foreground_city();
}

static void update_mouse_grid_offset(int x_view, int y_view, int grid_offset)
{
    if (minimap_data.mouse.y == y_view && (minimap_data.mouse.x == x_view || minimap_data.mouse.x == x_view + 1)) {
        minimap_data.mouse.grid_offset = grid_offset < 0 ? 0 : grid_offset;
    }
}

static void play_speech_file(char *filename)
{
    if (!settings[SETTINGS_SPEECH_ENABLED].config_value) {
        return;
    }
    stop_sound_channel(SOUND_CHANNEL_SPEECH);
    if (filename) {
        stop_sound_channel(SOUND_CHANNEL_SPEECH);
        sound_channels[SOUND_CHANNEL_SPEECH].chunk = load_chunk(filename);
        if (sound_channels[SOUND_CHANNEL_SPEECH].chunk) {
            set_channel_volume(SOUND_CHANNEL_SPEECH, settings[SETTINGS_SPEECH_VOLUME].config_value);
            Mix_PlayChannel(SOUND_CHANNEL_SPEECH, sound_channels[SOUND_CHANNEL_SPEECH].chunk, 0);
        }
    }
}

static void set_destination_for_soldier(struct figure_t *soldier, int dst_x, int dst_y, int dst_grid_offset)
{
    soldier->destination_x = dst_x;
    soldier->destination_y = dst_y;
    soldier->destination_grid_offset = dst_grid_offset;
    soldier->action_state = FIGURE_ACTION_SOLDIER_GOING_TO_STANDARD;
}

static int destination_is_clear(struct figure_t *legion_unit, int target_grid_offset)
{
    // check terrain at destination
    if (map_terrain_is(target_grid_offset, TERRAIN_IMPASSABLE)) {
        return 0;
    }
    // check if any legion unit is heading towards the destination
    for (int i = 1; i < MAX_FIGURES; i++) {
        struct figure_t *f = &figures[i];
        if (figure_is_alive(f) && figure_properties[f->type].is_player_legion_unit && f->id != legion_unit->id) {
            if (f->destination_grid_offset == target_grid_offset) {
                if (f->formation_id == legion_unit->formation_id) { // same formation, stationary units may not have received the command to move yet
                    if (f->action_state == FIGURE_ACTION_SOLDIER_GOING_TO_STANDARD) {
                        return 0;
                    }
                } else {
                    return 0;
                }
            }
        }
    }
    return 1;
}

static void deploy_legion_unit_to_formation_location(struct figure_t *legion_unit, struct formation_t *legion_formation)
{
    figure_route_remove(legion_unit);
    int target_dst_x = legion_formation->standard_x + FORMATION_LAYOUT_POSITION_X[legion_formation->layout][legion_unit->index_in_formation];
    int target_dst_y = legion_formation->standard_y + FORMATION_LAYOUT_POSITION_Y[legion_formation->layout][legion_unit->index_in_formation];
    int target_dst_grid_offset = map_grid_offset(target_dst_x, target_dst_y);
    if (destination_is_clear(legion_unit, target_dst_grid_offset)) {
        set_destination_for_soldier(legion_unit, target_dst_x, target_dst_y, target_dst_grid_offset);
    } else {
        // attempt to route to nearest clear tile
        for (int j = 1; j < 10; j++) {
            target_dst_grid_offset = map_grid_offset(target_dst_x + j, target_dst_y); // +x
            if (destination_is_clear(legion_unit, target_dst_grid_offset)) {
                set_destination_for_soldier(legion_unit, target_dst_x + j, target_dst_y, target_dst_grid_offset);
                break;
            }
            target_dst_grid_offset = map_grid_offset(target_dst_x - j, target_dst_y); // -x
            if (destination_is_clear(legion_unit, target_dst_grid_offset)) {
                set_destination_for_soldier(legion_unit, target_dst_x - j, target_dst_y, target_dst_grid_offset);
                break;
            }
            target_dst_grid_offset = map_grid_offset(target_dst_x, target_dst_y + j); // +y
            if (destination_is_clear(legion_unit, target_dst_grid_offset)) {
                set_destination_for_soldier(legion_unit, target_dst_x, target_dst_y + j, target_dst_grid_offset);
                break;
            }
            target_dst_grid_offset = map_grid_offset(target_dst_x, target_dst_y - j); // -y
            if (destination_is_clear(legion_unit, target_dst_grid_offset)) {
                set_destination_for_soldier(legion_unit, target_dst_x, target_dst_y - j, target_dst_grid_offset);
                break;
            }
            target_dst_grid_offset = map_grid_offset(target_dst_x + j, target_dst_y - j); // +x, -y
            if (destination_is_clear(legion_unit, target_dst_grid_offset)) {
                set_destination_for_soldier(legion_unit, target_dst_x + j, target_dst_y - j, target_dst_grid_offset);
                break;
            }
            target_dst_grid_offset = map_grid_offset(target_dst_x - j, target_dst_y + j); // -x, +y
            if (destination_is_clear(legion_unit, target_dst_grid_offset)) {
                set_destination_for_soldier(legion_unit, target_dst_x - j, target_dst_y + j, target_dst_grid_offset);
                break;
            }
            target_dst_grid_offset = map_grid_offset(target_dst_x + j, target_dst_y + j); // +x, +y
            if (destination_is_clear(legion_unit, target_dst_grid_offset)) {
                set_destination_for_soldier(legion_unit, target_dst_x + j, target_dst_y + j, target_dst_grid_offset);
                break;
            }
            target_dst_grid_offset = map_grid_offset(target_dst_x - j, target_dst_y - j); // -x, -y
            if (destination_is_clear(legion_unit, target_dst_grid_offset)) {
                set_destination_for_soldier(legion_unit, target_dst_x - j, target_dst_y - j, target_dst_grid_offset);
                break;
            }
        }
    }
}

static void init_point(struct map_point_t *point)
{
    point->x = -1;
    point->y = -1;
}

static void game_file_editor_create_scenario(int size)
{
    memset(&scenario, 0, sizeof(scenario));
    scenario.map.width = MAP_SIZES[size].width;
    scenario.map.height = MAP_SIZES[size].height;
    scenario.map.grid_start = (GRID_SIZE - scenario.map.height) / 2 * GRID_SIZE + (GRID_SIZE - scenario.map.width) / 2;
    // Brief description
    string_copy("Brief description", scenario.brief_description, MAX_BRIEF_DESCRIPTION_LENGTH);
    scenario.brief_description_image_id = 7953;
    // Scenario briefing
    string_copy("12Brief \n1 \n @969\n description of this map, for players. History, aims and tips etc.",
 scenario.briefing, MAX_BRIEFING_LENGTH);
    // Starting conditions
    scenario.start_year = -500;
    scenario.initial_favor = 40;
    scenario.initial_funds = 1000;
    scenario.rescue_loan = 500;
    // Win criteria
    scenario.culture_win_criteria = 10;
    scenario.prosperity_win_criteria = 10;
    scenario.peace_win_criteria = 10;
    scenario.favor_win_criteria = 10;
    // Buildings allowed
    for (int i = 1; i < BUILDING_TYPE_MAX; i++) {
        scenario.allowed_buildings[i] = 1;
    }
    // Special events
    scenario.gladiator_revolt.year_offset = 1;
    // Requests
    for (int i = 0; i < MAX_REQUESTS; i++) {
        scenario.requests[i].year_offset = 1;
        scenario.requests[i].amount = 1;
        scenario.requests[i].years_deadline = 5;
        scenario.requests[i].months_to_comply = 60;
        scenario.requests[i].favor = 8;
    }
    // Custom messages
    for (int i = 0; i < MAX_EDITOR_CUSTOM_MESSAGES; i++) {
        scenario.editor_custom_messages[i].year_offset = 1;
    }
    // Earthquakes
    for (int i = 0; i < MAX_EARTHQUAKES; i++) {
        scenario.earthquakes[i].year_offset = 1;
        for (int j = 0; j < MAX_EARTHQUAKE_BRANCHES; j++) {
            init_point(&scenario.earthquakes[i].branch_coordinates[j]);
        }
    }
    // Invasions
    for (int i = 0; i < MAX_INVASIONS; i++) {
        scenario.invasions[i].year_offset = 1;
        scenario.invasions[i].from = 8;
    }
    // Price changes
    for (int i = 0; i < MAX_PRICE_CHANGES; i++) {
        scenario.price_changes[i].year_offset = 1;
        scenario.price_changes[i].amount = 1;
    }
    // Demand changes
    for (int i = 0; i < MAX_DEMAND_CHANGES; i++) {
        scenario.demand_changes[i].year_offset = 1;
    }
    for (int i = 0; i < MAX_EARTHQUAKE_POINTS; i++) {
        init_point(&scenario.earthquake_points[i]);
    }
    for (int i = 0; i < MAX_INVASION_POINTS; i++) {
        init_point(&scenario.invasion_points[i]);
    }
    init_point(&scenario.entry_point);
    init_point(&scenario.exit_point);
    init_point(&scenario.river_entry_point);
    init_point(&scenario.river_exit_point);
    for (int i = 0; i < MAX_FISH_POINTS; i++) {
        init_point(&scenario.fishing_points[i]);
    }
    for (int i = 0; i < MAX_HERD_POINTS; i++) {
        init_point(&scenario.herd_points[i]);
    }
    map_grid_init(scenario.map.width, scenario.map.height, scenario.map.grid_start);
    clear_map_data();
    for (int x = 1; x < map_data.width; x++) {
        images.items[map_grid_offset(x, map_data.height)] = 1;
    }
    for (int y = 1; y < map_data.height; y++) {
        images.items[map_grid_offset(map_data.width, y)] = 2;
    }
    images.items[map_grid_offset(0, map_data.height)] = 3;
    images.items[map_grid_offset(map_data.width, 0)] = 4;
    images.items[map_grid_offset(map_data.width, map_data.height)] = 5;
    city_view_set_camera(76, 152);
    city_view_reset_orientation();
    prepare_map_for_editing(1);
}

static char *get_message_text(int32_t offset)
{
    if (!offset) {
        return 0;
    }
    return &lang_data.message_data[offset];
}

static int load_files(char *text_filename, char *message_filename)
{
    int buffer_size = 400000;
    uint8_t *buffer = (uint8_t *) malloc(buffer_size);
    if (!buffer) {
        return 0;
    }
    int success;
    struct buffer_t buf;
    int min_text_size = (28 + MAX_TEXT_ENTRIES * 8);
    int filesize = read_file_into_buffer(text_filename, buffer, 1);
    if (filesize < min_text_size || filesize > min_text_size + MAX_TEXT_DATA) {
        success = 0;
    } else {
        buffer_init(&buf, buffer, filesize);
        buf.index += 28; // header
        for (int i = 0; i < MAX_TEXT_ENTRIES; i++) {
            lang_data.text_entries[i].offset = buffer_read_i32(&buf);
            lang_data.text_entries[i].in_use = buffer_read_i32(&buf);
        }
        buffer_read_raw(&buf, lang_data.text_data, MAX_TEXT_DATA);
        success = 1;
    }
    filesize = read_file_into_buffer(message_filename, buffer, 1);
    if (filesize < 32024 || filesize > 32024 + MAX_MESSAGE_DATA) {
        success = 0;
    } else {
        buffer_init(&buf, buffer, filesize);
        buf.index += 24; // header
        for (int i = 0; i < MAX_MESSAGE_ENTRIES; i++) {
            struct lang_message_t *m = &lang_data.message_entries[i];
            m->type = buffer_read_i16(&buf);
            m->message_type = buffer_read_i16(&buf);
            buf.index += 2;
            m->x = buffer_read_i16(&buf);
            m->y = buffer_read_i16(&buf);
            m->width_blocks = buffer_read_i16(&buf);
            m->height_blocks = buffer_read_i16(&buf);
            m->image.id = buffer_read_i16(&buf);
            m->image.x = buffer_read_i16(&buf);
            m->image.y = buffer_read_i16(&buf);
            buf.index += 6; // unused image2 id, x, y
            m->title.x = buffer_read_i16(&buf);
            m->title.y = buffer_read_i16(&buf);
            m->subtitle.x = buffer_read_i16(&buf);
            m->subtitle.y = buffer_read_i16(&buf);
            buf.index += 4;
            m->video.x = buffer_read_i16(&buf);
            m->video.y = buffer_read_i16(&buf);
            buf.index += 14;
            m->urgent = buffer_read_i32(&buf);
            m->video.text = get_message_text(buffer_read_i32(&buf));
            buf.index += 4;
            m->title.text = get_message_text(buffer_read_i32(&buf));
            m->subtitle.text = get_message_text(buffer_read_i32(&buf));
            m->content.text = get_message_text(buffer_read_i32(&buf));
        }
        buffer_read_raw(&buf, &lang_data.message_data, MAX_MESSAGE_DATA);
        success = 1;
    }
    free(buffer);
    return success;
}

static int game_undo_start_build(int type)
{
    undo_data.ready = 0;
    undo_data.available = 1;
    undo_data.timeout_ticks = 0;
    undo_data.building_cost = 0;
    undo_data.type = type;
    clear_buildings();
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_UNDO) {
            undo_data.available = 0;
            return 0;
        }
        if (b->state == BUILDING_STATE_DELETED_BY_PLAYER) {
            undo_data.available = 0;
        }
    }
    memcpy(images_backup.items, images.items, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
    memcpy(terrain_grid_backup.items, terrain_grid.items, GRID_SIZE * GRID_SIZE * sizeof(uint16_t));
    memcpy(aqueduct_backup.items, aqueduct.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memcpy(bitfields_backup.items, bitfields_grid.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memcpy(edge_backup.items, edge_grid.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    memcpy(sprite_backup.items, sprite.items, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
    return 1;
}

static void update_terrain_after_elevation_changes(void)
{
    // elevation is max 5, so we need 4 passes to fix the lot
    for (int level = 0; level < 4; level++) {
        int grid_offset = map_data.start_offset;
        for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
            for (int x = 0; x < map_data.width; x++, grid_offset++) {
                if (terrain_elevation.items[grid_offset] > 0) {
                    // reduce elevation when the surrounding tiles are at least 2 lower
                    if (terrain_elevation.items[grid_offset + map_grid_delta(-1, 0)] < terrain_elevation.items[grid_offset] - 1 ||
                        terrain_elevation.items[grid_offset + map_grid_delta(0, -1)] < terrain_elevation.items[grid_offset] - 1 ||
                        terrain_elevation.items[grid_offset + map_grid_delta(1, 0)] < terrain_elevation.items[grid_offset] - 1 ||
                        terrain_elevation.items[grid_offset + map_grid_delta(0, 1)] < terrain_elevation.items[grid_offset] - 1) {
                        terrain_elevation.items[grid_offset]--;
                    }
                }
            }
        }
    }
    clear_current_offset(context_pointers[CONTEXT_WATER].context, context_pointers[CONTEXT_WATER].size);
    clear_current_offset(context_pointers[CONTEXT_ELEVATION].context, context_pointers[CONTEXT_ELEVATION].size);
    map_tiles_update_all_elevation();
    map_tiles_update_all_empty_land();
}

static void callback_calc_distance_build_wall(int next_offset, int dist)
{
    if (terrain_land_citizen.items[next_offset] == CITIZEN_4_CLEAR_TERRAIN) {
        enqueue(next_offset, dist);
    }
}

static int map_can_place_aqueduct_on_road(int grid_offset)
{
    int image_id = images.items[grid_offset] - 591;
    if (image_id != 0 && image_id != 1 && image_id != 49 && image_id != 50) {
        return 0;
    }
    int check_y = image_id == 0 || image_id == 49;
    if (view_data.orientation == DIR_6_LEFT || view_data.orientation == DIR_2_RIGHT) {
        check_y = !check_y;
    }
    if (check_y) {
        if (routing_distance.items[grid_offset + map_grid_delta(0, -1)] > 0 ||
            routing_distance.items[grid_offset + map_grid_delta(0, 1)] > 0) {
            return 0;
        }
    } else {
        if (routing_distance.items[grid_offset + map_grid_delta(-1, 0)] > 0 ||
            routing_distance.items[grid_offset + map_grid_delta(1, 0)] > 0) {
            return 0;
        }
    }
    return 1;
}

static void callback_calc_distance_build_aqueduct(int next_offset, int dist)
{
    int blocked = 0;
    switch (terrain_land_citizen.items[next_offset]) {
        case CITIZEN_N3_AQUEDUCT:
        case CITIZEN_2_PASSABLE_TERRAIN: // rubble, garden, access ramp
        case CITIZEN_N1_BLOCKED: // non-empty land
            blocked = 1;
            break;
        default:
            if (map_terrain_is(next_offset, TERRAIN_BUILDING)) {
                if (terrain_land_citizen.items[next_offset] != CITIZEN_N4_RESERVOIR_CONNECTOR) {
                    blocked = 1;
                }
            }
            break;
    }
    if (map_terrain_is(next_offset, TERRAIN_ROAD) && !map_can_place_aqueduct_on_road(next_offset)) {
        routing_distance.items[next_offset] = -1;
        blocked = 1;
    }
    if (!blocked) {
        enqueue(next_offset, dist);
    }
}

static void callback_calc_distance_build_road(int next_offset, int dist)
{
    int blocked = 0;
    switch (terrain_land_citizen.items[next_offset]) {
        case CITIZEN_N3_AQUEDUCT:
            if (!map_can_place_road_under_aqueduct(next_offset)) {
                routing_distance.items[next_offset] = -1;
                blocked = 1;
            }
            break;
        case CITIZEN_2_PASSABLE_TERRAIN: // rubble, garden, access ramp
        case CITIZEN_N1_BLOCKED: // non-empty land
            blocked = 1;
            break;
        default:
            if (map_terrain_is(next_offset, TERRAIN_BUILDING)) {
                blocked = 1;
            }
            break;
    }
    if (!blocked) {
        enqueue(next_offset, dist);
    }
}

static int map_routing_calculate_distances_for_building(int type, int x, int y)
{
    if (type == ROUTED_BUILDING_WALL) {
        route_queue(map_grid_offset(x, y), -1, callback_calc_distance_build_wall);
        return 1;
    }
    memset(routing_distance.items, 0, GRID_SIZE * GRID_SIZE * sizeof(int16_t));
    int source_offset = map_grid_offset(x, y);
    int can_place_init_road_or_aqueduct = 1;
    if (terrain_land_citizen.items[source_offset] == CITIZEN_N1_BLOCKED) {
        // not open land, can only if:
        // - aqueduct should be placed, and:
        // - land is a reservoir building OR an aqueduct
        if (type != ROUTED_BUILDING_ROAD) {
            can_place_init_road_or_aqueduct = 0;
        } else if (map_terrain_is(source_offset, TERRAIN_AQUEDUCT)) {
            can_place_init_road_or_aqueduct = 1;
        } else if (map_terrain_is(source_offset, TERRAIN_BUILDING)) {
            if (all_buildings[map_building_at(source_offset)].type == BUILDING_RESERVOIR) {
                can_place_init_road_or_aqueduct = 1;
            }
        } else {
            can_place_init_road_or_aqueduct = 0;
        }
    } else if (terrain_land_citizen.items[source_offset] == CITIZEN_2_PASSABLE_TERRAIN) {
        // rubble, access ramp, garden
        can_place_init_road_or_aqueduct = 0;
    } else if (terrain_land_citizen.items[source_offset] == CITIZEN_N3_AQUEDUCT) {
        if (type != ROUTED_BUILDING_ROAD) {
            can_place_init_road_or_aqueduct = 0;
        } else if (map_can_place_road_under_aqueduct(source_offset)) {
            can_place_init_road_or_aqueduct = 1;
        } else {
            can_place_init_road_or_aqueduct = 0;
        }
    }
    if (!can_place_init_road_or_aqueduct) {
        return 0;
    }
    if (map_terrain_is(source_offset, TERRAIN_ROAD) &&
        type != ROUTED_BUILDING_ROAD && !map_can_place_aqueduct_on_road(source_offset)) {
        return 0;
    }
    ++stats.total_routes_calculated;
    if (type == ROUTED_BUILDING_ROAD) {
        route_queue(source_offset, -1, callback_calc_distance_build_road);
    } else {
        route_queue(source_offset, -1, callback_calc_distance_build_aqueduct);
    }
    return 1;
}

static int place_routed_building(int x_start, int y_start, int x_end, int y_end, int type, int *items)
{
    static   int direction_indices[8][4] = {
        {0, 2, 6, 4},
        {0, 2, 6, 4},
        {2, 4, 0, 6},
        {2, 4, 0, 6},
        {4, 6, 2, 0},
        {4, 6, 2, 0},
        {6, 0, 4, 2},
        {6, 0, 4, 2}
    };
    *items = 0;
    int grid_offset = map_grid_offset(x_end, y_end);
    int guard = 0;
    // reverse routing
    while (1) {
        if (++guard >= 400) {
            return 0;
        }
        int distance = routing_distance.items[grid_offset];
        if (distance <= 0) {
            return 0;
        }
        switch (type) {
            case ROUTED_BUILDING_ROAD:
                if (!map_terrain_is(grid_offset, TERRAIN_ROAD)) {
                    *items += 1;
                }
                terrain_grid.items[grid_offset] |= TERRAIN_ROAD;
                bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
                foreach_region_tile(x_end - 1, y_end - 1, x_end + 1, y_end + 1, set_road_image);
                break;
            case ROUTED_BUILDING_WALL:
                if (!map_terrain_is(grid_offset, TERRAIN_WALL)) {
                    *items += 1;
                }
                terrain_grid.items[grid_offset] = TERRAIN_WALL;
                bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
                foreach_region_tile(x_end - 1, y_end - 1, x_end + 1, y_end + 1, set_wall_image);
                break;
            case ROUTED_BUILDING_AQUEDUCT:
                terrain_grid.items[grid_offset] |= TERRAIN_AQUEDUCT;
                bitfields_grid.items[grid_offset] &= BIT_NO_CONSTRUCTION;
                break;
            case ROUTED_BUILDING_AQUEDUCT_WITHOUT_GRAPHIC:
                *items += 1;
                break;
        }
        int direction = calc_general_direction(x_end, y_end, x_start, y_start);
        if (direction == DIR_8_NONE) {
            return 1; // destination reached
        }
        int routed = 0;
        for (int i = 0; i < 4; i++) {
            int index = direction_indices[direction][i];
            int new_grid_offset = grid_offset + map_grid_direction_delta(index);
            int new_dist = routing_distance.items[new_grid_offset];
            if (new_dist > 0 && new_dist < distance) {
                grid_offset = new_grid_offset;
                x_end = map_grid_offset_to_x(grid_offset);
                y_end = map_grid_offset_to_y(grid_offset);
                routed = 1;
                break;
            }
        }
        if (!routed) {
            return 0;
        }
    }
}

static int building_construction_place_road(int measure_only, int x_start, int y_start, int x_end, int y_end)
{
    game_undo_restore_map(0);
    int start_offset = map_grid_offset(x_start, y_start);
    int end_offset = map_grid_offset(x_end, y_end);
    int forbidden_terrain_mask =
        TERRAIN_SHRUB | TERRAIN_ROCK | TERRAIN_WATER |
        TERRAIN_TREE | TERRAIN_GARDEN | TERRAIN_ELEVATION |
        TERRAIN_RUBBLE | TERRAIN_BUILDING | TERRAIN_WALL;
    if (map_terrain_is(start_offset, forbidden_terrain_mask)) {
        return 0;
    }
    if (map_terrain_is(end_offset, forbidden_terrain_mask)) {
        return 0;
    }
    int items_placed = 0;
    if (map_routing_calculate_distances_for_building(ROUTED_BUILDING_ROAD, x_start, y_start) &&
            place_routed_building(x_start, y_start, x_end, y_end, ROUTED_BUILDING_ROAD, &items_placed)) {
        if (!measure_only) {
            map_routing_update_land();
            // window_invalidate();
        }
    }
    return items_placed;
}

static void end_editor_tool_use(void)
{
    tool_data.build_in_progress = 0;
    if (!current_tile.grid_offset) {
        return;
    }
    int warning = 0;
    switch (tool_data.type) {
        case TOOL_ROAD:
            building_construction_place_road(0, tool_data.start_tile.x, tool_data.start_tile.y, current_tile.x, current_tile.y);
            break;
        case TOOL_RAISE_LAND:
        case TOOL_LOWER_LAND:
            update_terrain_after_elevation_changes();
            break;
        case TOOL_ACCESS_RAMP:
        {
            int orientation = 0;
            if (can_place_access_ramp_editor(&current_tile, &orientation)) {
                int terrain_mask = ~(TERRAIN_ROCK | TERRAIN_WATER | TERRAIN_BUILDING | TERRAIN_GARDEN | TERRAIN_AQUEDUCT);
                for (int dy = 0; dy < 2; dy++) {
                    for (int dx = 0; dx < 2; dx++) {
                        int grid_offset = current_tile.grid_offset + map_grid_delta(dx, dy);
                        terrain_grid.items[grid_offset] = terrain_grid.items[grid_offset] & terrain_mask;
                    }
                }
                map_building_tiles_add(0, current_tile.x, current_tile.y, 2, 845 + orientation, TERRAIN_ACCESS_RAMP);

                update_terrain_after_elevation_changes();
            } else {
                city_warning_show(WARNING_EDITOR_CANNOT_PLACE);
            }
            break;
        }
        case TOOL_ENTRY_POINT:
            if (can_place_flag_editor(tool_data.type, &current_tile, &warning)) {
                scenario.entry_point.x = current_tile.x;
                scenario.entry_point.y = current_tile.y;
            }
            break;
        case TOOL_EXIT_POINT:
            if (can_place_flag_editor(tool_data.type, &current_tile, &warning)) {
                scenario.exit_point.x = current_tile.x;
                scenario.exit_point.y = current_tile.y;
            }
            break;
        case TOOL_RIVER_ENTRY_POINT:
            if (can_place_flag_editor(tool_data.type, &current_tile, &warning)) {
                scenario.river_entry_point.x = current_tile.x;
                scenario.river_entry_point.y = current_tile.y;
                figure_create_flotsam();
                map_routing_update_water();
            }
            break;
        case TOOL_RIVER_EXIT_POINT:
            if (can_place_flag_editor(tool_data.type, &current_tile, &warning)) {
                scenario.river_exit_point.x = current_tile.x;
                scenario.river_exit_point.y = current_tile.y;
                figure_create_flotsam();
                map_routing_update_water();
            }
            break;
        case TOOL_EARTHQUAKE_POINT:
            if (can_place_flag_editor(tool_data.type, &current_tile, &warning)) {
                scenario.earthquake_points[tool_data.id].x = current_tile.x;
                scenario.earthquake_points[tool_data.id].y = current_tile.y;
            }
            break;
        case TOOL_INVASION_POINT:
            if (can_place_flag_editor(tool_data.type, &current_tile, &warning)) {
                scenario.invasion_points[tool_data.id].x = current_tile.x;
                scenario.invasion_points[tool_data.id].y = current_tile.y;
            }
            break;
        case TOOL_FISHING_POINT:
            if (can_place_flag_editor(tool_data.type, &current_tile, &warning)) {
                scenario.fishing_points[tool_data.id].x = current_tile.x;
                scenario.fishing_points[tool_data.id].y = current_tile.y;
            }
            break;
        case TOOL_HERD_POINT:
            if (can_place_flag_editor(tool_data.type, &current_tile, &warning)) {
                scenario.herd_points[tool_data.id].x = current_tile.x;
                scenario.herd_points[tool_data.id].y = current_tile.y;
            }
            break;
        case TOOL_NATIVE_HUT:
        case TOOL_NATIVE_FIELD:
        case TOOL_NATIVE_CENTER:
        case TOOL_HOUSE_VACANT_LOT:
        {
            int image_id;
            int size;
            int type;
            switch (tool_data.type) {
                case TOOL_NATIVE_HUT:
                    type = BUILDING_NATIVE_HUT;
                    image_id = 2830 + (random_data.random1_7bit & 1);
                    size = 1;
                    break;
                case TOOL_NATIVE_FIELD:
                    type = BUILDING_NATIVE_CROPS;
                    image_id = 2833;
                    size = 1;
                    break;
                case TOOL_NATIVE_CENTER:
                    type = BUILDING_NATIVE_MEETING;
                    image_id = 2832;
                    size = 2;
                    break;
                case TOOL_HOUSE_VACANT_LOT:
                    type = BUILDING_HOUSE_VACANT_LOT;
                    image_id = 2826;
                    size = 1;
                    break;
                default:
                    return;
            }
            if (can_place_building_editor(&current_tile, size * size, 0)) {
                struct building_t *b = building_create(type, current_tile.x, current_tile.y);
                map_building_tiles_add(b->id, current_tile.x, current_tile.y, size, image_id, TERRAIN_BUILDING);
            } else {
                city_warning_show(WARNING_EDITOR_CANNOT_PLACE);
            }
            break;
        }
        default:
            break;
    }
    if (warning) {
        city_warning_show(warning);
    }
}

static void editor_tool_deactivate(void)
{
    if (tool_data.type == TOOL_ROAD && tool_data.build_in_progress) {
        game_undo_restore_map(1);
    }
    tool_data.type = 0;
    tool_data.build_in_progress = 0;
    refresh_current_window = 1;
}

static void place_rock_at(int x, int y, int grid_offset, int size)
{
    int x_size_adjusted = size > 1 ? size - 1 : size; // use x - 1 for medium/large rocks; technically causes image overlap but looks better
    // check if all needed tiles are clear and within the map grid
    for (int dy = 0; dy < size; dy++) {
        for (int dx = 0; dx < size; dx++) { // separate full x-size check to avoid protrusion beyond the map grid
            if (!map_grid_is_inside(x + dx, y - dy, 1)) {
                return;
            }
        }
        for (int dx = 0; dx < x_size_adjusted; dx++) {
            if (map_terrain_is(map_grid_offset(x + dx, y - dy), TERRAIN_NOT_DISPLACEABLE)) {
                return;
            }
        }
    }
    // set terrain rock for all covered tiles
    for (int dy = 0; dy < size; dy++) {
        for (int dx = 0; dx < x_size_adjusted; dx++) {
            terrain_grid.items[map_grid_offset(x + dx, y - dy)] = TERRAIN_ROCK;
        }
    }
    // set multitile rock image
    int image_id;
    if (size == 1) { // small rock
        image_id = random.items[grid_offset] & 7;
    } else if (size == 2) { // medium rock
        image_id = 8 + (random.items[grid_offset] & 3);
    } else { // large rock
        image_id = 12 + (random.items[grid_offset] & 1);
    }
    if (map_terrain_exists_tile_in_radius_with_type(x, y, size, 4, TERRAIN_ELEVATION)) {
        image_id += 534;
    } else {
        image_id += 849;
    }
    images.items[grid_offset] = image_id;
}

static void place_selected_terrain_at_brush_location(void)
{
    for (int y = current_tile.y - tool_data.brush_size; y <= current_tile.y + tool_data.brush_size; y++) {
        for (int x = current_tile.x - tool_data.brush_size; x <= current_tile.x + tool_data.brush_size; x++) {
            if (map_grid_is_inside(x, y, 1) && abs(x - current_tile.x) + abs(y - current_tile.y) <= tool_data.brush_size) {
                int grid_offset = map_data.start_offset + x + y * GRID_SIZE;
                switch (tool_data.type) {
                    case TOOL_GRASS:
                        if (!(terrain_grid.items[grid_offset] & (TERRAIN_ELEVATION | TERRAIN_ACCESS_RAMP))) {
                            if (terrain_grid.items[grid_offset] & TERRAIN_BUILDING) {
                                map_building_tiles_remove(0, x, y);
                            }
                            terrain_grid.items[grid_offset] = 0;
                        }
                        break;
                    case TOOL_SMALL_SHRUB:
                    case TOOL_MEDIUM_SHRUB:
                    case TOOL_LARGE_SHRUB:
                    case TOOL_LARGEST_SHRUB:
                        if (!(terrain_grid.items[grid_offset] & (TERRAIN_NOT_DISPLACEABLE))) {
                            terrain_grid.items[grid_offset] = TERRAIN_SHRUB;
                            images.items[grid_offset] = 274 + (random.items[grid_offset] & 7) + 8 * (tool_data.type - TOOL_SMALL_SHRUB);
                        }
                        break;
                    case TOOL_WATER:
                        if (!(terrain_grid.items[grid_offset] & (TERRAIN_NOT_DISPLACEABLE))) {
                            terrain_grid.items[grid_offset] = TERRAIN_WATER;
                        }
                        break;
                    case TOOL_RAISE_LAND:
                        if (terrain_elevation.items[grid_offset] < 5 && terrain_elevation.items[grid_offset] == tool_data.start_elevation) {
                            map_property_set_multi_tile_size(grid_offset, 1);
                            terrain_elevation.items[grid_offset]++;
                            terrain_grid.items[grid_offset] = TERRAIN_ELEVATION;
                        }
                        break;
                    case TOOL_LOWER_LAND:
                        if (terrain_elevation.items[grid_offset] && terrain_elevation.items[grid_offset] == tool_data.start_elevation) {
                            terrain_elevation.items[grid_offset]--;
                            if (!terrain_elevation.items[grid_offset]) {
                                terrain_grid.items[grid_offset] = 0;
                            }
                        }
                        break;
                    case TOOL_TREES:
                        if (!(terrain_grid.items[grid_offset] & (TERRAIN_NOT_DISPLACEABLE))) {
                            terrain_grid.items[grid_offset] = TERRAIN_TREE;
                            images.items[grid_offset] = 254 + (random.items[grid_offset] & 7);
                        }
                        break;
                    case TOOL_SMALL_ROCK:
                        place_rock_at(x, y, grid_offset, 1);
                        break;
                    case TOOL_MEDIUM_ROCK:
                        place_rock_at(x, y, grid_offset, 2);
                        break;
                    case TOOL_LARGE_ROCK:
                        place_rock_at(x, y, grid_offset, 3);
                        break;
                    case TOOL_MEADOW:
                        if (!(terrain_grid.items[grid_offset] & (TERRAIN_NOT_DISPLACEABLE))) {
                            terrain_grid.items[grid_offset] = TERRAIN_MEADOW;
                            set_meadow_image(x, y, grid_offset);
                        }
                        break;
                }
            }
        }
    }
}

static int text_draw_money(int value, int x_offset, int y_offset, int font)
{
    char str[NUMBER_BUFFER_LENGTH];
    int money_len = number_to_string(str, value, '@', " ");
    char *postfix;
    postfix = lang_get_string(6, 0);
    string_copy(postfix, str + money_len, NUMBER_BUFFER_LENGTH - money_len - 1);
    return text_draw(str, x_offset, y_offset, font, 0);
}

static void draw_label(int x, int y, int width, int taller, int hover)
{
    for (int i = 0; i < width / BLOCK_SIZE; i++) {
        if (i == 0) {
            if (!hover || (mouse_x >= x && mouse_x < x + width && mouse_y >= y && mouse_y < y + 20 + 5 * taller)) {
                image_draw(935 - 40 * taller, x + BLOCK_SIZE * i, y);
            } else {
                image_draw(938 - 46 * taller, x + BLOCK_SIZE * i, y);
            }
        } else if (i < width / BLOCK_SIZE - 1) {
            if (!hover || (mouse_x >= x && mouse_x < x + width && mouse_y >= y && mouse_y < y + 20 + 5 * taller)) {
                image_draw(936 - 40 * taller, x + BLOCK_SIZE * i, y);
            } else {
                image_draw(939 - 46 * taller, x + BLOCK_SIZE * i, y);
            }
        } else {
            if (!hover || (mouse_x >= x && mouse_x < x + width && mouse_y >= y && mouse_y < y + 20 + 5 * taller)) {
                image_draw(937 - 40 * taller, x + BLOCK_SIZE * i, y);
            } else {
                image_draw(940 - 46 * taller, x + BLOCK_SIZE * i, y);
            }
        }
    }
}

static void select_building_type(int building_type)
{
    building_construction_set_type(building_type);
    close_build_menu();
    show_city_window();
}

static void button_submenu_or_building(int param1)
{
    int n_skipped_items = 0;
    if (build_menu_data.selected_submenu > -1) { // selecting items from a submenu
        for (int k = 0; k < MAX_ITEMS_PER_SUBMENU; k++) { // select next enabled item
            if (build_menus[build_menu_data.selected_menu].menu_items[build_menu_data.selected_submenu].submenu_items[k]) {
                if (k - n_skipped_items >= param1) {
                    select_building_type(build_menus[build_menu_data.selected_menu].menu_items[build_menu_data.selected_submenu].submenu_items[k]);
                    break;
                }
            } else {
                n_skipped_items++;
            }
        }
    } else { // selecting items from a menu
        for (int j = 0; j < MAX_ITEMS_PER_BUILD_MENU; j++) { // select next enabled item
            if (build_menus[build_menu_data.selected_menu].menu_items[j].building_id) { // building or submenu is enabled
                if (j - n_skipped_items >= param1) { // align button index with item
                    if (build_menus[build_menu_data.selected_menu].menu_items[j].building_id == -1) { // submenu item
                        build_menu_data.selected_submenu = j;
                        build_menu_data.num_items_to_draw = 0;
                        for (int k = 0; k < MAX_ITEMS_PER_SUBMENU; k++) {
                            if (build_menus[build_menu_data.selected_menu].menu_items[j].submenu_items[k]) {
                                build_menu_data.num_items_to_draw++;
                            }
                        }
                    } else { // building item
                        select_building_type(build_menus[build_menu_data.selected_menu].menu_items[j].building_id);
                    }
                    break;
                }
            } else {
                n_skipped_items++;
            }
        }
    }
}

static void close_submenu(void)
{
    overlay_menu_data.selected_submenu = 0;
    overlay_menu_data.num_submenu_items = 0;
}

static void increase_count(int type, int active)
{
    ++count_data.buildings[type].total;
    if (active) {
        ++count_data.buildings[type].active;
    }
}

static void increase_industry_count(int resource, int active)
{
    ++count_data.industry[resource].total;
    if (active) {
        ++count_data.industry[resource].active;
    }
}

static void limit_hippodrome(void)
{
    if (count_data.buildings[BUILDING_HIPPODROME].total > 1) {
        count_data.buildings[BUILDING_HIPPODROME].total = 1;
    }
    if (count_data.buildings[BUILDING_HIPPODROME].active > 1) {
        count_data.buildings[BUILDING_HIPPODROME].active = 1;
    }
}

static void building_destroy_by_fire(struct building_t *b)
{
    destroy_on_fire(b, 0);
    destroy_linked_parts(b, 1);
}

static void check_labor_problem(struct building_t *b)
{
    if (b->houses_covered <= 0) {
        b->show_on_problem_overlay = 2;
    }
}

static void map_grid_bound(int *x, int *y)
{
    if (*x < 0) {
        *x = 0;
    }
    if (*y < 0) {
        *y = 0;
    }
    if (*x >= map_data.width) {
        *x = map_data.width - 1;
    }
    if (*y >= map_data.height) {
        *y = map_data.height - 1;
    }
}

static int map_closest_road_within_radius(int x, int y, int size, int radius, int *x_road, int *y_road)
{
    for (int r = 1; r <= radius; r++) {
        int x_min, y_min, x_max, y_max;
        map_grid_get_area(x, y, size, r, &x_min, &y_min, &x_max, &y_max);
        for (int yy = y_min; yy <= y_max; yy++) {
            for (int xx = x_min; xx <= x_max; xx++) {
                if (map_terrain_is(map_grid_offset(xx, yy), TERRAIN_ROAD)) {
                    if (x_road && y_road) {
                        *x_road = xx;
                        *y_road = yy;
                    }
                    return 1;
                }
            }
        }
    }
    return 0;
}

static void figure_movement_init_roaming(struct figure_t *f)
{
    struct building_t *b = &all_buildings[f->building_id];
    f->progress_on_tile = 15;
    f->roam_choose_destination = 0;
    f->roam_ticks_until_next_turn = -1;
    f->roam_turn_direction = 2;
    int roam_dir = b->figure_roam_direction;
    b->figure_roam_direction += 2;
    if (b->figure_roam_direction > 6) {
        b->figure_roam_direction = 0;
    }
    int x = b->x;
    int y = b->y;
    switch (roam_dir) {
        case DIR_0_TOP: y -= 8; break;
        case DIR_2_RIGHT: x += 8; break;
        case DIR_4_BOTTOM: y += 8; break;
        case DIR_6_LEFT: x -= 8; break;
    }
    map_grid_bound(&x, &y);
    int x_road, y_road;
    if (map_closest_road_within_radius(x, y, 1, 6, &x_road, &y_road)) {
        f->destination_x = x_road;
        f->destination_y = y_road;
    } else {
        f->roam_choose_destination = 1;
    }
}

static void generate_labor_seeker(struct building_t *b, int x, int y)
{
    if (city_data.population.population <= 0) {
        return;
    }
    if (b->figure_id2) {
        struct figure_t *f = &figures[b->figure_id2];
        if (!figure_is_alive(f) || f->type != FIGURE_LABOR_SEEKER || f->building_id != b->id) {
            b->figure_id2 = 0;
        }
    } else {
        struct figure_t *f = figure_create(FIGURE_LABOR_SEEKER, x, y, DIR_0_TOP);
        f->action_state = FIGURE_ACTION_ROAMING;
        f->is_targetable = 1;
        f->terrain_usage = TERRAIN_USAGE_ROADS;
        f->building_id = b->id;
        b->figure_id2 = f->id;
        figure_movement_init_roaming(f);
    }
}

static void spawn_labor_seeker(struct building_t *b, int x, int y, int min_houses)
{
    if (b->houses_covered <= min_houses) {
        generate_labor_seeker(b, x, y);
    }
}

static int has_figure_of_types(struct building_t *b, int type1, int type2)
{
    if (b->figure_id <= 0) {
        return 0;
    }
    struct figure_t *f = &figures[b->figure_id];
    if (figure_is_alive(f) && f->building_id == b->id && (f->type == type1 || f->type == type2)) {
        return 1;
    } else {
        b->figure_id = 0;
        return 0;
    }
}

static int default_spawn_delay(struct building_t *b)
{
    int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
    if (pct_workers >= 100) {
        return 3;
    } else if (pct_workers >= 75) {
        return 7;
    } else if (pct_workers >= 50) {
        return 15;
    } else if (pct_workers >= 25) {
        return 29;
    } else if (pct_workers >= 1) {
        return 44;
    } else {
        return 0;
    }
}

static void create_roaming_figure(struct building_t *b, int x, int y, int type)
{
    struct figure_t *f = figure_create(type, x, y, DIR_0_TOP);
    f->action_state = FIGURE_ACTION_ROAMING;
    f->is_targetable = 1;
    f->terrain_usage = TERRAIN_USAGE_ROADS;
    f->building_id = b->id;
    b->figure_id = f->id;
    figure_movement_init_roaming(f);
}

static int contains_non_stockpiled_food(struct building_t *space, int *resources)
{
    if (space->id <= 0) {
        return 0;
    }
    if (space->loads_stored <= 0) {
        return 0;
    }
    int resource = space->subtype.warehouse_resource_id;
    if (city_data.resource.stockpiled[resource]) {
        return 0;
    }
    if (resource == RESOURCE_WHEAT || resource == RESOURCE_VEGETABLES ||
        resource == RESOURCE_FRUIT || resource == RESOURCE_MEAT) {
        if (resources[resource] > 0) {
            return 1;
        }
    }
    return 0;
}

static void update_food_resource(struct resource_data *data, int resource, struct building_t *b, int distance)
{
    if (b->data.granary.resource_stored[resource]) {
        data->num_buildings++;
        if (distance < data->distance) {
            data->distance = distance;
            data->building_id = b->id;
        }
    }
}

static int building_warehouse_get_amount(struct building_t *warehouse, int resource)
{
    int loads = 0;
    struct building_t *space = warehouse;
    for (int i = 0; i < 8; i++) {
        space = &all_buildings[space->next_part_building_id];
        if (space->id <= 0) {
            return 0;
        }
        if (space->subtype.warehouse_resource_id && space->subtype.warehouse_resource_id == resource) {
            loads += space->loads_stored;
        }
    }
    return loads;
}

static void update_good_resource(struct resource_data *data, int resource, struct building_t *b, int distance)
{
    if (!city_data.resource.stockpiled[resource] && building_warehouse_get_amount(b, resource) > 0) {
        data->num_buildings++;
        if (distance < data->distance) {
            data->distance = distance;
            data->building_id = b->id;
        }
    }
}

static int map_terrain_get_adjacent_road_or_clear_land(int x, int y, int size, int *x_tile, int *y_tile)
{
    int base_offset = map_grid_offset(x, y);
    for (int *tile_delta = ADJACENT_OFFSETS_MAP_GRID[size]; *tile_delta; tile_delta++) {
        int grid_offset = base_offset + *tile_delta;
        if (map_terrain_is(grid_offset, TERRAIN_ROAD) ||
            !map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR)) {
            *x_tile = map_grid_offset_to_x(grid_offset);
            *y_tile = map_grid_offset_to_y(grid_offset);
            return 1;
        }
    }
    return 0;
}

static int map_has_road_access_granary(int x, int y, struct map_point_t *road)
{
    int rx = -1, ry = -1;
    if (map_terrain_is(map_grid_offset(x + 1, y - 1), TERRAIN_ROAD)) {
        rx = x + 1;
        ry = y - 1;
    } else if (map_terrain_is(map_grid_offset(x + 3, y + 1), TERRAIN_ROAD)) {
        rx = x + 3;
        ry = y + 1;
    } else if (map_terrain_is(map_grid_offset(x + 1, y + 3), TERRAIN_ROAD)) {
        rx = x + 1;
        ry = y + 3;
    } else if (map_terrain_is(map_grid_offset(x - 1, y + 1), TERRAIN_ROAD)) {
        rx = x - 1;
        ry = y + 1;
    }
    if (rx >= 0 && ry >= 0) {
        if (road) {
            road->x = rx;
            road->y = ry;
        }
        return 1;
    }
    return 0;
}

static int building_granary_add_resource(struct building_t *granary, int resource, int is_produced)
{
    if (granary->id <= 0) {
        return 1;
    }
    if (!resource_is_food(resource)) {
        return 0;
    }
    if (granary->type != BUILDING_GRANARY) {
        return 0;
    }
    if (granary->data.granary.resource_stored[RESOURCE_NONE] <= 0) {
        return 0; // no space
    }
    if (is_produced) {
        city_data.resource.food_produced_this_month += ONE_LOAD;
    }
    if (granary->data.granary.resource_stored[RESOURCE_NONE] <= ONE_LOAD) {
        granary->data.granary.resource_stored[resource] += granary->data.granary.resource_stored[RESOURCE_NONE];
        granary->data.granary.resource_stored[RESOURCE_NONE] = 0;
    } else {
        granary->data.granary.resource_stored[resource] += ONE_LOAD;
        granary->data.granary.resource_stored[RESOURCE_NONE] -= ONE_LOAD;
    }
    return 1;
}

static int building_granary_remove_resource(struct building_t *granary, int resource, int amount)
{
    if (amount <= 0) {
        return 0;
    }
    int removed;
    if (granary->data.granary.resource_stored[resource] >= amount) {
        removed = amount;
    } else {
        removed = granary->data.granary.resource_stored[resource];
    }
    city_data.resource.granary_food_stored[resource] -= removed;
    granary->data.granary.resource_stored[resource] -= removed;
    granary->data.granary.resource_stored[RESOURCE_NONE] += removed;
    return amount - removed;
}

static void update_farm_image(struct building_t *b)
{
    map_building_tiles_add_farm(b->id, b->x, b->y,
        2884 + resource_images[b->output_resource_id].farm_field_img_id,
        b->data.industry.progress);
}

static void building_list_large_clear(int clear_entries)
{
    building_list_data.large.size = 0;
    if (clear_entries) {
        memset(building_list_data.large.items, 0, MAX_LARGE * sizeof(int));
    }
}

static void building_list_large_add(int building_id)
{
    if (building_list_data.large.size < MAX_LARGE) {
        building_list_data.large.items[building_list_data.large.size++] = building_id;
    }
}

static   int *building_list_large_items(void)
{
    return building_list_data.large.items;
}

static int building_market_get_max_food_stock(struct building_t *market)
{
    int max_stock = 0;
    if (market->id > 0 && market->type == BUILDING_MARKET) {
        for (int i = INVENTORY_WHEAT; i <= INVENTORY_MEAT; i++) {
            int stock = market->data.market.inventory[i];
            if (stock > max_stock) {
                max_stock = stock;
            }
        }
    }
    return max_stock;
}

static int building_warehouse_remove_resource(struct building_t *warehouse, int resource, int amount)
{
    // returns amount still needing removal
    if (warehouse->type != BUILDING_WAREHOUSE) {
        return amount;
    }
    struct building_t *space = warehouse;
    for (int i = 0; i < 8; i++) {
        if (amount <= 0) {
            return 0;
        }
        space = &all_buildings[space->next_part_building_id];
        if (space->id <= 0) {
            continue;
        }
        if (space->subtype.warehouse_resource_id != resource || space->loads_stored <= 0) {
            continue;
        }
        if (space->loads_stored > amount) {
            city_resource_remove_from_warehouse(resource, amount);
            space->loads_stored -= amount;
            amount = 0;
        } else {
            city_resource_remove_from_warehouse(resource, space->loads_stored);
            amount -= space->loads_stored;
            space->loads_stored = 0;
            space->subtype.warehouse_resource_id = RESOURCE_NONE;
        }
        building_warehouse_space_set_image(space, resource);
    }
    return amount;
}

static void draw_title_advisors(int y, char *text)
{
    image_draw(926, screen_center_x - 288, y + 1);
    text_draw(text, screen_center_x - 272, y, FONT_NORMAL_WHITE, COLOR_BLACK);
}

static int city_military_distant_battle_roman_army_is_traveling(void)
{
    return city_data.distant_battle.roman_months_to_travel_forth > 0 || city_data.distant_battle.roman_months_to_travel_back > 0;
}

static int city_migration_no_room_for_immigrants(void)
{
    return city_data.migration.refused_immigrants_today || city_data.population.room_in_houses <= 0;
}

static void graphics_shade_rect(int x, int y, int width, int height, int darkness)
{
    struct clip_info_t *cur_clip = graphics_get_clip_info(x, y, width, height);
    if (!cur_clip->is_visible) {
        return;
    }
    for (int yy = y + cur_clip->clipped_pixels_top; yy < y + height - cur_clip->clipped_pixels_bottom; yy++) {
        for (int xx = x + cur_clip->clipped_pixels_left; xx < x + width - cur_clip->clipped_pixels_right; xx++) {
            uint32_t *pixel = graphics_get_pixel(xx, yy);
            int r = (*pixel & 0xff0000) >> 16;
            int g = (*pixel & 0xff00) >> 8;
            int b = (*pixel & 0xff);
            int grey = (r + g + b) / 3 >> darkness;
            uint32_t new_pixel = (uint32_t) (grey << 16 | grey << 8 | grey);
            *pixel = new_pixel;
        }
    }
}

static void city_finance_process_misc(int cost)
{
    city_data.finance.treasury -= cost;
    city_data.finance.this_year.expenses.sundries += cost;
}

static int building_warehouses_remove_resource(int resource, int amount)
{
    int amount_left = amount;
    int building_id = city_data.resource.last_used_warehouse;
    // first go for non-getting warehouses
    for (int i = 1; i < MAX_BUILDINGS && amount_left > 0; i++) {
        building_id++;
        if (building_id >= MAX_BUILDINGS) {
            building_id = 1;
        }
        struct building_t *b = &all_buildings[building_id];
        if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_WAREHOUSE) {
            if (storages[b->storage_id].storage.resource_state[resource] != BUILDING_STORAGE_STATE_GETTING) {
                city_data.resource.last_used_warehouse = building_id;
                amount_left = building_warehouse_remove_resource(b, resource, amount_left);
            }
        }
    }
    // if that doesn't work, take it anyway
    for (int i = 1; i < MAX_BUILDINGS && amount_left > 0; i++) {
        building_id++;
        if (building_id >= MAX_BUILDINGS) {
            building_id = 1;
        }
        struct building_t *b = &all_buildings[building_id];
        if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_WAREHOUSE) {
            city_data.resource.last_used_warehouse = building_id;
            amount_left = building_warehouse_remove_resource(b, resource, amount_left);
        }
    }
    return amount - amount_left;
}

static int city_gods_calculate_least_happy(void)
{
    int max_god = 0;
    int max_wrath = 0;
    for (int i = 0; i < MAX_GODS; i++) {
        if (city_data.religion.gods[i].wrath_bolts > max_wrath) {
            max_god = i + 1;
            max_wrath = city_data.religion.gods[i].wrath_bolts;
        }
    }
    if (max_god > 0) {
        city_data.religion.least_happy_god = max_god;
        return 1;
    }
    int min_happiness = 40;
    for (int i = 0; i < MAX_GODS; i++) {
        if (city_data.religion.gods[i].happiness < min_happiness) {
            max_god = i + 1;
            min_happiness = city_data.religion.gods[i].happiness;
        }
    }
    city_data.religion.least_happy_god = max_god;
    return max_god > 0;
}

static int get_amount(struct building_t *granary, int resource)
{
    if (!resource_is_food(resource)) {
        return 0;
    }
    if (granary->type != BUILDING_GRANARY) {
        return 0;
    }
    return granary->data.granary.resource_stored[resource];
}

static void city_sentiment_change_happiness(int amount)
{
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_IN_USE && b->house_size) {
            b->sentiment.house_happiness = calc_bound(b->sentiment.house_happiness + amount, 0, 100);
        }
    }
}

static void building_curse_farms(int big_curse)
{
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_IN_USE && b->output_resource_id && building_is_farm(b->type)) {
            b->data.industry.progress = 0;
            b->data.industry.blessing_days_left = 0;
            b->data.industry.curse_days_left = big_curse ? 48 : 4;
            update_farm_image(b);
        }
    }
}

static void figure_sink_all_ships(void)
{
    for (int i = 1; i < MAX_FIGURES; i++) {
        struct figure_t *f = &figures[i];
        if (!figure_is_alive(f)) {
            continue;
        }
        if (f->type == FIGURE_TRADE_SHIP) {
            all_buildings[f->destination_building_id].data.dock.trade_ship_id = 0;
        } else if (f->type == FIGURE_FISHING_BOAT) {
            all_buildings[f->building_id].data.industry.fishing_boat_id = 0;
        } else {
            continue;
        }
        f->building_id = 0;
        f->type = FIGURE_SHIPWRECK;
        f->wait_ticks = 0;
    }
}

static void building_granary_warehouse_curse(int big)
{
    int max_stored = 0;
    struct building_t *max_building = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE) {
            continue;
        }
        int total_stored = 0;
        if (b->type == BUILDING_WAREHOUSE) {
            for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                total_stored += building_warehouse_get_amount(b, r);
            }
        } else if (b->type == BUILDING_GRANARY) {
            for (int r = RESOURCE_WHEAT; r < FOOD_TYPES_MAX; r++) {
                total_stored += get_amount(b, r);
            }
            total_stored /= UNITS_PER_LOAD;
        } else {
            continue;
        }
        if (total_stored > max_stored) {
            max_stored = total_stored;
            max_building = b;
        }
    }
    if (!max_building) {
        return;
    }
    if (big) {
        should_play_sound = 0;
        city_message_post(0, MESSAGE_FIRE, max_building->type, max_building->grid_offset);
        building_destroy_by_fire(max_building);
        play_sound_effect(SOUND_EFFECT_EXPLOSION);
        map_routing_update_land();
    } else {
        if (max_building->type == BUILDING_WAREHOUSE) {
            int amount = CURSE_LOADS;
            struct building_t *space = max_building;
            for (int i = 0; i < 8 && amount > 0; i++) {
                space = &all_buildings[space->next_part_building_id];
                if (space->id <= 0 || space->loads_stored <= 0) {
                    continue;
                }
                int resource = space->subtype.warehouse_resource_id;
                if (space->loads_stored > amount) {
                    city_resource_remove_from_warehouse(resource, amount);
                    space->loads_stored -= amount;
                    amount = 0;
                } else {
                    city_resource_remove_from_warehouse(resource, space->loads_stored);
                    amount -= space->loads_stored;
                    space->loads_stored = 0;
                    space->subtype.warehouse_resource_id = RESOURCE_NONE;
                }
                building_warehouse_space_set_image(space, resource);
            }
        } else if (max_building->type == BUILDING_GRANARY) {
            int amount = building_granary_remove_resource(max_building, RESOURCE_WHEAT, CURSE_LOADS * UNITS_PER_LOAD);
            amount = building_granary_remove_resource(max_building, RESOURCE_VEGETABLES, amount);
            amount = building_granary_remove_resource(max_building, RESOURCE_FRUIT, amount);
            building_granary_remove_resource(max_building, RESOURCE_MEAT, amount);
        }
    }
}

static void cause_invasion_mars(int enemy_amount)
{
    int grid_offset = start_invasion(ENEMY_TYPE_BARBARIAN, enemy_amount, MAX_INVASION_POINTS, FORMATION_ATTACK_FOOD_CHAIN);
    if (grid_offset > 0) {
        city_message_post(1, MESSAGE_LOCAL_UPRISING_MARS, 0, grid_offset);
    }
}

static void city_sentiment_set_max_happiness(int max)
{
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_IN_USE && b->house_size) {
            if (b->sentiment.house_happiness > max) {
                b->sentiment.house_happiness = max;
            }
            b->sentiment.house_happiness = calc_bound(b->sentiment.house_happiness, 0, 100);
        }
    }
}

static int calculate_people_per_house_type(void)
{
    city_data.population.people_in_tents_shacks = 0;
    city_data.population.people_in_villas_palaces = 0;
    city_data.population.people_in_tents = 0;
    city_data.population.people_in_large_insula_and_above = 0;
    int total = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_UNUSED ||
            b->state == BUILDING_STATE_UNDO ||
            b->state == BUILDING_STATE_DELETED_BY_GAME ||
            b->state == BUILDING_STATE_DELETED_BY_PLAYER) {
            continue;
        }
        if (b->house_size) {
            int pop = b->house_population;
            total += pop;
            if (b->subtype.house_level <= HOUSE_LARGE_TENT) {
                city_data.population.people_in_tents += pop;
            }
            if (b->subtype.house_level <= HOUSE_LARGE_SHACK) {
                city_data.population.people_in_tents_shacks += pop;
            }
            if (b->subtype.house_level >= HOUSE_LARGE_INSULA) {
                city_data.population.people_in_large_insula_and_above += pop;
            }
            if (b->subtype.house_level >= HOUSE_SMALL_VILLA) {
                city_data.population.people_in_villas_palaces += pop;
            }
        }
    }
    return total;
}

static void city_sentiment_update(void)
{
    int people_in_houses = calculate_people_per_house_type();
    if (people_in_houses < city_data.population.population) {
        remove_from_census(city_data.population.population - people_in_houses);
    }
    int sentiment_contribution_taxes = SENTIMENT_PER_TAX_RATE[city_data.finance.tax_percentage];
    int sentiment_contribution_wages = 0;
    int wage_diff = city_data.labor.wages - city_data.labor.wages_rome;
    if (wage_diff < 0) {
        sentiment_contribution_wages = wage_diff / 2;
        if (!sentiment_contribution_wages) {
            sentiment_contribution_wages = -1;
        }
    } else if (wage_diff > 7) {
        sentiment_contribution_wages = 4;
    } else if (wage_diff > 4) {
        sentiment_contribution_wages = 3;
    } else if (wage_diff > 1) {
        sentiment_contribution_wages = 2;
    } else if (wage_diff > 0) {
        sentiment_contribution_wages = 1;
    }
    int sentiment_contribution_employment = 1;
    if (city_data.labor.unemployment_percentage > 25) {
        sentiment_contribution_employment = -3;
    } else if (city_data.labor.unemployment_percentage > 17) {
        sentiment_contribution_employment = -2;
    } else if (city_data.labor.unemployment_percentage > 10) {
        sentiment_contribution_employment = -1;
    } else if (city_data.labor.unemployment_percentage > 4) {
        sentiment_contribution_employment = 0;
    }
    int sentiment_penalty_tents;
    int pct_tents = calc_percentage(city_data.population.people_in_tents, city_data.population.population);
    if (city_data.population.people_in_villas_palaces > 0) {
        if (pct_tents >= 57) {
            sentiment_penalty_tents = 0;
        } else if (pct_tents >= 40) {
            sentiment_penalty_tents = -3;
        } else if (pct_tents >= 26) {
            sentiment_penalty_tents = -4;
        } else if (pct_tents >= 10) {
            sentiment_penalty_tents = -5;
        } else {
            sentiment_penalty_tents = -6;
        }
    } else if (city_data.population.people_in_large_insula_and_above > 0) {
        if (pct_tents >= 57) {
            sentiment_penalty_tents = 0;
        } else if (pct_tents >= 40) {
            sentiment_penalty_tents = -2;
        } else if (pct_tents >= 26) {
            sentiment_penalty_tents = -3;
        } else if (pct_tents >= 10) {
            sentiment_penalty_tents = -4;
        } else {
            sentiment_penalty_tents = -5;
        }
    } else {
        if (pct_tents >= 40) {
            sentiment_penalty_tents = 0;
        } else if (pct_tents >= 26) {
            sentiment_penalty_tents = -1;
        } else if (pct_tents >= 10) {
            sentiment_penalty_tents = -2;
        } else {
            sentiment_penalty_tents = -3;
        }
    }
    int houses_calculated = 0;
    int houses_needing_food = 0;
    int total_sentiment_contribution_food = 0;
    int total_sentiment_penalty_tents = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE || !b->house_size) {
            continue;
        }
        if (!b->house_population) {
            b->sentiment.house_happiness = 50;
            continue;
        }
        if (city_data.population.population < 300) {
            // small town has no complaints
            sentiment_contribution_employment = 0;
            sentiment_contribution_taxes = 0;
            sentiment_contribution_wages = 0;

            b->sentiment.house_happiness = 50;
            if (city_data.population.population < 200) {
                b->sentiment.house_happiness += 10;
            }
            continue;
        }
        // population >= 300
        houses_calculated++;
        int sentiment_contribution_food = 0;
        int sentiment_contribution_tents = 0;
        if (!house_properties[b->subtype.house_level].food_types) {
            // tents
            b->house_days_without_food = 0;
            sentiment_contribution_tents = sentiment_penalty_tents;
            total_sentiment_penalty_tents += sentiment_penalty_tents;
        } else {
            // shack+
            houses_needing_food++;
            if (b->data.house.num_foods >= 2) {
                sentiment_contribution_food = 2;
                total_sentiment_contribution_food += 2;
                b->house_days_without_food = 0;
            } else if (b->data.house.num_foods >= 1) {
                sentiment_contribution_food = 1;
                total_sentiment_contribution_food += 1;
                b->house_days_without_food = 0;
            } else {
                // needs food but has no food
                if (b->house_days_without_food < 3) {
                    b->house_days_without_food++;
                }
                sentiment_contribution_food = -b->house_days_without_food;
                total_sentiment_contribution_food -= b->house_days_without_food;
            }
        }
        b->sentiment.house_happiness += sentiment_contribution_taxes;
        b->sentiment.house_happiness += sentiment_contribution_wages;
        b->sentiment.house_happiness += sentiment_contribution_employment;
        b->sentiment.house_happiness += sentiment_contribution_food;
        b->sentiment.house_happiness += sentiment_contribution_tents;
        b->sentiment.house_happiness = calc_bound(b->sentiment.house_happiness, 0, 100);
    }

    int sentiment_contribution_food = 0;
    int sentiment_contribution_tents = 0;
    if (houses_needing_food) {
        sentiment_contribution_food = total_sentiment_contribution_food / houses_needing_food;
    }
    if (houses_calculated) {
        sentiment_contribution_tents = total_sentiment_penalty_tents / houses_calculated;
    }

    int total_sentiment = 0;
    int total_houses = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_IN_USE && b->house_size && b->house_population) {
            total_houses++;
            total_sentiment += b->sentiment.house_happiness;
        }
    }
    if (total_houses) {
        city_data.sentiment.value = total_sentiment / total_houses;
    } else {
        city_data.sentiment.value = 60;
    }
    if (city_data.sentiment.message_delay) {
        city_data.sentiment.message_delay--;
    }
    if (city_data.sentiment.value < 48 && city_data.sentiment.value < city_data.sentiment.previous_value) {
        if (city_data.sentiment.message_delay <= 0) {
            city_data.sentiment.message_delay = 3;
            if (city_data.sentiment.value < 35) {
                city_message_post(0, MESSAGE_PEOPLE_ANGRY, 0, 0);
            } else if (city_data.sentiment.value < 40) {
                city_message_post(0, MESSAGE_PEOPLE_UNHAPPY, 0, 0);
            } else {
                city_message_post(0, MESSAGE_PEOPLE_DISGRUNTLED, 0, 0);
            }
        }
    }
    int worst_sentiment = 0;
    city_data.sentiment.low_mood_cause = LOW_MOOD_CAUSE_NONE;
    if (sentiment_contribution_food < worst_sentiment) {
        worst_sentiment = sentiment_contribution_food;
        city_data.sentiment.low_mood_cause = LOW_MOOD_CAUSE_NO_FOOD;
    }
    if (sentiment_contribution_employment < worst_sentiment) {
        worst_sentiment = sentiment_contribution_employment;
        city_data.sentiment.low_mood_cause = LOW_MOOD_CAUSE_NO_JOBS;
    }
    if (sentiment_contribution_taxes < worst_sentiment) {
        worst_sentiment = sentiment_contribution_taxes;
        city_data.sentiment.low_mood_cause = LOW_MOOD_CAUSE_HIGH_TAXES;
    }
    if (sentiment_contribution_wages < worst_sentiment) {
        worst_sentiment = sentiment_contribution_wages;
        city_data.sentiment.low_mood_cause = LOW_MOOD_CAUSE_LOW_WAGES;
    }
    if (sentiment_contribution_tents < worst_sentiment) {
        city_data.sentiment.low_mood_cause = LOW_MOOD_CAUSE_MANY_TENTS;
    }
    city_data.sentiment.previous_value = city_data.sentiment.value;
}

static void city_gods_calculate_moods(int update_moods)
{
    // base happiness: percentage of houses covered
    for (int i = 0; i < MAX_GODS; i++) {
        city_data.religion.gods[i].target_happiness = culture_coverage.religion[i];
    }

    int max_temples = 0;
    int max_god = TIE;
    int min_temples = 100000;
    int min_god = TIE;
    for (int i = 0; i < MAX_GODS; i++) {
        int num_temples = 0;
        switch (i) {
            case GOD_CERES:
                num_temples = count_data.buildings[BUILDING_SMALL_TEMPLE_CERES].total + count_data.buildings[BUILDING_LARGE_TEMPLE_CERES].total;
                break;
            case GOD_NEPTUNE:
                num_temples = count_data.buildings[BUILDING_SMALL_TEMPLE_NEPTUNE].total + count_data.buildings[BUILDING_LARGE_TEMPLE_NEPTUNE].total;
                break;
            case GOD_MERCURY:
                num_temples = count_data.buildings[BUILDING_SMALL_TEMPLE_MERCURY].total + count_data.buildings[BUILDING_LARGE_TEMPLE_MERCURY].total;
                break;
            case GOD_MARS:
                num_temples = count_data.buildings[BUILDING_SMALL_TEMPLE_MARS].total + count_data.buildings[BUILDING_LARGE_TEMPLE_MARS].total;
                break;
            case GOD_VENUS:
                num_temples = count_data.buildings[BUILDING_SMALL_TEMPLE_VENUS].total + count_data.buildings[BUILDING_LARGE_TEMPLE_VENUS].total;
                break;
        }
        if (num_temples == max_temples) {
            max_god = TIE;
        } else if (num_temples > max_temples) {
            max_temples = num_temples;
            max_god = i;
        }
        if (num_temples == min_temples) {
            min_god = TIE;
        } else if (num_temples < min_temples) {
            min_temples = num_temples;
            min_god = i;
        }
    }
    // happiness factor based on months since festival (max 40)
    for (int i = 0; i < MAX_GODS; i++) {
        int festival_penalty = city_data.religion.gods[i].months_since_festival;
        if (festival_penalty > 40) {
            festival_penalty = 40;
        }
        city_data.religion.gods[i].target_happiness += 12 - festival_penalty;
    }

    if (max_god < MAX_GODS) {
        if (city_data.religion.gods[max_god].target_happiness >= 50) {
            city_data.religion.gods[max_god].target_happiness = 100;
        } else {
            city_data.religion.gods[max_god].target_happiness += 50;
        }
    }
    if (min_god < MAX_GODS) {
        city_data.religion.gods[min_god].target_happiness -= 25;
    }
    int min_happiness;
    if (city_data.population.population < 100) {
        min_happiness = 50;
    } else if (city_data.population.population < 200) {
        min_happiness = 40;
    } else if (city_data.population.population < 300) {
        min_happiness = 30;
    } else if (city_data.population.population < 400) {
        min_happiness = 20;
    } else if (city_data.population.population < 500) {
        min_happiness = 10;
    } else {
        min_happiness = 0;
    }
    for (int i = 0; i < MAX_GODS; i++) {
        city_data.religion.gods[i].target_happiness =
            calc_bound(city_data.religion.gods[i].target_happiness, min_happiness, 100);
    }
    if (update_moods) {
        for (int i = 0; i < MAX_GODS; i++) {
            struct god_status_t *god = &city_data.religion.gods[i];
            if (god->happiness < god->target_happiness) {
                god->happiness++;
            } else if (god->happiness > god->target_happiness) {
                god->happiness--;
            }
            if (god->happiness > 50) {
                god->small_curse_done = 0;
            }
            if (god->happiness < 50) {
                god->blessing_done = 0;
            }
        }
        int god_id = random_data.random1_7bit & 7;
        if (god_id < MAX_GODS) {
            struct god_status_t *god = &city_data.religion.gods[god_id];
            if (god->happiness >= 50) {
                god->wrath_bolts = 0;
            } else if (god->happiness < 40) {
                if (god->happiness >= 20) {
                    god->wrath_bolts += 1;
                } else if (god->happiness >= 10) {
                    god->wrath_bolts += 2;
                } else {
                    god->wrath_bolts += 5;
                }
            }
            if (god->wrath_bolts > 50) {
                god->wrath_bolts = 50;
            }
        }
        if (time_data.day != 0) {
            return;
        }
        // handle blessings, curses, etc every month
        for (int i = 0; i < MAX_GODS; i++) {
            city_data.religion.gods[i].months_since_festival++;
        }
        if (god_id >= MAX_GODS) {
            if (city_gods_calculate_least_happy()) {
                god_id = city_data.religion.least_happy_god - 1;
            }
        }
        if (god_id < MAX_GODS) {
            struct god_status_t *god = &city_data.religion.gods[god_id];
            if (god->happiness >= 100 && !god->blessing_done) {
                god->blessing_done = 1;
                switch (god_id) {
                    case GOD_CERES:
                        city_message_post(1, MESSAGE_BLESSING_FROM_CERES, 0, 0);
                        for (int i = 1; i < MAX_BUILDINGS; i++) {
                            struct building_t *b = &all_buildings[i];
                            if (b->state == BUILDING_STATE_IN_USE && b->output_resource_id && building_is_farm(b->type)) {
                                b->data.industry.progress = MAX_PROGRESS_RAW;
                                b->data.industry.curse_days_left = 0;
                                b->data.industry.blessing_days_left = 16;
                                update_farm_image(b);
                            }
                        }
                        break;
                    case GOD_NEPTUNE:
                        city_message_post(1, MESSAGE_BLESSING_FROM_NEPTUNE, 0, 0);
                        city_data.religion.neptune_double_trade_active = 1;
                        break;
                    case GOD_MERCURY:
                        city_message_post(1, MESSAGE_BLESSING_FROM_MERCURY, 0, 0);
                        int min_stored = INFINITE;
                        struct building_t *min_building = 0;
                        for (int i = 1; i < MAX_BUILDINGS; i++) {
                            struct building_t *b = &all_buildings[i];
                            if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_GRANARY) {
                                continue;
                            }
                            int total_stored = 0;
                            for (int r = RESOURCE_WHEAT; r < FOOD_TYPES_MAX; r++) {
                                total_stored += get_amount(b, r);
                            }
                            if (total_stored < min_stored) {
                                min_stored = total_stored;
                                min_building = b;
                            }
                        }
                        if (min_building) {
                            for (int n = 0; n < 6; n++) {
                                building_granary_add_resource(min_building, RESOURCE_WHEAT, 0);
                            }
                            for (int n = 0; n < 6; n++) {
                                building_granary_add_resource(min_building, RESOURCE_VEGETABLES, 0);
                            }
                            for (int n = 0; n < 6; n++) {
                                building_granary_add_resource(min_building, RESOURCE_FRUIT, 0);
                            }
                            for (int n = 0; n < 6; n++) {
                                building_granary_add_resource(min_building, RESOURCE_MEAT, 0);
                            }
                        }
                        break;
                    case GOD_MARS:
                        city_message_post(1, MESSAGE_BLESSING_FROM_MARS, 0, 0);
                        city_data.religion.mars_spirit_power = 10;
                        break;
                    case GOD_VENUS:
                        city_message_post(1, MESSAGE_BLESSING_FROM_VENUS, 0, 0);
                        city_sentiment_change_happiness(25);
                        break;
                }
            } else if (god->wrath_bolts >= 20 && !god->small_curse_done && god->months_since_festival > 3) {
                god->small_curse_done = 1;
                god->wrath_bolts = 0;
                god->happiness += 12;
                switch (god_id) {
                    case GOD_CERES:
                        city_message_post(1, MESSAGE_CERES_IS_UPSET, 0, 0);
                        building_curse_farms(0);
                        break;
                    case GOD_NEPTUNE:
                        city_message_post(1, MESSAGE_NEPTUNE_IS_UPSET, 0, 0);
                        figure_sink_all_ships();
                        city_data.religion.neptune_sank_ships = 1;
                        break;
                    case GOD_MERCURY:
                        city_message_post(1, MESSAGE_MERCURY_IS_UPSET, 0, 0);
                        building_granary_warehouse_curse(0);
                        break;
                    case GOD_MARS:
                        city_message_post(1, MESSAGE_MARS_IS_UPSET, 0, 0);
                        cause_invasion_mars(MARS_INVASION_SMALL);
                        break;
                    case GOD_VENUS:
                        city_message_post(1, MESSAGE_VENUS_IS_UPSET, 0, 0);
                        city_sentiment_set_max_happiness(50);
                        city_sentiment_change_happiness(-5);
                        city_data.health.value = calc_bound(city_data.health.value - 10, 0, 100);
                        city_sentiment_update();
                        break;
                }
            } else if (god->wrath_bolts >= 50 && god->months_since_festival > 3) {
                god->wrath_bolts = 0;
                god->happiness += 30;
                switch (god_id) {
                    case GOD_CERES:
                        city_message_post(1, MESSAGE_WRATH_OF_CERES, 0, 0);
                        building_curse_farms(1);
                        break;
                    case GOD_NEPTUNE:
                        if (city_data.trade.num_sea_routes <= 0) {
                            city_message_post(1, MESSAGE_WRATH_OF_NEPTUNE_NO_SEA_TRADE, 0, 0);
                            return;
                        } else {
                            city_message_post(1, MESSAGE_WRATH_OF_NEPTUNE, 0, 0);
                            figure_sink_all_ships();
                            city_data.religion.neptune_sank_ships = 1;
                            city_data.trade.sea_trade_problem_duration = 80;
                        }
                        break;
                    case GOD_MERCURY:
                        city_message_post(1, MESSAGE_WRATH_OF_MERCURY, 0, 0);
                        building_granary_warehouse_curse(1);
                        break;
                    case GOD_MARS:
                    {
                        struct formation_t *best_legion = 0;
                        int best_legion_weight = 0;
                        for (int i = 0; i < MAX_LEGIONS; i++) {
                            if (legion_formations[i].in_use) {
                                int weight = legion_formations[i].num_figures;
                                if (legion_formations[i].figure_type == FIGURE_FORT_LEGIONARY) {
                                    weight *= 2;
                                }
                                if (weight > best_legion_weight) {
                                    best_legion_weight = weight;
                                    best_legion = &legion_formations[i];
                                }
                            }
                        }
                        if (best_legion) {
                            for (int i = 0; i < best_legion->max_figures; i++) {
                                if (best_legion->figures[i]) {
                                    struct figure_t *f = &figures[best_legion->figures[i]];
                                    struct map_point_t nearest_barracks_road_tile = { 0 };
                                    set_destination__closest_building_of_type(best_legion->building_id, BUILDING_BARRACKS, &nearest_barracks_road_tile);
                                    figure_route_remove(f);
                                    if (nearest_barracks_road_tile.x) {
                                        f->destination_x = nearest_barracks_road_tile.x;
                                        f->destination_y = nearest_barracks_road_tile.y;
                                    } else {
                                        f->destination_x = scenario.exit_point.x;
                                        f->destination_y = scenario.exit_point.y;
                                    }
                                    f->action_state = FIGURE_ACTION_SOLDIER_RETURNING_TO_BARRACKS;
                                }
                            }
                            best_legion->cursed_by_mars = 96;
                            city_message_post(1, MESSAGE_WRATH_OF_MARS, 0, 0);
                        } else {
                            city_message_post(1, MESSAGE_WRATH_OF_MARS_NO_MILITARY, 0, 0);
                        }
                        cause_invasion_mars(MARS_INVASION_LARGE);
                        break;
                    }
                    case GOD_VENUS:
                        city_message_post(1, MESSAGE_WRATH_OF_VENUS, 0, 0);
                        city_sentiment_set_max_happiness(40);
                        city_sentiment_change_happiness(-10);
                        if (city_data.health.value >= 80) {
                            city_data.health.value = calc_bound(city_data.health.value - 50, 0, 100);
                        } else if (city_data.health.value >= 60) {
                            city_data.health.value = calc_bound(city_data.health.value - 40, 0, 100);
                        } else {
                            city_data.health.value = calc_bound(city_data.health.value - 20, 0, 100);
                        }
                        city_data.religion.venus_curse_active = 1;
                        city_sentiment_update();
                        break;
                }
            }
        }
        min_happiness = 100;
        for (int i = 0; i < MAX_GODS; i++) {
            if (city_data.religion.gods[i].happiness < min_happiness) {
                min_happiness = city_data.religion.gods[i].happiness;
            }
        }
        if (city_data.religion.angry_message_delay) {
            city_data.religion.angry_message_delay--;
        } else if (min_happiness < 30) {
            city_data.religion.angry_message_delay = 20;
            if (min_happiness < 10) {
                city_message_post(0, MESSAGE_GODS_WRATHFUL, 0, 0);
            } else {
                city_message_post(0, MESSAGE_GODS_UNHAPPY, 0, 0);
            }
        }
    }
}

static void city_culture_calculate(void)
{
    city_data.culture.average_entertainment = 0;
    city_data.culture.average_religion = 0;
    city_data.culture.average_education = 0;
    city_data.culture.average_health = 0;

    int num_houses = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_IN_USE && b->house_size) {
            num_houses++;
            city_data.culture.average_entertainment += b->data.house.entertainment;
            city_data.culture.average_religion += b->data.house.num_gods;
            city_data.culture.average_education += b->data.house.education;
            city_data.culture.average_health += b->data.house.health;
        }
    }
    if (num_houses) {
        city_data.culture.average_entertainment /= num_houses;
        city_data.culture.average_religion /= num_houses;
        city_data.culture.average_education /= num_houses;
        city_data.culture.average_health /= num_houses;
    }
    // calculate entertainment shows
    city_data.entertainment.theater_shows = 0;
    city_data.entertainment.theater_no_shows_weighted = 0;
    city_data.entertainment.amphitheater_shows = 0;
    city_data.entertainment.amphitheater_no_shows_weighted = 0;
    city_data.entertainment.colosseum_shows = 0;
    city_data.entertainment.colosseum_no_shows_weighted = 0;
    city_data.entertainment.hippodrome_shows = 0;
    city_data.entertainment.hippodrome_no_shows_weighted = 0;
    city_data.entertainment.venue_needing_shows = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE) {
            continue;
        }
        switch (b->type) {
            case BUILDING_THEATER:
                if (b->data.entertainment.days1) {
                    city_data.entertainment.theater_shows++;
                } else {
                    city_data.entertainment.theater_no_shows_weighted++;
                }
                break;
            case BUILDING_AMPHITHEATER:
                if (b->data.entertainment.days1) {
                    city_data.entertainment.amphitheater_shows++;
                } else {
                    city_data.entertainment.amphitheater_no_shows_weighted += 2;
                }
                if (b->data.entertainment.days2) {
                    city_data.entertainment.amphitheater_shows++;
                } else {
                    city_data.entertainment.amphitheater_no_shows_weighted += 2;
                }
                break;
            case BUILDING_COLOSSEUM:
                if (b->data.entertainment.days1) {
                    city_data.entertainment.colosseum_shows++;
                } else {
                    city_data.entertainment.colosseum_no_shows_weighted += 3;
                }
                if (b->data.entertainment.days2) {
                    city_data.entertainment.colosseum_shows++;
                } else {
                    city_data.entertainment.colosseum_no_shows_weighted += 3;
                }
                break;
            case BUILDING_HIPPODROME:
                if (b->data.entertainment.days1) {
                    city_data.entertainment.hippodrome_shows++;
                } else {
                    city_data.entertainment.hippodrome_no_shows_weighted += 100;
                }
                break;
        }
    }
    int worst_shows = 0;
    if (city_data.entertainment.theater_no_shows_weighted > worst_shows) {
        worst_shows = city_data.entertainment.theater_no_shows_weighted;
        city_data.entertainment.venue_needing_shows = 1;
    }
    if (city_data.entertainment.amphitheater_no_shows_weighted > worst_shows) {
        worst_shows = city_data.entertainment.amphitheater_no_shows_weighted;
        city_data.entertainment.venue_needing_shows = 2;
    }
    if (city_data.entertainment.colosseum_no_shows_weighted > worst_shows) {
        worst_shows = city_data.entertainment.colosseum_no_shows_weighted;
        city_data.entertainment.venue_needing_shows = 3;
    }
    if (city_data.entertainment.hippodrome_no_shows_weighted > worst_shows) {
        city_data.entertainment.venue_needing_shows = 4;
    }
}

static void city_finance_estimate_taxes(void)
{
    city_data.taxes.monthly.collected_plebs = 0;
    city_data.taxes.monthly.collected_patricians = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_IN_USE && b->house_size && b->house_tax_coverage) {
            int is_patrician = b->subtype.house_level >= HOUSE_SMALL_VILLA;
            if (is_patrician) {
                city_data.taxes.monthly.collected_patricians += b->house_population * house_properties[b->subtype.house_level].tax_multiplier;
            } else {
                city_data.taxes.monthly.collected_plebs += b->house_population * house_properties[b->subtype.house_level].tax_multiplier;
            }
        }
    }
    int monthly_patricians = calc_adjust_with_percentage(city_data.taxes.monthly.collected_patricians / 2, city_data.finance.tax_percentage);
    int monthly_plebs = calc_adjust_with_percentage(city_data.taxes.monthly.collected_plebs / 2, city_data.finance.tax_percentage);
    int estimated_rest_of_year = (12 - time_data.month) * (monthly_patricians + monthly_plebs);

    city_data.finance.this_year.income.taxes =
        city_data.taxes.yearly.collected_plebs + city_data.taxes.yearly.collected_patricians;
    city_data.finance.estimated_tax_income = city_data.finance.this_year.income.taxes + estimated_rest_of_year;
}

static void city_finance_calculate_totals(void)
{
    struct finance_overview_t *this_year = &city_data.finance.this_year;
    this_year->income.total =
        this_year->income.donated +
        this_year->income.taxes +
        this_year->income.exports;

    this_year->expenses.total =
        this_year->expenses.sundries +
        this_year->expenses.salary +
        this_year->expenses.interest +
        this_year->expenses.construction +
        this_year->expenses.wages +
        this_year->expenses.imports;

    struct finance_overview_t *last_year = &city_data.finance.last_year;
    last_year->net_in_out = last_year->income.total - last_year->expenses.total;
    this_year->net_in_out = this_year->income.total - this_year->expenses.total;
    this_year->balance = last_year->balance + this_year->net_in_out;

    this_year->expenses.tribute = 0;
}

static void adjust_taxes(int value)
{
    city_data.finance.tax_percentage = calc_bound(city_data.finance.tax_percentage + value, 0, 25);
    city_finance_estimate_taxes();
    city_finance_calculate_totals();
}

static void adjust_donation_amount(int value)
{
    city_data.emperor.donate_amount = calc_bound(city_data.emperor.donate_amount + value, 0, city_data.emperor.personal_savings);
    refresh_current_window = 1;
}

static void set_donation_amount(int amount)
{
    city_data.emperor.donate_amount = calc_bound(amount, 0, city_data.emperor.personal_savings);
    refresh_current_window = 1;
}

static void city_finance_process_donation(int amount)
{
    city_data.finance.treasury += amount;
    city_data.finance.this_year.income.donated += amount;
}

static void city_ratings_update_favor_explanation(void)
{
    city_data.ratings.favor_salary_penalty = 0;
    int salary_delta = city_data.emperor.salary_rank - city_data.emperor.player_rank;
    if (city_data.emperor.player_rank != 0) {
        if (salary_delta > 0) {
            city_data.ratings.favor_salary_penalty = salary_delta + 1;
        }
    } else if (salary_delta > 0) {
        city_data.ratings.favor_salary_penalty = salary_delta;
    }

    if (city_data.ratings.favor_salary_penalty >= 8) {
        city_data.ratings.favor_explanation = 1;
    } else if (city_data.finance.tribute_not_paid_total_years >= 3) {
        city_data.ratings.favor_explanation = 2;
    } else if (city_data.ratings.favor_ignored_request_penalty >= 5) {
        city_data.ratings.favor_explanation = 3;
    } else if (city_data.ratings.favor_salary_penalty >= 5) {
        city_data.ratings.favor_explanation = 4;
    } else if (city_data.finance.tribute_not_paid_total_years >= 2) {
        city_data.ratings.favor_explanation = 5;
    } else if (city_data.ratings.favor_ignored_request_penalty >= 3) {
        city_data.ratings.favor_explanation = 6;
    } else if (city_data.ratings.favor_salary_penalty >= 3) {
        city_data.ratings.favor_explanation = 7;
    } else if (city_data.finance.tribute_not_paid_last_year) {
        city_data.ratings.favor_explanation = 8;
    } else if (city_data.ratings.favor_salary_penalty >= 2) {
        city_data.ratings.favor_explanation = 9;
    } else if (city_data.ratings.favor_salary_penalty) {
        city_data.ratings.favor_explanation = 11;
    } else if (city_data.ratings.favor_change == 2) { // rising
        city_data.ratings.favor_explanation = 12;
    } else if (city_data.ratings.favor_change == 1) { // the same
        city_data.ratings.favor_explanation = 13;
    } else {
        city_data.ratings.favor_explanation = 0;
    }
}

static void send_gift_to_emperor(int gift_size)
{
    if (city_data.emperor.gifts[gift_size].cost <= city_data.emperor.personal_savings) {
        if (city_data.emperor.gift_overdose_penalty <= 0) {
            city_data.emperor.gift_overdose_penalty = 1;
            if (gift_size == GIFT_MODEST) {
                city_data.ratings.favor = calc_bound(city_data.ratings.favor + 3, 0, 100);
            } else if (gift_size == GIFT_GENEROUS) {
                city_data.ratings.favor = calc_bound(city_data.ratings.favor + 5, 0, 100);
            } else if (gift_size == GIFT_LAVISH) {
                city_data.ratings.favor = calc_bound(city_data.ratings.favor + 10, 0, 100);
            }
        } else if (city_data.emperor.gift_overdose_penalty == 1) {
            city_data.emperor.gift_overdose_penalty = 2;
            if (gift_size == GIFT_MODEST) {
                city_data.ratings.favor = calc_bound(city_data.ratings.favor + 1, 0, 100);
            } else if (gift_size == GIFT_GENEROUS) {
                city_data.ratings.favor = calc_bound(city_data.ratings.favor + 3, 0, 100);
            } else if (gift_size == GIFT_LAVISH) {
                city_data.ratings.favor = calc_bound(city_data.ratings.favor + 5, 0, 100);
            }
        } else if (city_data.emperor.gift_overdose_penalty == 2) {
            city_data.emperor.gift_overdose_penalty = 3;
            if (gift_size == GIFT_MODEST) {
                city_data.ratings.favor = calc_bound(city_data.ratings.favor + 0, 0, 100);
            } else if (gift_size == GIFT_GENEROUS) {
                city_data.ratings.favor = calc_bound(city_data.ratings.favor + 0, 0, 100);
            } else if (gift_size == GIFT_LAVISH) {
                city_data.ratings.favor = calc_bound(city_data.ratings.favor + 3, 0, 100);
            }
        } else if (city_data.emperor.gift_overdose_penalty == 3) {
            city_data.emperor.gift_overdose_penalty = 4;
            if (gift_size == GIFT_MODEST) {
                city_data.ratings.favor = calc_bound(city_data.ratings.favor + 0, 0, 100);
            } else if (gift_size == GIFT_GENEROUS) {
                city_data.ratings.favor = calc_bound(city_data.ratings.favor + 0, 0, 100);
            } else if (gift_size == GIFT_LAVISH) {
                city_data.ratings.favor = calc_bound(city_data.ratings.favor + 1, 0, 100);
            }
        }
        city_data.emperor.months_since_gift = 0;
        // rotate gift type
        city_data.emperor.gifts[gift_size].id++;
        if (city_data.emperor.gifts[gift_size].id >= 4) {
            city_data.emperor.gifts[gift_size].id = 0;
        }
        city_data.emperor.personal_savings -= city_data.emperor.gifts[gift_size].cost;
    }
    change_window(WINDOW_ADVISOR_IMPERIAL);
}

static void draw_trade_resource(int resource, int trade_max, int x_offset, int y_offset)
{
    graphics_draw_inset_rect(x_offset, y_offset, 26, 26);
    int image_id = resource_images[resource].empire_icon_img_id + resource_image_offset(resource, RESOURCE_IMAGE_ICON);
    image_draw(image_id, x_offset + 1, y_offset + 1);
    if (empire_window_data.focus_resource == resource) {
        button_border_draw(x_offset - 2, y_offset - 2, 101 + 4, 30, 1);
    }
    switch (trade_max) {
        case 15:
            image_draw(8000, x_offset + 21, y_offset - 1);
            break;
        case 25:
            image_draw(8001, x_offset + 17, y_offset - 1);
            break;
        case 40:
            image_draw(8002, x_offset + 13, y_offset - 1);
            break;
    }
}

static void window_empire_show(void)
{
    selected_empire_object = 0;
    change_window(WINDOW_EMPIRE);
}

static void draw_finances_row(int value_last_year, int value_this_year, int y)
{
    text_draw_number(value_last_year, 0, 0, screen_center_x - 18, y, FONT_NORMAL_BLACK);
    text_draw_number(value_this_year, 0, 0, screen_center_x + 154, y, FONT_NORMAL_BLACK);
}

static int house_population_remove_from_city(int num_people)
{
    int removed = 0;
    int building_id = city_data.population.last_used_house_remove;
    for (int i = 1; i < 4 * MAX_BUILDINGS && removed < num_people; i++) {
        if (++building_id >= MAX_BUILDINGS) {
            building_id = 1;
        }
        struct building_t *b = &all_buildings[building_id];
        if (b->state == BUILDING_STATE_IN_USE && b->house_size) {
            city_data.population.last_used_house_remove = building_id;
            if (b->house_population > 0) {
                ++removed;
                --b->house_population;
            }
        }
    }
    return removed;
}

static void allocate_workers_to_categories(void)
{
    int workers_needed = 0;
    for (int i = 0; i < LABOR_CATEGORIES_COUNT; i++) {
        city_data.labor.categories[i].workers_allocated = 0;
        workers_needed += city_data.labor.categories[i].workers_needed;
    }
    city_data.labor.workers_needed = 0;
    if (workers_needed <= city_data.labor.workers_available) {
        for (int i = 0; i < LABOR_CATEGORIES_COUNT; i++) {
            city_data.labor.categories[i].workers_allocated = city_data.labor.categories[i].workers_needed;
        }
        city_data.labor.workers_employed = workers_needed;
    } else {
        // not enough workers
        int available = city_data.labor.workers_available;
        // distribute by user-defined priority
        for (int p = 1; p <= 9 && available > 0; p++) {
            for (int c = 0; c < 9; c++) {
                if (p == city_data.labor.categories[c].priority) {
                    int to_allocate = city_data.labor.categories[c].workers_needed;
                    if (to_allocate > available) {
                        to_allocate = available;
                    }
                    city_data.labor.categories[c].workers_allocated = to_allocate;
                    available -= to_allocate;
                    break;
                }
            }
        }
        // (sort of) round-robin distribution over unprioritized categories:
        int guard = 0;
        do {
            guard++;
            if (guard >= city_data.labor.workers_available) {
                break;
            }
            for (int p = 0; p < 9; p++) {
                int cat = DEFAULT_PRIORITY[p].category;
                if (!city_data.labor.categories[cat].priority) {
                    int needed = city_data.labor.categories[cat].workers_needed
                        - city_data.labor.categories[cat].workers_allocated;
                    if (needed > 0) {
                        int to_allocate = DEFAULT_PRIORITY[p].workers;
                        if (to_allocate > available) {
                            to_allocate = available;
                        }
                        if (to_allocate > needed) {
                            to_allocate = needed;
                        }
                        city_data.labor.categories[cat].workers_allocated += to_allocate;
                        available -= to_allocate;
                        if (available <= 0) {
                            break;
                        }
                    }
                }
            }
        } while (available > 0);

        city_data.labor.workers_employed = city_data.labor.workers_available;
        for (int i = 0; i < 9; i++) {
            city_data.labor.workers_needed +=
                city_data.labor.categories[i].workers_needed - city_data.labor.categories[i].workers_allocated;
        }
    }
    city_data.labor.workers_unemployed = city_data.labor.workers_available - city_data.labor.workers_employed;
    city_data.labor.unemployment_percentage =
        calc_percentage(city_data.labor.workers_unemployed, city_data.labor.workers_available);
}

static int should_have_workers(struct building_t *b, int check_access)
{
    if (b->labor_category < 0) {
        return 0;
    }

    if (b->labor_category == LABOR_CATEGORY_ENTERTAINMENT) {
        if (b->type == BUILDING_HIPPODROME && b->prev_part_building_id) {
            return 0;
        }
    } else if (b->labor_category == LABOR_CATEGORY_FOOD_PRODUCTION || b->labor_category == LABOR_CATEGORY_INDUSTRY_COMMERCE) {
        if (b->type >= BUILDING_WHEAT_FARM && b->type <= BUILDING_WEAPONS_WORKSHOP && city_data.resource.mothballed[b->output_resource_id]) {
            return 0;
        }
    }
    // engineering and water are always covered
    if (b->labor_category == LABOR_CATEGORY_ENGINEERING || b->labor_category == LABOR_CATEGORY_WATER) {
        return 1;
    }
    if (check_access) {
        return b->houses_covered > 0 ? 1 : 0;
    }
    return 1;
}

static void allocate_workers_to_buildings(void)
{
    // set building worker weight
    int water_per_10k_per_building = calc_percentage(100, city_data.labor.categories[LABOR_CATEGORY_WATER].buildings);
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE) {
            continue;
        }
        int cat = building_properties[b->type].labor_category;
        if (cat == LABOR_CATEGORY_WATER) {
            b->percentage_houses_covered = water_per_10k_per_building;
        } else if (cat >= 0) {
            b->percentage_houses_covered = 0;
            if (b->houses_covered) {
                b->percentage_houses_covered =
                    calc_percentage(100 * b->houses_covered, city_data.labor.categories[cat].total_houses_covered);
            }
        }
    }
    // allocate workers to water
    static int start_building_id = 1;
    struct labor_category_data_t *water_cat = &city_data.labor.categories[LABOR_CATEGORY_WATER];

    int percentage_not_filled = 100 - calc_percentage(water_cat->workers_allocated, water_cat->workers_needed);

    int buildings_to_skip = calc_adjust_with_percentage(water_cat->buildings, percentage_not_filled);

    int workers_per_building;
    if (buildings_to_skip == water_cat->buildings) {
        workers_per_building = 1;
    } else {
        workers_per_building = water_cat->workers_allocated / (water_cat->buildings - buildings_to_skip);
    }
    int building_id = start_building_id;
    start_building_id = 0;
    for (int guard = 1; guard < MAX_BUILDINGS; guard++, building_id++) {
        if (building_id >= MAX_BUILDINGS) {
            building_id = 1;
        }
        struct building_t *b = &all_buildings[building_id];
        if (b->state != BUILDING_STATE_IN_USE || building_properties[b->type].labor_category != LABOR_CATEGORY_WATER) {
            continue;
        }
        b->num_workers = 0;
        if (b->percentage_houses_covered > 0) {
            if (percentage_not_filled > 0) {
                if (buildings_to_skip) {
                    --buildings_to_skip;
                } else if (start_building_id) {
                    b->num_workers = workers_per_building;
                } else {
                    start_building_id = building_id;
                    b->num_workers = workers_per_building;
                }
            } else {
                b->num_workers = building_properties[b->type].n_laborers;
            }
        }
    }
    if (!start_building_id) {
        // no buildings assigned or full employment
        start_building_id = 1;
    }
    // allocate workers to non-water buildings
    int category_workers_needed[LABOR_CATEGORIES_COUNT];
    int category_workers_allocated[LABOR_CATEGORIES_COUNT];
    for (int i = 0; i < LABOR_CATEGORIES_COUNT; i++) {
        category_workers_allocated[i] = 0;
        category_workers_needed[i] =
            city_data.labor.categories[i].workers_allocated < city_data.labor.categories[i].workers_needed
            ? 1 : 0;
    }
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE) {
            continue;
        }
        int cat = building_properties[b->type].labor_category;
        if (cat == LABOR_CATEGORY_WATER || cat < 0) {
            // water is handled by allocate workers to water(void)
            continue;
        }
        b->num_workers = 0;
        if (!should_have_workers(b, 0)) {
            continue;
        }
        if (b->percentage_houses_covered > 0) {
            if (category_workers_needed[cat]) {
                int num_workers = calc_adjust_with_percentage(
                    city_data.labor.categories[cat].workers_allocated,
                    b->percentage_houses_covered) / 100;
                if (num_workers > building_properties[b->type].n_laborers) {
                    num_workers = building_properties[b->type].n_laborers;
                }
                b->num_workers = num_workers;
                category_workers_allocated[cat] += num_workers;
            } else {
                b->num_workers = building_properties[b->type].n_laborers;
            }
        }
    }
    for (int i = 0; i < LABOR_CATEGORIES_COUNT; i++) {
        if (category_workers_needed[i]) {
            // watch out: category_workers_needed is now reset to 'unallocated workers available'
            if (category_workers_allocated[i] >= city_data.labor.categories[i].workers_allocated) {
                category_workers_needed[i] = 0;
                category_workers_allocated[i] = 0;
            } else {
                category_workers_needed[i] =
                    city_data.labor.categories[i].workers_allocated - category_workers_allocated[i];
            }
        }
    }
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE) {
            continue;
        }
        int cat = building_properties[b->type].labor_category;
        if (cat < 0 || cat == LABOR_CATEGORY_WATER || cat == LABOR_CATEGORY_MILITARY) {
            continue;
        }
        if (!should_have_workers(b, 0)) {
            continue;
        }
        if (b->percentage_houses_covered > 0 && category_workers_needed[cat]) {
            if (b->num_workers < building_properties[b->type].n_laborers) {
                int needed = building_properties[b->type].n_laborers - b->num_workers;
                if (needed > category_workers_needed[cat]) {
                    b->num_workers += category_workers_needed[cat];
                    category_workers_needed[cat] = 0;
                } else {
                    b->num_workers += needed;
                    category_workers_needed[cat] -= needed;
                }
            }
        }
    }
}

static void city_labor_allocate_workers(void)
{
    allocate_workers_to_categories();
    allocate_workers_to_buildings();
}

static void city_labor_set_priority(int category, int new_priority)
{
    int old_priority = city_data.labor.categories[category].priority;
    if (old_priority == new_priority) {
        return;
    }
    int shift;
    int from_prio;
    int to_prio;
    if (!old_priority && new_priority) {
        // shift all bigger than 'new_priority' by one down (+1)
        shift = 1;
        from_prio = new_priority;
        to_prio = 9;
    } else if (old_priority && !new_priority) {
        // shift all bigger than 'old_priority' by one up (-1)
        shift = -1;
        from_prio = old_priority;
        to_prio = 9;
    } else if (new_priority < old_priority) {
        // shift all between new and old by one down (+1)
        shift = 1;
        from_prio = new_priority;
        to_prio = old_priority;
    } else {
        // shift all between old and new by one up (-1)
        shift = -1;
        from_prio = old_priority;
        to_prio = new_priority;
    }
    city_data.labor.categories[category].priority = new_priority;
    for (int i = 0; i < 9; i++) {
        if (i == category) {
            continue;
        }
        int current_priority = city_data.labor.categories[i].priority;
        if (from_prio <= current_priority && current_priority <= to_prio) {
            city_data.labor.categories[i].priority += shift;
        }
    }
    city_labor_allocate_workers();
}

static void city_finance_estimate_wages(void)
{
    int monthly_wages = city_data.labor.wages * city_data.labor.workers_employed / 10 / 12;
    city_data.finance.this_year.expenses.wages = city_data.finance.wages_so_far;
    city_data.finance.estimated_wages = (12 - time_data.month) * monthly_wages + city_data.finance.wages_so_far;
}

static void modify_wages(int value)
{
    city_data.labor.wages = calc_bound(city_data.labor.wages + value, 0, 100);
    city_finance_estimate_wages();
    city_finance_calculate_totals();
    refresh_current_window = 1;
}

static int get_legion_formation_by_index_rank(int legion_index)
{
    int index = 0;
    for (int i = 0; i < MAX_LEGIONS; i++) {
        if (legion_formations[i].in_use) {
            if (index == legion_index) {
                return i;
            }
            index++;
        }
    }
    return -1;
}

static void draw_rating_column(int x_offset, int y_offset, int value, int has_reached)
{
    int y = y_offset - image_get(1414)->height;
    image_draw(1414, x_offset, y);
    for (int i = 0; i < 2 * value; i++) {
        image_draw(1415, x_offset + 11, --y);
    }
    if (value >= 30 && has_reached) {
        image_draw(1416, x_offset - 6, y);
    }
}

static int our_city_can_produce_resource(int resource)
{
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        if (empire_objects[i].in_use && empire_objects[i].city_type == EMPIRE_CITY_OURS) {
            if (empire_objects[i].resource_sell_limit[resource]) {
                return 1;
            } else {
                // there's only one of our city per empire state, no need to search the rest of the list
                return 0;
            }
        }
    }
    // our city wasn't found or not in use (shouldn't happen)
    return 0;
}

static int resource_import_trade_route_open(int resource)
{
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        if (empire_objects[i].in_use
            && empire_objects[i].city_type == EMPIRE_CITY_TRADE
            && empire_objects[i].trade_route_open
            && empire_objects[i].resource_sell_limit[resource]) {
            return 1;
        }
    }
    return 0;
}

static int empire_can_produce_resource(int resource)
{
    int raw_resource;
    switch (resource) {
        case RESOURCE_POTTERY:
            raw_resource = RESOURCE_CLAY;
            break;
        case RESOURCE_FURNITURE:
            raw_resource = RESOURCE_TIMBER;
            break;
        case RESOURCE_OIL:
            raw_resource = RESOURCE_OLIVES;
            break;
        case RESOURCE_WINE:
            raw_resource = RESOURCE_VINES;
            break;
        case RESOURCE_WEAPONS:
            raw_resource = RESOURCE_IRON;
            break;
        default:
            raw_resource = resource;
            break;
    }
    // if raw resource, available if we can either produce or import it
    if (resource == raw_resource) {
        return (our_city_can_produce_resource(resource) || resource_import_trade_route_open(resource));
    }
    // if finished goods, available if we can either:
    // - produce the raw material or import it, and we can produce the finished material (workshop is allowed)
    // - import the finished goods
    else {
        return (
                resource_import_trade_route_open(resource)
            || ((our_city_can_produce_resource(raw_resource) || resource_import_trade_route_open(raw_resource)) && our_city_can_produce_resource(resource))
        );
    }
}

static void city_resource_determine_available(void)
{
    for (int i = 0; i < RESOURCE_TYPES_MAX; i++) {
        available.resource_list.items[i] = 0;
        available.food_list.items[i] = 0;
    }
    available.resource_list.size = 0;
    available.food_list.size = 0;

    for (int i = RESOURCE_WHEAT; i < RESOURCE_TYPES_MAX; i++) {
        if (empire_can_produce_resource(i)) {
            available.resource_list.items[available.resource_list.size++] = i;
        }
    }
    for (int i = RESOURCE_WHEAT; i <= RESOURCE_MEAT; i++) {
        if (empire_can_produce_resource(i)) {
            available.food_list.items[available.food_list.size++] = i;
        }
    }
}

static void switch_population_graph(int new_order_determinant)
{
    int new_order;
    switch (city_data.population.graph_order) {
        default:
        case 0:
            new_order = new_order_determinant ? 5 : 2;
            break;
        case 1:
            new_order = new_order_determinant ? 3 : 4;
            break;
        case 2:
            new_order = new_order_determinant ? 4 : 0;
            break;
        case 3:
            new_order = new_order_determinant ? 1 : 5;
            break;
        case 4:
            new_order = new_order_determinant ? 2 : 1;
            break;
        case 5:
            new_order = new_order_determinant ? 0 : 3;
            break;
    }
    city_data.population.graph_order = new_order;
    refresh_current_window = 1;
}

static void get_y_axis(int max_value, int *y_max, int *y_shift)
{
    int max = 1;
    int shift = -1;
    int value = max_value > 0 ? (max_value - 1) / 100 : 0;
    while (value) {
        max <<= 1;
        shift++;
        value >>= 1;
    }
    *y_max = max * 100;
    *y_shift = shift;
}

static int city_population_at_month(int max_months, int month)
{
    int start_offset = 0;
    if (city_data.population.monthly.count > max_months) {
        start_offset = city_data.population.monthly.count + 2400 - max_months;
    }
    int index = (start_offset + month) % 2400;
    return city_data.population.monthly.values[index];
}

static void draw_history_graph(int full_size, int x, int y)
{
    int max_months;
    if (city_data.population.monthly.count <= 20) {
        max_months = 20;
    } else if (city_data.population.monthly.count <= 40) {
        max_months = 40;
    } else if (city_data.population.monthly.count <= 100) {
        max_months = 100;
    } else if (city_data.population.monthly.count <= 200) {
        max_months = 200;
    } else {
        max_months = 400;
    }
    if (!full_size) {
        if (max_months <= 40) {
            max_months = 20;
        } else {
            max_months = 100;
        }
    }
    // determine max value
    int max_value = 0;
    for (int m = 0; m < max_months; m++) {
        int value = city_population_at_month(max_months, m);
        if (value > max_value) {
            max_value = value;
        }
    }
    int y_max, y_shift;
    get_y_axis(max_value, &y_max, &y_shift);
    if (full_size) {
        // y axis
        text_draw_number_centered(y_max, x - 66, y - 3, 60, FONT_SMALL_PLAIN);
        text_draw_number_centered(y_max / 2, x - 66, y + 96, 60, FONT_SMALL_PLAIN);
        text_draw_number_centered(0, x - 66, y + 196, 60, FONT_SMALL_PLAIN);
        // x axis
        int start_month, start_year, end_month, end_year;
        if (city_data.population.monthly.count > max_months) {
            end_month = time_data.month - 1;
            end_year = time_data.year;
            if (end_month < 0) {
                end_year -= 1;
            }
            start_month = 11 - (max_months % 12);
            start_year = end_year - max_months / 12;
        } else {
            start_month = 0;
            start_year = scenario.start_year;
            end_month = (max_months + start_month) % 12;
            end_year = (max_months + start_month) / 12 + start_year;
        }

        int width = text_draw(short_month_names[start_month], x - 20, y + 210, FONT_SMALL_PLAIN, COLOR_BLACK);
        text_draw_year(start_year, x + width - 20, y + 210, FONT_SMALL_PLAIN);
        width = text_draw(short_month_names[end_month], x + 380, y + 210, FONT_SMALL_PLAIN, COLOR_BLACK);
        text_draw_year(end_year, x + width + 380, y + 210, FONT_SMALL_PLAIN);
    }
    if (full_size) {
        graphics_set_clip_rectangle(0, 0, 640, y + 200);
        for (int m = 0; m < max_months; m++) {
            int pop = city_population_at_month(max_months, m);
            int val;
            if (y_shift == -1) {
                val = 2 * pop;
            } else {
                val = pop >> y_shift;
            }
            if (val > 0) {
                switch (max_months) {
                    case 20:
                        image_draw(945, x + 20 * m, y + 200 - val);
                        break;
                    case 40:
                        image_draw(946, x + 10 * m, y + 200 - val);
                        break;
                    case 100:
                        image_draw(947, x + 4 * m, y + 200 - val);
                        break;
                    case 200:
                        image_draw(948, x + 2 * m, y + 200 - val);
                        break;
                    default:
                        graphics_draw_vertical_line(x + m, y + 200 - val, y + 199, COLOR_RED);
                        break;
                }
            }
        }
        graphics_reset_clip_rectangle();
    } else {
        y_shift += 2;
        for (int m = 0; m < max_months; m++) {
            int val = city_population_at_month(max_months, m) >> y_shift;
            if (val > 0) {
                if (max_months == 20) {
                    graphics_fill_rect(x + m, y + 50 - val, 4, val + 1, COLOR_RED);
                } else {
                    graphics_draw_vertical_line(x + m, y + 50 - val, y + 50, COLOR_RED);
                }
            }
        }
    }
}

static void draw_census_graph(int full_size, int x, int y)
{
    int max_value = 0;
    for (int i = 0; i < 100; i++) {
        if (city_data.population.at_age[i] > max_value) {
            max_value = city_data.population.at_age[i];
        }
    }
    int y_max, y_shift;
    get_y_axis(max_value, &y_max, &y_shift);
    if (full_size) {
        // y axis
        text_draw_number_centered(y_max, x - 66, y - 3, 60, FONT_SMALL_PLAIN);
        text_draw_number_centered(y_max / 2, x - 66, y + 96, 60, FONT_SMALL_PLAIN);
        text_draw_number_centered(0, x - 66, y + 196, 60, FONT_SMALL_PLAIN);
        // x axis
        for (int i = 0; i <= 10; i++) {
            text_draw_number_centered(i * 10, x + 40 * i - 22, y + 210, 40, FONT_SMALL_PLAIN);
        }
    }
    if (full_size) {
        graphics_set_clip_rectangle(0, 0, 640, y + 200);
        for (int i = 0; i < 100; i++) {
            int val;
            if (y_shift == -1) {
                val = 2 * city_data.population.at_age[i];
            } else {
                val = city_data.population.at_age[i] >> y_shift;
            }
            if (val > 0) {
                image_draw(947, x + 4 * i, y + 200 - val);
            }
        }
        graphics_reset_clip_rectangle();
    } else {
        y_shift += 2;
        for (int i = 0; i < 100; i++) {
            int val = city_data.population.at_age[i] >> y_shift;
            if (val > 0) {
                graphics_draw_vertical_line(x + i, y + 50 - val, y + 50, COLOR_RED);
            }
        }
    }
}

static void draw_society_graph(int full_size, int x, int y)
{
    int max_value = 0;
    for (int i = 0; i < 20; i++) {
        if (city_data.population.at_level[i] > max_value) {
            max_value = city_data.population.at_level[i];
        }
    }
    int y_max, y_shift;
    get_y_axis(max_value, &y_max, &y_shift);
    if (full_size) {
        // y axis
        text_draw_number_centered(y_max, x - 66, y - 3, 60, FONT_SMALL_PLAIN);
        text_draw_number_centered(y_max / 2, x - 66, y + 96, 60, FONT_SMALL_PLAIN);
        text_draw_number_centered(0, x - 66, y + 196, 60, FONT_SMALL_PLAIN);
        // x axis
        text_draw_centered("Tent dwellers", x - 80, y + 210, 200, FONT_SMALL_PLAIN, COLOR_BLACK);
        text_draw_centered("Palace dwellers", x + 280, y + 210, 200, FONT_SMALL_PLAIN, COLOR_BLACK);
    }
    if (full_size) {
        graphics_set_clip_rectangle(0, 0, 640, y + 200);
        for (int i = 0; i < 20; i++) {
            int val;
            if (y_shift == -1) {
                val = 2 * city_data.population.at_level[i];
            } else {
                val = city_data.population.at_level[i] >> y_shift;
            }
            if (val > 0) {
                image_draw(945, x + 20 * i, y + 200 - val);
            }
        }
        graphics_reset_clip_rectangle();
    } else {
        y_shift += 2;
        for (int i = 0; i < 20; i++) {
            int val = city_data.population.at_level[i] >> y_shift;
            if (val > 0) {
                graphics_fill_rect(x + 5 * i, y + 50 - val, 4, val + 1, COLOR_RED);
            }
        }
    }
}

static int cap_input_at_100(int input)
{
    return input > 100 ? 100 : input;
}

static int get_people_aged_between(int min, int max)
{
    int pop = 0;
    for (int i = min; i < max; i++) {
        pop += city_data.population.at_age[i];
    }
    return pop;
}

static void city_culture_update_coverage(void)
{
    int population = city_data.population.population;
    // entertainment
    culture_coverage.theater = cap_input_at_100(calc_percentage(500 * count_data.buildings[BUILDING_THEATER].active, population));
    culture_coverage.amphitheater = cap_input_at_100(calc_percentage(800 * count_data.buildings[BUILDING_AMPHITHEATER].active, population));
    culture_coverage.colosseum = cap_input_at_100(calc_percentage(1500 * count_data.buildings[BUILDING_COLOSSEUM].active, population));
    if (!count_data.buildings[BUILDING_HIPPODROME].active) {
        culture_coverage.hippodrome = 0;
    } else {
        culture_coverage.hippodrome = 100;
    }
    // religion
    int oracles = count_data.buildings[BUILDING_ORACLE].total;
    culture_coverage.religion[GOD_CERES] = cap_input_at_100(calc_percentage(
        500 * oracles +
        750 * count_data.buildings[BUILDING_SMALL_TEMPLE_CERES].active +
        1500 * count_data.buildings[BUILDING_LARGE_TEMPLE_CERES].active,
        population));
    culture_coverage.religion[GOD_NEPTUNE] = cap_input_at_100(calc_percentage(
        500 * oracles +
        750 * count_data.buildings[BUILDING_SMALL_TEMPLE_NEPTUNE].active +
        1500 * count_data.buildings[BUILDING_LARGE_TEMPLE_NEPTUNE].active,
        population));
    culture_coverage.religion[GOD_MERCURY] = cap_input_at_100(calc_percentage(
        500 * oracles +
        750 * count_data.buildings[BUILDING_SMALL_TEMPLE_MERCURY].active +
        1500 * count_data.buildings[BUILDING_LARGE_TEMPLE_MERCURY].active,
        population));
    culture_coverage.religion[GOD_MARS] = cap_input_at_100(calc_percentage(
        500 * oracles +
        750 * count_data.buildings[BUILDING_SMALL_TEMPLE_MARS].active +
        1500 * count_data.buildings[BUILDING_LARGE_TEMPLE_MARS].active,
        population));
    culture_coverage.religion[GOD_VENUS] = cap_input_at_100(calc_percentage(
        500 * oracles +
        750 * count_data.buildings[BUILDING_SMALL_TEMPLE_VENUS].active +
        1500 * count_data.buildings[BUILDING_LARGE_TEMPLE_VENUS].active,
        population));
    culture_coverage.oracle = cap_input_at_100(calc_percentage(500 * oracles, population));
    city_data.culture.religion_coverage =
        culture_coverage.religion[GOD_CERES] +
        culture_coverage.religion[GOD_NEPTUNE] +
        culture_coverage.religion[GOD_MERCURY] +
        culture_coverage.religion[GOD_MARS] +
        culture_coverage.religion[GOD_VENUS];
    city_data.culture.religion_coverage /= 5;
    // education
    city_data.population.school_age = get_people_aged_between(0, 14);
    city_data.population.academy_age = get_people_aged_between(14, 21);
    culture_coverage.school = cap_input_at_100(calc_percentage(
        75 * count_data.buildings[BUILDING_SCHOOL].active, city_data.population.school_age));
    culture_coverage.library = cap_input_at_100(calc_percentage(
        800 * count_data.buildings[BUILDING_LIBRARY].active, population));
    culture_coverage.academy = cap_input_at_100(calc_percentage(
        100 * count_data.buildings[BUILDING_ACADEMY].active, city_data.population.academy_age));
    // health
    culture_coverage.hospital = cap_input_at_100(calc_percentage(
        1000 * count_data.buildings[BUILDING_HOSPITAL].active, population));
}

static void calculate_available_food(void)
{
    for (int i = 0; i < FOOD_TYPES_MAX; i++) {
        city_data.resource.granary_food_stored[i] = 0;
    }
    city_data.resource.granary_total_stored = 0;
    city_data.resource.food_types_available = 0;
    city_data.resource.food_supply_months = 0;
    city_data.resource.granaries.operating = 0;
    city_data.resource.granaries.understaffed = 0;
    city_data.resource.granaries.not_operating = 0;
    city_data.resource.granaries.not_operating_with_food = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_GRANARY) {
            continue;
        }
        b->has_road_access = 0;
        if (map_has_road_access_granary(b->x, b->y, 0)) {
            b->has_road_access = 1;
            int pct_workers = calc_percentage(
                b->num_workers, building_properties[b->type].n_laborers);
            if (pct_workers < 100) {
                city_data.resource.granaries.understaffed++;
            }
            int amount_stored = 0;
            for (int r = RESOURCE_WHEAT; r < FOOD_TYPES_MAX; r++) {
                amount_stored += b->data.granary.resource_stored[r];
            }
            if (pct_workers < 50) {
                city_data.resource.granaries.not_operating++;
                if (amount_stored > 0) {
                    city_data.resource.granaries.not_operating_with_food++;
                }
            } else {
                city_data.resource.granaries.operating++;
                for (int r = 0; r < FOOD_TYPES_MAX; r++) {
                    city_data.resource.granary_food_stored[r] += b->data.granary.resource_stored[r];
                }
            }
        }
    }
    for (int i = RESOURCE_WHEAT; i < FOOD_TYPES_MAX; i++) {
        if (city_data.resource.granary_food_stored[i]) {
            city_data.resource.granary_total_stored += city_data.resource.granary_food_stored[i];
            city_data.resource.food_types_available++;
        }
    }
    city_data.resource.food_needed_per_month =
        calc_adjust_with_percentage(city_data.population.population, 50);
    if (city_data.resource.food_needed_per_month > 0) {
        city_data.resource.food_supply_months =
            city_data.resource.granary_total_stored / city_data.resource.food_needed_per_month;
    } else {
        city_data.resource.food_supply_months =
            city_data.resource.granary_total_stored > 0 ? 1 : 0;
    }
    if (scenario.rome_supplies_wheat) {
        city_data.resource.food_types_available = 1;
        city_data.resource.food_supply_months = 12;
    }
}

static void city_resource_calculate_food_stocks_and_supply_wheat(void)
{
    calculate_available_food();
    if (scenario.rome_supplies_wheat) {
        for (int i = 1; i < MAX_BUILDINGS; i++) {
            struct building_t *b = &all_buildings[i];
            if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_MARKET) {
                b->data.market.inventory[INVENTORY_WHEAT] = 200;
            }
        }
    }
}

static void update_culture_explanation(void)
{
    int min_percentage = 100;
    int reason = 0;
    if (city_data.culture.religion_coverage && city_data.culture.religion_coverage < min_percentage) {
        min_percentage = city_data.culture.religion_coverage;
        reason = 4;
    }
    if (culture_coverage.theater && culture_coverage.theater < min_percentage) {
        min_percentage = culture_coverage.theater;
        reason = 5;
    }
    if (culture_coverage.library && culture_coverage.library < min_percentage) {
        min_percentage = culture_coverage.library;
        reason = 2;
    }
    if (culture_coverage.school && culture_coverage.school < min_percentage) {
        min_percentage = culture_coverage.school;
        reason = 1;
    }
    if (culture_coverage.academy &&culture_coverage.academy < min_percentage) {
        reason = 3;
    }
    city_data.ratings.culture_explanation = reason;
}

static int has_made_money(void)
{
    return city_data.finance.last_year.expenses.construction + city_data.finance.treasury >
        city_data.ratings.prosperity_treasury_last_year;
}

static void update_prosperity_explanation(void)
{
    int change = 0;
    int profit = 0;
    // unemployment: -1 for too high, +1 for low
    if (city_data.labor.unemployment_percentage < 5) {
        change += 1;
    } else if (city_data.labor.unemployment_percentage >= 15) {
        change -= 1;
    }
    // losing/earning money: -1 for losing, +5 for profit
    if (has_made_money()) {
        change += 5;
        profit = 1;
    } else {
        change -= 1;
    }
    // food types: +1 for multiple foods
    if (city_data.resource.food_types_eaten >= 2) {
        change += 1;
    }
    // wages: +1 for wages 2+ above Rome, -1 for wages below Rome
    int avg_wage = city_data.finance.wage_rate_paid_last_year / 12;
    if (avg_wage >= city_data.labor.wages_rome + 2) {
        change += 1;
    } else if (avg_wage < city_data.labor.wages_rome) {
        change -= 1;
    }
    // high percentage poor: -1, high percentage rich: +1
    int pct_tents = calc_percentage(city_data.population.people_in_tents_shacks, city_data.population.population);
    if (pct_tents > 30) {
        change -= 1;
    }
    if (calc_percentage(city_data.population.people_in_villas_palaces, city_data.population.population) > 10) {
        change += 1;
    }
    // tribute not paid: -1
    if (city_data.finance.tribute_not_paid_last_year) {
        change -= 1;
    }
    // working hippodrome: +1
    if (city_data.entertainment.hippodrome_shows > 0) {
        change += 1;
    }
    int reason;
    if (city_data.ratings.prosperity <= 0 && time_data.year == scenario.start_year) {
        reason = 0;
    } else if (city_data.ratings.prosperity >= city_data.ratings.prosperity_max) {
        reason = 1;
    } else if (change > 0) {
        reason = 2;
    } else if (!profit) {
        reason = 3;
    } else if (city_data.labor.unemployment_percentage >= 15) {
        reason = 4;
    } else if (avg_wage < city_data.labor.wages_rome) {
        reason = 5;
    } else if (pct_tents > 30) {
        reason = 6;
    } else if (city_data.finance.tribute_not_paid_last_year) {
        reason = 7;
    } else {
        reason = 9;
    }
    // 8 = for bailout
    city_data.ratings.prosperity_explanation = reason;
}

static void update_peace_explanation(void)
{
    int reason;
    if (city_data.figure.imperial_soldiers) {
        reason = 8; // FIXED: 7+8 interchanged
    } else if (city_data.figure.enemies) {
        reason = 7;
    } else if (city_data.figure.rioters) {
        reason = 6;
    } else {
        if (city_data.ratings.peace < 10) {
            reason = 0;
        } else if (city_data.ratings.peace < 30) {
            reason = 1;
        } else if (city_data.ratings.peace < 60) {
            reason = 2;
        } else if (city_data.ratings.peace < 90) {
            reason = 3;
        } else if (city_data.ratings.peace < 100) {
            reason = 4;
        } else { // >= 100
            reason = 5;
        }
    }
    city_data.ratings.peace_explanation = reason;
}

static void window_advisors_show(int advisor)
{
    city_labor_allocate_workers();
    city_finance_estimate_taxes();
    city_finance_estimate_wages();
    city_data.finance.this_year.expenses.interest = city_data.finance.interest_so_far;
    city_data.finance.this_year.expenses.salary = city_data.finance.salary_so_far;
    city_finance_calculate_totals();
    switch (city_data.sentiment.low_mood_cause) {
        case LOW_MOOD_CAUSE_NO_FOOD:
            city_data.migration.no_immigration_cause = 2;
            break;
        case LOW_MOOD_CAUSE_NO_JOBS:
            city_data.migration.no_immigration_cause = 1;
            break;
        case LOW_MOOD_CAUSE_HIGH_TAXES:
            city_data.migration.no_immigration_cause = 3;
            break;
        case LOW_MOOD_CAUSE_LOW_WAGES:
            city_data.migration.no_immigration_cause = 0;
            break;
        case LOW_MOOD_CAUSE_MANY_TENTS:
            city_data.migration.no_immigration_cause = 4;
            break;
        default:
            city_data.migration.no_immigration_cause = 5;
            break;
    }
    // health
    city_data.houses.health = 0;
    int max = 0;
    if (city_data.houses.missing.bathhouse > max) {
        city_data.houses.health = 1;
        max = city_data.houses.missing.bathhouse;
    }
    if (city_data.houses.missing.barber > max) {
        city_data.houses.health = 2;
        max = city_data.houses.missing.barber;
    }
    if (city_data.houses.missing.clinic > max) {
        city_data.houses.health = 3;
        max = city_data.houses.missing.clinic;
    }
    if (city_data.houses.missing.hospital > max) {
        city_data.houses.health = 4;
    }
    // education
    city_data.houses.education = 0;
    if (city_data.houses.missing.more_education > city_data.houses.missing.education) {
        city_data.houses.education = 1; // schools(academies?)
    } else if (city_data.houses.missing.more_education < city_data.houses.missing.education) {
        city_data.houses.education = 2; // libraries
    } else if (city_data.houses.missing.more_education || city_data.houses.missing.education) {
        city_data.houses.education = 3; // more education
    }
    // entertainment
    city_data.houses.entertainment = 0;
    if (city_data.houses.missing.entertainment > city_data.houses.missing.more_entertainment) {
        city_data.houses.entertainment = 1;
    } else if (city_data.houses.missing.more_entertainment) {
        city_data.houses.entertainment = 2;
    }
    // religion
    city_data.houses.religion = 0;
    max = 0;
    if (city_data.houses.missing.religion > max) {
        city_data.houses.religion = 1;
        max = city_data.houses.missing.religion;
    }
    if (city_data.houses.missing.second_religion > max) {
        city_data.houses.religion = 2;
        max = city_data.houses.missing.second_religion;
    }
    if (city_data.houses.missing.third_religion > max) {
        city_data.houses.religion = 3;
    }
    city_culture_update_coverage();
    city_resource_calculate_food_stocks_and_supply_wheat();
    update_culture_explanation();
    update_prosperity_explanation();
    update_peace_explanation();
    city_ratings_update_favor_explanation();
    change_window(WINDOW_ADVISOR_LABOR + advisor);
}

static void button_go_to_problem_message_dialog(__attribute__((unused)) int param1, __attribute__((unused)) int param2)
{
    cleanup_message_dialog();
    int grid_offset = player_message.param2;
    if (grid_offset > 0 && grid_offset < 26244) {
        city_view_go_to_grid_offset(grid_offset);
    }
    show_city_window();
}

static struct image_button_t image_button_go_to_problem = {
    0, 0, 27, 27, IB_NORMAL, 92, 52, button_go_to_problem_message_dialog, button_none, 1, 0, 1, 0, 0, 0
};

static int is_problem_message(struct lang_message_t *msg)
{
    return msg->type == TYPE_MESSAGE && (msg->message_type == MESSAGE_TYPE_DISASTER || msg->message_type == MESSAGE_TYPE_INVASION);
}

static void draw_foreground_video(void)
{
    if (get_next_frame()) {
        struct clip_info_t *clip = graphics_get_clip_info(message_dialog_data.x + 8, message_dialog_data.y + 8, data_video.video.width, data_video.video.height);
        if (clip && clip->is_visible) {
            unsigned char *frame = data_video.s->frame_data.video;
            uint32_t *pal = data_video.s->frame_data.palette;
            if (frame && pal) {
                for (int y = clip->clipped_pixels_top; y < clip->visible_pixels_y; y++) {
                    uint32_t *pixel = graphics_get_pixel(
                        message_dialog_data.x + 8 + clip->clipped_pixels_left, y + message_dialog_data.y + 8 + clip->clipped_pixels_top);
                    int video_y = data_video.video.y_scale == SMACKER_Y_SCALE_NONE ? y : y / 2;
                    unsigned char *line = frame + (video_y * data_video.video.width);
                    for (int x = clip->clipped_pixels_left; x < clip->visible_pixels_x; x++) {
                        *pixel = pal[line[x]];
                        ++pixel;
                    }
                }
            }
        }
    }
    struct lang_message_t *msg = &lang_data.message_entries[message_dialog_data.text_id];
    if (is_problem_message(msg)) {
        // image_buttons_draw(message_dialog_data.x + 48, message_dialog_data.y + 407, &image_button_go_to_problem, 1);
    }
}

static int resource_image(int resource)
{
    return resource_images[resource].icon_img_id + resource_image_offset(resource, RESOURCE_IMAGE_ICON);
}

static void custom_music_callback(__attribute__((unused)) void *dummy, Uint8 *stream, int len)
{
    // Write silence
    memset(stream, 0, len);
    if (len <= 0 || custom_music.stream == 0) {
        return;
    }
    int bytes_copied = 0;
    // Mix audio to sound effect volume
    Uint8 *mix_buffer = (Uint8 *) malloc(len);
    if (!mix_buffer) {
        return;
    }
    memset(mix_buffer, 0, len);
    bytes_copied = SDL_AudioStreamGet(custom_music.stream, mix_buffer, len);
    if (bytes_copied <= 0) {
        return;
    }
    SDL_MixAudioFormat(stream, mix_buffer,
        custom_music.dst_format, bytes_copied,
        settings[SETTINGS_SOUND_EFFECTS_VOLUME].config_value * SDL_MIX_MAXVOLUME / 100);
    free(mix_buffer);
}

static void video_init(int restart_music)
{
    data_video.video.start_render_millis = SDL_GetTicks64();
    data_video.restart_music = restart_music;
    if (data_video.audio.has_audio) {
        int audio_len = data_video.s->frame_data.audio_len[0];
        if (audio_len > 0) {
            SDL_AudioFormat format;
            if (data_video.audio.bitdepth == 8) {
                format = AUDIO_U8;
            } else if (data_video.audio.bitdepth == 16) {
                format = AUDIO_S16SYS;
            } else {
                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("Custom music bitdepth not supported:", 0, data_video.audio.bitdepth));
                return;
            }
            int device_rate;
            Uint16 device_format;
            int device_channels;
            Mix_QuerySpec(&device_rate, &device_format, &device_channels);
            free_custom_audio_stream();
            custom_music.dst_format = device_format;
            custom_music.stream = SDL_NewAudioStream(
                format, data_video.audio.channels, data_video.audio.rate,
                device_format, device_channels, device_rate
            );
            if (!custom_music.stream) {
                return;
            }
            write_custom_music_data(data_video.s->frame_data.audio[0], audio_len);
            Mix_HookMusic(custom_music_callback, 0);
        }
    }
}

static void smacker_get_audio_info(smacker s, int track, int *enabled, int *channels, int *bitdepth, int *audio_rate)
{
    int has_track = (s->audio_rate[track] & AUDIO_FLAG_HAS_TRACK) ? 1 : 0;
    if (enabled) {
        *enabled = has_track;
    }
    if (channels) {
        if (has_track) {
            *channels = (s->audio_rate[track] & AUDIO_FLAG_STEREO) ? 2 : 1;
        } else {
            *channels = 0;
        }
    }
    if (bitdepth) {
        if (has_track) {
            *bitdepth = (s->audio_rate[track] & AUDIO_FLAG_16BIT) ? 16 : 8;
        } else {
            *bitdepth = 0;
        }
    }
    if (audio_rate) {
        *audio_rate = s->audio_rate[track] & AUDIO_MASK_RATE;
    }
}

static void smacker_get_video_info(smacker s, int *width, int *height, int *y_scale_mode)
{
    if (width) {
        *width = s->width;
    }
    if (height) {
        *height = s->height;
    }
    if (y_scale_mode) {
        if (s->flags & FLAG_Y_INTERLACE) {
            *y_scale_mode = SMACKER_Y_SCALE_INTERLACE;
        } else if (s->flags & FLAG_Y_DOUBLE) {
            *y_scale_mode = SMACKER_Y_SCALE_DOUBLE;
        } else {
            *y_scale_mode = SMACKER_Y_SCALE_NONE;
        }
    }
}

static struct huffnode16_t *build_tree16_nodes(struct bitstream_t *bs, struct hufftree16_t *tree)
{
    struct huffnode16_t *node = (struct huffnode16_t *) clear_malloc(sizeof(struct huffnode16_t));
    if (!node) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: no memory for 16-bit tree node", 0, 0));
        return 0;
    }
    if (read_bit(bs)) {
        node->is_leaf = 0;
        node->b[0] = build_tree16_nodes(bs, tree);
        if (!node->b[0]) {
            free(node);
            return 0;
        }
        node->b[1] = build_tree16_nodes(bs, tree);
        if (!node->b[1]) {
            free_node16(node->b[0]);
            free(node);
            return 0;
        }
    } else {
        node->is_leaf = 1;
        uint8_t lo_val = lookup_tree8(bs, tree->low);
        uint8_t hi_val = lookup_tree8(bs, tree->high);
        uint16_t leaf_value = lo_val | (hi_val << 8);
        node->value = leaf_value;

        for (int i = 0; i < 3; i++) {
            if (leaf_value == tree->escape_codes[i]) {
                tree->escape_nodes[i] = node;
            }
        }
    }
    return node;
}

static struct hufftree16_t *create_tree16(struct bitstream_t *bs, struct hufftree8_t *low, struct hufftree8_t *high)
{
    struct hufftree16_t *tree = (struct hufftree16_t *) clear_malloc(sizeof(struct hufftree16_t));
    if (!tree) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: no memory for 16-bit tree", 0, 0));
        return 0;
    }
    tree->low = low;
    tree->high = high;
    for (int i = 0; i < 3; i++) {
        // Do not join the following two lines as it results in an optimization bug for MSVC. See PR #215
        tree->escape_codes[i] = read_byte(bs);
        tree->escape_codes[i] |= read_byte(bs) << 8;
    }
    tree->root = build_tree16_nodes(bs, tree);
    if (!tree->root) {
        free(tree);
        return 0;
    }
    if (read_bit(bs) != 0) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: 16-bit tree not closed", 0, 0));
        free_tree16(tree);
        return 0;
    }
    for (int i = 0; i < 3; i++) {
        if (!tree->escape_nodes[i]) {
            // Escape node is not in the tree: create a dummy node
            tree->escape_nodes[i] = (struct huffnode16_t *) clear_malloc(sizeof(struct huffnode16_t));
            tree->escape_nodes[i]->is_leaf = 0;
            tree->escape_nodes[i]->value = 0;
        }
    }
    return tree;
}

static struct hufftree16_t *read_header_tree(struct bitstream_t *bs)
{
    if (read_bit(bs)) {
        struct hufftree8_t *low = create_tree8(bs);
        struct hufftree8_t *high = create_tree8(bs);
        if (!low || !high) {
            free(low);
            free(high);
            return 0;
        }
        return create_tree16(bs, low, high);
    } else {
        return 0;
    }
}

static void read_header_trees(smacker s, uint8_t *data)
{
    struct bitstream_t bstream;
    struct bitstream_t *bs = bitstream_init(&bstream, data, s->trees_size);

    s->mmap_tree = read_header_tree(bs);
    s->mclr_tree = read_header_tree(bs);
    s->full_tree = read_header_tree(bs);
    s->type_tree = read_header_tree(bs);
}

static int read_header_smacker(smacker s)
{
    uint8_t header[HEADER_SIZE_SMACKER];
    if (fread(header, 1, HEADER_SIZE_SMACKER, fp) != HEADER_SIZE_SMACKER) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: unable to read header", 0, 0));
        return 0;
    }
    // check signature
    if (header[0] != 'S' || header[1] != 'M' || header[2] != 'K' || header[3] != '2') {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: file is not an SMK2 video", 0, 0));
        return 0;
    }
    s->width = read_i32(&header[4]);
    s->height = read_i32(&header[8]);
    s->frames = read_i32(&header[12]);
    int32_t frame_rate = read_i32(&header[16]);
    if (frame_rate > 0) {
        // frame rate is given in ms
        s->us_per_frame = frame_rate * 1000;
    } else if (frame_rate < 0) {
        // frame rate is given in 10us
        s->us_per_frame = -10 * frame_rate;
    } else {
        // 10 FPS = 0.1 sec per frame = 100,000 microseconds
        s->us_per_frame = 100000;
    }
    s->flags = read_i32(&header[20]);
    for (int i = 0; i < MAX_TRACKS; i++) {
        s->audio_size[i] = read_i32(&header[24 + 4 * i]);
    }
    s->trees_size = read_i32(&header[52]);
    // 56 - 72: skip mmap_size, mclr_size, full_size, type_size
    for (int i = 0; i < MAX_TRACKS; i++) {
        s->audio_rate[i] = read_i32(&header[72 + 4 * i]);
    }
    return 1;
}

static int read_frame_info(smacker s)
{
    int sizes_length = sizeof(int32_t) * s->frames;
    int types_length = sizeof(uint8_t) * s->frames;

    s->frame_sizes = (int32_t *) clear_malloc(sizes_length);
    s->frame_offsets = (long *) clear_malloc(sizeof(long) * s->frames);
    s->frame_types = (uint8_t *) clear_malloc(types_length);

    if (!s->frame_sizes || !s->frame_offsets || !s->frame_types) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: no memory for frame info", 0, 0));
        free(s->frame_sizes);
        free(s->frame_offsets);
        free(s->frame_types);
        return 0;
    }

    if (fread(s->frame_sizes, 1, sizes_length, fp) != (unsigned) sizes_length ||
        fread(s->frame_types, 1, types_length, fp) != (unsigned) types_length) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: unable to read frame info from file", 0, 0));
        free(s->frame_sizes);
        free(s->frame_offsets);
        free(s->frame_types);
        return 0;
    }

    uint8_t *data = (uint8_t *) s->frame_sizes;
    long offset = 0;
    for (int i = 0; i < s->frames; i++) {
        // Clear first two flag bits in-place (and flip endian-ness if necessary)
        s->frame_sizes[i] = read_i32(&data[4 * i]) & 0xfffffffc;
        s->frame_offsets[i] = offset;
        offset += s->frame_sizes[i];
    }
    return 1;
}

static int read_trees_data(smacker s)
{
    uint8_t *trees_data = (uint8_t *) clear_malloc(s->trees_size);
    if (!trees_data) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: no memory for tree input data", 0, 0));
        return 0;
    }
    if (fread(trees_data, 1, s->trees_size, fp) != (unsigned) s->trees_size) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: unable to read tree data from file", 0, 0));
        free(trees_data);
        return 0;
    }
    read_header_trees(s, trees_data);
    free(trees_data);
    return 1;
}

static int allocate_frame_memory(smacker s)
{
    s->frame_data.video = clear_malloc(sizeof(uint8_t) * s->width * s->height);
    if (!s->frame_data.video) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: no memory for video frame", 0, 0));
        return 0;
    }
    for (int i = 0; i < MAX_TRACKS; i++) {
        if (s->audio_rate[i] & AUDIO_FLAG_HAS_TRACK) {
            s->frame_data.audio[i] = clear_malloc(s->audio_size[i]);
            if (!s->frame_data.audio[i]) {
                SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: no memory for audio track", 0, i));
                return 0;
            }
        }
    }
    return 1;
}

static smacker smacker_open(void)
{
    if (!fp) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "%s", build_message("SMK: file does not exist", 0, 0));
        return 0;
    }
    smacker s = (struct smacker_t *) clear_malloc(sizeof(struct smacker_t));
    memset(s, 0, sizeof(struct smacker_t));
    fp = fp;

    if (!read_header_smacker(s)) {
        smacker_close(s);
        return 0;
    }
    if (!read_frame_info(s)) {
        smacker_close(s);
        return 0;
    }
    if (!read_trees_data(s)) {
        smacker_close(s);
        return 0;
    }
    if (!allocate_frame_memory(s)) {
        smacker_close(s);
        return 0;
    }
    s->frame_data_offset_in_file = ftell(fp);
    return s;
}

static int video_start(char *filename)
{
    data_video.is_playing = 0;
    data_video.is_ended = 0;

    fp = fopen(filename, "rb");
    data_video.s = smacker_open();
    if (!data_video.s) {
        // smacker_open() closes the stream on error: no need to close fp
        return 0;
    }
    int width, height, y_scale;
    int micros_per_frame = data_video.s->us_per_frame;
    smacker_get_video_info(data_video.s, &width, &height, &y_scale);
    data_video.video.width = width;
    data_video.video.height = y_scale == SMACKER_Y_SCALE_NONE ? height : height * 2;
    data_video.video.y_scale = y_scale;
    data_video.video.current_frame = 0;
    data_video.video.micros_per_frame = micros_per_frame;

    data_video.audio.has_audio = 0;
    if (settings[SETTINGS_SOUND_EFFECTS_ENABLED].config_value) {
        int has_track, channels, bitdepth, rate;
        smacker_get_audio_info(data_video.s, 0, &has_track, &channels, &bitdepth, &rate);
        if (has_track) {
            data_video.audio.has_audio = 1;
            data_video.audio.bitdepth = bitdepth;
            data_video.audio.channels = channels;
            data_video.audio.rate = rate;
        }
    }
    data_video.s->current_frame = 0;
    if (decode_frame(data_video.s) != SMACKER_FRAME_OK) {
        close_smk();
        return 0;
    }
    stop_music();
    stop_sound_channel(SOUND_CHANNEL_SPEECH);
    data_video.is_playing = 1;
    return 1;
}

static void window_message_dialog_show(int text_id, void (*background_callback)(void))
{
    // scroll_drag_end();
    for (int i = 0; i < MAX_HISTORY; i++) {
        message_dialog_data.history[i].text_id = 0;
        message_dialog_data.history[i].scroll_position = 0;
    }
    // rich_text_reset(0);
    message_dialog_data.text_id = text_id;
    message_dialog_data.background_callback = background_callback;
    struct lang_message_t *msg = &lang_data.message_entries[text_id];
    if (player_message.use_popup != 1) {
        message_dialog_data.show_video = 0;
    } else if (msg->video.text && video_start(msg->video.text)) {
        message_dialog_data.show_video = 1;
    } else {
        message_dialog_data.show_video = 0;
    }
    if (message_dialog_data.show_video) {
        video_init(1);
    }
    change_window(WINDOW_MESSAGE_DIALOG);
}

static void window_message_dialog_show_city_message(int text_id, int year, int month, int param1, int param2, int message_advisor, int use_popup)
{
    player_message.year = year;
    player_message.month = month;
    player_message.param1 = param1;
    player_message.param2 = param2;
    player_message.message_advisor = message_advisor;
    player_message.use_popup = use_popup;
    window_message_dialog_show(text_id, window_city_draw_all);
}

static int city_message_get_advisor(int message_type)
{
    switch (message_type) {
        case MESSAGE_LOCAL_UPRISING:
        case MESSAGE_BARBARIAN_ATTACK:
        case MESSAGE_CAESAR_ARMY_ATTACK:
        case MESSAGE_CAESAR_ARMY_CONTINUE:
        case MESSAGE_CAESAR_ARMY_RETREAT:
        case MESSAGE_ENEMY_ARMY_ATTACK:
        case MESSAGE_DISTANT_BATTLE:
        case MESSAGE_ENEMIES_CLOSING:
        case MESSAGE_ENEMIES_AT_THE_DOOR:
        case MESSAGE_TROOPS_RETURN_VICTORIOUS:
        case MESSAGE_TROOPS_RETURN_FAILED:
        case MESSAGE_DISTANT_BATTLE_LOST_NO_TROOPS:
        case MESSAGE_DISTANT_BATTLE_LOST_TOO_LATE:
        case MESSAGE_DISTANT_BATTLE_LOST_TOO_WEAK:
        case MESSAGE_DISTANT_BATTLE_CITY_RETAKEN:
        case MESSAGE_SPIRIT_OF_MARS:
        case MESSAGE_GLADIATOR_REVOLT:
        case MESSAGE_GLADIATOR_REVOLT_FINISHED:
            return MESSAGE_ADVISOR_MILITARY;
        case MESSAGE_CAESAR_REQUESTS_GOODS:
        case MESSAGE_CAESAR_REQUESTS_MONEY:
        case MESSAGE_CAESAR_REQUESTS_ARMY:
        case MESSAGE_REQUEST_REMINDER:
        case MESSAGE_REQUEST_RECEIVED:
        case MESSAGE_REQUEST_REFUSED:
        case MESSAGE_REQUEST_REFUSED_OVERDUE:
        case MESSAGE_REQUEST_RECEIVED_LATE:
        case MESSAGE_REQUEST_CAN_COMPLY:
        case MESSAGE_CAESAR_WRATH:
        case MESSAGE_CAESAR_RESPECT_1:
        case MESSAGE_CAESAR_RESPECT_2:
        case MESSAGE_CAESAR_RESPECT_3:
            return MESSAGE_ADVISOR_IMPERIAL;
        case MESSAGE_UNEMPLOYMENT:
        case MESSAGE_WORKERS_NEEDED:
        case MESSAGE_ROME_LOWERS_WAGES:
        case MESSAGE_ROME_RAISES_WAGES:
            return MESSAGE_ADVISOR_LABOR;
        case MESSAGE_NOT_ENOUGH_FOOD:
        case MESSAGE_FOOD_NOT_DELIVERED:
        case MESSAGE_POPULATION_500:
        case MESSAGE_POPULATION_1000:
        case MESSAGE_POPULATION_2000:
        case MESSAGE_POPULATION_3000:
        case MESSAGE_POPULATION_5000:
        case MESSAGE_POPULATION_10000:
        case MESSAGE_POPULATION_15000:
        case MESSAGE_POPULATION_20000:
        case MESSAGE_POPULATION_25000:
            return MESSAGE_ADVISOR_POPULATION;
        case MESSAGE_HEALTH_ILLNESS:
        case MESSAGE_HEALTH_DISEASE:
        case MESSAGE_HEALTH_PESTILENCE:
        case MESSAGE_CONTAMINATED_WATER:
            return MESSAGE_ADVISOR_HEALTH;
        case MESSAGE_GODS_UNHAPPY:
        case MESSAGE_GODS_WRATHFUL:
        case MESSAGE_GRAND_FESTIVAL:
        case MESSAGE_LARGE_FESTIVAL:
        case MESSAGE_SMALL_FESTIVAL:
        case MESSAGE_BLESSING_FROM_CERES:
        case MESSAGE_BLESSING_FROM_MARS:
        case MESSAGE_BLESSING_FROM_MERCURY:
        case MESSAGE_BLESSING_FROM_NEPTUNE:
        case MESSAGE_BLESSING_FROM_VENUS:
        case MESSAGE_CERES_IS_UPSET:
        case MESSAGE_MARS_IS_UPSET:
        case MESSAGE_MERCURY_IS_UPSET:
        case MESSAGE_NEPTUNE_IS_UPSET:
        case MESSAGE_VENUS_IS_UPSET:
        case MESSAGE_WRATH_OF_CERES:
        case MESSAGE_WRATH_OF_MARS:
        case MESSAGE_WRATH_OF_MARS_NO_MILITARY:
        case MESSAGE_WRATH_OF_MERCURY:
        case MESSAGE_WRATH_OF_NEPTUNE:
        case MESSAGE_WRATH_OF_NEPTUNE_NO_SEA_TRADE:
        case MESSAGE_WRATH_OF_VENUS:
        case MESSAGE_LOCAL_UPRISING_MARS:
            return MESSAGE_ADVISOR_RELIGION;
        case MESSAGE_INCREASED_TRADING:
        case MESSAGE_DECREASED_TRADING:
        case MESSAGE_PRICE_DECREASED:
        case MESSAGE_PRICE_INCREASED:
        case MESSAGE_TRADE_STOPPED:
        case MESSAGE_LAND_TRADE_DISRUPTED_LANDSLIDES:
        case MESSAGE_LAND_TRADE_DISRUPTED_SANDSTORMS:
        case MESSAGE_SEA_TRADE_DISRUPTED:
            return MESSAGE_ADVISOR_TRADE;
        default:
            return MESSAGE_ADVISOR_NONE;
    }
}

static void show_message_popup(int message_id)
{
    message_data.consecutive_message_delay = 5;
    message_data.messages[message_id].is_read = 1;
    int text_id = city_message_get_text_id(message_data.messages[message_id].message_type);
    struct lang_message_t *msg = &lang_data.message_entries[text_id];
    if (!msg->video.text || !file_exists(0, msg->video.text)) { // does not have video
        play_sound(text_id);
    }
    window_message_dialog_show_city_message(text_id,
        message_data.messages[message_id].year, message_data.messages[message_id].month, message_data.messages[message_id].param1, message_data.messages[message_id].param2,
        city_message_get_advisor(message_data.messages[message_id].message_type), 1);
}

static void city_message_apply_sound_interval(int category)
{
    if (current_time - message_data.last_sound_time[category] <= 15000) {
        should_play_sound = 0;
    } else {
        message_data.last_sound_time[category] = current_time;
    }
}

static int figure_service_provide_coverage(struct figure_t *f)
{
    int houses_serviced = 0;
    int x = f->x;
    int y = f->y;
    struct building_t *b;
    switch (f->type) {
        case FIGURE_PATRICIAN:
            return 0;
        case FIGURE_LABOR_SEEKER:
            houses_serviced = provide_culture(x, y, labor_seeker_coverage);
            break;
        case FIGURE_TAX_COLLECTOR:
        {
            int max_tax_rate = 0;
            houses_serviced = provide_service(x, y, &max_tax_rate, tax_collector_coverage);
            f->min_max_seen = max_tax_rate;
            break;
        }
        case FIGURE_MARKET_TRADER:
        case FIGURE_MARKET_BUYER:
        {
            int serviced = 0;
            struct building_t *market = &all_buildings[f->building_id];
            int x_min, y_min, x_max, y_max;
            map_grid_get_area(x, y, 1, 2, &x_min, &y_min, &x_max, &y_max);
            for (int yy = y_min; yy <= y_max; yy++) {
                for (int xx = x_min; xx <= x_max; xx++) {
                    int grid_offset = map_grid_offset(xx, yy);
                    int building_id = map_building_at(grid_offset);
                    if (building_id) {
                        b = &all_buildings[building_id];
                        if (b->house_size && b->house_population > 0) {
                            int level = b->subtype.house_level;
                            if (level < HOUSE_LUXURY_PALACE) {
                                level++;
                            }
                            int max_food_stocks = 4 * b->house_highest_population;
                            int food_types_stored_max = 0;
                            for (int i = INVENTORY_WHEAT; i <= INVENTORY_MEAT; i++) {
                                if (b->data.house.inventory[i] >= max_food_stocks) {
                                    food_types_stored_max++;
                                }
                            }
                            if (house_properties[level].food_types > food_types_stored_max) {
                                for (int i = INVENTORY_WHEAT; i <= INVENTORY_MEAT; i++) {
                                    if (b->data.house.inventory[i] >= max_food_stocks) {
                                        continue;
                                    }
                                    if (market->data.market.inventory[i] >= max_food_stocks) {
                                        b->data.house.inventory[i] += max_food_stocks;
                                        market->data.market.inventory[i] -= max_food_stocks;
                                        break;
                                    } else if (market->data.market.inventory[i]) {
                                        b->data.house.inventory[i] += market->data.market.inventory[i];
                                        market->data.market.inventory[i] = 0;
                                        break;
                                    }
                                }
                            }
                            if (house_properties[level].pottery) {
                                market->data.market.pottery_demand = 10;
                                distribute_good(b, market, 8 * house_properties[level].pottery, INVENTORY_POTTERY);
                            }
                            if (house_properties[level].furniture) {
                                market->data.market.furniture_demand = 10;
                                distribute_good(b, market, 4 * house_properties[level].furniture, INVENTORY_FURNITURE);
                            }
                            if (house_properties[level].oil) {
                                market->data.market.oil_demand = 10;
                                distribute_good(b, market, 4 * house_properties[level].oil, INVENTORY_OIL);
                            }
                            if (house_properties[level].wine) {
                                market->data.market.wine_demand = 10;
                                distribute_good(b, market, 4 * house_properties[level].wine, INVENTORY_WINE);
                            }
                            serviced++;
                        }
                    }
                }
            }
            houses_serviced = serviced;
            break;
        }
        case FIGURE_BATHHOUSE_WORKER:
            houses_serviced = provide_culture(x, y, bathhouse_coverage);
            break;
        case FIGURE_SCHOOL_CHILD:
            houses_serviced = provide_culture(x, y, school_coverage);
            break;
        case FIGURE_TEACHER:
            houses_serviced = provide_culture(x, y, academy_coverage);
            break;
        case FIGURE_LIBRARIAN:
            houses_serviced = provide_culture(x, y, library_coverage);
            break;
        case FIGURE_BARBER:
            houses_serviced = provide_culture(x, y, barber_coverage);
            break;
        case FIGURE_DOCTOR:
            houses_serviced = provide_culture(x, y, clinic_coverage);
            break;
        case FIGURE_SURGEON:
            houses_serviced = provide_culture(x, y, hospital_coverage);
            break;
        case FIGURE_MISSIONARY:
        {
            int x_min, y_min, x_max, y_max;
            map_grid_get_area(x, y, 1, 4, &x_min, &y_min, &x_max, &y_max);
            for (int yy = y_min; yy <= y_max; yy++) {
                for (int xx = x_min; xx <= x_max; xx++) {
                    int building_id = map_building_at(map_grid_offset(xx, yy));
                    if (building_id) {
                        b = &all_buildings[building_id];
                        if (b->type == BUILDING_NATIVE_HUT || b->type == BUILDING_NATIVE_MEETING) {
                            b->sentiment.native_anger = 0;
                        }
                    }
                }
            }
            houses_serviced = 1;
            break;
        }
        case FIGURE_PRIEST:
            switch (all_buildings[f->building_id].type) {
                case BUILDING_SMALL_TEMPLE_CERES:
                case BUILDING_LARGE_TEMPLE_CERES:
                    houses_serviced = provide_culture(x, y, religion_coverage_ceres);
                    break;
                case BUILDING_SMALL_TEMPLE_NEPTUNE:
                case BUILDING_LARGE_TEMPLE_NEPTUNE:
                    houses_serviced = provide_culture(x, y, religion_coverage_neptune);
                    break;
                case BUILDING_SMALL_TEMPLE_MERCURY:
                case BUILDING_LARGE_TEMPLE_MERCURY:
                    houses_serviced = provide_culture(x, y, religion_coverage_mercury);
                    break;
                case BUILDING_SMALL_TEMPLE_MARS:
                case BUILDING_LARGE_TEMPLE_MARS:
                    houses_serviced = provide_culture(x, y, religion_coverage_mars);
                    break;
                case BUILDING_SMALL_TEMPLE_VENUS:
                case BUILDING_LARGE_TEMPLE_VENUS:
                    houses_serviced = provide_culture(x, y, religion_coverage_venus);
                    break;
                default:
                    break;
            }
            break;
        case FIGURE_ACTOR:
            b = get_entertainment_building(f);
            if (b->type == BUILDING_THEATER) {
                houses_serviced = provide_culture(x, y, theater_coverage);
            } else if (b->type == BUILDING_AMPHITHEATER) {
                houses_serviced = provide_entertainment(x, y,
                    b->data.entertainment.days1 ? 2 : 1, amphitheater_coverage);
            }
            break;
        case FIGURE_GLADIATOR:
            b = get_entertainment_building(f);
            if (b->type == BUILDING_AMPHITHEATER) {
                houses_serviced = provide_entertainment(x, y,
                    b->data.entertainment.days2 ? 2 : 1, amphitheater_coverage);
            } else if (b->type == BUILDING_COLOSSEUM) {
                houses_serviced = provide_entertainment(x, y,
                    b->data.entertainment.days1 ? 2 : 1, colosseum_coverage);
            }
            break;
        case FIGURE_LION_TAMER:
            b = get_entertainment_building(f);
            houses_serviced = provide_entertainment(x, y,
                b->data.entertainment.days2 ? 2 : 1, colosseum_coverage);
            break;
        case FIGURE_CHARIOTEER:
            houses_serviced = provide_culture(x, y, hippodrome_coverage);
            break;
        case FIGURE_ENGINEER:
        {
            int max_damage = 0;
            houses_serviced = provide_service(x, y, &max_damage, engineer_coverage);
            if (max_damage > f->min_max_seen) {
                f->min_max_seen = max_damage;
            } else if (f->min_max_seen <= 10) {
                f->min_max_seen = 0;
            } else {
                f->min_max_seen -= 10;
            }
            break;
        }
        case FIGURE_PREFECT:
        {
            int min_happiness = 100;
            houses_serviced = provide_service(x, y, &min_happiness, prefect_coverage);
            f->min_max_seen = min_happiness;
            break;
        }
        case FIGURE_RIOTER:
        {
            for (int dir = 0; dir < 8; dir += 2) {
                int grid_offset = f->grid_offset + map_grid_direction_delta(dir);
                if (!map_building_at(grid_offset)) {
                    continue;
                }
                b = &all_buildings[map_building_at(grid_offset)];
                switch (b->type) {
                    case BUILDING_WAREHOUSE_SPACE:
                    case BUILDING_WAREHOUSE:
                    case BUILDING_FORT_GROUND:
                    case BUILDING_FORT_LEGIONARIES:
                    case BUILDING_FORT_JAVELIN:
                    case BUILDING_FORT_MOUNTED:
                    case BUILDING_BURNING_RUIN:
                        continue;
                }
                if (b->house_size && b->subtype.house_level < HOUSE_SMALL_CASA) {
                    continue;
                }
                city_message_apply_sound_interval(MESSAGE_CAT_RIOT_COLLAPSE);
                city_message_post(0, MESSAGE_DESTROYED_BUILDING, b->type, f->grid_offset);
                message_data.message_count[MESSAGE_CAT_RIOT_COLLAPSE]++;
                destroy_on_fire(b, 0);
                f->action_state = FIGURE_ACTION_RIOTER_CREATED;
                f->wait_ticks = 0;
                f->direction = dir;
                return 1;
            }
            break;
        }
    }
    if (f->building_id) {
        b = &all_buildings[f->building_id];
        b->houses_covered += houses_serviced;
        if (b->houses_covered > 300) {
            b->houses_covered = 300;
        }
    }
    return 0;
}

static void figure__remove_ranged_targeter_from_list(struct figure_t *f, struct figure_t *ranged_targeter)
{
    for (int i = 0; i < MAX_RANGED_TARGETERS_PER_UNIT; i++) {
        if (f->ranged_targeter_ids[i] == ranged_targeter->id) {
            f->ranged_targeter_ids[i] = 0;
        }
    }
}

static void engage_in_melee_combat(struct figure_t *attacker, struct figure_t *opponent)
{
    attacker->engaged_in_combat = 1;
    // if ranged unit engages in melee combat, remove it from its (previous) target's ranged targeter list
    if (figure_properties[attacker->type].max_range && attacker->target_figure_id) {
        struct figure_t *target_of_ranged_unit = &figures[attacker->target_figure_id];
        figure__remove_ranged_targeter_from_list(target_of_ranged_unit, attacker);
    }
    attacker->target_figure_id = opponent->id;
    attacker->melee_combatant_ids[0] = opponent->id;
    attacker->num_melee_combatants++;
    attacker->attack_image_offset = 12;
    if (opponent->x != opponent->destination_x || opponent->y != opponent->destination_y) {
        attacker->attack_direction = calc_general_direction(attacker->previous_tile_x, attacker->previous_tile_y,
            opponent->previous_tile_x, opponent->previous_tile_y);
    } else {
        attacker->attack_direction = calc_general_direction(attacker->previous_tile_x, attacker->previous_tile_y,
            opponent->x, opponent->y);
    }
    if (attacker->attack_direction >= 8) {
        attacker->attack_direction = 0;
    }
    if (!opponent->engaged_in_combat) {
        opponent->engaged_in_combat = 1;
        // if opponent ranged unit engaged in melee combat, remove it from its (previous) target's ranged targeter list
        if (figure_properties[opponent->type].max_range && opponent->target_figure_id) {
            struct figure_t *target_of_opponent_ranged_unit = &figures[opponent->target_figure_id];
            figure__remove_ranged_targeter_from_list(target_of_opponent_ranged_unit, opponent);
        }
        opponent->target_figure_id = attacker->id;
        opponent->attack_image_offset = 0;
        opponent->attack_direction = (attacker->attack_direction + 4) % 8;
    }
    // add attacker to opponent's melee combatants list
    for (int i = 0; i < MAX_MELEE_COMBATANTS_PER_UNIT; i++) {
        if (!opponent->melee_combatant_ids[i]) {
            opponent->melee_combatant_ids[i] = attacker->id;
            break;
        }
    }
    opponent->num_melee_combatants++;
}

static int can_see_target(struct figure_t *observer, struct figure_t *target)
{
    int observer_elevation = terrain_elevation.items[observer->grid_offset];
    if (map_terrain_is(observer->grid_offset, TERRAIN_WALL_OR_GATEHOUSE)) {
        observer_elevation += 6;
    }

    int x_delta = abs(observer->x - target->x);
    int y_delta = abs(observer->y - target->y);
    double slope;
    int x_check = 0;
    int y_check = 0;
    int delta;
    if (x_delta > y_delta) {
        slope = (double) (target->y - observer->y) / (double) (target->x - observer->x);
        x_check = observer->x;
        delta = x_delta;
    } else {
        slope = (double) (target->x - observer->x) / (double) (target->y - observer->y);
        y_check = observer->y;
        delta = y_delta;
    }
    while (delta > 1) {
        delta--;
        if (x_delta > y_delta) {
            if (observer->x < target->x) {
                x_check++;
            } else {
                x_check--;
            }
            y_check = slope * (x_check - observer->x) + observer->y;
        } else {
            if (observer->y < target->y) {
                y_check++;
            } else {
                y_check--;
            }
            x_check = slope * (y_check - observer->y) + observer->x;
        }
        if (observer_elevation > terrain_elevation.items[target->grid_offset]) {
            observer_elevation--;
            continue;
        }
        int grid_offset = map_grid_offset(x_check, y_check);
        int map_img_at_offset = images.items[grid_offset];
        // only higher elevation between targets obstructs
        if (terrain_elevation.items[grid_offset] > 1) {
            return 0;
        }
        // only taller shrubs obstruct
        if (terrain_grid.items[grid_offset] & TERRAIN_SHRUB) {
            int shrub_first_img_id = 274;
            if (((scenario.climate == CLIMATE_CENTRAL || scenario.climate == CLIMATE_NORTHERN) && map_img_at_offset >= shrub_first_img_id + 8)
            || (scenario.climate == CLIMATE_DESERT && map_img_at_offset >= shrub_first_img_id + 24)) {
                return 0;
            }
        }
        // only larger rocks obstruct
        if (terrain_grid.items[grid_offset] & TERRAIN_ROCK) {
            int rock_first_img_id = 849;
            if (map_img_at_offset >= rock_first_img_id + 8) {
                return 0;
            }
        }
        if (terrain_grid.items[grid_offset] & (TERRAIN_TREE | TERRAIN_WALL | TERRAIN_GATEHOUSE)) { // "terrain contains any of"
            return 0;
        }
        if (terrain_grid.items[grid_offset] & TERRAIN_BUILDING) {
            struct building_t *b = &all_buildings[map_building_at(grid_offset)];
            // buildings with a low max height do not obstruct
            if (b->type != BUILDING_FORT_GROUND && b->type != BUILDING_CLAY_PIT && b->type != BUILDING_MARBLE_QUARRY) {
                return 0;
            }
        }
    }
    return 1;
}

static int is_valid_target_for_player_unit(struct figure_t *target)
{
    return figure_properties[target->type].is_criminal_unit
        || (figure_properties[target->type].is_native_unit && target->action_state == FIGURE_ACTION_NATIVE_ATTACKING)
        || target->type == FIGURE_WOLF
        || figure_properties[target->type].is_enemy_unit
        || figure_properties[target->type].is_caesar_legion_unit;
}

static int is_valid_target_for_enemy_unit(struct figure_t *target)
{
    return figure_properties[target->type].is_unarmed_civilian_unit
        || figure_properties[target->type].is_friendly_armed_unit
        || figure_properties[target->type].is_player_legion_unit
        || figure_properties[target->type].is_criminal_unit
        || figure_properties[target->type].is_empire_trader
        || (figure_properties[target->type].is_native_unit && target->action_state != FIGURE_ACTION_NATIVE_ATTACKING)
        || target->type == FIGURE_WOLF
        || figure_properties[target->type].is_caesar_legion_unit;
}

static int is_valid_target_for_caesar_unit(struct figure_t *target)
{
    return figure_properties[target->type].is_friendly_armed_unit
        || figure_properties[target->type].is_player_legion_unit
        || figure_properties[target->type].is_criminal_unit
        || (figure_properties[target->type].is_native_unit && target->action_state != FIGURE_ACTION_NATIVE_ATTACKING)
        || target->type == FIGURE_WOLF
        || figure_properties[target->type].is_enemy_unit;
}

static void melee_attack_figure_at_offset(struct figure_t *attacker, int grid_offset)
{
    if (attacker->engaged_in_combat) {
        return;
    }
    int figure_id = map_figures.items[grid_offset];
    while (figure_id) {
        struct figure_t *opponent = &figures[figure_id];
        if (opponent->id != attacker->id
        && figure_is_alive(opponent)
        && opponent->is_targetable
        && opponent->num_melee_combatants < MAX_MELEE_COMBATANTS_PER_UNIT) {
            if (figure_properties[attacker->type].is_friendly_armed_unit || figure_properties[attacker->type].is_player_legion_unit) {
                if (is_valid_target_for_player_unit(opponent) || (opponent->type == FIGURE_SHEEP || opponent->type == FIGURE_ZEBRA)) {
                    engage_in_melee_combat(attacker, opponent);
                    return;
                }
            } else if (attacker->type == FIGURE_WOLF) {
                if (opponent->type != FIGURE_WOLF) {
                    engage_in_melee_combat(attacker, opponent);
                    return;
                }
            } else if (figure_properties[attacker->type].is_enemy_unit) {
                if (is_valid_target_for_enemy_unit(opponent)) {
                    engage_in_melee_combat(attacker, opponent);
                    return;
                }
            } else if (figure_properties[attacker->type].is_caesar_legion_unit) {
                if (is_valid_target_for_caesar_unit(opponent)) {
                    engage_in_melee_combat(attacker, opponent);
                    return;
                }
            }
        }
        figure_id = opponent->next_figure_id_on_same_tile;
    }
}

static void move_to_next_tile(struct figure_t *f)
{
    int old_x = f->x;
    int old_y = f->y;
    map_figure_delete(f);
    switch (f->direction) {
        default:
            return;
        case DIR_0_TOP:
            f->y--;
            break;
        case DIR_1_TOP_RIGHT:
            f->x++; f->y--;
            break;
        case DIR_2_RIGHT:
            f->x++;
            break;
        case DIR_3_BOTTOM_RIGHT:
            f->x++; f->y++;
            break;
        case DIR_4_BOTTOM:
            f->y++;
            break;
        case DIR_5_BOTTOM_LEFT:
            f->x--; f->y++;
            break;
        case DIR_6_LEFT:
            f->x--;
            break;
        case DIR_7_TOP_LEFT:
            f->x--; f->y--;
            break;
    }
    f->grid_offset += map_grid_direction_delta(f->direction);
    map_figure_add(f);
    if (map_terrain_is(f->grid_offset, TERRAIN_ROAD)) {
        if (map_terrain_is(f->grid_offset, TERRAIN_WATER)) { // bridge
            f->height_adjusted_ticks = 18;
            if (sprite.items[f->grid_offset] <= 6) {
                // low bridge
                switch (sprite.items[f->grid_offset]) {
                    case 1:
                    case 4:
                        f->target_height = 10;
                        break;
                    case 2:
                    case 3:
                        f->target_height = 16;
                        break;
                    default:
                        f->target_height = 20;
                        break;
                }
            } else {
                // ship bridge
                switch (sprite.items[f->grid_offset]) {
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                        f->target_height = 14;
                        break;
                    case 13:
                        f->target_height = 30;
                        break;
                    default:
                        f->target_height = 36;
                        break;
                }
            }
        }
    }
    if (figure_properties[f->type].is_friendly_armed_unit || figure_properties[f->type].is_player_legion_unit
    || figure_properties[f->type].is_native_unit || f->type == FIGURE_WOLF || figure_properties[f->type].is_enemy_unit || figure_properties[f->type].is_caesar_legion_unit) {
        melee_attack_figure_at_offset(f, f->grid_offset);
    }
    f->previous_tile_x = old_x;
    f->previous_tile_y = old_y;
}

static void advance_tick_movement(struct figure_t *f)
{
    switch (f->direction) {
        case DIR_0_TOP:
            f->cross_country_y--;
            break;
        case DIR_1_TOP_RIGHT:
            f->cross_country_x++;
            f->cross_country_y--;
            break;
        case DIR_2_RIGHT:
            f->cross_country_x++;
            break;
        case DIR_3_BOTTOM_RIGHT:
            f->cross_country_x++;
            f->cross_country_y++;
            break;
        case DIR_4_BOTTOM:
            f->cross_country_y++;
            break;
        case DIR_5_BOTTOM_LEFT:
            f->cross_country_x--;
            f->cross_country_y++;
            break;
        case DIR_6_LEFT:
            f->cross_country_x--;
            break;
        case DIR_7_TOP_LEFT:
            f->cross_country_x--;
            f->cross_country_y--;
            break;
        default:
            break;
    }
    if (f->height_adjusted_ticks) {
        f->height_adjusted_ticks--;
        if (f->height_adjusted_ticks > 0) {
            f->is_invisible = 1;
            if (f->current_height < f->target_height) {
                f->current_height++;
            }
            if (f->current_height > f->target_height) {
                f->current_height--;
            }
        } else {
            f->is_invisible = 0;
        }
    } else {
        if (f->current_height) {
            f->current_height--;
        }
    }
}

static void map_routing_calculate_distances_water_boat(int x, int y)
{
    int grid_offset = map_grid_offset(x, y);
    if (terrain_water.items[grid_offset] == WATER_N1_BLOCKED) {
        memset(routing_distance.items, 0, GRID_SIZE * GRID_SIZE * sizeof(int16_t));
    } else {
        memset(routing_distance.items, 0, GRID_SIZE * GRID_SIZE * sizeof(int16_t));
        memset(water_drag.items, 0, GRID_SIZE * GRID_SIZE * sizeof(uint8_t));
        routing_queue.head = routing_queue.tail = 0;
        enqueue(grid_offset, 1);
        int tiles = 0;
        while (routing_queue.head != routing_queue.tail) {
            int offset = routing_queue.items[routing_queue.head];
            if (++tiles > GUARD) {
                break;
            }
            int drag = terrain_water.items[offset] == WATER_N2_MAP_EDGE ? 4 : 0;
            if (drag && water_drag.items[offset]++ < drag) {
                routing_queue.items[routing_queue.tail++] = offset;
                if (routing_queue.tail >= MAX_QUEUE_ROUTING) {
                    routing_queue.tail = 0;
                }
            } else {
                int dist = 1 + routing_distance.items[offset];
                for (int i = 0; i < 4; i++) {
                    if (valid_offset(offset + ROUTE_OFFSETS[i])) {
                        if (terrain_water.items[offset + ROUTE_OFFSETS[i]] != WATER_N1_BLOCKED &&
    terrain_water.items[offset + ROUTE_OFFSETS[i]] != WATER_N3_LOW_BRIDGE) {
                            enqueue(offset + ROUTE_OFFSETS[i], dist);
                            if (terrain_water.items[offset + ROUTE_OFFSETS[i]] == WATER_N2_MAP_EDGE) {
                                routing_distance.items[offset + ROUTE_OFFSETS[i]] += 4;
                            }
                        }
                    }
                }
            }
            if (++routing_queue.head >= MAX_QUEUE_ROUTING) {
                routing_queue.head = 0;
            }
        }
    }
}

static void callback_travel_noncitizen_land_through_building(int next_offset, int dist)
{
    if (terrain_land_noncitizen.items[next_offset] == NONCITIZEN_0_PASSABLE ||
        terrain_land_noncitizen.items[next_offset] == NONCITIZEN_2_CLEARABLE ||
        (terrain_land_noncitizen.items[next_offset] == NONCITIZEN_1_BUILDING &&
            map_building_at(next_offset) == route_through_building_id)) {
        enqueue(next_offset, dist);
    }
}

static int map_routing_noncitizen_can_travel_over_land(int src_x, int src_y, int dst_x, int dst_y, int only_through_building_id, int max_tiles)
{
    int src_offset = map_grid_offset(src_x, src_y);
    int dst_offset = map_grid_offset(dst_x, dst_y);
    ++stats.total_routes_calculated;
    ++stats.enemy_routes_calculated;
    if (only_through_building_id) {
        route_through_building_id = only_through_building_id;
        route_queue(src_offset, dst_offset, callback_travel_noncitizen_land_through_building);
    } else {
        memset(routing_distance.items, 0, GRID_SIZE * GRID_SIZE * sizeof(int16_t));
        routing_queue.head = routing_queue.tail = 0;
        enqueue(src_offset, 1);
        int tiles = 0;
        while (routing_queue.head != routing_queue.tail) {
            int offset = routing_queue.items[routing_queue.head];
            if (offset == dst_offset) break;
            if (++tiles > max_tiles) break;
            int dist = 1 + routing_distance.items[offset];
            for (int i = 0; i < 4; i++) {
                if (valid_offset(offset + ROUTE_OFFSETS[i])) {
                    if (terrain_land_noncitizen.items[offset + ROUTE_OFFSETS[i]] >= NONCITIZEN_0_PASSABLE &&
    terrain_land_noncitizen.items[offset + ROUTE_OFFSETS[i]] <= NONCITIZEN_5_FORT) {
                        enqueue(offset + ROUTE_OFFSETS[i], dist);
                    }
                }
            }
            if (++routing_queue.head >= MAX_QUEUE_ROUTING) {
                routing_queue.head = 0;
            }
        }
    }
    return routing_distance.items[dst_offset] != 0;
}

static void callback_travel_noncitizen_through_everything(int next_offset, int dist)
{
    if (terrain_land_noncitizen.items[next_offset] >= NONCITIZEN_0_PASSABLE) {
        enqueue(next_offset, dist);
    }
}

static int map_routing_noncitizen_can_travel_through_everything(int src_x, int src_y, int dst_x, int dst_y)
{
    int src_offset = map_grid_offset(src_x, src_y);
    int dst_offset = map_grid_offset(dst_x, dst_y);
    ++stats.total_routes_calculated;
    route_queue(src_offset, dst_offset, callback_travel_noncitizen_through_everything);
    return routing_distance.items[dst_offset] != 0;
}

static void walk_ticks(struct figure_t *f, int num_ticks, int roaming_enabled)
{
    while (num_ticks > 0) {
        f->figure_is_halted = 0;
        num_ticks--;
        f->progress_on_tile++;
        if (f->progress_on_tile < 15) {
            advance_tick_movement(f);
        } else {
            figure_service_provide_coverage(f);
            f->progress_on_tile = 15;
            if (f->routing_path_id <= 0) {
                f->routing_path_id = 0;
                f->routing_path_current_tile = 0;
                f->routing_path_length = 0;
                int path_id = 0;
                for (int i = 1; i < MAX_ROUTES; i++) {
                    if (figure_route_data.figure_ids[i] == 0) {
                        path_id = i;
                        break;
                    }
                }
                int path_length = 0;
                if (path_id) {
                    if (figure_properties[f->type].is_boat) {
                        if (figure_properties[f->type].is_boat == 2) { // flotsam
                            int grid_offset = map_grid_offset(f->x, f->y);
                            if (terrain_water.items[grid_offset] == WATER_N1_BLOCKED) {
                                memset(routing_distance.items, 0, GRID_SIZE * GRID_SIZE * sizeof(int16_t));
                            } else {
                                memset(routing_distance.items, 0, GRID_SIZE * GRID_SIZE * sizeof(int16_t));
                                routing_queue.head = routing_queue.tail = 0;
                                enqueue(grid_offset, 1);
                                int tiles = 0;
                                while (routing_queue.head != routing_queue.tail) {
                                    if (++tiles > GUARD) {
                                        break;
                                    }
                                    int offset = routing_queue.items[routing_queue.head];
                                    int dist = 1 + routing_distance.items[offset];
                                    for (int i = 0; i < 8; i++) {
                                        if (valid_offset(offset + ROUTE_OFFSETS[i])) {
                                            if (terrain_water.items[offset + ROUTE_OFFSETS[i]] != WATER_N1_BLOCKED) {
                                                enqueue(offset + ROUTE_OFFSETS[i], dist);
                                            }
                                        }
                                    }
                                    if (++routing_queue.head >= MAX_QUEUE_ROUTING) {
                                        routing_queue.head = 0;
                                    }
                                }
                            }
                            path_length = map_routing_get_path_on_water(figure_route_data.direction_paths[path_id],
                                f->destination_x, f->destination_y, 1);
                        } else {
                            map_routing_calculate_distances_water_boat(f->x, f->y);
                            path_length = map_routing_get_path_on_water(figure_route_data.direction_paths[path_id],
                                f->destination_x, f->destination_y, 0);
                        }
                    } else {
                        // land figure
                        int can_travel;
                        switch (f->terrain_usage) {
                            case TERRAIN_USAGE_ENEMY:
                                can_travel = map_routing_noncitizen_can_travel_over_land(f->x, f->y,
                                    f->destination_x, f->destination_y, f->destination_building_id, 5000);
                                if (!can_travel) {
                                    can_travel = map_routing_noncitizen_can_travel_over_land(f->x, f->y,
                                        f->destination_x, f->destination_y, 0, 25000);
                                    if (!can_travel) {
                                        can_travel = map_routing_noncitizen_can_travel_through_everything(
                                            f->x, f->y, f->destination_x, f->destination_y);
                                    }
                                }
                                break;
                            case TERRAIN_USAGE_WALLS:
                            {
                                int src_offset = map_grid_offset(f->x, f->y);
                                int dst_offset = map_grid_offset(f->destination_x, f->destination_y);
                                stats.total_routes_calculated++;
                                route_queue(src_offset, dst_offset, callback_travel_walls);
                                can_travel = routing_distance.items[dst_offset] != 0;
                                break;
                            }
                            case TERRAIN_USAGE_ANIMAL:
                                can_travel = map_routing_noncitizen_can_travel_over_land(f->x, f->y, f->destination_x, f->destination_y, -1, 5000);
                                break;
                            case TERRAIN_USAGE_PREFER_ROADS:
                                can_travel = map_routing_citizen_can_travel_over_road_garden(f->x, f->y, f->destination_x, f->destination_y);
                                if (!can_travel) {
                                    can_travel = map_routing_citizen_can_travel_over_land(f->x, f->y, f->destination_x, f->destination_y);
                                }
                                break;
                            case TERRAIN_USAGE_ROADS:
                                can_travel = map_routing_citizen_can_travel_over_road_garden(f->x, f->y, f->destination_x, f->destination_y);
                                break;
                            default:
                                can_travel = map_routing_citizen_can_travel_over_land(f->x, f->y, f->destination_x, f->destination_y);
                                break;
                        }
                        if (can_travel) {
                            if (f->terrain_usage == TERRAIN_USAGE_WALLS) {
                                path_length = map_routing_get_path(figure_route_data.direction_paths[path_id], f->x, f->y,
                                    f->destination_x, f->destination_y, 4);
                                if (path_length <= 0) {
                                    path_length = map_routing_get_path(figure_route_data.direction_paths[path_id], f->x, f->y,
                                        f->destination_x, f->destination_y, 8);
                                }
                            } else {
                                path_length = map_routing_get_path(figure_route_data.direction_paths[path_id], f->x, f->y,
                                    f->destination_x, f->destination_y, 8);
                            }
                        } else { // cannot travel
                            path_length = 0;
                        }
                    }
                }
                if (path_length) {
                    figure_route_data.figure_ids[path_id] = f->id;
                    f->routing_path_id = path_id;
                    f->routing_path_length = path_length;
                }
            }
            if (f->routing_path_id > 0) {
                if (f->routing_path_current_tile < f->routing_path_length) {
                    f->direction = figure_route_data.direction_paths[f->routing_path_id][f->routing_path_current_tile];
                } else {
                    figure_route_remove(f);
                    f->direction = DIR_FIGURE_AT_DESTINATION;
                    f->figure_is_halted = 1;
                }
            } else { // should be at destination
                f->direction = calc_general_direction(f->x, f->y, f->destination_x, f->destination_y);
                if (f->direction != DIR_FIGURE_AT_DESTINATION) {
                    f->direction = DIR_FIGURE_LOST;
                }
            }
            if (f->direction < 8) {
                int target_grid_offset = f->grid_offset + map_grid_direction_delta(f->direction);
                if (figure_properties[f->type].is_boat) {
                    if (!map_terrain_is(target_grid_offset, TERRAIN_WATER)) {
                        f->direction = DIR_FIGURE_REROUTE;
                    }
                } else if (f->terrain_usage == TERRAIN_USAGE_ENEMY) {
                    if (terrain_land_noncitizen.items[target_grid_offset] < NONCITIZEN_0_PASSABLE) {
                        f->direction = DIR_FIGURE_REROUTE;
                    } else if (terrain_land_noncitizen.items[target_grid_offset] > NONCITIZEN_0_PASSABLE && terrain_land_noncitizen.items[target_grid_offset] != NONCITIZEN_5_FORT) {
                        int cause_damage = 1;
                        int max_damage = 0;
                        int destructible = 0;
                        switch (terrain_land_noncitizen.items[target_grid_offset]) {
                            case NONCITIZEN_1_BUILDING:
                                destructible = DESTROYABLE_BUILDING;
                                break;
                            case NONCITIZEN_2_CLEARABLE:
                                destructible = DESTROYABLE_AQUEDUCT_GARDEN;
                                break;
                            case NONCITIZEN_3_WALL:
                                destructible = DESTROYABLE_WALL;
                                break;
                            case NONCITIZEN_4_GATEHOUSE:
                                destructible = DESTROYABLE_GATEHOUSE;
                                break;
                            default:
                                destructible = DESTROYABLE_NONE;
                                break;
                        }
                        switch (destructible) {
                            case DESTROYABLE_BUILDING:
                                max_damage = 10;
                                break;
                            case DESTROYABLE_AQUEDUCT_GARDEN:
                                if (map_terrain_is(target_grid_offset, TERRAIN_GARDEN | TERRAIN_ACCESS_RAMP | TERRAIN_RUBBLE)) {
                                    cause_damage = 0;
                                } else {
                                    max_damage = 10;
                                }
                                break;
                            case DESTROYABLE_WALL:
                                max_damage = 200;
                                break;
                            case DESTROYABLE_GATEHOUSE:
                                max_damage = 150;
                                break;
                        }
                        if (cause_damage) {
                            f->attack_direction = f->direction;
                            f->direction = DIR_FIGURE_ATTACK;
                            if (!(time_data.tick & 3)) {
                                damage_grid.items[target_grid_offset]++;
                                if (damage_grid.items[target_grid_offset] > max_damage) {
                                    building_destroy_by_enemy(map_grid_offset_to_x(target_grid_offset), map_grid_offset_to_y(target_grid_offset), target_grid_offset);
                                }
                            }
                        }
                    }
                } else if (f->terrain_usage == TERRAIN_USAGE_WALLS) {
                    if (terrain_walls.items[target_grid_offset] != WALL_0_PASSABLE) {
                        f->direction = DIR_FIGURE_REROUTE;
                    }
                } else if (map_terrain_is(target_grid_offset, TERRAIN_ROAD | TERRAIN_ACCESS_RAMP)) {
                    if (roaming_enabled && map_terrain_is(target_grid_offset, TERRAIN_BUILDING)) {
                        if (all_buildings[map_building_at(target_grid_offset)].type == BUILDING_GATEHOUSE) {
                            // do not allow roaming through gatehouse
                            f->direction = DIR_FIGURE_REROUTE;
                        }
                    }
                } else if (map_terrain_is(target_grid_offset, TERRAIN_BUILDING)) {
                    switch (all_buildings[map_building_at(target_grid_offset)].type) {
                        case BUILDING_WAREHOUSE:
                        case BUILDING_GRANARY:
                        case BUILDING_TRIUMPHAL_ARCH:
                        case BUILDING_FORT_GROUND:
                            break; // OK to walk
                        default:
                            f->direction = DIR_FIGURE_REROUTE;
                    }
                } else if (map_terrain_is(target_grid_offset, TERRAIN_IMPASSABLE)) {
                    f->direction = DIR_FIGURE_REROUTE;
                }
            }
            if (f->direction >= 8) {
                break;
            }
            f->routing_path_current_tile++;
            f->previous_tile_direction = f->direction;
            f->progress_on_tile = 0;
            move_to_next_tile(f);
            advance_tick_movement(f);
        }
    }
}

static void figure_movement_roam_ticks(struct figure_t *f, int num_ticks)
{
    if (f->roam_choose_destination == 0) {
        walk_ticks(f, num_ticks, 1);
        if (f->direction == DIR_FIGURE_AT_DESTINATION) {
            f->roam_choose_destination = 1;
            f->roam_length = 0;
        } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
            f->roam_choose_destination = 1;
        }
        if (f->roam_choose_destination) {
            f->roam_ticks_until_next_turn = 100;
            f->direction = f->previous_tile_direction;
        } else {
            return;
        }
    }
    // no destination: walk to end of tile and pick a direction
    while (num_ticks > 0) {
        num_ticks--;
        f->progress_on_tile++;
        if (f->progress_on_tile < 15) {
            advance_tick_movement(f);
        } else {
            f->progress_on_tile = 15;
            f->roam_random_counter++;
            int came_from_direction = (f->previous_tile_direction + 4) % 8;
            if (figure_service_provide_coverage(f)) {
                return;
            }
            int road_tiles[8];
            road_tiles[1] = road_tiles[3] = road_tiles[5] = road_tiles[7] = 0;
            road_tiles[0] = get_adjacent_road_tile_for_roaming(f->grid_offset + map_grid_delta(0, -1));
            road_tiles[2] = get_adjacent_road_tile_for_roaming(f->grid_offset + map_grid_delta(1, 0));
            road_tiles[4] = get_adjacent_road_tile_for_roaming(f->grid_offset + map_grid_delta(0, 1));
            road_tiles[6] = get_adjacent_road_tile_for_roaming(f->grid_offset + map_grid_delta(-1, 0));
            int adjacent_road_tiles = road_tiles[0] + road_tiles[2] + road_tiles[4] + road_tiles[6];
            if (adjacent_road_tiles == 3 && map_get_diagonal_road_tiles_for_roaming(f->grid_offset, road_tiles) >= 5) {
                // go in the straight direction of a double-wide road
                adjacent_road_tiles = 2;
                if (came_from_direction == DIR_0_TOP || came_from_direction == DIR_4_BOTTOM) {
                    if (road_tiles[0] && road_tiles[4]) {
                        road_tiles[2] = road_tiles[6] = 0;
                    } else {
                        road_tiles[0] = road_tiles[4] = 0;
                    }
                } else {
                    if (road_tiles[2] && road_tiles[6]) {
                        road_tiles[0] = road_tiles[4] = 0;
                    } else {
                        road_tiles[2] = road_tiles[6] = 0;
                    }
                }
            }
            if (adjacent_road_tiles == 4 && map_get_diagonal_road_tiles_for_roaming(f->grid_offset, road_tiles) >= 8) {
                // go straight on when all surrounding tiles are road
                adjacent_road_tiles = 2;
                if (came_from_direction == DIR_0_TOP || came_from_direction == DIR_4_BOTTOM) {
                    road_tiles[2] = road_tiles[6] = 0;
                } else {
                    road_tiles[0] = road_tiles[4] = 0;
                }
            }
            if (adjacent_road_tiles <= 0) {
                f->roam_length = figure_properties[f->type].max_roam_length; // end roaming walk
                return;
            }
            if (adjacent_road_tiles == 1) {
                int dir = 0;
                do {
                    f->direction = 2 * dir;
                } while (!road_tiles[f->direction] && dir++ < 4);
            } else if (adjacent_road_tiles == 2) {
                if (f->roam_ticks_until_next_turn == -1) {
                    roam_set_direction(f);
                    came_from_direction = -1;
                }
                // 1. continue in the same direction
                // 2. turn in the direction given by roam_turn_direction
                int dir = 0;
                do {
                    if (road_tiles[f->direction] && f->direction != came_from_direction) {
                        break;
                    }
                    f->direction += f->roam_turn_direction;
                    if (f->direction > 6) f->direction = 0;
                    if (f->direction < 0) f->direction = 6;
                } while (dir++ < 4);
            } else { // > 2 road tiles
                f->direction = (f->roam_random_counter + random.items[f->grid_offset]) & 6;
                if (!road_tiles[f->direction] || f->direction == came_from_direction) {
                    f->roam_ticks_until_next_turn--;
                    if (f->roam_ticks_until_next_turn <= 0) {
                        roam_set_direction(f);
                        came_from_direction = -1;
                    }
                    int dir = 0;
                    do {
                        if (road_tiles[f->direction] && f->direction != came_from_direction) {
                            break;
                        }
                        f->direction += f->roam_turn_direction;
                        if (f->direction > 6) f->direction = 0;
                        if (f->direction < 0) f->direction = 6;
                    } while (dir++ < 4);
                }
            }
            f->routing_path_current_tile++;
            f->previous_tile_direction = f->direction;
            f->progress_on_tile = 0;
            move_to_next_tile(f);
            advance_tick_movement(f);
        }
    }
}

static void roamer_action(struct figure_t *f, int num_ticks)
{
    switch (f->action_state) {
        case FIGURE_ACTION_ROAMING:
            f->is_invisible = 0;
            f->roam_length++;
            if (f->roam_length >= figure_properties[f->type].max_roam_length) {
                int x, y;
                struct building_t *b = &all_buildings[f->building_id];
                if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x, &y)) {
                    f->action_state = FIGURE_ACTION_ROAMER_RETURNING;
                    f->destination_x = x;
                    f->destination_y = y;
                    figure_route_remove(f);
                    f->roam_length = 0;
                } else {
                    figure_delete(f);
                    return;
                }
            }
            figure_movement_roam_ticks(f, num_ticks);
            break;
        case FIGURE_ACTION_ROAMER_RETURNING:
            walk_ticks(f, num_ticks, 0);
            if (f->direction == DIR_FIGURE_AT_DESTINATION ||
                f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                figure_delete(f);
                return;
            }
            break;
    }
}

static int figure_image_direction(struct figure_t *f)
{
    int dir = f->direction - view_data.orientation;
    if (dir < 0) {
        dir += 8;
    }
    return dir;
}

static void figure_image_increase_offset(struct figure_t *f, int max)
{
    f->image_offset++;
    if (f->image_offset >= max) {
        f->image_offset = 0;
    }
}

static void culture_action(struct figure_t *f, int img_id)
{
    struct building_t *b = &all_buildings[f->building_id];
    if (b->state != BUILDING_STATE_IN_USE || b->figure_id != f->id) {
        figure_delete(f);
        return;
    }
    figure_image_increase_offset(f, 12);
    roamer_action(f, 1);
    f->image_id = img_id + figure_image_direction(f) + 8 * f->image_offset;
}

static void figure_play_die_sound(struct figure_t *f)
{
    int is_combatant = 0;
    int is_citizen = 0;
    switch (f->type) {
        case FIGURE_WOLF:
            play_sound_effect(SOUND_EFFECT_WOLF_DIE);
            break;
        case FIGURE_SHEEP:
            play_sound_effect(SOUND_EFFECT_SHEEP_DIE);
            break;
        case FIGURE_ZEBRA:
            play_sound_effect(SOUND_EFFECT_ZEBRA_DIE);
            break;
        case FIGURE_LION_TAMER:
            play_sound_effect(SOUND_EFFECT_LION_DIE);
            break;
        case FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT:
            play_sound_effect(SOUND_EFFECT_ELEPHANT_DIE);
            break;
        case FIGURE_ENEMY_BRITON_CHARIOT:
        case FIGURE_ENEMY_CELT_CHARIOT:
        case FIGURE_ENEMY_PICT_CHARIOT:
        case FIGURE_ENEMY_HUN_MOUNTED_ARCHER:
        case FIGURE_ENEMY_GOTH_MOUNTED_ARCHER:
        case FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER:
            play_sound_effect(SOUND_EFFECT_HORSE2);
            break;
        case FIGURE_ENEMY_EGYPTIAN_CAMEL:
            play_sound_effect(SOUND_EFFECT_CAMEL);
            break;
        case FIGURE_NATIVE_TRADER:
        case FIGURE_TRADE_CARAVAN:
        case FIGURE_TRADE_CARAVAN_DONKEY:
            break;
        case FIGURE_PREFECT:
        case FIGURE_FORT_JAVELIN:
        case FIGURE_FORT_MOUNTED:
        case FIGURE_FORT_LEGIONARY:
        case FIGURE_GLADIATOR:
        case FIGURE_INDIGENOUS_NATIVE:
        case FIGURE_TOWER_SENTRY:
        case FIGURE_ENEMY_GLADIATOR:
        case FIGURE_ENEMY_BARBARIAN_SWORDSMAN:
        case FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN:
        case FIGURE_ENEMY_BRITON_SWORDSMAN:
        case FIGURE_ENEMY_CELT_SWORDSMAN:
        case FIGURE_ENEMY_PICT_SWORDSMAN:
        case FIGURE_ENEMY_EGYPTIAN_SWORDSMAN:
        case FIGURE_ENEMY_ETRUSCAN_SWORDSMAN:
        case FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER:
        case FIGURE_ENEMY_SAMNITE_SWORDSMAN:
        case FIGURE_ENEMY_SAMNITE_SPEAR_THROWER:
        case FIGURE_ENEMY_GAUL_SWORDSMAN:
        case FIGURE_ENEMY_GAUL_AXEMAN:
        case FIGURE_ENEMY_HELVETIUS_SWORDSMAN:
        case FIGURE_ENEMY_HELVETIUS_AXEMAN:
        case FIGURE_ENEMY_HUN_SWORDSMAN:
        case FIGURE_ENEMY_GOTH_SWORDSMAN:
        case FIGURE_ENEMY_VISIGOTH_SWORDSMAN:
        case FIGURE_ENEMY_GREEK_SWORDSMAN:
        case FIGURE_ENEMY_GREEK_SPEAR_THROWER:
        case FIGURE_ENEMY_MACEDONIAN_SWORDSMAN:
        case FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER:
        case FIGURE_ENEMY_NUMIDIAN_SWORDSMAN:
        case FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER:
        case FIGURE_ENEMY_PERGAMUM_SWORDSMAN:
        case FIGURE_ENEMY_PERGAMUM_ARCHER:
        case FIGURE_ENEMY_IBERIAN_SWORDSMAN:
        case FIGURE_ENEMY_IBERIAN_SPEAR_THROWER:
        case FIGURE_ENEMY_JUDEAN_SWORDSMAN:
        case FIGURE_ENEMY_JUDEAN_SPEAR_THROWER:
        case FIGURE_ENEMY_SELEUCID_SWORDSMAN:
        case FIGURE_ENEMY_SELEUCID_SPEAR_THROWER:
        case FIGURE_ENEMY_CAESAR_JAVELIN:
        case FIGURE_ENEMY_CAESAR_MOUNTED:
        case FIGURE_ENEMY_CAESAR_LEGIONARY:
            is_combatant = 1;
            break;
        default:
            is_citizen = 1;
            break;
    }
    city_data.sound.die_citizen++;
    if (is_combatant) {
        city_data.sound.die_soldier++;
        if (city_data.sound.die_soldier >= 4) {
            city_data.sound.die_soldier = 0;
        }
        play_sound_effect(SOUND_EFFECT_SOLDIER_DIE + city_data.sound.die_soldier);
    } else if (is_citizen) {
        if (city_data.sound.die_citizen >= 4) {
            city_data.sound.die_citizen = 0;
        }
        play_sound_effect(SOUND_EFFECT_CITIZEN_DIE + city_data.sound.die_citizen);
    }
}

static void update_formation_morale_after_death(struct formation_t *m)
{
    int pct_dead = calc_percentage(1, m->num_figures);
    int morale;
    if (pct_dead < 8) {
        morale = -5;
    } else if (pct_dead < 10) {
        morale = -7;
    } else if (pct_dead < 14) {
        morale = -10;
    } else if (pct_dead < 20) {
        morale = -12;
    } else if (pct_dead < 30) {
        morale = -15;
    } else {
        morale = -20;
    }
    m->morale = calc_bound(m->morale + morale, 0, m->max_morale);
}

static int figure__targeted_by_ranged_unit(struct figure_t *f, struct figure_t *ranged_targeter)
{
    for (int i = 0; i < MAX_RANGED_TARGETERS_PER_UNIT; i++) {
        if (f->ranged_targeter_ids[i] == ranged_targeter->id) {
            return 1;
        }
    }
    return 0;
}

static void figure__remove_melee_targeter_from_list(struct figure_t *f, struct figure_t *melee_targeter)
{
    for (int i = 0; i < MAX_MELEE_TARGETERS_PER_UNIT; i++) {
        if (f->melee_targeter_ids[i] == melee_targeter->id) {
            f->melee_targeter_ids[i] = 0;
        }
    }
}

static void clear_targeting_on_unit_death(struct figure_t *dead_unit)
{
    // remove unit from its target's targeter lists
    struct figure_t *target = &figures[dead_unit->target_figure_id];
    figure__remove_melee_targeter_from_list(target, dead_unit);
    figure__remove_ranged_targeter_from_list(target, dead_unit);

    // reset target of all opponents targeting the unit; remove unit from melee combatant list of all opponents fighting it
    for (int i = 0; i < MAX_FIGURES; i++) {
        struct figure_t *opponent = &figures[i];
        if (figure_is_alive(opponent)) {
            if (opponent->target_figure_id == dead_unit->id) {
                opponent->target_figure_id = 0;
            }
            for (int j = 0; j < MAX_MELEE_COMBATANTS_PER_UNIT; j++) {
                if (opponent->melee_combatant_ids[j] == dead_unit->id) {
                    opponent->melee_combatant_ids[j] = 0;
                    opponent->num_melee_combatants--;
                }
            }
        }
    }
}

static void missile_hit_target(struct figure_t *projectile, struct figure_t *target)
{
    struct figure_t *shooter = &figures[projectile->building_id];
    int damage_inflicted = (figure_properties[shooter->type].missile_attack_value + figure_properties[projectile->type].missile_attack_value) - figure_properties[target->type].missile_defense_value;
    if (damage_inflicted < 0) {
        damage_inflicted = 0;
    }
    if (projectile->type != FIGURE_BOLT
        && ((target->type == FIGURE_FORT_LEGIONARY && legion_formations[target->formation_id].layout == FORMATION_TORTOISE)
            || (target->type == FIGURE_ENEMY_CAESAR_LEGIONARY && enemy_formations[target->formation_id].layout == FORMATION_TORTOISE))
            && target->figure_is_halted) {
        damage_inflicted = 1;
    }
    int target_damage = damage_inflicted + target->damage;
    if (target_damage <= figure_properties[target->type].max_damage) {
        target->damage = target_damage;
    } else { // kill target
        target->damage = figure_properties[target->type].max_damage + 1;
        target->is_corpse = 1;
        target->is_targetable = 0;
        target->wait_ticks = 0;
        figure_play_die_sound(target);
        if (figure_properties[target->type].is_player_legion_unit) {
            update_formation_morale_after_death(&legion_formations[target->formation_id]);
        } else {
            update_formation_morale_after_death(&enemy_formations[target->formation_id]);
        }
        clear_targeting_on_unit_death(target);
    }
    if (figure_properties[target->type].is_player_legion_unit) {
        legion_formations[target->formation_id].missile_attack_timeout = 6;
    } else if (figure_properties[target->type].is_herd_animal) {
        herd_formations[target->formation_id].missile_attack_timeout = 6;
    } else if (figure_properties[target->type].is_enemy_unit || figure_properties[target->type].is_caesar_legion_unit) {
        enemy_formations[target->formation_id].missile_attack_timeout = 6;
    }
    // clear targeting
    shooter->target_figure_id = 0;
    figure__remove_ranged_targeter_from_list(target, shooter);
    figure_delete(projectile);
}

static int get_target_on_tile(struct figure_t *projectile)
{
    struct figure_t *shooter = &figures[projectile->building_id];
    if (map_figures.items[projectile->grid_offset] > 0) {
        int figure_id = map_figures.items[projectile->grid_offset];
        while (figure_id) {
            struct figure_t *target = &figures[figure_id];
            if (figure_is_alive(target) && target->is_targetable) {
                if (figure_properties[shooter->type].is_friendly_armed_unit || figure_properties[shooter->type].is_player_legion_unit) {
                    if (is_valid_target_for_player_unit(target)) {
                        return target->id;
                    }
                } else if (figure_properties[shooter->type].is_enemy_unit) {
                    if (is_valid_target_for_enemy_unit(target)) {
                        return target->id;
                    }
                }
            }
            figure_id = target->next_figure_id_on_same_tile;
        }
    }
    return 0;
}

static int closest_house_with_room(int x, int y)
{
    int min_dist = 1000;
    int min_building_id = 0;
    for (int i = 1; i <= extra.highest_id_in_use; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state == BUILDING_STATE_IN_USE && b->house_size
            && b->house_population_room > 0) {
            if (!b->immigrant_figure_id) {
                int dist = calc_maximum_distance(x, y, b->x, b->y);
                if (dist < min_dist) {
                    min_dist = dist;
                    min_building_id = i;
                }
            }
        }
    }
    return min_building_id;
}

static void figure_image_set_cart_offset(struct figure_t *f, int direction)
{
    f->x_offset_cart = CART_OFFSETS_X[direction];
    f->y_offset_cart = CART_OFFSETS_Y[direction];
}

static void update_migrant_dir_and_image(struct figure_t *f)
{
    figure_image_increase_offset(f, 12);
    f->image_id = 4442 + figure_image_direction(f) + 8 * f->image_offset;
    if (f->action_state == FIGURE_ACTION_IMMIGRANT_ARRIVING || f->action_state == FIGURE_ACTION_EMIGRANT_LEAVING) {
        int dir = figure_image_direction(f);
        f->cart_image_id = 4778 + dir;
        figure_image_set_cart_offset(f, (dir + 4) % 8);
    }
}

static int create_delivery_boy(int leader_id, struct figure_t *f)
{
    struct figure_t *boy = figure_create(FIGURE_DELIVERY_BOY, f->x, f->y, 0);
    boy->is_targetable = 1;
    boy->terrain_usage = TERRAIN_USAGE_ROADS;
    boy->leading_figure_id = leader_id;
    boy->collecting_item_id = f->collecting_item_id;
    boy->building_id = f->building_id;
    return boy->id;
}

static int fight_fire(struct figure_t *f)
{
    if (!building_list_data.burning.size) {
        return 0;
    }
    switch (f->action_state) {
        case FIGURE_ACTION_PREFECT_CREATED:
        case FIGURE_ACTION_PREFECT_ENTERING_EXITING:
        case FIGURE_ACTION_PREFECT_GOING_TO_FIRE:
        case FIGURE_ACTION_PREFECT_AT_FIRE:
            return 0;
    }
    f->wait_ticks_missile++;
    if (f->wait_ticks_missile < 20) {
        return 0;
    }
    int distance;
    int ruin_id = 0;
    int min_occupied_building_id = 0;
    int min_occupied_dist = distance = 10000;
    int *burning = building_list_data.burning.items;
    for (int i = 0; i < building_list_data.burning.size; i++) {
        int building_id = burning[i];
        struct building_t *b = &all_buildings[building_id];
        if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_BURNING_RUIN && !b->ruin_has_plague) {
            int dist = calc_maximum_distance(f->x, f->y, b->x, b->y);
            if (b->figure_id4) {
                if (dist < min_occupied_dist) {
                    min_occupied_dist = dist;
                    min_occupied_building_id = building_id;
                }
            } else if (dist < distance) {
                distance = dist;
                ruin_id = building_id;
            }
        }
    }
    if (!ruin_id && min_occupied_dist <= 2) {
        ruin_id = min_occupied_building_id;
        distance = 2;
    }
    if (ruin_id > 0 && distance <= 25) {
        struct building_t *ruin = &all_buildings[ruin_id];
        f->wait_ticks_missile = 0;
        f->action_state = FIGURE_ACTION_PREFECT_GOING_TO_FIRE;
        f->destination_x = ruin->road_access_x;
        f->destination_y = ruin->road_access_y;
        f->destination_building_id = ruin_id;
        figure_route_remove(f);
        ruin->figure_id4 = f->id;
        return 1;
    }
    return 0;
}

static int determine_destination(int x, int y, int type1, int type2)
{
    building_list_data.small.size = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE) {
            continue;
        }
        if (b->type != type1 && b->type != type2) {
            continue;
        }
        if (b->type == BUILDING_HIPPODROME && b->prev_part_building_id) {
            continue;
        }
        building_list_small_add(i);
    }
    if (building_list_data.small.size <= 0) {
        return 0;
    }
    int min_building_id = 0;
    int min_distance = 10000;
    for (int i = 0; i < building_list_data.small.size; i++) {
        struct building_t *b = &all_buildings[building_list_data.small.items[i]];
        int days_left;
        if (b->type == type1) {
            days_left = b->data.entertainment.days1;
        } else if (b->type == type2) {
            days_left = b->data.entertainment.days2;
        } else {
            days_left = 0;
        }
        int dist = days_left + calc_maximum_distance(x, y, b->x, b->y);
        if (dist < min_distance) {
            min_distance = dist;
            min_building_id = building_list_data.small.items[i];
        }
    }
    return min_building_id;
}

static void figure_create_missile(struct figure_t *shooter, struct map_point_t *target_tile, int type)
{
    struct figure_t *missile = figure_create(type, shooter->x, shooter->y, DIR_0_TOP);
    if (missile->id) {
        missile->missile_offset = type == FIGURE_BOLT ? 60 : 10;
        missile->building_id = shooter->id;
        missile->destination_x = target_tile->x;
        missile->destination_y = target_tile->y;
        figure_movement_set_cross_country_direction(missile, missile->cross_country_x, missile->cross_country_y, 15 * target_tile->x, 15 * target_tile->y, 1);
    }
}

static void shoot_enemy_missile(struct figure_t *f, struct map_point_t *tile)
{
    f->is_shooting = 1;
    f->attack_image_offset = 1;
    figure_create_missile(f, tile, figure_properties[f->type].missile_type);
    if (figure_properties[f->type].missile_type == FIGURE_ARROW) {
        play_sound_effect(SOUND_EFFECT_ARROW);
    }
    f->wait_ticks_missile = 0;
    // clear targeting
    figure__remove_ranged_targeter_from_list(&figures[f->target_figure_id], f);
    f->target_figure_id = 0;
}

static void spawn_enemy(struct figure_t *f, struct formation_t *m)
{
    if (f->wait_ticks) {
        f->wait_ticks--;
        if (!f->wait_ticks) {
            if (f->index_in_formation % 4 < 1) {
                if (m->layout == FORMATION_ENEMY_MOB) {
                    play_speech_file("wavs/drums.wav");
                } else {
                    play_speech_file("wavs/horn1.wav");
                }
            }
            f->is_invisible = 0;
            f->action_state = FIGURE_ACTION_ENEMY_ADVANCING;
        }
    }
}

static void map_figure_update(struct figure_t *f)
{
    if (!map_grid_is_valid_offset(f->grid_offset)) {
        return;
    }
    struct figure_t *next = &figures[map_figures.items[f->grid_offset]];
    while (next->id) {
        if (next->id == f->id) {
            return;
        }
        next = &figures[next->next_figure_id_on_same_tile];
    }
}

static int target_ranged_targeter_list_full(struct figure_t *target)
{
    for (int j = 0; j < MAX_RANGED_TARGETERS_PER_UNIT; j++) {
        if (!target->ranged_targeter_ids[j]) {
            return 0;
        }
    }
    return 1;
}

static void update_ranged_targeting(struct figure_t *shooter, struct figure_t *target, struct map_point_t *tile)
{
    if (shooter->target_figure_id && shooter->target_figure_id != target->id) {
        // if switching targets, remove targeter from previous target's ranged targeters list
        struct figure_t *previous_target = &figures[shooter->target_figure_id];
        figure__remove_ranged_targeter_from_list(previous_target, shooter);
    }
    shooter->target_figure_id = target->id;
    if (!figure__targeted_by_ranged_unit(target, shooter)) {
        // update new target's ranged targeters list
        for (int i = 0; i < MAX_RANGED_TARGETERS_PER_UNIT; i++) {
            if (!target->ranged_targeter_ids[i]) {
                target->ranged_targeter_ids[i] = shooter->id;
                break;
            }
        };
    }
    tile->x = target->x;
    tile->y = target->y;
}

static int set_missile_target(struct figure_t *shooter, struct map_point_t *tile)
{
    int closest_target_distance = figure_properties[shooter->type].max_range;
    struct figure_t *closest_eligible_target = 0;
    struct figure_t *closest_eligible_overhit_target = 0;
    for (int i = 1; i < MAX_FIGURES; i++) {
        struct figure_t *potential_target = &figures[i];
        if (!figure_is_alive(potential_target) || !potential_target->is_targetable) {
            continue;
        }
        int potential_target_distance = calc_maximum_distance(shooter->x, shooter->y, potential_target->x, potential_target->y);
        if ((potential_target_distance < closest_target_distance)) {
            // if potential target is the current target, it's eligible (could still end up being switched for a nearer one)
            if (figure__targeted_by_ranged_unit(potential_target, shooter)) {
                closest_target_distance = potential_target_distance;
                closest_eligible_target = potential_target;
                continue;
            }
            if (figure_properties[shooter->type].is_friendly_armed_unit || figure_properties[shooter->type].is_player_legion_unit) {
                if (is_valid_target_for_player_unit(potential_target) && can_see_target(shooter, potential_target)) {
                    if (shooter->is_military_trained && target_ranged_targeter_list_full(potential_target)) {
                        // prefer targets that aren't already aimed at to prevent overhit, but keep overhit targets as a second option
                        closest_eligible_overhit_target = potential_target;
                    } else {
                        closest_target_distance = potential_target_distance;
                        closest_eligible_target = potential_target;
                    }
                    continue;
                }
            } else if (figure_properties[shooter->type].is_enemy_unit) {
                // skip (closer) unarmed target if already targeting a dangerous foe
                if ((figure_properties[potential_target->type].is_unarmed_civilian_unit || figure_properties[potential_target->type].is_empire_trader || potential_target->type == FIGURE_NATIVE_TRADER)
                    && closest_eligible_target
                    && (figure_properties[closest_eligible_target->type].is_friendly_armed_unit || figure_properties[closest_eligible_target->type].is_player_legion_unit || closest_eligible_target->type == FIGURE_WOLF || figure_properties[closest_eligible_target->type].is_caesar_legion_unit)) {
                    continue;
                }
                if (is_valid_target_for_enemy_unit(potential_target) && can_see_target(shooter, potential_target)) {
                    if (target_ranged_targeter_list_full(potential_target)) {
                        // prefer targets that aren't already aimed at to prevent overhit, but keep overhit targets as a second option
                        closest_eligible_overhit_target = potential_target;
                    } else {
                        closest_target_distance = potential_target_distance;
                        closest_eligible_target = potential_target;
                    }
                    continue;
                }
            }
        }
    }
    if (closest_eligible_target) {
        update_ranged_targeting(shooter, closest_eligible_target, tile);
        return 1;
    } else if (closest_eligible_overhit_target) {
        update_ranged_targeting(shooter, closest_eligible_overhit_target, tile);
        return 1;
    }
    return 0;
}

static int calc_missile_shooter_direction(int x_from, int y_from, int x_to, int y_to)
{
    int dx = x_from > x_to ? x_from - x_to : x_to - x_from;
    int dy = y_from > y_to ? y_from - y_to : y_to - y_from;
    int percentage;
    if (dx > dy) {
        percentage = calc_percentage(dx, dy);
    } else if (dx == dy) {
        percentage = 100;
    } else {
        percentage = -calc_percentage(dy, dx);
    }
    if (x_from == x_to) {
        if (y_from < y_to) {
            return DIR_4_BOTTOM;
        } else {
            return DIR_0_TOP;
        }
    } else if (x_from > x_to) {
        if (y_from == y_to) {
            return DIR_6_LEFT;
        } else if (y_from > y_to) {
            if (percentage >= 400) {
                return DIR_6_LEFT;
            } else if (percentage > -400) {
                return DIR_7_TOP_LEFT;
            } else {
                return DIR_0_TOP;
            }
        } else {
            if (percentage >= 400) {
                return DIR_6_LEFT;
            } else if (percentage > -400) {
                return DIR_5_BOTTOM_LEFT;
            } else {
                return DIR_4_BOTTOM;
            }
        }
    } else { // x_from < x_to
        if (y_from == y_to) {
            return DIR_2_RIGHT;
        } else if (y_from > y_to) {
            if (percentage >= 400) {
                return DIR_2_RIGHT;
            } else if (percentage > -400) {
                return DIR_1_TOP_RIGHT;
            } else {
                return DIR_0_TOP;
            }
        } else {
            if (percentage >= 400) {
                return DIR_2_RIGHT;
            } else if (percentage > -400) {
                return DIR_3_BOTTOM_RIGHT;
            } else {
                return DIR_4_BOTTOM;
            }
        }
    }
}

static void ranged_enemy_action(struct figure_t *f)
{
    struct formation_t *m = &enemy_formations[f->formation_id];
    struct map_point_t tile = { -1, -1 };
    if (f->is_shooting) {
        f->attack_image_offset++;
        if (f->attack_image_offset > 100) {
            f->attack_image_offset = 0;
            f->is_shooting = 0;
        }
    } else {
        f->wait_ticks_missile++;
        if (f->wait_ticks_missile > 250) {
            f->wait_ticks_missile = 250;
        }
    }
    switch (f->action_state) {
        case FIGURE_ACTION_ENEMY_SPAWNING:
            spawn_enemy(f, m);
            break;
        case FIGURE_ACTION_ENEMY_REGROUPING:
            map_figure_update(f);
            f->image_offset = 0;
            if (f->wait_ticks_missile > figure_properties[f->type].missile_delay && set_missile_target(f, &tile)) {
                f->direction = calc_missile_shooter_direction(f->x, f->y, tile.x, tile.y);
                shoot_enemy_missile(f, &tile);
            }
            break;
        case FIGURE_ACTION_ENEMY_ADVANCING:
            f->destination_x = m->destination_x + FORMATION_LAYOUT_POSITION_X[m->layout][f->index_in_formation];
            f->destination_y = m->destination_y + FORMATION_LAYOUT_POSITION_Y[m->layout][f->index_in_formation];
            walk_ticks(f, f->speed_multiplier, 0);
            if ((f->type == FIGURE_ENEMY_HUN_MOUNTED_ARCHER || f->type == FIGURE_ENEMY_GOTH_MOUNTED_ARCHER || f->type == FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER)
            && f->wait_ticks_missile > figure_properties[f->type].missile_delay
            && set_missile_target(f, &tile)) {
                shoot_enemy_missile(f, &tile);
            }
            if (f->direction == DIR_FIGURE_AT_DESTINATION
                || f->direction == DIR_FIGURE_REROUTE
                || f->direction == DIR_FIGURE_LOST) {
                figure_route_remove(f);
                f->action_state = FIGURE_ACTION_ENEMY_REGROUPING;
            }
            break;
        case FIGURE_ACTION_ENEMY_ENGAGED:
            if (f->target_figure_id && calc_maximum_distance(f->x, f->y, f->destination_x, f->destination_y) < figure_properties[f->type].max_range) {
                figure_route_remove(f);
                f->destination_x = f->x;
                f->destination_y = f->y;
                f->image_offset = 0;
                if (f->wait_ticks_missile > figure_properties[f->type].missile_delay && set_missile_target(f, &tile)) {
                    f->direction = calc_missile_shooter_direction(f->x, f->y, tile.x, tile.y);
                    shoot_enemy_missile(f, &tile);
                    break;
                }
            } else {
                walk_ticks(f, f->speed_multiplier, 0);
                if (f->direction == DIR_FIGURE_AT_DESTINATION
                    || f->direction == DIR_FIGURE_REROUTE
                    || f->direction == DIR_FIGURE_LOST) {
                    figure_route_remove(f);
                    f->action_state = FIGURE_ACTION_ENEMY_REGROUPING;
                }
            }
            break;
    }
}

static int figure__targeted_by_melee_unit(struct figure_t *f, struct figure_t *melee_targeter)
{
    for (int i = 0; i < MAX_MELEE_TARGETERS_PER_UNIT; i++) {
        if (f->melee_targeter_ids[i] == melee_targeter->id) {
            return 1;
        }
    }
    return 0;
}

static struct figure_t *melee_unit__set_closest_target(struct figure_t *f)
{
    struct figure_t *closest_eligible_target = 0;
    int closest_target_distance;
    switch (f->type) {
        case FIGURE_PREFECT:
            closest_target_distance = PREFECT_TARGET_ACQUISITION_RANGE;
            break;
        case FIGURE_WOLF:
            closest_target_distance = 5;
            break;
        default:
            closest_target_distance = 20;
            break;
    }
    for (int i = 1; i < MAX_FIGURES; i++) {
        struct figure_t *potential_target = &figures[i];
        if (!figure_is_alive(potential_target) || !potential_target->is_targetable) {
            continue;
        }
        int potential_target_distance = calc_maximum_distance(f->x, f->y, potential_target->x, potential_target->y);
        if (potential_target_distance < closest_target_distance) {
            // skip potential enemy target if its targeter list is full, unless the current targeter is already in it
            int potential_target_melee_targeter_list_full = 1;
            for (int j = 0; j < MAX_MELEE_TARGETERS_PER_UNIT; j++) {
                if (!potential_target->melee_targeter_ids[j]) {
                    potential_target_melee_targeter_list_full = 0;
                    break;
                }
            }
            if (potential_target_melee_targeter_list_full) {
                if (figure__targeted_by_melee_unit(potential_target, f)) {
                    closest_target_distance = potential_target_distance;
                    closest_eligible_target = potential_target;
                    // the remaining criteria (friendly, enemy) have already been checked on previous targeting, continue to next potential target
                    continue;
                } else {
                    continue;
                }
            }
            if (figure_properties[f->type].is_friendly_armed_unit || figure_properties[f->type].is_player_legion_unit) {
                if (is_valid_target_for_player_unit(potential_target) && can_see_target(f, potential_target)) { // can_see_target is expensive, call it last (allows for short-circuiting)
                    closest_target_distance = potential_target_distance;
                    closest_eligible_target = potential_target;
                    continue;
                }
            } else if (f->type == FIGURE_WOLF) {
                if (potential_target->type != FIGURE_WOLF && can_see_target(f, potential_target)) {
                    closest_target_distance = potential_target_distance;
                    closest_eligible_target = potential_target;
                    continue;
                }
            } else if (figure_properties[f->type].is_enemy_unit) {
                if (is_valid_target_for_enemy_unit(potential_target) && can_see_target(f, potential_target)) {
                    closest_target_distance = potential_target_distance;
                    closest_eligible_target = potential_target;
                    continue;
                }
            } else if (figure_properties[f->type].is_caesar_legion_unit) {
                if (is_valid_target_for_caesar_unit(potential_target) && can_see_target(f, potential_target)) {
                    closest_target_distance = potential_target_distance;
                    closest_eligible_target = potential_target;
                    continue;
                }
            }
        }
    }
    if (closest_eligible_target) {
        // set target and destination for figure
        if (f->target_figure_id && f->target_figure_id != closest_eligible_target->id) {
            // if switching targets, remove targeter from previous target's melee targeters list
            struct figure_t *previous_target = &figures[f->target_figure_id];
            figure__remove_melee_targeter_from_list(previous_target, f);
        }
        f->target_figure_id = closest_eligible_target->id;
        f->destination_x = closest_eligible_target->x;
        f->destination_y = closest_eligible_target->y;
        figure_route_remove(f);
        if (!figure__targeted_by_melee_unit(closest_eligible_target, f)) {
            // update new target's melee targeter list
            for (int i = 0; i < MAX_MELEE_TARGETERS_PER_UNIT; i++) {
                if (!closest_eligible_target->melee_targeter_ids[i]) {
                    closest_eligible_target->melee_targeter_ids[i] = f->id;
                    break;
                }
            };
        }
    }
    return closest_eligible_target;
}

static void melee_enemy_action(struct figure_t *f)
{
    struct formation_t *m = &enemy_formations[f->formation_id];
    switch (f->action_state) {
        case FIGURE_ACTION_ENEMY_SPAWNING:
            spawn_enemy(f, m);
            break;
        case FIGURE_ACTION_ENEMY_REGROUPING:
            map_figure_update(f);
            f->image_offset = 0;
            break;
        case FIGURE_ACTION_ENEMY_ADVANCING:
            f->destination_x = m->destination_x + FORMATION_LAYOUT_POSITION_X[m->layout][f->index_in_formation];
            f->destination_y = m->destination_y + FORMATION_LAYOUT_POSITION_Y[m->layout][f->index_in_formation];
            walk_ticks(f, f->speed_multiplier, 0);
            if (f->direction == DIR_FIGURE_AT_DESTINATION
                || f->direction == DIR_FIGURE_REROUTE
                || f->direction == DIR_FIGURE_LOST) {
                figure_route_remove(f);
                f->action_state = FIGURE_ACTION_ENEMY_REGROUPING;
            }
            break;
        case FIGURE_ACTION_ENEMY_ENGAGED:
        {
            struct figure_t *target_unit = melee_unit__set_closest_target(f);
            if (target_unit) {
                f->destination_x = target_unit->x;
                f->destination_y = target_unit->y;
                walk_ticks(f, f->speed_multiplier, 0);
            } else {
                walk_ticks(f, f->speed_multiplier, 0);
            }
            if (f->direction == DIR_FIGURE_AT_DESTINATION
                || f->direction == DIR_FIGURE_REROUTE
                || f->direction == DIR_FIGURE_LOST) {
                figure_route_remove(f);
                f->action_state = FIGURE_ACTION_ENEMY_REGROUPING;
            }
            break;
        }
    }
}

static void figure_editor_flag_action(struct figure_t *f)
{
    figure_image_increase_offset(f, 16);
    f->image_id = 2916 + f->image_offset / 2;
    map_figure_delete(f);
    struct map_point_t point = { 0, 0 };
    if (f->resource_id == MAP_FLAG_ENTRY) {
        point.x = scenario.entry_point.x;
        point.y = scenario.entry_point.y;
        f->cart_image_id = 2926;
    } else if (f->resource_id == MAP_FLAG_EXIT) {
        point.x = scenario.exit_point.x;
        point.y = scenario.exit_point.y;
        f->cart_image_id = 2927;
    } else if (f->resource_id == MAP_FLAG_RIVER_ENTRY) {
        point.x = scenario.river_entry_point.x;
        point.y = scenario.river_entry_point.y;
        f->cart_image_id = 2928;
    } else if (f->resource_id == MAP_FLAG_RIVER_EXIT) {
        point.x = scenario.river_exit_point.x;
        point.y = scenario.river_exit_point.y;
        f->cart_image_id = 2929;
    } else if (f->resource_id >= MAP_FLAG_EARTHQUAKE_MIN && f->resource_id <= MAP_FLAG_EARTHQUAKE_MAX) {
        point = scenario.earthquake_points[f->resource_id - MAP_FLAG_EARTHQUAKE_MIN];
        f->cart_image_id = 2924;
    } else if (f->resource_id >= MAP_FLAG_INVASION_MIN && f->resource_id <= MAP_FLAG_INVASION_MAX) {
        point = scenario.invasion_points[f->resource_id - MAP_FLAG_INVASION_MIN];
        f->cart_image_id = 2925;
    } else if (f->resource_id >= MAP_FLAG_FISHING_MIN && f->resource_id <= MAP_FLAG_FISHING_MAX) {
        point = scenario.fishing_points[f->resource_id - MAP_FLAG_FISHING_MIN];
        f->cart_image_id = 5425;
    } else if (f->resource_id >= MAP_FLAG_HERD_MIN && f->resource_id <= MAP_FLAG_HERD_MAX) {
        point = scenario.herd_points[f->resource_id - MAP_FLAG_HERD_MIN];
        f->cart_image_id = 5426;
    }
    f->x = point.x;
    f->y = point.y;
    f->grid_offset = map_grid_offset(f->x, f->y);
    f->cross_country_x = 15 * f->x + 7;
    f->cross_country_y = 15 * f->y + 7;
    map_figure_add(f);
}

static void get_trade_center_location(struct figure_t *f, int *x, int *y)
{
    if (city_data.building.trade_center_building_id) {
        struct building_t *trade_center = &all_buildings[city_data.building.trade_center_building_id];
        *x = trade_center->x;
        *y = trade_center->y;
    } else {
        *x = f->x;
        *y = f->y;
    }
}

static int city_trade_next_docker_export_resource(void)
{
    city_data.trade.docker_export_resource++;
    if (city_data.trade.docker_export_resource >= RESOURCE_TYPES_MAX) {
        city_data.trade.docker_export_resource = RESOURCE_WHEAT;
    }
    return city_data.trade.docker_export_resource;
}

static int fetch_export_resource(struct figure_t *f, struct building_t *dock)
{
    int ship_id = dock->data.dock.trade_ship_id;
    if (!ship_id) {
        return 0;
    }
    struct figure_t *ship = &figures[ship_id];
    if (ship->action_state != FIGURE_ACTION_TRADE_SHIP_MOORED || ship->trader_amount_bought >= 12) {
        return 0;
    }
    int x, y;
    get_trade_center_location(f, &x, &y);
    struct map_point_t tile;
    int exportable[RESOURCE_TYPES_MAX];
    exportable[RESOURCE_NONE] = 0;
    for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
        exportable[r] = can_export_resource_to_trade_city(ship->empire_city_id, r);
    }
    int resource = city_trade_next_docker_export_resource();
    for (int i = RESOURCE_WHEAT; i < RESOURCE_TYPES_MAX && !exportable[resource]; i++) {
        resource = city_trade_next_docker_export_resource();
    }
    int min_building_id = 0;
    if (exportable[resource]) {
        int min_distance = 10000;
        for (int i = 1; i < MAX_BUILDINGS; i++) {
            struct building_t *b = &all_buildings[i];
            if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_WAREHOUSE) {
                continue;
            }
            if (!b->has_road_access) {
                continue;
            }
            int distance_penalty = 32;
            struct building_t *space = b;
            for (int s = 0; s < 8; s++) {
                space = &all_buildings[space->next_part_building_id];
                if (space->id && space->subtype.warehouse_resource_id == resource && space->loads_stored > 0) {
                    distance_penalty--;
                }
            }
            if (distance_penalty < 32) {
                int distance = calc_maximum_distance(b->x, b->y, x, y);
                // prefer fuller warehouse
                distance += distance_penalty;
                if (distance < min_distance) {
                    min_distance = distance;
                    min_building_id = i;
                }
            }
        }
        if (min_building_id) {
            struct building_t *min = &all_buildings[min_building_id];
            if (map_has_road_access(min->x, min->y, 3, &tile) && min->has_road_access == 1) {
                tile.x = min->x;
                tile.y = min->y;
            }
        }
    }
    if (!min_building_id) {
        return 0;
    }
    ship->trader_amount_bought++;
    f->destination_building_id = min_building_id;
    f->action_state = FIGURE_ACTION_DOCKER_EXPORT_GOING_TO_WAREHOUSE;
    f->wait_ticks = 0;
    f->destination_x = tile.x;
    f->destination_y = tile.y;
    f->resource_id = resource;
    return 1;
}

static void generate_protestor(struct building_t *b)
{
    city_data.sentiment.protesters++;
    if (b->house_criminal_active < 1) {
        b->house_criminal_active = 1;
        int x_road, y_road;
        if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
            struct figure_t *f = figure_create(FIGURE_PROTESTER, x_road, y_road, DIR_4_BOTTOM);
            f->is_targetable = 1;
            f->terrain_usage = TERRAIN_USAGE_ROADS;
            f->wait_ticks = 10 + (b->house_figure_generation_delay & 0xf);
            city_data.ratings.peace_num_criminals++;
        }
    }
}

static void generate_mugger(struct building_t *b)
{
    city_data.sentiment.criminals++;
    if (b->house_criminal_active < 2) {
        b->house_criminal_active = 2;
        int x_road, y_road;
        if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
            struct figure_t *f = figure_create(FIGURE_CRIMINAL, x_road, y_road, DIR_4_BOTTOM);
            f->is_targetable = 1;
            f->terrain_usage = TERRAIN_USAGE_ROADS;
            f->wait_ticks = 10 + (b->house_figure_generation_delay & 0xf);
            city_data.ratings.peace_num_criminals++;
            if (city_data.finance.this_year.income.taxes > 20) {
                int money_stolen = city_data.finance.this_year.income.taxes / 4;
                if (money_stolen > 400) {
                    money_stolen = 400 - random_data.random1_7bit / 2;
                }
                city_message_post(1, MESSAGE_THEFT, money_stolen, f->grid_offset);
                city_data.finance.stolen_this_year += money_stolen;
                city_finance_process_misc(money_stolen);
            }
        }
    }
}

static void remove_resource_from_warehouse(struct figure_t *f)
{
    if (figure_is_alive(f)) {
        int err = building_warehouse_remove_resource(&all_buildings[f->building_id], f->resource_id, 1);
        if (err) {
            figure_delete(f);
        }
    }
}

static void building_workshop_add_raw_material(struct building_t *b)
{
    if (b->id > 0 && building_is_workshop(b->type)) {
        b->loads_stored++; // BUG: any raw material accepted
    }
}

static void reroute_cartpusher(struct figure_t *f)
{
    figure_route_remove(f);
    if (terrain_land_citizen.items[f->grid_offset] != CITIZEN_2_PASSABLE_TERRAIN) {
        f->action_state = FIGURE_ACTION_CARTPUSHER_INITIAL;
    }
    f->wait_ticks = 0;
}

static void update_image_cartpusher(struct figure_t *f)
{
    int dir = figure_image_normalize_direction(f->direction < 8 ? f->direction : f->previous_tile_direction);

    f->image_id = 4338 + dir + 8 * f->image_offset;
    if (f->cart_image_id) {
        f->cart_image_id += dir;
        figure_image_set_cart_offset(f, dir);
        if (f->loads_sold_or_carrying >= 8) {
            f->y_offset_cart -= 40;
        }
    }
}

static int building_granary_for_storing(int x, int y, int resource, int force_on_stockpile, int *understaffed, struct map_point_t *dst)
{
    if (scenario.rome_supplies_wheat) {
        return 0;
    }
    if (!resource_is_food(resource)) {
        return 0;
    }
    if (city_data.resource.stockpiled[resource] && !force_on_stockpile) {
        return 0;
    }
    int min_dist = INFINITE;
    int min_building_id = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_GRANARY) {
            continue;
        }
        if (!b->has_road_access) {
            continue;
        }
        if (calc_percentage(b->num_workers, building_properties[b->type].n_laborers) < 100) {
            if (understaffed) {
                *understaffed += 1;
            }
            continue;
        }
        struct building_storage_t *s = &storages[b->storage_id].storage;
        if (s->resource_state[resource] == BUILDING_STORAGE_STATE_NOT_ACCEPTING || s->empty_all) {
            continue;
        }
        if (b->data.granary.resource_stored[RESOURCE_NONE] >= ONE_LOAD) {
            // there is room
            int dist = calc_maximum_distance(b->x + 1, b->y + 1, x, y);
            if (dist < min_dist) {
                min_dist = dist;
                min_building_id = i;
            }
        }
    }
    // deliver to center of granary
    struct building_t *min = &all_buildings[min_building_id];
    dst->x = min->x + 1;
    dst->y = min->y + 1;
    return min_building_id;
}

static int resource_to_workshop_type(int resource)
{
    switch (resource) {
        case RESOURCE_OLIVES:
            return WORKSHOP_OLIVES_TO_OIL;
        case RESOURCE_VINES:
            return WORKSHOP_VINES_TO_WINE;
        case RESOURCE_CLAY:
            return WORKSHOP_CLAY_TO_POTTERY;
        case RESOURCE_TIMBER:
            return WORKSHOP_TIMBER_TO_FURNITURE;
        case RESOURCE_IRON:
            return WORKSHOP_IRON_TO_WEAPONS;
        default:
            return WORKSHOP_NONE;
    }
}

static int building_get_workshop_for_raw_material_with_room(int x, int y, int resource, struct map_point_t *dst)
{
    if (city_data.resource.stockpiled[resource]) {
        return 0;
    }
    int output_type = resource_to_workshop_type(resource);
    if (output_type == WORKSHOP_NONE) {
        return 0;
    }
    int min_dist = INFINITE;
    struct building_t *min_building = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE || !building_is_workshop(b->type)) {
            continue;
        }
        if (!b->has_road_access) {
            continue;
        }
        if (b->subtype.workshop_type == output_type && b->loads_stored < 2) {
            int dist = calc_maximum_distance(b->x, b->y, x, y);
            if (b->loads_stored > 0) {
                dist += 20;
            }
            if (dist < min_dist) {
                min_dist = dist;
                min_building = b;
            }
        }
    }
    if (min_building) {
        dst->x = min_building->road_access_x;
        dst->y = min_building->road_access_y;
        return min_building->id;
    }
    return 0;
}

static void set_destination(struct figure_t *f, int action, int building_id, int x_dst, int y_dst)
{
    f->destination_building_id = building_id;
    f->action_state = action;
    f->wait_ticks = 0;
    f->destination_x = x_dst;
    f->destination_y = y_dst;
}

static void set_cart_graphic(struct figure_t *f)
{
    f->cart_image_id = 4650 + resource_images[f->resource_id].cart_img_id + resource_image_offset(f->resource_id, RESOURCE_IMAGE_CART);
}

static void map_terrain_add_with_radius(int x, int y, int size, int radius, int terrain)
{
    int x_min, y_min, x_max, y_max;
    map_grid_get_area(x, y, size, radius, &x_min, &y_min, &x_max, &y_max);

    for (int yy = y_min; yy <= y_max; yy++) {
        for (int xx = x_min; xx <= x_max; xx++) {
            terrain_grid.items[map_grid_offset(xx, yy)] |= terrain;
        }
    }
}

static int tower_sentry_shooting(struct figure_t *f)
{
    struct map_point_t tile = { -1, -1 };
    if (f->is_shooting) {
        f->attack_image_offset++;
        if (f->attack_image_offset > 100) {
            f->attack_image_offset = 0;
            f->is_shooting = 0;
        }
        f->image_id = 6705 + figure_image_direction(f) + 96 + 8 * TOWER_SENTRY_FIRING_OFFSETS[f->attack_image_offset / 2];
        return 1;
    }
    if (!f->in_building_wait_ticks && f->wait_ticks_missile > figure_properties[f->type].missile_delay && set_missile_target(f, &tile)) {
        f->progress_on_tile = 15; // align to wall
        f->direction = calc_missile_shooter_direction(f->x, f->y, tile.x, tile.y);
        figure_create_missile(f, &tile, figure_properties[f->type].missile_type);
        f->wait_ticks_missile = 0;
        f->is_shooting = 1;
        return 1;
    }
    return 0;
}

static int figure_trade_caravan_can_sell(struct figure_t *trader, int warehouse_id, int city_id)
{
    struct building_t *warehouse = &all_buildings[warehouse_id];
    if (warehouse->type != BUILDING_WAREHOUSE) {
        return 0;
    }
    if (trader->loads_sold_or_carrying >= 8) {
        return 0;
    }
    struct building_storage_t *storage = &storages[warehouse->storage_id].storage;
    if (storage->empty_all) {
        return 0;
    }
    int num_importable = 0;
    for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
        if (storage->resource_state[r] != BUILDING_STORAGE_STATE_NOT_ACCEPTING) {
            if (can_import_resource_from_trade_city(city_id, r)) {
                num_importable++;
            }
        }
    }
    if (num_importable <= 0) {
        return 0;
    }
    int can_import = 0;
    int resource = city_data.trade.caravan_import_resource;
    if (storage->resource_state[resource] != BUILDING_STORAGE_STATE_NOT_ACCEPTING &&
        can_import_resource_from_trade_city(city_id, resource)) {
        can_import = 1;
    } else {
        for (int i = RESOURCE_WHEAT; i < RESOURCE_TYPES_MAX; i++) {
            resource = city_trade_next_caravan_import_resource();
            if (storage->resource_state[resource] != BUILDING_STORAGE_STATE_NOT_ACCEPTING &&
                    can_import_resource_from_trade_city(city_id, resource)) {
                can_import = 1;
                break;
            }
        }
    }
    if (can_import) {
        // at least one resource can be imported and accepted by this warehouse
        // check if warehouse can store any importable goods
        struct building_t *space = warehouse;
        for (int s = 0; s < 8; s++) {
            space = &all_buildings[space->next_part_building_id];
            if (space->id > 0 && space->loads_stored < 4) {
                if (!space->loads_stored) {
                    // empty space
                    return 1;
                }
                if (can_import_resource_from_trade_city(city_id, space->subtype.warehouse_resource_id)) {
                    return 1;
                }
            }
        }
    }
    return 0;
}

static int figure_trade_caravan_can_buy(struct figure_t *trader, int warehouse_id, int city_id)
{
    struct building_t *warehouse = &all_buildings[warehouse_id];
    if (warehouse->type != BUILDING_WAREHOUSE) {
        return 0;
    }
    if (trader->trader_amount_bought >= 8) {
        return 0;
    }
    struct building_t *space = warehouse;
    for (int i = 0; i < 8; i++) {
        space = &all_buildings[space->next_part_building_id];
        if (space->id > 0 && space->loads_stored > 0 &&
            can_export_resource_to_trade_city(city_id, space->subtype.warehouse_resource_id)) {
            return 1;
        }
    }
    return 0;
}

static void figure_create_homeless(int x, int y, int num_people)
{
    struct figure_t *f = figure_create(FIGURE_HOMELESS, x, y, DIR_0_TOP);
    f->action_state = FIGURE_ACTION_HOMELESS_CREATED;
    f->is_targetable = 1;
    f->terrain_usage = TERRAIN_USAGE_PREFER_ROADS;
    f->wait_ticks = 0;
    f->migrant_num_people = num_people;
    city_data.population.lost_homeless += num_people;
    remove_from_census(num_people);
    recalculate_population();
}

static void trader_record_sold_resource(int trader_id, int resource)
{
    figure_trader_data.traders[trader_id].sold_amount++;
    figure_trader_data.traders[trader_id].sold_resources[resource]++;
}

static void trader_record_bought_resource(int trader_id, int resource)
{
    figure_trader_data.traders[trader_id].bought_amount++;
    figure_trader_data.traders[trader_id].bought_resources[resource]++;
}

static void cross_country_advance_x(struct figure_t *f)
{
    if (f->cross_country_x < f->cc_destination_x) {
        f->cross_country_x++;
    } else if (f->cross_country_x > f->cc_destination_x) {
        f->cross_country_x--;
    }
}

static void cross_country_advance_y(struct figure_t *f)
{
    if (f->cross_country_y < f->cc_destination_y) {
        f->cross_country_y++;
    } else if (f->cross_country_y > f->cc_destination_y) {
        f->cross_country_y--;
    }
}

static int figure_movement_move_ticks_cross_country(struct figure_t *f, int num_ticks)
{
    map_figure_delete(f);
    int is_at_destination = 0;
    while (num_ticks > 0) {
        num_ticks--;
        if (f->missile_offset > 0) {
            f->missile_offset--;
        } else {
            f->missile_offset = 0;
        }
        if (f->cc_delta_x + f->cc_delta_y <= 0) {
            is_at_destination = 1;
            break;
        }
        if (f->cc_direction == 1) { // x
            if (f->cc_delta_xy >= 0) {
                f->cc_delta_xy += 2 * (f->cc_delta_y - f->cc_delta_x);
            } else {
                f->cc_delta_xy += 2 * f->cc_delta_y;
            }
            f->cc_delta_x--;
        } else { // y
            if (f->cc_delta_xy >= 0) {
                f->cc_delta_xy += 2 * (f->cc_delta_x - f->cc_delta_y);
            } else {
                f->cc_delta_xy += 2 * f->cc_delta_x;
            }
            f->cc_delta_y--;
        }
        if (f->cc_direction == 2) { // y
            cross_country_advance_y(f);
            if (f->cc_delta_xy >= 0) {
                f->cc_delta_x--;
                cross_country_advance_x(f);
            }
        } else {
            cross_country_advance_x(f);
            if (f->cc_delta_xy >= 0) {
                f->cc_delta_y--;
                cross_country_advance_y(f);
            }
        }
    }
    f->x = f->cross_country_x / 15;
    f->y = f->cross_country_y / 15;
    f->grid_offset = map_grid_offset(f->x, f->y);
    if (map_terrain_is(f->grid_offset, TERRAIN_BUILDING)) {
        f->in_building_wait_ticks = 8;
    } else if (f->in_building_wait_ticks) {
        f->in_building_wait_ticks--;
    }
    map_figure_add(f);
    return is_at_destination;
}

static void figure_movement_set_cross_country_destination(struct figure_t *f, int x_dst, int y_dst)
{
    f->destination_x = x_dst;
    f->destination_y = y_dst;
    figure_movement_set_cross_country_direction(f, f->cross_country_x, f->cross_country_y, 15 * x_dst, 15 * y_dst, 0);
}

static void figure_movement_follow_ticks(struct figure_t *f, int num_ticks)
{
    struct figure_t *leader = &figures[f->leading_figure_id];
    if (f->x == f->source_x && f->y == f->source_y) {
        f->is_invisible = 1;
    }
    while (num_ticks > 0) {
        num_ticks--;
        f->progress_on_tile++;
        if (f->progress_on_tile < 15) {
            advance_tick_movement(f);
        } else {
            f->progress_on_tile = 15;
            f->direction = calc_general_direction(f->x, f->y,
                leader->previous_tile_x, leader->previous_tile_y);
            if (f->direction >= 8) {
                break;
            }
            f->previous_tile_direction = f->direction;
            f->progress_on_tile = 0;
            move_to_next_tile(f);
            advance_tick_movement(f);
        }
    }
}

static void set_herd_animals_in_motion(struct formation_t *m)
{
    for (int j = 0; j < m->num_figures; j++) {
        struct figure_t *f = &figures[m->figures[j]];
        f->destination_x = m->destination_x + HERD_FORMATION_LAYOUT_POSITION_X_OFFSETS[f->index_in_formation];
        f->destination_y = m->destination_y + HERD_FORMATION_LAYOUT_POSITION_Y_OFFSETS[f->index_in_formation];
        f->action_state = FIGURE_ACTION_HERD_ANIMAL_MOVING;
    }
}

static void set_herd_formation_in_motion(struct formation_t *m, int roam_distance)
{
    if (m->figure_type == FIGURE_WOLF) {
        // wolves hunt nearby units
        for (int n = 0; n < m->num_figures; n++) {
            struct figure_t *f = &figures[m->figures[n]];
            struct figure_t *target_unit = melee_unit__set_closest_target(f);
            if (target_unit) {
                m->destination_x = target_unit->x;
                m->destination_y = target_unit->y;
                set_herd_animals_in_motion(m);
                return;
            }
        }
    }
    int target_tile_x, target_tile_y;
    switch (rand() % 8) {
        case DIR_0_TOP:
            target_tile_x = figures[m->figures[0]].x;
            target_tile_y = figures[m->figures[0]].y - roam_distance;
            break;
        case DIR_1_TOP_RIGHT:
            target_tile_x = figures[m->figures[0]].x + roam_distance;
            target_tile_y = figures[m->figures[0]].y - roam_distance;
            break;
        case DIR_2_RIGHT:
            target_tile_x = figures[m->figures[0]].x + roam_distance;
            target_tile_y = figures[m->figures[0]].y;
            break;
        case DIR_3_BOTTOM_RIGHT:
            target_tile_x = figures[m->figures[0]].x + roam_distance;
            target_tile_y = figures[m->figures[0]].y + roam_distance;
            break;
        case DIR_4_BOTTOM:
            target_tile_x = figures[m->figures[0]].x;
            target_tile_y = figures[m->figures[0]].y + roam_distance;
            break;
        case DIR_5_BOTTOM_LEFT:
            target_tile_x = figures[m->figures[0]].x - roam_distance;
            target_tile_y = figures[m->figures[0]].y + roam_distance;
            break;
        case DIR_6_LEFT:
            target_tile_x = figures[m->figures[0]].x - roam_distance;
            target_tile_y = figures[m->figures[0]].y;
            break;
        case DIR_7_TOP_LEFT:
            target_tile_x = figures[m->figures[0]].x - roam_distance;
            target_tile_y = figures[m->figures[0]].y - roam_distance;
            break;
        default:
            return;
    }
    if (target_tile_x <= 0 || target_tile_y <= 0) {
        return;
    } else if (target_tile_x >= map_data.width - 1) {
        target_tile_x = map_data.width - 2;
    } else if (target_tile_y >= map_data.height - 1) {
        target_tile_y = map_data.height - 2;
    }

    for (int fig = 0; fig < m->num_figures; fig++) {
        int fig_target_loc_grid_offset = map_grid_offset(target_tile_x + HERD_FORMATION_LAYOUT_POSITION_X_OFFSETS[fig], target_tile_y + HERD_FORMATION_LAYOUT_POSITION_Y_OFFSETS[fig]);
        if (!map_grid_is_valid_offset(fig_target_loc_grid_offset)) {
            return;
        }
        if (map_terrain_is(fig_target_loc_grid_offset, TERRAIN_IMPASSABLE)) {
            return;
        }
        if (map_grid_is_valid_offset(fig_target_loc_grid_offset) && map_figures.items[fig_target_loc_grid_offset] > 0) {
            return;
        }
    }
    m->destination_x = target_tile_x;
    m->destination_y = target_tile_y;
    for (int j = 0; j < m->num_figures; j++) {
        struct figure_t *f = &figures[m->figures[j]];
        if (f->type == FIGURE_SHEEP && figure_is_alive(f)) {
            f->wait_ticks = f->id & 0x1f;
        }
        set_herd_animals_in_motion(m);
    }
    m->wait_ticks_movement = 0;
}

static void clear_formation_combat_counters(struct formation_t *m)
{
    m->missile_attack_timeout = 0;
    m->recent_fight = 0;
}

static void decrease_formation_combat_counters(struct formation_t *m)
{
    if (m->missile_attack_timeout) {
        m->missile_attack_timeout--;
    }
    if (m->recent_fight) {
        m->recent_fight--;
    }
}

static int formation_rioter_get_target_building(int *x_tile, int *y_tile)
{
    int best_type_index = 100;
    struct building_t *best_building = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE) {
            continue;
        }
        for (int t = 0; t < 100 && t <= best_type_index && RIOTER_ATTACK_PRIORITY[t]; t++) {
            if (b->type == RIOTER_ATTACK_PRIORITY[t]) {
                if (t < best_type_index) {
                    best_type_index = t;
                    best_building = b;
                }
                break;
            }
        }
    }
    if (!best_building) {
        return 0;
    }
    if (best_building->type == BUILDING_WAREHOUSE) {
        *x_tile = best_building->x + 1;
        *y_tile = best_building->y;
        return best_building->id + 1;
    } else {
        *x_tile = best_building->x;
        *y_tile = best_building->y;
        return best_building->id;
    }
}

static int get_direction(struct figure_t *f)
{
    int dir;
    if (f->engaged_in_combat) {
        dir = f->attack_direction;
    } else if (f->direction < 8) {
        dir = f->direction;
    } else {
        dir = f->previous_tile_direction;
    }
    return figure_image_normalize_direction(dir);
}

static void rout_unit(struct figure_t *f)
{
    if (figure_properties[f->type].is_player_legion_unit) {
        struct formation_t *m = &legion_formations[f->formation_id];
        f->destination_x = all_buildings[m->building_id].x + 3 + FORMATION_LAYOUT_POSITION_X[FORMATION_AT_REST][f->index_in_formation];
        f->destination_y = all_buildings[m->building_id].y - 1 + FORMATION_LAYOUT_POSITION_Y[FORMATION_AT_REST][f->index_in_formation];
        f->destination_grid_offset = map_grid_offset(f->destination_x, f->destination_y);
        walk_ticks(f, f->speed_multiplier, 0);
        if (f->direction == DIR_FIGURE_AT_DESTINATION) {
            f->action_state = FIGURE_ACTION_SOLDIER_AT_REST;
            f->is_fleeing = 0;
        } else if (f->direction == DIR_FIGURE_REROUTE) {
            figure_route_remove(f);
        }
    } else if (figure_properties[f->type].is_enemy_unit || figure_properties[f->type].is_caesar_legion_unit) {
        f->destination_x = f->source_x;
        f->destination_y = f->source_y;
        walk_ticks(f, f->speed_multiplier, 0);
        if (f->direction == DIR_FIGURE_AT_DESTINATION ||
            f->direction == DIR_FIGURE_REROUTE ||
            f->direction == DIR_FIGURE_LOST) {
            figure_delete(f);
            return;
        }
    }
    figure_image_increase_offset(f, 12);
    int dir = get_direction(f);
    switch (f->type) {
        case FIGURE_FORT_JAVELIN:
            f->image_id = 6849 + dir + 8 * f->image_offset;
            break;
        case FIGURE_FORT_MOUNTED:
            f->image_id = 8376 + dir + 8 * f->image_offset;
            break;
        case FIGURE_FORT_LEGIONARY:
            f->image_id = 7161 + dir + 8 * f->image_offset;
            break;
        case FIGURE_ENEMY_BARBARIAN_SWORDSMAN:
            f->image_id = 297 + dir + 8 * f->image_offset;
            break;
        case FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN:
        case FIGURE_ENEMY_BRITON_SWORDSMAN:
        case FIGURE_ENEMY_CELT_SWORDSMAN:
        case FIGURE_ENEMY_PICT_SWORDSMAN:
        case FIGURE_ENEMY_EGYPTIAN_SWORDSMAN:
        case FIGURE_ENEMY_ETRUSCAN_SWORDSMAN:
        case FIGURE_ENEMY_SAMNITE_SWORDSMAN:
        case FIGURE_ENEMY_GAUL_SWORDSMAN:
        case FIGURE_ENEMY_HELVETIUS_SWORDSMAN:
        case FIGURE_ENEMY_HUN_SWORDSMAN:
        case FIGURE_ENEMY_GOTH_SWORDSMAN:
        case FIGURE_ENEMY_VISIGOTH_SWORDSMAN:
        case FIGURE_ENEMY_GREEK_SWORDSMAN:
        case FIGURE_ENEMY_MACEDONIAN_SWORDSMAN:
        case FIGURE_ENEMY_NUMIDIAN_SWORDSMAN:
        case FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER:
        case FIGURE_ENEMY_PERGAMUM_SWORDSMAN:
        case FIGURE_ENEMY_IBERIAN_SWORDSMAN:
        case FIGURE_ENEMY_JUDEAN_SWORDSMAN:
        case FIGURE_ENEMY_SELEUCID_SWORDSMAN:
            f->image_id = 449 + dir + 8 * f->image_offset;
            break;
        case FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT:
        case FIGURE_ENEMY_BRITON_CHARIOT:
        case FIGURE_ENEMY_CELT_CHARIOT:
        case FIGURE_ENEMY_PICT_CHARIOT:
        case FIGURE_ENEMY_EGYPTIAN_CAMEL:
        case FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER:
        case FIGURE_ENEMY_SAMNITE_SPEAR_THROWER:
        case FIGURE_ENEMY_GAUL_AXEMAN:
        case FIGURE_ENEMY_HELVETIUS_AXEMAN:
        case FIGURE_ENEMY_HUN_MOUNTED_ARCHER:
        case FIGURE_ENEMY_GOTH_MOUNTED_ARCHER:
        case FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER:
        case FIGURE_ENEMY_GREEK_SPEAR_THROWER:
        case FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER:
        case FIGURE_ENEMY_PERGAMUM_ARCHER:
        case FIGURE_ENEMY_IBERIAN_SPEAR_THROWER:
        case FIGURE_ENEMY_JUDEAN_SPEAR_THROWER:
        case FIGURE_ENEMY_SELEUCID_SPEAR_THROWER:
            f->image_id = 601 + dir + 8 * f->image_offset;
            break;
        case FIGURE_ENEMY_CAESAR_LEGIONARY:
            f->image_id = 7049 + dir + 8 * f->image_offset;
            break;
    }
}

static int unit_is_charging_opponent(struct figure_t *f, struct figure_t *opponent)
{
    return f->mounted_charge_ticks
        && !f->figure_is_halted
        && opponent->type != FIGURE_FORT_MOUNTED
        && opponent->type != FIGURE_ENEMY_EGYPTIAN_CAMEL
        && opponent->type != FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT
        && opponent->type != FIGURE_ENEMY_BRITON_CHARIOT && opponent->type != FIGURE_ENEMY_CELT_CHARIOT && opponent->type != FIGURE_ENEMY_PICT_CHARIOT
        && opponent->type != FIGURE_ENEMY_HUN_MOUNTED_ARCHER && opponent->type != FIGURE_ENEMY_GOTH_MOUNTED_ARCHER && opponent->type != FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER;
}

static int trade_price_change(int resource, int amount)
{
    if (amount < 0 && trade_prices[resource].sell <= 0) {
        // cannot lower the price to negative
        return 0;
    }
    if (amount < 0 && trade_prices[resource].sell <= -amount) {
        trade_prices[resource].buy = 2;
        trade_prices[resource].sell = 0;
    } else {
        trade_prices[resource].buy += amount;
        trade_prices[resource].sell += amount;
    }
    return 1;
}

static int city_trade_next_docker_import_resource(void)
{
    city_data.trade.docker_import_resource++;
    if (city_data.trade.docker_import_resource >= RESOURCE_TYPES_MAX) {
        city_data.trade.docker_import_resource = RESOURCE_WHEAT;
    }
    return city_data.trade.docker_import_resource;
}

static void city_ratings_update(int is_yearly_update)
{
    // update culture rating
    city_data.ratings.culture = 0;
    city_data.ratings.culture_explanation = 0;
    if (city_data.population.population) {
        if (culture_coverage.theater >= 100) {
            city_data.ratings.culture += 25;
        } else if (culture_coverage.theater > 85) {
            city_data.ratings.culture += 18;
        } else if (culture_coverage.theater > 70) {
            city_data.ratings.culture += 12;
        } else if (culture_coverage.theater > 50) {
            city_data.ratings.culture += 8;
        } else if (culture_coverage.theater > 30) {
            city_data.ratings.culture += 3;
        }
        int pct_religion = city_data.culture.religion_coverage;
        if (pct_religion >= 100) {
            city_data.ratings.culture += 30;
        } else if (pct_religion > 85) {
            city_data.ratings.culture += 22;
        } else if (pct_religion > 70) {
            city_data.ratings.culture += 14;
        } else if (pct_religion > 50) {
            city_data.ratings.culture += 9;
        } else if (pct_religion > 30) {
            city_data.ratings.culture += 3;
        }
        if (culture_coverage.school >= 100) {
            city_data.ratings.culture += 15;
        } else if (culture_coverage.school > 85) {
            city_data.ratings.culture += 10;
        } else if (culture_coverage.school > 70) {
            city_data.ratings.culture += 6;
        } else if (culture_coverage.school > 50) {
            city_data.ratings.culture += 4;
        } else if (culture_coverage.school > 30) {
            city_data.ratings.culture += 1;
        }
        if (culture_coverage.academy >= 100) {
            city_data.ratings.culture += 10;
        } else if (culture_coverage.academy > 85) {
            city_data.ratings.culture += 7;
        } else if (culture_coverage.academy > 70) {
            city_data.ratings.culture += 4;
        } else if (culture_coverage.academy > 50) {
            city_data.ratings.culture += 2;
        } else if (culture_coverage.academy > 30) {
            city_data.ratings.culture += 1;
        }
        if (culture_coverage.library >= 100) {
            city_data.ratings.culture += 20;
        } else if (culture_coverage.library > 85) {
            city_data.ratings.culture += 14;
        } else if (culture_coverage.library > 70) {
            city_data.ratings.culture += 8;
        } else if (culture_coverage.library > 50) {
            city_data.ratings.culture += 4;
        } else if (culture_coverage.library > 30) {
            city_data.ratings.culture += 2;
        }
        city_data.ratings.culture = calc_bound(city_data.ratings.culture, 0, 100);
        update_culture_explanation();
    }
    // update favor rating
    city_data.emperor.months_since_gift++;
    if (city_data.emperor.months_since_gift >= 12) {
        city_data.emperor.gift_overdose_penalty = 0;
    }
    // update prosperity
    int points = 0;
    int houses = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state && b->house_size) {
            points += house_properties[b->subtype.house_level].prosperity;
            houses++;
        }
    }
    if (houses > 0) {
        city_data.ratings.prosperity_max = points / houses;
    } else {
        city_data.ratings.prosperity_max = 0;
    }
    if (is_yearly_update) {
        // update favor
        city_data.ratings.favor_salary_penalty = 0;
        city_data.ratings.favor_ignored_request_penalty = 0;
        city_data.ratings.favor -= 2;
        // tribute penalty
        if (city_data.finance.tribute_not_paid_last_year) {
            if (city_data.finance.tribute_not_paid_total_years <= 1) {
                city_data.ratings.favor -= 3;
            } else if (city_data.finance.tribute_not_paid_total_years <= 2) {
                city_data.ratings.favor -= 5;
            } else {
                city_data.ratings.favor -= 8;
            }
        }
        // salary
        int salary_delta = city_data.emperor.salary_rank - city_data.emperor.player_rank;
        if (city_data.emperor.player_rank != 0) {
            if (salary_delta > 0) {
                // salary too high
                city_data.ratings.favor -= salary_delta;
                city_data.ratings.favor_salary_penalty = salary_delta + 1;
            } else if (salary_delta < 0) {
                // salary lower than rank
                city_data.ratings.favor += 1;
            }
        } else if (salary_delta > 0) {
            city_data.ratings.favor -= salary_delta;
            city_data.ratings.favor_salary_penalty = salary_delta;
        }

        if (city_data.ratings.favor < city_data.ratings.favor_last_year) {
            city_data.ratings.favor_change = 0;
        } else if (city_data.ratings.favor == city_data.ratings.favor_last_year) {
            city_data.ratings.favor_change = 1;
        } else {
            city_data.ratings.favor_change = 2;
        }
        city_data.ratings.favor_last_year = city_data.ratings.favor;
        // update prosperity rating
        int change = 0;
        // unemployment: -1 for too high, +1 for low
        if (city_data.labor.unemployment_percentage < 5) {
            change += 1;
        } else if (city_data.labor.unemployment_percentage >= 15) {
            change -= 1;
        }
        // losing/earning money: -1 for losing, +5 for profit
        if (has_made_money()) {
            change += 5;
        } else {
            change -= 1;
        }
        city_data.ratings.prosperity_treasury_last_year = city_data.finance.treasury;
        // food types: +1 for multiple foods
        if (city_data.resource.food_types_eaten >= 2) {
            change += 1;
        }
        // wages: +1 for wages 2+ above Rome, -1 for wages below Rome
        int avg_wage = city_data.finance.wage_rate_paid_last_year / 12;
        if (avg_wage >= city_data.labor.wages_rome + 2) {
            change += 1;
        } else if (avg_wage < city_data.labor.wages_rome) {
            change -= 1;
        }
        // high percentage poor: -1, high percentage rich: +1
        if (calc_percentage(city_data.population.people_in_tents_shacks, city_data.population.population) > 30) {
            change -= 1;
        }
        if (calc_percentage(city_data.population.people_in_villas_palaces, city_data.population.population) > 10) {
            change += 1;
        }
        // tribute not paid: -1
        if (city_data.finance.tribute_not_paid_last_year) {
            change -= 1;
        }
        // working hippodrome: +1
        if (city_data.entertainment.hippodrome_shows > 0) {
            change += 1;
        }
        city_data.ratings.prosperity += change;
        if (city_data.ratings.prosperity > city_data.ratings.prosperity_max) {
            city_data.ratings.prosperity = city_data.ratings.prosperity_max;
        }
        city_data.ratings.prosperity = calc_bound(city_data.ratings.prosperity, 0, 100);
        update_prosperity_explanation();
        // update peace rating
        change = 0;
        if (city_data.ratings.peace_years_of_peace < 2) {
            change += 2;
        } else {
            change += 5;
        }
        if (city_data.ratings.peace_num_criminals) {
            change -= 1;
        }
        if (city_data.ratings.peace_num_rioters) {
            change -= 5;
        }
        if (city_data.ratings.peace_destroyed_buildings) {
            change -= city_data.ratings.peace_destroyed_buildings;
        }
        if (city_data.ratings.peace_num_rioters || city_data.ratings.peace_destroyed_buildings) {
            city_data.ratings.peace_years_of_peace = 0;
        } else {
            city_data.ratings.peace_years_of_peace += 1;
        }
        city_data.ratings.peace_num_criminals = 0;
        city_data.ratings.peace_num_rioters = 0;
        city_data.ratings.peace_destroyed_buildings = 0;
        city_data.ratings.peace = calc_bound(city_data.ratings.peace + change, 0, 100);
        update_peace_explanation();
    }
    city_data.ratings.favor = calc_bound(city_data.ratings.favor, 0, 100);
    city_ratings_update_favor_explanation();
}

static int city_message_mark_population_shown(int population)
{
    int *field;
    switch (population) {
        case 500: field = &message_data.population_shown.pop500; break;
        case 1000: field = &message_data.population_shown.pop1000; break;
        case 2000: field = &message_data.population_shown.pop2000; break;
        case 3000: field = &message_data.population_shown.pop3000; break;
        case 5000: field = &message_data.population_shown.pop5000; break;
        case 10000: field = &message_data.population_shown.pop10000; break;
        case 15000: field = &message_data.population_shown.pop15000; break;
        case 20000: field = &message_data.population_shown.pop20000; break;
        case 25000: field = &message_data.population_shown.pop25000; break;
        default: return 0;
    }
    if (!*field) {
        *field = 1;
        return 1;
    }
    return 0;
}

static void city_message_post_with_message_delay(int category, int use_popup, int message_type, int delay)
{
    if (category == MESSAGE_CAT_FISHING_BLOCKED || category == MESSAGE_CAT_NO_WORKING_DOCK) {
        // bug in the original game: delays for 'fishing blocked' and 'no working dock'
        // are stored in message_count with manual countdown
        if (message_data.message_count[category] > 0) {
            message_data.message_count[category]--;
        } else {
            message_data.message_count[category] = delay;
            city_message_post(use_popup, message_type, 0, 0);
        }
    } else {
        if (message_data.message_delay[category] <= 0) {
            message_data.message_delay[category] = delay;
            city_message_post(use_popup, message_type, 0, 0);
        }
    }
}

static void city_message_post_with_popup_delay(int category, int message_type, int param1, short param2)
{
    int use_popup = 0;
    if (message_data.message_delay[category] <= 0) {
        use_popup = 1;
        message_data.message_delay[category] = 12;
    }
    city_message_post(use_popup, message_type, param1, param2);
    message_data.message_count[category]++;
}

static int building_warehouse_for_storing(int src_building_id, int x, int y, int resource, int *understaffed, struct map_point_t *dst)
{
    int min_dist = 10000;
    int min_building_id = 0;
    for (int i = 1; i < MAX_BUILDINGS; i++) {
        struct building_t *b = &all_buildings[i];
        if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_WAREHOUSE_SPACE) {
            continue;
        }
        if (!b->has_road_access) {
            continue;
        }
        struct building_t *building_dst = building_main(b);
        if (src_building_id == building_dst->id) {
            continue;
        }
        struct building_storage_t *s = &storages[building_dst->storage_id].storage;
        if (s->resource_state[resource] == BUILDING_STORAGE_STATE_NOT_ACCEPTING || s->empty_all) {
            continue;
        }
        if (calc_percentage(building_dst->num_workers, building_properties[building_dst->type].n_laborers) < 100) {
            if (understaffed) {
                *understaffed += 1;
            }
            continue;
        }
        int dist;
        if (b->subtype.warehouse_resource_id == RESOURCE_NONE) { // empty warehouse space
            dist = calc_maximum_distance(b->x, b->y, x, y);
        } else if (b->subtype.warehouse_resource_id == resource && b->loads_stored < 4) {
            dist = calc_maximum_distance(b->x, b->y, x, y);
        } else {
            dist = 0;
        }
        if (dist > 0 && dist < min_dist) {
            min_dist = dist;
            min_building_id = i;
        }
    }
    struct building_t *b = building_main(&all_buildings[min_building_id]);
    if (b->has_road_access == 1) {
        dst->x = b->x;
        dst->y = b->y;
    } else if (!map_has_road_access(b->x, b->y, 3, dst)) {
        return 0;
    }
    return min_building_id;
}

static void building_totals_add_corrupted_house(int unfixable)
{
    extra.incorrect_houses++;
    if (unfixable) {
        extra.unfixable_houses++;
    }
}

static void add_to_census(int num_people)
{
    int odd = 0;
    int index = 0;
    for (int i = 0; i < num_people; i++, odd = 1 - odd) {
        int age = random_data.pool[(random_data.pool_index + index) % MAX_RANDOM] & 0x3f; // 63
        index++;
        if (age > 50) {
            age -= 30;
        } else if (age < 10 && odd) {
            age += 20;
        }
        city_data.population.at_age[age]++;
    }
}

static void building_warehouse_space_add_import(struct building_t *space, int resource)
{
    city_resource_add_to_warehouse(resource, 1);
    space->loads_stored++;
    space->subtype.warehouse_resource_id = resource;
    city_data.finance.treasury -= trade_prices[resource].buy;
    city_data.finance.this_year.expenses.imports += trade_prices[resource].buy;
    building_warehouse_space_set_image(space, resource);
}

static int map_terrain_is_adjacent_to_open_water(int x, int y, int size)
{
    int base_offset = map_grid_offset(x, y);
    for (int *tile_delta = ADJACENT_OFFSETS_MAP_GRID[size]; *tile_delta; tile_delta++) {
        if (map_terrain_is(base_offset + *tile_delta, TERRAIN_WATER) &&
            routing_distance.items[base_offset + *tile_delta] > 0) {
            return 1;
        }
    }
    return 0;
}

static void figure_create_immigrant(struct building_t *house, int num_people)
{
    struct figure_t *f = figure_create(FIGURE_IMMIGRANT, scenario.entry_point.x, scenario.entry_point.y, DIR_0_TOP);
    f->action_state = FIGURE_ACTION_IMMIGRANT_CREATED;
    f->is_targetable = 1;
    f->terrain_usage = TERRAIN_USAGE_ANY;
    f->immigrant_building_id = house->id;
    f->wait_ticks = 10 + (house->house_figure_generation_delay & 0x7f);
    f->migrant_num_people = num_people;
    house->immigrant_figure_id = f->id;
}

static void create_immigrants(int num_people)
{
    int *houses = building_list_large_items();
    int to_immigrate = num_people;
    // clean up any dead immigrants
    for (int i = 0; i < building_list_data.large.size; i++) {
        struct building_t *b = &all_buildings[houses[i]];
        if (b->immigrant_figure_id && !figure_is_alive(&figures[b->immigrant_figure_id])) {
            b->immigrant_figure_id = 0;
        }
    }
    // houses with plenty of room
    for (int i = 0; i < building_list_data.large.size && to_immigrate > 0; i++) {
        struct building_t *b = &all_buildings[houses[i]];
        if (b->house_population_room >= 8 && !b->immigrant_figure_id) {
            if (to_immigrate <= 4) {
                figure_create_immigrant(b, to_immigrate);
                to_immigrate = 0;
            } else {
                figure_create_immigrant(b, 4);
                to_immigrate -= 4;
            }
        }
    }
    // houses with less room
    for (int i = 0; i < building_list_data.large.size && to_immigrate > 0; i++) {
        struct building_t *b = &all_buildings[houses[i]];
        if (b->house_population_room > 0 && !b->immigrant_figure_id) {
            if (to_immigrate <= b->house_population_room) {
                figure_create_immigrant(b, to_immigrate);
                to_immigrate = 0;
            } else {
                figure_create_immigrant(b, b->house_population_room);
                to_immigrate -= b->house_population_room;
            }
        }
    }
    int immigrated = num_people - to_immigrate;
    city_data.migration.immigrated_today += immigrated;
    city_data.migration.newcomers += city_data.migration.immigrated_today;
    if (immigrated == 0) {
        city_data.migration.refused_immigrants_today += num_people;
    }
}

static void create_vacant_lot(int x, int y, int image_id)
{
    struct building_t *b = building_create(BUILDING_HOUSE_VACANT_LOT, x, y);
    b->house_population = 0;
    map_building_tiles_add(b->id, b->x, b->y, 1, image_id, TERRAIN_BUILDING);
}

static void figure_create_emigrant(struct building_t *house, int num_people)
{
    city_data.population.last_change = -num_people;
    remove_from_census(num_people);
    recalculate_population();
    if (num_people < house->house_population) {
        house->house_population -= num_people;
    } else {
        house->house_population = 0;
        house->type = BUILDING_HOUSE_VACANT_LOT;
        house->subtype.house_level = house->type - BUILDING_HOUSE_SMALL_TENT;
        int image_id = 2823;
        if (house->house_is_merged) {
            map_building_tiles_remove(house->id, house->x, house->y);
            house->house_is_merged = 0;
            house->size = house->house_size = 1;
            map_building_tiles_add(house->id, house->x, house->y, 1, image_id, TERRAIN_BUILDING);
            create_vacant_lot(house->x + 1, house->y, image_id);
            create_vacant_lot(house->x, house->y + 1, image_id);
            create_vacant_lot(house->x + 1, house->y + 1, image_id);
        } else {
            images.items[house->grid_offset] = image_id;
        }
    }
    struct figure_t *f = figure_create(FIGURE_EMIGRANT, house->x, house->y, DIR_0_TOP);
    f->action_state = FIGURE_ACTION_EMIGRANT_CREATED;
    f->is_targetable = 1;
    f->terrain_usage = TERRAIN_USAGE_ANY;
    f->wait_ticks = 0;
    f->migrant_num_people = num_people;
}

static void create_emigrants(int num_people)
{
    int *houses = building_list_large_items();
    int to_emigrate = num_people;
    for (int level = HOUSE_SMALL_TENT; level < HOUSE_LARGE_INSULA && to_emigrate > 0; level++) {
        for (int i = 0; i < building_list_data.large.size && to_emigrate > 0; i++) {
            struct building_t *b = &all_buildings[houses[i]];
            if (b->house_population > 0 && b->subtype.house_level == level) {
                int current_people;
                if (b->house_population >= 4) {
                    current_people = 4;
                } else {
                    current_people = b->house_population;
                }
                if (to_emigrate <= current_people) {
                    figure_create_emigrant(b, to_emigrate);
                    to_emigrate = 0;
                } else {
                    figure_create_emigrant(b, current_people);
                    to_emigrate -= current_people;
                }
            }
        }
    }
    city_data.migration.emigrated_today += (num_people - to_emigrate);
}

static int get_people_in_age_decennium(int decennium)
{
    int pop = 0;
    for (int i = 0; i < 10; i++) {
        pop += city_data.population.at_age[10 * decennium + i];
    }
    return pop;
}

static int map_has_road_access_hippodrome(int x, int y, struct map_point_t *road)
{
    int min_value = 12;
    int min_grid_offset = map_grid_offset(x, y);
    find_minimum_road_tile(x, y, 5, &min_value, &min_grid_offset);
    find_minimum_road_tile(x + 5, y, 5, &min_value, &min_grid_offset);
    find_minimum_road_tile(x + 10, y, 5, &min_value, &min_grid_offset);
    if (min_value < 12) {
        if (road) {
            road->x = map_grid_offset_to_x(min_grid_offset);
            road->y = map_grid_offset_to_y(min_grid_offset);
        }
        return 1;
    }
    return 0;
}

static void set_city_foreign(void)
{
    if (city_data.distant_battle.city) {
        empire_objects[city_data.distant_battle.city].city_type = EMPIRE_CITY_DISTANT_FOREIGN;
    }
    city_data.distant_battle.city_foreign_months_left = 24;
}

static void video_draw_fullscreen(void)
{
    if (!get_next_frame()) {
        return;
    }
    int s_width = current_resolution_width;
    int s_height = current_resolution_height;
    unsigned char *frame = data_video.s->frame_data.video;
    uint32_t *pal = data_video.s->frame_data.palette;
    if (frame && pal) {
        double scale_w = s_width / (double) data_video.video.width;
        double scale_h = s_height / (double) data_video.video.height * (data_video.video.y_scale == SMACKER_Y_SCALE_NONE ? 1 : 2);
        double scale = scale_w < scale_h ? scale_w : scale_h;
        int video_width = (int) (scale * data_video.video.width);
        int video_height = (int) (scale * data_video.video.height);
        int x_offset = (s_width - video_width) / 2;
        int y_offset = (s_height - video_height) / 2;
        struct clip_info_t *clip = graphics_get_clip_info(x_offset, y_offset, video_width, video_height);
        if (!clip || !clip->is_visible) {
            return;
        }
        for (int y = clip->clipped_pixels_top; y < video_height - clip->clipped_pixels_bottom; y++) {
            uint32_t *pixel = graphics_get_pixel(x_offset + clip->clipped_pixels_left, y_offset + y);
            int x_max = video_width - clip->clipped_pixels_right;
            int video_y = (int) ((data_video.video.y_scale == SMACKER_Y_SCALE_NONE ? y : y / 2) / scale);
            unsigned char *line = frame + (video_y * data_video.video.width);
            for (int x = clip->clipped_pixels_left; x < x_max; x++) {
                *pixel = ALPHA_OPAQUE | pal[line[(int) (x / scale)]];
                ++pixel;
            }
        }
    }
}

static void window_victory_video_show(char *filename, int width, int height)
{
    if (video_start(filename)) {
        victory_video_data.width = width;
        victory_video_data.height = height;
        video_init(0);
        change_window(WINDOW_VICTORY_VIDEO);
    } else {
        show_main_menu_window(1);
    }
}

static void show_defeat_message(void)
{
    game_lost = 1;
    stop_sound_channel(SOUND_CHANNEL_SPEECH);
    stop_music();
    city_message_post(1, MESSAGE_FIRED, 0, 0);
}

static void game_run(void)
{
    current_time = SDL_GetTicks64();
    for (int i = 0; i < MAX_ANIM_TIMERS; i++) {
        timers[i].should_update = 0;
    }
    unsigned int delay_millis = 0;
    for (int i = 0; i < MAX_ANIM_TIMERS; i++) {
        if (current_time - timers[i].last_update >= delay_millis) {
            timers[i].should_update = 1;
            timers[i].last_update = current_time;
        }
        delay_millis += 20;
    }
    int last_check_was_valid = speed_data.last_check_was_valid;
    speed_data.last_check_was_valid = 0;
    if (state_data.paused) {
        return;
    }
    int millis_per_tick = 1;
    switch (current_window) {
        default:
            return;
        case WINDOW_CITY:
        case WINDOW_SLIDING_SIDEBAR:
        case WINDOW_OVERLAY_MENU:
        {
            if (settings[SETTINGS_GAME_SPEED].config_value < 10) {
                return;
            } else if (settings[SETTINGS_GAME_SPEED].config_value <= 100) {
                millis_per_tick = MILLIS_PER_TICK_PER_SPEED[settings[SETTINGS_GAME_SPEED].config_value / 10];
            } else {
                if (settings[SETTINGS_GAME_SPEED].config_value > 500) {
                    settings[SETTINGS_GAME_SPEED].config_value = 500;
                }
                millis_per_tick = MILLIS_PER_HYPER_SPEED[settings[SETTINGS_GAME_SPEED].config_value / 100];
            }
            break;
        }
        case WINDOW_EDITOR_MAP:
            millis_per_tick = MILLIS_PER_TICK_PER_SPEED[7]; // 70%, nice speed for flag animations
            break;
    }
    uint32_t diff = current_time - speed_data.last_update;
    speed_data.last_check_was_valid = 1;
    int num_ticks;
    if (last_check_was_valid) {
        int ticks = diff / millis_per_tick;
        if (!ticks) {
            return;
        } else if (ticks <= MAX_TICKS_PER_FRAME) {
            speed_data.last_update = current_time - (diff % millis_per_tick); // account for left-over millis in this frame
            num_ticks = ticks;
        } else {
            speed_data.last_update = current_time;
            num_ticks = MAX_TICKS_PER_FRAME;
        }
    } else {
        // returning to map from another window or pause: always force a tick
        speed_data.last_update = current_time;
        num_ticks = 1;
    }
    for (int i = 0; i < num_ticks; i++) {
        if (editor_active) {
            random_generate_next(); // update random to randomize native huts
            for (int j = 1; j < MAX_FIGURES; j++) {
                struct figure_t *f = &figures[j];
                if (f->in_use && f->type == FIGURE_MAP_FLAG) {
                    figure_editor_flag_action(f);
                }
            }
            return;
        }
        random_generate_next();
        if (undo_data.ready && undo_data.available) {
            int earthquake_in_progress = 0;
            for (int j = 0; j < MAX_EARTHQUAKES; j++) {
                if (scenario.earthquakes[j].state == EVENT_IN_PROGRESS) {
                    earthquake_in_progress = 1;
                    break;
                }
            }
            if (undo_data.timeout_ticks <= 0 || earthquake_in_progress) {
                undo_data.available = 0;
                clear_buildings();
                // window_invalidate();
            } else {
                undo_data.timeout_ticks--;
                if (undo_data.type != BUILDING_CLEAR_LAND
                && undo_data.type != BUILDING_AQUEDUCT
                && undo_data.type != BUILDING_ROAD
                && undo_data.type != BUILDING_WALL
                && undo_data.type != BUILDING_LOW_BRIDGE
                && undo_data.type != BUILDING_SHIP_BRIDGE
                && undo_data.type != BUILDING_PLAZA
                && undo_data.type != BUILDING_GARDENS) {
                    if (undo_data.num_buildings <= 0) {
                        undo_data.available = 0;
                        // window_invalidate();
                    } else {
                        int cont = 1;
                        if (undo_data.type == BUILDING_HOUSE_VACANT_LOT) {
                            for (int j = 0; j < undo_data.num_buildings; j++) {
                                if (undo_data.buildings[j].id && all_buildings[undo_data.buildings[j].id].house_population) {
                                    // no undo on a new house where people moved in
                                    undo_data.available = 0;
                                    // window_invalidate();
                                    cont = 0;
                                    break;
                                }
                            }
                        }
                        if (cont) {
                            for (int j = 0; j < undo_data.num_buildings; j++) {
                                if (undo_data.buildings[j].id) {
                                    struct building_t *b = &all_buildings[undo_data.buildings[j].id];
                                    if (b->state == BUILDING_STATE_UNDO ||
                                        b->state == BUILDING_STATE_RUBBLE ||
                                        b->state == BUILDING_STATE_DELETED_BY_GAME) {
                                        undo_data.available = 0;
                                        // window_invalidate();
                                        break;
                                    } else {
                                        if (b->type != undo_data.buildings[j].type || b->grid_offset != undo_data.buildings[j].grid_offset) {
                                            undo_data.available = 0;
                                            // window_invalidate();
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        // NB: these ticks are noop:
        // 0, 9, 11, 13, 14, 15, 26, 29, 41, 42, 47
        int *houses;
        int recalculate_terrain = 0;
        switch (time_data.tick) {
            case 1: city_gods_calculate_moods(1); break;
            case 2: update_music(0); break;
            case 3:
                minimap_data.refresh_requested = 1;
                break;
            case 4:
                // update debt state
                if (city_data.finance.treasury >= 0) {
                    city_data.emperor.months_in_debt = -1;
                } else {
                    if (city_data.emperor.debt_state == 0) {
                        // provide bailout
                        int rescue_loan = scenario.rescue_loan;
                        city_finance_process_donation(rescue_loan);
                        city_finance_calculate_totals();
                        city_data.emperor.debt_state = 1;
                        city_data.emperor.months_in_debt = 0;
                        city_message_post(1, MESSAGE_CITY_IN_DEBT, 0, 0);
                        if (city_data.ratings.prosperity >= 3) {
                            city_data.ratings.prosperity -= 3;
                        }
                        city_data.ratings.prosperity_explanation = 8;
                    } else if (city_data.emperor.debt_state == 1) {
                        city_data.emperor.debt_state = 2;
                        city_data.emperor.months_in_debt = 0;
                        city_message_post(1, MESSAGE_CITY_IN_DEBT_AGAIN, 0, 0);
                        city_data.ratings.favor = calc_bound(city_data.ratings.favor - 5, 0, 100);
                    } else if (city_data.emperor.debt_state == 2) {
                        if (city_data.emperor.months_in_debt == -1) {
                            city_message_post(1, MESSAGE_CITY_IN_DEBT_AGAIN, 0, 0);
                            city_data.emperor.months_in_debt = 0;
                        }
                        if (time_data.day == 0) {
                            city_data.emperor.months_in_debt++;
                        }
                        if (city_data.emperor.months_in_debt >= 12) {
                            city_data.emperor.debt_state = 3;
                            city_data.emperor.months_in_debt = 0;
                            if (!city_data.figure.imperial_soldiers) {
                                city_message_post(1, MESSAGE_CITY_STILL_IN_DEBT, 0, 0);
                                city_data.ratings.favor = calc_bound(city_data.ratings.favor - 10, 0, 100);
                            }
                        }
                    } else if (city_data.emperor.debt_state == 3) {
                        if (city_data.emperor.months_in_debt == -1) {
                            city_message_post(1, MESSAGE_CITY_STILL_IN_DEBT, 0, 0);
                            city_data.emperor.months_in_debt = 0;
                        }
                        if (time_data.day == 0) {
                            city_data.emperor.months_in_debt++;
                        }
                        if (city_data.emperor.months_in_debt >= 12) {
                            city_data.emperor.debt_state = 4;
                            city_data.emperor.months_in_debt = 0;
                            if (!city_data.figure.imperial_soldiers) {
                                if (city_data.ratings.favor > 10) {
                                    city_data.ratings.favor = 10;
                                }
                            }
                        }
                    }
                }
                // process caesar invasion
                if (city_data.figure.imperial_soldiers && !city_data.emperor.invasion.from_editor) {
                    // caesar invasion in progress
                    city_data.emperor.invasion.duration_day_countdown--;
                    if (city_data.ratings.favor >= 35 && city_data.emperor.invasion.duration_day_countdown < 176) {
                        // pause legions
                        for (int j = 0; j < MAX_ENEMY_FORMATIONS; j++) {
                            if (enemy_formations[j].in_use == 1 && enemy_formations[j].figure_type == FIGURE_ENEMY_CAESAR_LEGIONARY) {
                                enemy_formations[j].wait_ticks_movement = 0;
                            }
                        }
                    } else if (city_data.ratings.favor >= 22) {
                        if (city_data.emperor.invasion.duration_day_countdown > 0) {
                            // retreat
                            for (int j = 0; j < MAX_ENEMY_FORMATIONS; j++) {
                                if (enemy_formations[j].in_use && enemy_formations[j].figure_type == FIGURE_ENEMY_CAESAR_LEGIONARY) {
                                    enemy_formations[j].morale = 0;
                                }
                            }
                            if (!city_data.emperor.invasion.retreat_message_shown) {
                                city_data.emperor.invasion.retreat_message_shown = 1;
                                city_message_post(1, MESSAGE_CAESAR_ARMY_RETREAT, 0, 0);
                            }
                        } else if (city_data.emperor.invasion.duration_day_countdown == 0) {
                            // a year has passed (11 months), siege goes on
                            city_message_post(1, MESSAGE_CAESAR_ARMY_CONTINUE, 0, 0);
                        }
                    }
                } else if (city_data.emperor.invasion.soldiers_killed && city_data.emperor.invasion.soldiers_killed >= city_data.emperor.invasion.size) {
                    // player defeated caesar army
                    city_data.emperor.invasion.size = 0;
                    city_data.emperor.invasion.soldiers_killed = 0;
                    if (!city_data.emperor.invasion.from_editor) {
                        if (city_data.ratings.favor < 35) {
                            city_data.ratings.favor = calc_bound(city_data.ratings.favor + 10, 0, 100);
                            if (city_data.emperor.invasion.count < 2) {
                                city_message_post(1, MESSAGE_CAESAR_RESPECT_1, 0, 0);
                            } else if (city_data.emperor.invasion.count < 3) {
                                city_message_post(1, MESSAGE_CAESAR_RESPECT_2, 0, 0);
                            } else {
                                city_message_post(1, MESSAGE_CAESAR_RESPECT_3, 0, 0);
                            }
                        }
                    }
                    if (city_data.emperor.invasion.from_editor) {
                        city_data.emperor.invasion.from_editor = 0;
                    }
                } else if (city_data.emperor.invasion.days_until_invasion <= 0) {
                    if (city_data.ratings.favor <= 10) {
                        // warn player that caesar is angry and will invade in a year
                        city_data.emperor.invasion.warnings_given++;
                        city_data.emperor.invasion.days_until_invasion = 192;
                        if (city_data.emperor.invasion.warnings_given <= 1) {
                            city_message_post(1, MESSAGE_CAESAR_WRATH, 0, 0);
                        }
                    }
                } else {
                    city_data.emperor.invasion.days_until_invasion--;
                    if (city_data.emperor.invasion.days_until_invasion == 0) {
                        // invade!
                        int size;
                        if (city_data.emperor.invasion.count == 0) {
                            size = 32;
                        } else if (city_data.emperor.invasion.count == 1) {
                            size = 64;
                        } else if (city_data.emperor.invasion.count == 2) {
                            size = 96;
                        } else {
                            size = 160;
                        }
                        int grid_offset = start_invasion(ENEMY_TYPE_CAESAR, size, 0, FORMATION_ATTACK_BEST_BUILDINGS);
                        if (grid_offset > 0) {
                            city_message_post(1, MESSAGE_CAESAR_ARMY_ATTACK, 0, grid_offset);
                            city_data.emperor.invasion.count++;
                            city_data.emperor.invasion.duration_day_countdown = 192;
                            city_data.emperor.invasion.retreat_message_shown = 0;
                            city_data.emperor.invasion.size = size;
                            city_data.emperor.invasion.soldiers_killed = 0;
                        }
                    }
                }
                break;
            case 5: // update all formations
            {
                for (int j = 0; j < MAX_LEGIONS; j++) {
                    if (legion_formations[j].in_use) {
                        struct formation_t *m = &legion_formations[j];
                        decrease_formation_combat_counters(m);
                        if (m->cursed_by_mars) {
                            m->cursed_by_mars--;
                        }
                        if (m->figure_type == FIGURE_FORT_MOUNTED && m->is_at_rest) {
                            for (int k = 0; k < m->num_figures; k++) {
                                struct figure_t *f = &figures[m->figures[k]];
                                if (f->mounted_charge_ticks < f->mounted_charge_ticks_max) {
                                    f->mounted_charge_ticks += 2;
                                }
                            }
                        }
                        if (!city_data.figure.enemies) {
                            clear_formation_combat_counters(m);
                        }
                        // check formation military training status, send untrained units to train
                        int formation_military_trained = 1;
                        for (int n = 0; n < m->num_figures; n++) {
                            struct figure_t *f = &figures[m->figures[n]];
                            if (!f->is_military_trained) {
                                formation_military_trained = 0;
                                m->has_military_training = 0;
                                if (m->figure_type == FIGURE_FORT_LEGIONARY) {
                                    m->max_morale = 80;
                                } else {
                                    m->max_morale = 60;
                                }
                                if (scenario.allowed_buildings[BUILDING_MILITARY_ACADEMY] && f->action_state == FIGURE_ACTION_SOLDIER_AT_REST) {
                                    struct map_point_t mil_acad_road = { 0 };
                                    set_destination__closest_building_of_type(f->building_id, BUILDING_MILITARY_ACADEMY, &mil_acad_road);
                                    if (mil_acad_road.x) {
                                        f->destination_x = mil_acad_road.x;
                                        f->destination_y = mil_acad_road.y;
                                        f->action_state = FIGURE_ACTION_SOLDIER_GOING_TO_MILITARY_ACADEMY;
                                        break; // causes a delay between sending units
                                    }
                                }
                            }
                        }
                        if (formation_military_trained) {
                            m->has_military_training = 1;
                            if (m->figure_type == FIGURE_FORT_LEGIONARY) {
                                m->max_morale = 100;
                            } else {
                                m->max_morale = 80;
                            }
                        }
                        // check if all units of a formation are at rest (not deployed)
                        int formation_at_rest = 1;
                        for (int n = 0; n < m->num_figures; n++) {
                            struct figure_t *f = &figures[m->figures[n]];
                            if (f->engaged_in_combat
                            || f->action_state == FIGURE_ACTION_SOLDIER_GOING_TO_STANDARD
                            || f->action_state == FIGURE_ACTION_SOLDIER_AT_STANDARD
                            || f->action_state == FIGURE_ACTION_SOLDIER_MOPPING_UP
                            || f->action_state == FIGURE_ACTION_SOLDIER_GOING_TO_DISTANT_BATTLE) {
                                formation_at_rest = 0;
                                m->is_at_rest = 0;
                                break;
                            }
                        }
                        if (formation_at_rest) {
                            m->is_at_rest = 1;
                        }
                        // decrease damage
                        for (int n = 0; n < m->num_figures; n++) {
                            struct figure_t *f = &figures[m->figures[n]];
                            if (figure_is_alive(f) && f->action_state == FIGURE_ACTION_SOLDIER_AT_REST) {
                                if (f->damage) {
                                    f->damage--;
                                }
                            }
                        }
                        if (m->morale > ROUT_MORALE_THRESHOLD) {
                            m->routed = 0;
                        } else {
                            m->standard_x = all_buildings[m->building_id].x + 3;
                            m->standard_y = all_buildings[m->building_id].y - 1;
                            update_legion_standard_map_location(m);
                            // flee back to fort
                            for (int n = 0; n < m->num_figures; n++) {
                                struct figure_t *f = &figures[m->figures[n]];
                                if (f->action_state != FIGURE_ACTION_SOLDIER_AT_REST) {
                                    f->is_fleeing = 1;
                                    figure_route_remove(f);
                                }
                            }
                            // on formation rout, reduce morale of all legions, improve morale of all enemy formations
                            if (!m->routed) {
                                for (int k = 0; k < MAX_LEGIONS; k++) {
                                    legion_formations[k].morale = calc_bound(legion_formations[k].morale - 5, 0, legion_formations[k].max_morale);
                                }
                                for (int k = 0; k < MAX_ENEMY_FORMATIONS; k++) {
                                    if (enemy_formations[k].in_use) {
                                        enemy_formations[k].morale = calc_bound(enemy_formations[k].morale + 5, 0, enemy_formations[k].max_morale);
                                    }
                                }
                                m->routed = 1;
                                if (city_data.figure.enemies) {
                                    play_speech_file("wavs/barbarian_war_cry.wav");
                                }
                            }
                        }
                    }
                }
                for (int j = 0; j < MAX_ENEMY_FORMATIONS; j++) {
                    if (enemy_formations[j].in_use) {
                        struct formation_t *m = &enemy_formations[j];
                        decrease_formation_combat_counters(m);
                        if (!city_data.figure.soldiers) {
                            clear_formation_combat_counters(m);
                        }
                        if (city_data.religion.mars_spirit_power && m->wait_ticks_movement > 16) {
                            int grid_offset = 0;
                            for (int k = 1; k < MAX_FIGURES && city_data.religion.mars_spirit_power > 0; k++) {
                                struct figure_t *f = &figures[k];
                                if (figure_is_alive(f)) {
                                    if ((figure_properties[f->type].is_enemy_unit && f->type != FIGURE_ENEMY_GLADIATOR) || figure_properties[f->type].is_caesar_legion_unit) {
                                        f->is_corpse = 1;
                                        f->is_targetable = 0;
                                        clear_targeting_on_unit_death(f);
                                        city_data.religion.mars_spirit_power--;
                                        if (!grid_offset) {
                                            grid_offset = f->grid_offset;
                                        }
                                    }
                                }
                            }
                            city_data.religion.mars_spirit_power = 0;
                            city_message_post(1, MESSAGE_SPIRIT_OF_MARS, 0, grid_offset);
                        }
                        int formation_spawning = 0;
                        for (int n = 0; n < m->num_figures; n++) {
                            if (figures[m->figures[n]].is_invisible) {
                                formation_spawning = 1;
                                break;
                            }
                        }
                        if (formation_spawning) {
                            // delay all other (already spawned, but not engaged) formations so they move together after
                            for (int k = 0; k < MAX_ENEMY_FORMATIONS; k++) {
                                if (enemy_formations[k].in_use && !(enemy_formations[k].recent_fight || enemy_formations[k].missile_attack_timeout)) {
                                    enemy_formations[k].wait_ticks_movement = 0;
                                }
                            }
                            continue;
                        }
                        if (m->morale <= ROUT_MORALE_THRESHOLD) {
                            for (int n = 0; n < MAX_FORMATION_FIGURES; n++) {
                                struct figure_t *f = &figures[m->figures[n]];
                                f->is_fleeing = 1;
                                figure_route_remove(f);
                            }
                            // on formation rout, reduce morale of all enemy formations, improve morale of all legions
                            if (!m->routed) {
                                for (int k = 0; k < MAX_ENEMY_FORMATIONS; k++) {
                                    if (enemy_formations[k].in_use) {
                                        enemy_formations[k].morale = calc_bound(enemy_formations[k].morale - 5, 0, enemy_formations[k].max_morale);
                                    }
                                }
                                for (int k = 0; k < MAX_LEGIONS; k++) {
                                    legion_formations[k].morale = calc_bound(legion_formations[k].morale + 5, 0, legion_formations[k].max_morale);
                                }
                                m->routed = 1;
                                play_sound_effect(SOUND_EFFECT_HORN3);
                                play_speech_file("wavs/army_war_cry.wav");
                            }
                            continue;
                        }

                        if (m->recent_fight || m->missile_attack_timeout) {
                            for (int k = 0; k < MAX_ENEMY_FORMATIONS; k++) {
                                if (enemy_formations[k].in_use) {
                                    enemy_formations[k].wait_ticks_movement += 2;
                                }
                            }
                        } else {
                            m->wait_ticks_movement++;
                        }
                        struct figure_t *target_unit = 0;
                        for (int n = 0; n < m->num_figures; n++) {
                            struct figure_t *f = &figures[m->figures[n]];
                            if (!figure_properties[f->type].max_range) {
                                target_unit = melee_unit__set_closest_target(f);
                                if (target_unit) {
                                    if (m->layout == FORMATION_ENEMY_MOB  // melee units in a mob break rank to chase enemies
                                    || (target_unit->type == FIGURE_FORT_JAVELIN && f->speed_multiplier >= target_unit->speed_multiplier)) { // melee units in other formations chase javelins only, and only if they are at least as fast as them
                                        f->destination_x = target_unit->x;
                                        f->destination_y = target_unit->y;
                                        f->action_state = FIGURE_ACTION_ENEMY_ENGAGED;
                                    }
                                }
                            }
                        }

                        if (m->wait_ticks_movement > LAYOUT_REGROUP_DURATION[m->layout]) {
                            if (target_unit) {
                                int reinforcements_sent = 0;
                                for (int k = 0; k < MAX_ENEMY_FORMATIONS; k++) {
                                    if (enemy_formations[k].in_use) {
                                        for (int n = 0; n < enemy_formations[k].num_figures; n++) {
                                            struct figure_t *f = &figures[enemy_formations[k].figures[n]];
                                            if (!f->is_invisible) {
                                                f->destination_x = target_unit->x;
                                                f->destination_y = target_unit->y;
                                                f->target_figure_id = target_unit->id;
                                                f->action_state = FIGURE_ACTION_ENEMY_ENGAGED;
                                                reinforcements_sent++;
                                            }
                                        }
                                        if (reinforcements_sent >= city_data.figure.soldiers
                                        || (m->figure_type == FIGURE_ENEMY_CAESAR_LEGIONARY && reinforcements_sent >= city_data.figure.imperial_soldiers)
                                        || (m->figure_type != FIGURE_ENEMY_CAESAR_LEGIONARY && reinforcements_sent >= city_data.figure.enemies)) {
                                            break;
                                        }
                                    }
                                }
                            }
                            struct building_t *target_building = 0;
                            int attack = m->attack_priority;
                            if (attack == FORMATION_ATTACK_RANDOM) {
                                attack = rand() % 4;
                            }
                            int best_type_index = 100;
                            struct building_t *best_building = 0;
                            int min_distance = 10000;
                            for (int k = 1; k < MAX_BUILDINGS; k++) {
                                struct building_t *b = &all_buildings[k];
                                if (b->state != BUILDING_STATE_IN_USE) {
                                    continue;
                                }
                                for (int n = 0; n < 100 && n <= best_type_index && ENEMY_ATTACK_PRIORITY[attack][n]; n++) {
                                    if (b->type == ENEMY_ATTACK_PRIORITY[attack][n]) {
                                        int distance = calc_maximum_distance(figures[m->figures[0]].x, figures[m->figures[0]].y, b->x, b->y);
                                        if (n < best_type_index) {
                                            best_type_index = n;
                                            best_building = b;
                                            min_distance = distance;
                                        } else if (distance < min_distance) {
                                            best_building = b;
                                            min_distance = distance;
                                        }
                                        break;
                                    }
                                }
                            }
                            if (best_building) {
                                target_building = best_building;
                            } else {
                                // no priority buildings left: target population
                                for (int k = 1; k < MAX_BUILDINGS; k++) {
                                    struct building_t *b = &all_buildings[k];
                                    if (b->state != BUILDING_STATE_IN_USE) {
                                        continue;
                                    }
                                    if (building_is_house(b->type)) {
                                        target_building = b;
                                    }
                                }
                            }
                            if (target_building) {
                                if (map_routing_noncitizen_can_travel_over_land(m->destination_x, m->destination_y, target_building->x, target_building->y, 0, 400)
                                || map_routing_noncitizen_can_travel_through_everything(m->destination_x, m->destination_y, target_building->x, target_building->y)) {
                                    int x_tile, y_tile;
                                    int dst_grid_offset = map_grid_offset(target_building->x, target_building->y);
                                    int distance = routing_distance.items[dst_grid_offset];
                                    if (distance > 0 && distance < 998) {
                                        int num_tiles = 0;
                                        int last_direction = -1;
                                        int x = target_building->x;
                                        int y = target_building->y;
                                        int grid_offset = dst_grid_offset;
                                        while (distance > 1) {
                                            distance = routing_distance.items[grid_offset];
                                            x_tile = x;
                                            y_tile = y;
                                            if (distance <= 20) {
                                                m->destination_x = x_tile;
                                                m->destination_y = y_tile;
                                                for (int n = 0; n < m->num_figures; n++) {
                                                    struct figure_t *f = &figures[m->figures[n]];
                                                    if (!f->is_invisible && (f->action_state == FIGURE_ACTION_ENEMY_SPAWNING || f->action_state == FIGURE_ACTION_ENEMY_REGROUPING)) {
                                                        f->action_state = FIGURE_ACTION_ENEMY_ADVANCING;
                                                    }
                                                }
                                                m->wait_ticks_movement = 0;
                                                break;
                                            }
                                            int direction = -1;
                                            int general_direction = calc_general_direction(x, y, m->destination_x, m->destination_y);
                                            for (int d = 0; d < 8; d++) {
                                                if (d != last_direction) {
                                                    int next_offset = grid_offset + map_grid_direction_delta(d);
                                                    int next_distance = routing_distance.items[next_offset];
                                                    if (next_distance) {
                                                        if (next_distance < 20) {
                                                            distance = next_distance;
                                                            direction = d;
                                                        } else if (next_distance == distance && (d == general_direction || direction == -1)) {
                                                            distance = next_distance;
                                                            direction = d;
                                                        }
                                                    }
                                                }
                                            }
                                            if (direction != -1) {
                                                adjust_tile_in_direction(direction, &x, &y, &grid_offset);
                                                int forward_direction = (direction + 4) % 8;
                                                direction_path[num_tiles++] = forward_direction;
                                                last_direction = forward_direction;
                                                if (num_tiles >= MAX_PATH) {
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (city_data.figure.animals) {
                    for (int k = 0; k < MAX_HERD_POINTS; k++) {
                        if (herd_formations[k].in_use && herd_formations[k].num_figures) {
                            struct formation_t *m = &herd_formations[k];
                            int random_factor = rand();
                            int roam_distance = 0;
                            int roam_delay = 0;
                            switch (m->figure_type) {
                                case FIGURE_WOLF:
                                    roam_distance = (random_factor % MAX_WOLF_ROAM_DISTANCE) >= MAX_WOLF_ROAM_DISTANCE / 2 ? (random_factor % MAX_WOLF_ROAM_DISTANCE) : MAX_WOLF_ROAM_DISTANCE;
                                    roam_delay = WOLF_PACK_ROAM_DELAY;
                                    break;
                                case FIGURE_SHEEP:
                                    roam_distance = (random_factor % MAX_SHEEP_ROAM_DISTANCE) >= MAX_SHEEP_ROAM_DISTANCE / 2 ? (random_factor % MAX_SHEEP_ROAM_DISTANCE) : MAX_SHEEP_ROAM_DISTANCE;
                                    roam_delay = SHEEP_HERD_ROAM_DELAY;
                                    break;
                                case FIGURE_ZEBRA:
                                    roam_distance = (random_factor % MAX_ZEBRA_ROAM_DISTANCE) >= MAX_ZEBRA_ROAM_DISTANCE / 2 ? (random_factor % MAX_ZEBRA_ROAM_DISTANCE) : MAX_ZEBRA_ROAM_DISTANCE;
                                    roam_delay = ZEBRA_HERD_ROAM_DELAY;
                                    break;
                                default:
                                    break;
                            }
                            decrease_formation_combat_counters(m);
                            // being shot at or attacked prompts an immediate response
                            if (m->missile_attack_timeout) {
                                set_herd_formation_in_motion(m, roam_distance);
                            } else {
                                for (int l = 0; l < m->num_figures; l++) {
                                    struct figure_t *f = &figures[m->figures[l]];
                                    if (f->engaged_in_combat) {
                                        m->wait_ticks_movement = roam_delay;
                                        break;
                                    }
                                }
                                m->wait_ticks_movement++;
                                if (m->wait_ticks_movement > roam_delay) {
                                    set_herd_formation_in_motion(m, roam_distance);
                                }
                            }
                        }
                    }
                }
                break;
            }
            case 6:
            {
                for (int j = 0; j < GRID_SIZE * GRID_SIZE; j++) {
                    edge_grid.items[j] &= EDGE_NO_NATIVE_LAND;
                }
                if (city_data.military.native_attack_duration) {
                    city_data.military.native_attack_duration--;
                }

                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE) {
                        continue;
                    }
                    int size, radius;
                    if (b->type == BUILDING_NATIVE_HUT) {
                        size = 1;
                        radius = 3;
                    } else if (b->type == BUILDING_NATIVE_MEETING) {
                        size = 2;
                        radius = 6;
                    } else {
                        continue;
                    }
                    if (b->sentiment.native_anger >= 100) {
                        mark_native_land(b->x, b->y, size, radius);
                        int x_min, y_min, x_max, y_max;
                        map_grid_get_area(b->x, b->y, size, radius, &x_min, &y_min, &x_max, &y_max);
                        for (int yy = y_min; yy <= y_max; yy++) {
                            for (int xx = x_min; xx <= x_max; xx++) {
                                int building_id = map_building_at(map_grid_offset(xx, yy));
                                if (building_id > 0) {
                                    int type = all_buildings[building_id].type;
                                    if (type != BUILDING_MISSION_POST &&
                                        type != BUILDING_NATIVE_HUT &&
                                        type != BUILDING_NATIVE_MEETING &&
                                        type != BUILDING_NATIVE_CROPS) {
                                        city_data.military.native_attack_duration = 1;
                                        break;
                                    }
                                }
                            }
                        }
                    } else {
                        b->sentiment.native_anger++;
                    }
                }
            }
            break;
            case 7: map_road_network_update(); break;
            case 8: building_granaries_calculate_stocks(); break;
            case 10: // update building highest id
            {
                extra.highest_id_in_use = 0;
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    if (all_buildings[j].state != BUILDING_STATE_UNUSED) {
                        extra.highest_id_in_use = j;
                    }
                }
                if (extra.highest_id_in_use > extra.highest_id_ever) {
                    extra.highest_id_ever = extra.highest_id_in_use;
                }
            }
            break;
            case 12: // decay houses services coverage
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_UNUSED && b->type != BUILDING_TOWER) {
                        if (b->houses_covered <= 1) {
                            b->houses_covered = 0;
                        } else {
                            b->houses_covered--;
                        }
                    }
                }
                break;
            case 16: // calculate warehouse stocks
            {
                for (int j = 0; j < RESOURCE_TYPES_MAX; j++) {
                    city_data.resource.space_in_warehouses[i] = 0;
                    city_data.resource.stored_in_warehouses[i] = 0;
                }
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_WAREHOUSE) {
                        b->has_road_access = 0;
                        if (map_has_road_access(b->x, b->y, b->size, 0)) {
                            b->has_road_access = 1;
                        } else if (map_has_road_access(b->x, b->y, 3, 0)) {
                            b->has_road_access = 2;
                        }
                    }
                }
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_WAREHOUSE_SPACE) {
                        continue;
                    }
                    struct building_t *warehouse = building_main(b);
                    if (warehouse->has_road_access) {
                        b->has_road_access = warehouse->has_road_access;
                        if (b->subtype.warehouse_resource_id) {
                            int loads = b->loads_stored;
                            int resource = b->subtype.warehouse_resource_id;
                            city_data.resource.stored_in_warehouses[resource] += loads;
                            city_data.resource.space_in_warehouses[resource] += 4 - loads;
                        } else {
                            city_data.resource.space_in_warehouses[RESOURCE_NONE] += 4;
                        }
                    }
                }
            }
            break;
            case 17: city_resource_calculate_food_stocks_and_supply_wheat(); break;
            case 18: // calculate workshop stocks
            {
                for (int j = 0; j < 6; j++) {
                    city_data.resource.stored_in_workshops[j] = 0;
                    city_data.resource.space_in_workshops[j] = 0;
                }
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE || !building_is_workshop(b->type)) {
                        continue;
                    }
                    b->has_road_access = 0;
                    if (map_has_road_access(b->x, b->y, b->size, 0)) {
                        b->has_road_access = 1;
                        int room = 2 - b->loads_stored;
                        if (room < 0) {
                            room = 0;
                        }
                        int workshop_resource = b->subtype.workshop_type;
                        city_data.resource.space_in_workshops[workshop_resource] += room;
                        city_data.resource.stored_in_workshops[workshop_resource] += b->loads_stored;
                    }
                }
            }
            break;
            case 19: // update dock open water access
                map_routing_calculate_distances_water_boat(scenario.river_entry_point.x, scenario.river_entry_point.y);
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state == BUILDING_STATE_IN_USE && !b->house_size && b->type == BUILDING_DOCK) {
                        if (map_terrain_is_adjacent_to_open_water(b->x, b->y, 3)) {
                            b->has_water_access = 1;
                        } else {
                            b->has_water_access = 0;
                        }
                    }
                }
                break;
            case 20: // update industry production
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE || !b->output_resource_id) {
                        continue;
                    }
                    b->data.industry.has_raw_materials = 0;
                    if (b->houses_covered <= 0 || b->num_workers <= 0) {
                        continue;
                    }
                    if (b->subtype.workshop_type && !b->loads_stored) {
                        continue;
                    }
                    if (b->data.industry.curse_days_left) {
                        b->data.industry.curse_days_left--;
                    } else {
                        if (b->data.industry.blessing_days_left) {
                            b->data.industry.blessing_days_left--;
                        }
                        if (b->type == BUILDING_MARBLE_QUARRY) {
                            b->data.industry.progress += b->num_workers / 2;
                        } else {
                            b->data.industry.progress += b->num_workers;
                        }
                        if (b->data.industry.blessing_days_left && building_is_farm(b->type)) {
                            b->data.industry.progress += b->num_workers;
                        }
                        int max = b->subtype.workshop_type ? MAX_PROGRESS_WORKSHOP : MAX_PROGRESS_RAW;
                        if (b->data.industry.progress > max) {
                            b->data.industry.progress = max;
                        }
                        if (building_is_farm(b->type)) {
                            update_farm_image(b);
                        }
                    }
                }
                break;
            case 22: // update house room
                city_data.population.total_capacity = 0;
                city_data.population.room_in_houses = 0;

                building_list_large_clear(0);
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state == BUILDING_STATE_IN_USE && b->house_size) {
                        building_list_large_add(j);
                    }
                }
                houses = building_list_large_items();
                for (int j = 0; j < building_list_data.large.size; j++) {
                    struct building_t *b = &all_buildings[houses[j]];
                    b->house_population_room = 0;
                    int max_pop = house_properties[b->subtype.house_level].max_people;
                    if (b->house_is_merged) {
                        max_pop *= 4;
                    }
                    city_data.population.total_capacity += max_pop;
                    city_data.population.room_in_houses += max_pop - b->house_population;
                    b->house_population_room = max_pop - b->house_population;
                    if (b->house_population > b->house_highest_population) {
                        b->house_highest_population = b->house_population;
                    }
                }
                break;
            case 23: // update migration
                if (city_data.sentiment.value > 70) {
                    city_data.migration.percentage = 100;
                } else if (city_data.sentiment.value > 60) {
                    city_data.migration.percentage = 75;
                } else if (city_data.sentiment.value >= 50) {
                    city_data.migration.percentage = 50;
                } else if (city_data.sentiment.value > 40) {
                    city_data.migration.percentage = 0;
                } else if (city_data.sentiment.value > 30) {
                    city_data.migration.percentage = -10;
                } else if (city_data.sentiment.value > 20) {
                    city_data.migration.percentage = -25;
                } else {
                    city_data.migration.percentage = -50;
                }
                city_data.migration.immigration_amount_per_batch = 0;
                city_data.migration.emigration_amount_per_batch = 0;
                int population_cap = 200000;
                if (city_data.population.population >= population_cap) {
                    city_data.migration.percentage = 0;
                } else if (city_figures_total_invading_enemies() > 3 && city_data.migration.percentage > 0) { // war scares immigrants away
                    city_data.migration.percentage = 0;
                } else {
                    if (city_data.migration.percentage > 0) {
                        // immigration
                        if (city_data.migration.emigration_duration) {
                            city_data.migration.emigration_duration--;
                        } else {
                            city_data.migration.immigration_amount_per_batch = calc_adjust_with_percentage(12, city_data.migration.percentage);
                            city_data.migration.immigration_duration = 2;
                        }
                    } else if (city_data.migration.percentage < 0) {
                        // emigration
                        if (city_data.migration.immigration_duration) {
                            city_data.migration.immigration_duration--;
                        } else if (city_data.population.population > 100) {
                            city_data.migration.emigration_amount_per_batch = calc_adjust_with_percentage(12, -city_data.migration.percentage);
                            city_data.migration.emigration_duration = 2;
                        }
                    }
                }
                city_data.migration.immigrated_today = 0;
                city_data.migration.emigrated_today = 0;
                city_data.migration.refused_immigrants_today = 0;
                if (city_data.migration.immigration_amount_per_batch > 0) {
                    if (city_data.migration.immigration_amount_per_batch >= 4) {
                        create_immigrants(city_data.migration.immigration_amount_per_batch);
                    } else if (city_data.migration.immigration_amount_per_batch
                        + city_data.migration.immigration_queue_size >= 4) {
                        create_immigrants(city_data.migration.immigration_amount_per_batch
                            + city_data.migration.immigration_queue_size);
                        city_data.migration.immigration_queue_size = 0;
                    } else {
                        // queue them for next round
                        city_data.migration.immigration_queue_size += city_data.migration.immigration_amount_per_batch;
                    }
                }
                if (city_data.migration.emigration_amount_per_batch > 0) {
                    if (city_data.migration.emigration_amount_per_batch >= 4) {
                        create_emigrants(city_data.migration.emigration_amount_per_batch);
                    } else if (city_data.migration.emigration_amount_per_batch + city_data.migration.emigration_queue_size >= 4) {
                        create_emigrants(city_data.migration.emigration_amount_per_batch
                            + city_data.migration.emigration_queue_size);
                        city_data.migration.emigration_queue_size = 0;
                        if (!city_data.migration.emigration_message_shown) {
                            city_data.migration.emigration_message_shown = 1;
                            city_message_post(1, MESSAGE_EMIGRATION, 0, 0);
                        }
                    } else {
                        // queue them for next round
                        city_data.migration.emigration_queue_size += city_data.migration.emigration_amount_per_batch;
                    }
                }
                city_data.migration.immigration_amount_per_batch = 0;
                city_data.migration.emigration_amount_per_batch = 0;
                if (city_data.population.yearly_update_requested) {
                    int aged100 = city_data.population.at_age[99];
                    for (int age = 99; age > 0; age--) {
                        city_data.population.at_age[age] = city_data.population.at_age[age - 1];
                    }
                    city_data.population.at_age[0] = 0;
                    city_data.population.yearly_deaths = 0;
                    for (int decennium = 9; decennium >= 0; decennium--) {
                        int people = get_people_in_age_decennium(decennium);
                        int death_percentage = DEATHS_PER_HEALTH_PER_AGE_DECENNIUM[city_data.health.value / 10][decennium];
                        int deaths = calc_adjust_with_percentage(people, death_percentage);
                        int removed = house_population_remove_from_city(deaths + aged100);
                        int empty_buckets = 0;
                        int age = 0;
                        while (deaths > 0 && empty_buckets < 10) {
                            if (city_data.population.at_age[10 * decennium + age] <= 0) {
                                empty_buckets++;
                            } else {
                                city_data.population.at_age[10 * decennium + age]--;
                                deaths--;
                                empty_buckets = 0;
                            }
                            age++;
                            if (age >= 10) {
                                age = 0;
                            }
                        }
                        city_data.population.yearly_deaths += removed;
                        aged100 = 0;
                    }
                    city_data.population.yearly_births = 0;
                    for (int decennium = 9; decennium >= 0; decennium--) {
                        int people = get_people_in_age_decennium(decennium);
                        int births = calc_adjust_with_percentage(people, BIRTHS_PER_AGE_DECENNIUM[decennium]);
                        int added = 0;
                        int building_id = city_data.population.last_used_house_add;
                        for (int k = 1; k < MAX_BUILDINGS && added < births; k++) {
                            if (++building_id >= MAX_BUILDINGS) {
                                building_id = 1;
                            }
                            struct building_t *b = &all_buildings[building_id];
                            if (b->state == BUILDING_STATE_IN_USE && b->house_size && b->house_population > 0) {
                                city_data.population.last_used_house_add = building_id;
                                int max_people = house_properties[b->subtype.house_level].max_people;
                                if (b->house_is_merged) {
                                    max_people *= 4;
                                }
                                if (b->house_population < max_people) {
                                    ++added;
                                    ++b->house_population;
                                    b->house_population_room = max_people - b->house_population;
                                }
                            }
                        }
                        city_data.population.at_age[0] += added;
                        city_data.population.yearly_births += added;
                    }
                    city_data.population.yearly_update_requested = 0;
                    city_data.population.population_last_year = city_data.population.population;
                    recalculate_population();
                    city_data.population.lost_removal = 0;
                    city_data.population.total_all_years += city_data.population.population;
                    city_data.population.total_years++;
                    city_data.population.average_per_year = city_data.population.total_all_years / city_data.population.total_years;
                }
                int num_plebs = 0;
                int num_patricians = 0;
                houses = building_list_large_items();
                for (int j = 0; j < building_list_data.large.size; j++) {
                    struct building_t *b = &all_buildings[houses[j]];
                    if (b->house_population > 0) {
                        if (b->subtype.house_level >= HOUSE_SMALL_VILLA) {
                            num_patricians += b->house_population;
                        } else {
                            num_plebs += b->house_population;
                        }
                    }
                }
                city_data.population.percentage_plebs = calc_percentage(num_plebs, num_plebs + num_patricians);
                city_data.population.working_age = calc_adjust_with_percentage(get_people_in_age_decennium(2) + get_people_in_age_decennium(3) + get_people_in_age_decennium(4), 60);
                city_data.labor.workers_available = calc_adjust_with_percentage(city_data.population.working_age, city_data.population.percentage_plebs);
                // population messages
                if (city_data.population.population >= 500 && city_message_mark_population_shown(500)) {
                    city_message_post(1, MESSAGE_POPULATION_500, 0, 0);
                }
                if (city_data.population.population >= 1000 && city_message_mark_population_shown(1000)) {
                    city_message_post(1, MESSAGE_POPULATION_1000, 0, 0);
                }
                if (city_data.population.population >= 2000 && city_message_mark_population_shown(2000)) {
                    city_message_post(1, MESSAGE_POPULATION_2000, 0, 0);
                }
                if (city_data.population.population >= 3000 && city_message_mark_population_shown(3000)) {
                    city_message_post(1, MESSAGE_POPULATION_3000, 0, 0);
                }
                if (city_data.population.population >= 5000 && city_message_mark_population_shown(5000)) {
                    city_message_post(1, MESSAGE_POPULATION_5000, 0, 0);
                }
                if (city_data.population.population >= 10000 && city_message_mark_population_shown(10000)) {
                    city_message_post(1, MESSAGE_POPULATION_10000, 0, 0);
                }
                if (city_data.population.population >= 15000 && city_message_mark_population_shown(15000)) {
                    city_message_post(1, MESSAGE_POPULATION_15000, 0, 0);
                }
                if (city_data.population.population >= 20000 && city_message_mark_population_shown(20000)) {
                    city_message_post(1, MESSAGE_POPULATION_20000, 0, 0);
                }
                if (city_data.population.population >= 25000 && city_message_mark_population_shown(25000)) {
                    city_message_post(1, MESSAGE_POPULATION_25000, 0, 0);
                }
                break;
            case 24: // evict overcrowded
            {
                int *items = building_list_large_items();
                for (int j = 0; j < building_list_data.large.size; j++) {
                    struct building_t *b = &all_buildings[items[j]];
                    if (b->house_population_room < 0) {
                        int num_people_to_evict = -b->house_population_room;
                        figure_create_homeless(b->x, b->y, num_people_to_evict);
                        if (num_people_to_evict < b->house_population) {
                            b->house_population -= num_people_to_evict;
                        } else {
                            // house has been removed
                            b->state = BUILDING_STATE_UNDO;
                        }
                    }
                }
                break;
            }
            case 25: // update labor
            {    // calculate workers needed per category
                for (int cat = 0; cat < LABOR_CATEGORIES_COUNT; cat++) {
                    city_data.labor.categories[cat].buildings = 0;
                    city_data.labor.categories[cat].total_houses_covered = 0;
                    city_data.labor.categories[cat].workers_allocated = 0;
                    city_data.labor.categories[cat].workers_needed = 0;
                }
                for (int k = 1; k < MAX_BUILDINGS; k++) {
                    struct building_t *b = &all_buildings[k];
                    if (b->state != BUILDING_STATE_IN_USE) {
                        continue;
                    }
                    b->labor_category = building_properties[b->type].labor_category;
                    if (!should_have_workers(b, 1)) {
                        continue;
                    }
                    city_data.labor.categories[b->labor_category].workers_needed += building_properties[b->type].n_laborers;
                    city_data.labor.categories[b->labor_category].total_houses_covered += b->houses_covered;
                    city_data.labor.categories[b->labor_category].buildings++;
                }
                // check employment
                int orig_needed = city_data.labor.workers_needed;
                allocate_workers_to_categories();
                // senate unemployment display is delayed when unemployment is rising
                if (city_data.labor.unemployment_percentage < city_data.labor.unemployment_percentage_for_senate) {
                    city_data.labor.unemployment_percentage_for_senate = city_data.labor.unemployment_percentage;
                } else if (city_data.labor.unemployment_percentage < city_data.labor.unemployment_percentage_for_senate + 5) {
                    city_data.labor.unemployment_percentage_for_senate = city_data.labor.unemployment_percentage;
                } else {
                    city_data.labor.unemployment_percentage_for_senate += 5;
                }
                if (city_data.labor.unemployment_percentage_for_senate > 100) {
                    city_data.labor.unemployment_percentage_for_senate = 100;
                }
                // workers needed message
                if (!orig_needed && city_data.labor.workers_needed > 0) {
                    if (time_data.year >= scenario.start_year) {
                        city_message_post_with_message_delay(MESSAGE_CAT_WORKERS_NEEDED, 0, MESSAGE_WORKERS_NEEDED, 6);
                    }
                }
                allocate_workers_to_buildings();
            }
            break;
            case 27: // update water supply
            {
                for (int k = 0; k < GRID_SIZE * GRID_SIZE; k++) {
                    terrain_grid.items[k] &= ~(TERRAIN_FOUNTAIN_RANGE | TERRAIN_RESERVOIR_RANGE);
                }
                // reservoirs
                int image_without_water = 681;
                int grid_offset = map_data.start_offset;
                for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
                    for (int x = 0; x < map_data.width; x++, grid_offset++) {
                        if (map_terrain_is(grid_offset, TERRAIN_AQUEDUCT)) {
                            aqueduct.items[grid_offset] = 0;
                            if (images.items[grid_offset] < image_without_water) {
                                images.items[grid_offset] = images.items[grid_offset] + 15;
                            }
                        }
                    }
                }
                building_list_large_clear(1);
                // mark reservoirs next to water
                for (int k = 1; k < MAX_BUILDINGS; k++) {
                    struct building_t *b = &all_buildings[i];
                    if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_RESERVOIR) {
                        building_list_large_add(k);
                        if (map_terrain_exists_tile_in_area_with_type(b->x - 1, b->y - 1, 5, TERRAIN_WATER)) {
                            b->has_water_access = 2;
                        } else {
                            b->has_water_access = 0;
                        }
                    }
                }
                int *reservoirs = building_list_large_items();
                // fill reservoirs from full ones
                int changed = 1;
                static   int CONNECTOR_OFFSETS[] = { OFFSET(1,-1), OFFSET(3,1), OFFSET(1,3), OFFSET(-1,1) };
                while (changed == 1) {
                    changed = 0;
                    for (int l = 0; l < building_list_data.large.size; l++) {
                        struct building_t *b = &all_buildings[reservoirs[l]];
                        if (b->has_water_access == 2) {
                            b->has_water_access = 1;
                            changed = 1;
                            for (int d = 0; d < 4; d++) {
                                int grid_offset2 = b->grid_offset + CONNECTOR_OFFSETS[d];
                                if (map_terrain_is(grid_offset2, TERRAIN_AQUEDUCT)) {
                                    memset(&water_supply_queue, 0, sizeof(water_supply_queue));
                                    int guard = 0;
                                    int next_offset;
                                    do {
                                        if (++guard >= GRID_SIZE * GRID_SIZE) {
                                            break;
                                        }
                                        aqueduct.items[grid_offset2] = 1;
                                        int image_id = images.items[grid_offset2];
                                        if (image_id >= image_without_water) {
                                            images.items[grid_offset2] = image_id - 15;
                                        }
                                        next_offset = -1;
                                        for (int j = 0; j < 4; j++) {
                                            int new_offset = grid_offset2 + ADJACENT_OFFSETS_ROUTING[j];
                                            struct building_t *bb = &all_buildings[map_building_at(new_offset)];
                                            if (bb->id && bb->type == BUILDING_RESERVOIR) {
                                                // check if aqueduct connects to reservoir --> doesn't connect to corner
                                                int xy = edge_grid.items[new_offset] & EDGE_MASK_XY;
                                                if (xy != EDGE_X0Y0 && xy != EDGE_X2Y0 && xy != EDGE_X0Y2 && xy != EDGE_X2Y2) {
                                                    if (!bb->has_water_access) {
                                                        bb->has_water_access = 2;
                                                    }
                                                }
                                            } else if (map_terrain_is(new_offset, TERRAIN_AQUEDUCT)) {
                                                if (!aqueduct.items[new_offset]) {
                                                    if (next_offset == -1) {
                                                        next_offset = new_offset;
                                                    } else {
                                                        water_supply_queue.items[water_supply_queue.tail++] = new_offset;
                                                        if (water_supply_queue.tail >= MAX_QUEUE) {
                                                            water_supply_queue.tail = 0;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        if (next_offset == -1) {
                                            if (water_supply_queue.head != water_supply_queue.tail) {
                                                next_offset = water_supply_queue.items[water_supply_queue.head++];
                                                if (water_supply_queue.head >= MAX_QUEUE) {
                                                    water_supply_queue.head = 0;
                                                }
                                            }
                                        }
                                        grid_offset2 = next_offset;
                                    } while (next_offset > -1);
                                }
                            }
                        }
                    }
                }
                // mark reservoir ranges
                for (int k = 0; k < building_list_data.large.size; k++) {
                    struct building_t *b = &all_buildings[reservoirs[k]];
                    if (b->has_water_access) {
                        map_terrain_add_with_radius(b->x, b->y, 3, 10, TERRAIN_RESERVOIR_RANGE);
                    }
                }
                // fountains
                for (int k = 1; k < MAX_BUILDINGS; k++) {
                    struct building_t *b = &all_buildings[k];
                    if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_FOUNTAIN) {
                        continue;
                    }
                    int image_id;
                    if (desirability_grid.items[b->grid_offset] > 60) {
                        image_id = 2831;
                    } else if (desirability_grid.items[b->grid_offset] > 40) {
                        image_id = 2855;
                    } else if (desirability_grid.items[b->grid_offset] > 20) {
                        image_id = 2847;
                    } else {
                        image_id = 2839;
                    }
                    map_building_tiles_add(i, b->x, b->y, 1, image_id, TERRAIN_BUILDING);
                    if (map_terrain_is(b->grid_offset, TERRAIN_RESERVOIR_RANGE) && b->num_workers) {
                        b->has_water_access = 1;
                        map_terrain_add_with_radius(b->x, b->y, 1,
                            scenario.climate == CLIMATE_DESERT ? 3 : 4,
                            TERRAIN_FOUNTAIN_RANGE);
                    } else {
                        b->has_water_access = 0;
                    }
                }
                // wells (to show range in water overlay)
                for (int k = 1; k < MAX_BUILDINGS; k++) {
                    struct building_t *b = &all_buildings[k];
                    if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_WELL) {
                        continue;
                    }
                    map_terrain_add_with_radius(b->x, b->y, 1, 2, TERRAIN_FOUNTAIN_RANGE);
                }
            }
            break;
            case 28: // update houses water supply
                building_list_data.small.size = 0;
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE) {
                        continue;
                    }
                    if (b->type == BUILDING_WELL) {
                        building_list_small_add(j);
                    } else if (b->house_size) {
                        b->has_water_access = 0;
                        b->has_well_access = 0;
                        if (map_terrain_exists_tile_in_area_with_type(
                            b->x, b->y, b->size, TERRAIN_FOUNTAIN_RANGE)) {
                            b->has_water_access = 1;
                        }
                    }
                }
                for (int j = 0; j < building_list_data.small.size; j++) {
                    struct building_t *well = &all_buildings[building_list_data.small.items[j]];
                    int x_min, y_min, x_max, y_max;
                    map_grid_get_area(well->x, well->y, 1, 2, &x_min, &y_min, &x_max, &y_max);

                    for (int yy = y_min; yy <= y_max; yy++) {
                        for (int xx = x_min; xx <= x_max; xx++) {
                            int building_id = map_building_at(map_grid_offset(xx, yy));
                            if (building_id) {
                                all_buildings[building_id].has_well_access = 1;
                            }
                        }
                    }
                }
                break;
            case 30:
                minimap_data.refresh_requested = 1;
                break;
            case 31: // generate building figures
            {
                if (tower_sentry_request > 0) {
                    tower_sentry_request--;
                }
                for (int k = 1; k <= extra.highest_id_in_use; k++) {
                    struct building_t *b = &all_buildings[k];
                    if (b->state != BUILDING_STATE_IN_USE) {
                        continue;
                    }
                    if (b->type == BUILDING_WAREHOUSE_SPACE || (b->type == BUILDING_HIPPODROME && b->prev_part_building_id)) {
                        continue;
                    }
                    b->show_on_problem_overlay = 0;
                    // range of building types
                    if (b->type >= BUILDING_HOUSE_SMALL_VILLA && b->type <= BUILDING_HOUSE_LUXURY_PALACE) {
                        struct map_point_t road;
                        if (map_has_road_access(b->x, b->y, b->size, &road)) {
                            b->figure_spawn_delay++;
                            if (b->figure_spawn_delay > 40) {
                                b->figure_spawn_delay = 0;
                                struct figure_t *f = figure_create(FIGURE_PATRICIAN, road.x, road.y, DIR_4_BOTTOM);
                                f->action_state = FIGURE_ACTION_ROAMING;
                                f->is_targetable = 1;
                                f->terrain_usage = TERRAIN_USAGE_ROADS;
                                f->building_id = b->id;
                                figure_movement_init_roaming(f);
                            }
                        }
                    } else if (b->type >= BUILDING_WHEAT_FARM && b->type <= BUILDING_WEAPONS_WORKSHOP) {
                        check_labor_problem(b);
                        struct map_point_t road;
                        if (map_has_road_access(b->x, b->y, b->size, &road)) {
                            spawn_labor_seeker(b, road.x, road.y, 50);
                            if (!has_figure_of_types(b, FIGURE_CART_PUSHER, 0)) {
                                if (b->data.industry.progress >= (b->subtype.workshop_type ? MAX_PROGRESS_WORKSHOP : MAX_PROGRESS_RAW)) {
                                    b->data.industry.progress = 0;
                                    if (b->subtype.workshop_type) {
                                        if (b->loads_stored) {
                                            if (b->loads_stored > 1) {
                                                b->data.industry.has_raw_materials = 1;
                                            }
                                            b->loads_stored--;
                                        }
                                    }
                                    if (building_is_farm(b->type)) {
                                        update_farm_image(b);
                                    }
                                    struct figure_t *f = figure_create(FIGURE_CART_PUSHER, road.x, road.y, DIR_4_BOTTOM);
                                    f->action_state = FIGURE_ACTION_CARTPUSHER_INITIAL;
                                    f->is_targetable = 1;
                                    f->terrain_usage = TERRAIN_USAGE_ROADS;
                                    f->resource_id = b->output_resource_id;
                                    f->building_id = b->id;
                                    b->figure_id = f->id;
                                    f->wait_ticks = 30;
                                }
                            }
                        }
                    } else if (b->type == BUILDING_SENATE || b->type == BUILDING_FORUM) {
                        if (b->type == BUILDING_SENATE && b->state == BUILDING_STATE_IN_USE) {
                            if (desirability_grid.items[b->grid_offset] <= 30) {
                                map_building_tiles_add(b->id, b->x, b->y, b->size, 3158, TERRAIN_BUILDING);
                            } else {
                                map_building_tiles_add(b->id, b->x, b->y, b->size, 3163, TERRAIN_BUILDING);
                            }
                        }
                        check_labor_problem(b);
                        if (!has_figure_of_types(b, FIGURE_TAX_COLLECTOR, 0)) {
                            struct map_point_t road;
                            if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                spawn_labor_seeker(b, road.x, road.y, 50);
                                int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                int spawn_delay;
                                if (pct_workers >= 100) {
                                    spawn_delay = 0;
                                } else if (pct_workers >= 75) {
                                    spawn_delay = 1;
                                } else if (pct_workers >= 50) {
                                    spawn_delay = 3;
                                } else if (pct_workers >= 25) {
                                    spawn_delay = 7;
                                } else if (pct_workers >= 1) {
                                    spawn_delay = 15;
                                } else {
                                    spawn_delay = INFINITE;
                                }
                                b->figure_spawn_delay++;
                                if (b->figure_spawn_delay > spawn_delay) {
                                    b->figure_spawn_delay = 0;
                                    struct figure_t *f = figure_create(FIGURE_TAX_COLLECTOR, road.x, road.y, DIR_0_TOP);
                                    f->action_state = FIGURE_ACTION_TAX_COLLECTOR_CREATED;
                                    f->is_targetable = 1;
                                    f->terrain_usage = TERRAIN_USAGE_ROADS;
                                    f->building_id = b->id;
                                    b->figure_id = f->id;
                                }
                            }
                        }
                    } else if (b->type >= BUILDING_SMALL_TEMPLE_CERES && b->type <= BUILDING_LARGE_TEMPLE_VENUS) {
                        check_labor_problem(b);
                        if (!has_figure_of_types(b, FIGURE_PRIEST, 0)) {
                            struct map_point_t road;
                            if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                spawn_labor_seeker(b, road.x, road.y, 50);
                                int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                int spawn_delay;
                                if (building_properties[b->type].n_laborers <= 0) {
                                    spawn_delay = 7;
                                } else if (pct_workers >= 100) {
                                    spawn_delay = 3;
                                } else if (pct_workers >= 75) {
                                    spawn_delay = 7;
                                } else if (pct_workers >= 50) {
                                    spawn_delay = 10;
                                } else if (pct_workers >= 25) {
                                    spawn_delay = 15;
                                } else if (pct_workers >= 1) {
                                    spawn_delay = 20;
                                } else {
                                    spawn_delay = INFINITE;
                                }
                                b->figure_spawn_delay++;
                                if (b->figure_spawn_delay > spawn_delay) {
                                    b->figure_spawn_delay = 0;
                                    create_roaming_figure(b, road.x, road.y, FIGURE_PRIEST);
                                }
                            }
                        }
                    } else {
                        int x_out, y_out;
                        struct map_point_t road;
                        // single building type
                        switch (b->type) {
                            case BUILDING_WAREHOUSE:
                                check_labor_problem(b);
                                struct building_t *space = b;
                                for (int ii = 0; ii < 8; ii++) {
                                    space = &all_buildings[space->next_part_building_id];
                                    if (space->id) {
                                        space->show_on_problem_overlay = b->show_on_problem_overlay;
                                    }
                                }
                                if (map_has_road_access(b->x, b->y, b->size, &road) ||
                                    map_has_road_access(b->x, b->y, 3, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 100);
                                    if (!has_figure_of_types(b, FIGURE_WAREHOUSEMAN, 0)) {
                                        int resource;
                                        int task = WAREHOUSE_TASK_NONE;
                                        if (calc_percentage(b->num_workers, building_properties[b->type].n_laborers) < 50) {
                                            task = WAREHOUSE_TASK_NONE;
                                        } else {
                                            struct building_storage_t *s = &storages[b->storage_id].storage;
                                            // get resources
                                            for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                                if (s->resource_state[r] != BUILDING_STORAGE_STATE_GETTING || city_data.resource.stockpiled[r]) {
                                                    continue;
                                                }
                                                int loads_stored = 0;
                                                space = b;
                                                for (int ii = 0; ii < 8; ii++) {
                                                    space = &all_buildings[space->next_part_building_id];
                                                    if (space->id > 0 && space->loads_stored > 0) {
                                                        if (space->subtype.warehouse_resource_id == r) {
                                                            loads_stored += space->loads_stored;
                                                        }
                                                    }
                                                }
                                                int room = 0;
                                                space = b;
                                                for (int ii = 0; ii < 8; ii++) {
                                                    space = &all_buildings[space->next_part_building_id];
                                                    if (space->id > 0) {
                                                        if (space->loads_stored <= 0) {
                                                            room += 4;
                                                        }
                                                        if (space->subtype.warehouse_resource_id == r) {
                                                            room += 4 - space->loads_stored;
                                                        }
                                                    }
                                                }
                                                if (room >= 8 && loads_stored <= 4 && city_data.resource.stored_in_warehouses[r] - loads_stored > 4) {
                                                    resource = r;
                                                    task = WAREHOUSE_TASK_GETTING;
                                                }
                                            }
                                            if (task == WAREHOUSE_TASK_NONE) {
                                                // deliver weapons to barracks
                                                if (count_data.buildings[BUILDING_BARRACKS].active > 0 && city_data.military.legionary_legions && !city_data.resource.stockpiled[RESOURCE_WEAPONS]) {
                                                    struct building_t *barracks = &all_buildings[city_data.building.barracks_building_id];
                                                    if (barracks->loads_stored < 4) {
                                                        space = b;
                                                        for (int ii = 0; ii < 8; ii++) {
                                                            space = &all_buildings[space->next_part_building_id];
                                                            if (space->id > 0 && space->loads_stored > 0 && space->subtype.warehouse_resource_id == RESOURCE_WEAPONS) {
                                                                resource = RESOURCE_WEAPONS;
                                                                task = WAREHOUSE_TASK_DELIVERING;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            if (task == WAREHOUSE_TASK_NONE) {
                                                // deliver raw materials to workshops
                                                space = b;
                                                for (int ii = 0; ii < 8; ii++) {
                                                    space = &all_buildings[space->next_part_building_id];
                                                    if (space->id > 0 && space->loads_stored > 0) {
                                                        if (!city_data.resource.stockpiled[space->subtype.warehouse_resource_id]) {
                                                            int workshop_type = resource_to_workshop_type(space->subtype.warehouse_resource_id);
                                                            if (workshop_type != WORKSHOP_NONE && city_data.resource.space_in_workshops[workshop_type]) {
                                                                resource = space->subtype.warehouse_resource_id;
                                                                task = WAREHOUSE_TASK_DELIVERING;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            if (!scenario.rome_supplies_wheat && task == WAREHOUSE_TASK_NONE) {
                                                // deliver food to getting granary
                                                int granary_resources[FOOD_TYPES_MAX];
                                                int can_deliver_to_granary = 0;
                                                for (int ii = 0; ii < FOOD_TYPES_MAX; ii++) {
                                                    granary_resources[ii] = 0;
                                                }
                                                for (int ii = 1; ii < MAX_BUILDINGS; ii++) {
                                                    struct building_t *bb = &all_buildings[ii];
                                                    if (bb->state != BUILDING_STATE_IN_USE || bb->type != BUILDING_GRANARY || !bb->has_road_access) {
                                                        continue;
                                                    }
                                                    if (calc_percentage(bb->num_workers, building_properties[bb->type].n_laborers) >= 100 && bb->data.granary.resource_stored[RESOURCE_NONE] > 100) {
                                                        struct building_storage_t *st = &storages[b->storage_id].storage;
                                                        if (!st->empty_all) {
                                                            for (int r = 0; r < FOOD_TYPES_MAX; r++) {
                                                                if (st->resource_state[r] == BUILDING_STORAGE_STATE_GETTING) {
                                                                    granary_resources[r]++;
                                                                    can_deliver_to_granary = 1;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                if (can_deliver_to_granary) {
                                                    space = b;
                                                    for (int ii = 0; ii < 8; ii++) {
                                                        space = &all_buildings[space->next_part_building_id];
                                                        if (contains_non_stockpiled_food(space, granary_resources)) {
                                                            resource = space->subtype.warehouse_resource_id;
                                                            task = WAREHOUSE_TASK_DELIVERING;
                                                        }
                                                    }
                                                }
                                                // deliver food to accepting granary
                                                if (task == WAREHOUSE_TASK_NONE) {
                                                    int granary_can_accept = 0;
                                                    for (int ii = 0; ii < FOOD_TYPES_MAX; ii++) {
                                                        granary_resources[ii] = 0;
                                                    }
                                                    for (int ii = 1; ii < MAX_BUILDINGS; ii++) {
                                                        struct building_t *bb = &all_buildings[ii];
                                                        if (bb->state != BUILDING_STATE_IN_USE || bb->type != BUILDING_GRANARY || !bb->has_road_access) {
                                                            continue;
                                                        }
                                                        if (calc_percentage(bb->num_workers, building_properties[bb->type].n_laborers) >= 100 && bb->data.granary.resource_stored[RESOURCE_NONE] >= 1200) {
                                                            struct building_storage_t *st = &storages[bb->storage_id].storage;
                                                            if (!st->empty_all) {
                                                                for (int r = 0; r < FOOD_TYPES_MAX; r++) {
                                                                    if (st->resource_state[r] != BUILDING_STORAGE_STATE_NOT_ACCEPTING) {
                                                                        granary_resources[r]++;
                                                                        granary_can_accept = 1;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    if (granary_can_accept) {
                                                        space = b;
                                                        for (int ii = 0; ii < 8; ii++) {
                                                            space = &all_buildings[space->next_part_building_id];
                                                            if (contains_non_stockpiled_food(space, granary_resources)) {
                                                                resource = space->subtype.warehouse_resource_id;
                                                                task = WAREHOUSE_TASK_DELIVERING;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            // move goods to other warehouses
                                            if (s->empty_all) {
                                                space = b;
                                                for (int ii = 0; ii < 8; ii++) {
                                                    space = &all_buildings[space->next_part_building_id];
                                                    if (space->id > 0 && space->loads_stored > 0) {
                                                        resource = space->subtype.warehouse_resource_id;
                                                        task = WAREHOUSE_TASK_DELIVERING;
                                                    }
                                                }
                                            }
                                        }
                                        if (task != WAREHOUSE_TASK_NONE) {
                                            struct figure_t *f = figure_create(FIGURE_WAREHOUSEMAN, road.x, road.y, DIR_4_BOTTOM);
                                            f->is_targetable = 1;
                                            f->action_state = FIGURE_ACTION_WAREHOUSEMAN_CREATED;
                                            if (task == WAREHOUSE_TASK_GETTING) {
                                                f->resource_id = RESOURCE_NONE;
                                                f->collecting_item_id = resource;
                                            } else {
                                                f->resource_id = resource;
                                            }
                                            b->figure_id = f->id;
                                            f->building_id = b->id;
                                        }
                                    }
                                }
                                break;
                            case BUILDING_GRANARY:
                                check_labor_problem(b);
                                if (map_has_road_access_granary(b->x, b->y, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 100);
                                    if (!has_figure_of_types(b, FIGURE_WAREHOUSEMAN, 0)) {
                                        struct building_storage_t *s = &storages[b->storage_id].storage;
                                        int task = GRANARY_TASK_NONE;
                                        if (calc_percentage(b->num_workers, building_properties[b->type].n_laborers) < 50
                                        || b->data.granary.resource_stored[RESOURCE_NONE] <= 0) { // granary full, nothing to get
                                            task = GRANARY_TASK_NONE;
                                        } else if (s->empty_all) {
                                            // bring food to another granary
                                            for (int ii = RESOURCE_WHEAT; ii < FOOD_TYPES_MAX; ii++) {
                                                if (b->data.granary.resource_stored[k]) {
                                                    task = GRANARY_TASK_GETTING;
                                                    break;
                                                }
                                            }
                                        } else if ((s->resource_state[RESOURCE_WHEAT] == BUILDING_STORAGE_STATE_GETTING && non_getting_granaries.total_storage_wheat > ONE_LOAD)
                                        || (s->resource_state[RESOURCE_VEGETABLES] == BUILDING_STORAGE_STATE_GETTING && non_getting_granaries.total_storage_vegetables > ONE_LOAD)
                                        || (s->resource_state[RESOURCE_FRUIT] == BUILDING_STORAGE_STATE_GETTING && non_getting_granaries.total_storage_fruit > ONE_LOAD)
                                        || (s->resource_state[RESOURCE_MEAT] == BUILDING_STORAGE_STATE_GETTING && non_getting_granaries.total_storage_meat > ONE_LOAD)) {
                                            task = GRANARY_TASK_GETTING;
                                        }
                                        if (task != GRANARY_TASK_NONE) {
                                            struct figure_t *f = figure_create(FIGURE_WAREHOUSEMAN, road.x, road.y, DIR_4_BOTTOM);
                                            f->is_targetable = 1;
                                            f->action_state = FIGURE_ACTION_WAREHOUSEMAN_CREATED;
                                            f->resource_id = task;
                                            b->figure_id = f->id;
                                            f->building_id = b->id;
                                        }
                                    }
                                }
                                break;
                            case BUILDING_TOWER:
                                check_labor_problem(b);
                                if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 50);
                                    if (b->num_workers) {
                                        if (!b->figure_id4 && b->figure_id) { // has sentry but no ballista -> create
                                            struct figure_t *f = figure_create(FIGURE_BALLISTA, b->x, b->y, DIR_0_TOP);
                                            b->figure_id4 = f->id;
                                            f->building_id = b->id;
                                            f->action_state = FIGURE_ACTION_BALLISTA_READY;
                                            f->terrain_usage = TERRAIN_USAGE_WALLS;
                                        }
                                        has_figure_of_types(b, FIGURE_TOWER_SENTRY, 0);
                                        if (b->figure_id <= 0) {
                                            tower_sentry_request = 2;
                                        }
                                    }
                                }
                                break;
                            case BUILDING_ENGINEERS_POST:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_ENGINEER, 0)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        spawn_labor_seeker(b, road.x, road.y, 100);
                                        int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                        int spawn_delay;
                                        if (pct_workers >= 100) {
                                            spawn_delay = 0;
                                        } else if (pct_workers >= 75) {
                                            spawn_delay = 1;
                                        } else if (pct_workers >= 50) {
                                            spawn_delay = 3;
                                        } else if (pct_workers >= 25) {
                                            spawn_delay = 7;
                                        } else if (pct_workers >= 1) {
                                            spawn_delay = 15;
                                        } else {
                                            spawn_delay = INFINITE;
                                        }
                                        b->figure_spawn_delay++;
                                        if (b->figure_spawn_delay > spawn_delay) {
                                            b->figure_spawn_delay = 0;
                                            struct figure_t *f = figure_create(FIGURE_ENGINEER, road.x, road.y, DIR_0_TOP);
                                            f->action_state = FIGURE_ACTION_ENGINEER_CREATED;
                                            f->is_targetable = 1;
                                            f->terrain_usage = TERRAIN_USAGE_ROADS;
                                            f->building_id = b->id;
                                            b->figure_id = f->id;
                                        }
                                    }
                                }
                                break;
                            case BUILDING_PREFECTURE:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_PREFECT, 0)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        spawn_labor_seeker(b, road.x, road.y, 100);
                                        int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                        int spawn_delay;
                                        if (pct_workers >= 100) {
                                            spawn_delay = 0;
                                        } else if (pct_workers >= 75) {
                                            spawn_delay = 1;
                                        } else if (pct_workers >= 50) {
                                            spawn_delay = 3;
                                        } else if (pct_workers >= 25) {
                                            spawn_delay = 7;
                                        } else if (pct_workers >= 1) {
                                            spawn_delay = 15;
                                        } else {
                                            spawn_delay = INFINITE;;
                                        }
                                        b->figure_spawn_delay++;
                                        if (b->figure_spawn_delay > spawn_delay) {
                                            b->figure_spawn_delay = 0;
                                            struct figure_t *f = figure_create(FIGURE_PREFECT, road.x, road.y, DIR_0_TOP);
                                            f->action_state = FIGURE_ACTION_PREFECT_CREATED;
                                            f->is_targetable = 1;
                                            f->building_id = b->id;
                                            b->figure_id = f->id;
                                        }
                                    }
                                }
                                break;
                            case BUILDING_ACTOR_COLONY:
                                check_labor_problem(b);
                                if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 50);
                                    int spawn_delay = default_spawn_delay(b);
                                    if (spawn_delay) {
                                        b->figure_spawn_delay++;
                                        if (b->figure_spawn_delay > spawn_delay) {
                                            b->figure_spawn_delay = 0;
                                            struct figure_t *f = figure_create(FIGURE_ACTOR, road.x, road.y, DIR_0_TOP);
                                            f->action_state = FIGURE_ACTION_ENTERTAINER_AT_SCHOOL_CREATED;
                                            f->is_targetable = 1;
                                            f->terrain_usage = TERRAIN_USAGE_ROADS;
                                            f->building_id = b->id;
                                            b->figure_id = f->id;
                                        }
                                    }
                                }
                                break;
                            case BUILDING_GLADIATOR_SCHOOL:
                                check_labor_problem(b);
                                if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 50);
                                    int spawn_delay = default_spawn_delay(b);
                                    if (spawn_delay) {
                                        b->figure_spawn_delay++;
                                        if (b->figure_spawn_delay > spawn_delay) {
                                            b->figure_spawn_delay = 0;
                                            if (scenario.gladiator_revolt.state != EVENT_IN_PROGRESS) {
                                                struct figure_t *f = figure_create(FIGURE_GLADIATOR, road.x, road.y, DIR_0_TOP);
                                                f->action_state = FIGURE_ACTION_ENTERTAINER_AT_SCHOOL_CREATED;
                                                f->is_targetable = 1;
                                                f->terrain_usage = TERRAIN_USAGE_ROADS;
                                                f->building_id = b->id;
                                                b->figure_id = f->id;
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_LION_HOUSE:
                                check_labor_problem(b);
                                if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 50);
                                    int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                    int spawn_delay;
                                    if (pct_workers >= 100) {
                                        spawn_delay = 5;
                                    } else if (pct_workers >= 75) {
                                        spawn_delay = 10;
                                    } else if (pct_workers >= 50) {
                                        spawn_delay = 20;
                                    } else if (pct_workers >= 25) {
                                        spawn_delay = 35;
                                    } else if (pct_workers >= 1) {
                                        spawn_delay = 60;
                                    } else {
                                        spawn_delay = INFINITE;;
                                    }
                                    b->figure_spawn_delay++;
                                    if (b->figure_spawn_delay > spawn_delay) {
                                        b->figure_spawn_delay = 0;
                                        struct figure_t *f = figure_create(FIGURE_LION_TAMER, road.x, road.y, DIR_0_TOP);
                                        f->action_state = FIGURE_ACTION_ENTERTAINER_AT_SCHOOL_CREATED;
                                        f->is_targetable = 1;
                                        f->terrain_usage = TERRAIN_USAGE_ROADS;
                                        f->building_id = b->id;
                                        b->figure_id = f->id;
                                    }
                                }
                                break;
                            case BUILDING_CHARIOT_MAKER:
                                check_labor_problem(b);
                                if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 50);
                                    int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                    int spawn_delay;
                                    if (pct_workers >= 100) {
                                        spawn_delay = 7;
                                    } else if (pct_workers >= 75) {
                                        spawn_delay = 15;
                                    } else if (pct_workers >= 50) {
                                        spawn_delay = 30;
                                    } else if (pct_workers >= 25) {
                                        spawn_delay = 60;
                                    } else if (pct_workers >= 1) {
                                        spawn_delay = 90;
                                    } else {
                                        spawn_delay = INFINITE;;
                                    }
                                    b->figure_spawn_delay++;
                                    if (b->figure_spawn_delay > spawn_delay) {
                                        b->figure_spawn_delay = 0;
                                        struct figure_t *f = figure_create(FIGURE_CHARIOTEER, road.x, road.y, DIR_0_TOP);
                                        f->action_state = FIGURE_ACTION_ENTERTAINER_AT_SCHOOL_CREATED;
                                        f->is_targetable = 1;
                                        f->terrain_usage = TERRAIN_USAGE_ROADS;
                                        f->building_id = b->id;
                                        b->figure_id = f->id;
                                    }
                                }
                                break;
                            case BUILDING_AMPHITHEATER:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_ACTOR, FIGURE_GLADIATOR)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        if (b->houses_covered <= 50 ||
                                            (b->data.entertainment.days1 <= 0 && b->data.entertainment.days2 <= 0)) {
                                            generate_labor_seeker(b, road.x, road.y);
                                        }
                                        int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                        int spawn_delay;
                                        if (pct_workers >= 100) {
                                            spawn_delay = 3;
                                        } else if (pct_workers >= 75) {
                                            spawn_delay = 7;
                                        } else if (pct_workers >= 50) {
                                            spawn_delay = 15;
                                        } else if (pct_workers >= 25) {
                                            spawn_delay = 29;
                                        } else if (pct_workers >= 1) {
                                            spawn_delay = 44;
                                        } else {
                                            spawn_delay = INFINITE;;
                                        }
                                        b->figure_spawn_delay++;
                                        if (b->figure_spawn_delay > spawn_delay) {
                                            b->figure_spawn_delay = 0;
                                            if (b->data.entertainment.days1 > 0) {
                                                if (scenario.gladiator_revolt.state != EVENT_IN_PROGRESS) {
                                                    struct figure_t *f = figure_create(FIGURE_GLADIATOR, road.x, road.y, DIR_0_TOP);
                                                    f->action_state = FIGURE_ACTION_ENTERTAINER_ROAMING;
                                                    f->is_targetable = 1;
                                                    f->terrain_usage = TERRAIN_USAGE_ROADS;
                                                    f->building_id = b->id;
                                                    b->figure_id = f->id;
                                                    figure_movement_init_roaming(f);
                                                }
                                            } else {
                                                struct figure_t *f = figure_create(FIGURE_ACTOR, road.x, road.y, DIR_0_TOP);
                                                f->action_state = FIGURE_ACTION_ENTERTAINER_ROAMING;
                                                f->is_targetable = 1;
                                                f->terrain_usage = TERRAIN_USAGE_ROADS;
                                                f->building_id = b->id;
                                                b->figure_id = f->id;
                                                figure_movement_init_roaming(f);
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_THEATER:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_ACTOR, 0)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        if (b->houses_covered <= 50 || b->data.entertainment.days1 <= 0) {
                                            generate_labor_seeker(b, road.x, road.y);
                                        }
                                        int spawn_delay = default_spawn_delay(b);
                                        if (spawn_delay) {
                                            b->figure_spawn_delay++;
                                            if (b->figure_spawn_delay > spawn_delay) {
                                                b->figure_spawn_delay = 0;
                                                struct figure_t *f = figure_create(FIGURE_ACTOR, road.x, road.y, DIR_0_TOP);
                                                f->action_state = FIGURE_ACTION_ENTERTAINER_ROAMING;
                                                f->is_targetable = 1;
                                                f->terrain_usage = TERRAIN_USAGE_ROADS;
                                                f->building_id = b->id;
                                                b->figure_id = f->id;
                                                figure_movement_init_roaming(f);
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_HIPPODROME:
                                check_labor_problem(b);
                                if (!b->prev_part_building_id) {
                                    struct building_t *part = b;
                                    for (int ii = 0; ii < 2; ii++) {
                                        part = &all_buildings[part->next_part_building_id];
                                        if (part->id) {
                                            part->show_on_problem_overlay = b->show_on_problem_overlay;
                                        }
                                    }
                                    if (!has_figure_of_types(b, FIGURE_CHARIOTEER, 0)) {
                                        if (map_has_road_access_hippodrome(b->x, b->y, &road)) {
                                            if (b->houses_covered <= 50 || b->data.entertainment.days1 <= 0) {
                                                generate_labor_seeker(b, road.x, road.y);
                                            }
                                            int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                            int spawn_delay;
                                            if (pct_workers >= 100) {
                                                spawn_delay = 7;
                                            } else if (pct_workers >= 75) {
                                                spawn_delay = 15;
                                            } else if (pct_workers >= 50) {
                                                spawn_delay = 30;
                                            } else if (pct_workers >= 25) {
                                                spawn_delay = 50;
                                            } else if (pct_workers >= 1) {
                                                spawn_delay = 80;
                                            } else {
                                                spawn_delay = INFINITE;;
                                            }
                                            b->figure_spawn_delay++;
                                            if (b->figure_spawn_delay > spawn_delay) {
                                                b->figure_spawn_delay = 0;
                                                struct figure_t *f = figure_create(FIGURE_CHARIOTEER, road.x, road.y, DIR_0_TOP);
                                                f->action_state = FIGURE_ACTION_ENTERTAINER_ROAMING;
                                                f->is_targetable = 1;
                                                f->terrain_usage = TERRAIN_USAGE_ROADS;
                                                f->building_id = b->id;
                                                b->figure_id = f->id;
                                                figure_movement_init_roaming(f);

                                                if (!city_data.entertainment.hippodrome_has_race) {
                                                    // create mini-horses
                                                    struct figure_t *horse1 = figure_create(FIGURE_HIPPODROME_HORSES, b->x + 2, b->y + 1, DIR_2_RIGHT);
                                                    horse1->action_state = FIGURE_ACTION_HIPPODROME_HORSE_CREATED;
                                                    horse1->use_cross_country = 1;
                                                    horse1->building_id = b->id;
                                                    horse1->resource_id = 0;
                                                    horse1->speed_multiplier = 3;

                                                    struct figure_t *horse2 = figure_create(FIGURE_HIPPODROME_HORSES, b->x + 2, b->y + 2, DIR_2_RIGHT);
                                                    horse2->action_state = FIGURE_ACTION_HIPPODROME_HORSE_CREATED;
                                                    horse2->use_cross_country = 1;
                                                    horse2->building_id = b->id;
                                                    horse2->resource_id = 1;
                                                    horse2->speed_multiplier = 2;

                                                    if (b->data.entertainment.days1 > 0) {
                                                        if (!city_data.entertainment.hippodrome_message_shown) {
                                                            city_data.entertainment.hippodrome_message_shown = 1;
                                                            city_message_post(1, MESSAGE_WORKING_HIPPODROME, 0, 0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_COLOSSEUM:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_GLADIATOR, FIGURE_LION_TAMER)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        if (b->houses_covered <= 50 ||
                                            (b->data.entertainment.days1 <= 0 && b->data.entertainment.days2 <= 0)) {
                                            generate_labor_seeker(b, road.x, road.y);
                                        }
                                        int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                        int spawn_delay;
                                        if (pct_workers >= 100) {
                                            spawn_delay = 6;
                                        } else if (pct_workers >= 75) {
                                            spawn_delay = 12;
                                        } else if (pct_workers >= 50) {
                                            spawn_delay = 20;
                                        } else if (pct_workers >= 25) {
                                            spawn_delay = 40;
                                        } else if (pct_workers >= 1) {
                                            spawn_delay = 70;
                                        } else {
                                            spawn_delay = INFINITE;;
                                        }
                                        b->figure_spawn_delay++;
                                        if (b->figure_spawn_delay > spawn_delay) {
                                            b->figure_spawn_delay = 0;
                                            if (b->data.entertainment.days1 > 0) {
                                                if (scenario.gladiator_revolt.state != EVENT_IN_PROGRESS) {
                                                    struct figure_t *f = figure_create(FIGURE_LION_TAMER, road.x, road.y, DIR_0_TOP);
                                                    f->action_state = FIGURE_ACTION_ENTERTAINER_ROAMING;
                                                    f->is_targetable = 1;
                                                    f->terrain_usage = TERRAIN_USAGE_ROADS;
                                                    f->building_id = b->id;
                                                    b->figure_id = f->id;
                                                    figure_movement_init_roaming(f);
                                                }
                                            } else {
                                                struct figure_t *f = figure_create(FIGURE_GLADIATOR, road.x, road.y, DIR_0_TOP);
                                                f->action_state = FIGURE_ACTION_ENTERTAINER_ROAMING;
                                                f->is_targetable = 1;
                                                f->terrain_usage = TERRAIN_USAGE_ROADS;
                                                f->building_id = b->id;
                                                b->figure_id = f->id;
                                                figure_movement_init_roaming(f);
                                            }

                                            if (b->data.entertainment.days1 > 0 || b->data.entertainment.days2 > 0) {
                                                if (!city_data.entertainment.colosseum_message_shown) {
                                                    city_data.entertainment.colosseum_message_shown = 1;
                                                    city_message_post(1, MESSAGE_WORKING_COLOSSEUM, 0, 0);
                                                }
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_MARKET:
                                if (b->state == BUILDING_STATE_IN_USE) {
                                    if (desirability_grid.items[b->grid_offset] <= 30) {
                                        map_building_tiles_add(b->id, b->x, b->y, b->size, 2872, TERRAIN_BUILDING);
                                    } else {
                                        map_building_tiles_add(b->id, b->x, b->y, b->size, 3029, TERRAIN_BUILDING);
                                    }
                                    check_labor_problem(b);
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        spawn_labor_seeker(b, road.x, road.y, 50);
                                        int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                        int spawn_delay;
                                        if (pct_workers >= 100) {
                                            spawn_delay = 2;
                                        } else if (pct_workers >= 75) {
                                            spawn_delay = 5;
                                        } else if (pct_workers >= 50) {
                                            spawn_delay = 10;
                                        } else if (pct_workers >= 25) {
                                            spawn_delay = 20;
                                        } else if (pct_workers >= 1) {
                                            spawn_delay = 30;
                                        } else {
                                            spawn_delay = INFINITE;;
                                        }
                                        // market trader
                                        if (!has_figure_of_types(b, FIGURE_MARKET_TRADER, 0)) {
                                            b->figure_spawn_delay++;
                                            if (b->figure_spawn_delay > spawn_delay) {
                                                b->figure_spawn_delay = 0;
                                                create_roaming_figure(b, road.x, road.y, FIGURE_MARKET_TRADER);
                                            }
                                        }
                                        // market buyer or labor seeker
                                        if (b->figure_id2) {
                                            struct figure_t *f = &figures[b->figure_id2];
                                            if (!figure_is_alive(f) || (f->type != FIGURE_MARKET_BUYER && f->type != FIGURE_LABOR_SEEKER)) {
                                                b->figure_id2 = 0;
                                            }
                                        } else {
                                            map_has_road_access(b->x, b->y, b->size, &road);
                                            struct resource_data resources[INVENTORY_MAX];
                                            for (int ii = 0; ii < INVENTORY_MAX; ii++) {
                                                resources[ii].building_id = 0;
                                                resources[ii].num_buildings = 0;
                                                resources[ii].distance = 40;
                                            }
                                            for (int ii = 1; ii < MAX_BUILDINGS; ii++) {
                                                struct building_t *bb = &all_buildings[ii];
                                                if (bb->state != BUILDING_STATE_IN_USE) {
                                                    continue;
                                                }
                                                if (bb->type != BUILDING_GRANARY && bb->type != BUILDING_WAREHOUSE) {
                                                    continue;
                                                }
                                                if (!bb->has_road_access) {
                                                    continue;
                                                }
                                                int distance = calc_maximum_distance(b->x, b->y, bb->x, bb->y);
                                                if (distance >= 40) {
                                                    continue;
                                                }
                                                if (bb->type == BUILDING_GRANARY) {
                                                    if (scenario.rome_supplies_wheat) {
                                                        continue;
                                                    }
                                                    update_food_resource(&resources[INVENTORY_WHEAT], RESOURCE_WHEAT, bb, distance);
                                                    update_food_resource(&resources[INVENTORY_VEGETABLES], RESOURCE_VEGETABLES, bb, distance);
                                                    update_food_resource(&resources[INVENTORY_FRUIT], RESOURCE_FRUIT, bb, distance);
                                                    update_food_resource(&resources[INVENTORY_MEAT], RESOURCE_MEAT, bb, distance);
                                                } else if (bb->type == BUILDING_WAREHOUSE) {
                                                    // goods
                                                    update_good_resource(&resources[INVENTORY_WINE], RESOURCE_WINE, bb, distance);
                                                    update_good_resource(&resources[INVENTORY_OIL], RESOURCE_OIL, bb, distance);
                                                    update_good_resource(&resources[INVENTORY_POTTERY], RESOURCE_POTTERY, bb, distance);
                                                    update_good_resource(&resources[INVENTORY_FURNITURE], RESOURCE_FURNITURE, bb, distance);
                                                }
                                            }
                                            // update demands
                                            if (b->data.market.pottery_demand) {
                                                b->data.market.pottery_demand--;
                                            } else {
                                                resources[INVENTORY_POTTERY].num_buildings = 0;
                                            }
                                            if (b->data.market.furniture_demand) {
                                                b->data.market.furniture_demand--;
                                            } else {
                                                resources[INVENTORY_FURNITURE].num_buildings = 0;
                                            }
                                            if (b->data.market.oil_demand) {
                                                b->data.market.oil_demand--;
                                            } else {
                                                resources[INVENTORY_OIL].num_buildings = 0;
                                            }
                                            if (b->data.market.wine_demand) {
                                                b->data.market.wine_demand--;
                                            } else {
                                                resources[INVENTORY_WINE].num_buildings = 0;
                                            }
                                            int can_go = 0;
                                            for (int ii = 0; ii < INVENTORY_MAX; ii++) {
                                                if (resources[ii].num_buildings) {
                                                    can_go = 1;
                                                    break;
                                                }
                                            }
                                            if (can_go) {
                                                int dst_building_id = 0;
                                                int min_stock = 50;
                                                int fetch_inventory = -1;
                                                if (!b->data.market.inventory[INVENTORY_WHEAT] && resources[INVENTORY_WHEAT].num_buildings) { // prefer food if we don't have it
                                                    b->data.market.fetch_inventory_id = INVENTORY_WHEAT;
                                                    dst_building_id = resources[INVENTORY_WHEAT].building_id;
                                                } else if (!b->data.market.inventory[INVENTORY_VEGETABLES] && resources[INVENTORY_VEGETABLES].num_buildings) {
                                                    b->data.market.fetch_inventory_id = INVENTORY_VEGETABLES;
                                                    dst_building_id = resources[INVENTORY_VEGETABLES].building_id;
                                                } else if (!b->data.market.inventory[INVENTORY_FRUIT] && resources[INVENTORY_FRUIT].num_buildings) {
                                                    b->data.market.fetch_inventory_id = INVENTORY_FRUIT;
                                                    dst_building_id = resources[INVENTORY_FRUIT].building_id;
                                                } else if (!b->data.market.inventory[INVENTORY_MEAT] && resources[INVENTORY_MEAT].num_buildings) {
                                                    b->data.market.fetch_inventory_id = INVENTORY_MEAT;
                                                    dst_building_id = resources[INVENTORY_MEAT].building_id;
                                                } else if (!b->data.market.inventory[INVENTORY_POTTERY] && resources[INVENTORY_POTTERY].num_buildings) { // then prefer resource if we don't have it
                                                    b->data.market.fetch_inventory_id = INVENTORY_POTTERY;
                                                    dst_building_id = resources[INVENTORY_POTTERY].building_id;
                                                } else if (!b->data.market.inventory[INVENTORY_FURNITURE] && resources[INVENTORY_FURNITURE].num_buildings) {
                                                    b->data.market.fetch_inventory_id = INVENTORY_FURNITURE;
                                                    dst_building_id = resources[INVENTORY_FURNITURE].building_id;
                                                } else if (!b->data.market.inventory[INVENTORY_OIL] && resources[INVENTORY_OIL].num_buildings) {
                                                    b->data.market.fetch_inventory_id = INVENTORY_OIL;
                                                    dst_building_id = resources[INVENTORY_OIL].building_id;
                                                } else if (!b->data.market.inventory[INVENTORY_WINE] && resources[INVENTORY_WINE].num_buildings) {
                                                    b->data.market.fetch_inventory_id = INVENTORY_WINE;
                                                    dst_building_id = resources[INVENTORY_WINE].building_id;
                                                } else { // then prefer smallest stock below 50
                                                    if (resources[INVENTORY_WHEAT].num_buildings && b->data.market.inventory[INVENTORY_WHEAT] < min_stock) {
                                                        min_stock = b->data.market.inventory[INVENTORY_WHEAT];
                                                        fetch_inventory = INVENTORY_WHEAT;
                                                    }
                                                    if (resources[INVENTORY_VEGETABLES].num_buildings && b->data.market.inventory[INVENTORY_VEGETABLES] < min_stock) {
                                                        min_stock = b->data.market.inventory[INVENTORY_VEGETABLES];
                                                        fetch_inventory = INVENTORY_VEGETABLES;
                                                    }
                                                    if (resources[INVENTORY_FRUIT].num_buildings && b->data.market.inventory[INVENTORY_FRUIT] < min_stock) {
                                                        min_stock = b->data.market.inventory[INVENTORY_FRUIT];
                                                        fetch_inventory = INVENTORY_FRUIT;
                                                    }
                                                    if (resources[INVENTORY_MEAT].num_buildings && b->data.market.inventory[INVENTORY_MEAT] < min_stock) {
                                                        min_stock = b->data.market.inventory[INVENTORY_MEAT];
                                                        fetch_inventory = INVENTORY_MEAT;
                                                    }
                                                    if (resources[INVENTORY_POTTERY].num_buildings && b->data.market.inventory[INVENTORY_POTTERY] < min_stock) {
                                                        min_stock = b->data.market.inventory[INVENTORY_POTTERY];
                                                        fetch_inventory = INVENTORY_POTTERY;
                                                    }
                                                    if (resources[INVENTORY_FURNITURE].num_buildings && b->data.market.inventory[INVENTORY_FURNITURE] < min_stock) {
                                                        min_stock = b->data.market.inventory[INVENTORY_FURNITURE];
                                                        fetch_inventory = INVENTORY_FURNITURE;
                                                    }
                                                    if (resources[INVENTORY_OIL].num_buildings && b->data.market.inventory[INVENTORY_OIL] < min_stock) {
                                                        min_stock = b->data.market.inventory[INVENTORY_OIL];
                                                        fetch_inventory = INVENTORY_OIL;
                                                    }
                                                    if (resources[INVENTORY_WINE].num_buildings && b->data.market.inventory[INVENTORY_WINE] < min_stock) {
                                                        fetch_inventory = INVENTORY_WINE;
                                                    }
                                                    if (fetch_inventory == -1) { // all items well stocked: pick food below threshold
                                                        if (resources[INVENTORY_WHEAT].num_buildings && b->data.market.inventory[INVENTORY_WHEAT] < 600) {
                                                            fetch_inventory = INVENTORY_WHEAT;
                                                        }
                                                        if (resources[INVENTORY_VEGETABLES].num_buildings && b->data.market.inventory[INVENTORY_VEGETABLES] < 400) {
                                                            fetch_inventory = INVENTORY_VEGETABLES;
                                                        }
                                                        if (resources[INVENTORY_FRUIT].num_buildings && b->data.market.inventory[INVENTORY_FRUIT] < 400) {
                                                            fetch_inventory = INVENTORY_FRUIT;
                                                        }
                                                        if (resources[INVENTORY_MEAT].num_buildings && b->data.market.inventory[INVENTORY_MEAT] < 400) {
                                                            fetch_inventory = INVENTORY_MEAT;
                                                        }
                                                    }
                                                    if (fetch_inventory > 0) {
                                                        b->data.market.fetch_inventory_id = fetch_inventory;
                                                        dst_building_id = resources[fetch_inventory].building_id;
                                                    }
                                                }
                                                if (dst_building_id > 0) {
                                                    struct figure_t *f = figure_create(FIGURE_MARKET_BUYER, road.x, road.y, DIR_0_TOP);
                                                    f->action_state = FIGURE_ACTION_MARKET_BUYER_GOING_TO_STORAGE;
                                                    f->is_targetable = 1;
                                                    f->terrain_usage = TERRAIN_USAGE_ROADS;
                                                    f->building_id = b->id;
                                                    b->figure_id2 = f->id;
                                                    f->destination_building_id = dst_building_id;
                                                    f->collecting_item_id = b->data.market.fetch_inventory_id;
                                                    struct building_t *b_dst = &all_buildings[dst_building_id];
                                                    if (map_has_road_access(b_dst->x, b_dst->y, b_dst->size, &road) ||
                                                        map_has_road_access(b_dst->x, b_dst->y, 3, &road)) {
                                                        f->destination_x = road.x;
                                                        f->destination_y = road.y;
                                                    } else {
                                                        f->action_state = FIGURE_ACTION_MARKET_BUYER_RETURNING;
                                                        f->destination_x = f->x;
                                                        f->destination_y = f->y;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_BATHHOUSE:
                                if (b->state == BUILDING_STATE_IN_USE) {
                                    if (map_terrain_exists_tile_in_area_with_type(b->x, b->y, b->size, TERRAIN_RESERVOIR_RANGE)) {
                                        b->has_water_access = 1;
                                    } else {
                                        b->has_water_access = 0;
                                    }
                                    if (b->has_water_access && b->num_workers) {
                                        if (desirability_grid.items[b->grid_offset] <= 30) {
                                            map_building_tiles_add(b->id, b->x, b->y, b->size, 3185, TERRAIN_BUILDING);
                                        } else {
                                            map_building_tiles_add(b->id, b->x, b->y, b->size, 3197, TERRAIN_BUILDING);
                                        }
                                    } else {
                                        if (desirability_grid.items[b->grid_offset] <= 30) {
                                            map_building_tiles_add(b->id, b->x, b->y, b->size, 3196, TERRAIN_BUILDING);
                                        } else {
                                            map_building_tiles_add(b->id, b->x, b->y, b->size, 3207, TERRAIN_BUILDING);
                                        }
                                    }
                                    check_labor_problem(b);
                                    if (!b->has_water_access) {
                                        b->show_on_problem_overlay = 2;
                                    }
                                    if (!has_figure_of_types(b, FIGURE_BATHHOUSE_WORKER, 0)) {
                                        if (map_has_road_access(b->x, b->y, b->size, &road) && b->has_water_access) {
                                            spawn_labor_seeker(b, road.x, road.y, 50);
                                            int spawn_delay = default_spawn_delay(b);
                                            if (spawn_delay) {
                                                b->figure_spawn_delay++;
                                                if (b->figure_spawn_delay > spawn_delay) {
                                                    b->figure_spawn_delay = 0;
                                                    create_roaming_figure(b, road.x, road.y, FIGURE_BATHHOUSE_WORKER);
                                                }
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_SCHOOL:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_SCHOOL_CHILD, 0)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        spawn_labor_seeker(b, road.x, road.y, 50);
                                        int spawn_delay = default_spawn_delay(b);
                                        if (spawn_delay) {
                                            b->figure_spawn_delay++;
                                            if (b->figure_spawn_delay > spawn_delay) {
                                                b->figure_spawn_delay = 0;
                                                struct figure_t *child1 = figure_create(FIGURE_SCHOOL_CHILD, road.x, road.y, DIR_0_TOP);
                                                child1->action_state = FIGURE_ACTION_ROAMING;
                                                child1->is_targetable = 1;
                                                child1->terrain_usage = TERRAIN_USAGE_ROADS;
                                                child1->building_id = b->id;
                                                b->figure_id = child1->id;
                                                figure_movement_init_roaming(child1);
                                                struct figure_t *child2 = figure_create(FIGURE_SCHOOL_CHILD, road.x, road.y, DIR_0_TOP);
                                                child2->action_state = FIGURE_ACTION_ROAMING;
                                                child2->is_targetable = 1;
                                                child2->terrain_usage = TERRAIN_USAGE_ROADS;
                                                child2->building_id = b->id;
                                                figure_movement_init_roaming(child2);
                                                struct figure_t *child3 = figure_create(FIGURE_SCHOOL_CHILD, road.x, road.y, DIR_0_TOP);
                                                child3->action_state = FIGURE_ACTION_ROAMING;
                                                child3->is_targetable = 1;
                                                child3->terrain_usage = TERRAIN_USAGE_ROADS;
                                                child3->building_id = b->id;
                                                figure_movement_init_roaming(child3);
                                                struct figure_t *child4 = figure_create(FIGURE_SCHOOL_CHILD, road.x, road.y, DIR_0_TOP);
                                                child4->action_state = FIGURE_ACTION_ROAMING;
                                                child4->is_targetable = 1;
                                                child4->terrain_usage = TERRAIN_USAGE_ROADS;
                                                child4->building_id = b->id;
                                                figure_movement_init_roaming(child4);
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_LIBRARY:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_LIBRARIAN, 0)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        spawn_labor_seeker(b, road.x, road.y, 50);
                                        int spawn_delay = default_spawn_delay(b);
                                        if (spawn_delay) {
                                            b->figure_spawn_delay++;
                                            if (b->figure_spawn_delay > spawn_delay) {
                                                b->figure_spawn_delay = 0;
                                                create_roaming_figure(b, road.x, road.y, FIGURE_LIBRARIAN);
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_ACADEMY:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_TEACHER, 0)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        spawn_labor_seeker(b, road.x, road.y, 50);
                                        int spawn_delay = default_spawn_delay(b);
                                        if (spawn_delay) {
                                            b->figure_spawn_delay++;
                                            if (b->figure_spawn_delay > spawn_delay) {
                                                b->figure_spawn_delay = 0;
                                                create_roaming_figure(b, road.x, road.y, FIGURE_TEACHER);
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_BARBER:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_BARBER, 0)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        spawn_labor_seeker(b, road.x, road.y, 50);
                                        int spawn_delay = default_spawn_delay(b);
                                        if (spawn_delay) {
                                            b->figure_spawn_delay++;
                                            if (b->figure_spawn_delay > spawn_delay) {
                                                b->figure_spawn_delay = 0;
                                                create_roaming_figure(b, road.x, road.y, FIGURE_BARBER);
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_DOCTOR:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_DOCTOR, 0)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        spawn_labor_seeker(b, road.x, road.y, 50);
                                        int spawn_delay = default_spawn_delay(b);
                                        if (spawn_delay) {
                                            b->figure_spawn_delay++;
                                            if (b->figure_spawn_delay > spawn_delay) {
                                                b->figure_spawn_delay = 0;
                                                create_roaming_figure(b, road.x, road.y, FIGURE_DOCTOR);
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_HOSPITAL:
                                check_labor_problem(b);
                                if (!has_figure_of_types(b, FIGURE_SURGEON, 0)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        spawn_labor_seeker(b, road.x, road.y, 50);
                                        int spawn_delay = default_spawn_delay(b);
                                        if (spawn_delay) {
                                            b->figure_spawn_delay++;
                                            if (b->figure_spawn_delay > spawn_delay) {
                                                b->figure_spawn_delay = 0;
                                                create_roaming_figure(b, road.x, road.y, FIGURE_SURGEON);
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_MISSION_POST:
                                if (!has_figure_of_types(b, FIGURE_MISSIONARY, 0)) {
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        if (city_data.population.population > 0) {
                                            city_data.building.mission_post_operational = 1;
                                            b->figure_spawn_delay++;
                                            if (b->figure_spawn_delay > 1) {
                                                b->figure_spawn_delay = 0;
                                                create_roaming_figure(b, road.x, road.y, FIGURE_MISSIONARY);
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_DOCK:
                                check_labor_problem(b);
                                if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 50);
                                    int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                    int max_dockers;
                                    if (pct_workers >= 75) {
                                        max_dockers = 3;
                                    } else if (pct_workers >= 50) {
                                        max_dockers = 2;
                                    } else if (pct_workers > 0) {
                                        max_dockers = 1;
                                    } else {
                                        max_dockers = 0;
                                    }
                                    // count existing dockers
                                    int existing_dockers = 0;
                                    for (int ii = 0; ii < 3; ii++) {
                                        if (b->data.dock.docker_ids[ii]) {
                                            if (figures[b->data.dock.docker_ids[ii]].type == FIGURE_DOCKER) {
                                                existing_dockers++;
                                            } else {
                                                b->data.dock.docker_ids[ii] = 0;
                                            }
                                        }
                                    }
                                    if (existing_dockers > max_dockers) {
                                        // too many dockers, kill one of them
                                        for (int ii = 2; ii >= 0; ii--) {
                                            if (b->data.dock.docker_ids[ii]) {
                                                figure_delete(&figures[b->data.dock.docker_ids[ii]]);
                                                break;
                                            }
                                        }
                                    } else if (existing_dockers < max_dockers) {
                                        struct figure_t *f = figure_create(FIGURE_DOCKER, road.x, road.y, DIR_4_BOTTOM);
                                        f->action_state = FIGURE_ACTION_DOCKER_IDLING;
                                        f->is_targetable = 1;
                                        f->terrain_usage = TERRAIN_USAGE_ROADS;
                                        f->building_id = b->id;
                                        for (int ii = 0; ii < 3; ii++) {
                                            if (!b->data.dock.docker_ids[ii]) {
                                                b->data.dock.docker_ids[ii] = f->id;
                                                break;
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_WHARF:
                                check_labor_problem(b);
                                if (b->data.industry.fishing_boat_id) {
                                    struct figure_t *f = &figures[b->data.industry.fishing_boat_id];
                                    if (!figure_is_alive(f) || f->type != FIGURE_FISHING_BOAT) {
                                        b->data.industry.fishing_boat_id = 0;
                                    }
                                }
                                if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 50);
                                    if (!has_figure_of_types(b, FIGURE_CART_PUSHER, 0)) {
                                        if (b->figure_spawn_delay) {
                                            b->figure_spawn_delay = 0;
                                            b->data.industry.has_fish = 0;
                                            b->output_resource_id = RESOURCE_MEAT;
                                            struct figure_t *f = figure_create(FIGURE_CART_PUSHER, road.x, road.y, DIR_4_BOTTOM);
                                            f->action_state = FIGURE_ACTION_CARTPUSHER_INITIAL;
                                            f->is_targetable = 1;
                                            f->terrain_usage = TERRAIN_USAGE_ROADS;
                                            f->resource_id = RESOURCE_MEAT;
                                            f->building_id = b->id;
                                            b->figure_id = f->id;
                                            f->wait_ticks = 30;
                                        }
                                    }
                                }
                                break;
                            case BUILDING_SHIPYARD:
                                check_labor_problem(b);
                                if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 50);
                                    if (!has_figure_of_types(b, FIGURE_FISHING_BOAT, 0)) {
                                        int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                        if (pct_workers >= 100) {
                                            b->data.industry.progress += 10;
                                        } else if (pct_workers >= 75) {
                                            b->data.industry.progress += 8;
                                        } else if (pct_workers >= 50) {
                                            b->data.industry.progress += 6;
                                        } else if (pct_workers >= 25) {
                                            b->data.industry.progress += 4;
                                        } else if (pct_workers >= 1) {
                                            b->data.industry.progress += 2;
                                        }
                                        if (b->data.industry.progress >= 160) {
                                            b->data.industry.progress = 0;
                                            struct map_point_t boat;
                                            int base_offset = map_grid_offset(b->x, b->y);
                                            for (int *tile_delta = ADJACENT_OFFSETS_MAP_GRID[b->size]; *tile_delta; tile_delta++) {
                                                int grid_offset = base_offset + *tile_delta;
                                                if (map_terrain_is(grid_offset, TERRAIN_WATER)) {
                                                    if (!map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
                                                        int surrounding_water_tiles = 0;
                                                        for (int j = 0; j < DIR_8_NONE; j++) {
                                                            if (map_terrain_is(grid_offset + map_grid_direction_delta(j), TERRAIN_WATER)) {
                                                                surrounding_water_tiles++;
                                                            }
                                                        }
                                                        if (surrounding_water_tiles >= 8) {
                                                            boat.x = map_grid_offset_to_x(grid_offset);
                                                            boat.y = map_grid_offset_to_y(grid_offset);
                                                            struct figure_t *f = figure_create(FIGURE_FISHING_BOAT, boat.x, boat.y, DIR_0_TOP);
                                                            f->action_state = FIGURE_ACTION_FISHING_BOAT_CREATED;
                                                            f->building_id = b->id;
                                                            b->figure_id = f->id;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_NATIVE_HUT:
                                images.items[b->grid_offset] = 2827 + (random.items[b->grid_offset] & 1);
                                if (!has_figure_of_types(b, FIGURE_INDIGENOUS_NATIVE, 0)) {
                                    if (b->subtype.native_meeting_center_id > 0
                                        && map_terrain_get_adjacent_road_or_clear_land(b->x, b->y, b->size, &x_out, &y_out)) {
                                        b->figure_spawn_delay++;
                                        if (b->figure_spawn_delay > 4) {
                                            b->figure_spawn_delay = 0;
                                            struct figure_t *f = figure_create(FIGURE_INDIGENOUS_NATIVE, x_out, y_out, DIR_0_TOP);
                                            f->is_targetable = 1;
                                            f->action_state = FIGURE_ACTION_NATIVE_CREATED;
                                            f->terrain_usage = TERRAIN_USAGE_ANY;
                                            f->building_id = b->id;
                                            b->figure_id = f->id;
                                        }
                                    }
                                }
                                break;
                            case BUILDING_NATIVE_MEETING:
                                map_building_tiles_add(b->id, b->x, b->y, 2, 2829, TERRAIN_BUILDING);
                                if (city_data.building.mission_post_operational > 0 && !has_figure_of_types(b, FIGURE_NATIVE_TRADER, 0)) {
                                    if (map_terrain_get_adjacent_road_or_clear_land(b->x, b->y, b->size, &x_out, &y_out)) {
                                        b->figure_spawn_delay++;
                                        if (b->figure_spawn_delay > 8) {
                                            b->figure_spawn_delay = 0;
                                            struct figure_t *f = figure_create(FIGURE_NATIVE_TRADER, x_out, y_out, DIR_0_TOP);
                                            f->is_targetable = 1;
                                            f->action_state = FIGURE_ACTION_NATIVE_TRADER_CREATED;
                                            f->terrain_usage = TERRAIN_USAGE_ANY;
                                            f->building_id = b->id;
                                            b->figure_id = f->id;
                                        }
                                    }
                                }
                                break;
                            case BUILDING_NATIVE_CROPS:
                                b->data.industry.progress++;
                                if (b->data.industry.progress >= 5) {
                                    b->data.industry.progress = 0;
                                }
                                images.items[b->grid_offset] = 2884 + b->data.industry.progress;
                                break;
                            case BUILDING_BARRACKS:
                                check_labor_problem(b);
                                if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 100);
                                    int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                    int spawn_delay;
                                    if (pct_workers >= 100) {
                                        spawn_delay = 8;
                                    } else if (pct_workers >= 75) {
                                        spawn_delay = 12;
                                    } else if (pct_workers >= 50) {
                                        spawn_delay = 16;
                                    } else if (pct_workers >= 25) {
                                        spawn_delay = 32;
                                    } else if (pct_workers >= 1) {
                                        spawn_delay = 48;
                                    } else {
                                        spawn_delay = INFINITE;
                                    }
                                    b->figure_spawn_delay++;
                                    if (b->figure_spawn_delay > spawn_delay) {
                                        b->figure_spawn_delay = 0;
                                        map_has_road_access(b->x, b->y, b->size, &road);
                                        int create_tower_sentry = 0;
                                        if (tower_sentry_request) {
                                            struct building_t *tower = 0;
                                            for (int ii = 1; ii < MAX_BUILDINGS; ii++) {
                                                struct building_t *bb = &all_buildings[ii];
                                                if (bb->state == BUILDING_STATE_IN_USE && bb->type == BUILDING_TOWER && bb->num_workers > 0 && !bb->figure_id) {
                                                    tower = bb;
                                                    break;
                                                }
                                            }
                                            if (tower) {
                                                struct map_point_t tower_road;
                                                if (map_has_road_access(tower->x, tower->y, tower->size, &tower_road)) {
                                                    struct figure_t *f = figure_create(FIGURE_TOWER_SENTRY, road.x, road.y, DIR_0_TOP);
                                                    tower->figure_id = f->id;
                                                    f->building_id = tower->id;
                                                    struct map_point_t mil_acad_road = { 0 };
                                                    set_destination__closest_building_of_type(tower->id, BUILDING_MILITARY_ACADEMY, &mil_acad_road);
                                                    if (mil_acad_road.x) {
                                                        f->action_state = FIGURE_ACTION_SOLDIER_GOING_TO_MILITARY_ACADEMY;
                                                        f->destination_x = mil_acad_road.x;
                                                        f->destination_y = mil_acad_road.y;
                                                        f->destination_grid_offset = map_grid_offset(f->destination_x, f->destination_y);
                                                    } else {
                                                        f->action_state = FIGURE_ACTION_TOWER_SENTRY_GOING_TO_TOWER;
                                                    }
                                                    create_tower_sentry = 1;
                                                }
                                            }
                                        }
                                        if (!create_tower_sentry) {
                                            struct formation_t *closest_formation = 0;
                                            int closest_formation_distance = 10000;
                                            for (int j = 0; j < MAX_LEGIONS; j++) {
                                                struct formation_t *m = &legion_formations[j];
                                                if (m->in_use && !m->in_distant_battle && !m->cursed_by_mars && m->num_figures < m->max_figures) {
                                                    if (m->figure_type == FIGURE_FORT_LEGIONARY && !b->loads_stored) {
                                                        continue;
                                                    }
                                                    struct building_t *fort = &all_buildings[m->building_id];
                                                    int dist = calc_maximum_distance(b->x, b->y, fort->x, fort->y);
                                                    if (dist < closest_formation_distance) {
                                                        // prefer legionaries
                                                        if (closest_formation && closest_formation->figure_type == FIGURE_FORT_LEGIONARY && m->figure_type != FIGURE_FORT_LEGIONARY) {
                                                            continue;
                                                        }
                                                        closest_formation = &legion_formations[j];
                                                        closest_formation_distance = dist;
                                                    }
                                                }
                                            }
                                            if (closest_formation) {
                                                struct figure_t *f = figure_create(closest_formation->figure_type, road.x, road.y, DIR_0_TOP);
                                                f->is_targetable = 1;
                                                f->terrain_usage = TERRAIN_USAGE_ANY;
                                                f->formation_id = closest_formation->id;
                                                switch (f->type) {
                                                    case FIGURE_FORT_JAVELIN:
                                                        f->speed_multiplier = 2;
                                                        break;
                                                    case FIGURE_FORT_MOUNTED:
                                                        f->mounted_charge_ticks = 10;
                                                        f->mounted_charge_ticks_max = 10;
                                                        f->speed_multiplier = 3;
                                                        break;
                                                    case FIGURE_FORT_LEGIONARY:
                                                        if (b->loads_stored) {
                                                            b->loads_stored--;
                                                        }
                                                        break;
                                                }
                                                f->building_id = closest_formation->building_id;
                                                add_figure_to_formation(f, closest_formation);
                                                struct map_point_t mil_acad_road = { 0 };
                                                set_destination__closest_building_of_type(closest_formation->building_id, BUILDING_MILITARY_ACADEMY, &mil_acad_road);
                                                if (mil_acad_road.x) {
                                                    f->action_state = FIGURE_ACTION_SOLDIER_GOING_TO_MILITARY_ACADEMY;
                                                    f->destination_x = mil_acad_road.x;
                                                    f->destination_y = mil_acad_road.y;
                                                    f->destination_grid_offset = map_grid_offset(f->destination_x, f->destination_y);
                                                } else {
                                                    if (closest_formation->is_at_rest) {
                                                        f->action_state = FIGURE_ACTION_SOLDIER_GOING_TO_FORT;
                                                    } else {
                                                        deploy_legion_unit_to_formation_location(f, closest_formation);
                                                    }
                                                }
                                                city_data.figure.soldiers++;
                                            }
                                        }
                                    }
                                }
                                break;
                            case BUILDING_MILITARY_ACADEMY:
                                check_labor_problem(b);
                                if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                    spawn_labor_seeker(b, road.x, road.y, 100);
                                }
                                break;
                        }
                    }
                }
            }
            break;
            case 32: // update trade
            {
                city_data.trade.num_sea_routes = 0;
                city_data.trade.num_land_routes = 0;
                // Wine types
                city_data.resource.wine_types_available = count_data.industry[RESOURCE_WINE].total > 0 ? 1 : 0;
                if (city_data.resource.trade_status[RESOURCE_WINE] == TRADE_STATUS_IMPORT) {
                    for (int k = 0; k < MAX_EMPIRE_OBJECTS; k++) {
                        if (empire_objects[k].in_use
                            && empire_objects[k].trade_route_open
                            && empire_objects[k].resource_sell_limit[RESOURCE_WINE]) {
                            city_data.resource.wine_types_available++;
                        }
                    }
                }
                // Update trade problems
                if (city_data.trade.land_trade_problem_duration > 0) {
                    city_data.trade.land_trade_problem_duration--;
                } else {
                    city_data.trade.land_trade_problem_duration = 0;
                }
                if (city_data.trade.sea_trade_problem_duration > 0) {
                    city_data.trade.sea_trade_problem_duration--;
                } else {
                    city_data.trade.sea_trade_problem_duration = 0;
                }

                for (int k = 1; k < MAX_EMPIRE_OBJECTS; k++) {
                    if (!empire_objects[k].in_use || !empire_objects[k].trade_route_open) {
                        continue;
                    }
                    if (empire_objects[k].is_sea_trade) {
                        if (!city_data.building.working_docks) {
                            // delay of 384 = 1 year
                            city_message_post_with_message_delay(MESSAGE_CAT_NO_WORKING_DOCK, 1, MESSAGE_NO_WORKING_DOCK, 384);
                            continue;
                        }
                        if (scenario.river_entry_point.x == -1 || scenario.river_entry_point.y == -1) {
                            continue;
                        }
                        city_data.trade.num_sea_routes++;
                    } else {
                        city_data.trade.num_land_routes++;
                    }
                    // generate trader
                    struct empire_object_t *city = &empire_objects[i];
                    int max_traders = 0;
                    int num_resources = 0;
                    for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                        if (city->resource_buy_limit[r]) {
                            ++num_resources;
                            switch (city->resource_buy_limit[r]) {
                                case 15: max_traders += 1; break;
                                case 25: max_traders += 2; break;
                                case 40: max_traders += 3; break;
                            }
                        } else if (city->resource_sell_limit[r]) {
                            ++num_resources;
                            switch (city->resource_sell_limit[r]) {
                                case 15: max_traders += 1; break;
                                case 25: max_traders += 2; break;
                                case 40: max_traders += 3; break;
                            }
                        }
                    }
                    if (num_resources > 1) {
                        if (max_traders % num_resources) {
                            max_traders = max_traders / num_resources + 1;
                        } else {
                            max_traders = max_traders / num_resources;
                        }
                    }
                    if (max_traders <= 0) {
                        continue;
                    }
                    int index;
                    if (max_traders == 1) {
                        if (!city->trader_figure_ids[0]) {
                            index = 0;
                        } else {
                            continue;
                        }
                    } else if (max_traders == 2) {
                        if (!city->trader_figure_ids[0]) {
                            index = 0;
                        } else if (!city->trader_figure_ids[1]) {
                            index = 1;
                        } else {
                            continue;
                        }
                    } else { // 3
                        if (!city->trader_figure_ids[0]) {
                            index = 0;
                        } else if (!city->trader_figure_ids[1]) {
                            index = 1;
                        } else if (!city->trader_figure_ids[2]) {
                            index = 2;
                        } else {
                            continue;
                        }
                    }
                    if (city->trader_entry_delay > 0) {
                        city->trader_entry_delay--;
                        continue;
                    }
                    city->trader_entry_delay = city->is_sea_trade ? 30 : 4;
                    if (city->is_sea_trade) {
                        // generate ship
                        if (city_data.building.working_docks && (scenario.river_entry_point.x != -1 && scenario.river_entry_point.y != -1) && !city_data.trade.sea_trade_problem_duration) {
                            struct figure_t *ship = figure_create(FIGURE_TRADE_SHIP, scenario.river_entry_point.x, scenario.river_entry_point.y, DIR_0_TOP);
                            ship->empire_city_id = city->id;
                            ship->action_state = FIGURE_ACTION_TRADE_SHIP_CREATED;
                            ship->wait_ticks = 10;
                            city->trader_figure_ids[index] = ship->id;
                            break;
                        }
                    } else {
                        // generate caravan and donkeys
                        if (!city_data.trade.land_trade_problem_duration) {
                            // caravan head
                            struct figure_t *caravan = figure_create(FIGURE_TRADE_CARAVAN, scenario.entry_point.x, scenario.entry_point.y, DIR_0_TOP);
                            caravan->is_targetable = 1;
                            caravan->empire_city_id = city->id;
                            caravan->action_state = FIGURE_ACTION_TRADE_CARAVAN_CREATED;
                            caravan->terrain_usage = TERRAIN_USAGE_PREFER_ROADS;
                            caravan->wait_ticks = 10;
                            // donkey 1
                            struct figure_t *donkey1 = figure_create(FIGURE_TRADE_CARAVAN_DONKEY, scenario.entry_point.x, scenario.entry_point.y, DIR_0_TOP);
                            donkey1->is_targetable = 1;
                            donkey1->action_state = FIGURE_ACTION_TRADE_CARAVAN_CREATED;
                            donkey1->terrain_usage = TERRAIN_USAGE_PREFER_ROADS;
                            donkey1->leading_figure_id = caravan->id;
                            // donkey 2
                            struct figure_t *donkey2 = figure_create(FIGURE_TRADE_CARAVAN_DONKEY, scenario.entry_point.x, scenario.entry_point.y, DIR_0_TOP);
                            donkey2->is_targetable = 1;
                            donkey2->action_state = FIGURE_ACTION_TRADE_CARAVAN_CREATED;
                            donkey2->terrain_usage = TERRAIN_USAGE_PREFER_ROADS;
                            donkey2->leading_figure_id = donkey1->id;
                            city->trader_figure_ids[index] = caravan->id;
                            break;
                        }
                    }
                }
            }
            break;
            case 33: // building cont update, culture coverage update
            {
                memset(&count_data, 0, sizeof(count_data));
                city_data.building.working_wharfs = 0;
                city_data.building.shipyard_boats_requested = 0;
                for (int k = 0; k < 8; k++) {
                    city_data.building.working_dock_ids[k] = 0;
                }
                city_data.building.working_docks = 0;
                city_data.health.num_hospital_workers = 0;
                for (int k = 1; k < MAX_BUILDINGS; k++) {
                    struct building_t *b = &all_buildings[k];
                    if (b->state != BUILDING_STATE_IN_USE || b->house_size) {
                        continue;
                    }
                    int is_entertainment_venue = 0;
                    int type = b->type;
                    switch (type) {
                        // SPECIAL TREATMENT
                        // entertainment venues
                        case BUILDING_THEATER:
                        case BUILDING_AMPHITHEATER:
                        case BUILDING_COLOSSEUM:
                        case BUILDING_HIPPODROME:
                            is_entertainment_venue = 1;
                            increase_count(type, b->num_workers > 0);
                            break;
                        case BUILDING_BARRACKS:
                            city_data.building.barracks_building_id = k;
                            increase_count(type, b->num_workers > 0);
                            break;
                        case BUILDING_HOSPITAL:
                            increase_count(type, b->num_workers > 0);
                            city_data.health.num_hospital_workers += b->num_workers;
                            break;
                            // water
                        case BUILDING_RESERVOIR:
                        case BUILDING_FOUNTAIN:
                            increase_count(type, b->has_water_access);
                            break;
                            // DEFAULT TREATMENT
                            // education
                        case BUILDING_SCHOOL:
                        case BUILDING_LIBRARY:
                        case BUILDING_ACADEMY:
                            // health
                        case BUILDING_BARBER:
                        case BUILDING_BATHHOUSE:
                        case BUILDING_DOCTOR:
                            // government
                        case BUILDING_FORUM:
                        case BUILDING_SENATE:
                            // entertainment schools
                        case BUILDING_ACTOR_COLONY:
                        case BUILDING_GLADIATOR_SCHOOL:
                        case BUILDING_LION_HOUSE:
                        case BUILDING_CHARIOT_MAKER:
                            // distribution
                        case BUILDING_MARKET:
                            // military
                        case BUILDING_MILITARY_ACADEMY:
                            // religion
                        case BUILDING_SMALL_TEMPLE_CERES:
                        case BUILDING_SMALL_TEMPLE_NEPTUNE:
                        case BUILDING_SMALL_TEMPLE_MERCURY:
                        case BUILDING_SMALL_TEMPLE_MARS:
                        case BUILDING_SMALL_TEMPLE_VENUS:
                        case BUILDING_LARGE_TEMPLE_CERES:
                        case BUILDING_LARGE_TEMPLE_NEPTUNE:
                        case BUILDING_LARGE_TEMPLE_MERCURY:
                        case BUILDING_LARGE_TEMPLE_MARS:
                        case BUILDING_LARGE_TEMPLE_VENUS:
                        case BUILDING_ORACLE:
                            increase_count(type, b->num_workers > 0);
                            break;
                            // industry
                        case BUILDING_WHEAT_FARM:
                            increase_industry_count(RESOURCE_WHEAT, b->num_workers > 0);
                            break;
                        case BUILDING_VEGETABLE_FARM:
                            increase_industry_count(RESOURCE_VEGETABLES, b->num_workers > 0);
                            break;
                        case BUILDING_FRUIT_FARM:
                            increase_industry_count(RESOURCE_FRUIT, b->num_workers > 0);
                            break;
                        case BUILDING_OLIVE_FARM:
                            increase_industry_count(RESOURCE_OLIVES, b->num_workers > 0);
                            break;
                        case BUILDING_VINES_FARM:
                            increase_industry_count(RESOURCE_VINES, b->num_workers > 0);
                            break;
                        case BUILDING_PIG_FARM:
                            increase_industry_count(RESOURCE_MEAT, b->num_workers > 0);
                            break;
                        case BUILDING_MARBLE_QUARRY:
                            increase_industry_count(RESOURCE_MARBLE, b->num_workers > 0);
                            break;
                        case BUILDING_IRON_MINE:
                            increase_industry_count(RESOURCE_IRON, b->num_workers > 0);
                            break;
                        case BUILDING_TIMBER_YARD:
                            increase_industry_count(RESOURCE_TIMBER, b->num_workers > 0);
                            break;
                        case BUILDING_CLAY_PIT:
                            increase_industry_count(RESOURCE_CLAY, b->num_workers > 0);
                            break;
                        case BUILDING_WINE_WORKSHOP:
                            increase_industry_count(RESOURCE_WINE, b->num_workers > 0);
                            break;
                        case BUILDING_OIL_WORKSHOP:
                            increase_industry_count(RESOURCE_OIL, b->num_workers > 0);
                            break;
                        case BUILDING_WEAPONS_WORKSHOP:
                            increase_industry_count(RESOURCE_WEAPONS, b->num_workers > 0);
                            break;
                        case BUILDING_FURNITURE_WORKSHOP:
                            increase_industry_count(RESOURCE_FURNITURE, b->num_workers > 0);
                            break;
                        case BUILDING_POTTERY_WORKSHOP:
                            increase_industry_count(RESOURCE_POTTERY, b->num_workers > 0);
                            break;
                            // water-side
                        case BUILDING_WHARF:
                            if (b->num_workers > 0) {
                                city_data.building.working_wharfs++;
                                if (!b->data.industry.fishing_boat_id) {
                                    city_data.building.shipyard_boats_requested++;
                                }
                            }
                            break;
                        case BUILDING_DOCK:
                            if (b->num_workers > 0 && b->has_water_access) {
                                city_data.building.working_dock_ids[city_data.building.working_docks] = k;
                                city_data.building.working_docks++;
                            }
                            break;
                        default:
                            continue;
                    }
                    if (b->immigrant_figure_id) {
                        struct figure_t *f = &figures[b->immigrant_figure_id];
                        if (!figure_is_alive(f) || f->destination_building_id != k) {
                            b->immigrant_figure_id = 0;
                        }
                    }
                    if (is_entertainment_venue) {
                        // update number of shows
                        int shows = 0;
                        if (b->data.entertainment.days1 > 0) {
                            --b->data.entertainment.days1;
                            ++shows;
                        }
                        if (b->data.entertainment.days2 > 0) {
                            --b->data.entertainment.days2;
                            ++shows;
                        }
                        b->data.entertainment.num_shows = shows;
                    }
                }
                limit_hippodrome();
                city_culture_update_coverage();
            }
            break;
            case 34: // distribute treasury
            {
                int units = 5 * count_data.buildings[BUILDING_SENATE].active + count_data.buildings[BUILDING_FORUM].active;
                int amount_per_unit;
                int remainder;
                if (city_data.finance.treasury > 0 && units > 0) {
                    amount_per_unit = city_data.finance.treasury / units;
                    remainder = city_data.finance.treasury - units * amount_per_unit;
                } else {
                    amount_per_unit = 0;
                    remainder = 0;
                }

                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE || b->house_size) {
                        continue;
                    }
                    b->tax_income_or_storage = 0;
                    if (b->num_workers <= 0) {
                        continue;
                    }
                    switch (b->type) {
                        // ordered based on importance: most important gets the remainder
                        case BUILDING_SENATE:
                            b->tax_income_or_storage = 5 * amount_per_unit + remainder;
                            remainder = 0;
                            break;
                        case BUILDING_FORUM:
                            if (remainder && !count_data.buildings[BUILDING_SENATE].active) {
                                b->tax_income_or_storage = amount_per_unit + remainder;
                                remainder = 0;
                            } else {
                                b->tax_income_or_storage = amount_per_unit;
                            }
                            break;
                    }
                }
                break;
            }
            case 35: // decay culture 
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE || !b->house_size) {
                        continue;
                    }
                    decay(&b->data.house.theater);
                    decay(&b->data.house.amphitheater_actor);
                    decay(&b->data.house.amphitheater_gladiator);
                    decay(&b->data.house.colosseum_gladiator);
                    decay(&b->data.house.colosseum_lion);
                    decay(&b->data.house.hippodrome);
                    decay(&b->data.house.school);
                    decay(&b->data.house.library);
                    decay(&b->data.house.academy);
                    decay(&b->data.house.barber);
                    decay(&b->data.house.clinic);
                    decay(&b->data.house.bathhouse);
                    decay(&b->data.house.hospital);
                    decay(&b->data.house.temple_ceres);
                    decay(&b->data.house.temple_neptune);
                    decay(&b->data.house.temple_mercury);
                    decay(&b->data.house.temple_mars);
                    decay(&b->data.house.temple_venus);
                }
                break;
            case 36: // calculate culture aggregates
            {
                int base_entertainment = (culture_coverage.hippodrome + culture_coverage.colosseum + culture_coverage.amphitheater + culture_coverage.theater) / 4 / 5;
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE || !b->house_size) {
                        continue;
                    }
                    // entertainment
                    b->data.house.entertainment = base_entertainment;
                    if (b->data.house.theater) {
                        b->data.house.entertainment += 10;
                    }
                    if (b->data.house.amphitheater_actor) {
                        if (b->data.house.amphitheater_gladiator) {
                            b->data.house.entertainment += 15;
                        } else {
                            b->data.house.entertainment += 10;
                        }
                    }
                    if (b->data.house.colosseum_gladiator) {
                        if (b->data.house.colosseum_lion) {
                            b->data.house.entertainment += 25;
                        } else {
                            b->data.house.entertainment += 15;
                        }
                    }
                    if (b->data.house.hippodrome) {
                        b->data.house.entertainment += 30;
                    }
                    // education
                    b->data.house.education = 0;
                    // release build mingw doesn't like school || library for some reason
                    if (b->data.house.school) {
                        b->data.house.education = 1;
                    }
                    if (b->data.house.library) {
                        b->data.house.education = 1;
                    }
                    if (b->data.house.school && b->data.house.library) {
                        b->data.house.education = 2;
                        if (b->data.house.academy) {
                            b->data.house.education = 3;
                        }
                    }
                    // religion
                    b->data.house.num_gods = 0;
                    if (b->data.house.temple_ceres) {
                        ++b->data.house.num_gods;
                    }
                    if (b->data.house.temple_neptune) {
                        ++b->data.house.num_gods;
                    }
                    if (b->data.house.temple_mercury) {
                        ++b->data.house.num_gods;
                    }
                    if (b->data.house.temple_mars) {
                        ++b->data.house.num_gods;
                    }
                    if (b->data.house.temple_venus) {
                        ++b->data.house.num_gods;
                    }
                    // health
                    b->data.house.health = 0;
                    if (b->data.house.clinic) {
                        ++b->data.house.health;
                    }
                    if (b->data.house.hospital) {
                        ++b->data.house.health;
                    }
                }
                break;
            }
            case 37: // update map desirability
            {
                memset(desirability_grid.items, 0, GRID_SIZE * GRID_SIZE * sizeof(int8_t));
                for (int k = 1; k <= extra.highest_id_in_use; k++) {
                    struct building_t *b = &all_buildings[k];
                    if (b->state == BUILDING_STATE_IN_USE) {
                        add_to_terrain(
                            b->x, b->y, b->size,
                            building_properties[b->type].desirability_value,
                            building_properties[b->type].desirability_step,
                            building_properties[b->type].desirability_step_size,
                            building_properties[b->type].desirability_range);
                    }
                }
                int grid_offset = map_data.start_offset;
                for (int y = 0; y < map_data.height; y++, grid_offset += map_data.border_size) {
                    for (int x = 0; x < map_data.width; x++, grid_offset++) {
                        if (bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
                            int type;
                            if (terrain_grid.items[grid_offset] & TERRAIN_ROAD) {
                                type = BUILDING_PLAZA;
                            } else if (terrain_grid.items[grid_offset] & TERRAIN_ROCK) {
                                // earthquake fault line: slight negative
                                type = BUILDING_HOUSE_VACANT_LOT;
                            } else {
                                // invalid plaza/earthquake flag
                                bitfields_grid.items[grid_offset] &= BIT_NO_PLAZA;
                                continue;
                            }
                            add_to_terrain(x, y, 1,
                                building_properties[type].desirability_value,
                                building_properties[type].desirability_step,
                                building_properties[type].desirability_step_size,
                                building_properties[type].desirability_range);
                        } else if (terrain_grid.items[grid_offset] & TERRAIN_GARDEN) {
                            add_to_terrain(x, y, 1,
                                building_properties[BUILDING_GARDENS].desirability_value,
                                building_properties[BUILDING_GARDENS].desirability_step,
                                building_properties[BUILDING_GARDENS].desirability_step_size,
                                building_properties[BUILDING_GARDENS].desirability_range);
                        } else if (terrain_grid.items[grid_offset] & TERRAIN_RUBBLE) {
                            add_to_terrain(x, y, 1, -2, 1, 1, 2);
                        } else if (terrain_grid.items[grid_offset] & TERRAIN_WATER) {
                            add_to_terrain(x, y, 1, 1, 1, 0, 3);
                        } else if (terrain_grid.items[grid_offset] & TERRAIN_SHRUB) {
                            add_to_terrain(x, y, 1, 1, 1, 0, 1);
                        } else if (terrain_grid.items[grid_offset] & TERRAIN_TREE) {
                            add_to_terrain(x, y, 1, 1, 1, 0, 3);
                        }
                    }
                }
                int index = 0;
                int x, y;
                for (int size = 1; size <= 5; size++) {
                    for (int dist = 1; dist <= 6; dist++) {
                        desirability_data.index[size][dist] = index;
                        // top row, from x=0
                        for (y = -dist, x = 0; x < size + dist; x++, index++) {
                            desirability_data.tiles[index].x = x;
                            desirability_data.tiles[index].y = y;
                        }
                        // right row down
                        for (x = size + dist - 1, y = -dist + 1; y < size + dist; y++, index++) {
                            desirability_data.tiles[index].x = x;
                            desirability_data.tiles[index].y = y;
                        }
                        // bottom row to the left
                        for (y = size + dist - 1, x = size + dist - 2; x >= -dist; x--, index++) {
                            desirability_data.tiles[index].x = x;
                            desirability_data.tiles[index].y = y;
                        }
                        // left row up
                        for (x = -dist, y = size + dist - 2; y >= -dist; y--, index++) {
                            desirability_data.tiles[index].x = x;
                            desirability_data.tiles[index].y = y;
                        }
                        // top row up to x=0
                        for (y = -dist, x = -dist + 1; x < 0; x++, index++) {
                            desirability_data.tiles[index].x = x;
                            desirability_data.tiles[index].y = y;
                        }
                    }
                }
                for (int k = 0; k < index; k++) {
                    desirability_data.tiles[k].grid_offset = map_grid_delta(desirability_data.tiles[k].x, desirability_data.tiles[k].y);
                }
            }
            break;
            case 38: // update building desirability
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE) {
                        continue;
                    }
                    if (b->size == 1) {
                        b->desirability = desirability_grid.items[map_grid_offset(b->x, b->y)];
                    } else {
                        int max = -9999;
                        for (int dy = 0; dy < b->size; dy++) {
                            for (int dx = 0; dx < b->size; dx++) {
                                int grid_offset = map_grid_offset(b->x + dx, b->y + dy);
                                if (desirability_grid.items[grid_offset] > max) {
                                    max = desirability_grid.items[grid_offset];
                                }
                            }
                        }
                        b->desirability = max;
                    }
                }
                break;
            case 39: // evolve/devolve houses, consume goods
                city_data.houses.missing.fountain = 0;
                city_data.houses.missing.well = 0;
                city_data.houses.missing.entertainment = 0;
                city_data.houses.missing.more_entertainment = 0;
                city_data.houses.missing.education = 0;
                city_data.houses.missing.more_education = 0;
                city_data.houses.missing.religion = 0;
                city_data.houses.missing.second_religion = 0;
                city_data.houses.missing.third_religion = 0;
                city_data.houses.missing.barber = 0;
                city_data.houses.missing.bathhouse = 0;
                city_data.houses.missing.clinic = 0;
                city_data.houses.missing.hospital = 0;
                city_data.houses.missing.food = 0;
                // NB: second_wine purposely not cleared
                city_data.houses.requiring.school = 0;
                city_data.houses.requiring.library = 0;
                city_data.houses.requiring.barber = 0;
                city_data.houses.requiring.bathhouse = 0;
                city_data.houses.requiring.clinic = 0;
                city_data.houses.requiring.religion = 0;
                int has_expanded = 0;
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state == BUILDING_STATE_IN_USE && building_is_house(b->type) && b->type != BUILDING_HOUSE_VACANT_LOT) {
                        int calc_grid_offset = map_grid_offset(b->x, b->y);
                        b->data.house.no_space_to_expand = 0;
                        if (b->grid_offset != calc_grid_offset || map_building_at(b->grid_offset) != b->id) {
                            for (int y = 0; y < map_data.height; y++) {
                                for (int x = 0; x < map_data.width; x++) {
                                    int grid_offset = map_grid_offset(x, y);
                                    if (map_building_at(grid_offset) == b->id) {
                                        b->grid_offset = grid_offset;
                                        b->x = map_grid_offset_to_x(grid_offset);
                                        b->y = map_grid_offset_to_y(grid_offset);
                                        building_totals_add_corrupted_house(0);
                                        return;
                                    }
                                }
                            }
                            building_totals_add_corrupted_house(1);
                            b->state = BUILDING_STATE_RUBBLE;
                        }
                        has_expanded |= evolve_callback[b->type - BUILDING_HOUSE_SMALL_TENT](b, &city_data.houses);
                        if (time_data.day == 0 || time_data.day == 7) {
                            consume_resource(b, INVENTORY_POTTERY, house_properties[b->subtype.house_level].pottery);
                            consume_resource(b, INVENTORY_FURNITURE, house_properties[b->subtype.house_level].furniture);
                            consume_resource(b, INVENTORY_OIL, house_properties[b->subtype.house_level].oil);
                            consume_resource(b, INVENTORY_WINE, house_properties[b->subtype.house_level].wine);
                        }
                    }
                }
                if (has_expanded) {
                    map_routing_update_land();
                }
                break;
            case 40: building_update_state(); break;
            case 43: // update burning ruins
                building_list_data.burning.size = 0;
                building_list_data.burning.total = 0;
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_BURNING_RUIN) {
                        continue;
                    }
                    if (b->fire_duration < 0) {
                        b->fire_duration = 0;
                    }
                    b->fire_duration++;
                    if (b->fire_duration > 32) {
                        undo_data.available = 0;
                        b->state = BUILDING_STATE_RUBBLE;
                        map_building_tiles_set_rubble(j, b->x, b->y, b->size);
                        recalculate_terrain = 1;
                        continue;
                    }
                    if (b->ruin_has_plague) {
                        continue;
                    }
                    building_list_data.burning.total++;
                    building_list_data.burning.items[building_list_data.burning.size++] = j;
                    if (building_list_data.burning.size >= MAX_BURNING) {
                        building_list_data.burning.size = MAX_BURNING - 1;
                    }
                    if (scenario.climate == CLIMATE_DESERT) {
                        if (b->fire_duration & 3) { // check spread every 4 ticks
                            continue;
                        }
                    } else {
                        if (b->fire_duration & 7) { // check spread every 8 ticks
                            continue;
                        }
                    }
                    if ((b->house_figure_generation_delay & 3) != (random_data.random1_7bit & 3)) {
                        continue;
                    }
                    int dir1 = fire_spread_direction - 1;
                    if (dir1 < 0) dir1 = 7;
                    int dir2 = fire_spread_direction + 1;
                    if (dir2 > 7) dir2 = 0;

                    int grid_offset = b->grid_offset;
                    int next_building_id = map_building_at(grid_offset + map_grid_direction_delta(fire_spread_direction));
                    if (next_building_id && !all_buildings[next_building_id].fire_proof) {
                        building_destroy_by_fire(&all_buildings[next_building_id]);
                        play_sound_effect(SOUND_EFFECT_EXPLOSION);
                        recalculate_terrain = 1;
                    } else {
                        next_building_id = map_building_at(grid_offset + map_grid_direction_delta(dir1));
                        if (next_building_id && !all_buildings[next_building_id].fire_proof) {
                            building_destroy_by_fire(&all_buildings[next_building_id]);
                            play_sound_effect(SOUND_EFFECT_EXPLOSION);
                            recalculate_terrain = 1;
                        } else {
                            next_building_id = map_building_at(grid_offset + map_grid_direction_delta(dir2));
                            if (next_building_id && !all_buildings[next_building_id].fire_proof) {
                                building_destroy_by_fire(&all_buildings[next_building_id]);
                                play_sound_effect(SOUND_EFFECT_EXPLOSION);
                                recalculate_terrain = 1;
                            }
                        }
                    }
                }
                if (recalculate_terrain) {
                    map_routing_update_land();
                }
                break;
            case 44: // check fire/collapse
                city_data.sentiment.protesters = 0;
                city_data.sentiment.criminals = 0;
                int random_global = random_data.random1_7bit & 7;
                for (int j = 1; j <= extra.highest_id_in_use; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE || b->fire_proof) {
                        continue;
                    }
                    if (b->type == BUILDING_HIPPODROME && b->prev_part_building_id) {
                        continue;
                    }
                    int random_building = (j + random.items[b->grid_offset]) & 7;
                    // damage
                    b->damage_risk += random_building == random_global ? 3 : 1;
                    if (b->house_size && b->subtype.house_level <= HOUSE_LARGE_TENT) {
                        b->damage_risk = 0;
                    }
                    if (b->damage_risk > 200) {
                        city_message_apply_sound_interval(MESSAGE_CAT_COLLAPSE);
                        city_message_post_with_popup_delay(MESSAGE_CAT_COLLAPSE, MESSAGE_COLLAPSED_BUILDING, b->type, b->grid_offset);
                        undo_data.available = 0;
                        building_destroy_by_collapse(b);
                        recalculate_terrain = 1;
                        continue;
                    }
                    // fire
                    if (random_building == random_global) {
                        if (!b->house_size) {
                            b->fire_risk += 5;
                        } else if (b->house_population <= 0) {
                            b->fire_risk = 0;
                        } else if (b->subtype.house_level <= HOUSE_LARGE_SHACK) {
                            b->fire_risk += 10;
                        } else if (b->subtype.house_level <= HOUSE_GRAND_INSULA) {
                            b->fire_risk += 5;
                        } else {
                            b->fire_risk += 2;
                        }
                        if (scenario.climate == CLIMATE_NORTHERN) {
                            b->fire_risk = 0;
                        } else if (scenario.climate == CLIMATE_DESERT) {
                            b->fire_risk += 3;
                        }
                    }
                    if (b->fire_risk > 100) {
                        city_message_apply_sound_interval(MESSAGE_CAT_FIRE);
                        city_message_post_with_popup_delay(MESSAGE_CAT_FIRE, MESSAGE_FIRE, b->type, b->grid_offset);
                        building_destroy_by_fire(b);
                        play_sound_effect(SOUND_EFFECT_EXPLOSION);
                        recalculate_terrain = 1;
                    }
                }
                if (recalculate_terrain) {
                    map_routing_update_land();
                }
                break;
            case 45:
            {
                struct building_t *min_building = 0;
                int min_happiness = 50;
                for (int k = 1; k <= extra.highest_id_in_use; k++) {
                    struct building_t *b = &all_buildings[k];
                    if (b->state == BUILDING_STATE_IN_USE && b->house_size) {
                        if (b->sentiment.house_happiness >= 50) {
                            b->house_criminal_active = 0;
                        } else if (b->sentiment.house_happiness < min_happiness) {
                            min_happiness = b->sentiment.house_happiness;
                            min_building = b;
                        }
                    }
                }
                if (min_building) {
                    int sentiment = city_data.sentiment.value;
                    if (sentiment < 30) {
                        if (random_data.random1_7bit >= sentiment + 50) {
                            if (min_happiness <= 10) {
                                int x_road, y_road;
                                if (map_closest_road_within_radius(min_building->x, min_building->y, min_building->size, 4, &x_road, &y_road)) {
                                    city_data.sentiment.criminals++;
                                    int people_in_mob;
                                    if (city_data.population.population <= 150) {
                                        people_in_mob = 1;
                                    } else if (city_data.population.population <= 300) {
                                        people_in_mob = 2;
                                    } else if (city_data.population.population <= 800) {
                                        people_in_mob = 3;
                                    } else if (city_data.population.population <= 1200) {
                                        people_in_mob = 4;
                                    } else if (city_data.population.population <= 2000) {
                                        people_in_mob = 5;
                                    } else {
                                        people_in_mob = 6;
                                    }
                                    int x_target, y_target;
                                    int target_building_id = formation_rioter_get_target_building(&x_target, &y_target);
                                    for (int k = 0; k < people_in_mob; k++) {
                                        struct figure_t *f = figure_create(FIGURE_RIOTER, x_road, y_road, DIR_4_BOTTOM);
                                        f->is_targetable = 1;
                                        f->action_state = FIGURE_ACTION_RIOTER_CREATED;
                                        f->terrain_usage = TERRAIN_USAGE_ENEMY;
                                        f->roam_length = 0;
                                        f->wait_ticks = 10 + 4 * k;
                                        if (target_building_id) {
                                            f->destination_x = x_target;
                                            f->destination_y = y_target;
                                            f->destination_building_id = target_building_id;
                                        }
                                        city_data.figure.rioters++;
                                    }
                                    destroy_on_fire(min_building, 0);
                                    city_data.ratings.peace_num_rioters++;
                                    city_data.ratings.peace_riot_cause = city_data.sentiment.low_mood_cause;
                                    city_sentiment_change_happiness(20);
                                    city_message_apply_sound_interval(MESSAGE_CAT_RIOT);
                                    city_message_post_with_popup_delay(MESSAGE_CAT_RIOT, MESSAGE_RIOT, min_building->type, map_grid_offset(x_road, y_road));
                                }
                            } else if (min_happiness < 30) {
                                generate_mugger(min_building);
                            } else if (min_happiness < 50) {
                                generate_protestor(min_building);
                            }
                        }
                    } else if (sentiment < 60) {
                        if (random_data.random1_7bit >= sentiment + 40) {
                            if (min_happiness < 30) {
                                generate_mugger(min_building);
                            } else if (min_happiness < 50) {
                                generate_protestor(min_building);
                            }
                        }
                    } else {
                        if (random_data.random1_7bit >= sentiment + 20) {
                            if (min_happiness < 50) {
                                generate_protestor(min_building);
                            }
                        }
                    }
                }
            }
            break;
            case 46: // update wheat production
                if (scenario.climate != CLIMATE_NORTHERN) {
                    for (int j = 1; j < MAX_BUILDINGS; j++) {
                        struct building_t *b = &all_buildings[j];
                        if (b->state != BUILDING_STATE_IN_USE || !b->output_resource_id) {
                            continue;
                        }
                        if (b->houses_covered <= 0 || b->num_workers <= 0) {
                            continue;
                        }
                        if (b->type == BUILDING_WHEAT_FARM && !b->data.industry.curse_days_left) {
                            b->data.industry.progress += b->num_workers;
                            if (b->data.industry.blessing_days_left) {
                                b->data.industry.progress += b->num_workers;
                            }
                            if (b->data.industry.progress > MAX_PROGRESS_RAW) {
                                b->data.industry.progress = MAX_PROGRESS_RAW;
                            }
                            update_farm_image(b);
                        }
                    }
                }
                break;
            case 48: // decay tax collector
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state == BUILDING_STATE_IN_USE && b->house_tax_coverage) {
                        b->house_tax_coverage--;
                    }
                }
                break;
            case 49: city_culture_calculate(); break;
        }
        time_data.tick++;
        if (time_data.tick >= 50) {
            time_data.tick = 0;
            time_data.total_days++;
            time_data.day++;
            if (time_data.day >= 16) { // advance month
                time_data.day = 0;
                city_data.migration.newcomers = 0;
                if (city_data.population.population < 200) {
                    city_data.health.value = 50;
                    city_data.health.target_value = 50;
                } else {
                    int total_population = 0;
                    int healthy_population = 0;
                    for (int k = 1; k < MAX_BUILDINGS; k++) {
                        struct building_t *b = &all_buildings[k];
                        if (b->state != BUILDING_STATE_IN_USE || !b->house_size || !b->house_population) {
                            continue;
                        }
                        total_population += b->house_population;
                        if (b->subtype.house_level <= HOUSE_LARGE_TENT) {
                            if (b->data.house.clinic) {
                                healthy_population += b->house_population;
                            } else {
                                healthy_population += b->house_population / 4;
                            }
                        } else if (b->data.house.clinic) {
                            if (b->house_days_without_food == 0) {
                                healthy_population += b->house_population;
                            } else {
                                healthy_population += b->house_population / 4;
                            }
                        } else if (b->house_days_without_food == 0) {
                            healthy_population += b->house_population / 4;
                        }
                    }
                    city_data.health.target_value = calc_percentage(healthy_population, total_population);
                    if (city_data.health.value < city_data.health.target_value) {
                        city_data.health.value += 2;
                        if (city_data.health.value > city_data.health.target_value) {
                            city_data.health.value = city_data.health.target_value;
                        }
                    } else if (city_data.health.value > city_data.health.target_value) {
                        city_data.health.value -= 2;
                        if (city_data.health.value < city_data.health.target_value) {
                            city_data.health.value = city_data.health.target_value;
                        }
                    }
                    city_data.health.value = calc_bound(city_data.health.value, 0, 100);
                    int chance_value = random_data.random1_7bit & 0x3f;
                    if (city_data.health.value < 40) {
                        if (city_data.religion.venus_curse_active) {
                            // force plague
                            chance_value = 0;
                            city_data.religion.venus_curse_active = 0;
                        }
                        if (chance_value <= 40 - city_data.health.value) {
                            int sick_people = calc_adjust_with_percentage(total_population, 7 + (random_data.random1_7bit & 3));
                            if (sick_people) {
                                city_data.health.value = calc_bound(city_data.health.value + 10, 0, 100);
                                int people_to_kill = sick_people - city_data.health.num_hospital_workers;
                                if (!people_to_kill) {
                                    city_message_post(1, MESSAGE_HEALTH_ILLNESS, 0, 0);
                                } else {
                                    if (city_data.health.num_hospital_workers > 0) {
                                        city_message_post(1, MESSAGE_HEALTH_DISEASE, 0, 0);
                                    } else {
                                        city_message_post(1, MESSAGE_HEALTH_PESTILENCE, 0, 0);
                                    }
                                    int cont = 1;
                                    // kill people who don't have access to a doctor
                                    for (int l = 1; l < MAX_BUILDINGS; l++) {
                                        struct building_t *b = &all_buildings[l];
                                        if (b->state == BUILDING_STATE_IN_USE && b->house_size && b->house_population) {
                                            if (!b->data.house.clinic) {
                                                people_to_kill -= b->house_population;
                                                destroy_on_fire(b, 1);
                                                if (people_to_kill <= 0) {
                                                    cont = 0;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (cont) {
                                        // kill people in tents
                                        for (int l = 1; l < MAX_BUILDINGS; l++) {
                                            struct building_t *b = &all_buildings[l];
                                            if (b->state == BUILDING_STATE_IN_USE && b->house_size && b->house_population) {
                                                if (b->subtype.house_level <= HOUSE_LARGE_TENT) {
                                                    people_to_kill -= b->house_population;
                                                    destroy_on_fire(b, 1);
                                                    if (people_to_kill <= 0) {
                                                        cont = 0;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if (cont) {
                                            // kill anyone
                                            for (int l = 1; l < MAX_BUILDINGS; l++) {
                                                struct building_t *b = &all_buildings[l];
                                                if (b->state == BUILDING_STATE_IN_USE && b->house_size && b->house_population) {
                                                    people_to_kill -= b->house_population;
                                                    destroy_on_fire(b, 1);
                                                    if (people_to_kill <= 0) {
                                                        return;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                int event = RANDOM_EVENT_PROBABILITY[random_data.random1_7bit];
                switch (event) {
                    case EVENT_ROME_RAISES_WAGES:
                        if (scenario.random_events.raise_wages) {
                            if (city_data.labor.wages_rome < 45) {
                                city_data.labor.wages_rome += 1 + (random_data.random2_7bit & 3);
                                if (city_data.labor.wages_rome > 45) {
                                    city_data.labor.wages_rome = 45;
                                }
                                city_message_post(1, MESSAGE_ROME_RAISES_WAGES, 0, 0);
                            }
                        }
                        break;
                    case EVENT_ROME_LOWERS_WAGES:
                        if (scenario.random_events.lower_wages) {
                            if (city_data.labor.wages_rome > 5) {
                                city_data.labor.wages_rome -= 1 + (random_data.random2_7bit & 3);
                                city_message_post(1, MESSAGE_ROME_LOWERS_WAGES, 0, 0);
                            }
                        }
                        break;
                    case EVENT_LAND_TRADE_DISRUPTED:
                        if (scenario.random_events.land_trade_problem) {
                            if (city_data.trade.num_land_routes) {
                                city_data.trade.land_trade_problem_duration = 48;
                                if (scenario.climate == CLIMATE_DESERT) {
                                    city_message_post(1, MESSAGE_LAND_TRADE_DISRUPTED_SANDSTORMS, 0, 0);
                                } else {
                                    city_message_post(1, MESSAGE_LAND_TRADE_DISRUPTED_LANDSLIDES, 0, 0);
                                }
                            }
                        }
                        break;
                    case EVENT_LAND_SEA_DISRUPTED:
                        if (scenario.random_events.sea_trade_problem) {
                            if (city_data.trade.num_sea_routes) {
                                city_data.trade.sea_trade_problem_duration = 48;
                                city_message_post(1, MESSAGE_SEA_TRADE_DISRUPTED, 0, 0);
                            }
                        }
                        break;
                    case EVENT_CONTAMINATED_WATER:
                        if (scenario.random_events.contaminated_water) {
                            if (city_data.population.population > 200) {
                                int change;
                                if (city_data.health.value > 80) {
                                    change = -50;
                                } else if (city_data.health.value > 60) {
                                    change = -40;
                                } else {
                                    change = -25;
                                }
                                city_data.health.value = calc_bound(city_data.health.value + change, 0, 100);
                                city_message_post(1, MESSAGE_CONTAMINATED_WATER, 0, 0);
                            }
                        }
                        break;
                }
                // collect monthly taxes
                city_data.taxes.taxed_plebs = 0;
                city_data.taxes.taxed_patricians = 0;
                city_data.taxes.untaxed_plebs = 0;
                city_data.taxes.untaxed_patricians = 0;
                city_data.taxes.monthly.uncollected_plebs = 0;
                city_data.taxes.monthly.collected_plebs = 0;
                city_data.taxes.monthly.uncollected_patricians = 0;
                city_data.taxes.monthly.collected_patricians = 0;
                for (int j = 0; j < MAX_HOUSE_LEVELS; j++) {
                    city_data.population.at_level[j] = 0;
                }
                for (int j = 1; j < MAX_BUILDINGS; j++) {
                    struct building_t *b = &all_buildings[j];
                    if (b->state != BUILDING_STATE_IN_USE || !b->house_size) {
                        continue;
                    }
                    int is_patrician = b->subtype.house_level >= HOUSE_SMALL_VILLA;
                    int population = b->house_population;
                    city_data.population.at_level[b->subtype.house_level] += population;
                    int tax = population * house_properties[b->subtype.house_level].tax_multiplier;
                    if (b->house_tax_coverage) {
                        if (is_patrician) {
                            city_data.taxes.taxed_patricians += population;
                            city_data.taxes.monthly.collected_patricians += tax;
                        } else {
                            city_data.taxes.taxed_plebs += population;
                            city_data.taxes.monthly.collected_plebs += tax;
                        }
                        b->tax_income_or_storage += tax;
                    } else {
                        if (is_patrician) {
                            city_data.taxes.untaxed_patricians += population;
                            city_data.taxes.monthly.uncollected_patricians += tax;
                        } else {
                            city_data.taxes.untaxed_plebs += population;
                            city_data.taxes.monthly.uncollected_plebs += tax;
                        }
                    }
                }
                int collected_patricians = calc_adjust_with_percentage(
                    city_data.taxes.monthly.collected_patricians / 2,
                    city_data.finance.tax_percentage);
                int collected_plebs = calc_adjust_with_percentage(
                    city_data.taxes.monthly.collected_plebs / 2,
                    city_data.finance.tax_percentage);
                int collected_total = collected_patricians + collected_plebs;
                city_data.taxes.yearly.collected_patricians += collected_patricians;
                city_data.taxes.yearly.collected_plebs += collected_plebs;
                city_data.taxes.yearly.uncollected_patricians += calc_adjust_with_percentage(
                    city_data.taxes.monthly.uncollected_patricians / 2,
                    city_data.finance.tax_percentage);
                city_data.taxes.yearly.uncollected_plebs += calc_adjust_with_percentage(
                    city_data.taxes.monthly.uncollected_plebs / 2,
                    city_data.finance.tax_percentage);

                city_data.finance.treasury += collected_total;
                int total_patricians = city_data.taxes.taxed_patricians + city_data.taxes.untaxed_patricians;
                int total_plebs = city_data.taxes.taxed_plebs + city_data.taxes.untaxed_plebs;
                city_data.taxes.percentage_taxed_patricians = calc_percentage(city_data.taxes.taxed_patricians, total_patricians);
                city_data.taxes.percentage_taxed_plebs = calc_percentage(city_data.taxes.taxed_plebs, total_plebs);
                city_data.taxes.percentage_taxed_people = calc_percentage(
                    city_data.taxes.taxed_patricians + city_data.taxes.taxed_plebs,
                    total_patricians + total_plebs);
                // pay monthly wages
                int wages = city_data.labor.wages * city_data.labor.workers_employed / 10 / 12;
                city_data.finance.treasury -= wages;
                city_data.finance.wages_so_far += wages;
                city_data.finance.wage_rate_paid_this_year += city_data.labor.wages;
                // pay monthly interest
                if (city_data.finance.treasury < 0) {
                    int interest = calc_adjust_with_percentage(-city_data.finance.treasury, 10) / 12;
                    city_data.finance.treasury -= interest;
                    city_data.finance.interest_so_far += interest;
                }
                // pay monthly salary
                if (city_finance_can_afford(city_data.emperor.salary_amount)) {
                    city_data.finance.salary_so_far += city_data.emperor.salary_amount;
                    city_data.emperor.personal_savings += city_data.emperor.salary_amount;
                    city_data.finance.treasury -= city_data.emperor.salary_amount;
                }
                calculate_available_food();
                city_data.resource.food_types_eaten = 0;
                int total_consumed = 0;
                for (int k = 1; k < MAX_BUILDINGS; k++) {
                    struct building_t *b = &all_buildings[k];
                    if (b->state == BUILDING_STATE_IN_USE && b->house_size) {
                        int amount_per_type = calc_adjust_with_percentage(b->house_population, 50);
                        if (house_properties[b->subtype.house_level].food_types > 1) {
                            amount_per_type /= house_properties[b->subtype.house_level].food_types;
                        }
                        b->data.house.num_foods = 0;
                        if (scenario.rome_supplies_wheat) {
                            city_data.resource.food_types_eaten = 1;
                            city_data.resource.food_types_available = 1;
                            b->data.house.inventory[INVENTORY_WHEAT] = amount_per_type;
                            b->data.house.num_foods = 1;
                        } else if (house_properties[b->subtype.house_level].food_types > 0) {
                            for (int t = INVENTORY_WHEAT; t <= INVENTORY_MEAT && b->data.house.num_foods < house_properties[b->subtype.house_level].food_types; t++) {
                                if (b->data.house.inventory[t] >= amount_per_type) {
                                    b->data.house.inventory[t] -= amount_per_type;
                                    b->data.house.num_foods++;
                                    total_consumed += amount_per_type;
                                } else if (b->data.house.inventory[t]) {
                                    // has food but not enough
                                    b->data.house.inventory[t] = 0;
                                    b->data.house.num_foods++;
                                    total_consumed += amount_per_type;
                                }
                                if (b->data.house.num_foods > city_data.resource.food_types_eaten) {
                                    city_data.resource.food_types_eaten = b->data.house.num_foods;
                                }
                            }
                        }
                    }
                }
                city_data.resource.food_consumed_last_month = total_consumed;
                city_data.resource.food_produced_last_month = city_data.resource.food_produced_this_month;
                city_data.resource.food_produced_this_month = 0;
                if (city_data.mission.has_won) {
                    city_data.mission.continue_months_left--;
                }
                for (int k = 0; k < MAX_LEGIONS; k++) {
                    if (legion_formations[k].in_use && !legion_formations[k].in_distant_battle) {
                        struct formation_t *m = &legion_formations[k];
                        if (m->is_at_rest) {
                            m->deployed_duration_months = 0;
                            m->morale = calc_bound(m->morale + 5, 0, m->max_morale);
                        } else if (!m->recent_fight) {
                            m->deployed_duration_months++;
                            if (m->deployed_duration_months > 3) {
                                m->morale = calc_bound(m->morale - 5, 0, m->max_morale);
                            }
                        }
                    }
                }
                for (int k = 0; k < MAX_MESSAGE_CATEGORIES; k++) {
                    if (message_data.message_delay[k] > 0) {
                        message_data.message_delay[k]--;
                    }
                }
                map_tiles_update_all_roads();
                map_tiles_update_all_water();
                map_routing_update_land_citizen();
                city_message_sort_and_compact();
                time_data.month++;
                if (time_data.month >= 12) { // advance year
                    time_data.month = 0;
                    undo_data.available = 0;
                    time_data.year++;
                    if (!scenario.empire.is_expanded && scenario.empire.expansion_year && time_data.year >= scenario.empire.expansion_year + scenario.start_year) {
                        for (int k = 0; k < MAX_EMPIRE_OBJECTS; k++) {
                            if (!empire_objects[k].in_use || empire_objects[k].type != EMPIRE_OBJECT_CITY) {
                                continue;
                            }
                            if (empire_objects[k].city_type == EMPIRE_CITY_FUTURE_TRADE) {
                                empire_objects[k].city_type = EMPIRE_CITY_TRADE;
                                empire_objects[k].expanded.image_id = 8010;
                            } else if (empire_objects[k].city_type == EMPIRE_CITY_FUTURE_ROMAN) {
                                empire_objects[k].city_type = EMPIRE_CITY_DISTANT_ROMAN;
                                empire_objects[k].expanded.image_id = 8017;
                            } else {
                                continue;
                            }
                        }
                        scenario.empire.is_expanded = 1;
                        city_message_post(1, MESSAGE_EMPIRE_HAS_EXPANDED, 0, 0);
                    }
                    city_data.population.yearly_update_requested = 1;
                    calculate_people_per_house_type();
                    // reset taxes
                    city_data.finance.last_year.income.taxes = city_data.taxes.yearly.collected_plebs + city_data.taxes.yearly.collected_patricians;
                    city_data.taxes.yearly.collected_plebs = 0;
                    city_data.taxes.yearly.collected_patricians = 0;
                    city_data.taxes.yearly.uncollected_plebs = 0;
                    city_data.taxes.yearly.uncollected_patricians = 0;
                    // reset tax income in building list
                    for (int j = 1; j < MAX_BUILDINGS; j++) {
                        struct building_t *b = &all_buildings[j];
                        if (b->state == BUILDING_STATE_IN_USE && b->house_size) {
                            b->tax_income_or_storage = 0;
                        }
                    }
                    // copy amounts to last year
                    struct finance_overview_t *last_year = &city_data.finance.last_year;
                    struct finance_overview_t *this_year = &city_data.finance.this_year;
                    // wages
                    last_year->expenses.wages = city_data.finance.wages_so_far;
                    city_data.finance.wages_so_far = 0;
                    city_data.finance.wage_rate_paid_last_year = city_data.finance.wage_rate_paid_this_year;
                    city_data.finance.wage_rate_paid_this_year = 0;
                    // import/export
                    last_year->income.exports = this_year->income.exports;
                    this_year->income.exports = 0;
                    last_year->expenses.imports = this_year->expenses.imports;
                    this_year->expenses.imports = 0;
                    // construction
                    last_year->expenses.construction = this_year->expenses.construction;
                    this_year->expenses.construction = 0;
                    // interest
                    last_year->expenses.interest = city_data.finance.interest_so_far;
                    city_data.finance.interest_so_far = 0;
                    // salary
                    city_data.finance.last_year.expenses.salary = city_data.finance.salary_so_far;
                    city_data.finance.salary_so_far = 0;
                    // sundries
                    last_year->expenses.sundries = this_year->expenses.sundries;
                    this_year->expenses.sundries = 0;
                    city_data.finance.stolen_last_year = city_data.finance.stolen_this_year;
                    city_data.finance.stolen_this_year = 0;
                    // donations
                    last_year->income.donated = this_year->income.donated;
                    this_year->income.donated = 0;
                    // pay tribute
                    int income =
                        last_year->income.donated +
                        last_year->income.taxes +
                        last_year->income.exports;
                    int expenses =
                        last_year->expenses.sundries +
                        last_year->expenses.salary +
                        last_year->expenses.interest +
                        last_year->expenses.construction +
                        last_year->expenses.wages +
                        last_year->expenses.imports;
                    city_data.finance.tribute_not_paid_last_year = 0;
                    if (city_data.finance.treasury <= 0) {
                        // city is in debt
                        city_data.finance.tribute_not_paid_last_year = 1;
                        city_data.finance.tribute_not_paid_total_years++;
                        last_year->expenses.tribute = 0;
                    } else if (income <= expenses) {
                        // city made a loss: fixed tribute based on population
                        city_data.finance.tribute_not_paid_total_years = 0;
                        if (city_data.population.population > 2000) {
                            last_year->expenses.tribute = 200;
                        } else if (city_data.population.population > 1000) {
                            last_year->expenses.tribute = 100;
                        } else {
                            last_year->expenses.tribute = 0;
                        }
                    } else {
                        // city made a profit: tribute is max of: 25% of profit, fixed tribute based on population
                        city_data.finance.tribute_not_paid_total_years = 0;
                        if (city_data.population.population > 5000) {
                            last_year->expenses.tribute = 500;
                        } else if (city_data.population.population > 3000) {
                            last_year->expenses.tribute = 400;
                        } else if (city_data.population.population > 2000) {
                            last_year->expenses.tribute = 300;
                        } else if (city_data.population.population > 1000) {
                            last_year->expenses.tribute = 225;
                        } else if (city_data.population.population > 500) {
                            last_year->expenses.tribute = 150;
                        } else {
                            last_year->expenses.tribute = 50;
                        }
                        int pct_profit = calc_adjust_with_percentage(income - expenses, 25);
                        if (pct_profit > last_year->expenses.tribute) {
                            last_year->expenses.tribute = pct_profit;
                        }
                    }
                    city_data.finance.treasury -= last_year->expenses.tribute;
                    city_data.finance.this_year.expenses.tribute = 0;
                    last_year->balance = city_data.finance.treasury;
                    last_year->income.total = income;
                    last_year->expenses.total = last_year->expenses.tribute + expenses;
                    // reset yearly trade amounts
                    for (int j = 0; j < MAX_EMPIRE_OBJECTS; j++) {
                        if (empire_objects[j].in_use && empire_objects[j].trade_route_open) {
                            for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                empire_objects[j].resource_bought[r] = 0;
                                empire_objects[j].resource_sold[r] = 0;
                            }
                        }
                    }
                    fire_spread_direction = random_data.random1_7bit & 7;
                    city_ratings_update(1);
                    city_data.religion.neptune_double_trade_active = 0;
                } else {
                    city_ratings_update(0);
                }
                refresh_current_window = 1;
                for (int k = 0; k < MAX_EDITOR_CUSTOM_MESSAGES; k++) {
                    if (!scenario.editor_custom_messages[k].enabled) {
                        continue;
                    }
                    if (time_data.year == scenario.editor_custom_messages[k].year_offset + scenario.start_year
                        && time_data.month == scenario.editor_custom_messages[k].month) {
                        city_message_post(1, MESSAGE_EDITOR_1 + k, 0, 0);
                    }
                }
                if (scenario.gladiator_revolt.state) {
                    if (scenario.gladiator_revolt.state == EVENT_NOT_STARTED) {
                        if (time_data.year == scenario.start_year + scenario.gladiator_revolt.year_offset && time_data.month == scenario.gladiator_revolt.month) {
                            if (count_data.buildings[BUILDING_GLADIATOR_SCHOOL].active > 0) {
                                scenario.gladiator_revolt.state = EVENT_IN_PROGRESS;
                                city_message_post(1, MESSAGE_GLADIATOR_REVOLT, 0, 0);
                            } else {
                                scenario.gladiator_revolt.state = EVENT_FINISHED;
                            }
                        }
                    } else if (scenario.gladiator_revolt.state == EVENT_IN_PROGRESS) {
                        if (scenario.gladiator_revolt.month + 3 == time_data.month) {
                            scenario.gladiator_revolt.state = EVENT_FINISHED;
                            city_message_post(1, MESSAGE_GLADIATOR_REVOLT_FINISHED, 0, 0);
                        }
                    }
                }
                for (int k = 0; k < MAX_REQUESTS; k++) {
                    if (!scenario.requests[k].resource || scenario.requests[k].state > REQUEST_STATE_DISPATCHED_LATE) {
                        continue;
                    }
                    if (scenario.requests[k].state == REQUEST_STATE_DISPATCHED || scenario.requests[k].state == REQUEST_STATE_DISPATCHED_LATE) {
                        --scenario.requests[k].months_to_comply;
                        if (scenario.requests[k].months_to_comply <= 0) {
                            if (scenario.requests[k].state == REQUEST_STATE_DISPATCHED) {
                                city_message_post(1, MESSAGE_REQUEST_RECEIVED, k, 0);
                                city_data.ratings.favor = calc_bound(city_data.ratings.favor + scenario.requests[k].favor, 0, 100);
                            } else {
                                city_message_post(1, MESSAGE_REQUEST_RECEIVED_LATE, k, 0);
                                city_data.ratings.favor = calc_bound(city_data.ratings.favor + scenario.requests[k].favor / 2, 0, 100);
                            }
                            scenario.requests[k].state = REQUEST_STATE_RECEIVED;
                            scenario.requests[k].visible = 0;
                        }
                    } else {
                        // normal or overdue
                        if (scenario.requests[k].visible) {
                            --scenario.requests[k].months_to_comply;
                            if (scenario.requests[k].state == REQUEST_STATE_NORMAL) {
                                if (scenario.requests[k].months_to_comply == 12) {
                                    // reminder
                                    city_message_post(1, MESSAGE_REQUEST_REMINDER, k, 0);
                                } else if (scenario.requests[k].months_to_comply <= 0) {
                                    city_message_post(1, MESSAGE_REQUEST_REFUSED, k, 0);
                                    scenario.requests[k].state = REQUEST_STATE_OVERDUE;
                                    scenario.requests[k].months_to_comply = 24;
                                    city_data.ratings.favor = calc_bound(city_data.ratings.favor - 3, 0, 100);
                                    city_data.ratings.favor_ignored_request_penalty = 3;
                                }
                            } else if (scenario.requests[k].state == REQUEST_STATE_OVERDUE) {
                                if (scenario.requests[k].months_to_comply <= 0) {
                                    city_message_post(1, MESSAGE_REQUEST_REFUSED_OVERDUE, k, 0);
                                    scenario.requests[k].state = REQUEST_STATE_IGNORED;
                                    scenario.requests[k].visible = 0;
                                    city_data.ratings.favor = calc_bound(city_data.ratings.favor - 5, 0, 100);
                                    city_data.ratings.favor_ignored_request_penalty = 5;
                                }
                            }
                            if (!scenario.requests[k].can_comply_dialog_shown &&
                                city_data.resource.stored_in_warehouses[scenario.requests[k].resource] >= scenario.requests[k].amount) {
                                scenario.requests[k].can_comply_dialog_shown = 1;
                                city_message_post(1, MESSAGE_REQUEST_CAN_COMPLY, k, 0);
                            }
                        } else {
                            // request is not visible
                            int year = scenario.start_year;
                            if (time_data.year == year + scenario.requests[k].year_offset &&
                                time_data.month == scenario.requests[k].month) {
                                scenario.requests[k].visible = 1;
                                if (city_data.resource.stored_in_warehouses[scenario.requests[k].resource] >= scenario.requests[k].amount) {
                                    scenario.requests[k].can_comply_dialog_shown = 1;
                                }
                                if (scenario.requests[k].resource == RESOURCE_DENARII) {
                                    city_message_post(1, MESSAGE_CAESAR_REQUESTS_MONEY, k, 0);
                                } else if (scenario.requests[k].resource == RESOURCE_TROOPS) {
                                    city_message_post(1, MESSAGE_CAESAR_REQUESTS_ARMY, k, 0);
                                } else {
                                    city_message_post(1, MESSAGE_CAESAR_REQUESTS_GOODS, k, 0);
                                }
                            }
                        }
                    }
                }
                for (int k = 0; k < MAX_PRICE_CHANGES; k++) {
                    if (!scenario.price_changes[k].resource) {
                        continue;
                    }
                    if (time_data.year != scenario.price_changes[k].year_offset + scenario.start_year ||
                        time_data.month != scenario.price_changes[k].month) {
                        continue;
                    }
                    if (scenario.price_changes[k].is_rise) {
                        if (trade_price_change(scenario.price_changes[k].resource, scenario.price_changes[k].amount)) {
                            city_message_post(1, MESSAGE_PRICE_INCREASED, scenario.price_changes[k].amount, scenario.price_changes[k].resource);
                        }
                    } else {
                        if (trade_price_change(scenario.price_changes[k].resource, -scenario.price_changes[k].amount)) {
                            city_message_post(1, MESSAGE_PRICE_DECREASED, scenario.price_changes[k].amount, scenario.price_changes[k].resource);
                        }
                    }
                }
                for (int k = 0; k < MAX_DEMAND_CHANGES; k++) {
                    if (scenario.demand_changes[k].resource && scenario.demand_changes[k].trade_city_id
                        && time_data.year == scenario.demand_changes[k].year_offset + scenario.start_year
                        && time_data.month == scenario.demand_changes[k].month) {
                        struct empire_object_t *trade_city = &empire_objects[scenario.demand_changes[k].trade_city_id];
                        if (trade_city->trade_route_open) {
                            if (scenario.demand_changes[k].is_rise) {
                                if (trade_city->resource_buy_limit[scenario.demand_changes[k].resource]) {
                                    switch (trade_city->resource_buy_limit[scenario.demand_changes[k].resource]) {
                                        case 0:
                                            trade_city->resource_buy_limit[scenario.demand_changes[k].resource] = 15;
                                            city_message_post(1, MESSAGE_INCREASED_TRADING, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        case 15:
                                            trade_city->resource_buy_limit[scenario.demand_changes[k].resource] = 25;
                                            city_message_post(1, MESSAGE_INCREASED_TRADING, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        case 25:
                                            trade_city->resource_buy_limit[scenario.demand_changes[k].resource] = 40;
                                            city_message_post(1, MESSAGE_INCREASED_TRADING, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        default:
                                            break;
                                    }
                                } else if (trade_city->resource_sell_limit[scenario.demand_changes[k].resource]) {
                                    switch (trade_city->resource_sell_limit[scenario.demand_changes[k].resource]) {
                                        case 0:
                                            trade_city->resource_sell_limit[scenario.demand_changes[k].resource] = 15;
                                            city_message_post(1, MESSAGE_INCREASED_TRADING, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        case 15:
                                            trade_city->resource_sell_limit[scenario.demand_changes[k].resource] = 25;
                                            city_message_post(1, MESSAGE_INCREASED_TRADING, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        case 25:
                                            trade_city->resource_sell_limit[scenario.demand_changes[k].resource] = 40;
                                            city_message_post(1, MESSAGE_INCREASED_TRADING, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        default:
                                            break;
                                    }
                                }
                            } else {
                                if (trade_city->resource_buy_limit[scenario.demand_changes[k].resource]) {
                                    switch (trade_city->resource_buy_limit[scenario.demand_changes[k].resource]) {
                                        case 40:
                                            trade_city->resource_buy_limit[scenario.demand_changes[k].resource] = 25;
                                            city_message_post(1, MESSAGE_DECREASED_TRADING, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        case 25:
                                            trade_city->resource_buy_limit[scenario.demand_changes[k].resource] = 15;
                                            city_message_post(1, MESSAGE_DECREASED_TRADING, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        case 15:
                                            trade_city->resource_buy_limit[scenario.demand_changes[k].resource] = 0;
                                            city_message_post(1, MESSAGE_TRADE_STOPPED, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        default:
                                            break;
                                    }
                                }
                                if (trade_city->resource_sell_limit[scenario.demand_changes[k].resource]) {
                                    switch (trade_city->resource_sell_limit[scenario.demand_changes[k].resource]) {
                                        case 40:
                                            trade_city->resource_sell_limit[scenario.demand_changes[k].resource] = 25;
                                            city_message_post(1, MESSAGE_DECREASED_TRADING, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        case 25:
                                            trade_city->resource_sell_limit[scenario.demand_changes[k].resource] = 15;
                                            city_message_post(1, MESSAGE_DECREASED_TRADING, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        case 15:
                                            trade_city->resource_sell_limit[scenario.demand_changes[k].resource] = 0;
                                            city_message_post(1, MESSAGE_TRADE_STOPPED, trade_city->id, scenario.demand_changes[k].resource);
                                            break;
                                        default:
                                            break;
                                    }
                                }
                            }
                        }
                    }
                }
                // handle warnings
                for (int k = 0; k < MAX_INVASIONS; k++) {
                    for (int l = 3; l > 0; l--) {
                        if (scenario.invasions[k].type == INVASION_TYPE_ENEMY_ARMY
                        && (time_data.year == scenario.start_year + scenario.invasions[k].year_offset - l && time_data.month == scenario.invasions[k].month)) {
                            scenario.invasion_upcoming = 1;
                            city_message_post(0, MESSAGE_ENEMIES_AT_THE_DOOR + 1 - l, 0, 0);
                        }
                    }

                }
                // trigger invasions
                for (int k = 0; k < MAX_INVASIONS; k++) {
                    if (time_data.year == scenario.start_year + scenario.invasions[k].year_offset && time_data.month == scenario.invasions[k].month) {
                        // enemy army
                        if (scenario.invasions[k].type == INVASION_TYPE_ENEMY_ARMY) {
                            int grid_offset = start_invasion(
                                scenario.invasions[k].enemy_type,
                                scenario.invasions[k].amount,
                                scenario.invasions[k].from,
                                scenario.invasions[k].target_type);
                            if (grid_offset > 0) {
                                if (scenario.invasions[k].enemy_type) {
                                    city_message_post(1, MESSAGE_ENEMY_ARMY_ATTACK, 0, grid_offset);
                                } else {
                                    city_message_post(1, MESSAGE_BARBARIAN_ATTACK, 0, grid_offset);
                                }
                            }
                        }
                        // editor scheduled invasion by Caesar
                        if (scenario.invasions[k].type == INVASION_TYPE_CAESAR) {
                            int grid_offset = start_invasion(
                                ENEMY_TYPE_CAESAR,
                                scenario.invasions[k].amount,
                                scenario.invasions[k].from,
                                scenario.invasions[k].target_type);
                            if (grid_offset > 0) {
                                city_data.emperor.invasion.from_editor = 1;
                                city_message_post(1, MESSAGE_CAESAR_ARMY_ATTACK, 0, grid_offset);
                            }
                        }
                        // local uprisings
                        if (scenario.invasions[k].type == INVASION_TYPE_LOCAL_UPRISING) {
                            int grid_offset = start_invasion(
                                ENEMY_TYPE_BARBARIAN,
                                scenario.invasions[k].amount,
                                scenario.invasions[k].from,
                                scenario.invasions[k].target_type);
                            if (grid_offset > 0) {
                                city_message_post(1, MESSAGE_LOCAL_UPRISING, 0, grid_offset);
                            }
                        }
                        scenario.invasion_upcoming = 0;
                    }
                }
                for (int k = 0; k < MAX_INVASIONS; k++) {
                    if (scenario.invasions[k].type == INVASION_TYPE_DISTANT_BATTLE
                        && time_data.year == scenario.invasions[k].year_offset + scenario.start_year
                        && time_data.month == scenario.invasions[k].month
                        && scenario.empire.distant_battle_enemy_travel_months > 4
                        && scenario.empire.distant_battle_roman_travel_months > 4
                        && !(city_data.distant_battle.months_until_battle > 0 ||
                            city_data.distant_battle.roman_months_to_travel_back > 0 ||
                            city_data.distant_battle.roman_months_to_travel_forth > 0 ||
                            city_data.distant_battle.city_foreign_months_left > 0)) {
                        distant_battle_army_requested = 1;
                        city_message_post(1, MESSAGE_CAESAR_REQUESTS_ARMY, 0, 0);
                        // init distant battle
                        city_data.distant_battle.enemy_months_traveled = 1;
                        city_data.distant_battle.roman_months_traveled = 1;
                        city_data.distant_battle.months_until_battle = 24;
                        city_data.distant_battle.enemy_strength = scenario.invasions[k].amount;
                        city_data.distant_battle.total_count++;
                        city_data.distant_battle.roman_months_to_travel_back = 0;
                        city_data.distant_battle.roman_months_to_travel_forth = 0;
                    }
                }
                if (city_data.distant_battle.months_until_battle > 0) {
                    --city_data.distant_battle.months_until_battle;
                    if (city_data.distant_battle.months_until_battle > 0) {
                        if (city_data.distant_battle.months_until_battle < scenario.empire.distant_battle_enemy_travel_months) {
                            city_data.distant_battle.enemy_months_traveled =
                                scenario.empire.distant_battle_enemy_travel_months - city_data.distant_battle.months_until_battle + 1;
                        } else {
                            city_data.distant_battle.enemy_months_traveled = 1;
                        }
                        if (city_data.distant_battle.roman_months_to_travel_forth >= 1) {
                            if (scenario.empire.distant_battle_roman_travel_months - city_data.distant_battle.roman_months_traveled >
                                scenario.empire.distant_battle_enemy_travel_months - city_data.distant_battle.enemy_months_traveled) {
                                city_data.distant_battle.roman_months_to_travel_forth -= 2;
                            } else {
                                city_data.distant_battle.roman_months_to_travel_forth--;
                            }
                            if (city_data.distant_battle.roman_months_to_travel_forth <= 1) {
                                city_data.distant_battle.roman_months_to_travel_forth = 1;
                            }
                            city_data.distant_battle.roman_months_traveled =
                                scenario.empire.distant_battle_roman_travel_months - city_data.distant_battle.roman_months_to_travel_forth + 1;
                            if (city_data.distant_battle.roman_months_traveled < 1) {
                                city_data.distant_battle.roman_months_traveled = 1;
                            }
                            if (city_data.distant_battle.roman_months_traveled > scenario.empire.distant_battle_roman_travel_months) {
                                city_data.distant_battle.roman_months_traveled = scenario.empire.distant_battle_roman_travel_months;
                            }
                        }
                    } else {
                        if (city_data.distant_battle.roman_months_to_travel_forth <= 0) {
                            city_message_post(1, MESSAGE_DISTANT_BATTLE_LOST_NO_TROOPS, 0, 0);
                            city_data.ratings.favor = calc_bound(city_data.ratings.favor - 50, 0, 100);
                            set_city_foreign();
                        } else if (city_data.distant_battle.roman_months_to_travel_forth > 2) {
                            city_message_post(1, MESSAGE_DISTANT_BATTLE_LOST_TOO_LATE, 0, 0);
                            city_data.ratings.favor = calc_bound(city_data.ratings.favor - 25, 0, 100);
                            set_city_foreign();
                            city_data.distant_battle.roman_months_to_travel_back = city_data.distant_battle.roman_months_traveled;
                        } else {
                            int player_won;
                            int pct_loss;
                            if (city_data.distant_battle.roman_strength < city_data.distant_battle.enemy_strength) {
                                player_won = 0;
                                pct_loss = 100;
                            } else {
                                player_won = 1;
                                int pct_advantage = calc_percentage(
                                    city_data.distant_battle.roman_strength - city_data.distant_battle.enemy_strength,
                                    city_data.distant_battle.roman_strength);
                                if (pct_advantage < 10) {
                                    pct_loss = 70;
                                } else if (pct_advantage < 25) {
                                    pct_loss = 50;
                                } else if (pct_advantage < 50) {
                                    pct_loss = 25;
                                } else if (pct_advantage < 75) {
                                    pct_loss = 15;
                                } else if (pct_advantage < 100) {
                                    pct_loss = 10;
                                } else if (pct_advantage < 150) {
                                    pct_loss = 5;
                                } else {
                                    pct_loss = 0;
                                }
                            }
                            // apply legion losses
                            for (int k = 0; k < MAX_LEGIONS; k++) {
                                if (legion_formations[k].in_use && legion_formations[k].in_distant_battle) {
                                    struct formation_t *m = &legion_formations[k];
                                    m->morale = calc_bound(m->morale - 75, 0, m->max_morale);
                                    int soldiers_total = 0;
                                    for (int fig = 0; fig < m->num_figures; fig++) {
                                        if (m->figures[fig] > 0) {
                                            struct figure_t *f = &figures[m->figures[fig]];
                                            if (figure_is_alive(f)) {
                                                soldiers_total++;
                                            }
                                        }
                                    }
                                    int soldiers_to_kill = calc_adjust_with_percentage(soldiers_total, pct_loss);
                                    if (soldiers_to_kill >= soldiers_total) {
                                        m->in_distant_battle = 0;
                                    }
                                    for (int fig = 0; fig < m->num_figures; fig++) {
                                        if (m->figures[fig] > 0) {
                                            struct figure_t *f = &figures[m->figures[fig]];
                                            if (figure_is_alive(f)) {
                                                if (soldiers_to_kill) {
                                                    soldiers_to_kill--;
                                                    figure_delete(f);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (player_won) {
                                if (scenario.allowed_buildings[BUILDING_TRIUMPHAL_ARCH]) {
                                    city_message_post(1, MESSAGE_DISTANT_BATTLE_WON, 0, 0);
                                    city_data.building.triumphal_arches_available++;
                                    build_menus[MENU_ADMINISTRATION].is_enabled = 1; // in case every other item in the menu was disabled
                                    build_menus[MENU_ADMINISTRATION].menu_items[10].building_id = BUILDING_TRIUMPHAL_ARCH;
                                } else {
                                    city_message_post(1, MESSAGE_DISTANT_BATTLE_WON_TRIUMPHAL_ARCH_DISABLED, 0, 0);
                                }
                                city_data.ratings.favor = calc_bound(city_data.ratings.favor + 25, 0, 100);
                                city_data.distant_battle.won_count++;
                                city_data.distant_battle.city_foreign_months_left = 0;
                                city_data.distant_battle.roman_months_to_travel_back = city_data.distant_battle.roman_months_traveled;
                            } else {
                                city_message_post(1, MESSAGE_DISTANT_BATTLE_LOST_TOO_WEAK, 0, 0);
                                city_data.ratings.favor = calc_bound(city_data.ratings.favor - 10, 0, 100);
                                set_city_foreign();
                                city_data.distant_battle.roman_months_traveled = 0;
                            }
                        }
                        city_data.distant_battle.months_until_battle = 0;
                        city_data.distant_battle.enemy_months_traveled = 0;
                        city_data.distant_battle.roman_months_to_travel_forth = 0;
                    }
                } else {
                    if (city_data.distant_battle.roman_months_to_travel_back > 0) {
                        city_data.distant_battle.roman_months_to_travel_back--;
                        city_data.distant_battle.roman_months_traveled = city_data.distant_battle.roman_months_to_travel_back;
                        if (city_data.distant_battle.roman_months_to_travel_back <= 0) {
                            if (city_data.distant_battle.city_foreign_months_left) {
                                // soldiers return - not in time
                                city_message_post(1, MESSAGE_TROOPS_RETURN_FAILED, 0, map_grid_offset(scenario.exit_point.x, scenario.exit_point.y));
                            } else {
                                // victorious
                                city_message_post(1, MESSAGE_TROOPS_RETURN_VICTORIOUS, 0, map_grid_offset(scenario.exit_point.x, scenario.exit_point.y));
                            }
                            city_data.distant_battle.roman_months_traveled = 0;
                            // return soldiers
                            for (int l = 0; l < MAX_LEGIONS; l++) {
                                if (legion_formations[l].in_use && legion_formations[l].in_distant_battle) {
                                    legion_formations[l].in_distant_battle = 0;
                                    for (int fig = 0; fig < legion_formations[l].num_figures; fig++) {
                                        if (legion_formations[l].figures[fig] > 0) {
                                            struct figure_t *f = &figures[legion_formations[l].figures[fig]];
                                            if (figure_is_alive(f)) {
                                                f->action_state = FIGURE_ACTION_SOLDIER_RETURNING_FROM_DISTANT_BATTLE;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else if (city_data.distant_battle.city_foreign_months_left > 0) {
                        city_data.distant_battle.city_foreign_months_left--;
                        if (city_data.distant_battle.city_foreign_months_left <= 0) {
                            city_message_post(1, MESSAGE_DISTANT_BATTLE_CITY_RETAKEN, 0, 0);
                            if (city_data.distant_battle.city) {
                                empire_objects[city_data.distant_battle.city].city_type = EMPIRE_CITY_VULNERABLE_ROMAN;
                            }
                        }
                    }
                }
                // record monthly population
                city_data.population.monthly.values[city_data.population.monthly.next_index++] = city_data.population.population;
                if (city_data.population.monthly.next_index >= 2400) {
                    city_data.population.monthly.next_index = 0;
                }
                city_data.population.monthly.count++;
                city_data.festival.months_since_festival++;
                if (city_data.festival.first_festival_effect_months) {
                    --city_data.festival.first_festival_effect_months;
                }
                if (city_data.festival.second_festival_effect_months) {
                    --city_data.festival.second_festival_effect_months;
                }
                // throw festival
                if (city_data.festival.queued) {
                    city_data.festival.months_to_go--;
                    if (city_data.festival.months_to_go <= 0) {
                        if (city_data.festival.first_festival_effect_months <= 0) {
                            city_data.festival.first_festival_effect_months = 12;
                            switch (city_data.festival.size) {
                                case FESTIVAL_SMALL: city_sentiment_change_happiness(7); break;
                                case FESTIVAL_LARGE: city_sentiment_change_happiness(9); break;
                                case FESTIVAL_GRAND: city_sentiment_change_happiness(12); break;
                            }
                        } else if (city_data.festival.second_festival_effect_months <= 0) {
                            city_data.festival.second_festival_effect_months = 12;
                            switch (city_data.festival.size) {
                                case FESTIVAL_SMALL: city_sentiment_change_happiness(2); break;
                                case FESTIVAL_LARGE: city_sentiment_change_happiness(3); break;
                                case FESTIVAL_GRAND: city_sentiment_change_happiness(5); break;
                            }
                        }
                        city_data.festival.months_since_festival = 1;
                        city_data.religion.gods[city_data.festival.god].months_since_festival = 0;
                        switch (city_data.festival.size) {
                            case FESTIVAL_SMALL: city_message_post(1, MESSAGE_SMALL_FESTIVAL, 0, 0); break;
                            case FESTIVAL_LARGE: city_message_post(1, MESSAGE_LARGE_FESTIVAL, 0, 0); break;
                            case FESTIVAL_GRAND: city_message_post(1, MESSAGE_GRAND_FESTIVAL, 0, 0); break;
                        }
                        city_data.festival.queued = 0;
                        city_data.festival.months_to_go = 0;
                    }
                }
                if (configs[CONFIG_MONTHLY_AUTOSAVE].config_value) {
                    game_file_io_write_saved_game(SAVES_DIR_PATH, "autosave.sav");
                }
            }
            if (time_data.day == 0 || time_data.day == 8) {
                city_sentiment_update();
            }
        }
        for (int k = 0; k < MAX_EARTHQUAKES; k++) {
            if (scenario.earthquakes[k].state && scenario.earthquakes[k].branch_coordinates[0].x > -1 && scenario.earthquakes[k].branch_coordinates[0].y > -1) {
                if (scenario.earthquakes[k].state == EVENT_NOT_STARTED) {
                    if (scenario.start_year + scenario.earthquakes[k].year_offset == time_data.year && scenario.earthquakes[k].month == time_data.month) {
                        scenario.earthquakes[k].state = EVENT_IN_PROGRESS;
                        city_message_post(1, MESSAGE_EARTHQUAKE, 0, map_grid_offset(scenario.earthquakes[k].branch_coordinates[0].x, scenario.earthquakes[k].branch_coordinates[1].y));
                    }
                } else if (scenario.earthquakes[k].state == EVENT_IN_PROGRESS) {
                    scenario.earthquakes[k].delay++;
                    if (scenario.earthquakes[k].delay >= scenario.earthquakes[k].max_delay) {
                        scenario.earthquakes[k].delay = 0;
                        scenario.earthquakes[k].duration++;
                        if (scenario.earthquakes[k].duration >= scenario.earthquakes[k].max_duration) {
                            scenario.earthquakes[k].state = EVENT_FINISHED;
                        }
                        int index = rand() % 4;
                        int dx = 0;
                        int dy = 0;
                        switch (index) {
                            case 0:
                                // ~north
                                dx = rand() % 3 - 1;
                                dy = dx ? 0 : -1;
                                break;
                            case 1:
                                // ~east
                                dy = rand() % 3 - 1;
                                dx = dy ? 0 : 1;
                                break;
                            case 2:
                                // ~south
                                dx = rand() % 3 - 1;
                                dy = dx ? 0 : 1;
                                break;
                            case 3:
                                // ~west
                                dy = rand() % 3 - 1;
                                dx = dy ? 0 : -1;
                                break;
                            default:
                                break;
                        }
                        int x = calc_bound(scenario.earthquakes[k].branch_coordinates[index].x + dx, 0, scenario.map.width - 1);
                        int y = calc_bound(scenario.earthquakes[k].branch_coordinates[index].y + dy, 0, scenario.map.height - 1);
                        if (!map_terrain_is(map_grid_offset(x, y), TERRAIN_ELEVATION | TERRAIN_ROCK | TERRAIN_WATER)) {
                            scenario.earthquakes[k].branch_coordinates[index].x = x;
                            scenario.earthquakes[k].branch_coordinates[index].y = y;
                            // advance_earthquake_to_tile(x, y);
                            // advance earthquake to tile
                            int grid_offset = map_grid_offset(x, y);
                            int building_id = map_building_at(grid_offset);
                            if (building_id) {
                                building_destroy_by_collapse(&all_buildings[building_id]);
                                int ruin_id = map_building_at(grid_offset);
                                if (ruin_id) {
                                    all_buildings[ruin_id].state = BUILDING_STATE_DELETED_BY_GAME;
                                    buildings_grid.items[grid_offset] = 0;
                                }
                            }
                            terrain_grid.items[grid_offset] = 0;
                            // earthquake: terrain = rock && bitfields = plaza
                            terrain_grid.items[grid_offset] |= TERRAIN_ROCK;
                            bitfields_grid.items[grid_offset] |= BIT_PLAZA_OR_EARTHQUAKE;

                            foreach_region_tile(x - 1, y - 1, x + 1, y + 1, set_earthquake_image);
                            map_tiles_update_all_gardens();
                            map_tiles_update_all_roads();
                            map_tiles_update_all_plazas();
                            map_routing_update_land();
                            map_routing_update_walls();
                            play_sound_effect(SOUND_EFFECT_EXPLOSION);
                            figure_create_explosion_cloud(x, y, 1);
                        }
                    }
                }
            }
        }
        if ((scenario.time_limit_win_criteria && (time_data.year >= scenario.start_year + scenario.time_limit_win_criteria))
        || (city_figures_total_invading_enemies() > 2 + city_data.figure.soldiers && city_data.population.population < city_data.population.highest_ever / 4)
        || (city_figures_total_invading_enemies() > 0 && !city_data.population.population)
        ) {
            show_defeat_message();
        } else if ((scenario.survival_time_win_criteria && time_data.year > scenario.start_year + scenario.survival_time_win_criteria)
        || (city_data.population.population >= scenario.population_win_criteria
            && city_data.ratings.culture >= scenario.culture_win_criteria
            && city_data.ratings.prosperity >= scenario.prosperity_win_criteria
            && city_data.ratings.peace >= scenario.peace_win_criteria
            && city_data.ratings.favor >= scenario.favor_win_criteria)) {
            change_window(WINDOW_VICTORY_DIALOG);
        }
        city_data.entertainment.hippodrome_has_race = 0;
        for (int j = 1; j < MAX_FIGURES; j++) {
            struct figure_t *f = &figures[j];
            if (f->is_corpse) {
                if (f->wait_ticks < 0) {
                    f->wait_ticks = 0;
                }
                f->wait_ticks++;
                if (f->wait_ticks >= 128) {
                    f->wait_ticks = 127;
                    figure_delete(f);
                    break;
                }
                switch (f->type) {
                    case FIGURE_IMMIGRANT:
                    case FIGURE_EMIGRANT:
                    case FIGURE_CHARIOTEER: // corpse images missing for charioteer, assign migrant ones
                    case FIGURE_TRADE_CARAVAN:
                    case FIGURE_TRADE_CARAVAN_DONKEY:
                        f->image_id = 4442 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;  // corpse images missing for trade caravan, assign migrant ones
                        break;
                    case FIGURE_HOMELESS:
                        f->image_id = 6489 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_PATRICIAN:
                        f->image_id = 7321 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_CART_PUSHER:
                    case FIGURE_DOCKER:
                    case FIGURE_WAREHOUSEMAN:
                    case FIGURE_NATIVE_TRADER:
                        f->image_id = 4338 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        f->cart_image_id = 0;
                        break;
                    case FIGURE_LABOR_SEEKER:
                        f->image_id = 3410 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_BARBER:
                        f->image_id = 6041 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_BATHHOUSE_WORKER:
                        f->image_id = 3514 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_DOCTOR:
                    case FIGURE_SURGEON:
                        f->image_id = 7425 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_PRIEST:
                        f->image_id = 3618 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_SCHOOL_CHILD:
                        f->image_id = 4130 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_TEACHER:
                    case FIGURE_LIBRARIAN:
                        f->image_id = 7633 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_MISSIONARY:
                        f->image_id = 7529 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_ACTOR:
                        f->image_id = 3722 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_GLADIATOR:
                    case FIGURE_ENEMY_GLADIATOR:
                        f->image_id = 5579 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_LION_TAMER:
                        f->image_id = 3826 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        f->cart_image_id = 0;
                        break;
                    case FIGURE_TAX_COLLECTOR:
                        f->image_id = 4026 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_ENGINEER:
                        f->image_id = 4546 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_TOWER_SENTRY:
                        f->image_id = 6705 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 136;
                        break;
                    case FIGURE_PREFECT:
                        f->image_id = 6193 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_FORT_JAVELIN:
                        f->image_id = 6849 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 144;
                        break;
                    case FIGURE_FORT_MOUNTED:
                        f->image_id = 8376 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 144;
                        break;
                    case FIGURE_FORT_LEGIONARY:
                        f->image_id = 7161 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 152;
                        break;
                    case FIGURE_MARKET_BUYER:
                    case FIGURE_MARKET_TRADER:
                        f->image_id = 4234 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_DELIVERY_BOY:
                        f->image_id = 5018 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_PROTESTER:
                    case FIGURE_CRIMINAL:
                    case FIGURE_RIOTER:
                        f->image_id = 5929 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_INDIGENOUS_NATIVE:
                    case FIGURE_ENEMY_BARBARIAN_SWORDSMAN:
                        f->image_id = 441 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2];
                        break;
                    case FIGURE_WOLF:
                        f->image_id = 8640 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_SHEEP:
                        f->image_id = 8528 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 104;
                        break;
                    case FIGURE_ZEBRA:
                        f->image_id = 8800 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2] + 96;
                        break;
                    case FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN:
                    case FIGURE_ENEMY_BRITON_SWORDSMAN:
                    case FIGURE_ENEMY_CELT_SWORDSMAN:
                    case FIGURE_ENEMY_PICT_SWORDSMAN:
                    case FIGURE_ENEMY_EGYPTIAN_SWORDSMAN:
                    case FIGURE_ENEMY_ETRUSCAN_SWORDSMAN:
                    case FIGURE_ENEMY_SAMNITE_SWORDSMAN:
                    case FIGURE_ENEMY_GAUL_SWORDSMAN:
                    case FIGURE_ENEMY_HELVETIUS_SWORDSMAN:
                    case FIGURE_ENEMY_HUN_SWORDSMAN:
                    case FIGURE_ENEMY_GOTH_SWORDSMAN:
                    case FIGURE_ENEMY_VISIGOTH_SWORDSMAN:
                    case FIGURE_ENEMY_GREEK_SWORDSMAN:
                    case FIGURE_ENEMY_MACEDONIAN_SWORDSMAN:
                    case FIGURE_ENEMY_IBERIAN_SWORDSMAN:
                    case FIGURE_ENEMY_PERGAMUM_SWORDSMAN:
                    case FIGURE_ENEMY_JUDEAN_SWORDSMAN:
                    case FIGURE_ENEMY_SELEUCID_SWORDSMAN:
                        f->image_id = 593 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2];
                        break;
                    case FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT:
                        f->image_id = 705 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2];
                        break;
                    case FIGURE_ENEMY_BRITON_CHARIOT:
                    case FIGURE_ENEMY_CELT_CHARIOT:
                    case FIGURE_ENEMY_PICT_CHARIOT:
                    case FIGURE_ENEMY_EGYPTIAN_CAMEL:
                    case FIGURE_ENEMY_GAUL_AXEMAN:
                    case FIGURE_ENEMY_HELVETIUS_AXEMAN:
                    case FIGURE_ENEMY_HUN_MOUNTED_ARCHER:
                    case FIGURE_ENEMY_GOTH_MOUNTED_ARCHER:
                    case FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER:
                        f->image_id = 745 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2];
                        break;
                    case FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_SAMNITE_SPEAR_THROWER:
                    case FIGURE_ENEMY_GREEK_SPEAR_THROWER:
                    case FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_PERGAMUM_ARCHER:
                    case FIGURE_ENEMY_IBERIAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_JUDEAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_SELEUCID_SPEAR_THROWER:
                        f->image_id = 793 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2];
                        break;
                    case FIGURE_ENEMY_NUMIDIAN_SWORDSMAN:
                    case FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER:
                        f->image_id = 641 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2];
                        break;
                    case FIGURE_ENEMY_CAESAR_JAVELIN:
                    case FIGURE_ENEMY_CAESAR_MOUNTED:
                    case FIGURE_ENEMY_CAESAR_LEGIONARY:
                        f->image_id = 7153 + CORPSE_IMAGE_OFFSETS[f->wait_ticks / 2];
                        break;
                }
                continue;
            } else if (f->engaged_in_combat) {
                if (f->progress_on_tile <= 5) {
                    f->progress_on_tile++;
                    advance_tick_movement(f);
                }
                f->attack_image_offset++;
                if (f->target_figure_id) {
                    struct figure_t *opponent = &figures[f->target_figure_id];
                    if (f->attack_image_offset >= 24 || unit_is_charging_opponent(f, opponent)) {
                        if (figure_properties[opponent->type].is_unarmed_civilian_unit || figure_properties[opponent->type].is_criminal_unit) {
                            f->attack_image_offset = 12;
                        } else {
                            f->attack_image_offset = 0;
                        }
                        int attacker_attack_value = figure_properties[f->type].melee_attack_value;
                        int opponent_defense_value = figure_properties[opponent->type].melee_defense_value;
                        int deg_abs_delta = abs(f->attack_direction * 45 - opponent->attack_direction * 45);
                        switch (deg_abs_delta) {
                            case 0:
                            case 45:
                            case 315:
                                attacker_attack_value *= 2;
                                opponent_defense_value = 0;
                                play_sound_effect(SOUND_EFFECT_SWORD_SWING);
                                break;
                            case 90:
                            case 270:
                                attacker_attack_value += 2;
                                opponent_defense_value /= 2;
                                break;
                            default:
                                break;
                        }
                        int net_attack = attacker_attack_value - opponent_defense_value;
                        if (net_attack < 0) {
                            net_attack = 0;
                        }
                        opponent->damage += net_attack;
                        if (opponent->damage <= figure_properties[opponent->type].max_damage) {
                            switch (f->type) {
                                case FIGURE_LION_TAMER:
                                    play_sound_effect(SOUND_EFFECT_LION_ATTACK);
                                    break;
                                case FIGURE_WOLF:
                                    play_sound_effect(SOUND_EFFECT_WOLF_ATTACK);
                                    break;
                                case FIGURE_FORT_LEGIONARY:
                                case FIGURE_ENEMY_CAESAR_LEGIONARY:
                                    play_sound_effect(SOUND_EFFECT_SWORD);
                                    break;
                                case FIGURE_FORT_JAVELIN:
                                case FIGURE_FORT_MOUNTED:
                                case FIGURE_ENEMY_GLADIATOR:
                                case FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN:
                                case FIGURE_ENEMY_ETRUSCAN_SWORDSMAN:
                                case FIGURE_ENEMY_SAMNITE_SWORDSMAN:
                                case FIGURE_ENEMY_GREEK_SWORDSMAN:
                                case FIGURE_ENEMY_MACEDONIAN_SWORDSMAN:
                                case FIGURE_ENEMY_BRITON_CHARIOT:
                                case FIGURE_ENEMY_CELT_CHARIOT:
                                case FIGURE_ENEMY_PICT_CHARIOT:
                                case FIGURE_ENEMY_BRITON_SWORDSMAN:
                                case FIGURE_ENEMY_CELT_SWORDSMAN:
                                case FIGURE_ENEMY_PICT_SWORDSMAN:
                                case FIGURE_ENEMY_GAUL_SWORDSMAN:
                                case FIGURE_ENEMY_HELVETIUS_SWORDSMAN:
                                case FIGURE_ENEMY_HUN_MOUNTED_ARCHER:
                                case FIGURE_ENEMY_GOTH_MOUNTED_ARCHER:
                                case FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER:
                                    play_sound_effect(SOUND_EFFECT_LIGHT_SWORD);
                                    break;
                                case FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER:
                                case FIGURE_ENEMY_SAMNITE_SPEAR_THROWER:
                                case FIGURE_ENEMY_GREEK_SPEAR_THROWER:
                                case FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER:
                                case FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER:
                                case FIGURE_ENEMY_IBERIAN_SPEAR_THROWER:
                                case FIGURE_ENEMY_JUDEAN_SPEAR_THROWER:
                                case FIGURE_ENEMY_SELEUCID_SPEAR_THROWER:
                                    play_sound_effect(SOUND_EFFECT_SPEAR);
                                    break;
                                case FIGURE_ENEMY_EGYPTIAN_SWORDSMAN:
                                case FIGURE_ENEMY_PERGAMUM_SWORDSMAN:
                                case FIGURE_ENEMY_IBERIAN_SWORDSMAN:
                                case FIGURE_ENEMY_JUDEAN_SWORDSMAN:
                                case FIGURE_ENEMY_SELEUCID_SWORDSMAN:
                                case FIGURE_ENEMY_BARBARIAN_SWORDSMAN:
                                case FIGURE_ENEMY_HUN_SWORDSMAN:
                                case FIGURE_ENEMY_GOTH_SWORDSMAN:
                                case FIGURE_ENEMY_VISIGOTH_SWORDSMAN:
                                case FIGURE_ENEMY_NUMIDIAN_SWORDSMAN:
                                    play_sound_effect(SOUND_EFFECT_CLUB);
                                    break;
                                case FIGURE_ENEMY_GAUL_AXEMAN:
                                case FIGURE_ENEMY_HELVETIUS_AXEMAN:
                                    play_sound_effect(SOUND_EFFECT_AXE);
                                    break;
                                case FIGURE_ENEMY_EGYPTIAN_CAMEL:
                                    play_sound_effect(SOUND_EFFECT_CAMEL);
                                    break;
                                case FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT:
                                    city_data.sound.hit_elephant = !city_data.sound.hit_elephant;
                                    if (city_data.sound.hit_elephant) {
                                        play_sound_effect(SOUND_EFFECT_ELEPHANT);
                                    } else {
                                        play_sound_effect(SOUND_EFFECT_ELEPHANT_HIT);
                                    }
                                    break;
                                default:
                                    break;
                            }
                        } else {
                            opponent->is_corpse = 1;
                            opponent->is_targetable = 0;
                            opponent->wait_ticks = 0;
                            figure_play_die_sound(opponent);
                            if (figure_properties[opponent->type].is_player_legion_unit) {
                                update_formation_morale_after_death(&legion_formations[opponent->formation_id]);
                            } else {
                                update_formation_morale_after_death(&enemy_formations[opponent->formation_id]);
                            }
                            clear_targeting_on_unit_death(opponent);
                        }
                        if (unit_is_charging_opponent(f, opponent)) {
                            play_sound_effect(SOUND_EFFECT_HORSE_MOVING);
                            f->mounted_charge_ticks--;
                        }
                        if (figure_properties[opponent->type].is_player_legion_unit) {
                            legion_formations[opponent->formation_id].recent_fight = 6;
                        } else if (figure_properties[opponent->type].is_enemy_unit || figure_properties[opponent->type].is_caesar_legion_unit) {
                            enemy_formations[opponent->formation_id].recent_fight = 6;
                        }
                    }
                } else {
                    f->engaged_in_combat = 0;
                    figure_route_remove(f);
                }
                figure_image_increase_offset(f, 12);
                int dir = get_direction(f);
                switch (f->type) {
                    case FIGURE_GLADIATOR:
                    case FIGURE_ENEMY_GLADIATOR:
                        f->image_id = 5579 + dir + 104 + 8 * (f->image_offset / 2);
                        break;
                    case FIGURE_LION_TAMER:
                        f->image_id = 3826 + dir + 8 * f->image_offset;
                        break;
                    case FIGURE_TOWER_SENTRY:
                        if (f->attack_image_offset < 12) {
                            f->image_id = 6801 + figure_image_direction(f);
                        } else {
                            f->image_id = 6801 + figure_image_direction(f) + 8 * ((f->attack_image_offset - 12) / 2);
                            // some buffer images missing, img ids 6841+ are for corpse
                            if (f->image_id >= 6841) {
                                f->image_id = f->image_id - 8;
                            }
                        }
                        break;
                    case FIGURE_PREFECT:
                        if (f->attack_image_offset >= 12) {
                            f->image_id = 6297 + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        } else {
                            f->image_id = 6297 + dir;
                        }
                        break;
                    case FIGURE_FORT_JAVELIN:
                        if (f->attack_image_offset < 12) {
                            f->image_id = 6945 + dir;
                        } else {
                            f->image_id = 6945 + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        }
                        break;
                    case FIGURE_FORT_MOUNTED:
                        if (f->attack_image_offset < 12) {
                            f->image_id = 8472 + dir;
                        } else {
                            f->image_id = 8472 + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        }
                        break;
                    case FIGURE_FORT_LEGIONARY:
                        if (f->attack_image_offset < 12) {
                            f->image_id = 7161 + 96 + f->attack_direction;
                        } else {
                            f->image_id = 7161 + 96 + f->attack_direction + 8 * ((f->attack_image_offset - 12) / 2);
                        }
                        break;
                    case FIGURE_INDIGENOUS_NATIVE:
                    case FIGURE_ENEMY_BARBARIAN_SWORDSMAN:
                        if (f->attack_image_offset >= 12) {
                            f->image_id = 393 + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        } else {
                            f->image_id = 393 + dir;
                        }
                        break;
                    case FIGURE_WOLF:
                        f->image_id = 8744 + dir + 8 * (f->attack_image_offset / 4);
                        break;
                    case FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN:
                    case FIGURE_ENEMY_BRITON_SWORDSMAN:
                    case FIGURE_ENEMY_CELT_SWORDSMAN:
                    case FIGURE_ENEMY_PICT_SWORDSMAN:
                    case FIGURE_ENEMY_EGYPTIAN_SWORDSMAN:
                    case FIGURE_ENEMY_ETRUSCAN_SWORDSMAN:
                    case FIGURE_ENEMY_SAMNITE_SWORDSMAN:
                    case FIGURE_ENEMY_GAUL_SWORDSMAN:
                    case FIGURE_ENEMY_HELVETIUS_SWORDSMAN:
                    case FIGURE_ENEMY_GREEK_SWORDSMAN:
                    case FIGURE_ENEMY_MACEDONIAN_SWORDSMAN:
                    case FIGURE_ENEMY_PERGAMUM_SWORDSMAN:
                    case FIGURE_ENEMY_IBERIAN_SWORDSMAN:
                    case FIGURE_ENEMY_JUDEAN_SWORDSMAN:
                    case FIGURE_ENEMY_SELEUCID_SWORDSMAN:
                        if (f->attack_image_offset >= 12) {
                            f->image_id = 545 + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        } else {
                            f->image_id = 545 + dir;
                        }
                        break;
                    case FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT:
                    case FIGURE_ENEMY_EGYPTIAN_CAMEL:
                    case FIGURE_ENEMY_HUN_MOUNTED_ARCHER:
                    case FIGURE_ENEMY_GOTH_MOUNTED_ARCHER:
                    case FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER:
                        f->image_id = 601 + dir + 8 * f->image_offset;
                        break;
                    case FIGURE_ENEMY_BRITON_CHARIOT:
                    case FIGURE_ENEMY_CELT_CHARIOT:
                    case FIGURE_ENEMY_PICT_CHARIOT:
                        f->image_id = 697 + dir + 8 * (f->image_offset / 2);
                        break;
                    case FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_SAMNITE_SPEAR_THROWER:
                    case FIGURE_ENEMY_GREEK_SPEAR_THROWER:
                    case FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_PERGAMUM_ARCHER:
                    case FIGURE_ENEMY_IBERIAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_JUDEAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_SELEUCID_SPEAR_THROWER:
                        if (f->attack_image_offset >= 12) {
                            f->image_id = 745 + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        } else {
                            f->image_id = 745 + dir;
                        }
                        break;
                    case FIGURE_ENEMY_GAUL_AXEMAN:
                    case FIGURE_ENEMY_HELVETIUS_AXEMAN:
                        if (f->attack_image_offset >= 12) {
                            f->image_id = 697 + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        } else {
                            f->image_id = 697 + dir;
                        }
                        break;
                    case FIGURE_ENEMY_HUN_SWORDSMAN:
                    case FIGURE_ENEMY_GOTH_SWORDSMAN:
                    case FIGURE_ENEMY_VISIGOTH_SWORDSMAN:
                        if (f->attack_image_offset >= 12) {
                            f->image_id = 545 + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        } else {
                            f->image_id = 545 + dir;
                        }
                        break;
                    case FIGURE_ENEMY_NUMIDIAN_SWORDSMAN:
                    case FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER:
                        if (f->attack_image_offset >= 12) {
                            f->image_id = 593 + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        } else {
                            f->image_id = 593 + dir;
                        }
                        break;
                    case FIGURE_ENEMY_CAESAR_LEGIONARY:
                        if (f->attack_image_offset >= 12) {
                            f->image_id = 7001 + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        } else {
                            f->image_id = 7001 + dir;
                        }
                        break;
                }
                continue;
            } else if (f->is_fleeing) {
                rout_unit(f);
                continue;
            }
            if (f->in_use) {
                switch (f->type) {
                    case FIGURE_IMMIGRANT:
                    {
                        struct building_t *b = &all_buildings[f->immigrant_building_id];
                        f->cart_image_id = 0;
                        if (b->state != BUILDING_STATE_IN_USE || b->immigrant_figure_id != f->id || !b->house_size) {
                            figure_delete(f);
                            return;
                        }
                        switch (f->action_state) {
                            case FIGURE_ACTION_IMMIGRANT_CREATED:
                                f->is_invisible = 1;
                                f->wait_ticks--;
                                if (f->wait_ticks <= 0) {
                                    int x_road, y_road;
                                    if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                        f->action_state = FIGURE_ACTION_IMMIGRANT_ARRIVING;
                                        f->destination_x = x_road;
                                        f->destination_y = y_road;
                                        f->roam_length = 0;
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_IMMIGRANT_ARRIVING:
                                f->is_invisible = 0;
                                walk_ticks(f, 1, 0);
                                switch (f->direction) {
                                    case DIR_FIGURE_AT_DESTINATION:
                                        f->action_state = FIGURE_ACTION_IMMIGRANT_ENTERING_HOUSE;
                                        figure_movement_set_cross_country_destination(f, b->x, b->y);
                                        f->roam_length = 0;
                                        break;
                                    case DIR_FIGURE_REROUTE:
                                        figure_route_remove(f);
                                        break;
                                    case DIR_FIGURE_LOST:
                                        b->immigrant_figure_id = 0;
                                        figure_delete(f);
                                        return;
                                }
                                break;
                            case FIGURE_ACTION_IMMIGRANT_ENTERING_HOUSE:
                                f->use_cross_country = 1;
                                f->is_invisible = 1;
                                if (figure_movement_move_ticks_cross_country(f, 1) == 1) {
                                    int max_people = house_properties[b->subtype.house_level].max_people;
                                    if (b->house_is_merged) {
                                        max_people *= 4;
                                    }
                                    int room = max_people - b->house_population;
                                    if (room < 0) {
                                        room = 0;
                                    }
                                    if (room < f->migrant_num_people) {
                                        f->migrant_num_people = room;
                                    }
                                    if (!b->house_population) {
                                        building_house_change_to(b, BUILDING_HOUSE_SMALL_TENT);
                                    }
                                    b->house_population += f->migrant_num_people;
                                    b->house_population_room = max_people - b->house_population;
                                    city_data.population.last_change = f->migrant_num_people;
                                    add_to_census(f->migrant_num_people);
                                    recalculate_population();
                                    b->immigrant_figure_id = 0;
                                    figure_delete(f);
                                    return;
                                }
                                f->is_invisible = f->in_building_wait_ticks ? 1 : 0;
                                break;
                        }
                        update_migrant_dir_and_image(f);
                    }
                    break;
                    case FIGURE_EMIGRANT:
                        f->cart_image_id = 0;
                        switch (f->action_state) {
                            case FIGURE_ACTION_EMIGRANT_CREATED:
                                f->is_invisible = 1;
                                f->wait_ticks++;
                                if (f->wait_ticks >= 5) {
                                    int x_road, y_road;
                                    if (!map_closest_road_within_radius(f->x, f->y, 1, 5, &x_road, &y_road)) {
                                        figure_delete(f);
                                        return;
                                    }
                                    f->action_state = FIGURE_ACTION_EMIGRANT_EXITING_HOUSE;
                                    figure_movement_set_cross_country_destination(f, x_road, y_road);
                                    f->roam_length = 0;
                                }
                                break;
                            case FIGURE_ACTION_EMIGRANT_EXITING_HOUSE:
                                f->use_cross_country = 1;
                                f->is_invisible = 1;
                                if (figure_movement_move_ticks_cross_country(f, 1) == 1) {
                                    f->action_state = FIGURE_ACTION_EMIGRANT_LEAVING;
                                    f->destination_x = scenario.entry_point.x;
                                    f->destination_y = scenario.entry_point.y;
                                    f->roam_length = 0;
                                    f->progress_on_tile = 15;
                                }
                                f->is_invisible = f->in_building_wait_ticks ? 1 : 0;
                                break;
                            case FIGURE_ACTION_EMIGRANT_LEAVING:
                                f->use_cross_country = 0;
                                f->is_invisible = 0;
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION ||
                                    f->direction == DIR_FIGURE_REROUTE ||
                                    f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                        }
                        update_migrant_dir_and_image(f);
                        break;
                    case FIGURE_HOMELESS:
                        switch (f->action_state) {
                            case FIGURE_ACTION_HOMELESS_CREATED:
                                f->image_offset = 0;
                                f->wait_ticks++;
                                if (f->wait_ticks > 51) {
                                    int building_id = closest_house_with_room(f->x, f->y);
                                    if (building_id) {
                                        struct building_t *b = &all_buildings[building_id];
                                        int x_road, y_road;
                                        if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                            b->immigrant_figure_id = f->id;
                                            f->immigrant_building_id = building_id;
                                            f->action_state = FIGURE_ACTION_HOMELESS_GOING_TO_HOUSE;
                                            f->destination_x = x_road;
                                            f->destination_y = y_road;
                                            f->roam_length = 0;
                                        } else {
                                            figure_delete(f);
                                            return;
                                        }
                                    } else {
                                        f->action_state = FIGURE_ACTION_HOMELESS_LEAVING;
                                        f->destination_x = scenario.exit_point.x;
                                        f->destination_y = scenario.exit_point.y;
                                        f->roam_length = 0;
                                        f->wait_ticks = 0;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_HOMELESS_GOING_TO_HOUSE:
                                f->is_invisible = 0;
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                    all_buildings[f->immigrant_building_id].immigrant_figure_id = 0;
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    struct building_t *b = &all_buildings[f->immigrant_building_id];
                                    f->action_state = FIGURE_ACTION_HOMELESS_ENTERING_HOUSE;
                                    figure_movement_set_cross_country_destination(f, b->x, b->y);
                                    f->roam_length = 0;
                                }
                                break;
                            case FIGURE_ACTION_HOMELESS_ENTERING_HOUSE:
                                f->use_cross_country = 1;
                                f->is_invisible = 1;
                                if (figure_movement_move_ticks_cross_country(f, 1) == 1) {
                                    struct building_t *b = &all_buildings[f->immigrant_building_id];
                                    if (f->immigrant_building_id && building_is_house(b->type)) {
                                        int max_people = house_properties[b->subtype.house_level].max_people;
                                        if (b->house_is_merged) {
                                            max_people *= 4;
                                        }
                                        int room = max_people - b->house_population;
                                        if (room < 0) {
                                            room = 0;
                                        }
                                        if (room < f->migrant_num_people) {
                                            f->migrant_num_people = room;
                                        }
                                        if (!b->house_population) {
                                            building_house_change_to(b, BUILDING_HOUSE_SMALL_TENT);
                                        }
                                        b->house_population += f->migrant_num_people;
                                        b->house_population_room = max_people - b->house_population;
                                        city_data.population.lost_homeless -= f->migrant_num_people;
                                        add_to_census(f->migrant_num_people);
                                        recalculate_population();
                                        b->immigrant_figure_id = 0;
                                    }
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_HOMELESS_LEAVING:
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                }
                                f->wait_ticks++;
                                if (f->wait_ticks > 30) {
                                    f->wait_ticks = 0;
                                    int building_id = closest_house_with_room(f->x, f->y);
                                    if (building_id > 0) {
                                        struct building_t *b = &all_buildings[building_id];
                                        int x_road, y_road;
                                        if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                            b->immigrant_figure_id = f->id;
                                            f->immigrant_building_id = building_id;
                                            f->action_state = FIGURE_ACTION_HOMELESS_GOING_TO_HOUSE;
                                            f->destination_x = x_road;
                                            f->destination_y = y_road;
                                            f->roam_length = 0;
                                            figure_route_remove(f);
                                        }
                                    }
                                }
                                break;
                        }
                        figure_image_increase_offset(f, 12);
                        f->image_id = 6489 + figure_image_direction(f) + 8 * f->image_offset;
                        break;
                    case FIGURE_PATRICIAN:
                        if (all_buildings[f->building_id].state != BUILDING_STATE_IN_USE) {
                            figure_delete(f);
                            return;
                        }
                        roamer_action(f, 1);
                        figure_image_increase_offset(f, 12);
                        f->image_id = 7321 + figure_image_direction(f) + 8 * f->image_offset;
                        break;
                    case FIGURE_CART_PUSHER:
                    {
                        f->cart_image_id = 0;
                        struct building_t *b = &all_buildings[f->building_id];
                        switch (f->action_state) {
                            case FIGURE_ACTION_CARTPUSHER_INITIAL:
                                set_cart_graphic(f);
                                if (!map_routing_citizen_is_passable(f->grid_offset)) {
                                    figure_delete(f);
                                    return;
                                }
                                if (b->state != BUILDING_STATE_IN_USE || b->figure_id != f->id) {
                                    figure_delete(f);
                                    return;
                                }
                                f->wait_ticks++;
                                if (f->wait_ticks > 30) {
                                    struct map_point_t dst;
                                    int understaffed_storages = 0;
                                    // priority 1: warehouse if resource is on stockpile
                                    int dst_building_id = building_warehouse_for_storing(0, f->x, f->y, b->output_resource_id, &understaffed_storages, &dst);
                                    if (!city_data.resource.stockpiled[b->output_resource_id]) {
                                        dst_building_id = 0;
                                    }
                                    if (dst_building_id) {
                                        set_destination(f, FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_WAREHOUSE, dst_building_id, dst.x, dst.y);
                                    } else {
                                        // priority 2: accepting granary for food
                                        dst_building_id = building_granary_for_storing(f->x, f->y, b->output_resource_id, 0, &understaffed_storages, &dst);
                                        if (dst_building_id) {
                                            set_destination(f, FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_GRANARY, dst_building_id, dst.x, dst.y);
                                        } else {
                                            // priority 3: workshop for raw material
                                            dst_building_id = building_get_workshop_for_raw_material_with_room(f->x, f->y, b->output_resource_id, &dst);
                                            if (dst_building_id) {
                                                set_destination(f, FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_WORKSHOP, dst_building_id, dst.x, dst.y);
                                            } else {
                                                // priority 4: warehouse
                                                dst_building_id = building_warehouse_for_storing(0, f->x, f->y, b->output_resource_id, &understaffed_storages, &dst);
                                                if (dst_building_id) {
                                                    set_destination(f, FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_WAREHOUSE, dst_building_id, dst.x, dst.y);
                                                } else {
                                                    // priority 5: granary forced when on stockpile
                                                    dst_building_id = building_granary_for_storing(f->x, f->y, b->output_resource_id, 1, &understaffed_storages, &dst);
                                                    if (dst_building_id) {
                                                        set_destination(f, FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_GRANARY, dst_building_id, dst.x, dst.y);
                                                    } else {
                                                        // no one will accept
                                                        f->wait_ticks = 0;
                                                        // set cartpusher text
                                                        f->min_max_seen = understaffed_storages ? 2 : 1;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_WAREHOUSE:
                                set_cart_graphic(f);
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_CARTPUSHER_AT_WAREHOUSE;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    reroute_cartpusher(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                if (all_buildings[f->destination_building_id].state != BUILDING_STATE_IN_USE) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_GRANARY:
                                set_cart_graphic(f);
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_CARTPUSHER_AT_GRANARY;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    reroute_cartpusher(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    f->action_state = FIGURE_ACTION_CARTPUSHER_INITIAL;
                                    f->wait_ticks = 0;
                                }
                                if (all_buildings[f->destination_building_id].state != BUILDING_STATE_IN_USE) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_WORKSHOP:
                                set_cart_graphic(f);
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_CARTPUSHER_AT_WORKSHOP;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    reroute_cartpusher(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_CARTPUSHER_AT_WAREHOUSE:
                                f->wait_ticks++;
                                if (f->wait_ticks > 10) {
                                    if (building_warehouse_add_resource(&all_buildings[f->destination_building_id], f->resource_id)) {
                                        f->action_state = FIGURE_ACTION_CARTPUSHER_RETURNING;
                                        f->wait_ticks = 0;
                                        f->destination_x = f->source_x;
                                        f->destination_y = f->source_y;
                                    } else {
                                        figure_route_remove(f);
                                        f->action_state = FIGURE_ACTION_CARTPUSHER_INITIAL;
                                        f->wait_ticks = 0;
                                    }
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_CARTPUSHER_AT_GRANARY:
                                f->wait_ticks++;
                                if (f->wait_ticks > 5) {
                                    if (building_granary_add_resource(&all_buildings[f->destination_building_id], f->resource_id, 1)) {
                                        f->action_state = FIGURE_ACTION_CARTPUSHER_RETURNING;
                                        f->wait_ticks = 0;
                                        f->destination_x = f->source_x;
                                        f->destination_y = f->source_y;
                                    } else {
                                        b = &all_buildings[f->building_id];
                                        struct map_point_t dst;
                                        // priority 1: accepting granary for food
                                        int dst_building_id = building_granary_for_storing(f->x, f->y, b->output_resource_id, 0, 0, &dst);
                                        if (dst_building_id) {
                                            set_destination(f, FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_GRANARY, dst_building_id, dst.x, dst.y);
                                        } else {
                                            // priority 2: warehouse
                                            dst_building_id = building_warehouse_for_storing(0, f->x, f->y, b->output_resource_id, 0, &dst);
                                            if (dst_building_id) {
                                                set_destination(f, FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_WAREHOUSE, dst_building_id, dst.x, dst.y);
                                            } else {
                                                // priority 3: granary
                                                dst_building_id = building_granary_for_storing(f->x, f->y, b->output_resource_id, 1, 0, &dst);
                                                if (dst_building_id) {
                                                    set_destination(f, FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_GRANARY, dst_building_id, dst.x, dst.y);
                                                } else {
                                                    // no one will accept, stand idle
                                                    f->wait_ticks = 0;
                                                }
                                            }
                                        }
                                    }
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_CARTPUSHER_AT_WORKSHOP:
                                f->wait_ticks++;
                                if (f->wait_ticks > 5) {
                                    building_workshop_add_raw_material(&all_buildings[f->destination_building_id]);
                                    f->action_state = FIGURE_ACTION_CARTPUSHER_RETURNING;
                                    f->wait_ticks = 0;
                                    f->destination_x = f->source_x;
                                    f->destination_y = f->source_y;
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_CARTPUSHER_RETURNING:
                                f->cart_image_id = 4650;
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                        }
                        figure_image_increase_offset(f, 12);
                        update_image_cartpusher(f);
                    }
                    break;
                    case FIGURE_LABOR_SEEKER:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        if (b->state != BUILDING_STATE_IN_USE || b->figure_id2 != f->id) {
                            figure_delete(f);
                            return;
                        }
                        roamer_action(f, 1);
                        figure_image_increase_offset(f, 12);
                        f->image_id = 3410 + figure_image_direction(f) + 8 * f->image_offset;
                    }
                    break;
                    case FIGURE_BARBER:
                        culture_action(f, 6041);
                        break;
                    case FIGURE_BATHHOUSE_WORKER:
                        culture_action(f, 3514);
                        break;
                    case FIGURE_DOCTOR:
                    case FIGURE_SURGEON:
                        culture_action(f, 7425);
                        break;
                    case FIGURE_PRIEST:
                        culture_action(f, 3618);
                        break;
                    case FIGURE_SCHOOL_CHILD:\
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_SCHOOL) {
                            figure_delete(f);
                            return;
                        }
                        figure_image_increase_offset(f, 12);
                        switch (f->action_state) {
                            case FIGURE_ACTION_ROAMING:
                                f->is_invisible = 0;
                                f->roam_length++;
                                if (f->roam_length >= figure_properties[f->type].max_roam_length) {
                                    figure_delete(f);
                                    return;
                                }
                                figure_movement_roam_ticks(f, 2);
                                break;
                        }
                        f->image_id = 4130 + figure_image_direction(f) + 8 * f->image_offset;
                        break;
                    }
                    case FIGURE_TEACHER:
                        culture_action(f, 7633);
                        break;
                    case FIGURE_LIBRARIAN:
                        culture_action(f, 7633);
                        break;
                    case FIGURE_MISSIONARY:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        if (b->state != BUILDING_STATE_IN_USE || b->figure_id != f->id) {
                            figure_delete(f);
                            return;
                        }
                        roamer_action(f, 1);
                        figure_image_increase_offset(f, 12);
                        f->image_id = 7529 + figure_image_direction(f) + 8 * f->image_offset;
                        break;
                    }
                    case FIGURE_ACTOR:
                    case FIGURE_GLADIATOR:
                    case FIGURE_LION_TAMER:
                    case FIGURE_CHARIOTEER:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        f->cart_image_id = 4650;
                        f->use_cross_country = 0;
                        figure_image_increase_offset(f, 12);
                        f->wait_ticks_missile++;
                        if (f->wait_ticks_missile >= 120) {
                            f->wait_ticks_missile = 0;
                        }
                        if (scenario.gladiator_revolt.state == EVENT_IN_PROGRESS && f->type == FIGURE_GLADIATOR) {
                            if (f->action_state == FIGURE_ACTION_ENTERTAINER_GOING_TO_VENUE ||
                                f->action_state == FIGURE_ACTION_ENTERTAINER_ROAMING ||
                                f->action_state == FIGURE_ACTION_ENTERTAINER_RETURNING) {
                                f->type = FIGURE_ENEMY_GLADIATOR;
                                figure_route_remove(f);
                                f->roam_length = 0;
                                f->action_state = FIGURE_ACTION_NATIVE_CREATED;
                                f->is_targetable = 1;
                                f->terrain_usage = TERRAIN_USAGE_ANY;
                                return;
                            }
                        }
                        int speed_factor = f->type == FIGURE_CHARIOTEER ? 2 : 1;
                        switch (f->action_state) {
                            case FIGURE_ACTION_ENTERTAINER_AT_SCHOOL_CREATED:
                                f->is_invisible = 1;
                                f->image_offset = 0;
                                f->wait_ticks_missile = 0;
                                f->wait_ticks--;
                                if (f->wait_ticks <= 0) {
                                    int x_road, y_road;
                                    if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                        f->action_state = FIGURE_ACTION_ENTERTAINER_EXITING_SCHOOL;
                                        figure_movement_set_cross_country_destination(f, x_road, y_road);
                                        f->roam_length = 0;
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_ENTERTAINER_EXITING_SCHOOL:
                                f->use_cross_country = 1;
                                f->is_invisible = 1;
                                if (figure_movement_move_ticks_cross_country(f, 1) == 1) {
                                    int dst_building_id = 0;
                                    switch (f->type) {
                                        case FIGURE_ACTOR:
                                            dst_building_id = determine_destination(f->x, f->y, BUILDING_THEATER, BUILDING_AMPHITHEATER);
                                            break;
                                        case FIGURE_GLADIATOR:
                                            dst_building_id = determine_destination(f->x, f->y, BUILDING_AMPHITHEATER, BUILDING_COLOSSEUM);
                                            break;
                                        case FIGURE_LION_TAMER:
                                            dst_building_id = determine_destination(f->x, f->y, BUILDING_COLOSSEUM, 0);
                                            break;
                                        case FIGURE_CHARIOTEER:
                                            dst_building_id = determine_destination(f->x, f->y, BUILDING_HIPPODROME, 0);
                                            break;
                                    }
                                    if (dst_building_id) {
                                        struct building_t *b_dst = &all_buildings[dst_building_id];
                                        int x_road, y_road;
                                        if (map_closest_road_within_radius(b_dst->x, b_dst->y, b_dst->size, 2, &x_road, &y_road)) {
                                            f->destination_building_id = dst_building_id;
                                            f->action_state = FIGURE_ACTION_ENTERTAINER_GOING_TO_VENUE;
                                            f->destination_x = x_road;
                                            f->destination_y = y_road;
                                            f->roam_length = 0;
                                        } else {
                                            figure_delete(f);
                                            return;
                                        }
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                f->is_invisible = 1;
                                break;
                            case FIGURE_ACTION_ENTERTAINER_GOING_TO_VENUE:
                            {
                                f->is_invisible = 0;
                                f->roam_length++;
                                if (f->roam_length >= 3200) {
                                    figure_delete(f);
                                    return;
                                }
                                walk_ticks(f, speed_factor, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    b = &all_buildings[f->destination_building_id];
                                    if (b->type >= BUILDING_AMPHITHEATER && b->type <= BUILDING_COLOSSEUM) {
                                        switch (f->type) {
                                            case FIGURE_ACTOR:
                                                b->data.entertainment.play++;
                                                if (b->data.entertainment.play >= 5) {
                                                    b->data.entertainment.play = 0;
                                                }
                                                if (b->type == BUILDING_THEATER) {
                                                    b->data.entertainment.days1 = 32;
                                                } else {
                                                    b->data.entertainment.days2 = 32;
                                                }
                                                break;
                                            case FIGURE_GLADIATOR:
                                                if (b->type == BUILDING_AMPHITHEATER) {
                                                    b->data.entertainment.days1 = 32;
                                                } else {
                                                    b->data.entertainment.days2 = 32;
                                                }
                                                break;
                                            case FIGURE_LION_TAMER:
                                            case FIGURE_CHARIOTEER:
                                                b->data.entertainment.days1 = 32;
                                                break;
                                        }
                                    }
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            }
                            case FIGURE_ACTION_ENTERTAINER_ROAMING:
                                f->is_invisible = 0;
                                f->roam_length++;
                                if (f->roam_length >= figure_properties[f->type].max_roam_length) {
                                    int x_road, y_road;
                                    if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                        f->action_state = FIGURE_ACTION_ENTERTAINER_RETURNING;
                                        f->destination_x = x_road;
                                        f->destination_y = y_road;
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                figure_movement_roam_ticks(f, speed_factor);
                                break;
                            case FIGURE_ACTION_ENTERTAINER_RETURNING:
                                walk_ticks(f, speed_factor, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION ||
                                    f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                        }
                        int dir = figure_image_normalize_direction(f->direction < 8 ? f->direction : f->previous_tile_direction);
                        if (f->type == FIGURE_CHARIOTEER) {
                            f->cart_image_id = 0;
                            f->image_id = 8192 + dir + 8 * f->image_offset;
                            return;
                        }
                        int image_id;
                        if (f->type == FIGURE_ACTOR) {
                            image_id = 3722;
                        } else if (f->type == FIGURE_GLADIATOR) {
                            image_id = 5579;
                        } else if (f->type == FIGURE_LION_TAMER) {
                            image_id = 3826;
                            if (f->wait_ticks_missile >= 96) {
                                image_id = 3930;
                            }
                            f->cart_image_id = 6609;
                        } else {
                            return;
                        }
                        f->image_id = image_id + dir + 8 * f->image_offset;
                        if (f->cart_image_id) {
                            f->cart_image_id += dir + 8 * f->image_offset;
                            figure_image_set_cart_offset(f, dir);
                        }
                        break;
                    }
                    case FIGURE_HIPPODROME_HORSES:
                    {
                        city_data.entertainment.hippodrome_has_race = 1;
                        f->use_cross_country = 1;
                        figure_image_increase_offset(f, 8);
                        switch (f->action_state) {
                            case FIGURE_ACTION_HIPPODROME_HORSE_CREATED:
                                f->image_offset = 0;
                                f->wait_ticks_missile = 0;
                                set_horse_destination(f, HORSE_CREATED);
                                f->wait_ticks++;
                                if (f->wait_ticks > 60 && f->resource_id == 0) {
                                    f->action_state = FIGURE_ACTION_HIPPODROME_HORSE_RACING;
                                    f->wait_ticks = 0;
                                }
                                f->wait_ticks++;
                                if (f->wait_ticks > 20 && f->resource_id == 1) {
                                    f->action_state = FIGURE_ACTION_HIPPODROME_HORSE_RACING;
                                    f->wait_ticks = 0;
                                }
                                break;
                            case FIGURE_ACTION_HIPPODROME_HORSE_RACING:
                                f->direction = calc_general_direction(f->x, f->y, f->destination_x, f->destination_y);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->wait_ticks_missile++;
                                    if (f->wait_ticks_missile >= 22) {
                                        f->wait_ticks_missile = 0;
                                        f->leading_figure_id++;
                                        if (f->leading_figure_id >= 6) {
                                            f->wait_ticks = 0;
                                            f->action_state = FIGURE_ACTION_HIPPODROME_HORSE_DONE;
                                        }
                                        if ((f->id + random_data.random1_7bit) & 1) {
                                            f->speed_multiplier = 3;
                                        } else {
                                            f->speed_multiplier = 4;
                                        }
                                    } else if (f->wait_ticks_missile == 11) {
                                        if ((f->id + random_data.random1_7bit) & 1) {
                                            f->speed_multiplier = 3;
                                        } else {
                                            f->speed_multiplier = 4;
                                        }
                                    }
                                    set_horse_destination(f, HORSE_RACING);
                                    f->direction = calc_general_direction(f->x, f->y, f->destination_x, f->destination_y);
                                    figure_movement_set_cross_country_direction(f,
                                        f->cross_country_x, f->cross_country_y, 15 * f->destination_x, 15 * f->destination_y, 0);
                                }
                                if (f->action_state != FIGURE_ACTION_HIPPODROME_HORSE_DONE) {
                                    figure_movement_move_ticks_cross_country(f, f->speed_multiplier);
                                }
                                break;
                            case FIGURE_ACTION_HIPPODROME_HORSE_DONE:
                                if (!f->wait_ticks) {
                                    set_horse_destination(f, HORSE_FINISHED);
                                    f->direction = calc_general_direction(f->x, f->y, f->destination_x, f->destination_y);
                                    figure_movement_set_cross_country_direction(f,
                                        f->cross_country_x, f->cross_country_y, 15 * f->destination_x, 15 * f->destination_y, 0);
                                }
                                if (f->direction != DIR_FIGURE_AT_DESTINATION) {
                                    figure_movement_move_ticks_cross_country(f, 1);
                                }
                                f->wait_ticks++;
                                if (f->wait_ticks > 30) {
                                    f->image_offset = 0;
                                }
                                f->wait_ticks++;
                                if (f->wait_ticks > 150) {
                                    figure_delete(f);
                                    break;
                                }
                                break;
                        }
                        int dir = figure_image_direction(f);
                        if (f->resource_id == 0) {
                            f->image_id = 5122 + dir + 8 * f->image_offset;
                            f->cart_image_id = 5250 + dir;
                        } else {
                            f->image_id = 5186 + dir + 8 * f->image_offset;
                            f->cart_image_id = 5258 + dir;
                        }
                        int cart_dir = (dir + 4) % 8;
                        figure_image_set_cart_offset(f, cart_dir);
                    }
                    break;
                    case FIGURE_TAX_COLLECTOR:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        f->use_cross_country = 0;
                        if (b->state != BUILDING_STATE_IN_USE || b->figure_id != f->id) {
                            figure_delete(f);
                            return;
                        }
                        switch (f->action_state) {
                            case FIGURE_ACTION_TAX_COLLECTOR_CREATED:
                                f->is_invisible = 1;
                                f->image_offset = 0;
                                f->wait_ticks--;
                                if (f->wait_ticks <= 0) {
                                    int x_road, y_road;
                                    if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                        f->action_state = FIGURE_ACTION_TAX_COLLECTOR_ENTERING_EXITING;
                                        figure_movement_set_cross_country_destination(f, x_road, y_road);
                                        f->roam_length = 0;
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_TAX_COLLECTOR_ENTERING_EXITING:
                                f->use_cross_country = 1;
                                f->is_invisible = 1;
                                if (figure_movement_move_ticks_cross_country(f, 1) == 1) {
                                    if (map_building_at(f->grid_offset) == f->building_id) {
                                        // returned to own building
                                        figure_delete(f);
                                        return;
                                    } else {
                                        f->action_state = FIGURE_ACTION_TAX_COLLECTOR_ROAMING;
                                        figure_movement_init_roaming(f);
                                        f->roam_length = 0;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_TAX_COLLECTOR_ROAMING:
                                f->is_invisible = 0;
                                f->roam_length++;
                                if (f->roam_length >= figure_properties[f->type].max_roam_length) {
                                    int x_road, y_road;
                                    if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                        f->action_state = FIGURE_ACTION_TAX_COLLECTOR_RETURNING;
                                        f->destination_x = x_road;
                                        f->destination_y = y_road;
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                figure_movement_roam_ticks(f, 1);
                                break;
                            case FIGURE_ACTION_TAX_COLLECTOR_RETURNING:
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_TAX_COLLECTOR_ENTERING_EXITING;
                                    figure_movement_set_cross_country_destination(f, b->x, b->y);
                                    f->roam_length = 0;
                                } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                        }
                        figure_image_increase_offset(f, 12);
                        f->image_id = 4026 + figure_image_direction(f) + 8 * f->image_offset;
                        break;
                    }
                    case FIGURE_ENGINEER:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        f->use_cross_country = 0;
                        if (b->state != BUILDING_STATE_IN_USE || b->figure_id != f->id) {
                            figure_delete(f);
                            return;
                        }
                        figure_image_increase_offset(f, 12);
                        switch (f->action_state) {
                            case FIGURE_ACTION_ENGINEER_CREATED:
                                f->is_invisible = 1;
                                f->image_offset = 0;
                                f->wait_ticks--;
                                if (f->wait_ticks <= 0) {
                                    int x_road, y_road;
                                    if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                        f->action_state = FIGURE_ACTION_ENGINEER_ENTERING_EXITING;
                                        figure_movement_set_cross_country_destination(f, x_road, y_road);
                                        f->roam_length = 0;
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_ENGINEER_ENTERING_EXITING:
                                f->use_cross_country = 1;
                                f->is_invisible = 1;
                                if (figure_movement_move_ticks_cross_country(f, 1) == 1) {
                                    if (map_building_at(f->grid_offset) == f->building_id) {
                                        // returned to own building
                                        figure_delete(f);
                                        return;
                                    } else {
                                        f->action_state = FIGURE_ACTION_ENGINEER_ROAMING;
                                        figure_movement_init_roaming(f);
                                        f->roam_length = 0;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_ENGINEER_ROAMING:
                                f->is_invisible = 0;
                                f->roam_length++;
                                if (f->roam_length >= figure_properties[f->type].max_roam_length) {
                                    int x_road, y_road;
                                    if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                        f->action_state = FIGURE_ACTION_ENGINEER_RETURNING;
                                        f->destination_x = x_road;
                                        f->destination_y = y_road;
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                figure_movement_roam_ticks(f, 1);
                                break;
                            case FIGURE_ACTION_ENGINEER_RETURNING:
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_ENGINEER_ENTERING_EXITING;
                                    figure_movement_set_cross_country_destination(f, b->x, b->y);
                                    f->roam_length = 0;
                                } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                        }
                        f->image_id = 4546 + figure_image_direction(f) + 8 * f->image_offset;
                    }
                    break;
                    case FIGURE_FISHING_BOAT:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        if (b->state != BUILDING_STATE_IN_USE) {
                            figure_delete(f);
                            return;
                        }
                        if (f->action_state != FIGURE_ACTION_FISHING_BOAT_CREATED && b->data.industry.fishing_boat_id != f->id) {
                            struct map_point_t tile;
                            b = &all_buildings[map_water_get_wharf_for_new_fishing_boat(f, &tile)];
                            if (b->id) {
                                f->building_id = b->id;
                                b->data.industry.fishing_boat_id = f->id;
                                f->action_state = FIGURE_ACTION_FISHING_BOAT_GOING_TO_WHARF;
                                f->destination_x = tile.x;
                                f->destination_y = tile.y;
                                f->source_x = tile.x;
                                f->source_y = tile.y;
                                figure_route_remove(f);
                            } else {
                                figure_delete(f);
                                return;
                            }
                        }
                        figure_image_increase_offset(f, 12);
                        f->cart_image_id = 0;
                        switch (f->action_state) {
                            case FIGURE_ACTION_FISHING_BOAT_CREATED:
                                f->wait_ticks++;
                                if (f->wait_ticks >= 50) {
                                    f->wait_ticks = 0;
                                    struct map_point_t tile;
                                    int wharf_id = map_water_get_wharf_for_new_fishing_boat(f, &tile);
                                    if (wharf_id) {
                                        b->figure_id = 0; // remove from original building
                                        f->building_id = wharf_id;
                                        all_buildings[wharf_id].data.industry.fishing_boat_id = f->id;
                                        f->action_state = FIGURE_ACTION_FISHING_BOAT_GOING_TO_WHARF;
                                        f->destination_x = tile.x;
                                        f->destination_y = tile.y;
                                        f->source_x = tile.x;
                                        f->source_y = tile.y;
                                        figure_route_remove(f);
                                    }
                                }
                                break;
                            case FIGURE_ACTION_FISHING_BOAT_GOING_TO_FISH:
                                walk_ticks(f, 1, 0);
                                f->height_adjusted_ticks = 0;
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    struct map_point_t tile = { 0 };

                                    if (map_grid_is_valid_offset(f->grid_offset) ? map_figures.items[f->grid_offset] : 0 != f->id) {
                                        for (int radius = 1; radius <= 5; radius++) {
                                            int x_min, y_min, x_max, y_max;
                                            map_grid_get_area(f->x, f->y, 1, radius, &x_min, &y_min, &x_max, &y_max);
                                            for (int yy = y_min; yy <= y_max; yy++) {
                                                for (int xx = x_min; xx <= x_max; xx++) {
                                                    int grid_offset = map_grid_offset(xx, yy);
                                                    if (!(map_grid_is_valid_offset(grid_offset) && map_figures.items[grid_offset] > 0) && map_terrain_is(grid_offset, TERRAIN_WATER)) {
                                                        tile.x = xx;
                                                        tile.y = yy;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if (tile.x) {
                                        figure_route_remove(f);
                                        f->destination_x = tile.x;
                                        f->destination_y = tile.y;
                                        f->direction = f->previous_tile_direction;
                                    } else {
                                        f->action_state = FIGURE_ACTION_FISHING_BOAT_FISHING;
                                        f->wait_ticks = 0;
                                    }
                                } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                    f->action_state = FIGURE_ACTION_FISHING_BOAT_AT_WHARF;
                                    f->destination_x = f->source_x;
                                    f->destination_y = f->source_y;
                                }
                                break;
                            case FIGURE_ACTION_FISHING_BOAT_FISHING:
                                f->wait_ticks++;
                                if (f->wait_ticks >= 200) {
                                    f->wait_ticks = 0;
                                    f->action_state = FIGURE_ACTION_FISHING_BOAT_RETURNING_WITH_FISH;
                                    f->destination_x = f->source_x;
                                    f->destination_y = f->source_y;
                                    figure_route_remove(f);
                                }
                                break;
                            case FIGURE_ACTION_FISHING_BOAT_GOING_TO_WHARF:
                                walk_ticks(f, 1, 0);
                                f->height_adjusted_ticks = 0;
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_FISHING_BOAT_AT_WHARF;
                                    f->wait_ticks = 0;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    // cannot reach grounds
                                    city_message_post_with_message_delay(MESSAGE_CAT_FISHING_BLOCKED, 1, MESSAGE_FISHING_BOAT_BLOCKED, 12);
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_FISHING_BOAT_AT_WHARF:
                            {
                                int pct_workers = calc_percentage(b->num_workers, building_properties[b->type].n_laborers);
                                int max_wait_ticks = 5 * (102 - pct_workers);
                                if (b->data.industry.has_fish > 0) {
                                    pct_workers = 0;
                                }
                                if (pct_workers > 0) {
                                    f->wait_ticks++;
                                    if (f->wait_ticks >= max_wait_ticks) {
                                        f->wait_ticks = 0;
                                        struct map_point_t tile;
                                        int num_fishing_spots = 0;
                                        for (int k = 0; k < MAX_FISH_POINTS; k++) {
                                            if (scenario.fishing_points[k].x > 0) {
                                                num_fishing_spots++;
                                            }
                                        }
                                        if (num_fishing_spots) {
                                            int min_dist = 10000;
                                            int min_fish_id = 0;
                                            for (int k = 0; k < MAX_FISH_POINTS; k++) {
                                                if (scenario.fishing_points[k].x > 0) {
                                                    int dist = calc_maximum_distance(f->x, f->y, scenario.fishing_points[k].x, scenario.fishing_points[k].y);
                                                    if (dist < min_dist) {
                                                        min_dist = dist;
                                                        min_fish_id = k;
                                                    }
                                                }
                                            }
                                            if (min_dist < 10000) {
                                                tile.x = scenario.fishing_points[min_fish_id].x;
                                                tile.y = scenario.fishing_points[min_fish_id].y;
                                                f->action_state = FIGURE_ACTION_FISHING_BOAT_GOING_TO_FISH;
                                                f->destination_x = tile.x;
                                                f->destination_y = tile.y;
                                                figure_route_remove(f);
                                            }
                                        }
                                    }
                                }
                            }
                            break;
                            case FIGURE_ACTION_FISHING_BOAT_RETURNING_WITH_FISH:
                                walk_ticks(f, 1, 0);
                                f->height_adjusted_ticks = 0;
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_FISHING_BOAT_AT_WHARF;
                                    f->wait_ticks = 0;
                                    b->figure_spawn_delay = 1;
                                    b->data.industry.has_fish++;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                        }
                        int dir = figure_image_normalize_direction(f->direction < 8 ? f->direction : f->previous_tile_direction);
                        if (f->action_state == FIGURE_ACTION_FISHING_BOAT_FISHING) {
                            f->image_id = 4906 + dir;
                        } else {
                            f->image_id = 4898 + dir;
                        }
                        break;
                    }
                    case FIGURE_FISH_GULLS:
                    {
                        f->use_cross_country = 1;
                        if (!(f->image_offset & 3) && figure_movement_move_ticks_cross_country(f, 1)) {
                            f->progress_on_tile++;
                            if (f->progress_on_tile > 8) {
                                f->progress_on_tile = 0;
                            }
                            figure_movement_set_cross_country_destination(f,
                                f->source_x + SEAGULL_OFFSETS[f->progress_on_tile].x,
                                f->source_y + SEAGULL_OFFSETS[f->progress_on_tile].y);
                        }
                        if (f->id & 1) {
                            figure_image_increase_offset(f, 54);
                            f->image_id = 779 + f->image_offset / 3;
                        } else {
                            figure_image_increase_offset(f, 72);
                            f->image_id = 797 + f->image_offset / 3;
                        }
                    }
                    break;
                    case FIGURE_SHIPWRECK:
                        figure_image_increase_offset(f, 128);
                        if (f->wait_ticks < 1000) {
                            map_figure_delete(f);
                            struct map_point_t tile = { 0 };
                            if (!(map_terrain_is(f->grid_offset, TERRAIN_WATER) && map_grid_is_valid_offset(f->grid_offset) ? map_figures.items[f->grid_offset] : 0 == f->id)) {
                                for (int radius = 1; radius <= 5; radius++) {
                                    int x_min, y_min, x_max, y_max;
                                    map_grid_get_area(f->x, f->y, 1, radius, &x_min, &y_min, &x_max, &y_max);

                                    for (int yy = y_min; yy <= y_max; yy++) {
                                        for (int xx = x_min; xx <= x_max; xx++) {
                                            int grid_offset = map_grid_offset(xx, yy);
                                            if (!(map_grid_is_valid_offset(grid_offset) && map_figures.items[grid_offset] > 0) || map_grid_is_valid_offset(grid_offset) ? map_figures.items[grid_offset] : 0 == f->id) {
                                                if (map_terrain_is(grid_offset, TERRAIN_WATER) &&
                                                    map_terrain_is(map_grid_offset(xx, yy - 2), TERRAIN_WATER) &&
                                                    map_terrain_is(map_grid_offset(xx, yy + 2), TERRAIN_WATER) &&
                                                    map_terrain_is(map_grid_offset(xx - 2, yy), TERRAIN_WATER) &&
                                                    map_terrain_is(map_grid_offset(xx + 2, yy), TERRAIN_WATER)) {
                                                    f->x = tile.x;
                                                    f->y = tile.y;
                                                    f->grid_offset = map_grid_offset(f->x, f->y);
                                                    f->cross_country_x = 15 * f->x + 7;
                                                    f->cross_country_y = 15 * f->y + 7;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            map_figure_add(f);
                            f->wait_ticks = 1000;
                        }
                        f->wait_ticks++;
                        if (f->wait_ticks > 2000) {
                            figure_delete(f);
                            return;
                        }
                        f->image_id = 4914 + f->image_offset / 16;
                        break;
                    case FIGURE_DOCKER:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        figure_image_increase_offset(f, 12);
                        f->cart_image_id = 0;
                        if (b->state != BUILDING_STATE_IN_USE) {
                            figure_delete(f);
                            return;
                        }
                        if (b->type != BUILDING_DOCK && b->type != BUILDING_WHARF) {
                            figure_delete(f);
                            return;
                        }
                        if (b->data.dock.num_ships) {
                            b->data.dock.num_ships--;
                        }
                        if (b->data.dock.trade_ship_id) {
                            struct figure_t *ship = &figures[b->data.dock.trade_ship_id];
                            if (!figure_is_alive(ship) || ship->type != FIGURE_TRADE_SHIP) {
                                b->data.dock.trade_ship_id = 0;
                            } else if (figure_trader_data.traders[ship->trader_id].bought_amount >= 12 || figure_trader_data.traders[ship->trader_id].sold_amount >= 12) {
                                b->data.dock.trade_ship_id = 0;
                            } else if (ship->action_state == FIGURE_ACTION_TRADE_SHIP_LEAVING) {
                                b->data.dock.trade_ship_id = 0;
                            }
                        }
                        switch (f->action_state) {
                            case FIGURE_ACTION_DOCKER_IDLING:
                                f->resource_id = 0;
                                f->cart_image_id = 0;
                                int ship_id = b->data.dock.trade_ship_id;
                                struct figure_t *ship = &figures[ship_id];
                                int x, y;
                                get_trade_center_location(f, &x, &y);
                                struct map_point_t tile;
                                int importable[16];
                                importable[RESOURCE_NONE] = 0;
                                for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                    importable[r] = can_import_resource_from_trade_city(ship->empire_city_id, r);
                                }
                                int resource = city_trade_next_docker_import_resource();
                                for (int k = RESOURCE_WHEAT; k < RESOURCE_TYPES_MAX && !importable[resource]; k++) {
                                    resource = city_trade_next_docker_import_resource();
                                }
                                int min_building_id = 0;
                                if (importable[resource]) {
                                    int min_distance = 10000;
                                    for (int l = 1; l < MAX_BUILDINGS; l++) {
                                        b = &all_buildings[l];
                                        if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_WAREHOUSE) {
                                            continue;
                                        }
                                        if (!b->has_road_access) {
                                            continue;
                                        }
                                        struct building_storage_t *storage = &storages[b->storage_id].storage;
                                        if (storage->resource_state[resource] != BUILDING_STORAGE_STATE_NOT_ACCEPTING && !storage->empty_all) {
                                            int distance_penalty = 32;
                                            struct building_t *space = b;
                                            for (int s = 0; s < 8; s++) {
                                                space = &all_buildings[space->next_part_building_id];
                                                if (space->id && space->subtype.warehouse_resource_id == RESOURCE_NONE) {
                                                    distance_penalty -= 8;
                                                }
                                                if (space->id && space->subtype.warehouse_resource_id == resource && space->loads_stored < 4) {
                                                    distance_penalty -= 4;
                                                }
                                            }
                                            if (distance_penalty < 32) {
                                                int distance = calc_maximum_distance(
                                                    b->x, b->y, x, y);
                                                // prefer emptier warehouse
                                                distance += distance_penalty;
                                                if (distance < min_distance) {
                                                    min_distance = distance;
                                                    min_building_id = l;
                                                }
                                            }
                                        }
                                    }
                                    if (min_building_id) {
                                        struct building_t *min = &all_buildings[min_building_id];
                                        if (map_has_road_access(min->x, min->y, 3, &tile) && min->has_road_access == 1) {
                                            tile.x = min->x;
                                            tile.y = min->y;
                                        }
                                    }
                                }

                                if (!ship_id || ship->action_state != FIGURE_ACTION_TRADE_SHIP_MOORED || !ship->loads_sold_or_carrying || !min_building_id) {
                                    fetch_export_resource(f, b);
                                } else {
                                    ship->loads_sold_or_carrying--;
                                    f->destination_building_id = min_building_id;
                                    f->wait_ticks = 0;
                                    f->action_state = FIGURE_ACTION_DOCKER_IMPORT_QUEUE;
                                    f->destination_x = tile.x;
                                    f->destination_y = tile.y;
                                    f->resource_id = resource;
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_DOCKER_IMPORT_QUEUE:
                                f->cart_image_id = 0;
                                f->image_offset = 0;
                                if (b->data.dock.queued_docker_id <= 0) {
                                    b->data.dock.queued_docker_id = f->id;
                                    f->wait_ticks = 0;
                                }
                                if (b->data.dock.queued_docker_id == f->id) {
                                    b->data.dock.num_ships = 120;
                                    f->wait_ticks++;
                                    if (f->wait_ticks >= 80) {
                                        f->action_state = FIGURE_ACTION_DOCKER_IMPORT_GOING_TO_WAREHOUSE;
                                        f->wait_ticks = 0;
                                        set_cart_graphic(f);
                                        b->data.dock.queued_docker_id = 0;
                                    }
                                } else {
                                    int has_queued_docker = 0;
                                    for (int k = 0; k < 3; k++) {
                                        if (b->data.dock.docker_ids[k]) {
                                            struct figure_t *docker = &figures[b->data.dock.docker_ids[k]];
                                            if (docker->id == b->data.dock.queued_docker_id && figure_is_alive(docker)) {
                                                if (docker->action_state == FIGURE_ACTION_DOCKER_IMPORT_QUEUE ||
                                                    docker->action_state == FIGURE_ACTION_DOCKER_EXPORT_QUEUE) {
                                                    has_queued_docker = 1;
                                                }
                                            }
                                        }
                                    }
                                    if (!has_queued_docker) {
                                        b->data.dock.queued_docker_id = 0;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_DOCKER_EXPORT_QUEUE:
                                set_cart_graphic(f);
                                if (b->data.dock.queued_docker_id <= 0) {
                                    b->data.dock.queued_docker_id = f->id;
                                    f->wait_ticks = 0;
                                }
                                if (b->data.dock.queued_docker_id == f->id) {
                                    b->data.dock.num_ships = 120;
                                    f->wait_ticks++;
                                    if (f->wait_ticks >= 80) {
                                        f->action_state = FIGURE_ACTION_DOCKER_IDLING;
                                        f->wait_ticks = 0;
                                        f->image_id = 0;
                                        f->cart_image_id = 0;
                                        b->data.dock.queued_docker_id = 0;
                                    }
                                }
                                f->wait_ticks++;
                                if (f->wait_ticks >= 20) {
                                    f->action_state = FIGURE_ACTION_DOCKER_IDLING;
                                    f->wait_ticks = 0;
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_DOCKER_IMPORT_GOING_TO_WAREHOUSE:
                                set_cart_graphic(f);
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_DOCKER_IMPORT_AT_WAREHOUSE;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                if (all_buildings[f->destination_building_id].state != BUILDING_STATE_IN_USE) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_DOCKER_EXPORT_GOING_TO_WAREHOUSE:
                                f->cart_image_id = 4650;
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_DOCKER_EXPORT_AT_WAREHOUSE;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                if (all_buildings[f->destination_building_id].state != BUILDING_STATE_IN_USE) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_DOCKER_EXPORT_RETURNING:
                                set_cart_graphic(f);
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_DOCKER_EXPORT_QUEUE;
                                    f->wait_ticks = 0;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                if (all_buildings[f->destination_building_id].state != BUILDING_STATE_IN_USE) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_DOCKER_IMPORT_RETURNING:
                                set_cart_graphic(f);
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_DOCKER_IDLING;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_DOCKER_IMPORT_AT_WAREHOUSE:
                                set_cart_graphic(f);
                                f->wait_ticks++;
                                if (f->wait_ticks > 10) {
                                    int trade_city_id;
                                    if (b->data.dock.trade_ship_id) {
                                        trade_city_id = figures[b->data.dock.trade_ship_id].empire_city_id;
                                    } else {
                                        trade_city_id = 0;
                                    }

                                    int try_import_resource = 0;
                                    struct building_t *warehouse = &all_buildings[f->destination_building_id];
                                    if (warehouse->type == BUILDING_WAREHOUSE) {
                                        // try existing storage bay with the same resource
                                        struct building_t *space = warehouse;
                                        for (int k = 0; k < 8; k++) {
                                            space = &all_buildings[space->next_part_building_id];
                                            if (space->id > 0) {
                                                if (space->loads_stored && space->loads_stored < 4 && space->subtype.warehouse_resource_id == f->resource_id) {
                                                    empire_objects[trade_city_id].resource_sold[f->resource_id]++;
                                                    building_warehouse_space_add_import(space, f->resource_id);
                                                    try_import_resource = 1;
                                                    break;
                                                }
                                            }
                                        }
                                        if (!try_import_resource) {
                                            // try unused storage bay
                                            space = warehouse;
                                            for (int k = 0; k < 8; k++) {
                                                space = &all_buildings[space->next_part_building_id];
                                                if (space->id > 0) {
                                                    if (space->subtype.warehouse_resource_id == RESOURCE_NONE) {
                                                        empire_objects[trade_city_id].resource_sold[f->resource_id]++;
                                                        building_warehouse_space_add_import(space, f->resource_id);
                                                        try_import_resource = 1;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if (try_import_resource) {
                                        int trader_id = figures[b->data.dock.trade_ship_id].trader_id;
                                        trader_record_sold_resource(trader_id, f->resource_id);
                                        f->action_state = FIGURE_ACTION_DOCKER_IMPORT_RETURNING;
                                        f->wait_ticks = 0;
                                        f->destination_x = f->source_x;
                                        f->destination_y = f->source_y;
                                        f->resource_id = 0;
                                        fetch_export_resource(f, b);
                                    } else {
                                        f->action_state = FIGURE_ACTION_DOCKER_IMPORT_RETURNING;
                                        f->destination_x = f->source_x;
                                        f->destination_y = f->source_y;
                                    }
                                    f->wait_ticks = 0;
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_DOCKER_EXPORT_AT_WAREHOUSE:
                                f->cart_image_id = 4650;
                                f->wait_ticks++;
                                if (f->wait_ticks > 10) {
                                    int trade_city_id;
                                    if (b->data.dock.trade_ship_id) {
                                        trade_city_id = figures[b->data.dock.trade_ship_id].empire_city_id;
                                    } else {
                                        trade_city_id = 0;
                                    }
                                    f->action_state = FIGURE_ACTION_DOCKER_IMPORT_RETURNING;
                                    f->destination_x = f->source_x;
                                    f->destination_y = f->source_y;
                                    f->wait_ticks = 0;
                                    struct building_t *warehouse = &all_buildings[f->destination_building_id];
                                    int try_export_resource = 0;
                                    if (warehouse->type == BUILDING_WAREHOUSE) {
                                        struct building_t *space = warehouse;
                                        for (int k = 0; k < 8; k++) {
                                            space = &all_buildings[space->next_part_building_id];
                                            if (space->id > 0) {
                                                if (space->loads_stored && space->subtype.warehouse_resource_id == f->resource_id) {
                                                    empire_objects[trade_city_id].resource_bought[f->resource_id]++;
                                                    city_resource_remove_from_warehouse(f->resource_id, 1);
                                                    space->loads_stored--;
                                                    if (space->loads_stored <= 0) {
                                                        space->subtype.warehouse_resource_id = RESOURCE_NONE;
                                                    }
                                                    city_finance_process_export(trade_prices[f->resource_id].sell);
                                                    building_warehouse_space_set_image(space, f->resource_id);
                                                    try_export_resource = 1;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (try_export_resource) {
                                        int trader_id = figures[b->data.dock.trade_ship_id].trader_id;
                                        trader_record_bought_resource(trader_id, f->resource_id);
                                        f->action_state = FIGURE_ACTION_DOCKER_EXPORT_RETURNING;
                                    } else {
                                        fetch_export_resource(f, b);
                                    }
                                }
                                f->image_offset = 0;
                                break;
                        }
                        int dir = figure_image_normalize_direction(f->direction < 8 ? f->direction : f->previous_tile_direction);
                        f->image_id = 4338 + dir + 8 * f->image_offset;
                        if (f->cart_image_id) {
                            f->cart_image_id += dir;
                            figure_image_set_cart_offset(f, dir);
                        } else {
                            f->image_id = 0;
                        }
                        break;
                    }
                    case FIGURE_FLOTSAM:
                        if (scenario.river_exit_point.x != -1 && scenario.river_exit_point.y != -1) {
                            f->is_invisible = 0;
                            switch (f->action_state) {
                                case FIGURE_ACTION_FLOTSAM_CREATED:
                                    f->is_invisible = 1;
                                    f->wait_ticks--;
                                    if (f->wait_ticks <= 0) {
                                        f->action_state = FIGURE_ACTION_FLOTSAM_FLOATING;
                                        f->wait_ticks = 0;
                                        int shipwreck_flotsam_created = 0;
                                        if (city_data.religion.neptune_sank_ships) {
                                            city_data.religion.neptune_sank_ships = 0;
                                            shipwreck_flotsam_created = 1;
                                        }
                                        if (!f->resource_id && shipwreck_flotsam_created) {
                                            f->min_max_seen = 1;
                                        }
                                        f->destination_x = scenario.river_exit_point.x;
                                        f->destination_y = scenario.river_exit_point.y;
                                    }
                                    break;
                                case FIGURE_ACTION_FLOTSAM_FLOATING:
                                    if (f->flotsam_visible) {
                                        f->flotsam_visible = 0;
                                    } else {
                                        f->flotsam_visible = 1;
                                        f->wait_ticks++;
                                        walk_ticks(f, 1, 0);
                                        f->is_invisible = 0;
                                        f->height_adjusted_ticks = 0;
                                        if (f->direction == DIR_FIGURE_AT_DESTINATION ||
                                            f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                            f->action_state = FIGURE_ACTION_FLOTSAM_OFF_MAP;
                                        }
                                    }
                                    break;
                                case FIGURE_ACTION_FLOTSAM_OFF_MAP:
                                    f->is_invisible = 1;
                                    f->min_max_seen = 0;
                                    f->action_state = FIGURE_ACTION_FLOTSAM_CREATED;
                                    if (f->wait_ticks >= 400) {
                                        f->wait_ticks = random_data.random1_7bit & 7;
                                    } else if (f->wait_ticks >= 200) {
                                        f->wait_ticks = 50 + (random_data.random1_7bit & 0xf);
                                    } else if (f->wait_ticks >= 100) {
                                        f->wait_ticks = 100 + (random_data.random1_7bit & 0x1f);
                                    } else if (f->wait_ticks >= 50) {
                                        f->wait_ticks = 200 + (random_data.random1_7bit & 0x3f);
                                    } else {
                                        f->wait_ticks = 300 + random_data.random1_7bit;
                                    }
                                    map_figure_delete(f);
                                    f->x = scenario.river_entry_point.x;
                                    f->y = scenario.river_entry_point.y;
                                    f->grid_offset = map_grid_offset(f->x, f->y);
                                    f->cross_country_x = 15 * f->x;
                                    f->cross_country_y = 15 * f->y;
                                    break;
                            }
                            if (f->resource_id == 0) {
                                figure_image_increase_offset(f, 12);
                                if (f->min_max_seen) {
                                    f->image_id = 5572 + FLOTSAM_TYPE_0[f->image_offset];
                                } else {
                                    f->image_id = 5446 + FLOTSAM_TYPE_0[f->image_offset];
                                }
                            } else if (f->resource_id == 1) {
                                figure_image_increase_offset(f, 24);
                                f->image_id = 5452 + FLOTSAM_TYPE_12[f->image_offset];
                            } else if (f->resource_id == 2) {
                                figure_image_increase_offset(f, 24);
                                f->image_id = 5457 + FLOTSAM_TYPE_12[f->image_offset];
                            } else if (f->resource_id == 3) {
                                figure_image_increase_offset(f, 24);
                                if (FLOTSAM_TYPE_3[f->image_offset] == -1) {
                                    f->image_id = 0;
                                } else {
                                    f->image_id = 5462 + FLOTSAM_TYPE_3[f->image_offset];
                                }
                            }
                        }
                        break;
                    case FIGURE_BALLISTA:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        f->is_invisible = 1;
                        f->height_adjusted_ticks = 10;
                        f->current_height = 45;
                        if (b->state != BUILDING_STATE_IN_USE || b->figure_id4 != f->id) {
                            figure_delete(f);
                            return;
                        }
                        if (b->num_workers <= 0 || b->figure_id <= 0) {
                            figure_delete(f);
                            return;
                        }
                        map_figure_delete(f);
                        switch (view_data.orientation) {
                            case DIR_0_TOP: f->x = b->x; f->y = b->y; break;
                            case DIR_2_RIGHT: f->x = b->x + 1; f->y = b->y; break;
                            case DIR_4_BOTTOM: f->x = b->x + 1; f->y = b->y + 1; break;
                            case DIR_6_LEFT: f->x = b->x; f->y = b->y + 1; break;
                        }
                        f->grid_offset = map_grid_offset(f->x, f->y);
                        map_figure_add(f);
                        switch (f->action_state) {
                            case FIGURE_ACTION_BALLISTA_READY:
                            {
                                struct map_point_t tile = { -1, -1 };
                                if (f->is_shooting) {
                                    f->attack_image_offset++;
                                    if (f->attack_image_offset > 100) {
                                        f->attack_image_offset = 0;
                                        f->is_shooting = 0;
                                    }
                                } else {
                                    f->wait_ticks_missile++;
                                    if (f->wait_ticks_missile > 250) {
                                        f->wait_ticks_missile = 250;
                                    }
                                }
                                if (f->wait_ticks_missile > figure_properties[f->type].missile_delay && set_missile_target(f, &tile)) {
                                    f->direction = calc_missile_shooter_direction(f->x, f->y, tile.x, tile.y);
                                    figure_create_missile(f, &tile, figure_properties[f->type].missile_type);
                                    play_sound_effect(SOUND_EFFECT_BALLISTA_SHOOT);
                                    f->wait_ticks_missile = 0;
                                    f->is_shooting = 1;
                                }
                                break;
                            }
                        }
                        int dir = figure_image_direction(f);
                        if (f->action_state == FIGURE_ACTION_BALLISTA_READY) {
                            f->image_id = 5515 + dir + 8 * BALLISTA_FIRING_OFFSETS[f->attack_image_offset / 4];
                        } else {
                            f->image_id = 5515 + dir;
                        }
                        break;
                    }
                    case FIGURE_BOLT:
                    {
                        f->use_cross_country = 1;
                        f->progress_on_tile++;
                        int should_die = figure_movement_move_ticks_cross_country(f, 10);
                        int target_id = get_target_on_tile(f);
                        if (target_id) {
                            struct figure_t *target = &figures[target_id];
                            missile_hit_target(f, target);
                            play_sound_effect(SOUND_EFFECT_BALLISTA_HIT_PERSON);
                        }
                        int dir = (16 + f->direction - 2 * view_data.orientation) % 16;
                        f->image_id = 5499 + dir;
                        if (f->progress_on_tile > 120) {
                            figure_delete(f);
                        }
                        if (should_die || target_id) {
                            play_sound_effect(SOUND_EFFECT_BALLISTA_HIT_GROUND);
                            figure_delete(f);
                        }
                        break;
                    }
                    case FIGURE_TOWER_SENTRY:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        f->height_adjusted_ticks = 10;
                        if (b->state != BUILDING_STATE_IN_USE || b->figure_id != f->id) {
                            figure_delete(f);
                            break;
                        }
                        figure_image_increase_offset(f, 12);
                        switch (f->action_state) {
                            case FIGURE_ACTION_TOWER_SENTRY_AT_REST:
                                f->is_targetable = 0;
                                if (!f->is_military_trained) {
                                    struct map_point_t mil_acad_road = { 0 };
                                    set_destination__closest_building_of_type(f->building_id, BUILDING_MILITARY_ACADEMY, &mil_acad_road);
                                    if (mil_acad_road.x) {
                                        struct map_point_t tower_road;
                                        if (map_has_road_access(b->x, b->y, b->size, &tower_road)) {
                                            f->terrain_usage = TERRAIN_USAGE_ROADS;
                                            f->destination_x = tower_road.x;
                                            f->destination_y = tower_road.y;
                                            walk_ticks(f, 1, 0);
                                            if (f->x == tower_road.x && f->y == tower_road.y) {
                                                f->destination_x = mil_acad_road.x;
                                                f->destination_y = mil_acad_road.y;
                                                f->action_state = FIGURE_ACTION_SOLDIER_GOING_TO_MILITARY_ACADEMY;
                                            }
                                            break;
                                        }
                                    }
                                }
                                f->terrain_usage = TERRAIN_USAGE_WALLS;
                                f->image_offset = 0;
                                f->wait_ticks++;
                                if (f->wait_ticks > 40) {
                                    f->wait_ticks = 0;
                                    int x_tile, y_tile;
                                    int dir = b->figure_roam_direction;
                                    int x = b->x;
                                    int y = b->y;
                                    switch (dir) {
                                        case DIR_0_TOP: y -= 8; break;
                                        case DIR_2_RIGHT: x += 8; break;
                                        case DIR_4_BOTTOM: y += 8; break;
                                        case DIR_6_LEFT: x -= 8; break;
                                    }
                                    map_grid_bound(&x, &y);
                                    if (map_routing_wall_tile_in_radius(x, y, 6, &x_tile, &y_tile)) {
                                        b->figure_roam_direction += 2;
                                        if (b->figure_roam_direction > 6) b->figure_roam_direction = 0;
                                        f->action_state = FIGURE_ACTION_TOWER_SENTRY_PATROLLING;
                                        f->destination_x = x_tile;
                                        f->destination_y = y_tile;
                                        figure_route_remove(f);
                                    }
                                    for (int l = 0; l < 4; l++) {
                                        dir = b->figure_roam_direction;
                                        b->figure_roam_direction += 2;
                                        if (b->figure_roam_direction > 6) b->figure_roam_direction = 0;
                                        x = b->x;
                                        y = b->y;
                                        switch (dir) {
                                            case DIR_0_TOP: y -= 3; break;
                                            case DIR_2_RIGHT: x += 3; break;
                                            case DIR_4_BOTTOM: y += 3; break;
                                            case DIR_6_LEFT: x -= 3; break;
                                        }
                                        map_grid_bound(&x, &y);
                                        if (map_routing_wall_tile_in_radius(x, y, 6, &x_tile, &y_tile)) {
                                            f->action_state = FIGURE_ACTION_TOWER_SENTRY_PATROLLING;
                                            f->destination_x = x_tile;
                                            f->destination_y = y_tile;
                                            figure_route_remove(f);
                                        }
                                    }
                                }
                                break;
                            case FIGURE_ACTION_TOWER_SENTRY_PATROLLING:
                                f->terrain_usage = TERRAIN_USAGE_WALLS;
                                f->wait_ticks_missile++;
                                if (f->wait_ticks_missile > 250) {
                                    f->wait_ticks_missile = 250;
                                }
                                if (tower_sentry_shooting(f)) {
                                    break;
                                } else {
                                    walk_ticks(f, 1, 0);
                                    if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                        f->action_state = FIGURE_ACTION_TOWER_SENTRY_RETURNING;
                                        f->destination_x = f->source_x;
                                        f->destination_y = f->source_y;
                                        figure_route_remove(f);
                                    } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                        f->action_state = FIGURE_ACTION_TOWER_SENTRY_AT_REST;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_TOWER_SENTRY_RETURNING:
                                f->terrain_usage = TERRAIN_USAGE_WALLS;
                                f->wait_ticks_missile++;
                                if (f->wait_ticks_missile > 250) {
                                    f->wait_ticks_missile = 250;
                                }
                                if (tower_sentry_shooting(f)) {
                                    break;
                                } else {
                                    walk_ticks(f, 1, 0);
                                    if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                        f->action_state = FIGURE_ACTION_TOWER_SENTRY_AT_REST;
                                    } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                        figure_delete(f);
                                        break;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_SOLDIER_GOING_TO_MILITARY_ACADEMY:
                                f->is_targetable = 1;
                                f->wait_ticks_missile++;
                                if (f->wait_ticks_missile > 250) {
                                    f->wait_ticks_missile = 250;
                                }
                                if (tower_sentry_shooting(f)) {
                                    break;
                                } else {
                                    figure_route_remove(f);
                                    f->terrain_usage = TERRAIN_USAGE_ROADS;
                                    f->is_military_trained = 1;
                                    f->height_adjusted_ticks = 0;
                                    walk_ticks(f, f->speed_multiplier, 0);
                                    if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                        f->action_state = FIGURE_ACTION_TOWER_SENTRY_GOING_TO_TOWER;
                                    } else if (f->direction == DIR_FIGURE_REROUTE) {
                                        figure_route_remove(f);
                                    } else if (f->direction == DIR_FIGURE_LOST) {
                                        figure_delete(f);
                                        break;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_TOWER_SENTRY_GOING_TO_TOWER:
                                f->is_targetable = 1;
                                f->wait_ticks_missile++;
                                if (f->wait_ticks_missile > 250) {
                                    f->wait_ticks_missile = 250;
                                }
                                if (tower_sentry_shooting(f)) {
                                    break;
                                } else {
                                    f->terrain_usage = TERRAIN_USAGE_ROADS;
                                    f->height_adjusted_ticks = 0;
                                    struct map_point_t road;
                                    if (map_has_road_access(b->x, b->y, b->size, &road)) {
                                        f->destination_x = road.x;
                                        f->destination_y = road.y;
                                    } else {
                                        figure_delete(f);
                                        break;
                                    }
                                    walk_ticks(f, 1, 0);
                                    if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                        map_figure_delete(f);
                                        f->source_x = f->x = b->x;
                                        f->source_y = f->y = b->y;
                                        f->grid_offset = map_grid_offset(f->x, f->y);
                                        map_figure_add(f);
                                        f->action_state = FIGURE_ACTION_TOWER_SENTRY_AT_REST;
                                        figure_route_remove(f);
                                    } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                        figure_delete(f);
                                        break;
                                    }
                                }
                                break;
                        }
                        if (map_terrain_is(f->grid_offset, TERRAIN_WALL)) {
                            f->current_height = 18;
                        } else if (map_terrain_is(f->grid_offset, TERRAIN_GATEHOUSE)) { // in tower
                            f->in_building_wait_ticks = 24;
                        }
                        if (f->in_building_wait_ticks) {
                            f->in_building_wait_ticks--;
                            f->height_adjusted_ticks = 0;
                        }
                        f->image_id = 6705 + figure_image_direction(f) + 8 * f->image_offset;
                    }
                    break;
                    case FIGURE_JAVELIN:
                    {
                        f->use_cross_country = 1;
                        f->progress_on_tile++;
                        int should_die = figure_movement_move_ticks_cross_country(f, 4);
                        int target_id = get_target_on_tile(f);
                        if (target_id) {
                            struct figure_t *target = &figures[target_id];
                            missile_hit_target(f, target);
                            play_sound_effect(SOUND_EFFECT_JAVELIN);
                        }
                        int dir = (16 + f->direction - 2 * view_data.orientation) % 16;
                        f->image_id = 5467 + dir;
                        if (should_die || target_id) {
                            figure_delete(f);
                        }
                        if (f->progress_on_tile > 120) {
                            figure_delete(f);
                        }
                        break;
                    }
                    case FIGURE_PREFECT:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        if (b->state != BUILDING_STATE_IN_USE || b->figure_id != f->id) {
                            figure_delete(f);
                            return;
                        }
                        f->terrain_usage = TERRAIN_USAGE_ROADS;
                        f->use_cross_country = 0;
                        figure_image_increase_offset(f, 12);
                        switch (f->action_state) {
                            case FIGURE_ACTION_PREFECT_CREATED:
                                f->is_invisible = 1;
                                f->image_offset = 0;
                                f->wait_ticks--;
                                if (f->wait_ticks <= 0) {
                                    int x_road, y_road;
                                    if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                        f->action_state = FIGURE_ACTION_PREFECT_ENTERING_EXITING;
                                        figure_movement_set_cross_country_destination(f, x_road, y_road);
                                        f->roam_length = 0;
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_PREFECT_ENTERING_EXITING:
                                f->use_cross_country = 1;
                                f->is_invisible = 1;
                                if (figure_movement_move_ticks_cross_country(f, f->speed_multiplier) == 1) {
                                    if (map_building_at(f->grid_offset) == f->building_id) {
                                        // returned to own building
                                        figure_delete(f);
                                        return;
                                    } else {
                                        f->action_state = FIGURE_ACTION_PREFECT_ROAMING;
                                        figure_movement_init_roaming(f);
                                        f->roam_length = 0;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_PREFECT_ROAMING:
                                f->is_invisible = 0;
                                struct figure_t *target = melee_unit__set_closest_target(f);
                                if (target && calc_maximum_distance(f->x, f->y, b->x, b->y) < PREFECT_LEASH_RANGE) {
                                    f->terrain_usage = TERRAIN_USAGE_ANY;
                                    f->roam_length = figure_properties[f->type].max_roam_length;
                                    f->prefect_recent_guard_duty = 1;
                                    walk_ticks(f, f->speed_multiplier, 0);
                                    if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                        f->action_state = FIGURE_ACTION_PREFECT_RETURNING;
                                    }
                                    break;
                                }
                                if (fight_fire(f)) {
                                    break;
                                }
                                f->roam_length++;
                                if (f->roam_length >= figure_properties[f->type].max_roam_length) {
                                    f->action_state = FIGURE_ACTION_PREFECT_RETURNING;
                                }
                                figure_movement_roam_ticks(f, f->speed_multiplier);
                                break;
                            case FIGURE_ACTION_PREFECT_RETURNING:
                                if (f->prefect_recent_guard_duty) {
                                    f->terrain_usage = TERRAIN_USAGE_ANY;
                                }
                                int x_road, y_road;
                                if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                    f->destination_x = x_road;
                                    f->destination_y = y_road;
                                    figure_route_remove(f);
                                }
                                walk_ticks(f, f->speed_multiplier, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_PREFECT_ENTERING_EXITING;
                                    figure_movement_set_cross_country_destination(f, b->x, b->y);
                                    f->roam_length = 0;
                                    f->prefect_recent_guard_duty = 0;
                                    f->target_figure_id = 0;
                                } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_PREFECT_GOING_TO_FIRE:
                                f->terrain_usage = TERRAIN_USAGE_ANY;
                                walk_ticks(f, f->speed_multiplier, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_PREFECT_AT_FIRE;
                                    figure_route_remove(f);
                                    f->roam_length = 0;
                                    f->wait_ticks = 50;
                                } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_PREFECT_AT_FIRE:
                            {
                                struct building_t *burn = &all_buildings[f->destination_building_id];
                                int distance = calc_maximum_distance(f->x, f->y, burn->x, burn->y);
                                if (burn->state == BUILDING_STATE_IN_USE && burn->type == BUILDING_BURNING_RUIN && distance < 2) {
                                    burn->fire_duration = 32;
                                    play_sound_effect(SOUND_EFFECT_FIRE_SPLASH);
                                } else {
                                    f->wait_ticks = 1;
                                }
                                f->attack_direction = calc_general_direction(f->x, f->y, burn->x, burn->y);
                                if (f->attack_direction >= 8) {
                                    f->attack_direction = 0;
                                }
                                f->wait_ticks--;
                                if (f->wait_ticks <= 0) {
                                    f->wait_ticks_missile = 20;
                                    if (!fight_fire(f)) {
                                        if (map_closest_road_within_radius(b->x, b->y, b->size, 2, &x_road, &y_road)) {
                                            f->action_state = FIGURE_ACTION_PREFECT_RETURNING;
                                            f->destination_x = x_road;
                                            f->destination_y = y_road;
                                            figure_route_remove(f);
                                        } else {
                                            figure_delete(f);
                                            return;
                                        }
                                    }
                                }
                                break;
                            }
                        }
                        // graphic id
                        int dir;
                        if (f->action_state == FIGURE_ACTION_PREFECT_AT_FIRE) {
                            dir = f->attack_direction;
                        } else if (f->direction < 8) {
                            dir = f->direction;
                        } else {
                            dir = f->previous_tile_direction;
                        }
                        dir = figure_image_normalize_direction(dir);
                        switch (f->action_state) {
                            case FIGURE_ACTION_PREFECT_GOING_TO_FIRE:
                                f->image_id = 6345 + dir + 8 * f->image_offset;
                                break;
                            case FIGURE_ACTION_PREFECT_AT_FIRE:
                                f->image_id = 6345 + dir + 96 + 8 * (f->image_offset / 2);
                                break;
                            default:
                                f->image_id = 6193 + dir + 8 * f->image_offset;
                                break;
                        }
                    }
                    break;
                    case FIGURE_FORT_STANDARD:
                        figure_image_increase_offset(f, 16);
                        f->image_id = 5421 - legion_formations[f->formation_id].morale / 5;
                        if (legion_formations[f->formation_id].figure_type == FIGURE_FORT_LEGIONARY) {
                            f->cart_image_id = 5374 + f->image_offset / 2;
                        } else if (legion_formations[f->formation_id].figure_type == FIGURE_FORT_MOUNTED) {
                            f->cart_image_id = 5392 + f->image_offset / 2;
                        } else {
                            f->cart_image_id = 5383 + f->image_offset / 2;
                        }
                        break;
                    case FIGURE_FORT_JAVELIN:
                    case FIGURE_FORT_MOUNTED:
                    case FIGURE_FORT_LEGIONARY:
                    {
                        figure_image_increase_offset(f, 12);
                        struct formation_t *m = &legion_formations[f->formation_id];
                        if (f->is_shooting) {
                            f->attack_image_offset++;
                            if (f->attack_image_offset > 100) {
                                f->attack_image_offset = 0;
                                f->is_shooting = 0;
                            }
                        } else {
                            f->wait_ticks_missile++;
                            if (f->wait_ticks_missile > 250) {
                                f->wait_ticks_missile = 250;
                            }
                        }
                        switch (f->action_state) {
                            case FIGURE_ACTION_SOLDIER_AT_REST:
                                map_figure_update(f);
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_SOLDIER_GOING_TO_FORT:
                                rout_unit(f);
                                break;
                            case FIGURE_ACTION_SOLDIER_RETURNING_TO_BARRACKS:
                                walk_ticks(f, f->speed_multiplier, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                }
                                break;
                            case FIGURE_ACTION_SOLDIER_GOING_TO_STANDARD:
                                walk_ticks(f, f->speed_multiplier, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION || f->direction == DIR_FIGURE_LOST) {
                                    f->action_state = FIGURE_ACTION_SOLDIER_AT_STANDARD;
                                    if (f->type == FIGURE_FORT_LEGIONARY && rand() % 100 == 1) {
                                        play_sound_effect(SOUND_EFFECT_FORMATION_SHIELD);
                                    }
                                    if (m->layout == FORMATION_DOUBLE_LINE_1 || m->layout == FORMATION_SINGLE_LINE_1) {
                                        if (m->standard_y < m->prev_standard_y) {
                                            m->direction = DIR_0_TOP;
                                        } else if (m->standard_y > m->prev_standard_y) {
                                            m->direction = DIR_4_BOTTOM;
                                        }
                                    } else if (m->layout == FORMATION_DOUBLE_LINE_2 || m->layout == FORMATION_SINGLE_LINE_2) {
                                        if (m->standard_x < m->prev_standard_x) {
                                            m->direction = DIR_6_LEFT;
                                        } else if (m->standard_x > m->prev_standard_x) {
                                            m->direction = DIR_2_RIGHT;
                                        }
                                    } else if (m->layout == FORMATION_TORTOISE) {
                                        int dx = (m->standard_x < m->prev_standard_x) ? (m->prev_standard_x - m->standard_x) : (m->standard_x - m->prev_standard_x);
                                        int dy = (m->standard_y < m->prev_standard_y) ? (m->prev_standard_y - m->standard_y) : (m->standard_y - m->prev_standard_y);
                                        if (dx > dy) {
                                            if (m->standard_x < m->prev_standard_x) {
                                                m->direction = DIR_6_LEFT;
                                            } else if (m->standard_x > m->prev_standard_x) {
                                                m->direction = DIR_2_RIGHT;
                                            }
                                        } else {
                                            if (m->standard_y < m->prev_standard_y) {
                                                m->direction = DIR_0_TOP;
                                            } else if (m->standard_y > m->prev_standard_y) {
                                                m->direction = DIR_4_BOTTOM;
                                            }
                                        }
                                    }
                                    m->prev_standard_x = m->standard_x;
                                    m->prev_standard_y = m->standard_y;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                }
                                break;
                            case FIGURE_ACTION_SOLDIER_AT_STANDARD:
                                f->image_offset = 0;
                                map_figure_update(f);
                                if (f->type == FIGURE_FORT_JAVELIN) {
                                    struct map_point_t tile = { -1, -1 };
                                    if (f->wait_ticks_missile > figure_properties[f->type].missile_delay && set_missile_target(f, &tile)) {
                                        f->is_shooting = 1;
                                        f->wait_ticks_missile = 0;
                                        f->attack_image_offset = 1;
                                        f->direction = calc_missile_shooter_direction(f->x, f->y, tile.x, tile.y);
                                        figure_create_missile(f, &tile, figure_properties[f->type].missile_type);
                                    } else {
                                        if (!f->is_shooting) {
                                            f->attack_image_offset = 0;
                                        }
                                    }
                                } else if (f->type == FIGURE_FORT_LEGIONARY) {
                                    // attack adjacent enemy
                                    for (int k = 0; k < 8; k++) {
                                        melee_attack_figure_at_offset(f, f->grid_offset + map_grid_direction_delta(k));
                                    }
                                }
                                break;
                            case FIGURE_ACTION_SOLDIER_GOING_TO_MILITARY_ACADEMY:
                                f->is_military_trained = 1;
                                if (f->type == FIGURE_FORT_MOUNTED) {
                                    f->mounted_charge_ticks = 20;
                                    f->mounted_charge_ticks_max = 20;
                                }
                                walk_ticks(f, f->speed_multiplier, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    if (m->is_at_rest) {
                                        f->action_state = FIGURE_ACTION_SOLDIER_GOING_TO_FORT;
                                    } else {
                                        deploy_legion_unit_to_formation_location(f, m);
                                    }
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_SOLDIER_MOPPING_UP:
                            {
                                struct figure_t *target = melee_unit__set_closest_target(f);
                                if (target) {
                                    walk_ticks(f, f->speed_multiplier, 0);
                                    if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                        figure_route_remove(f);
                                        f->action_state = FIGURE_ACTION_SOLDIER_AT_STANDARD;
                                        f->target_figure_id = 0;
                                    }
                                } else {
                                    f->image_offset = 0;
                                    deploy_legion_unit_to_formation_location(f, m);
                                }
                                break;
                            }
                            case FIGURE_ACTION_SOLDIER_GOING_TO_DISTANT_BATTLE:
                            {
                                f->destination_x = scenario.exit_point.x;
                                f->destination_y = scenario.exit_point.y;
                                walk_ticks(f, f->speed_multiplier, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->is_invisible = 1;
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            }
                            case FIGURE_ACTION_SOLDIER_RETURNING_FROM_DISTANT_BATTLE:
                                f->is_invisible = 0;
                                f->destination_x = m->standard_x + FORMATION_LAYOUT_POSITION_X[FORMATION_AT_REST][f->index_in_formation];
                                f->destination_y = m->standard_y + FORMATION_LAYOUT_POSITION_Y[FORMATION_AT_REST][f->index_in_formation];
                                f->destination_grid_offset = map_grid_offset(f->destination_x, f->destination_y);
                                walk_ticks(f, f->speed_multiplier, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_SOLDIER_AT_REST;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                        }
                        int dir;
                        if (f->is_shooting) {
                            dir = f->direction;
                            m->direction = f->direction;
                        } else if (f->action_state == FIGURE_ACTION_SOLDIER_AT_STANDARD) {
                            dir = m->direction;
                        } else if (f->direction < 8) {
                            dir = f->direction;
                        } else {
                            dir = f->previous_tile_direction;
                        }
                        dir = figure_image_normalize_direction(dir);
                        if (f->type == FIGURE_FORT_JAVELIN) {
                            int image_id = 6849;
                            if (f->action_state == FIGURE_ACTION_SOLDIER_AT_STANDARD) {
                                f->image_id = image_id + 96 + dir + 8 * MISSILE_LAUNCHER_OFFSETS[f->attack_image_offset / 2];
                            } else {
                                f->image_id = image_id + dir + 8 * f->image_offset;
                            }
                        } else if (f->type == FIGURE_FORT_MOUNTED) {
                            int image_id = 8376;
                            f->image_id = image_id + dir + 8 * f->image_offset;
                        } else if (f->type == FIGURE_FORT_LEGIONARY) {
                            int image_id = 7161;
                            if (f->action_state == FIGURE_ACTION_SOLDIER_AT_STANDARD) {
                                if (f->figure_is_halted && m->layout == FORMATION_TORTOISE && m->missile_attack_timeout) {
                                    f->image_id = image_id + dir + 144;
                                } else {
                                    f->image_id = image_id + dir;
                                }
                            } else {
                                f->image_id = image_id + dir + 8 * f->image_offset;
                            }
                        }
                        break;
                    }
                    case FIGURE_MARKET_BUYER:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        if (b->state != BUILDING_STATE_IN_USE || b->figure_id2 != f->id) {
                            figure_delete(f);
                            return;
                        }
                        figure_image_increase_offset(f, 12);
                        switch (f->action_state) {
                            case FIGURE_ACTION_MARKET_BUYER_GOING_TO_STORAGE:
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    if (f->collecting_item_id > 3) {
                                        int resource;
                                        switch (f->collecting_item_id) {
                                            case INVENTORY_POTTERY: resource = RESOURCE_POTTERY; break;
                                            case INVENTORY_FURNITURE: resource = RESOURCE_FURNITURE; break;
                                            case INVENTORY_OIL: resource = RESOURCE_OIL; break;
                                            case INVENTORY_WINE: resource = RESOURCE_WINE; break;
                                            default:
                                                figure_delete(f);
                                                return;
                                        }
                                        struct building_t *warehouse = &all_buildings[f->destination_building_id];
                                        int num_loads;
                                        int stored = building_warehouse_get_amount(warehouse, resource);
                                        if (stored < 2) {
                                            num_loads = stored;
                                        } else {
                                            num_loads = 2;
                                        }
                                        if (num_loads <= 0) {
                                            figure_delete(f);
                                            return;
                                        }
                                        building_warehouse_remove_resource(warehouse, resource, num_loads);
                                        // create delivery boys
                                        int boy1 = create_delivery_boy(f->id, f);
                                        if (num_loads > 1) {
                                            create_delivery_boy(boy1, f);
                                        }
                                    } else {
                                        int resource;
                                        switch (f->collecting_item_id) {
                                            case INVENTORY_WHEAT: resource = RESOURCE_WHEAT; break;
                                            case INVENTORY_VEGETABLES: resource = RESOURCE_VEGETABLES; break;
                                            case INVENTORY_FRUIT: resource = RESOURCE_FRUIT; break;
                                            case INVENTORY_MEAT: resource = RESOURCE_MEAT; break;
                                            default:
                                                figure_delete(f);
                                                return;
                                        }
                                        struct building_t *granary = &all_buildings[f->destination_building_id];
                                        int max_units = (f->collecting_item_id == INVENTORY_WHEAT ? 800 : 600) - all_buildings[f->building_id].data.market.inventory[f->collecting_item_id];
                                        int granary_units = granary->data.granary.resource_stored[resource];
                                        int num_loads;
                                        if (granary_units >= 800) {
                                            num_loads = 8;
                                        } else if (granary_units >= 700) {
                                            num_loads = 7;
                                        } else if (granary_units >= 600) {
                                            num_loads = 6;
                                        } else if (granary_units >= 500) {
                                            num_loads = 5;
                                        } else if (granary_units >= 400) {
                                            num_loads = 4;
                                        } else if (granary_units >= 300) {
                                            num_loads = 3;
                                        } else if (granary_units >= 200) {
                                            num_loads = 2;
                                        } else if (granary_units >= 100) {
                                            num_loads = 1;
                                        } else {
                                            num_loads = 0;
                                        }
                                        if (num_loads > max_units / 100) {
                                            num_loads = max_units / 100;
                                        }
                                        if (num_loads <= 0) {
                                            figure_delete(f);
                                            return;
                                        }
                                        building_granary_remove_resource(granary, resource, 100 * num_loads);
                                        // create delivery boys
                                        int previous_boy = f->id;
                                        for (int k = 0; k < num_loads; k++) {
                                            previous_boy = create_delivery_boy(previous_boy, f);
                                        }
                                    }
                                    f->action_state = FIGURE_ACTION_MARKET_BUYER_RETURNING;
                                    f->destination_x = f->source_x;
                                    f->destination_y = f->source_y;
                                } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                    f->action_state = FIGURE_ACTION_MARKET_BUYER_RETURNING;
                                    f->destination_x = f->source_x;
                                    f->destination_y = f->source_y;
                                    figure_route_remove(f);
                                }
                                break;
                            case FIGURE_ACTION_MARKET_BUYER_RETURNING:
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                }
                                break;
                        }
                        f->image_id = 4234 + figure_image_direction(f) + 8 * f->image_offset;
                        break;
                    }
                    case FIGURE_MARKET_TRADER:
                    {
                        struct building_t *market = &all_buildings[f->building_id];
                        if (market->state != BUILDING_STATE_IN_USE || market->figure_id != f->id) {
                            figure_delete(f);
                            return;
                        }
                        if (f->action_state == FIGURE_ACTION_ROAMING) {
                            // force return on out of stock
                            int max_stock = 0;
                            if (market->id > 0 && market->type == BUILDING_MARKET) {
                                for (int k = INVENTORY_OIL; k <= INVENTORY_FURNITURE; k++) {
                                    int stock = market->data.market.inventory[k];
                                    if (stock > max_stock) {
                                        max_stock = stock;
                                    }
                                }
                            }
                            int stock = building_market_get_max_food_stock(market) + max_stock;
                            if (f->roam_length >= 96 && stock <= 0) {
                                f->roam_length = figure_properties[f->type].max_roam_length;
                            }
                        }
                        roamer_action(f, 1);
                        figure_image_increase_offset(f, 12);
                        f->image_id = 4234 + figure_image_direction(f) + 8 * f->image_offset;
                        break;
                    }
                    case FIGURE_DELIVERY_BOY:
                    {
                        f->is_invisible = 0;
                        figure_image_increase_offset(f, 12);
                        struct figure_t *leader = &figures[f->leading_figure_id];
                        if (f->leading_figure_id <= 0) {
                            figure_delete(f);
                            return;
                        } else {
                            if (figure_is_alive(leader)) {
                                if (leader->type == FIGURE_MARKET_BUYER || leader->type == FIGURE_DELIVERY_BOY) {
                                    figure_movement_follow_ticks(f, 1);
                                } else {
                                    figure_delete(f);
                                    return;
                                }
                            } else { // leader arrived at market, drop resource at market
                                all_buildings[f->building_id].data.market.inventory[f->collecting_item_id] += 100;
                                figure_delete(f);
                                return;
                            }
                        }
                        if (leader->is_invisible) {
                            f->is_invisible = 1;
                        }
                        int dir = figure_image_normalize_direction(f->direction < 8 ? f->direction : f->previous_tile_direction);
                        f->image_id = 5018 + dir + 8 * f->image_offset;
                        break;
                    }
                    case FIGURE_WAREHOUSEMAN:
                    {
                        f->terrain_usage = TERRAIN_USAGE_ROADS;
                        figure_image_increase_offset(f, 12);
                        f->cart_image_id = 0;
                        switch (f->action_state) {
                            case FIGURE_ACTION_WAREHOUSEMAN_CREATED:
                            {
                                struct building_t *b = &all_buildings[f->building_id];
                                if (b->state != BUILDING_STATE_IN_USE || b->figure_id != f->id) {
                                    figure_delete(f);
                                    return;
                                }
                                f->wait_ticks++;
                                if (f->wait_ticks > 2) {
                                    if (all_buildings[f->building_id].type == BUILDING_GRANARY) {
                                        struct map_point_t dst;
                                        int dst_building_id;
                                        struct building_t *granary = &all_buildings[f->building_id];
                                        int min_building_id = 0;
                                        if (!f->resource_id) {
                                            // getting granaryman
                                            struct building_storage_t *s_src = &storages[granary->storage_id].storage;
                                            if (!s_src->empty_all && !scenario.rome_supplies_wheat) {
                                                int is_getting = 0;
                                                if (s_src->resource_state[RESOURCE_WHEAT] == BUILDING_STORAGE_STATE_GETTING ||
                                                        s_src->resource_state[RESOURCE_VEGETABLES] == BUILDING_STORAGE_STATE_GETTING ||
                                                        s_src->resource_state[RESOURCE_FRUIT] == BUILDING_STORAGE_STATE_GETTING ||
                                                        s_src->resource_state[RESOURCE_MEAT] == BUILDING_STORAGE_STATE_GETTING) {
                                                    is_getting = 1;
                                                }
                                                if (is_getting) {
                                                    int min_dist = INFINITE;
                                                    for (int l = 0; l < non_getting_granaries.num_items; l++) {
                                                        b = &all_buildings[non_getting_granaries.building_ids[l]];
                                                        struct building_storage_t *s = &storages[b->storage_id].storage;
                                                        int amount_gettable = 0;
                                                        if (s_src->resource_state[RESOURCE_WHEAT] == BUILDING_STORAGE_STATE_GETTING &&
                                                            s->resource_state[RESOURCE_WHEAT] != BUILDING_STORAGE_STATE_GETTING) {
                                                            amount_gettable += b->data.granary.resource_stored[RESOURCE_WHEAT];
                                                        }
                                                        if (s_src->resource_state[RESOURCE_VEGETABLES] == BUILDING_STORAGE_STATE_GETTING &&
                                                            s->resource_state[RESOURCE_VEGETABLES] != BUILDING_STORAGE_STATE_GETTING) {
                                                            amount_gettable += b->data.granary.resource_stored[RESOURCE_VEGETABLES];
                                                        }
                                                        if (s_src->resource_state[RESOURCE_FRUIT] == BUILDING_STORAGE_STATE_GETTING &&
                                                            s->resource_state[RESOURCE_FRUIT] != BUILDING_STORAGE_STATE_GETTING) {
                                                            amount_gettable += b->data.granary.resource_stored[RESOURCE_FRUIT];
                                                        }
                                                        if (s_src->resource_state[RESOURCE_MEAT] == BUILDING_STORAGE_STATE_GETTING &&
                                                            s->resource_state[RESOURCE_MEAT] != BUILDING_STORAGE_STATE_GETTING) {
                                                            amount_gettable += b->data.granary.resource_stored[RESOURCE_MEAT];
                                                        }
                                                        if (amount_gettable > 0) {
                                                            int dist = calc_maximum_distance(
                                                                b->x + 1, b->y + 1,
                                                                granary->x + 1, granary->y + 1);
                                                            if (amount_gettable <= 400) {
                                                                dist *= 2; // penalty for less food
                                                            }
                                                            if (dist < min_dist) {
                                                                min_dist = dist;
                                                                min_building_id = b->id;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            struct building_t *min = &all_buildings[min_building_id];
                                            dst.x = min->x + 1;
                                            dst.y = min->y + 1;
                                            dst_building_id = min_building_id;
                                            if (dst_building_id) {
                                                f->loads_sold_or_carrying = 0;
                                                set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_GETTING_FOOD, dst_building_id, dst.x, dst.y);
                                            } else {
                                                figure_delete(f);
                                            }
                                            return;
                                        }
                                        // delivering resource
                                        // priority 1: another granary
                                        dst_building_id = building_granary_for_storing(f->x, f->y, f->resource_id, 0, 0, &dst);
                                        if (dst_building_id) {
                                            set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE, dst_building_id, dst.x, dst.y);
                                            building_granary_remove_resource(granary, f->resource_id, 100);
                                            return;
                                        }
                                        // priority 2: warehouse
                                        dst_building_id = building_warehouse_for_storing(0, f->x, f->y, f->resource_id, 0, &dst);
                                        if (dst_building_id) {
                                            set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE, dst_building_id, dst.x, dst.y);
                                            building_granary_remove_resource(granary, f->resource_id, 100);
                                            return;
                                        }
                                        // priority 3: granary even though resource is on stockpile
                                        dst_building_id = building_granary_for_storing(f->x, f->y, f->resource_id, 1, 0, &dst);
                                        if (dst_building_id) {
                                            set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE, dst_building_id, dst.x, dst.y);
                                            building_granary_remove_resource(granary, f->resource_id, 100);
                                            return;
                                        }
                                        // nowhere to go to: kill figure
                                        figure_delete(f);
                                    } else {
                                        struct map_point_t dst;
                                        int dst_building_id = 0;
                                        if (!f->resource_id) {
                                            // getting warehouseman
                                            int min_dist = 10000;
                                            struct building_t *min_building = 0;
                                            for (int l = 1; l < MAX_BUILDINGS; l++) {
                                                struct building_t *bb = &all_buildings[l];
                                                if (bb->state != BUILDING_STATE_IN_USE || bb->type != BUILDING_WAREHOUSE) {
                                                    continue;
                                                }
                                                if (l == b->id) {
                                                    continue;
                                                }
                                                int loads_stored = 0;
                                                struct building_t *space = bb;
                                                struct building_storage_t *s = &storages[bb->storage_id].storage;
                                                for (int t = 0; t < 8; t++) {
                                                    space = &all_buildings[space->next_part_building_id];
                                                    if (space->id > 0 && space->loads_stored > 0) {
                                                        if (space->subtype.warehouse_resource_id == f->collecting_item_id) {
                                                            loads_stored += space->loads_stored;
                                                        }
                                                    }
                                                }
                                                if (loads_stored > 0 && s->resource_state[f->collecting_item_id] != BUILDING_STORAGE_STATE_GETTING) {
                                                    int dist = calc_maximum_distance(bb->x, bb->y, b->x, b->y);
                                                    dist -= 4 * loads_stored;
                                                    if (dist < min_dist) {
                                                        min_dist = dist;
                                                        min_building = bb;
                                                    }
                                                }
                                            }
                                            if (min_building) {
                                                dst.x = min_building->road_access_x;
                                                dst.y = min_building->road_access_y;
                                            }
                                            if (min_building->id) {
                                                f->loads_sold_or_carrying = 0;
                                                set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_GETTING_RESOURCE, min_building->id, dst.x, dst.y);
                                                f->terrain_usage = TERRAIN_USAGE_PREFER_ROADS;
                                            } else {
                                                figure_delete(f);
                                            }
                                            return;
                                        }
                                        // delivering resource
                                        // priority 1: weapons to barracks
                                        if (f->resource_id == RESOURCE_WEAPONS && !city_data.resource.stockpiled[RESOURCE_WEAPONS] && count_data.buildings[BUILDING_BARRACKS].active) {
                                            b = &all_buildings[city_data.building.barracks_building_id];
                                            if (b->loads_stored < 5 && city_data.military.legionary_legions) {
                                                if (map_has_road_access(b->x, b->y, b->size, &dst)) {
                                                    dst_building_id = b->id;
                                                }
                                            }
                                        }
                                        if (dst_building_id) {
                                            set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE, dst_building_id, dst.x, dst.y);
                                            remove_resource_from_warehouse(f);
                                            return;
                                        }
                                        // priority 2: raw materials to workshop
                                        dst_building_id = building_get_workshop_for_raw_material_with_room(f->x, f->y, f->resource_id, &dst);
                                        if (dst_building_id) {
                                            set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE, dst_building_id, dst.x, dst.y);
                                            remove_resource_from_warehouse(f);
                                            return;
                                        }
                                        // priority 3: food to granary
                                        dst_building_id = building_granary_for_storing(f->x, f->y, f->resource_id, 0, 0, &dst);
                                        if (dst_building_id) {
                                            set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE, dst_building_id, dst.x, dst.y);
                                            remove_resource_from_warehouse(f);
                                            return;
                                        }
                                        // priority 4: food to getting granary
                                        if (!scenario.rome_supplies_wheat && resource_is_food(f->resource_id) && !city_data.resource.stockpiled[f->resource_id]) {
                                            int min_dist = INFINITE;
                                            int min_building_id = 0;
                                            for (int k = 1; k < MAX_BUILDINGS; k++) {
                                                b = &all_buildings[k];
                                                if (b->state != BUILDING_STATE_IN_USE || b->type != BUILDING_GRANARY) {
                                                    continue;
                                                }
                                                if (!b->has_road_access) {
                                                    continue;
                                                }
                                                if (calc_percentage(b->num_workers, building_properties[b->type].n_laborers) < 100) {
                                                    continue;
                                                }
                                                struct building_storage_t *s = &storages[b->storage_id].storage;
                                                if (s->resource_state[f->resource_id] != BUILDING_STORAGE_STATE_GETTING || s->empty_all) {
                                                    continue;
                                                }
                                                if (b->data.granary.resource_stored[RESOURCE_NONE] > ONE_LOAD) {
                                                    // there is room
                                                    int dist = calc_maximum_distance(b->x + 1, b->y + 1, f->x, f->y);
                                                    if (dist < min_dist) {
                                                        min_dist = dist;
                                                        min_building_id = k;
                                                    }
                                                }
                                            }
                                            struct building_t *min = &all_buildings[min_building_id];
                                            dst.x = min->x + 1;
                                            dst.y = min->y + 1;
                                            dst_building_id = min_building_id;
                                            if (dst_building_id) {
                                                set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE, dst_building_id, dst.x, dst.y);
                                                remove_resource_from_warehouse(f);
                                                return;
                                            }
                                        }
                                        // priority 5: resource to other warehouse
                                        dst_building_id = building_warehouse_for_storing(f->building_id, f->x, f->y, f->resource_id, 0, &dst);
                                        if (dst_building_id) {
                                            if (dst_building_id == f->building_id) {
                                                figure_delete(f);
                                            } else {
                                                set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE, dst_building_id, dst.x, dst.y);
                                                remove_resource_from_warehouse(f);
                                            }
                                            return;
                                        }
                                        // priority 6: raw material to well-stocked workshop
                                        struct building_t *min_building = 0;
                                        if (!city_data.resource.stockpiled[f->resource_id]) {
                                            int output_type = resource_to_workshop_type(f->resource_id);
                                            if (output_type != WORKSHOP_NONE) {
                                                int min_dist = INFINITE;
                                                for (int k = 1; k < MAX_BUILDINGS; k++) {
                                                    b = &all_buildings[k];
                                                    if (b->state != BUILDING_STATE_IN_USE || !building_is_workshop(b->type)) {
                                                        continue;
                                                    }
                                                    if (!b->has_road_access) {
                                                        continue;
                                                    }
                                                    if (b->subtype.workshop_type == output_type) {
                                                        int dist = 10 * b->loads_stored +
                                                            calc_maximum_distance(b->x, b->y, f->x, f->y);
                                                        if (dist < min_dist) {
                                                            min_dist = dist;
                                                            min_building = b;
                                                        }
                                                    }
                                                }
                                                if (min_building) {
                                                    dst.x = min_building->road_access_x;
                                                    dst.y = min_building->road_access_y;
                                                }
                                            }
                                        }
                                        if (min_building->id) {
                                            set_destination(f, FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE, min_building->id, dst.x, dst.y);
                                            remove_resource_from_warehouse(f);
                                            return;
                                        }
                                        // no destination: kill figure
                                        figure_delete(f);
                                    }
                                }
                                f->image_offset = 0;
                                break;
                            }
                            case FIGURE_ACTION_WAREHOUSEMAN_DELIVERING_RESOURCE:
                                if (f->loads_sold_or_carrying == 1) {
                                    f->cart_image_id = 5266 + 8 * f->resource_id - 8 + resource_image_offset(f->resource_id, RESOURCE_IMAGE_FOOD_CART);
                                } else {
                                    set_cart_graphic(f);
                                }
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_WAREHOUSEMAN_AT_DELIVERY_BUILDING;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_WAREHOUSEMAN_AT_DELIVERY_BUILDING:
                                f->wait_ticks++;
                                if (f->wait_ticks > 4) {
                                    struct building_t *b = &all_buildings[f->destination_building_id];
                                    switch (b->type) {
                                        case BUILDING_GRANARY:
                                            building_granary_add_resource(b, f->resource_id, 0);
                                            break;
                                        case BUILDING_BARRACKS:
                                            b->loads_stored++;
                                            break;
                                        case BUILDING_WAREHOUSE:
                                        case BUILDING_WAREHOUSE_SPACE:
                                            building_warehouse_add_resource(b, f->resource_id);
                                            break;
                                        default: // workshop
                                            building_workshop_add_raw_material(b);
                                            break;
                                    }
                                    // BUG: what if warehouse/granary is full and returns false?
                                    f->action_state = FIGURE_ACTION_WAREHOUSEMAN_RETURNING_EMPTY;
                                    f->wait_ticks = 0;
                                    f->destination_x = f->source_x;
                                    f->destination_y = f->source_y;
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_WAREHOUSEMAN_RETURNING_EMPTY:
                                f->cart_image_id = 4650;
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                }
                                break;
                            case FIGURE_ACTION_WAREHOUSEMAN_GETTING_FOOD:
                                f->cart_image_id = 4650;
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_WAREHOUSEMAN_AT_GRANARY;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_WAREHOUSEMAN_AT_GRANARY:
                                f->wait_ticks++;
                                if (f->wait_ticks > 4) {
                                    struct building_t *src = &all_buildings[f->destination_building_id];
                                    struct building_t *dst = &all_buildings[f->building_id];
                                    struct building_storage_t *s_src = &storages[src->storage_id].storage;
                                    struct building_storage_t *s_dst = &storages[dst->storage_id].storage;
                                    int max_amount = 0;
                                    int max_resource = 0;
                                    if (s_dst->resource_state[RESOURCE_WHEAT] == BUILDING_STORAGE_STATE_GETTING &&
                                            s_src->resource_state[RESOURCE_WHEAT] != BUILDING_STORAGE_STATE_GETTING) {
                                        if (src->data.granary.resource_stored[RESOURCE_WHEAT] > max_amount) {
                                            max_amount = src->data.granary.resource_stored[RESOURCE_WHEAT];
                                            max_resource = RESOURCE_WHEAT;
                                        }
                                    }
                                    if (s_dst->resource_state[RESOURCE_VEGETABLES] == BUILDING_STORAGE_STATE_GETTING &&
                                            s_src->resource_state[RESOURCE_VEGETABLES] != BUILDING_STORAGE_STATE_GETTING) {
                                        if (src->data.granary.resource_stored[RESOURCE_VEGETABLES] > max_amount) {
                                            max_amount = src->data.granary.resource_stored[RESOURCE_VEGETABLES];
                                            max_resource = RESOURCE_VEGETABLES;
                                        }
                                    }
                                    if (s_dst->resource_state[RESOURCE_FRUIT] == BUILDING_STORAGE_STATE_GETTING &&
                                            s_src->resource_state[RESOURCE_FRUIT] != BUILDING_STORAGE_STATE_GETTING) {
                                        if (src->data.granary.resource_stored[RESOURCE_FRUIT] > max_amount) {
                                            max_amount = src->data.granary.resource_stored[RESOURCE_FRUIT];
                                            max_resource = RESOURCE_FRUIT;
                                        }
                                    }
                                    if (s_dst->resource_state[RESOURCE_MEAT] == BUILDING_STORAGE_STATE_GETTING &&
                                            s_src->resource_state[RESOURCE_MEAT] != BUILDING_STORAGE_STATE_GETTING) {
                                        if (src->data.granary.resource_stored[RESOURCE_MEAT] > max_amount) {
                                            max_amount = src->data.granary.resource_stored[RESOURCE_MEAT];
                                            max_resource = RESOURCE_MEAT;
                                        }
                                    }
                                    if (max_amount > 800) {
                                        max_amount = 800;
                                    }
                                    if (max_amount > dst->data.granary.resource_stored[RESOURCE_NONE]) {
                                        max_amount = dst->data.granary.resource_stored[RESOURCE_NONE];
                                    }
                                    building_granary_remove_resource(src, max_resource, max_amount);
                                    f->loads_sold_or_carrying = max_amount / UNITS_PER_LOAD;
                                    f->resource_id = max_resource;
                                    f->action_state = FIGURE_ACTION_WAREHOUSEMAN_RETURNING_WITH_FOOD;
                                    f->wait_ticks = 0;
                                    f->destination_x = f->source_x;
                                    f->destination_y = f->source_y;
                                    figure_route_remove(f);
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_WAREHOUSEMAN_RETURNING_WITH_FOOD:
                                // update graphic
                                if (f->loads_sold_or_carrying <= 0) {
                                    f->cart_image_id = 4650;
                                } else if (f->loads_sold_or_carrying == 1) {
                                    set_cart_graphic(f);
                                } else {
                                    if (f->loads_sold_or_carrying >= 8) {
                                        f->cart_image_id = 5266 + CART_OFFSET_8_LOADS_FOOD[f->resource_id];
                                    } else {
                                        f->cart_image_id = 5266 + CART_OFFSET_MULTIPLE_LOADS_FOOD[f->resource_id];
                                    }
                                    f->cart_image_id += resource_image_offset(f->resource_id, RESOURCE_IMAGE_FOOD_CART);
                                }
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    for (int k = 0; k < f->loads_sold_or_carrying; k++) {
                                        building_granary_add_resource(&all_buildings[f->building_id], f->resource_id, 0);
                                    }
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_WAREHOUSEMAN_GETTING_RESOURCE:
                                f->terrain_usage = TERRAIN_USAGE_PREFER_ROADS;
                                f->cart_image_id = 4650;
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_WAREHOUSEMAN_AT_WAREHOUSE;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_WAREHOUSEMAN_AT_WAREHOUSE:
                                f->terrain_usage = TERRAIN_USAGE_PREFER_ROADS;
                                f->wait_ticks++;
                                if (f->wait_ticks > 4) {
                                    f->loads_sold_or_carrying = 0;
                                    while (f->loads_sold_or_carrying < 4 && 0 == building_warehouse_remove_resource(
                                        &all_buildings[f->destination_building_id], f->collecting_item_id, 1)) {
                                        f->loads_sold_or_carrying++;
                                    }
                                    f->resource_id = f->collecting_item_id;
                                    f->action_state = FIGURE_ACTION_WAREHOUSEMAN_RETURNING_WITH_RESOURCE;
                                    f->wait_ticks = 0;
                                    f->destination_x = f->source_x;
                                    f->destination_y = f->source_y;
                                    figure_route_remove(f);
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_WAREHOUSEMAN_RETURNING_WITH_RESOURCE:
                                f->terrain_usage = TERRAIN_USAGE_PREFER_ROADS;
                                // update graphic
                                if (f->loads_sold_or_carrying <= 0) {
                                    f->cart_image_id = 4650;
                                } else if (f->loads_sold_or_carrying == 1) {
                                    set_cart_graphic(f);
                                } else {
                                    if (f->resource_id == RESOURCE_WHEAT || f->resource_id == RESOURCE_VEGETABLES ||
                                        f->resource_id == RESOURCE_FRUIT || f->resource_id == RESOURCE_MEAT) {
                                        f->cart_image_id = 5266 + CART_OFFSET_MULTIPLE_LOADS_FOOD[f->resource_id];
                                    } else {
                                        f->cart_image_id = 8288 + CART_OFFSET_MULTIPLE_LOADS_NON_FOOD[f->resource_id];
                                    }
                                    f->cart_image_id += resource_image_offset(f->resource_id, RESOURCE_IMAGE_FOOD_CART);
                                }
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    for (int k = 0; k < f->loads_sold_or_carrying; k++) {
                                        building_warehouse_add_resource(&all_buildings[f->building_id], f->resource_id);
                                    }
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                        }
                        update_image_cartpusher(f);
                    }
                    break;
                    case FIGURE_PROTESTER:
                    {
                        figure_image_increase_offset(f, 64);
                        f->wait_ticks++;
                        if (f->wait_ticks > 200) {
                            figure_delete(f);
                            return;
                        }
                        f->image_id = 5929 + CRIMINAL_OFFSETS[f->image_offset / 4] + 104;
                    }
                    break;
                    case FIGURE_CRIMINAL:
                    {
                        figure_image_increase_offset(f, 32);
                        f->wait_ticks++;
                        if (f->wait_ticks > 200) {
                            figure_delete(f);
                            return;
                        }
                        f->image_id = 5929 + CRIMINAL_OFFSETS[f->image_offset / 2] + 104;
                    }
                    break;
                    case FIGURE_RIOTER:
                    {
                        switch (f->action_state) {
                            case FIGURE_ACTION_RIOTER_CREATED:
                                figure_image_increase_offset(f, 32);
                                f->wait_ticks++;
                                if (f->wait_ticks >= 160) {
                                    f->action_state = FIGURE_ACTION_RIOTER_MOVING;
                                    int x_tile, y_tile;
                                    int building_id = formation_rioter_get_target_building(&x_tile, &y_tile);
                                    if (building_id) {
                                        f->destination_x = x_tile;
                                        f->destination_y = y_tile;
                                        f->destination_building_id = building_id;
                                        figure_route_remove(f);
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_RIOTER_MOVING:
                                figure_image_increase_offset(f, 12);
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    int x_tile, y_tile;
                                    int building_id = formation_rioter_get_target_building(&x_tile, &y_tile);
                                    if (building_id) {
                                        f->destination_x = x_tile;
                                        f->destination_y = y_tile;
                                        f->destination_building_id = building_id;
                                        figure_route_remove(f);
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                    f->action_state = FIGURE_ACTION_RIOTER_CREATED;
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_ATTACK) {
                                    if (f->image_offset > 12) {
                                        f->image_offset = 0;
                                    }
                                }
                                break;
                        }
                        int dir;
                        if (f->direction == DIR_FIGURE_ATTACK) {
                            dir = f->attack_direction;
                        } else if (f->direction < 8) {
                            dir = f->direction;
                        } else {
                            dir = f->previous_tile_direction;
                        }
                        dir = figure_image_normalize_direction(dir);
                        if (f->direction == DIR_FIGURE_ATTACK) {
                            f->image_id = 6033 + CRIMINAL_OFFSETS[f->image_offset % 16];
                        } else if (f->action_state == FIGURE_ACTION_RIOTER_MOVING) {
                            f->image_id = 5929 + dir + 8 * f->image_offset;
                        } else {
                            f->image_id = 6033 + CRIMINAL_OFFSETS[f->image_offset / 2];
                        }
                    }
                    break;
                    case FIGURE_TRADE_CARAVAN:
                        f->is_invisible = 0;
                        figure_image_increase_offset(f, 12);
                        switch (f->action_state) {
                            case FIGURE_ACTION_TRADE_CARAVAN_CREATED:
                                f->is_invisible = 1;
                                f->wait_ticks++;
                                if (f->wait_ticks > 20) {
                                    f->wait_ticks = 0;
                                    int x_base, y_base;
                                    if (city_data.building.trade_center_building_id) {
                                        struct building_t *trade_center = &all_buildings[city_data.building.trade_center_building_id];
                                        x_base = trade_center->x;
                                        y_base = trade_center->y;
                                    } else {
                                        x_base = f->x;
                                        y_base = f->y;
                                    }
                                    go_to_next_warehouse(f, x_base, y_base);
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_TRADE_CARAVAN_ARRIVING:
                                walk_ticks(f, 1, 0);
                                switch (f->direction) {
                                    case DIR_FIGURE_AT_DESTINATION:
                                        f->action_state = FIGURE_ACTION_TRADE_CARAVAN_TRADING;
                                        break;
                                    case DIR_FIGURE_REROUTE:
                                        figure_route_remove(f);
                                        break;
                                    case DIR_FIGURE_LOST:
                                        figure_delete(f);
                                        return;
                                }
                                if (all_buildings[f->destination_building_id].state != BUILDING_STATE_IN_USE) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_TRADE_CARAVAN_TRADING:
                                f->wait_ticks++;
                                if (f->wait_ticks > 10) {
                                    f->wait_ticks = 0;
                                    int move_on = 0;
                                    if (figure_trade_caravan_can_buy(f, f->destination_building_id, f->empire_city_id)) {
                                        int resource = trader_get_buy_resource(f->destination_building_id, f->empire_city_id);
                                        if (resource) {
                                            empire_objects[f->empire_city_id].resource_bought[resource]++;
                                            trader_record_bought_resource(f->trader_id, resource);
                                            f->trader_amount_bought++;
                                        } else {
                                            move_on++;
                                        }
                                    } else {
                                        move_on++;
                                    }
                                    if (figure_trade_caravan_can_sell(f, f->destination_building_id, f->empire_city_id)) {
                                        int resource = RESOURCE_NONE;
                                        struct building_t *warehouse = &all_buildings[f->destination_building_id];
                                        if (warehouse->type == BUILDING_WAREHOUSE) {
                                            int resource_to_import = city_data.trade.caravan_import_resource;
                                            int imp = RESOURCE_WHEAT;
                                            while (imp < RESOURCE_TYPES_MAX && !can_import_resource_from_trade_city(f->empire_city_id, resource_to_import)) {
                                                imp++;
                                                resource_to_import = city_trade_next_caravan_import_resource();
                                            }
                                            if (imp < RESOURCE_TYPES_MAX) {
                                                // add to existing bay with room
                                                struct building_t *space = warehouse;
                                                for (int k = 0; k < 8; k++) {
                                                    space = &all_buildings[space->next_part_building_id];
                                                    if (space->id > 0 && space->loads_stored > 0 && space->loads_stored < 4 &&
                                                        space->subtype.warehouse_resource_id == resource_to_import) {
                                                        building_warehouse_space_add_import(space, resource_to_import);
                                                        city_trade_next_caravan_import_resource();
                                                        resource = resource_to_import;
                                                        break;
                                                    }
                                                }
                                                if (!resource) {
                                                    // add to empty bay
                                                    space = warehouse;
                                                    for (int k = 0; k < 8; k++) {
                                                        space = &all_buildings[space->next_part_building_id];
                                                        if (space->id > 0 && !space->loads_stored) {
                                                            building_warehouse_space_add_import(space, resource_to_import);
                                                            city_trade_next_caravan_import_resource();
                                                            resource = resource_to_import;
                                                        }
                                                    }
                                                    if (!resource) {
                                                        // find another importable resource that can be added to this warehouse
                                                        for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                                            city_data.trade.caravan_backup_import_resource++;
                                                            if (city_data.trade.caravan_backup_import_resource >= RESOURCE_TYPES_MAX) {
                                                                city_data.trade.caravan_backup_import_resource = RESOURCE_WHEAT;
                                                            }
                                                            resource_to_import = city_data.trade.caravan_backup_import_resource;
                                                            if (can_import_resource_from_trade_city(f->empire_city_id, resource_to_import)) {
                                                                space = warehouse;
                                                                for (int k = 0; k < 8; k++) {
                                                                    space = &all_buildings[space->next_part_building_id];
                                                                    if (space->id > 0 && space->loads_stored < 4
                                                                        && space->subtype.warehouse_resource_id == resource_to_import) {
                                                                        building_warehouse_space_add_import(space, resource_to_import);
                                                                        resource = resource_to_import;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        if (resource) {
                                            empire_objects[f->empire_city_id].resource_sold[resource]++;
                                            trader_record_sold_resource(f->trader_id, resource);
                                            f->loads_sold_or_carrying++;
                                        } else {
                                            move_on++;
                                        }
                                    } else {
                                        move_on++;
                                    }
                                    if (move_on == 2) {
                                        go_to_next_warehouse(f, f->x, f->y);
                                    }
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_TRADE_CARAVAN_LEAVING:
                                walk_ticks(f, 1, 0);
                                switch (f->direction) {
                                    case DIR_FIGURE_AT_DESTINATION:
                                        f->action_state = FIGURE_ACTION_TRADE_CARAVAN_CREATED;
                                        figure_delete(f);
                                        return;
                                    case DIR_FIGURE_REROUTE:
                                        figure_route_remove(f);
                                        break;
                                    case DIR_FIGURE_LOST:
                                        figure_delete(f);
                                        return;
                                }
                                break;
                        }
                        int dir = figure_image_normalize_direction(f->direction < 8 ? f->direction : f->previous_tile_direction);
                        f->image_id = 4794 + dir + 8 * f->image_offset;
                        break;
                    case FIGURE_TRADE_CARAVAN_DONKEY:
                    {
                        f->is_invisible = 0;
                        figure_image_increase_offset(f, 12);
                        struct figure_t *leader = &figures[f->leading_figure_id];
                        if (f->leading_figure_id <= 0) {
                            figure_delete(f);
                            return;
                        } else {
                            if (leader->type != FIGURE_TRADE_CARAVAN && leader->type != FIGURE_TRADE_CARAVAN_DONKEY) {
                                figure_delete(f);
                                return;
                            } else {
                                figure_movement_follow_ticks(f, 1);
                            }
                        }
                        if (leader->is_invisible) {
                            f->is_invisible = 1;
                        }
                        dir = figure_image_normalize_direction(f->direction < 8 ? f->direction : f->previous_tile_direction);
                        f->image_id = 4794 + dir + 8 * f->image_offset;
                        break;
                    }
                    case FIGURE_TRADE_SHIP:
                        f->is_invisible = 0;
                        figure_image_increase_offset(f, 12);
                        switch (f->action_state) {
                            case FIGURE_ACTION_TRADE_SHIP_CREATED:
                                f->loads_sold_or_carrying = 12;
                                f->trader_amount_bought = 0;
                                f->is_invisible = 1;
                                f->wait_ticks++;
                                if (f->wait_ticks > 20) {
                                    f->wait_ticks = 0;
                                    struct map_point_t tile;
                                    int dock_id = building_dock_get_free_destination(f->id, &tile);
                                    if (dock_id) {
                                        f->destination_building_id = dock_id;
                                        f->action_state = FIGURE_ACTION_TRADE_SHIP_GOING_TO_DOCK;
                                        f->destination_x = tile.x;
                                        f->destination_y = tile.y;
                                    } else if (building_dock_get_queue_destination(&tile)) {
                                        f->action_state = FIGURE_ACTION_TRADE_SHIP_GOING_TO_DOCK_QUEUE;
                                        f->destination_x = tile.x;
                                        f->destination_y = tile.y;
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_TRADE_SHIP_GOING_TO_DOCK:
                                walk_ticks(f, 1, 0);
                                f->height_adjusted_ticks = 0;
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_TRADE_SHIP_MOORED;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    if (!message_data.message_count[MESSAGE_CAT_BLOCKED_DOCK]) {
                                        city_message_post(1, MESSAGE_NAVIGATION_IMPOSSIBLE, 0, 0);
                                        message_data.message_count[MESSAGE_CAT_BLOCKED_DOCK]++;
                                    }
                                    return;
                                }
                                if (all_buildings[f->destination_building_id].state != BUILDING_STATE_IN_USE) {
                                    f->action_state = FIGURE_ACTION_TRADE_SHIP_LEAVING;
                                    f->wait_ticks = 0;
                                    f->destination_x = scenario.river_exit_point.x;
                                    f->destination_y = scenario.river_exit_point.y;
                                }
                                break;
                            case FIGURE_ACTION_TRADE_SHIP_MOORED:
                            {
                                int trade_ship_done_trading = 1;
                                struct building_t *b = &all_buildings[f->destination_building_id];
                                if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_DOCK && b->num_workers > 0) {
                                    for (int k = 0; k < 3; k++) {
                                        if (b->data.dock.docker_ids[k]) {
                                            struct figure_t *docker = &figures[b->data.dock.docker_ids[k]];
                                            if (figure_is_alive(docker) && docker->action_state != FIGURE_ACTION_DOCKER_IDLING) {
                                                trade_ship_done_trading = 0;
                                                break;
                                            }
                                        }
                                    }
                                }
                                int trade_ship_lost_queue = 1;
                                if (b->state == BUILDING_STATE_IN_USE && b->type == BUILDING_DOCK && b->num_workers > 0 && b->data.dock.trade_ship_id == f->id) {
                                    trade_ship_lost_queue = 0;
                                }
                                if (trade_ship_lost_queue) {
                                    f->trade_ship_failed_dock_attempts = 0;
                                    f->action_state = FIGURE_ACTION_TRADE_SHIP_LEAVING;
                                    f->wait_ticks = 0;
                                    f->destination_x = scenario.river_entry_point.x;
                                    f->destination_y = scenario.river_entry_point.y;
                                } else if (trade_ship_done_trading) {
                                    f->trade_ship_failed_dock_attempts = 0;
                                    f->action_state = FIGURE_ACTION_TRADE_SHIP_LEAVING;
                                    f->wait_ticks = 0;
                                    f->destination_x = scenario.river_entry_point.x;
                                    f->destination_y = scenario.river_entry_point.y;
                                    struct building_t *dst = &all_buildings[f->destination_building_id];
                                    dst->data.dock.queued_docker_id = 0;
                                    dst->data.dock.num_ships = 0;
                                }
                                switch (all_buildings[f->destination_building_id].data.dock.orientation) {
                                    case 0: f->direction = DIR_2_RIGHT; break;
                                    case 1: f->direction = DIR_4_BOTTOM; break;
                                    case 2: f->direction = DIR_6_LEFT; break;
                                    default:f->direction = DIR_0_TOP; break;
                                }
                                f->image_offset = 0;
                                message_data.message_count[MESSAGE_CAT_BLOCKED_DOCK] = 0;
                                break;
                            }
                            case FIGURE_ACTION_TRADE_SHIP_GOING_TO_DOCK_QUEUE:
                                walk_ticks(f, 1, 0);
                                f->height_adjusted_ticks = 0;
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_TRADE_SHIP_ANCHORED;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_TRADE_SHIP_ANCHORED:
                                f->wait_ticks++;
                                if (f->wait_ticks > 40) {
                                    struct map_point_t tile;
                                    int dock_id = building_dock_get_free_destination(f->id, &tile);
                                    if (dock_id) {
                                        f->destination_building_id = dock_id;
                                        f->action_state = FIGURE_ACTION_TRADE_SHIP_GOING_TO_DOCK;
                                        f->destination_x = tile.x;
                                        f->destination_y = tile.y;
                                    } else if (map_grid_is_valid_offset(f->grid_offset) ? map_figures.items[f->grid_offset] : 0 != f->id &&
                                        building_dock_get_queue_destination(&tile)) {
                                        f->action_state = FIGURE_ACTION_TRADE_SHIP_GOING_TO_DOCK_QUEUE;
                                        f->destination_x = tile.x;
                                        f->destination_y = tile.y;
                                    }
                                    f->wait_ticks = 0;
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_TRADE_SHIP_LEAVING:
                                walk_ticks(f, 1, 0);
                                f->height_adjusted_ticks = 0;
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_TRADE_SHIP_CREATED;
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                        }
                        dir = figure_image_normalize_direction(f->direction < 8 ? f->direction : f->previous_tile_direction);
                        f->image_id = 4890 + dir;
                        break;
                    case FIGURE_INDIGENOUS_NATIVE:
                    {
                        struct building_t *b = &all_buildings[f->building_id];
                        if (b->state != BUILDING_STATE_IN_USE || b->figure_id != f->id) {
                            figure_delete(f);
                            return;
                        }
                        figure_image_increase_offset(f, 12);
                        switch (f->action_state) {
                            case FIGURE_ACTION_NATIVE_GOING_TO_MEETING_CENTER:
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_NATIVE_RETURNING_FROM_MEETING;
                                    f->destination_x = f->source_x;
                                    f->destination_y = f->source_y;
                                } else if (f->direction == DIR_FIGURE_REROUTE || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_NATIVE_RETURNING_FROM_MEETING:
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION ||
                                    f->direction == DIR_FIGURE_REROUTE ||
                                    f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_NATIVE_CREATED:
                            {
                                f->image_offset = 0;
                                f->wait_ticks++;
                                if (f->wait_ticks > 10 + (f->id & 3)) {
                                    f->wait_ticks = 0;
                                    if (city_data.military.native_attack_duration) {
                                        f->action_state = FIGURE_ACTION_NATIVE_ATTACKING;
                                        struct building_t *min_building = 0;
                                        int min_distance = 10000;
                                        for (int k = 1; k < MAX_BUILDINGS; k++) {
                                            b = &all_buildings[k];
                                            if (b->state != BUILDING_STATE_IN_USE) {
                                                continue;
                                            }
                                            switch (b->type) {
                                                case BUILDING_MISSION_POST:
                                                case BUILDING_FORT_LEGIONARIES:
                                                case BUILDING_FORT_JAVELIN:
                                                case BUILDING_FORT_MOUNTED:
                                                case BUILDING_FORT_GROUND:
                                                case BUILDING_NATIVE_HUT:
                                                case BUILDING_NATIVE_CROPS:
                                                case BUILDING_NATIVE_MEETING:
                                                case BUILDING_WAREHOUSE:
                                                    break;
                                                default:
                                                {
                                                    int distance = calc_maximum_distance(city_data.building.main_native_meeting.x, city_data.building.main_native_meeting.y, b->x, b->y);
                                                    if (distance < min_distance) {
                                                        min_building = b;
                                                        min_distance = distance;
                                                    }
                                                }
                                            }
                                        }
                                        if (min_building) {
                                            f->destination_x = min_building->x;
                                            f->destination_y = min_building->y;
                                        }
                                    } else {
                                        int x_tile, y_tile;
                                        struct building_t *meeting = &all_buildings[b->subtype.native_meeting_center_id];
                                        if (map_terrain_get_adjacent_road_or_clear_land(
                                            meeting->x, meeting->y, meeting->size, &x_tile, &y_tile)) {
                                            f->action_state = FIGURE_ACTION_NATIVE_GOING_TO_MEETING_CENTER;
                                            f->destination_x = x_tile;
                                            f->destination_y = y_tile;
                                        }
                                    }
                                    figure_route_remove(f);
                                }
                                break;
                            }
                            case FIGURE_ACTION_NATIVE_ATTACKING:
                                f->terrain_usage = TERRAIN_USAGE_ENEMY;
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION ||
                                    f->direction == DIR_FIGURE_REROUTE ||
                                    f->direction == DIR_FIGURE_LOST) {
                                    f->action_state = FIGURE_ACTION_NATIVE_CREATED;
                                }
                                break;
                        }
                        dir = get_direction(f);
                        if (f->action_state == FIGURE_ACTION_NATIVE_ATTACKING) {
                            f->image_id = 297 + dir + 8 * f->image_offset;
                        } else {
                            f->image_id = 201 + dir + 8 * f->image_offset;
                        }
                    }
                    break;
                    case FIGURE_NATIVE_TRADER:
                        f->is_invisible = 0;
                        figure_image_increase_offset(f, 12);
                        f->cart_image_id = 0;
                        switch (f->action_state) {
                            case FIGURE_ACTION_NATIVE_TRADER_GOING_TO_WAREHOUSE:
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION) {
                                    f->action_state = FIGURE_ACTION_NATIVE_TRADER_AT_WAREHOUSE;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                } else if (f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                }
                                if (all_buildings[f->destination_building_id].state != BUILDING_STATE_IN_USE) {
                                    figure_delete(f);
                                    return;
                                }
                                break;
                            case FIGURE_ACTION_NATIVE_TRADER_RETURNING:
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION || f->direction == DIR_FIGURE_LOST) {
                                    figure_delete(f);
                                    return;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                }
                                break;
                            case FIGURE_ACTION_NATIVE_TRADER_CREATED:
                                f->is_invisible = 1;
                                f->wait_ticks++;
                                if (f->wait_ticks > 10) {
                                    f->wait_ticks = 0;
                                    struct map_point_t tile;
                                    int building_id = get_closest_warehouse(f, f->x, f->y, 0, &tile);
                                    if (building_id) {
                                        f->action_state = FIGURE_ACTION_NATIVE_TRADER_GOING_TO_WAREHOUSE;
                                        f->destination_building_id = building_id;
                                        f->destination_x = tile.x;
                                        f->destination_y = tile.y;
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                f->image_offset = 0;
                                break;
                            case FIGURE_ACTION_NATIVE_TRADER_AT_WAREHOUSE:
                                f->wait_ticks++;
                                if (f->wait_ticks > 10) {
                                    f->wait_ticks = 0;
                                    if (figure_trade_caravan_can_buy(f, f->destination_building_id, 0)) {
                                        int resource = trader_get_buy_resource(f->destination_building_id, 0);
                                        trader_record_bought_resource(f->trader_id, resource);
                                        f->trader_amount_bought += 3;
                                    } else {
                                        struct map_point_t tile;
                                        int building_id = get_closest_warehouse(f, f->x, f->y, 0, &tile);
                                        if (building_id) {
                                            f->action_state = FIGURE_ACTION_NATIVE_TRADER_GOING_TO_WAREHOUSE;
                                            f->destination_building_id = building_id;
                                            f->destination_x = tile.x;
                                            f->destination_y = tile.y;
                                        } else {
                                            f->action_state = FIGURE_ACTION_NATIVE_TRADER_RETURNING;
                                            f->destination_x = f->source_x;
                                            f->destination_y = f->source_y;
                                        }
                                    }
                                }
                                f->image_offset = 0;
                                break;
                        }
                        dir = figure_image_normalize_direction(f->direction < 8 ? f->direction : f->previous_tile_direction);
                        f->image_id = 4338 + dir + 8 * f->image_offset;
                        f->cart_image_id = 4786 + 8 * f->resource_id;
                        if (f->cart_image_id) {
                            f->cart_image_id += dir;
                            figure_image_set_cart_offset(f, dir);
                        }
                        break;
                    case FIGURE_WOLF:
                    {
                        struct formation_t *m = &herd_formations[f->formation_id];
                        figure_image_increase_offset(f, 12);
                        switch (f->action_state) {
                            case FIGURE_ACTION_HERD_ANIMAL_AT_REST:
                                // replenish wolf pack
                                if (m->num_figures < m->max_figures) {
                                    m->wolf_spawn_delay++;
                                    if (m->wolf_spawn_delay > 1500) {
                                        int spawn_location_x = m->destination_x + HERD_FORMATION_LAYOUT_POSITION_X_OFFSETS[WOLF_PACK_SIZE - 1];
                                        int spawn_location_y = m->destination_y + HERD_FORMATION_LAYOUT_POSITION_Y_OFFSETS[WOLF_PACK_SIZE - 1];
                                        if (!map_terrain_is(map_grid_offset(spawn_location_x, spawn_location_y), TERRAIN_IMPASSABLE)) {
                                            struct figure_t *wolf = figure_create(m->figure_type, spawn_location_x, spawn_location_y, f->direction);
                                            wolf->action_state = FIGURE_ACTION_HERD_ANIMAL_AT_REST;
                                            wolf->formation_id = m->id;
                                            m->wolf_spawn_delay = 0;
                                        }
                                    }
                                }
                                break;
                            case FIGURE_ACTION_HERD_ANIMAL_MOVING:
                            {
                                struct figure_t *target = melee_unit__set_closest_target(f);
                                if (target) {
                                    walk_ticks(f, 2, 0);
                                    random_generate_next();
                                    if (random_data.random1_7bit < 3) {
                                        play_sound_effect(SOUND_EFFECT_WOLF_HOWL);
                                    }
                                    break;
                                } else {
                                    walk_ticks(f, 2, 0);
                                    if (f->direction == DIR_FIGURE_AT_DESTINATION || f->direction == DIR_FIGURE_LOST) {
                                        f->direction = f->previous_tile_direction;
                                        f->action_state = FIGURE_ACTION_HERD_ANIMAL_AT_REST;
                                        break;
                                    } else if (f->direction == DIR_FIGURE_REROUTE) {
                                        figure_route_remove(f);
                                        break;
                                    } else if (f->routing_path_current_tile > MAX_WOLF_ROAM_DISTANCE * 2) {
                                        figure_route_remove(f);
                                        m->destination_x = f->x;
                                        m->destination_y = f->y;
                                    }
                                }
                                break;
                            }
                        }
                        dir = figure_image_direction(f);
                        if (f->action_state == FIGURE_ACTION_HERD_ANIMAL_AT_REST) {
                            f->image_id = 8792 + dir;
                        } else {
                            f->image_id = 8640 + dir + 8 * f->image_offset;
                        }
                    }
                    break;
                    case FIGURE_SHEEP:
                    {
                        figure_image_increase_offset(f, 6);
                        struct formation_t *m = &herd_formations[f->formation_id];
                        switch (f->action_state) {
                            case FIGURE_ACTION_HERD_ANIMAL_AT_REST:
                                f->wait_ticks++;
                                break;
                            case FIGURE_ACTION_HERD_ANIMAL_MOVING:
                                walk_ticks(f, 2, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION || f->direction == DIR_FIGURE_LOST) {
                                    f->direction = f->previous_tile_direction;
                                    f->action_state = FIGURE_ACTION_HERD_ANIMAL_AT_REST;
                                    f->wait_ticks = f->id & 0x1f;
                                    break;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                    break;
                                } else if (f->routing_path_current_tile > MAX_SHEEP_ROAM_DISTANCE * 2) {
                                    figure_route_remove(f);
                                    m->destination_x = f->x;
                                    m->destination_y = f->y;
                                }
                                break;
                        }
                        dir = figure_image_direction(f);
                        if (f->action_state == FIGURE_ACTION_HERD_ANIMAL_AT_REST) {
                            if (f->id & 3) {
                                f->image_id = 8576 + dir + 8 * SHEEP_IMAGE_OFFSETS[f->wait_ticks & 0x3f];
                            } else {
                                f->image_id = 8624 + dir;
                            }
                        } else {
                            f->image_id = 8528 + dir + 8 * f->image_offset;
                        }
                    }
                    break;
                    case FIGURE_ZEBRA:
                    {
                        figure_image_increase_offset(f, 12);
                        struct formation_t *m = &herd_formations[f->formation_id];
                        switch (f->action_state) {
                            case FIGURE_ACTION_HERD_ANIMAL_AT_REST:
                                break;
                            case FIGURE_ACTION_HERD_ANIMAL_MOVING:
                                walk_ticks(f, 2, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION || f->direction == DIR_FIGURE_LOST) {
                                    f->direction = f->previous_tile_direction;
                                    f->action_state = FIGURE_ACTION_HERD_ANIMAL_AT_REST;
                                    break;
                                } else if (f->direction == DIR_FIGURE_REROUTE) {
                                    figure_route_remove(f);
                                    break;
                                } else if (f->routing_path_current_tile > MAX_SHEEP_ROAM_DISTANCE * 2) {
                                    figure_route_remove(f);
                                    m->destination_x = f->x;
                                    m->destination_y = f->y;
                                }
                                break;
                        }
                        dir = figure_image_direction(f);
                        if (f->action_state == FIGURE_ACTION_HERD_ANIMAL_AT_REST) {
                            f->image_id = 8800 + dir;
                        } else {
                            f->image_id = 8800 + dir + 8 * f->image_offset;
                        }
                    }
                    break;
                    case FIGURE_ENEMY_GLADIATOR:
                    {
                        figure_image_increase_offset(f, 12);
                        if (scenario.gladiator_revolt.state == EVENT_FINISHED) {
                            // end of gladiator revolt: kill gladiators
                            f->is_corpse = 1;
                            f->is_targetable = 0;
                            f->wait_ticks = 0;
                            f->direction = 0;
                            clear_targeting_on_unit_death(f);
                        }
                        switch (f->action_state) {
                            case FIGURE_ACTION_NATIVE_CREATED:
                                f->image_offset = 0;
                                f->wait_ticks++;
                                if (f->wait_ticks > 10 + (f->id & 3)) {
                                    f->wait_ticks = 0;
                                    f->action_state = FIGURE_ACTION_NATIVE_ATTACKING;
                                    int x_tile, y_tile;
                                    int building_id = formation_rioter_get_target_building(&x_tile, &y_tile);
                                    if (building_id) {
                                        f->destination_x = x_tile;
                                        f->destination_y = y_tile;
                                        f->destination_building_id = building_id;
                                        figure_route_remove(f);
                                    } else {
                                        figure_delete(f);
                                        return;
                                    }
                                }
                                break;
                            case FIGURE_ACTION_NATIVE_ATTACKING:
                                f->terrain_usage = TERRAIN_USAGE_ENEMY;
                                walk_ticks(f, 1, 0);
                                if (f->direction == DIR_FIGURE_AT_DESTINATION ||
                                    f->direction == DIR_FIGURE_REROUTE ||
                                    f->direction == DIR_FIGURE_LOST) {
                                    f->action_state = FIGURE_ACTION_NATIVE_CREATED;
                                }
                                break;
                        }
                        dir = get_direction(f);
                        f->image_id = 5579 + dir + 8 * f->image_offset;
                    }
                    break;
                    case FIGURE_ENEMY_BARBARIAN_SWORDSMAN:
                    case FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN:
                    case FIGURE_ENEMY_BRITON_SWORDSMAN:
                    case FIGURE_ENEMY_CELT_SWORDSMAN:
                    case FIGURE_ENEMY_PICT_SWORDSMAN:
                    case FIGURE_ENEMY_EGYPTIAN_SWORDSMAN:
                    case FIGURE_ENEMY_ETRUSCAN_SWORDSMAN:
                    case FIGURE_ENEMY_SAMNITE_SWORDSMAN:
                    case FIGURE_ENEMY_GAUL_SWORDSMAN:
                    case FIGURE_ENEMY_HELVETIUS_SWORDSMAN:
                    case FIGURE_ENEMY_HUN_SWORDSMAN:
                    case FIGURE_ENEMY_GOTH_SWORDSMAN:
                    case FIGURE_ENEMY_VISIGOTH_SWORDSMAN:
                    case FIGURE_ENEMY_NUMIDIAN_SWORDSMAN:
                    case FIGURE_ENEMY_GREEK_SWORDSMAN:
                    case FIGURE_ENEMY_MACEDONIAN_SWORDSMAN:
                    case FIGURE_ENEMY_PERGAMUM_SWORDSMAN:
                    case FIGURE_ENEMY_IBERIAN_SWORDSMAN:
                    case FIGURE_ENEMY_JUDEAN_SWORDSMAN:
                    case FIGURE_ENEMY_SELEUCID_SWORDSMAN:
                    {
                        figure_image_increase_offset(f, 12);
                        melee_enemy_action(f);
                        dir = get_direction(f);
                        int image_id;
                        if (f->enemy_image_group == ENEMY_IMG_TYPE_BARBARIAN) {
                            image_id = 297;
                        } else {
                            image_id = 449;
                        }
                        f->image_id = image_id + dir + 8 * f->image_offset;
                    }
                    break;
                    case FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT:
                    {
                        figure_image_increase_offset(f, 12);
                        ranged_enemy_action(f);
                        f->image_id = 601 + get_direction(f) + 8 * f->image_offset;
                    }
                    break;
                    case FIGURE_ENEMY_BRITON_CHARIOT:
                    case FIGURE_ENEMY_CELT_CHARIOT:
                    case FIGURE_ENEMY_PICT_CHARIOT:
                    {
                        figure_image_increase_offset(f, 12);
                        melee_enemy_action(f);
                        dir = get_direction(f);
                        f->image_id = 601 + dir + 8 * f->image_offset;
                    }
                    break;
                    case FIGURE_ENEMY_EGYPTIAN_CAMEL:
                    case FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_SAMNITE_SPEAR_THROWER:
                    case FIGURE_ENEMY_GREEK_SPEAR_THROWER:
                    case FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_PERGAMUM_ARCHER:
                    case FIGURE_ENEMY_IBERIAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_JUDEAN_SPEAR_THROWER:
                    case FIGURE_ENEMY_SELEUCID_SPEAR_THROWER:
                    {
                        figure_image_increase_offset(f, 12);
                        ranged_enemy_action(f);
                        dir = get_direction(f);
                        if (f->action_state == FIGURE_ACTION_ENEMY_REGROUPING) {
                            f->image_id = 697 + dir + 8 * MISSILE_LAUNCHER_OFFSETS[f->attack_image_offset / 2];
                        } else {
                            f->image_id = 601 + dir + 8 * f->image_offset;
                        }
                    }
                    break;
                    case FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER:
                    {
                        figure_image_increase_offset(f, 12);
                        ranged_enemy_action(f);
                        dir = get_direction(f);
                        if (f->action_state == FIGURE_ACTION_ENEMY_REGROUPING) {
                            f->image_id = 545 + dir + 8 * MISSILE_LAUNCHER_OFFSETS[f->attack_image_offset / 2];
                        } else {
                            f->image_id = 449 + dir + 8 * f->image_offset;
                        }
                    }
                    break;
                    case FIGURE_ENEMY_GAUL_AXEMAN:
                    case FIGURE_ENEMY_HELVETIUS_AXEMAN:
                    {
                        figure_image_increase_offset(f, 12);
                        melee_enemy_action(f);
                        dir = get_direction(f);
                        f->image_id = 601 + dir + 8 * f->image_offset;
                    }
                    break;
                    case FIGURE_ENEMY_HUN_MOUNTED_ARCHER:
                    case FIGURE_ENEMY_GOTH_MOUNTED_ARCHER:
                    case FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER:
                    {
                        figure_image_increase_offset(f, 12);
                        ranged_enemy_action(f);
                        dir = get_direction(f);
                        if (f->action_state == FIGURE_ACTION_ENEMY_REGROUPING) {
                            f->image_id = 697 + dir + 8 * MISSILE_LAUNCHER_OFFSETS[f->attack_image_offset / 2];
                        } else {
                            f->image_id = 601 + dir + 8 * f->image_offset;
                        }
                    }
                    break;
                    case FIGURE_ENEMY_CAESAR_JAVELIN:
                    case FIGURE_ENEMY_CAESAR_MOUNTED:
                    case FIGURE_ENEMY_CAESAR_LEGIONARY:
                        figure_image_increase_offset(f, 12);
                        melee_enemy_action(f);
                        dir = get_direction(f);
                        int img_group_base_id = 7001;

                        if (f->direction == DIR_FIGURE_ATTACK) {
                            f->image_id = img_group_base_id + dir + 8 * ((f->attack_image_offset - 12) / 2);
                        }
                        if (f->figure_is_halted && enemy_formations[f->formation_id].missile_attack_timeout) {
                            f->image_id = img_group_base_id + 144 + dir + 8 * f->image_offset;
                        } else {
                            f->image_id = img_group_base_id + 48 + dir + 8 * f->image_offset;
                        }
                        break;
                    case FIGURE_ARROW:
                        f->use_cross_country = 1;
                        f->progress_on_tile++;
                        int should_die = figure_movement_move_ticks_cross_country(f, 8);
                        int target_id = get_target_on_tile(f);
                        if (target_id) {
                            struct figure_t *target = &figures[target_id];
                            missile_hit_target(f, target);
                            play_sound_effect(SOUND_EFFECT_ARROW_HIT);
                        }
                        dir = (16 + f->direction - 2 * view_data.orientation) % 16;
                        f->image_id = 5483 + dir;
                        if (f->progress_on_tile > 120) {
                            figure_delete(f);
                        }
                        if (should_die || target_id) {
                            figure_delete(f);
                        }
                        break;
                    case FIGURE_EXPLOSION:
                        f->use_cross_country = 1;
                        f->progress_on_tile++;
                        if (f->progress_on_tile > 44) {
                            figure_delete(f);
                            return;
                        }
                        figure_movement_move_ticks_cross_country(f, f->speed_multiplier);
                        if (f->progress_on_tile < 48) {
                            f->image_id = 5354 + CLOUD_IMAGE_OFFSETS[f->progress_on_tile / 2];
                        } else {
                            f->image_id = 5361;
                        }
                        break;
                    default:
                        break;
                }
            }
        }
    }
}

static void update_screen(void)
{
    SDL_RenderClear(SDL.renderer);
    SDL_UpdateTexture(SDL.texture, 0, canvas.pixels, current_resolution_width * 4);
    SDL_RenderCopy(SDL.renderer, SDL.texture, 0, 0);
    SDL_RenderPresent(SDL.renderer);
}

static void resize_screen(int pixel_width, int pixel_height)
{
    SDL.texture = SDL_CreateTexture(SDL.renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STREAMING, pixel_width, pixel_height);
    current_resolution_width = pixel_width;
    current_resolution_height = pixel_height;
    current_resolution_aspect_ratio = (float) pixel_width / (float) pixel_height;
    map_y_max = current_resolution_height - TOP_BAR_HEIGHT;
    screen_center_x = current_resolution_width / 2;
    screen_center_y = current_resolution_height / 2;
    if (settings[SETTINGS_SIDEBAR_EXPANDED].config_value) {
        sidebar_x_offset = current_resolution_width - SIDEBAR_EXPANDED_WIDTH;
        map_center_x = (sidebar_x_offset) / 2;
    } else {
        sidebar_x_offset = current_resolution_width - SIDEBAR_COLLAPSED_WIDTH;
        map_center_x = (sidebar_x_offset) / 2;
    }
    map_center_y = (current_resolution_height - TOP_BAR_HEIGHT) / 2;
    switch (current_window) {
        case WINDOW_MAIN_MENU:
            scale_main_menu_buttons();
            break;
    }
    if (SDL.texture) {
        screen_set_resolution(pixel_width, pixel_height);
    }
    refresh_current_window = 1;
}

static void close_hotkey_editor_window(int accept_new_hotkey)
{
    if (accept_new_hotkey) {
        // clear conflicting mappings
        for (int i = 0; i < HOTKEY_CONFIGS_NUMBER_ROWS; i++) {
            if (hotkey_mappings[i].sdl_mods == hotkey_config_window_data.modifiers && hotkey_mappings[i].sdl_key == hotkey_config_window_data.key) {
                hotkey_mappings[i].sdl_mods = KMOD_NONE;
                hotkey_mappings[i].sdl_key = 0;
            }
        }
        // set new mapping
        hotkey_mappings[hotkey_config_window_data.action_index].sdl_mods = hotkey_config_window_data.modifiers;
        hotkey_mappings[hotkey_config_window_data.action_index].sdl_key = hotkey_config_window_data.key;
    }
    hotkey_config_window_data.modifiers = 0;
    hotkey_config_window_data.key = 0;
    change_window(WINDOW_HOTKEY_CONFIGS);
}

static void start_scenario(void)
{
    if (game_file_start_scenario(cck_selection_data.selected_scenario_filename)) {
        update_music(1);
        change_window(WINDOW_MISSION_BRIEFING);
    }
}

static void sort_editor_requests(void)
{
    for (int i = 0; i < MAX_REQUESTS; i++) {
        for (int j = MAX_REQUESTS - 1; j > 0; j--) {
            if (scenario.requests[j].resource) {
                // if no previous request scheduled, move current back until first; if previous request is later than current, swap
                if (!scenario.requests[j - 1].resource || scenario.requests[j - 1].year_offset > scenario.requests[j].year_offset
                || (scenario.requests[j - 1].year_offset == scenario.requests[j].year_offset && scenario.requests[j - 1].month > scenario.requests[j].month)) {
                    struct request_t tmp = scenario.requests[j];
                    scenario.requests[j] = scenario.requests[j - 1];
                    scenario.requests[j - 1] = tmp;
                }
            }
        }
    }
}

static void sort_custom_messages(void)
{
    for (int i = 0; i < MAX_EDITOR_CUSTOM_MESSAGES; i++) {
        for (int j = MAX_EDITOR_CUSTOM_MESSAGES - 1; j > 0; j--) {
            if (scenario.editor_custom_messages[j].enabled) {
                // if no previous custom message scheduled, move current back until first; if previous custom message is later than current, swap
                if (!scenario.editor_custom_messages[j - 1].enabled || scenario.editor_custom_messages[j - 1].year_offset > scenario.editor_custom_messages[j].year_offset
                || (scenario.editor_custom_messages[j - 1].year_offset == scenario.editor_custom_messages[j].year_offset && scenario.editor_custom_messages[j - 1].month > scenario.editor_custom_messages[j].month)) {
                    struct editor_custom_messages_t tmp = scenario.editor_custom_messages[j];
                    scenario.editor_custom_messages[j] = scenario.editor_custom_messages[j - 1];
                    scenario.editor_custom_messages[j - 1] = tmp;
                }
            }
        }
    }
}

static void sort_earthquakes(void)
{
    for (int i = 0; i < MAX_EARTHQUAKES; i++) {
        for (int j = MAX_EARTHQUAKES - 1; j > 0; j--) {
            if (scenario.earthquakes[j].state) {
                // if no previous earthquake scheduled, move current back until first; if previous earthquake is later than current, swap
                if (!scenario.earthquakes[j - 1].state || scenario.earthquakes[j - 1].year_offset > scenario.earthquakes[j].year_offset
                || (scenario.earthquakes[j - 1].year_offset == scenario.earthquakes[j].year_offset && scenario.earthquakes[j - 1].month > scenario.earthquakes[j].month)) {
                    struct earthquake_t tmp = scenario.earthquakes[j];
                    scenario.earthquakes[j] = scenario.earthquakes[j - 1];
                    scenario.earthquakes[j - 1] = tmp;
                }
            }
        }
    }
}

static void sort_invasions(void)
{
    for (int i = 0; i < MAX_INVASIONS; i++) {
        for (int j = MAX_INVASIONS - 1; j > 0; j--) {
            if (scenario.invasions[j].type) {
                // if no previous invasion scheduled, move current back until first; if previous invasion is later than current, swap
                if (!scenario.invasions[j - 1].type || scenario.invasions[j - 1].year_offset > scenario.invasions[j].year_offset
                || (scenario.invasions[j - 1].year_offset == scenario.invasions[j].year_offset && scenario.invasions[j - 1].month > scenario.invasions[j].month)) {
                    struct invasion_t tmp = scenario.invasions[j];
                    scenario.invasions[j] = scenario.invasions[j - 1];
                    scenario.invasions[j - 1] = tmp;
                }
            }
        }
    }
}

static void sort_price_changes(void)
{
    for (int i = 0; i < MAX_PRICE_CHANGES; i++) {
        for (int j = MAX_PRICE_CHANGES - 1; j > 0; j--) {
            if (scenario.price_changes[j].resource) {
                // if no previous price change scheduled, move current back until first; if previous price change is later than current, swap
                if (!scenario.price_changes[j - 1].resource || scenario.price_changes[j - 1].year_offset > scenario.price_changes[j].year_offset
                || (scenario.price_changes[j - 1].year_offset == scenario.price_changes[j].year_offset && scenario.price_changes[j - 1].month > scenario.price_changes[j].month)) {
                    struct price_change_t tmp = scenario.price_changes[j];
                    scenario.price_changes[j] = scenario.price_changes[j - 1];
                    scenario.price_changes[j - 1] = tmp;
                }
            }
        }
    }
}

static void sort_demand_changes(void)
{
    for (int i = 0; i < MAX_DEMAND_CHANGES; i++) {
        for (int j = MAX_DEMAND_CHANGES - 1; j > 0; j--) {
            if (scenario.demand_changes[j].resource) {
                // if no previous demand change scheduled, move current back until first; if previous demand change is later than current, swap
                if (!scenario.demand_changes[j - 1].resource || scenario.demand_changes[j - 1].year_offset > scenario.demand_changes[j].year_offset
                || (scenario.demand_changes[j - 1].year_offset == scenario.demand_changes[j].year_offset && scenario.demand_changes[j - 1].month > scenario.demand_changes[j].month)) {
                    struct demand_change_t tmp = scenario.demand_changes[j];
                    scenario.demand_changes[j] = scenario.demand_changes[j - 1];
                    scenario.demand_changes[j - 1] = tmp;
                }
            }
        }
    }
}

static void handle_overlay_hotkey(int overlay)
{
    if (state_data.current_overlay == overlay) {
        game_state_set_overlay(OVERLAY_NONE);
    } else {
        game_state_set_overlay(overlay);
    }
    select_city_overlay();
    // window_invalidate();
}

static void handle_go_to_bookmark_hotkey(int bookmark)
{
    if (bookmark - 1 >= 0 && bookmark - 1 < MAX_BOOKMARKS) {
        int x = bookmarks[bookmark - 1].x;
        int y = bookmarks[bookmark - 1].y;
        if (x > -1 && map_grid_offset(x, y) > -1) {
            city_view_set_camera(x, y);
            // window_invalidate();
        }
    }
}

static void handle_set_bookmark_hotkey(int bookmark)
{
    if (bookmark - 1 >= 0 && bookmark - 1 < MAX_BOOKMARKS) {
        city_view_get_camera(&bookmarks[bookmark - 1].x, &bookmarks[bookmark - 1].y);
    }
}

static void handle_set_building_hotkey(int building)
{
    if (building == BUILDING_CLEAR_LAND
    || (building == BUILDING_TRIUMPHAL_ARCH && city_data.building.triumphal_arches_available && scenario.allowed_buildings[building])
    || (building != BUILDING_TRIUMPHAL_ARCH && scenario.allowed_buildings[building])) {
        set_construction_building_type(building);
    }
}

static void set_default_configs(void)
{
    string_copy("BRUTUS", configs_player_name, MAX_PLAYER_NAME_LENGTH);
    configs[CONFIG_UI_SIDEBAR_INFO].config_value = 1;
    configs[CONFIG_UI_SHOW_INTRO_VIDEOS].config_value = 0;
    configs[CONFIG_UI_DISABLE_MOUSE_EDGE_SCROLLING].config_value = 0;
    configs[CONFIG_UI_DISABLE_RIGHT_CLICK_MAP_DRAG].config_value = 0;
    configs[CONFIG_UI_VISUAL_FEEDBACK_ON_DELETE].config_value = 1;
    configs[CONFIG_UI_HIGHLIGHT_LEGIONS].config_value = 1;
    configs[CONFIG_MONTHLY_AUTOSAVE].config_value = 0;
}

static void set_mapping(int action, int mods, int hotkey)
{
    hotkey_mappings[action].sdl_mods = mods;
    hotkey_mappings[action].sdl_key = hotkey;
}

static void set_default_hotkeys(void)
{
    // Arrow keys
    set_mapping(HOTKEY_ARROW_UP, KMOD_NONE, SDLK_UP);
    set_mapping(HOTKEY_ARROW_DOWN, KMOD_NONE, SDLK_DOWN);
    set_mapping(HOTKEY_ARROW_LEFT, KMOD_NONE, SDLK_LEFT);
    set_mapping(HOTKEY_ARROW_RIGHT, KMOD_NONE, SDLK_RIGHT);
    // Global hotkeys
    set_mapping(HOTKEY_TOGGLE_FULLSCREEN, KMOD_ALT, SDLK_RETURN);
    set_mapping(HOTKEY_RESET_WINDOW, KMOD_CTRL, SDLK_RETURN);
    set_mapping(HOTKEY_SAVE_SCREENSHOT, KMOD_CTRL, SDLK_LEFTBRACKET);
    set_mapping(HOTKEY_SAVE_CITY_SCREENSHOT, KMOD_CTRL, SDLK_RIGHTBRACKET);
    set_mapping(HOTKEY_LOAD_FILE, KMOD_CTRL, SDLK_l);
    set_mapping(HOTKEY_SAVE_FILE, KMOD_CTRL, SDLK_s);
    // City hotkeys
    set_mapping(HOTKEY_DECREASE_GAME_SPEED, KMOD_NONE, SDLK_KP_MINUS);
    set_mapping(HOTKEY_INCREASE_GAME_SPEED, KMOD_NONE, SDLK_KP_PLUS);
    set_mapping(HOTKEY_TOGGLE_PAUSE, KMOD_NONE, SDLK_p);
    set_mapping(HOTKEY_ROTATE_MAP_LEFT, KMOD_NONE, SDLK_HOME);
    set_mapping(HOTKEY_ROTATE_MAP_RIGHT, KMOD_NONE, SDLK_END);
    set_mapping(HOTKEY_REPLAY_MAP, KMOD_CTRL, SDLK_r);
    set_mapping(HOTKEY_CYCLE_LEGION, KMOD_NONE, SDLK_SPACE);
    set_mapping(HOTKEY_RETURN_LEGIONS_TO_FORT, KMOD_NONE, SDLK_b);
    set_mapping(HOTKEY_SHOW_LAST_ADVISOR, KMOD_NONE, SDLK_1);
    set_mapping(HOTKEY_SHOW_EMPIRE_MAP, KMOD_NONE, SDLK_2);
    set_mapping(HOTKEY_SHOW_MESSAGES, KMOD_NONE, SDLK_BACKQUOTE);
    set_mapping(HOTKEY_GO_TO_PROBLEM, KMOD_ALT, SDLK_BACKQUOTE);
    // Overlays
    set_mapping(HOTKEY_SHOW_OVERLAY_WATER, KMOD_SHIFT, SDLK_w);
    set_mapping(HOTKEY_SHOW_OVERLAY_FIRE, KMOD_SHIFT, SDLK_f);
    set_mapping(HOTKEY_SHOW_OVERLAY_DAMAGE, KMOD_SHIFT, SDLK_d);
    set_mapping(HOTKEY_SHOW_OVERLAY_CRIME, KMOD_SHIFT, SDLK_c);
    set_mapping(HOTKEY_SHOW_OVERLAY_PROBLEMS, KMOD_SHIFT, SDLK_r);
    // City map bookmarks
    set_mapping(HOTKEY_GO_TO_BOOKMARK_1, KMOD_NONE, SDLK_F1);
    set_mapping(HOTKEY_GO_TO_BOOKMARK_2, KMOD_NONE, SDLK_F2);
    set_mapping(HOTKEY_GO_TO_BOOKMARK_3, KMOD_NONE, SDLK_F3);
    set_mapping(HOTKEY_GO_TO_BOOKMARK_4, KMOD_NONE, SDLK_F4);
    set_mapping(HOTKEY_SET_BOOKMARK_1, KMOD_CTRL, SDLK_F1);
    set_mapping(HOTKEY_SET_BOOKMARK_2, KMOD_CTRL, SDLK_F2);
    set_mapping(HOTKEY_SET_BOOKMARK_3, KMOD_CTRL, SDLK_F3);
    set_mapping(HOTKEY_SET_BOOKMARK_4, KMOD_CTRL, SDLK_F4);
    // Editor
    set_mapping(HOTKEY_EDITOR_TOGGLE_BATTLE_INFO, KMOD_CTRL, SDLK_a);
    // Cheats
    set_mapping(HOTKEY_CHEAT_MONEY, KMOD_CTRL, SDLK_COMMA);
    set_mapping(HOTKEY_CHEAT_INVASION, KMOD_CTRL, SDLK_PERIOD);
    set_mapping(HOTKEY_CHEAT_VICTORY, KMOD_CTRL, SDLK_SLASH);
    // Construction hotkeys
    set_mapping(HOTKEY_BUILD_CLONE, KMOD_ALT, SDLK_q);
    set_mapping(HOTKEY_CYCLE_BUILDINGS, KMOD_NONE, SDLK_TAB);
    set_mapping(HOTKEY_CYCLE_BUILDINGS_REVERSE, KMOD_SHIFT, SDLK_TAB);
    set_mapping(HOTKEY_UNDO, KMOD_CTRL, SDLK_z);
    set_mapping(HOTKEY_BUILD_VACANT_HOUSE, KMOD_NONE, SDLK_q);
    set_mapping(HOTKEY_BUILD_CLEAR_LAND, KMOD_NONE, SDLK_w);
    set_mapping(HOTKEY_BUILD_ROAD, KMOD_NONE, SDLK_e);
    set_mapping(HOTKEY_BUILD_RESERVOIR, KMOD_NONE, SDLK_r);
    set_mapping(HOTKEY_BUILD_FOUNTAIN, KMOD_ALT, SDLK_r);
    set_mapping(HOTKEY_BUILD_DOCTOR, KMOD_ALT, SDLK_s);
    set_mapping(HOTKEY_BUILD_BATHHOUSE, KMOD_NONE, SDLK_f);
    set_mapping(HOTKEY_BUILD_BARBER, KMOD_NONE, SDLK_g);
    set_mapping(HOTKEY_BUILD_SMALL_TEMPLE_CERES, KMOD_NONE, SDLK_s);
    set_mapping(HOTKEY_BUILD_SCHOOL, KMOD_ALT, SDLK_d);
    set_mapping(HOTKEY_BUILD_LIBRARY, KMOD_NONE, SDLK_g);
    set_mapping(HOTKEY_BUILD_THEATER, KMOD_NONE, SDLK_d);
    set_mapping(HOTKEY_BUILD_AMPHITHEATER, KMOD_ALT, SDLK_f);
    set_mapping(HOTKEY_BUILD_LION_HOUSE, KMOD_ALT, SDLK_z);
    set_mapping(HOTKEY_BUILD_COLOSSEUM, KMOD_NONE, SDLK_z);
    set_mapping(HOTKEY_BUILD_GARDENS, KMOD_ALT, SDLK_w);
    set_mapping(HOTKEY_BUILD_PLAZA, KMOD_ALT, SDLK_e);
    set_mapping(HOTKEY_BUILD_FORUM, KMOD_NONE, SDLK_t);
    set_mapping(HOTKEY_BUILD_ENGINEERS_POST, KMOD_NONE, SDLK_a);
    set_mapping(HOTKEY_BUILD_PREFECTURE, KMOD_ALT, SDLK_a);
    set_mapping(HOTKEY_BUILD_WHEAT_FARM, KMOD_ALT, SDLK_x);
    set_mapping(HOTKEY_BUILD_CLAY_PIT, KMOD_NONE, SDLK_c);
    set_mapping(HOTKEY_BUILD_WINE_WORKSHOP, KMOD_ALT, SDLK_c);
    set_mapping(HOTKEY_BUILD_MARKET, KMOD_NONE, SDLK_x);
    set_mapping(HOTKEY_BUILD_GRANARY, KMOD_NONE, SDLK_v);
    set_mapping(HOTKEY_BUILD_WAREHOUSE, KMOD_ALT, SDLK_v);
}

static char *clean_key_value(char *str)
{
    size_t size = string_length(str);
    while (size > 0 && (str[size - 1] == '\n' || str[size - 1] == '\r')) {
        str[--size] = 0;
    }
    while (*str) {
        if (*str == '=') {
            *str = 0;
            return str;
        }
        str++;
    }
    return 0;
}

static void quit_game(void)
{
    SDL_Log("Exiting game");
    // save settings
    fp = fopen(SETTINGS_FILE_PATH, "wt");
    if (fp) {
        for (int i = 0; i < SETTINGS_MAX_ENTRIES; i++) {
            fprintf(fp, "%s=%d\n", settings[i].config_string, settings[i].config_value);
        }
        fclose(fp);
    } else {
        SDL_Log("Failed to write settings file %s", SETTINGS_FILE_PATH);
    }
    if (log_file) {
        fclose(log_file);
    }
    SDL_Quit();
    exit(0);
}

static void draw_scenario_minimap_tile(int x_view, int y_view, int grid_offset)
{
    if (grid_offset < 0) {
        return;
    }
    if (terrain_grid.items[grid_offset] & TERRAIN_BUILDING) {
        // Native huts/fields
        if (edge_grid.items[grid_offset] & EDGE_LEFTMOST_TILE) {
            int image_id = 7829;
            switch (map_property_multi_tile_size(grid_offset)) {
                case 1: image_draw(image_id, x_view, y_view); break;
                case 2: image_draw(image_id + 1, x_view, y_view - 1); break;
            }
        }
    } else {
        int rand = random.items[grid_offset];
        struct tile_color_t *color;
        struct tile_color_set_t *set = &MINIMAP_COLOR_SETS[scenario.climate];
        if (terrain_grid.items[grid_offset] & TERRAIN_WATER) {
            color = &set->water[rand & 3];
        } else if (terrain_grid.items[grid_offset] & (TERRAIN_TREE | TERRAIN_SHRUB)) {
            color = &set->tree[rand & 3];
        } else if (terrain_grid.items[grid_offset] & (TERRAIN_ROCK | TERRAIN_ELEVATION)) {
            color = &set->rock[rand & 3];
        } else if (terrain_grid.items[grid_offset] & TERRAIN_ROAD) {
            color = &set->road;
        } else if (terrain_grid.items[grid_offset] & TERRAIN_MEADOW) {
            color = &set->meadow[rand & 3];
        } else {
            color = &set->grass[rand & 7];
        }
        graphics_draw_vertical_line(x_view, y_view, y_view, color->left);
        graphics_draw_vertical_line(x_view + 1, y_view, y_view, color->right);
    }
}

static void widget_scenario_minimap_draw(int x_offset, int y_offset, int width, int height)
{
    scenario_minimap_data.width_tiles = (width + 2) / 2;
    scenario_minimap_data.height_tiles = height;
    scenario_minimap_data.x_offset = x_offset;
    scenario_minimap_data.y_offset = y_offset;
    scenario_minimap_data.absolute_x = (VIEW_X_MAX - scenario_minimap_data.width_tiles) / 2;
    scenario_minimap_data.absolute_y = (VIEW_Y_MAX - scenario_minimap_data.height_tiles) / 2;
    // ensure even height
    scenario_minimap_data.absolute_y &= ~1;
    graphics_set_clip_rectangle(x_offset, y_offset, width, height);
    city_view_foreach_minimap_tile(
    scenario_minimap_data.x_offset, scenario_minimap_data.y_offset, scenario_minimap_data.absolute_x, scenario_minimap_data.absolute_y,
    scenario_minimap_data.width_tiles, scenario_minimap_data.height_tiles, draw_scenario_minimap_tile);
    graphics_reset_clip_rectangle();
}

static void select_scenario(int index)
{
    string_copy(cck_selection_data.scenarios->files[index], cck_selection_data.selected_scenario_filename, FILE_NAME_LENGTH_MAX - 1);
    game_file_load_scenario_data(cck_selection_data.selected_scenario_filename);
    string_copy(cck_selection_data.selected_scenario_filename, cck_selection_data.selected_scenario_display, FILE_NAME_LENGTH_MAX - 1);
    file_remove_extension(cck_selection_data.selected_scenario_display);
    refresh_current_window = 1;
}

static void adjust_key_display_name(char **key_name)
{
    // adjust for chars that the internal font can't display
    switch (**key_name) {
        case '[':
            *key_name = "Left bracket";
            break;
        case ']':
            *key_name = "Right bracket";
            break;
        case '\\':
            *key_name = "Backslash";
            break;
        case '`':
            *key_name = "Backtick";
            break;
        case '~':
            *key_name = "Tilde";
            break;
        case '#':
            *key_name = "Hash";
            break;
        case '$':
            *key_name = "Dollar";
            break;
        case '&':
            *key_name = "Ampersand";
            break;
        case '<':
            *key_name = "Less than";
            break;
        case '>':
            *key_name = "Greater than";
            break;
        case '@':
            *key_name = "At-sign";
            break;
        case '^':
            *key_name = "Caret";
            break;
        case '_':
            *key_name = "Underscore";
            break;
        case '|':
            *key_name = "Pipe";
            break;
        case '{':
            *key_name = "Left curly brace";
            break;
        case '}':
            *key_name = "Right curly brace";
            break;
    }
}

static void release_scrollbar(void)
{
    scrollbar_up_arrow_pressed = 0;
    scrollbar_down_arrow_pressed = 0;
    is_dragging_scroll = 0;
}

static void handle_advisor_change(void)
{

    if (mouse_x >= screen_center_x + 268 && mouse_x < screen_center_x + 308 && mouse_y >= screen_center_y + 264 && mouse_y < screen_center_y + 304) {
        change_window(WINDOW_CITY);
    } else {
        for (int i = 0; i < 12; i++) {
            if (mouse_x >= screen_center_x - 308 + 48 * i && mouse_x < screen_center_x - 268 + 48 * i && mouse_y >= screen_center_y + 264 && mouse_y < screen_center_y + 304) {
                settings[SETTINGS_LAST_ADVISOR].config_value = i;
                window_advisors_show(i);
                break;
            }
        }
    }
}

static void game_undo_restore_building_state(void)
{
    for (int i = 0; i < undo_data.num_buildings; i++) {
        if (undo_data.buildings[i].id) {
            struct building_t *b = &all_buildings[undo_data.buildings[i].id];
            if (b->state == BUILDING_STATE_DELETED_BY_PLAYER) {
                b->state = BUILDING_STATE_IN_USE;
            }
            b->is_deleted = 0;
        }
    }
    clear_buildings();
}

static void map_grid_start_end_to_area(int x_start, int y_start, int x_end, int y_end, int *x_min, int *y_min, int *x_max, int *y_max)
{
    if (x_start < x_end) {
        *x_min = x_start;
        *x_max = x_end;
    } else {
        *x_min = x_end;
        *x_max = x_start;
    }
    if (y_start < y_end) {
        *y_min = y_start;
        *y_max = y_end;
    } else {
        *y_min = y_end;
        *y_max = y_start;
    }
    map_grid_bound_area(x_min, y_min, x_max, y_max);
}

static struct building_t *get_deletable_building(int grid_offset)
{
    int building_id = map_building_at(grid_offset);
    if (!building_id) {
        return 0;
    }
    struct building_t *b = building_main(&all_buildings[building_id]);
    if (b->type == BUILDING_BURNING_RUIN || b->type == BUILDING_NATIVE_CROPS ||
        b->type == BUILDING_NATIVE_HUT || b->type == BUILDING_NATIVE_MEETING) {
        return 0;
    }
    if (b->state == BUILDING_STATE_DELETED_BY_PLAYER || b->is_deleted) {
        return 0;
    }
    return b;
}

static void game_undo_add_building(struct building_t *b)
{
    if (b->id <= 0) {
        return;
    }
    undo_data.num_buildings = 0;
    int is_on_list = 0;
    for (int i = 0; i < MAX_UNDO_BUILDINGS; i++) {
        if (undo_data.buildings[i].id) {
            undo_data.num_buildings++;
        }
        if (undo_data.buildings[i].id == b->id) {
            is_on_list = 1;
        }
    }
    if (!is_on_list) {
        for (int i = 0; i < MAX_UNDO_BUILDINGS; i++) {
            if (!undo_data.buildings[i].id) {
                undo_data.num_buildings++;
                memcpy(&undo_data.buildings[i], b, sizeof(struct building_t));
                return;
            }
        }
        undo_data.available = 0;
    }
}

static int clear_land_confirmed(int measure_only, int x_start, int y_start, int x_end, int y_end)
{
    int items_placed = 0;
    game_undo_restore_building_state();
    game_undo_restore_map(0);

    int x_min, x_max, y_min, y_max;
    map_grid_start_end_to_area(x_start, y_start, x_end, y_end, &x_min, &y_min, &x_max, &y_max);

    int visual_feedback_on_delete = configs[CONFIG_UI_VISUAL_FEEDBACK_ON_DELETE].config_value;

    for (int y = y_min; y <= y_max; y++) {
        for (int x = x_min; x <= x_max; x++) {
            int grid_offset = map_grid_offset(x, y);
            if (measure_only && visual_feedback_on_delete) {
                struct building_t *b = get_deletable_building(grid_offset);
                if (bitfields_grid.items[grid_offset] & BIT_DELETED || (b && bitfields_grid.items[b->grid_offset] & BIT_DELETED)) {
                    continue;
                }
                map_building_tiles_mark_deleting(grid_offset);
                if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
                    if (b) {
                        items_placed++;
                    }
                } else if (map_terrain_is(grid_offset, TERRAIN_SHRUB | TERRAIN_TREE) && !scenario.allowed_buildings[BUILDING_CLEAR_LAND]) {
                    continue;
                } else if (map_terrain_is(grid_offset, TERRAIN_ROCK | TERRAIN_ELEVATION)) {
                    continue;
                } else if (map_terrain_is(grid_offset, TERRAIN_WATER)) { // keep the "bridge is free" bug from C3
                    continue;
                } else if (map_terrain_is(grid_offset, TERRAIN_AQUEDUCT)
                    || map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR)) {
                    items_placed++;
                }
                continue;
            }
            if (map_terrain_is(grid_offset, TERRAIN_SHRUB | TERRAIN_TREE) && !scenario.allowed_buildings[BUILDING_CLEAR_LAND]) {
                continue;
            }
            if (map_terrain_is(grid_offset, TERRAIN_ROCK | TERRAIN_ELEVATION)) {
                continue;
            }
            if (map_terrain_is(grid_offset, TERRAIN_BUILDING)) {
                struct building_t *b = get_deletable_building(grid_offset);
                if (!b) {
                    continue;
                }
                if (b->house_size && b->house_population && !measure_only) {
                    figure_create_homeless(b->x, b->y, b->house_population);
                    b->house_population = 0;
                }
                if (b->state != BUILDING_STATE_DELETED_BY_PLAYER) {
                    items_placed++;
                    game_undo_add_building(b);
                }
                b->state = BUILDING_STATE_DELETED_BY_PLAYER;
                b->is_deleted = 1;
                struct building_t *space = b;
                for (int i = 0; i < 9; i++) {
                    if (space->prev_part_building_id <= 0) {
                        break;
                    }
                    space = &all_buildings[space->prev_part_building_id];
                    game_undo_add_building(space);
                    space->state = BUILDING_STATE_DELETED_BY_PLAYER;
                }
                space = b;
                for (int i = 0; i < 9; i++) {
                    space = &all_buildings[space->next_part_building_id];
                    if (space->id <= 0) {
                        break;
                    }
                    game_undo_add_building(space);
                    space->state = BUILDING_STATE_DELETED_BY_PLAYER;
                }
            } else if (map_terrain_is(grid_offset, TERRAIN_AQUEDUCT)) {
                terrain_grid.items[grid_offset] &= ~TERRAIN_CLEARABLE;
                items_placed++;
                aqueduct.items[grid_offset] = 0;
                if (aqueduct.items[grid_offset + map_grid_delta(0, -1)] == 5) {
                    aqueduct.items[grid_offset + map_grid_delta(0, -1)] = 1;
                }
                if (aqueduct.items[grid_offset + map_grid_delta(1, 0)] == 6) {
                    aqueduct.items[grid_offset + map_grid_delta(1, 0)] = 2;
                }
                if (aqueduct.items[grid_offset + map_grid_delta(0, 1)] == 5) {
                    aqueduct.items[grid_offset + map_grid_delta(0, 1)] = 3;
                }
                if (aqueduct.items[grid_offset + map_grid_delta(-1, 0)] == 6) {
                    aqueduct.items[grid_offset + map_grid_delta(-1, 0)] = 4;
                }
            } else if (map_terrain_is(grid_offset, TERRAIN_WATER)) {
                int figures_n = 0;
                if (map_is_bridge(grid_offset)) {
                    int tiles_x = get_x_bridge_tiles(grid_offset);
                    int tiles_y = get_y_bridge_tiles(grid_offset);
                    int offset_up = tiles_x > tiles_y ? map_grid_delta(1, 0) : map_grid_delta(0, 1);
                    // find lower end of the bridge
                    while (map_is_bridge(grid_offset - offset_up)) {
                        grid_offset -= offset_up;
                    }
                    if (map_grid_is_valid_offset(grid_offset) && map_figures.items[grid_offset] > 0) {
                        figures_n = 1;
                    }
                    while (map_is_bridge(grid_offset + offset_up)) {
                        grid_offset += offset_up;
                        if (map_grid_is_valid_offset(grid_offset) && map_figures.items[grid_offset] > 0) {
                            figures_n++;
                        }
                    }
                }
                map_bridge_remove(grid_offset, measure_only);
                items_placed++;
            } else if (map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR)) {
                if (map_terrain_is(grid_offset, TERRAIN_ROAD)) {
                    bitfields_grid.items[grid_offset] &= BIT_NO_PLAZA;
                }
                terrain_grid.items[grid_offset] &= ~TERRAIN_CLEARABLE;
                items_placed++;
            }
        }
    }
    if (!measure_only || !visual_feedback_on_delete) {
        int radius;
        if (x_max - x_min <= y_max - y_min) {
            radius = y_max - y_min + 3;
        } else {
            radius = x_max - x_min + 3;
        }
        map_tiles_update_region_empty_land(x_min, y_min, x_max, y_max);
        foreach_region_tile(x_min, y_min, x_max, y_max, update_meadow_tile);
        foreach_region_tile(x_min, y_min, x_max, y_max, set_rubble_image);
        map_tiles_update_all_gardens();
        foreach_region_tile(x_min - 1, y_min - 1, x_min + radius - 2, y_min + radius - 2, set_road_image);
        map_tiles_update_all_plazas();
        foreach_region_tile(x_min - 1, y_min - 1, x_min + radius - 2, y_min + radius - 2, set_wall_image);
        foreach_region_tile(x_min - 3, y_min - 3, x_max + 3, y_max + 3, update_aqueduct_tile);
    }
    if (!measure_only) {
        map_routing_update_land();
        map_routing_update_walls();
        map_routing_update_water();
        // window_invalidate();
    }
    return items_placed;
}

static int building_construction_clear_land(int measure_only, int x_start, int y_start, int x_end, int y_end)
{
    if (measure_only) {
        return clear_land_confirmed(measure_only, x_start, y_start, x_end, y_end);
    }

    int x_min, x_max, y_min, y_max;
    map_grid_start_end_to_area(x_start, y_start, x_end, y_end, &x_min, &y_min, &x_max, &y_max);

    int ask_confirm_bridge = 0;
    int ask_confirm_fort = 0;
    for (int y = y_min; y <= y_max; y++) {
        for (int x = x_min; x <= x_max; x++) {
            int grid_offset = map_grid_offset(x, y);
            int building_id = map_building_at(grid_offset);
            if (building_id) {
                struct building_t *b = &all_buildings[building_id];
                if (building_is_fort(b->type) || b->type == BUILDING_FORT_GROUND) {
                    ask_confirm_fort = 1;
                }
            }
            if (map_is_bridge(grid_offset)) {
                ask_confirm_bridge = 1;
            }
        }
    }
    confirm.x_start = x_start;
    confirm.y_start = y_start;
    confirm.x_end = x_end;
    confirm.y_end = y_end;
    if (ask_confirm_fort) {
        // window_popup_dialog_show("Demolishing a fort", confirm_delete_fort, 2);
        return -1;
    } else if (ask_confirm_bridge) {
        // window_popup_dialog_show("Demolishing a bridge", confirm_delete_bridge, 2);
        return -1;
    } else {
        return clear_land_confirmed(measure_only, x_start, y_start, x_end, y_end);
    }
}

static int building_construction_place_wall(int measure_only, int x_start, int y_start, int x_end, int y_end)
{
    game_undo_restore_map(0);

    int start_offset = map_grid_offset(x_start, y_start);
    int end_offset = map_grid_offset(x_end, y_end);
    int forbidden_terrain_mask =
        TERRAIN_SHRUB | TERRAIN_ROCK | TERRAIN_WATER | TERRAIN_BUILDING |
        TERRAIN_TREE | TERRAIN_ROAD | TERRAIN_GARDEN | TERRAIN_ELEVATION |
        TERRAIN_RUBBLE | TERRAIN_AQUEDUCT | TERRAIN_ACCESS_RAMP;
    if (map_terrain_is(start_offset, forbidden_terrain_mask)) {
        return 0;
    }
    if (map_terrain_is(end_offset, forbidden_terrain_mask)) {
        return 0;
    }
    int items_placed = 0;
    if (place_routed_building(x_start, y_start, x_end, y_end, ROUTED_BUILDING_WALL, &items_placed)) {
        if (!measure_only) {
            map_routing_update_land();
            map_routing_update_walls();
            // window_invalidate();
        }
    }
    return items_placed;
}

static int place_plaza(int x_start, int y_start, int x_end, int y_end)
{
    int x_min, y_min, x_max, y_max;
    map_grid_start_end_to_area(x_start, y_start, x_end, y_end, &x_min, &y_min, &x_max, &y_max);
    game_undo_restore_map(1);

    int items_placed = 0;
    for (int y = y_min; y <= y_max; y++) {
        for (int x = x_min; x <= x_max; x++) {
            int grid_offset = map_grid_offset(x, y);
            if (map_terrain_is(grid_offset, TERRAIN_ROAD) &&
                !map_terrain_is(grid_offset, TERRAIN_WATER | TERRAIN_BUILDING | TERRAIN_AQUEDUCT)) {
                if (!(bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE)) {
                    items_placed++;
                }
                images.items[grid_offset] = 0;
                bitfields_grid.items[grid_offset] |= BIT_PLAZA_OR_EARTHQUAKE;
                map_property_set_multi_tile_size(grid_offset, 1);
                edge_grid.items[grid_offset] |= EDGE_LEFTMOST_TILE;
            }
        }
    }
    map_tiles_update_all_plazas();
    return items_placed;
}

static int place_garden(int x_start, int y_start, int x_end, int y_end)
{
    game_undo_restore_map(1);
    int x_min, y_min, x_max, y_max;
    map_grid_start_end_to_area(x_start, y_start, x_end, y_end, &x_min, &y_min, &x_max, &y_max);

    int items_placed = 0;
    for (int y = y_min; y <= y_max; y++) {
        for (int x = x_min; x <= x_max; x++) {
            int grid_offset = map_grid_offset(x, y);
            if (!map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR)) {
                items_placed++;
                terrain_grid.items[grid_offset] |= TERRAIN_GARDEN;
            }
        }
    }
    map_tiles_update_all_gardens();
    return items_placed;
}

static int building_construction_place_aqueduct(int x_start, int y_start, int x_end, int y_end, int *cost)
{
    game_undo_restore_map(0);

    *cost = 0;
    int blocked = 0;
    int grid_offset = map_grid_offset(x_start, y_start);
    if (map_terrain_is(grid_offset, TERRAIN_ROAD)) {
        if (bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
            blocked = 1;
        }
    } else if (map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR)) {
        blocked = 1;
    }
    grid_offset = map_grid_offset(x_end, y_end);
    if (map_terrain_is(grid_offset, TERRAIN_ROAD)) {
        if (bitfields_grid.items[grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
            blocked = 1;
        }
    } else if (map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR)) {
        blocked = 1;
    }
    if (blocked) {
        return 0;
    }
    if (!map_routing_calculate_distances_for_building(ROUTED_BUILDING_AQUEDUCT, x_start, y_start)) {
        return 0;
    }
    int num_items;
    place_routed_building(x_start, y_start, x_end, y_end, ROUTED_BUILDING_AQUEDUCT, &num_items);
    *cost = building_properties[BUILDING_AQUEDUCT].cost * num_items;
    return 1;
}

static void show(int warning)
{
    city_warning_show(warning);
    has_warning = 1;
}

static void building_construction_warning_check_food_stocks(int type)
{
    if (!has_warning && type == BUILDING_HOUSE_VACANT_LOT) {
        if (city_data.population.population >= 200 && !scenario.rome_supplies_wheat) {
            if (calc_percentage(city_data.resource.food_produced_last_month, city_data.resource.food_consumed_last_month) <= 95) {
                show(WARNING_MORE_FOOD_NEEDED);
            }
        }
    }
}

static void adjust_to_absolute_xy(int *x, int *y, int size)
{
    switch (view_data.orientation) {
        case DIR_2_RIGHT:
            *x = *x - size + 1;
            break;
        case DIR_4_BOTTOM:
            *x = *x - size + 1;
            /* fall through */
        case DIR_6_LEFT:
            *y = *y - size + 1;
            break;
    }
}

static int place_houses(int measure_only, int x_start, int y_start, int x_end, int y_end)
{
    int x_min, x_max, y_min, y_max;
    map_grid_start_end_to_area(x_start, y_start, x_end, y_end, &x_min, &y_min, &x_max, &y_max);

    int needs_road_warning = 0;
    int items_placed = 0;
    game_undo_restore_building_state();
    for (int y = y_min; y <= y_max; y++) {
        for (int x = x_min; x <= x_max; x++) {
            int grid_offset = map_grid_offset(x, y);
            if (map_terrain_is(grid_offset, TERRAIN_NOT_CLEAR)) {
                continue;
            }
            if (measure_only) {
                bitfields_grid.items[grid_offset] |= BIT_CONSTRUCTION;
                items_placed++;
            } else {
                struct building_t *b = building_create(BUILDING_HOUSE_VACANT_LOT, x, y);
                game_undo_add_building(b);
                if (b->id > 0) {
                    items_placed++;
                    map_building_tiles_add(b->id, x, y, 1,
                        2823, TERRAIN_BUILDING);
                    if (!map_terrain_exists_tile_in_radius_with_type(x, y, 1, 2, TERRAIN_ROAD)) {
                        needs_road_warning = 1;
                    }
                }
            }
        }
    }
    if (!measure_only) {
        building_construction_warning_check_food_stocks(BUILDING_HOUSE_VACANT_LOT);
        if (needs_road_warning) {
            city_warning_show(WARNING_HOUSE_TOO_FAR_FROM_ROAD);
        }
        map_routing_update_land();
        // window_invalidate();
    }
    return items_placed;
}

static int map_building_tiles_are_clear(int x, int y, int size, int terrain)
{
    adjust_to_absolute_xy(&x, &y, size);
    if (!map_grid_is_inside(x, y, size)) {
        return 0;
    }
    for (int dy = 0; dy < size; dy++) {
        for (int dx = 0; dx < size; dx++) {
            int grid_offset = map_grid_offset(x + dx, y + dy);
            if (map_terrain_is(grid_offset, terrain & TERRAIN_NOT_CLEAR)) {
                return 0;
            }
        }
    }
    return 1;
}

static void mark_construction(int x, int y, int size, int terrain, int absolute_xy)
{
    if (!absolute_xy) {
        adjust_to_absolute_xy(&x, &y, size);
    }
    if (map_grid_is_inside(x, y, size)) {
        for (int dy = 0; dy < size; dy++) {
            for (int dx = 0; dx < size; dx++) {
                int grid_offset = map_grid_offset(x + dx, y + dy);
                if (map_terrain_is(grid_offset, terrain & TERRAIN_NOT_CLEAR) || (map_grid_is_valid_offset(grid_offset) && map_figures.items[grid_offset] > 0)) {
                    return;
                }
            }
        }
        // mark as being constructed
        for (int dy = 0; dy < size; dy++) {
            for (int dx = 0; dx < size; dx++) {
                int grid_offset = map_grid_offset(x + dx, y + dy);
                bitfields_grid.items[grid_offset] |= BIT_CONSTRUCTION;
            }
        }
    }
    construction_data.draw_as_constructing = 1;
}

static void build_move(void)
{
    if (widget_city_data.current_tile.grid_offset) {
        construction_data.end.x = widget_city_data.current_tile.x;
        construction_data.end.y = widget_city_data.current_tile.y;
        construction_data.end.grid_offset = widget_city_data.current_tile.grid_offset;
    } else {
        widget_city_data.current_tile.x = construction_data.end.x;
        widget_city_data.current_tile.y = construction_data.end.y;
    }
    if (!construction_data.type) {
        construction_data.cost_preview = 0;
        return;
    }
    map_property_clear_constructing_and_deleted();
    int current_cost = building_properties[construction_data.type].cost;

    if (construction_data.type == BUILDING_CLEAR_LAND) {
        int items_placed = last_items_cleared = building_construction_clear_land(1, construction_data.start.x, construction_data.start.y, widget_city_data.current_tile.x, widget_city_data.current_tile.y);
        if (items_placed >= 0) {
            current_cost *= items_placed;
        }
    } else if (construction_data.type == BUILDING_WALL) {
        int items_placed = building_construction_place_wall(1, construction_data.start.x, construction_data.start.y, widget_city_data.current_tile.x, widget_city_data.current_tile.y);
        if (items_placed >= 0) {
            current_cost *= items_placed;
        }
    } else if (construction_data.type == BUILDING_ROAD) {
        int items_placed = building_construction_place_road(1, construction_data.start.x, construction_data.start.y, widget_city_data.current_tile.x, widget_city_data.current_tile.y);
        if (items_placed >= 0) {
            current_cost *= items_placed;
        }
    } else if (construction_data.type == BUILDING_PLAZA) {
        int items_placed = place_plaza(construction_data.start.x, construction_data.start.y, widget_city_data.current_tile.x, widget_city_data.current_tile.y);
        if (items_placed >= 0) {
            current_cost *= items_placed;
        }
    } else if (construction_data.type == BUILDING_GARDENS) {
        int items_placed = place_garden(construction_data.start.x, construction_data.start.y, widget_city_data.current_tile.x, widget_city_data.current_tile.y);
        if (items_placed >= 0) {
            current_cost *= items_placed;
        }
    } else if (construction_data.type == BUILDING_LOW_BRIDGE || construction_data.type == BUILDING_SHIP_BRIDGE) {
        int length = bridge.length;
        if (length > 1) {
            current_cost *= length;
        }
    } else if (construction_data.type == BUILDING_AQUEDUCT) {
        building_construction_place_aqueduct(construction_data.start.x, construction_data.start.y, widget_city_data.current_tile.x, widget_city_data.current_tile.y, &current_cost);
        map_tiles_update_all_aqueducts(0);
    } else if (construction_data.type == BUILDING_HOUSE_VACANT_LOT) {
        int items_placed = place_houses(1, construction_data.start.x, construction_data.start.y, widget_city_data.current_tile.x, widget_city_data.current_tile.y);
        if (items_placed >= 0) {
            current_cost *= items_placed;
        }
    } else if (construction_data.type == BUILDING_GATEHOUSE) {
        mark_construction(widget_city_data.current_tile.x, widget_city_data.current_tile.y, 2, ~TERRAIN_ROAD, 0);
    } else if (construction_data.type == BUILDING_TRIUMPHAL_ARCH) {
        mark_construction(widget_city_data.current_tile.x, widget_city_data.current_tile.y, 3, ~TERRAIN_ROAD, 0);
    } else if (construction_data.type == BUILDING_WAREHOUSE) {
        mark_construction(widget_city_data.current_tile.x, widget_city_data.current_tile.y, 3, TERRAIN_ALL, 0);
    } else if (building_is_fort(construction_data.type)) {
        if (city_data.military.total_legions < MAX_LEGIONS) {
            int offsets_x[] = { 3, 4, 4, 3 };
            int offsets_y[] = { -1, -1, 0, 0 };
            int orient_index = view_data.orientation / 2;
            int x_offset = offsets_x[orient_index];
            int y_offset = offsets_y[orient_index];
            if (map_building_tiles_are_clear(widget_city_data.current_tile.x, widget_city_data.current_tile.y, 3, TERRAIN_ALL) &&
                map_building_tiles_are_clear(widget_city_data.current_tile.x + x_offset, widget_city_data.current_tile.y + y_offset, 4, TERRAIN_ALL)) {
                mark_construction(widget_city_data.current_tile.x, widget_city_data.current_tile.y, 3, TERRAIN_ALL, 0);
                mark_construction(widget_city_data.current_tile.x + x_offset, widget_city_data.current_tile.y + y_offset, 4, TERRAIN_ALL, 0);
            }
        }
    } else if (construction_data.type == BUILDING_HIPPODROME) {
        if (map_building_tiles_are_clear(widget_city_data.current_tile.x, widget_city_data.current_tile.y, 5, TERRAIN_ALL) &&
            map_building_tiles_are_clear(widget_city_data.current_tile.x + 5, widget_city_data.current_tile.y, 5, TERRAIN_ALL) &&
            map_building_tiles_are_clear(widget_city_data.current_tile.x + 10, widget_city_data.current_tile.y, 5, TERRAIN_ALL) &&
            !city_data.building.hippodrome_placed) {
            mark_construction(widget_city_data.current_tile.x, widget_city_data.current_tile.y, 5, TERRAIN_ALL, 0);
            mark_construction(widget_city_data.current_tile.x + 5, widget_city_data.current_tile.y, 5, TERRAIN_ALL, 0);
            mark_construction(widget_city_data.current_tile.x + 10, widget_city_data.current_tile.y, 5, TERRAIN_ALL, 0);
        }
    } else if (construction_data.type == BUILDING_SHIPYARD || construction_data.type == BUILDING_WHARF) {
        if (!map_water_determine_orientation_size2(widget_city_data.current_tile.x, widget_city_data.current_tile.y, 1, 0, 0)) {
            construction_data.draw_as_constructing = 1;
        }
    } else if (construction_data.type == BUILDING_DOCK) {
        if (!map_water_determine_orientation_size3(widget_city_data.current_tile.x, widget_city_data.current_tile.y, 1, 0, 0)) {
            construction_data.draw_as_constructing = 1;
        }
    } else if (construction_data.required_terrain.meadow || construction_data.required_terrain.rock || construction_data.required_terrain.tree ||
            construction_data.required_terrain.water || construction_data.required_terrain.wall) {
        // never mark as constructing
    } else {
        if (!(construction_data.type == BUILDING_SENATE && city_data.building.senate_placed) &&
            !(construction_data.type == BUILDING_BARRACKS && count_data.buildings[BUILDING_BARRACKS].total > 0)) {
            mark_construction(widget_city_data.current_tile.x, widget_city_data.current_tile.y, building_properties[construction_data.type].size, TERRAIN_ALL, 0);
        }
    }
    if (!city_finance_can_afford(current_cost)) {
        map_property_clear_constructing_and_deleted();
        building_construction_cancel();
        construction_data.cost_preview = 0;
        city_warning_show(WARNING_OUT_OF_MONEY);
        return;
    }
    construction_data.cost_preview = current_cost;
}

static struct building_t *add_warehouse_space(int x, int y, struct building_t *prev)
{
    struct building_t *b = building_create(BUILDING_WAREHOUSE_SPACE, x, y);
    game_undo_add_building(b);
    b->prev_part_building_id = prev->id;
    prev->next_part_building_id = b->id;
    map_building_tiles_add(b->id, x, y, 1, 3337, TERRAIN_BUILDING);
    return b;
}

static int map_bridge_add(int x, int y, int is_ship_bridge)
{
    int min_length = is_ship_bridge ? 5 : 2;
    if (bridge.end_grid_offset <= 0 || bridge.length < min_length) {
        bridge.length = 0;
        return bridge.length;
    }
    bridge.direction -= view_data.orientation;
    if (bridge.direction < 0) {
        bridge.direction += 8;
    }

    int grid_offset = map_grid_offset(x, y);
    for (int i = 0; i < bridge.length; i++) {
        terrain_grid.items[grid_offset] |= TERRAIN_ROAD;
        int value = map_bridge_get_sprite_id(i, bridge.length, bridge.direction, is_ship_bridge);
        sprite.items[grid_offset] = value;
        grid_offset += bridge.direction_grid_delta;
    }
    map_routing_update_land();
    map_routing_update_water();
    return bridge.length;
}

static void building_construction_place(void)
{
    construction_data.cost_preview = 0;
    construction_data.in_progress = 0;
    int x_start = construction_data.start.x;
    int y_start = construction_data.start.y;
    int x_end = construction_data.end.x;
    int y_end = construction_data.end.y;
    has_warning = 0;
    if (construction_data.type >= BUILDING_LARGE_TEMPLE_CERES && construction_data.type <= BUILDING_LARGE_TEMPLE_VENUS && city_data.resource.stored_in_warehouses[RESOURCE_MARBLE] < 2) {
        map_property_clear_constructing_and_deleted();
        city_warning_show(WARNING_MARBLE_NEEDED_LARGE_TEMPLE);
        return;
    }
    if (construction_data.type == BUILDING_ORACLE && city_data.resource.stored_in_warehouses[RESOURCE_MARBLE] < 2) {
        map_property_clear_constructing_and_deleted();
        city_warning_show(WARNING_MARBLE_NEEDED_ORACLE);
        return;
    }
    int enemy_type = 0;
    for (int i = 1; i < MAX_FIGURES; i++) {
        struct figure_t *f = &figures[i];
        if (figure_is_alive(f) && (figure_properties[f->type].is_enemy_unit || figure_properties[f->type].is_caesar_legion_unit || f->type == FIGURE_WOLF)) {
            int dx = (f->x > x_start) ? (f->x - x_start) : (x_start - f->x);
            int dy = (f->y > y_start) ? (f->y - y_start) : (y_start - f->y);
            if (dx <= 12 && dy <= 12) {
                enemy_type = f->type;
                break;
            }
            dx = (f->x > x_end) ? (f->x - x_end) : (x_end - f->x);
            dy = (f->y > y_end) ? (f->y - y_end) : (y_end - f->y);
            if (dx <= 12 && dy <= 12) {
                enemy_type = f->type;
                break;
            }
        }
    }
    if (enemy_type && construction_data.type != BUILDING_CLEAR_LAND) {
        if (construction_data.type == BUILDING_WALL || construction_data.type == BUILDING_ROAD || construction_data.type == BUILDING_AQUEDUCT) {
            game_undo_restore_map(0);
        } else if (construction_data.type == BUILDING_PLAZA || construction_data.type == BUILDING_GARDENS) {
            game_undo_restore_map(1);
        } else if (construction_data.type == BUILDING_LOW_BRIDGE || construction_data.type == BUILDING_SHIP_BRIDGE) {
            bridge.length = 0;
        } else {
            map_property_clear_constructing_and_deleted();
        }
        if (enemy_type == FIGURE_WOLF) {
            play_sound_effect(SOUND_EFFECT_WOLF_ATTACK_2);
        } else {
            city_warning_show(WARNING_ENEMY_NEARBY);
        }
        return;
    }
    int placement_cost = building_properties[construction_data.type].cost;
    if (construction_data.type == BUILDING_CLEAR_LAND) {
        // BUG in original (keep this behaviour): if confirmation has to be asked (bridge/fort),
        // the previous cost is deducted from treasury and if user chooses 'no', they still pay for removal.
        // If we don't do it this way, the user doesn't pay for the removal at all since we don't come back
        // here when the user says yes.
        int items_placed = building_construction_clear_land(0, x_start, y_start, x_end, y_end);
        if (items_placed < 0) {
            items_placed = last_items_cleared;
        }
        placement_cost *= items_placed;
        map_property_clear_constructing_and_deleted();
    } else if (construction_data.type == BUILDING_WALL) {
        placement_cost *= building_construction_place_wall(0, x_start, y_start, x_end, y_end);
    } else if (construction_data.type == BUILDING_ROAD) {
        placement_cost *= building_construction_place_road(0, x_start, y_start, x_end, y_end);
    } else if (construction_data.type == BUILDING_PLAZA) {
        placement_cost *= place_plaza(x_start, y_start, x_end, y_end);
    } else if (construction_data.type == BUILDING_GARDENS) {
        placement_cost *= place_garden(x_start, y_start, x_end, y_end);
        map_routing_update_land();
    } else if (construction_data.type == BUILDING_LOW_BRIDGE) {
        int length = map_bridge_add(x_end, y_end, 0);
        if (length <= 1) {
            city_warning_show(WARNING_SHORE_NEEDED);
            return;
        }
        placement_cost *= length;
    } else if (construction_data.type == BUILDING_SHIP_BRIDGE) {
        int length = map_bridge_add(x_end, y_end, 1);
        if (length <= 1) {
            city_warning_show(WARNING_SHORE_NEEDED);
            return;
        }
        placement_cost *= length;
    } else if (construction_data.type == BUILDING_AQUEDUCT) {
        int cost;
        if (!building_construction_place_aqueduct(x_start, y_start, x_end, y_end, &cost)) {
            city_warning_show(WARNING_CLEAR_LAND_NEEDED);
            return;
        }
        placement_cost = cost;
        map_tiles_update_all_aqueducts(0);
        map_routing_update_land();
    } else if (construction_data.type == BUILDING_HOUSE_VACANT_LOT) {
        placement_cost *= place_houses(0, x_start, y_start, x_end, y_end);
    } else {
        int terrain_mask = TERRAIN_ALL;
        if (construction_data.type == BUILDING_GATEHOUSE || construction_data.type == BUILDING_TRIUMPHAL_ARCH) {
            terrain_mask = ~TERRAIN_ROAD;
        } else if (construction_data.type == BUILDING_TOWER) {
            terrain_mask = ~TERRAIN_WALL;
        }
        int size = building_properties[construction_data.type].size;
        if (construction_data.type == BUILDING_WAREHOUSE) {
            size = 3;
        }
        int building_orientation = 0;
        if (construction_data.type == BUILDING_GATEHOUSE) {
            building_orientation = map_orientation_for_gatehouse(x_end, y_end);
        } else if (construction_data.type == BUILDING_TRIUMPHAL_ARCH) {
            building_orientation = map_orientation_for_triumphal_arch(x_end, y_end);
        }
        switch (view_data.orientation) {
            case DIR_2_RIGHT: x_end = x_end - size + 1; break;
            case DIR_4_BOTTOM: x_end = x_end - size + 1; y_end = y_end - size + 1; break;
            case DIR_6_LEFT: y_end = y_end - size + 1; break;
        }
        // extra checks
        if (construction_data.type == BUILDING_GATEHOUSE) {
            if (!is_clear(x_end, y_end, size, terrain_mask, 0)) {
                city_warning_show(WARNING_CLEAR_LAND_NEEDED);
                return;
            }
            if (!building_orientation) {
                if (construction_data.road_orientation == 1) {
                    building_orientation = 1;
                } else {
                    building_orientation = 2;
                }
            }
        }
        if (construction_data.type == BUILDING_TRIUMPHAL_ARCH) {
            if (!is_clear(x_end, y_end, size, terrain_mask, 0)) {
                city_warning_show(WARNING_CLEAR_LAND_NEEDED);
                return;
            }
            if (!building_orientation) {
                if (construction_data.road_orientation == 1) {
                    building_orientation = 1;
                } else {
                    building_orientation = 3;
                }
            }
        }
        int waterside_orientation_abs = 0;
        int waterside_orientation_rel = 0;
        if (construction_data.type == BUILDING_SHIPYARD || construction_data.type == BUILDING_WHARF) {
            if (map_water_determine_orientation_size2(
                x_end, y_end, 0, &waterside_orientation_abs, &waterside_orientation_rel)) {
                city_warning_show(WARNING_SHORE_NEEDED);
                return;
            }
        } else if (construction_data.type == BUILDING_DOCK) {
            if (map_water_determine_orientation_size3(
                x_end, y_end, 0, &waterside_orientation_abs, &waterside_orientation_rel)) {
                city_warning_show(WARNING_SHORE_NEEDED);
                return;
            }
            map_routing_calculate_distances_water_boat(scenario.river_entry_point.x, scenario.river_entry_point.y);
            if (!map_terrain_is_adjacent_to_open_water(x_end, y_end, 3)) {
                city_warning_show(WARNING_DOCK_OPEN_WATER_NEEDED);
                return;
            }
        } else {
            if (!is_clear(x_end, y_end, size, terrain_mask, 0)) {
                city_warning_show(WARNING_CLEAR_LAND_NEEDED);
                return;
            }
            int warning_id;
            if (!check_building_terrain_requirements(x_end, y_end, &warning_id)) {
                city_warning_show(warning_id);
                return;
            }
        }
        if (building_is_fort(construction_data.type)) {
            if (!is_clear(x_end + 3, y_end - 1, 4, terrain_mask, 0)) {
                city_warning_show(WARNING_CLEAR_LAND_NEEDED);
                return;
            }
            if (city_data.military.total_legions >= MAX_LEGIONS) {
                city_warning_show(WARNING_MAX_LEGIONS_REACHED);
                return;
            }
        }
        if (construction_data.type == BUILDING_HIPPODROME) {
            if (city_data.building.hippodrome_placed) {
                city_warning_show(WARNING_ONE_BUILDING_OF_TYPE);
                return;
            }
            if (!is_clear(x_end + 5, y_end, 5, terrain_mask, 0)
               || !is_clear(x_end + 10, y_end, 5, terrain_mask, 0)) {
                city_warning_show(WARNING_CLEAR_LAND_NEEDED);
                return;
            }
        }
        if (construction_data.type == BUILDING_SENATE && city_data.building.senate_placed) {
            city_warning_show(WARNING_ONE_BUILDING_OF_TYPE);
            return;
        }
        if (construction_data.type == BUILDING_BARRACKS && count_data.buildings[BUILDING_BARRACKS].total > 0) {
            city_warning_show(WARNING_ONE_BUILDING_OF_TYPE);
            return;
        }
        building_construction_warning_check_food_stocks(construction_data.type);
        if (!has_warning && construction_data.type != BUILDING_WELL && !building_is_fort(construction_data.type)) {
            if (building_properties[construction_data.type].n_laborers > 0 && city_data.labor.workers_needed >= 10) {
                show(WARNING_WORKERS_NEEDED);
            }
        }
        if (!has_warning && construction_data.type == BUILDING_GRANARY) {
            if (!count_data.buildings[BUILDING_MARKET].active) {
                show(WARNING_BUILD_MARKET);
            }
        }
        if (!has_warning && construction_data.type == BUILDING_THEATER) {
            if (!count_data.buildings[BUILDING_ACTOR_COLONY].active) {
                show(WARNING_BUILD_ACTOR_COLONY);
            }
        }
        if (!has_warning && construction_data.type == BUILDING_AMPHITHEATER) {
            if (!count_data.buildings[BUILDING_GLADIATOR_SCHOOL].active) {
                show(WARNING_BUILD_GLADIATOR_SCHOOL);
            }
        }
        if (!has_warning && construction_data.type == BUILDING_COLOSSEUM) {
            if (!count_data.buildings[BUILDING_LION_HOUSE].active) {
                show(WARNING_BUILD_LION_HOUSE);
            }
        }
        if (!has_warning && construction_data.type == BUILDING_HIPPODROME) {
            if (!count_data.buildings[BUILDING_CHARIOT_MAKER].active) {
                show(WARNING_BUILD_CHARIOT_MAKER);
            }
        }
        if (!has_warning) {
            if (building_is_fort(construction_data.type) && !count_data.buildings[BUILDING_BARRACKS].active) {
                show(WARNING_BUILD_BARRACKS);
            }
        }
        if (!has_warning && construction_data.type == BUILDING_BARRACKS) {
            if (city_data.resource.stored_in_warehouses[RESOURCE_WEAPONS] <= 0) {
                show(WARNING_WEAPONS_NEEDED);
            }
        }
        if (!has_warning && construction_data.type == BUILDING_TOWER) {
            int terrain_is_adjacent_to_wall = 0;
            int base_offset = map_grid_offset(x_end, y_end);
            for (int *tile_delta = ADJACENT_OFFSETS_MAP_GRID[size]; *tile_delta; tile_delta++) {
                if (map_terrain_is(base_offset + *tile_delta, TERRAIN_WALL)) {
                    terrain_is_adjacent_to_wall = 1;
                    break;
                }
            }
            if (!terrain_is_adjacent_to_wall) {
                show(WARNING_SENTRIES_NEED_WALL);
            }
        }
        if (!has_warning && (construction_data.type == BUILDING_FOUNTAIN || construction_data.type == BUILDING_BATHHOUSE)) {
            int grid_offset = map_grid_offset(x_end, y_end);
            int has_water = 0;
            if (map_terrain_is(grid_offset, TERRAIN_RESERVOIR_RANGE)) {
                has_water = 1;
            } else if (construction_data.type == BUILDING_BATHHOUSE) {
                if (map_terrain_is(grid_offset + map_grid_delta(1, 0), TERRAIN_RESERVOIR_RANGE) ||
                    map_terrain_is(grid_offset + map_grid_delta(0, 1), TERRAIN_RESERVOIR_RANGE) ||
                    map_terrain_is(grid_offset + map_grid_delta(1, 1), TERRAIN_RESERVOIR_RANGE)) {
                    has_water = 1;
                }
            }
            if (!has_water) {
                show(WARNING_WATER_PIPE_ACCESS_NEEDED);
            }
        }
        switch (construction_data.type) {
            case BUILDING_SMALL_STATUE:
            case BUILDING_MEDIUM_STATUE:
            case BUILDING_LARGE_STATUE:
            case BUILDING_FOUNTAIN:
            case BUILDING_WELL:
            case BUILDING_RESERVOIR:
            case BUILDING_GATEHOUSE:
            case BUILDING_TRIUMPHAL_ARCH:
            case BUILDING_HOUSE_VACANT_LOT:
            case BUILDING_FORT_LEGIONARIES:
            case BUILDING_FORT_JAVELIN:
            case BUILDING_FORT_MOUNTED:
                break;
            default:
            {
                int has_road = 0;
                if (map_has_road_access(x_end, y_end, size, 0)
                || (construction_data.type == BUILDING_WAREHOUSE && map_has_road_access(x_end, y_end, size, 0))
                || (construction_data.type == BUILDING_HIPPODROME && map_has_road_access_hippodrome(x_end, y_end, 0))) {
                    has_road = 1;
                }
                if (!has_road) {
                    show(WARNING_ROAD_ACCESS_NEEDED);
                }
            }
        }
        // check raw resources availability
        int raw_resource = 0;
        int finished_good = 0;
        int warning_resource_needed = 0;
        int warning_resource_building = 0;
        switch (construction_data.type) {
            case BUILDING_OIL_WORKSHOP:
                raw_resource = RESOURCE_OLIVES;
                finished_good = RESOURCE_OIL;
                warning_resource_needed = WARNING_OLIVES_NEEDED;
                warning_resource_building = WARNING_BUILD_OLIVE_FARM;
                break;
            case BUILDING_WINE_WORKSHOP:
                raw_resource = RESOURCE_VINES;
                finished_good = RESOURCE_WINE;
                warning_resource_needed = WARNING_VINES_NEEDED;
                warning_resource_building = WARNING_BUILD_VINES_FARM;
                break;
            case BUILDING_WEAPONS_WORKSHOP:
                raw_resource = RESOURCE_IRON;
                finished_good = RESOURCE_WEAPONS;
                warning_resource_needed = WARNING_IRON_NEEDED;
                warning_resource_building = WARNING_BUILD_IRON_MINE;
                break;
            case BUILDING_FURNITURE_WORKSHOP:
                raw_resource = RESOURCE_TIMBER;
                finished_good = RESOURCE_FURNITURE;
                warning_resource_needed = WARNING_TIMBER_NEEDED;
                warning_resource_building = WARNING_BUILD_TIMBER_YARD;
                break;
            case BUILDING_POTTERY_WORKSHOP:
                raw_resource = RESOURCE_CLAY;
                finished_good = RESOURCE_POTTERY;
                warning_resource_needed = WARNING_CLAY_NEEDED;
                warning_resource_building = WARNING_BUILD_CLAY_PIT;
                break;
            default:
                break;
        }
        if (raw_resource && !count_data.industry[raw_resource].active) {
            if (!city_data.resource.stored_in_warehouses[finished_good] && !city_data.resource.stored_in_warehouses[raw_resource]) {
                show(warning_resource_needed);
                int empire_offers_resource = 0;
                for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
                    if (empire_objects[i].in_use
                        && empire_objects[i].city_type == EMPIRE_CITY_TRADE
                        && empire_objects[i].resource_sell_limit[raw_resource]) {
                        empire_offers_resource = 1;
                        break;
                    }
                }
                if (our_city_can_produce_resource(raw_resource)) {
                    show(warning_resource_building);
                } else if (empire_offers_resource && !resource_import_trade_route_open(raw_resource)) {
                    show(WARNING_OPEN_TRADE_TO_IMPORT);
                } else if (city_data.resource.trade_status[raw_resource] != TRADE_STATUS_IMPORT) {
                    show(WARNING_TRADE_IMPORT_RESOURCE);
                }
            }
        }
        // phew, checks done!
        struct building_t *b;
        b = building_create(construction_data.type, x_end, y_end);
        game_undo_add_building(b);
        if (b->id <= 0) {
            return;
        }
        switch (b->type) {
            case BUILDING_HOUSE_LARGE_TENT:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2781, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_SMALL_SHACK:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2785, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_LARGE_SHACK:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2787, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_SMALL_HOVEL:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2791, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_LARGE_HOVEL:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2793, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_SMALL_CASA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2797, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_LARGE_CASA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2799, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_SMALL_INSULA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2803, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_MEDIUM_INSULA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2805, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_LARGE_INSULA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2809, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_GRAND_INSULA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2811, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_SMALL_VILLA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2813, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_MEDIUM_VILLA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2815, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_LARGE_VILLA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2817, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_GRAND_VILLA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2818, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_SMALL_PALACE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2819, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_MEDIUM_PALACE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2820, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_LARGE_PALACE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2821, TERRAIN_BUILDING);
                break;
            case BUILDING_HOUSE_LUXURY_PALACE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2822, TERRAIN_BUILDING);
                break;
            case BUILDING_AMPHITHEATER:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3039, TERRAIN_BUILDING);
                break;
            case BUILDING_THEATER:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3051, TERRAIN_BUILDING);
                break;
            case BUILDING_COLOSSEUM:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3074, TERRAIN_BUILDING);
                break;
            case BUILDING_GLADIATOR_SCHOOL:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3089, TERRAIN_BUILDING);
                break;
            case BUILDING_LION_HOUSE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3100, TERRAIN_BUILDING);
                break;
            case BUILDING_ACTOR_COLONY:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3119, TERRAIN_BUILDING);
                break;
            case BUILDING_CHARIOT_MAKER:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3129, TERRAIN_BUILDING);
                break;
            case BUILDING_SMALL_STATUE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3155, TERRAIN_BUILDING);
                break;
            case BUILDING_MEDIUM_STATUE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3156, TERRAIN_BUILDING);
                break;
            case BUILDING_LARGE_STATUE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3157, TERRAIN_BUILDING);
                break;
            case BUILDING_DOCTOR:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3184, TERRAIN_BUILDING);
                break;
            case BUILDING_HOSPITAL:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3208, TERRAIN_BUILDING);
                break;
            case BUILDING_BATHHOUSE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3196, TERRAIN_BUILDING);
                break;
            case BUILDING_BARBER:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3183, TERRAIN_BUILDING);
                break;
            case BUILDING_SCHOOL:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2954, TERRAIN_BUILDING);
                break;
            case BUILDING_ACADEMY:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2956, TERRAIN_BUILDING);
                break;
            case BUILDING_LIBRARY:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2955, TERRAIN_BUILDING);
                break;
            case BUILDING_PREFECTURE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3165, TERRAIN_BUILDING);
                break;
            case BUILDING_WHEAT_FARM:
                map_building_tiles_add_farm(b->id, b->x, b->y, 2884, 0);
                break;
            case BUILDING_VEGETABLE_FARM:
                map_building_tiles_add_farm(b->id, b->x, b->y, 2889, 0);
                break;
            case BUILDING_FRUIT_FARM:
                map_building_tiles_add_farm(b->id, b->x, b->y, 2894, 0);
                break;
            case BUILDING_OLIVE_FARM:
                map_building_tiles_add_farm(b->id, b->x, b->y, 2899, 0);
                break;
            case BUILDING_VINES_FARM:
                map_building_tiles_add_farm(b->id, b->x, b->y, 2904, 0);
                break;
            case BUILDING_PIG_FARM:
                map_building_tiles_add_farm(b->id, b->x, b->y, 2904, 0);
                break;
            case BUILDING_MARBLE_QUARRY:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2914, TERRAIN_BUILDING);
                break;
            case BUILDING_IRON_MINE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2925, TERRAIN_BUILDING);
                break;
            case BUILDING_TIMBER_YARD:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2943, TERRAIN_BUILDING);
                break;
            case BUILDING_CLAY_PIT:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2932, TERRAIN_BUILDING);
                break;
            case BUILDING_WINE_WORKSHOP:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2957, TERRAIN_BUILDING);
                break;
            case BUILDING_OIL_WORKSHOP:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2970, TERRAIN_BUILDING);
                break;
            case BUILDING_WEAPONS_WORKSHOP:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2979, TERRAIN_BUILDING);
                break;
            case BUILDING_FURNITURE_WORKSHOP:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2988, TERRAIN_BUILDING);
                break;
            case BUILDING_POTTERY_WORKSHOP:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3003, TERRAIN_BUILDING);
                break;
            case BUILDING_GRANARY:
                b->storage_id = building_storage_create();
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3011, TERRAIN_BUILDING);
                foreach_region_tile(b->x - 1, b->y - 1, b->x + 5 - 2, b->y + 5 - 2, set_road_image);
                break;
            case BUILDING_MARKET:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2872, TERRAIN_BUILDING);
                break;
            case BUILDING_GOVERNORS_HOUSE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2824, TERRAIN_BUILDING);
                break;
            case BUILDING_GOVERNORS_VILLA:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2825, TERRAIN_BUILDING);
                break;
            case BUILDING_GOVERNORS_PALACE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2826, TERRAIN_BUILDING);
                break;
            case BUILDING_MISSION_POST:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3318, TERRAIN_BUILDING);
                break;
            case BUILDING_ENGINEERS_POST:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3281, TERRAIN_BUILDING);
                break;
            case BUILDING_FORUM:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3164, TERRAIN_BUILDING);
                break;
            case BUILDING_RESERVOIR:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2863, TERRAIN_BUILDING);
                break;
            case BUILDING_FOUNTAIN:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2839, TERRAIN_BUILDING);
                break;
            case BUILDING_WELL:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2830, TERRAIN_BUILDING);
                break;
            case BUILDING_MILITARY_ACADEMY:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3182, TERRAIN_BUILDING);
                break;
            case BUILDING_SMALL_TEMPLE_CERES:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3209, TERRAIN_BUILDING);
                break;
            case BUILDING_SMALL_TEMPLE_NEPTUNE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3211, TERRAIN_BUILDING);
                break;
            case BUILDING_SMALL_TEMPLE_MERCURY:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3213, TERRAIN_BUILDING);
                break;
            case BUILDING_SMALL_TEMPLE_MARS:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3215, TERRAIN_BUILDING);
                break;
            case BUILDING_SMALL_TEMPLE_VENUS:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3217, TERRAIN_BUILDING);
                break;
            case BUILDING_LARGE_TEMPLE_CERES:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3210, TERRAIN_BUILDING);
                break;
            case BUILDING_LARGE_TEMPLE_NEPTUNE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3212, TERRAIN_BUILDING);
                break;
            case BUILDING_LARGE_TEMPLE_MERCURY:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3214, TERRAIN_BUILDING);
                break;
            case BUILDING_LARGE_TEMPLE_MARS:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3216, TERRAIN_BUILDING);
                break;
            case BUILDING_LARGE_TEMPLE_VENUS:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3218, TERRAIN_BUILDING);
                break;
            case BUILDING_ORACLE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3219, TERRAIN_BUILDING);
                break;
            case BUILDING_SHIPYARD:
                b->data.industry.orientation = waterside_orientation_abs;
                map_water_add_building(b->id, b->x, b->y, 2, 3226 + waterside_orientation_rel);
                break;
            case BUILDING_WHARF:
                b->data.industry.orientation = waterside_orientation_abs;
                map_water_add_building(b->id, b->x, b->y, 2, 3277 + waterside_orientation_rel);
                break;
            case BUILDING_DOCK:
                city_data.building.working_docks++;
                b->data.dock.orientation = waterside_orientation_abs;
                {
                    int image_id;
                    switch (waterside_orientation_rel) {
                        case 0: image_id = 3230; break;
                        case 1: image_id = 3242; break;
                        case 2: image_id = 3254; break;
                        default:image_id = 3266; break;
                    }
                    map_water_add_building(b->id, b->x, b->y, b->size, image_id);
                }
                break;
            case BUILDING_TOWER:
            {
                int x_min, y_min, x_max, y_max;
                map_grid_get_area(b->x, b->y, size, 0, &x_min, &y_min, &x_max, &y_max);

                for (int yy = y_min; yy <= y_max; yy++) {
                    for (int xx = x_min; xx <= x_max; xx++) {
                        terrain_grid.items[map_grid_offset(xx, yy)] &= ~TERRAIN_WALL;
                    }
                }
                map_building_tiles_add(b->id, b->x, b->y, b->size, 696,
                    TERRAIN_BUILDING | TERRAIN_GATEHOUSE);
                foreach_region_tile(b->x - 1, b->y - 1, b->x + 5 - 2, b->y + 5 - 2, set_wall_image);
                break;
            }
            case BUILDING_GATEHOUSE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 696 + building_orientation, TERRAIN_BUILDING | TERRAIN_GATEHOUSE);
                b->subtype.orientation = building_orientation;
                map_orientation_update_buildings();
                map_terrain_add_gatehouse_roads(b->x, b->y, building_orientation);
                foreach_region_tile(b->x - 1, b->y - 1, b->x + 5 - 2, b->y + 5 - 2, set_road_image);
                map_tiles_update_all_plazas();
                foreach_region_tile(b->x - 1, b->y - 1, b->x + 5 - 2, b->y + 5 - 2, set_wall_image);
                break;
            case BUILDING_TRIUMPHAL_ARCH:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 821 + building_orientation - 1, TERRAIN_BUILDING);
                b->subtype.orientation = building_orientation;
                map_orientation_update_buildings();
                map_terrain_add_triumphal_arch_roads(b->x, b->y, building_orientation);
                foreach_region_tile(b->x - 1, b->y - 1, b->x + 5 - 2, b->y + 5 - 2, set_road_image);
                map_tiles_update_all_plazas();
                city_data.building.triumphal_arches_available--;
                if (!city_data.building.triumphal_arches_available) { // none left
                    build_menus[MENU_ADMINISTRATION].menu_items[10].building_id = 0;
                    // disable menu if this was the only enabled item
                    int menu_enabled = 0;
                    for (int j = 0; j < MAX_ITEMS_PER_BUILD_MENU; j++) {
                        if (build_menus[MENU_ADMINISTRATION].menu_items[j].building_id) {
                            menu_enabled = 1;
                            break;
                        }
                    }
                    if (!menu_enabled) {
                        build_menus[MENU_ADMINISTRATION].is_enabled = 0;
                    }
                }
                building_construction_clear_type();
                break;
            case BUILDING_SENATE:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3158, TERRAIN_BUILDING);
                city_data.building.senate_placed = 1;
                if (!city_data.building.senate_grid_offset) {
                    city_data.building.senate_building_id = b->id;
                    city_data.building.senate_x = b->x;
                    city_data.building.senate_y = b->y;
                    city_data.building.senate_grid_offset = b->grid_offset;
                }
                break;
            case BUILDING_BARRACKS:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3181, TERRAIN_BUILDING);
                if (!city_data.building.barracks_grid_offset) {
                    city_data.building.barracks_building_id = b->id;
                    city_data.building.barracks_x = b->x;
                    city_data.building.barracks_y = b->y;
                    city_data.building.barracks_grid_offset = b->grid_offset;
                }
                break;
            case BUILDING_WAREHOUSE:
                b->storage_id = building_storage_create();
                b->prev_part_building_id = 0;
                map_building_tiles_add(b->id, b->x, b->y, 1, 3319, TERRAIN_BUILDING);
                struct building_t *prev = b;
                prev = add_warehouse_space(b->x + 1, b->y, prev);
                prev = add_warehouse_space(b->x + 2, b->y, prev);
                prev = add_warehouse_space(b->x, b->y + 1, prev);
                prev = add_warehouse_space(b->x + 1, b->y + 1, prev);
                prev = add_warehouse_space(b->x + 2, b->y + 1, prev);
                prev = add_warehouse_space(b->x, b->y + 2, prev);
                prev = add_warehouse_space(b->x + 1, b->y + 2, prev);
                prev = add_warehouse_space(b->x + 2, b->y + 2, prev);
                prev->next_part_building_id = 0;
                break;
            case BUILDING_HIPPODROME:
            {
                int image1 = 7780;
                int image2 = 7789;
                city_data.building.hippodrome_placed = 1;
                int orientation = view_data.orientation;
                struct building_t *part1 = b;
                if (orientation == DIR_0_TOP || orientation == DIR_4_BOTTOM) {
                    part1->subtype.orientation = 0;
                } else {
                    part1->subtype.orientation = 3;
                }
                part1->prev_part_building_id = 0;
                int image_id;
                switch (orientation) {
                    case DIR_0_TOP:
                        image_id = image2;
                        break;
                    case DIR_2_RIGHT:
                        image_id = image1 + 4;
                        break;
                    case DIR_4_BOTTOM:
                        image_id = image2 + 4;
                        break;
                    case DIR_6_LEFT:
                        image_id = image1;
                        break;
                    default:
                        return;
                }
                map_building_tiles_add(b->id, b->x, b->y, b->size, image_id, TERRAIN_BUILDING);
                struct building_t *part2 = building_create(BUILDING_HIPPODROME, b->x + 5, b->y);
                game_undo_add_building(part2);
                if (orientation == DIR_0_TOP || orientation == DIR_4_BOTTOM) {
                    part2->subtype.orientation = 1;
                } else {
                    part2->subtype.orientation = 4;
                }
                part2->prev_part_building_id = part1->id;
                part1->next_part_building_id = part2->id;
                part2->next_part_building_id = 0;
                switch (orientation) {
                    case DIR_0_TOP:
                    case DIR_4_BOTTOM:
                        image_id = image2 + 2;
                        break;
                    case DIR_2_RIGHT:
                    case DIR_6_LEFT:
                        image_id = image1 + 2;
                        break;
                }
                map_building_tiles_add(part2->id, b->x + 5, b->y, b->size, image_id, TERRAIN_BUILDING);
                struct building_t *part3 = building_create(BUILDING_HIPPODROME, b->x + 10, b->y);
                game_undo_add_building(part3);
                if (orientation == DIR_0_TOP || orientation == DIR_4_BOTTOM) {
                    part3->subtype.orientation = 2;
                } else {
                    part3->subtype.orientation = 5;
                }
                part3->prev_part_building_id = part2->id;
                part2->next_part_building_id = part3->id;
                part3->next_part_building_id = 0;
                switch (orientation) {
                    case DIR_0_TOP:
                        image_id = image2 + 4;
                        break;
                    case DIR_2_RIGHT:
                        image_id = image1;
                        break;
                    case DIR_4_BOTTOM:
                        image_id = image2;
                        break;
                    case DIR_6_LEFT:
                        image_id = image1 + 4;
                        break;
                }
                map_building_tiles_add(part3->id, b->x + 10, b->y, b->size, image_id, TERRAIN_BUILDING);
                break;
            }
            case BUILDING_FORT_LEGIONARIES:
            case BUILDING_FORT_JAVELIN:
            case BUILDING_FORT_MOUNTED:
                b->prev_part_building_id = 0;
                map_building_tiles_add(b->id, b->x, b->y, b->size, 3176, TERRAIN_BUILDING);
                if (b->type == BUILDING_FORT_LEGIONARIES) {
                    b->subtype.fort_figure_type = FIGURE_FORT_LEGIONARY;
                } else if (b->type == BUILDING_FORT_JAVELIN) {
                    b->subtype.fort_figure_type = FIGURE_FORT_JAVELIN;
                } else if (b->type == BUILDING_FORT_MOUNTED) {
                    b->subtype.fort_figure_type = FIGURE_FORT_MOUNTED;
                }
                for (int i = 0; i < MAX_LEGIONS; i++) {
                    if (!legion_formations[i].in_use) {
                        struct formation_t *m = &legion_formations[i];
                        m->in_use = 1;
                        m->figure_type = b->subtype.fort_figure_type;
                        m->max_figures = MAX_FORMATION_FIGURES;
                        m->layout = FORMATION_DOUBLE_LINE_1;
                        if (b->subtype.fort_figure_type == FIGURE_FORT_LEGIONARY) {
                            m->max_morale = 80;
                        } else {
                            m->max_morale = 60;
                        }
                        m->morale = m->max_morale;
                        m->building_id = b->id;
                        m->standard_x = b->x + 3;
                        m->standard_y = b->y - 1;
                        struct figure_t *standard = figure_create(FIGURE_FORT_STANDARD, m->standard_x, m->standard_y, DIR_0_TOP);
                        standard->building_id = b->id;
                        standard->formation_id = m->id;
                        standard->terrain_usage = TERRAIN_USAGE_ANY;
                        m->legion_standard__figure_id = standard->id;
                        city_data.military.total_legions++;
                        if (m->figure_type == FIGURE_FORT_LEGIONARY) {
                            city_data.military.legionary_legions++;
                        }
                        b->formation_id = m->id;
                        break;
                    }
                }
                // create parade ground
                struct building_t *ground = building_create(BUILDING_FORT_GROUND, b->x + 3, b->y - 1);
                game_undo_add_building(ground);
                ground->formation_id = b->formation_id;
                ground->prev_part_building_id = b->id;
                b->next_part_building_id = ground->id;
                ground->next_part_building_id = 0;
                map_building_tiles_add(ground->id, b->x + 3, b->y - 1, 4, 3177, TERRAIN_BUILDING);
                break;
            case BUILDING_NATIVE_HUT:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2827 + (random_data.random1_7bit & 1), TERRAIN_BUILDING);
                break;
            case BUILDING_NATIVE_MEETING:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2829, TERRAIN_BUILDING);
                break;
            case BUILDING_NATIVE_CROPS:
                map_building_tiles_add(b->id, b->x, b->y, b->size, 2884, TERRAIN_BUILDING);
                break;
        }
        map_routing_update_land();
        map_routing_update_walls();
    }
    if ((construction_data.type >= BUILDING_LARGE_TEMPLE_CERES && construction_data.type <= BUILDING_LARGE_TEMPLE_VENUS) || construction_data.type == BUILDING_ORACLE) {
        building_warehouses_remove_resource(RESOURCE_MARBLE, 2);
    }
    if (construction_data.type >= BUILDING_SMALL_TEMPLE_CERES && construction_data.type <= BUILDING_SMALL_TEMPLE_VENUS) {
        construction_data.type++;
        if (construction_data.type > BUILDING_SMALL_TEMPLE_VENUS) {
            construction_data.type = BUILDING_SMALL_TEMPLE_CERES;
        }
    }
    if (construction_data.type >= BUILDING_LARGE_TEMPLE_CERES && construction_data.type <= BUILDING_LARGE_TEMPLE_VENUS) {
        construction_data.type++;
        if (construction_data.type > BUILDING_LARGE_TEMPLE_VENUS) {
            construction_data.type = BUILDING_LARGE_TEMPLE_CERES;
        }
    }
    city_finance_process_construction(placement_cost);
    // move herds away
    for (int i = 0; i < MAX_HERD_POINTS; i++) {
        if (herd_formations[i].in_use && herd_formations[i].figure_type != FIGURE_WOLF) {
            if (calc_maximum_distance(x_end, y_end, herd_formations[i].destination_x, herd_formations[i].destination_y) <= 6) {
                // force new roaming destination search
                herd_formations[i].wait_ticks_movement = SHEEP_HERD_ROAM_DELAY; // longest roam delay
            }
        }
    }
    if (construction_data.type != BUILDING_TRIUMPHAL_ARCH) {
        undo_data.ready = 1;
        undo_data.timeout_ticks = 500;
        undo_data.building_cost = placement_cost;
        refresh_current_window = 1;
    }
    construction_data.draw_as_constructing = 0;
}

static void draw_common_advisor_ui(void)
{
    if (refresh_current_window) {
        image_draw_scaled(7776, 0, 0, current_resolution_width, current_resolution_height);
        image_draw(7750, screen_center_x - 320, screen_center_y + 256); // bottom bar
        image_draw(1137, screen_center_x + 268, screen_center_y + 264); // return to city button
    }
    for (int i = 0; i < ADVISOR_MAX_ENTRIES; i++) {
        if (i == settings[SETTINGS_LAST_ADVISOR].config_value) {
            image_draw(1138 + i, screen_center_x - 308 + 48 * i, screen_center_y + 264);
        } else {
            image_draw(1125 + i, screen_center_x - 308 + 48 * i, screen_center_y + 264);
        }
    }
}

static void text_draw_number_centered_prefix(int value, char prefix, int x_offset, int y_offset, int box_width, int font)
{
    char str[NUMBER_BUFFER_LENGTH];
    number_to_string(str, value, prefix, " ");
    text_draw_centered(str, x_offset, y_offset, box_width, font, 0);
}

static void create_new_line_input_text(int text_y)
{
    text_num_completed_lines++;
    text_lines[text_num_completed_lines].line_y = text_y + text_num_completed_lines * (DEFINITIONS_DEFAULT[input_text_font].line_height + DEFINITIONS_DEFAULT[input_text_font].line_spacing);
}

static void parse_text(char *text, int text_x, int text_y, int text_length, int line_max_width, int font)
{
    memset(text_lines, 0, sizeof(text_lines));
    text_num_completed_lines = 0;
    int char_width = 0;
    int current_char_start_x = text_x;
    int line_counter_reset = 0;
    text_lines[0].line_y = text_y;
    for (int i = 0; i < text_length; i++) {
        char_width = get_char_width(text[i], font);
        if (i && text[i] >= '0' && text[i] <= '9') { // up to 4 numeric chars (max 9999) after '@' are for graphics drawing
            for (int j = i - 1; j > i - 5 && j >= 0; j--) {
                if (text[j] == '@') {
                    char_width = 0;
                    break;
                }
            }
        }
        if (text[i] == '\n') {
            text_lines[text_num_completed_lines].chars[i - line_counter_reset].position_in_text = i;
            text_lines[text_num_completed_lines].chars[i - line_counter_reset].x_start = current_char_start_x;
            text_lines[text_num_completed_lines].chars[i - line_counter_reset].x_end = current_char_start_x + char_width;
            text_lines[text_num_completed_lines].num_chars++;
            current_char_start_x = text_x;
            line_counter_reset = i + 1;
            create_new_line_input_text(text_y);
            continue;
        }
        if (current_char_start_x + char_width > text_x + line_max_width) {
            current_char_start_x = text_x;
            line_counter_reset = i;
            create_new_line_input_text(text_y);
            int num_chars_transfer = 0;
            for (int j = i - 1; j > i - 21 && j >= 0; j--) { // max word length 20 chars
                if (text[j] == '@') {
                    break;
                }
                if (text[j] == ' ') { // word found, transfer all chars after the space to the new line
                    int prev_line_initial_num_chars = text_lines[text_num_completed_lines - 1].num_chars;
                    for (int k = 0; k < num_chars_transfer; k++) {
                        int carried_over_char_width = text_lines[text_num_completed_lines - 1].chars[prev_line_initial_num_chars - num_chars_transfer + k].x_end -
                            text_lines[text_num_completed_lines - 1].chars[prev_line_initial_num_chars - num_chars_transfer + k].x_start;
                        text_lines[text_num_completed_lines].chars[k].position_in_text = j + 1 + k;
                        text_lines[text_num_completed_lines].chars[k].x_start = current_char_start_x;
                        text_lines[text_num_completed_lines].chars[k].x_end = current_char_start_x + carried_over_char_width;
                        text_lines[text_num_completed_lines].num_chars++;
                        text_lines[text_num_completed_lines].line_width += carried_over_char_width;
                        text_lines[text_num_completed_lines - 1].chars[prev_line_initial_num_chars - num_chars_transfer + k].position_in_text = 0;
                        text_lines[text_num_completed_lines - 1].chars[prev_line_initial_num_chars - num_chars_transfer + k].x_start = 0;
                        text_lines[text_num_completed_lines - 1].chars[prev_line_initial_num_chars - num_chars_transfer + k].x_end = 0;
                        text_lines[text_num_completed_lines - 1].num_chars--;
                        text_lines[text_num_completed_lines - 1].line_width -= carried_over_char_width;
                        current_char_start_x += carried_over_char_width;
                        line_counter_reset--;
                    }
                    break;
                }
                num_chars_transfer++;
            }
        }
        text_lines[text_num_completed_lines].chars[i - line_counter_reset].position_in_text = i;
        text_lines[text_num_completed_lines].chars[i - line_counter_reset].x_start = current_char_start_x;
        text_lines[text_num_completed_lines].chars[i - line_counter_reset].x_end = current_char_start_x + char_width;
        text_lines[text_num_completed_lines].num_chars++;
        text_lines[text_num_completed_lines].line_width += char_width;
        current_char_start_x += char_width;
    }
}

static void int_to_string(int num, char *resulting_string)
{
    int is_negative = 0;
    if (num < 0) {
        is_negative = 1;
        num = -num;
    }
    int length = 0;
    while (num) {
        int rem = num % 10;
        resulting_string[length] = rem + '0';
        num = num / 10;
        length++;
    }
    if (is_negative) {
        resulting_string[length] = '-';
        length++;
    }
    char tmp[length];
    for (int i = 0; i < length; i++) {
        tmp[i] = resulting_string[length - i - 1];
    }
    for (int i = 0; i < length; i++) {
        resulting_string[i] = tmp[i];
    }
    resulting_string[length] = '\0';
}

static void handle_input_text_mouse_click(int text_field_number, int text_field_x, int text_field_y, int max_text_length, int text_font, char *initial_text, int max_lines, int max_line_width)
{
    previous_text_field_active = text_field_active;
    text_field_active = text_field_number;
    if (!text_field_active || text_field_active != previous_text_field_active) {
        input_text_x = text_field_x + 10;
        input_text_y = text_field_y + 10;
        input_text_max_length = max_text_length;
        input_text_font = text_font;
        if (!input_text_numeric_only) {
            string_copy(initial_text, input_text_string, max_text_length);
        }
        input_text_current_length = string_length(input_text_string);
        input_text_max_lines = max_lines;
        input_text_field_line_max_width = max_line_width;
        parse_text(input_text_string, input_text_x, input_text_y, input_text_current_length, input_text_field_line_max_width, input_text_font);
    }
    for (int i = 0; i <= text_num_completed_lines; i++) {
        if (mouse_y > text_lines[i].line_y - DEFINITIONS_DEFAULT[input_text_font].line_spacing / 2) {
            input_text_cursor_current_line = i;
        }
    }
    if (text_lines[input_text_cursor_current_line].num_chars) {
        if (mouse_x > input_text_x + text_lines[input_text_cursor_current_line].line_width) { // clicked after last char on line (also when '\n' is the only char on line)
            input_text_cursor_position = text_lines[input_text_cursor_current_line].chars[text_lines[input_text_cursor_current_line].num_chars - 1].position_in_text + 1;
            input_text_current_line_cursor_position = text_lines[input_text_cursor_current_line].num_chars;
            input_text_cursor_current_x_offset = text_lines[input_text_cursor_current_line].chars[text_lines[input_text_cursor_current_line].num_chars - 1].x_end - input_text_x;
        } else {
            for (int i = 0; i < text_lines[input_text_cursor_current_line].num_chars; i++) {
                if (text_lines[input_text_cursor_current_line].chars[i].x_end >= mouse_x) {
                    if (abs(text_lines[input_text_cursor_current_line].chars[i].x_start - mouse_x) < text_lines[input_text_cursor_current_line].chars[i].x_end - mouse_x) {
                        input_text_cursor_position = text_lines[input_text_cursor_current_line].chars[i].position_in_text;
                        input_text_current_line_cursor_position = i;
                        input_text_cursor_current_x_offset = text_lines[input_text_cursor_current_line].chars[i].x_start - input_text_x;
                    } else {
                        input_text_cursor_position = text_lines[input_text_cursor_current_line].chars[i].position_in_text + 1;
                        input_text_current_line_cursor_position = i + 1;
                        input_text_cursor_current_x_offset = text_lines[input_text_cursor_current_line].chars[i].x_end - input_text_x;
                    }
                    break;
                }
            }
        }
    } else {
        if (input_text_cursor_current_line) { // empty last line
            input_text_cursor_position = text_lines[input_text_cursor_current_line - 1].chars[text_lines[input_text_cursor_current_line - 1].num_chars - 1].position_in_text + 1;
        } else { // empty text field
            input_text_cursor_position = 0;
        }
        input_text_current_line_cursor_position = 0;
        input_text_cursor_current_x_offset = 0;
    }
    SDL_StartTextInput();
}

static void move_input_text_cursor_next_line(void)
{
    input_text_cursor_current_line++;
    input_text_current_line_cursor_position = 0;
    input_text_cursor_current_x_offset = 0;
}

static void move_input_text_cursor_to_beginning(void)
{
    input_text_cursor_position = 0;
    input_text_cursor_current_line = 0;
    input_text_current_line_cursor_position = 0;
    input_text_cursor_current_x_offset = 0;
}

static void activate_numeric_input_text_field(int initial_num, int allow_negative)
{
    if (!text_field_active || text_field_active != previous_text_field_active) {
        int_to_string(initial_num, input_text_string);
        input_text_numeric_only = 1;
        input_text_numeric_allow_negative = allow_negative;
    }
}

static void hide_dropdown_list(void)
{
    dropdown_list_selected = 0;
    refresh_current_window = 1;
}

static void save_starting_conditions_numeric_field(void)
{
    switch (text_field_active) {
        case 1:
            scenario.start_year = string_to_int(input_text_string);
            if (scenario.start_year < -500) {
                scenario.start_year = -500;
            } else if (scenario.start_year > 500) {
                scenario.start_year = 500;
            }
            break;
        case 2:
            scenario.initial_favor = string_to_int(input_text_string);
            if (scenario.initial_favor > 100) {
                scenario.initial_favor = 100;
            }
            break;
        case 3:
            scenario.initial_funds = string_to_int(input_text_string);
            break;
        case 4:
            scenario.rescue_loan = string_to_int(input_text_string);
            break;
        case 5:
            scenario.initial_personal_savings = string_to_int(input_text_string);
            break;
    }
    stop_text_input();
}

static void save_win_criteria_numeric_field(void)
{
    switch (text_field_active) {
        case 1:
            scenario.population_win_criteria = string_to_int(input_text_string);
            if (scenario.population_win_criteria < 0) {
                scenario.population_win_criteria = 0;
            }
            break;
        case 2:
            scenario.culture_win_criteria = string_to_int(input_text_string);
            if (scenario.culture_win_criteria > 100) {
                scenario.culture_win_criteria = 100;
            }
            break;
        case 3:
            scenario.prosperity_win_criteria = string_to_int(input_text_string);
            if (scenario.prosperity_win_criteria > 100) {
                scenario.prosperity_win_criteria = 100;
            }
            break;
        case 4:
            scenario.peace_win_criteria = string_to_int(input_text_string);
            if (scenario.peace_win_criteria > 100) {
                scenario.peace_win_criteria = 100;
            }
            break;
        case 5:
            scenario.favor_win_criteria = string_to_int(input_text_string);
            if (scenario.favor_win_criteria > 100) {
                scenario.favor_win_criteria = 100;
            }
            break;
        case 6:
            scenario.time_limit_win_criteria = string_to_int(input_text_string);
            if (scenario.time_limit_win_criteria > 500) {
                scenario.time_limit_win_criteria = 500;
            }
            if (scenario.time_limit_win_criteria) {
                scenario.survival_time_win_criteria = 0;
            }
            break;
        case 7:
            scenario.survival_time_win_criteria = string_to_int(input_text_string);
            if (scenario.survival_time_win_criteria > 500) {
                scenario.survival_time_win_criteria = 500;
            }
            if (scenario.survival_time_win_criteria) {
                scenario.time_limit_win_criteria = 0;
            }
            break;
    }
    stop_text_input();
}

static void save_special_events_numeric_field(void)
{
    scenario.gladiator_revolt.year_offset = string_to_int(input_text_string);
    if (!scenario.gladiator_revolt.year_offset && !scenario.gladiator_revolt.month) {
        scenario.gladiator_revolt.month++; // don't allow Jan year 0 event
    } else if (scenario.gladiator_revolt.year_offset > 500) {
        scenario.gladiator_revolt.year_offset = 500;
    }
    stop_text_input();
}

static void save_edit_request_numeric_field(void)
{
    switch (text_field_active) {
        case 1:
            scenario.requests[id_edit_request].year_offset = string_to_int(input_text_string);
            if (!scenario.requests[id_edit_request].year_offset && !scenario.requests[id_edit_request].month) {
                scenario.requests[id_edit_request].month++; // don't allow Jan year 0 event
            } else if (scenario.requests[id_edit_request].year_offset > 500) {
                scenario.requests[id_edit_request].year_offset = 500;
            }
            break;
        case 4:
            scenario.requests[id_edit_request].amount = string_to_int(input_text_string);
            if (!scenario.requests[id_edit_request].amount) {
                scenario.requests[id_edit_request].amount++; // don't allow 0
            }
            break;
        case 5:
            scenario.requests[id_edit_request].years_deadline = string_to_int(input_text_string);
            if (!scenario.requests[id_edit_request].years_deadline) {
                scenario.requests[id_edit_request].years_deadline++; // don't allow 0
            }
            scenario.requests[id_edit_request].months_to_comply = 12 * scenario.requests[id_edit_request].years_deadline;
            break;
        case 6:
            scenario.requests[id_edit_request].favor = string_to_int(input_text_string);
            break;
    }
    stop_text_input();
}

static void save_custom_message_attributes_text_field(void)
{
    switch (text_field_active) {
        case 1:
            scenario.editor_custom_messages[custom_message_id].year_offset = string_to_int(input_text_string);
            if (!scenario.editor_custom_messages[custom_message_id].year_offset && !scenario.editor_custom_messages[custom_message_id].month) {
                scenario.editor_custom_messages[custom_message_id].month++; // don't allow Jan year 0 event
            } else if (scenario.editor_custom_messages[custom_message_id].year_offset > 500) {
                scenario.editor_custom_messages[custom_message_id].year_offset = 500;
            }
            break;
        case 4:
            string_copy(input_text_string, scenario.editor_custom_messages[custom_message_id].video_file, input_text_max_length);
            break;
    }
    stop_text_input();
}

static void save_earthquake_year_offset(void)
{
    scenario.earthquakes[id_edit_earthquake].year_offset = string_to_int(input_text_string);
    if (!scenario.earthquakes[id_edit_earthquake].year_offset && !scenario.earthquakes[id_edit_earthquake].month) {
        scenario.earthquakes[id_edit_earthquake].month++; // don't allow Jan year 0 event
    } else if (scenario.earthquakes[id_edit_earthquake].year_offset > 500) {
        scenario.earthquakes[id_edit_earthquake].year_offset = 500;
    }
    stop_text_input();
}

static void save_invasions_text_field(void)
{
    switch (text_field_active) {
        case 1:
            scenario.invasions[id_edit_invasion].year_offset = string_to_int(input_text_string);
            if (!scenario.invasions[id_edit_invasion].year_offset && !scenario.invasions[id_edit_invasion].month) {
                scenario.invasions[id_edit_invasion].month++; // don't allow Jan year 0 event
            } else if (scenario.invasions[id_edit_invasion].year_offset > 500) {
                scenario.invasions[id_edit_invasion].year_offset = 500;
            }
            break;
        case 3:
            scenario.invasions[id_edit_invasion].amount = string_to_int(input_text_string);
            // if this is set to 0, you get the incoming battle messages, but the enemies never show up... could be a cool trick for a map
            if (scenario.invasions[id_edit_invasion].amount > 256) {
                scenario.invasions[id_edit_invasion].amount = 256; // cap invaders amount

            }
            break;
    }
    stop_text_input();
}

static void save_price_change_text_field(void)
{
    switch (text_field_active) {
        case 1:
            scenario.price_changes[id_edit_price_change].year_offset = string_to_int(input_text_string);
            if (!scenario.price_changes[id_edit_price_change].year_offset && !scenario.price_changes[id_edit_price_change].month) {
                scenario.price_changes[id_edit_price_change].month++; // don't allow Jan year 0 event
            } else if (scenario.price_changes[id_edit_price_change].year_offset > 500) {
                scenario.price_changes[id_edit_price_change].year_offset = 500;
            }
            break;
        case 2:
            scenario.price_changes[id_edit_price_change].amount = string_to_int(input_text_string);
            if (scenario.price_changes[id_edit_price_change].amount > 99) {
                scenario.price_changes[id_edit_price_change].amount = 99;
            }
            break;
    }
    stop_text_input();
}

static void save_demand_change_text_field(void)
{
    scenario.demand_changes[id_demand_route].year_offset = string_to_int(input_text_string);
    if (!scenario.demand_changes[id_demand_route].year_offset && !scenario.demand_changes[id_demand_route].month) {
        scenario.demand_changes[id_demand_route].month++; // don't allow Jan year 0 event
    } else if (scenario.demand_changes[id_demand_route].year_offset > 500) {
        scenario.demand_changes[id_demand_route].year_offset = 500;
    }
    stop_text_input();
}

static void save_editor_empire_text_field(void)
{
    switch (text_field_active) {
        case 1:
            selected_empire_object->trade_route_cost = string_to_int(input_text_string);
            break;
        case 2:
            scenario.empire.expansion_year = string_to_int(input_text_string);
            break;
    }
    stop_text_input();
}

static void hide_editor_top_menu(void)
{
    dropdown_list_selected = 0;
    top_menu_data.open_sub_menu = TOP_MENU_NONE;
}

static int resource_export_trade_route_open(int resource)
{
    for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
        if (empire_objects[i].in_use
            && empire_objects[i].city_type == EMPIRE_CITY_TRADE
            && empire_objects[i].trade_route_open
            && empire_objects[i].resource_buy_limit[resource]) {
            return 1;
        }
    }
    return 0;
}

static void show_messages_window(void)
{
    city_message_sort_and_compact();
    // scrollbar_init(&scrollbar_message_list, message_data.scroll_position, message_data.total_messages - MAX_MESSAGES_IN_WINDOW);
    change_window(WINDOW_MESSAGE_LIST);
}

static void scroll_empire_arrow_keys(void)
{
    if (is_key_scrolling_left) {
        empire_data.scroll_x -= 10;
    }
    if (is_key_scrolling_right) {
        empire_data.scroll_x += 10;
    }
    if (is_key_scrolling_up) {
        empire_data.scroll_y -= 10;
    }
    if (is_key_scrolling_down) {
        empire_data.scroll_y += 10;
    }
    enforce_scroll_boundaries_empire();
}

static void start_mouse_scroll_drag(void)
{
    if (!configs[CONFIG_UI_DISABLE_RIGHT_CLICK_MAP_DRAG].config_value && mouse_x < sidebar_x_offset && mouse_y >= TOP_BAR_HEIGHT && mouse_y < map_y_max) { // mouse inside map
        SDL_SetRelativeMouseMode(SDL_TRUE);
        mouse_drag_scroll_active = 1;
        mouse_scroll_initial_x = mouse_x;
        mouse_scroll_initial_y = mouse_y;
        mouse_scroll_x = mouse_x;
        mouse_scroll_y = mouse_y;
    }
}

static void end_mouse_scroll_drag(void)
{
    if (mouse_drag_scroll_active) {
        SDL_SetRelativeMouseMode(SDL_FALSE);
        SDL_WarpMouseInWindow(SDL.window, mouse_scroll_initial_x, mouse_scroll_initial_y);
        mouse_drag_scroll_active = 0;
    }
}

static int trader_has_traded(int trader_id)
{
    return figure_trader_data.traders[trader_id].bought_amount || figure_trader_data.traders[trader_id].sold_amount;
}

static void draw_figure_list(void)
{
    struct pixel_coordinate_t coord = { 0, 0 };
    for (int i = 0; i < selected_units_count; i++) {
        int x_cam, y_cam;
        city_view_get_camera(&x_cam, &y_cam);
        int x, y;
        city_view_grid_offset_to_xy_view(selected_units_list[i]->grid_offset, &x, &y);
        city_view_set_camera(x - 2, y - 6);
        set_city_clip_rectangle();
        city_without_overlay_draw(selected_units_list[i]->id, &coord, &widget_city_data.current_tile);
        graphics_reset_clip_rectangle();
        city_view_set_camera(x_cam, y_cam);
        graphics_save_to_buffer(coord.x, coord.y, 48, 48, building_figures_data.figure_images[i]);
    }
    widget_city_draw();
    outer_panel_draw(map_center_x - 232, map_center_y - 128, 29, 16);
    inner_panel_draw(map_center_x - 216, map_center_y - 112, 27, 14);
    for (int i = 0; i < selected_units_count; i++) {
        button_border_draw(map_center_x - 208 + 60 * i, map_center_y - 104, 52, 52, selected_unit_index == i);
        graphics_draw_from_buffer(map_center_x - 206 + 60 * i, map_center_y - 102, 48, 48, building_figures_data.figure_images[i]);
    }
    button_border_draw(map_center_x - 208, map_center_y - 42, 412, 142, 0);
}

static void draw_context_employment_info(int panel_width, int y)
{
    inner_panel_draw(map_center_x - panel_width * 8, y, panel_width, 3);
    image_draw(1412, map_center_x - panel_width * 8 + 10, y + 8);
    int width = 0;
    if (selected_building->num_workers < building_properties[selected_building->type].n_laborers) {
        width = text_draw_number(selected_building->num_workers, 0, 0, map_center_x - panel_width * 8 + 38, y + 18, FONT_NORMAL_RED);
        width += text_draw("/", map_center_x - panel_width * 8 + 38 + width, y + 18, FONT_NORMAL_WHITE, COLOR_BLACK);
    } else {
        width = text_draw_number(selected_building->num_workers, 0, 0, map_center_x - panel_width * 8 + 38, y + 18, FONT_NORMAL_WHITE);
        width += text_draw("/", map_center_x - panel_width * 8 + 38 + width, y + 18, FONT_NORMAL_WHITE, COLOR_BLACK);
    }
    text_draw_number(building_properties[selected_building->type].n_laborers, 0, 0, map_center_x - panel_width * 8 + 38 + width, y + 18, FONT_NORMAL_WHITE);
    draw_image_button(1150, map_center_x + panel_width * 8 - 36, y + 9, 28, 28, 1); // x is width+8 away from inner panel end
}

static void draw_common_house_context(void)
{
    outer_panel_draw(map_center_x - 176, map_center_y - 160, 22, 20);
    int lowest_desirability = 0;
    int lowest_building_id = 0;
    int x_min, y_min, x_max, y_max;
    map_grid_get_area(selected_building->x, selected_building->y, 1, 6, &x_min, &y_min, &x_max, &y_max);
    for (int y = y_min; y <= y_max; y++) {
        for (int x = x_min; x <= x_max; x++) {
            int building_id = map_building_at(map_grid_offset(x, y));
            if (building_id <= 0) {
                continue;
            }
            struct building_t *bb = &all_buildings[building_id];
            if (bb->state != BUILDING_STATE_IN_USE || building_id == selected_building->id) {
                continue;
            }
            if (!bb->house_size || bb->type < selected_building->type) {
                int des = building_properties[bb->type].desirability_value;
                if (des < 0) {
                    // simplified desirability calculation
                    int step_size = building_properties[bb->type].desirability_step_size;
                    int range = building_properties[bb->type].desirability_range;
                    int dist = calc_maximum_distance(x, y, selected_building->x, selected_building->y);
                    if (dist <= range) {
                        while (--dist > 1) {
                            des += step_size;
                        }
                        if (des < lowest_desirability) {
                            lowest_desirability = des;
                            lowest_building_id = building_id;
                        }
                    }
                }
            }
        }
    }
    int foodtypes_available = 0;
    for (int i = INVENTORY_WHEAT; i <= INVENTORY_MEAT; i++) {
        if (selected_building->data.house.inventory[i]) {
            foodtypes_available++;
        }
    }
    // this house will devolve soon because...
    if (selected_building->desirability <= house_properties[selected_building->subtype.house_level].devolve_desirability) {
        text_draw_multiline("This house will devolve soon. The falling desirability of living in this locality is dragging it down", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else if (house_properties[selected_building->subtype.house_level].water == 1 && !selected_building->has_water_access && !selected_building->has_well_access) {
        text_draw_multiline("This house will devolve soon, as it lacks access to even the most primitive of water supplies", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else if (house_properties[selected_building->subtype.house_level].water == 2 && !selected_building->has_water_access) {
        text_draw_multiline("This house will devolve soon, as it does not have access to clean water from a fountain", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else if (selected_building->data.house.entertainment < house_properties[selected_building->subtype.house_level].entertainment) {
        if (!selected_building->data.house.entertainment) {
            text_draw_multiline("This house will devolve soon, as there is no entertainment to be found in the location", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else if (house_properties[selected_building->subtype.house_level].entertainment < 10) {
            text_draw_multiline("This house will devolve soon, as there is hardly any entertainment in the location", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else if (house_properties[selected_building->subtype.house_level].entertainment < 25) {
            text_draw_multiline("This house will devolve soon, as there is too little entertainment in the location", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else if (house_properties[selected_building->subtype.house_level].entertainment < 50) {
            text_draw_multiline("This house will devolve soon. There is some entertainment to be found in the location, but not enough", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else if (house_properties[selected_building->subtype.house_level].entertainment < 80) {
            text_draw_multiline("This house will devolve soon. There is good entertainment to be found in the location, but not enough variety", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else {
            text_draw_multiline("This house will devolve soon. There is excellent entertainment to be found in the location, but venues are too crowded, or lack enough variety for the discerning patrician classes", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        }
    } else if (foodtypes_available < house_properties[selected_building->subtype.house_level].food_types) {
        if (house_properties[selected_building->subtype.house_level].food_types == 1) {
            text_draw_multiline("This house will devolve soon, as it has not received any supplies of food recently from a local market", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else if (house_properties[selected_building->subtype.house_level].food_types == 2) {
            text_draw_multiline("This house will devolve soon, as it currently only has access to a single type of food from its local market. This discourages the wealthier plebes.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else if (house_properties[selected_building->subtype.house_level].food_types == 3) {
            text_draw_multiline("This house will devolve soon, as it currently only has access to 2 types of food from its local market. This is discouraging the patrician classes.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        }
    } else if (selected_building->data.house.education < house_properties[selected_building->subtype.house_level].education) {
        if (house_properties[selected_building->subtype.house_level].education == 1) {
            text_draw_multiline("This house will devolve soon, as it has lost all basic educational facilities provided by either a school or a library.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else if (house_properties[selected_building->subtype.house_level].education == 2) {
            if (selected_building->data.house.school) {
                text_draw_multiline("This house will devolve soon. Its access to education has been downgraded, as it has lost access to its library.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
            } else if (selected_building->data.house.library) {
                text_draw_multiline("This house will devolve soon. Its access to education has been downgraded, as it has lost access to its school.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
            }
        } else if (house_properties[selected_building->subtype.house_level].education == 3) {
            text_draw_multiline("This house will devolve soon. Its previously excellent access to education was downgraded when it lost access to its academy.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        }
    } else if (selected_building->data.house.bathhouse < house_properties[selected_building->subtype.house_level].bathhouse) {
        text_draw_multiline("This house will devolve soon, as it has lost bath-house access.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else if (selected_building->data.house.inventory[INVENTORY_POTTERY] < house_properties[selected_building->subtype.house_level].pottery) {
        text_draw_multiline("This house will devolve soon. It has run out of pottery, and its local market has at best an erratic supply.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else if (selected_building->data.house.num_gods < house_properties[selected_building->subtype.house_level].religion) {
        if (house_properties[selected_building->subtype.house_level].religion == 1) {
            text_draw_multiline("This house will devolve soon, as it has lost all access to local religious facilities.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else if (house_properties[selected_building->subtype.house_level].religion == 2) {
            text_draw_multiline("This house will devolve soon. Its access to local religious facilities was reduced to the temples of only one god.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else if (house_properties[selected_building->subtype.house_level].religion == 3) {
            text_draw_multiline("This house will devolve soon. Its previously excellent religious facilities were reduced to the temples of only two gods.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        }
    } else if (selected_building->data.house.barber < house_properties[selected_building->subtype.house_level].barber) {
        text_draw_multiline("This house will devolve soon, as it has lost barber access.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else if (selected_building->data.house.health < house_properties[selected_building->subtype.house_level].health) {
        if (house_properties[selected_building->subtype.house_level].health == 1) {
            text_draw_multiline("This house will devolve soon, as it now has woeful health provision. Not only does it lack access to a clinic, but hospital access is also less than perfect.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else if (selected_building->data.house.clinic) {
            text_draw_multiline("This house will devolve soon, as its health provision has been cut. Doctor clinic coverage is good, but there is no local access to a hospital.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else {
            text_draw_multiline("This house will devolve soon, as its health provision has been cut. There is local access to a hospital, but doctors' clinics are hard to find.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        }
    } else if (selected_building->data.house.inventory[INVENTORY_OIL] < house_properties[selected_building->subtype.house_level].oil) {
        text_draw_multiline("This house will devolve soon, as it has run out of oil and its local market has at best an erratic supply.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else if (selected_building->data.house.inventory[INVENTORY_FURNITURE] < house_properties[selected_building->subtype.house_level].furniture) {
        text_draw_multiline("This house will devolve soon, as it has run out of furniture and its local market has at best an erratic supply.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else if (selected_building->data.house.inventory[INVENTORY_WINE] < house_properties[selected_building->subtype.house_level].wine) {
        text_draw_multiline("This house will devolve soon, as it has run out of wine and its local market has at best an erratic supply.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else if (house_properties[selected_building->subtype.house_level].wine > 1 && city_data.resource.wine_types_available <= 1) {
        text_draw_multiline("This house will devolve soon, as the city has only 1 source of wine and its discerning residents are grumbling about lack of choice.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else if (selected_building->subtype.house_level >= HOUSE_LUXURY_PALACE) { // max level!
        text_draw_multiline("The dwellers of this palace are at the pinnacle of Roman society. They want for nothing. Just keeping their needs satisfied is a remarkable achievement!", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else if (selected_building->desirability < house_properties[selected_building->subtype.house_level].evolve_desirability) { // this house will evolve if ...
        if (lowest_building_id) {
            int width = text_draw("A nearby building (", map_center_x - 152, map_center_y - 102, FONT_NORMAL_BLACK, COLOR_BLACK);
            width += text_draw(all_buildings_strings[all_buildings[lowest_building_id].type], map_center_x - 152 + width, map_center_y - 102, FONT_NORMAL_PLAIN, COLOR_FONT_RED);
            text_draw(")", map_center_x - 152 + width, map_center_y - 102, FONT_NORMAL_BLACK, COLOR_BLACK);
            text_draw_multiline("is having a detrimental effect on the desirability of the location. Try placing gardens, statues or plazas, for example.", map_center_x - 152, map_center_y - 86, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else {
            text_draw_multiline("You need to improve the desirability of the local area - perhaps by placing some gardens or plaza, for example.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        }
    } // water
    else if (house_properties[selected_building->subtype.house_level + 1].water == 1 && !selected_building->has_water_access && !selected_building->has_well_access) {
        text_draw_multiline("This house cannot evolve, as it does not have access to even the most primitive of water supplies", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else if (house_properties[selected_building->subtype.house_level + 1].water == 2 && !selected_building->has_water_access) {
        text_draw_multiline("This house cannot evolve, as it does not have access to a clean water supply from a fountain", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else if (selected_building->data.house.entertainment < house_properties[selected_building->subtype.house_level + 1].entertainment) {
        if (!selected_building->data.house.entertainment) {
            text_draw_multiline("This house cannot evolve, as there is no entertainment to be found in the location.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else if (house_properties[selected_building->subtype.house_level + 1].entertainment < 10) {
            text_draw_multiline("This house cannot evolve, as there is hardly any entertainment to be found in the location.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else if (house_properties[selected_building->subtype.house_level + 1].entertainment < 25) {
            text_draw_multiline("This house cannot evolve, as there is too little entertainment to be found in the location.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else if (house_properties[selected_building->subtype.house_level + 1].entertainment < 50) {
            text_draw_multiline("This house cannot evolve, as there is some entertainment to be found in the location, but not enough.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else if (house_properties[selected_building->subtype.house_level + 1].entertainment < 80) {
            text_draw_multiline("This house cannot evolve, as there is good entertainment to be found in the location, but not enough variety.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else {
            text_draw_multiline("This house cannot evolve, as there is excellent entertainment to be found in the location, but the venues are too crowded or lack enough variety for the discerning patrician classes.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        }
    } else if (foodtypes_available < house_properties[selected_building->subtype.house_level + 1].food_types) {
        if (house_properties[selected_building->subtype.house_level + 1].food_types == 1) {
            text_draw_multiline("This house cannot evolve, as it needs a supply of food from a local market.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else if (house_properties[selected_building->subtype.house_level + 1].food_types == 2) {
            text_draw_multiline("This house cannot evolve, as it needs a second type of food, supplied from a local market, to encourage wealthier plebes to move in.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else if (house_properties[selected_building->subtype.house_level + 1].food_types == 3) {
            text_draw_multiline("This house cannot evolve, as it needs a third type of food, supplied from a local market, to encourage the patrician classes to move in.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        }
    } else if (selected_building->data.house.education < house_properties[selected_building->subtype.house_level + 1].education) {
        if (house_properties[selected_building->subtype.house_level + 1].education == 1) {
            text_draw_multiline("This house cannot evolve, as it has no basic educational facilities provided by either a school or a library.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else if (house_properties[selected_building->subtype.house_level + 1].education == 2) {
            if (selected_building->data.house.school) {
                text_draw_multiline("This house cannot evolve, as its access to education needs to be improved by access to a library.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
            } else if (selected_building->data.house.library) {
                text_draw_multiline("This house cannot evolve, as its access to education needs to be improved by access to a school.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
            }
        } else if (house_properties[selected_building->subtype.house_level + 1].education == 3) {
            text_draw_multiline("This house cannot evolve, as its already excellent access to education needs to be improved by access to an academy.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        }
    } else if (selected_building->data.house.bathhouse < house_properties[selected_building->subtype.house_level + 1].bathhouse) {
        text_draw_multiline("This house cannot evolve, as it does not have access to a local bath-house.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else if (selected_building->data.house.inventory[INVENTORY_POTTERY] < house_properties[selected_building->subtype.house_level + 1].pottery) {
        text_draw_multiline("This house cannot evolve. It needs supplies of pottery provided to it by its local market before a wealthier class of citizen will move in.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else if (selected_building->data.house.num_gods < house_properties[selected_building->subtype.house_level + 1].religion) {
        if (house_properties[selected_building->subtype.house_level + 1].religion == 1) {
            text_draw_multiline("This house cannot evolve, as it has no access to any local religious facilities.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else if (house_properties[selected_building->subtype.house_level + 1].religion == 2) {
            text_draw_multiline("This house cannot evolve, as it has access to the temples of a single god only. As its inhabitants move up the world, they wish to spend more time worshipping other gods.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else if (house_properties[selected_building->subtype.house_level + 1].religion == 3) {
            text_draw_multiline("This house cannot evolve, as it has access to the temples of only two religions. As its inhabitants move up the world, they wish to spend more time worshipping other gods.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        }
    } else if (selected_building->data.house.barber < house_properties[selected_building->subtype.house_level + 1].barber) {
        text_draw_multiline("This house cannot evolve, as it has no local access to a barber.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else if (selected_building->data.house.health < house_properties[selected_building->subtype.house_level + 1].health) {
        if (house_properties[selected_building->subtype.house_level + 1].health == 1) {
            text_draw_multiline("This house cannot evolve, as it effectively has no health provision. It does not have access to a clinic, or a hospital.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else if (selected_building->data.house.clinic) {
            text_draw_multiline("This house cannot evolve, as it wants greater health provision. Doctor's clinic  coverage is good, but there is no local access to a hospital.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        } else {
            text_draw_multiline("This house cannot evolve, as it wants greater health provision. There is local access to a hospital, but a doctor's clinic needs to be built nearby.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        }
    } else if (selected_building->data.house.inventory[INVENTORY_OIL] < house_properties[selected_building->subtype.house_level + 1].oil) {
        text_draw_multiline("This house cannot evolve. It needs supplies of oil provided to it by its local market before a wealthier class of citizen will move in.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else if (selected_building->data.house.inventory[INVENTORY_FURNITURE] < house_properties[selected_building->subtype.house_level + 1].furniture) {
        text_draw_multiline("This house cannot evolve. It needs supplies of furniture provided to it by its local market before a wealthier class of citizen will move in.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else if (selected_building->data.house.inventory[INVENTORY_WINE] < house_properties[selected_building->subtype.house_level + 1].wine) {
        text_draw_multiline("This house cannot evolve. It needs supplies of wine provided to it by its local market before a wealthier class of citizen will move in.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else if (house_properties[selected_building->subtype.house_level + 1].wine > 1 && city_data.resource.wine_types_available <= 1) {
        text_draw_multiline("This house cannot evolve. It needs a second type of wine to satisfy the idle patricians' decadent lifestyle. Open a new trade route, or make your own wine.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
    } else {
        // house is evolving
        text_draw_multiline("This dwelling will soon evolve to one of greater stature, as a result of the improving local conditions.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        if (selected_building->data.house.no_space_to_expand == 1) {
            // house would like to evolve but can't
            text_draw_multiline("This dwelling would soon evolve to one of greater stature if it had more space to expand into.", map_center_x - 152, map_center_y - 102, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
        }
    }
    inner_panel_draw(map_center_x - 160, map_center_y - 16, 20, 10);
    image_draw(1411, map_center_x - 150, map_center_y - 8);
    int width = text_draw_number(selected_building->house_population, 0, " occupants", map_center_x - 123, map_center_y, FONT_NORMAL_BROWN);
    if (selected_building->house_population_room) {
        width += text_draw(", extra room for", map_center_x - 127 + width, map_center_y, FONT_NORMAL_BROWN, COLOR_BLACK);
        text_draw_number(selected_building->house_population_room, 0, 0, map_center_x - 127 + width, map_center_y, FONT_NORMAL_BROWN);
    }
    if (selected_building->house_tax_coverage) {
        text_draw("Paid", map_center_x - 150, map_center_y + 32, FONT_NORMAL_BROWN, COLOR_BLACK);
        text_draw_number(calc_adjust_with_percentage(selected_building->tax_income_or_storage / 2, city_data.finance.tax_percentage), 0, " Dn tax so far", map_center_x - 110, map_center_y + 32, FONT_NORMAL_BROWN);
    } else {
        text_draw("Tax exempt", map_center_x - 150, map_center_y + 32, FONT_NORMAL_BROWN, COLOR_BLACK);
    }
    if (selected_building->sentiment.house_happiness >= 50) {
        text_draw("Residents have reported no crime at all.", map_center_x - 150, map_center_y + 54, FONT_NORMAL_BROWN, COLOR_BLACK);
    } else if (selected_building->sentiment.house_happiness >= 40) {
        text_draw("This is a peaceful neighborhood.", map_center_x - 150, map_center_y + 54, FONT_NORMAL_BROWN, COLOR_BLACK);
    } else if (selected_building->sentiment.house_happiness >= 30) {
        text_draw("There is some crime here, nothing serious.", map_center_x - 150, map_center_y + 54, FONT_NORMAL_BROWN, COLOR_BLACK);
    } else if (selected_building->sentiment.house_happiness >= 20) {
        text_draw("Crime is becoming a problem.", map_center_x - 150, map_center_y + 54, FONT_NORMAL_BROWN, COLOR_BLACK);
    } else if (selected_building->sentiment.house_happiness >= 10) {
        text_draw("High crime levels are scaring the locals.", map_center_x - 150, map_center_y + 54, FONT_NORMAL_BROWN, COLOR_BLACK);
    } else if (selected_building->sentiment.house_happiness >= 1) {
        text_draw("A lawless area. People are terrified.", map_center_x - 150, map_center_y + 54, FONT_NORMAL_BROWN, COLOR_BLACK);
    } else {
        text_draw("The threat of riots is imminent here.", map_center_x - 150, map_center_y + 54, FONT_NORMAL_BROWN, COLOR_BLACK);
    }
    for (int i = 1; i < 5; i++) {
        image_draw(resource_images[i].icon_img_id, map_center_x - 144 + 80 * (i - 1), map_center_y + 80);
        text_draw_number(selected_building->data.house.inventory[i], 0, 0, map_center_x - 114 + 80 * (i - 1), map_center_y + 84, FONT_NORMAL_BROWN);
    }
    for (int i = 1; i < 5; i++) {
        image_draw(resource_images[i + 10].icon_img_id, map_center_x - 144 + 80 * (i - 1), map_center_y + 112);
        text_draw_number(selected_building->data.house.inventory[i + 10], 0, 0, map_center_x - 114 + 80 * (i - 1), map_center_y + 116, FONT_NORMAL_BROWN);
    }
}

static void select_legion_formation(struct formation_t *legion_formation)
{
    selected_legion_formation = legion_formation;
    last_selected_legion_index = selected_legion_formation->id;
    set_cursor_shape(CURSOR_SWORD);
}

int main(__attribute__((unused)) int argc, __attribute__((unused)) char **argv) // actually SDL_main
{
    signal(SIGSEGV, handler);
    log_file = fopen("brutus_log.txt", "wt");
    SDL_LogSetOutputFunction(write_log, 0);
    if (SDL_Init(SDL_INIT_AUDIO | SDL_INIT_VIDEO) != 0) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Could not initialize SDL: %s", SDL_GetError());
        exit(-1);
    }
    SDL_Log("SDL initialized");
    reusable_char_ptr = SDL_GetBasePath(); // get path to brutus executable
    if (reusable_char_ptr) {
        if (string_length(reusable_char_ptr) < DIR_PATH_MAX - string_length("brutus_hotkey_configs.txt")) {
            string_copy(reusable_char_ptr, reusable_char_array, DIR_PATH_MAX - 1);
            strcat(reusable_char_array, "data_dir.txt");
            string_copy(reusable_char_ptr, SETTINGS_FILE_PATH, DIR_PATH_MAX - 1);
            strcat(SETTINGS_FILE_PATH, "brutus_settings.txt");
            string_copy(reusable_char_ptr, CONFIGS_FILE_PATH, DIR_PATH_MAX - 1);
            strcat(CONFIGS_FILE_PATH, "brutus_configs.txt");
            string_copy(reusable_char_ptr, HOTKEY_CONFIGS_FILE_PATH, DIR_PATH_MAX - 1);
            strcat(HOTKEY_CONFIGS_FILE_PATH, "brutus_hotkey_configs.txt");
            string_copy(reusable_char_ptr, MAPS_DIR_PATH, DIR_PATH_MAX - 1);
            strcat(MAPS_DIR_PATH, "maps");
            string_copy(reusable_char_ptr, SAVES_DIR_PATH, DIR_PATH_MAX - 1);
            strcat(SAVES_DIR_PATH, "saves");
        } else {
            SDL_Log("Brutus directory path too long, exiting");
            exit(1);
        }
    } else {
        SDL_Log("Brutus directory not found, exiting");
        exit(1);
    }
    // set/check path to game files
    fp = fopen(reusable_char_array, "r");
    if (fp) {
        for (int i = 0; i < DIR_PATH_MAX; i++) {
            reusable_char_array[i] = 0;
        }
        if (!fread(reusable_char_array, 1, 1000, fp)) {
            SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_INFORMATION,
                "Game path not specified",
                "Brutus requires Caesar 3 to run. Provide the path to the game in data_dir.txt.",
                0);
            exit(1);
        }
        fclose(fp);
    } else {
        fp = fopen(reusable_char_array, "w");
        fclose(fp);
        SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_INFORMATION,
            "Game path not specified",
            "Brutus requires Caesar 3 to run. Provide the path to the game in data_dir.txt.",
            0);
        exit(1);
    }
    if (chdir(reusable_char_array) != 0) {
        SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR,
            "Ya dun goofed",
            "Incorrect game path specified in data_dir.txt",
            0);
        exit(1);
    }
    _mkdir(MAPS_DIR_PATH);
    _mkdir(SAVES_DIR_PATH);
    // load settings from file (defaults already loaded on program start)
    fp = fopen(SETTINGS_FILE_PATH, "rt");
    if (fp) {
        for (int i = 0; i < SETTINGS_MAX_ENTRIES; i++) {
            fgets(reusable_char_array, FILE_LINE_LENGTH_MAX, fp);
            char *separator = clean_key_value(reusable_char_array);
            if (string_equals(settings[i].config_string, reusable_char_array)) {
                settings[i].config_value = atoi(&separator[1]);
            }
        }
        fclose(fp);
    }
    // load configs from file if available
    fp = fopen(CONFIGS_FILE_PATH, "rt");
    if (fp) {
        fgets(reusable_char_array, FILE_LINE_LENGTH_MAX, fp);
        char *separator = clean_key_value(reusable_char_array);
        if (string_equals("Player name", reusable_char_array)) {
            string_copy(&separator[1], configs_player_name, MAX_PLAYER_NAME_LENGTH);
        }
        for (int i = 0; i < CONFIGS_MAX_ENTRIES; i++) {
            fgets(reusable_char_array, FILE_LINE_LENGTH_MAX, fp);
            char *separator = clean_key_value(reusable_char_array);
            if (string_equals(configs[i].config_string, reusable_char_array)) {
                configs[i].config_value = atoi(&separator[1]);
            }
        }
        fclose(fp);
        string_copy(configs_player_name, scenario_settings.player_name, MAX_PLAYER_NAME_LENGTH);
    } else {
        set_default_configs();
    }
    // load hotkey configs from file if available
    fp = fopen(HOTKEY_CONFIGS_FILE_PATH, "rt");
    if (fp) {
        for (int i = 0; i < HOTKEY_CONFIGS_NUMBER_ROWS; i++) {
            fgets(reusable_char_array, FILE_LINE_LENGTH_MAX, fp);
            if (!hotkey_mappings[i].is_header) {
                char *separator = clean_key_value(reusable_char_array);
                if (string_equals(hotkey_mappings[i].action_name, reusable_char_array)) {
                    char editable_name[FILE_LINE_LENGTH_MAX] = { 0 };
                    string_copy(&separator[1], editable_name, FILE_LINE_LENGTH_MAX);
                    char *token = strtok(editable_name, "_");
                    int modifiers = KMOD_NONE;
                    while (token) {
                        for (int i = 0; i < 4; i++) {
                            if (string_equals(token, modifier_names[i].name)) {
                                modifiers |= modifier_names[i].modifier;
                            }
                        }
                        int key = SDL_GetKeyFromName(token);
                        if (key) {
                            set_mapping(i, modifiers, key);
                            break;
                        }
                        token = strtok(0, "_");
                    }
                }
            }
        }
        fclose(fp);
    } else {
        set_default_hotkeys();
    }
    // create screen
    if (settings[SETTINGS_FULLSCREEN].config_value) {
        SDL_DisplayMode mode;
        SDL_GetDesktopDisplayMode(0, &mode);
        current_resolution_width = mode.w;
        current_resolution_height = mode.h;
    } else {
        current_resolution_width = settings[SETTINGS_WINDOW_WIDTH].config_value;
        current_resolution_height = settings[SETTINGS_WINDOW_HEIGHT].config_value;
    }
    if (settings[SETTINGS_FULLSCREEN].config_value) {
        SDL.window = SDL_CreateWindow(
            "Caesar III",
            SDL_WINDOWPOS_CENTERED,
            SDL_WINDOWPOS_CENTERED,
            current_resolution_width,
            current_resolution_height,
            SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI | SDL_WINDOW_FULLSCREEN_DESKTOP);
    } else {
        SDL.window = SDL_CreateWindow(
            "Caesar III",
            SDL_WINDOWPOS_CENTERED,
            SDL_WINDOWPOS_CENTERED,
            current_resolution_width,
            current_resolution_height,
            SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI);
    }
    if (!SDL.window) {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unable to create window: %s", SDL_GetError());
        exit(-2);
    }
    SDL_SetWindowMinimumSize(SDL.window, MINIMUM_RESOLUTION_X, MINIMUM_RESOLUTION_Y);
    SDL.renderer = SDL_CreateRenderer(SDL.window, -1, SDL_RENDERER_PRESENTVSYNC);
    if (!SDL.renderer) {
        SDL_Log("Unable to create renderer, trying software renderer: %s", SDL_GetError());
        SDL.renderer = SDL_CreateRenderer(SDL.window, -1, SDL_RENDERER_SOFTWARE);
        if (!SDL.renderer) {
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Unable to create renderer: %s", SDL_GetError());
            exit(-2);
        }
    }
    resize_screen(current_resolution_width, current_resolution_height);
    // init random
    random_data.iv1 = 0x54657687;
    random_data.iv2 = 0x72641663;
    srand(time(0));
    // load text
    if (!load_files(FILE_TEXT_ENG, FILE_MM_ENG)) {
        SDL_Log("'c3.eng' or 'c3_mm.eng' files not found or too large.");
        exit(1);
    }
    // init cursors
    for (int i = 0; i < CURSOR_MAX; i++) {
        struct cursor_t *c;
        switch (i) {
            case CURSOR_ARROW:
                c = &ARROW[0];
                break;
            case CURSOR_SHOVEL:
                c = &SHOVEL[0];
                break;
            case CURSOR_SWORD:
                c = &SWORD[0];
                break;
            default:
                c = 0;
                break;
        }
        if (cursor_data.surfaces[i]) {
            SDL_FreeSurface(cursor_data.surfaces[i]);
        }
        if (cursor_data.cursors[i]) {
            SDL_FreeCursor(cursor_data.cursors[i]);
        }
        int size = 32;
        while (size <= c->width || size <= c->height) {
            size *= 2;
        }
        SDL_Surface *cursor_surface = SDL_CreateRGBSurface(0, size, size, 32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000);
        uint32_t *pixels = cursor_surface->pixels;
        SDL_memset(pixels, 0, sizeof(uint32_t) * size * size);
        for (int y = 0; y < c->height; y++) {
            for (int x = 0; x < c->width; x++) {
                pixels[y * size + x] = mouse_colors[c->data[y * c->width + x] - 32];
            }
        }
        cursor_data.surfaces[i] = cursor_surface;
        cursor_data.cursors[i] = SDL_CreateColorCursor(cursor_data.surfaces[i], c->hotspot_x, c->hotspot_y);
    }
    // load image data
    image_data_s.tmp_data = (uint8_t *) malloc(12100000);
    if (!image_data_s.tmp_data) {
        exit(2);
    }
    // load main image data
    if (!load_main_graphics(CLIMATE_NORTHERN, 0)) {
        SDL_Log("unable to load main graphics");
        exit(2);
    }
    // load empire image data
    image_data_s.empire_data = (uint32_t *) malloc(EMPIRE_IMAGE_DATA_SIZE);
    if (!image_data_s.empire_data) {
        exit(2);
    }
    int size = read_file_into_buffer("The_empire.555", image_data_s.tmp_data, 1);
    if (size != EMPIRE_IMAGE_DATA_SIZE / 2) {
        SDL_Log("unable to load empire data");
        return 0;
    }
    struct buffer_t buf;
    buffer_init(&buf, image_data_s.tmp_data, size);
    convert_uncompressed(&buf, size, image_data_s.empire_data);
    // load enemies image data
    for (int i = 0; i < ENEMY_FILES_COUNT; i++) {
        image_data_s.enemy_data[i] = (uint32_t *) malloc(2400000);
        if (!image_data_s.enemy_data[i]) {
            exit(2);
        }
    }
    for (int i = 0; i < ENEMY_FILES_COUNT; i++) {
        if (ENEMY_INDEX_SIZE != io_read_file_part_into_buffer(
            ENEMY_GRAPHICS_SG2[i], image_data_s.tmp_data, ENEMY_INDEX_SIZE, HEADER_SIZE_ENEMY_FILES)) {
            SDL_Log("unable to load enemy graphics");
            exit(2);
        }
        buffer_init(&buf, image_data_s.tmp_data, ENEMY_INDEX_SIZE);
        read_index(&buf, image_data_s.enemy[i], ENEMY_ENTRIES);
        int data_size = read_file_into_buffer(ENEMY_GRAPHICS_555[i], image_data_s.tmp_data, 1);
        if (!data_size) {
            SDL_Log("unable to load enemy graphics");
            exit(2);
        }
        buffer_init(&buf, image_data_s.tmp_data, data_size);
        convert_images(image_data_s.enemy[i], ENEMY_ENTRIES, &buf, image_data_s.enemy_data[i]);
    }
    // initialize sound
    if (Mix_OpenAudio(AUDIO_RATE, AUDIO_S16, 2, 1024) == 0) {
        Mix_AllocateChannels(SOUND_CHANNEL_MAX);
    } else {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Sound failed to initialize using default driver: %s", Mix_GetError());
        exit(2);
    }
    if (configs[CONFIG_UI_SHOW_INTRO_VIDEOS].config_value) {
        change_window(WINDOW_INTRO_VIDEOS);
    } else {
        change_window(WINDOW_LOGO);
    }
    while (1) { // main loop
        current_time = SDL_GetTicks64();
        SDL_Event event;
        while (SDL_PollEvent(&event)) { // handle input
            if (event.window.event == SDL_WINDOWEVENT_SIZE_CHANGED) {
                resize_screen(event.window.data1, event.window.data2);
                if (!settings[SETTINGS_FULLSCREEN].config_value) {
                    settings[SETTINGS_WINDOW_WIDTH].config_value = event.window.data1;
                    settings[SETTINGS_WINDOW_HEIGHT].config_value = event.window.data2;
                }
            } else if (event.window.event == SDL_WINDOWEVENT_CLOSE) {
                quit_game();
            }
            int mouse_left_down = event.type == SDL_MOUSEBUTTONDOWN && event.button.button == SDL_BUTTON_LEFT;
            int mouse_left_up = event.type == SDL_MOUSEBUTTONUP && event.button.button == SDL_BUTTON_LEFT;
            int mouse_right_up = event.type == SDL_MOUSEBUTTONUP && event.button.button == SDL_BUTTON_RIGHT;
            int mouse_middle_down = event.type == SDL_MOUSEBUTTONDOWN && event.button.button == SDL_BUTTON_MIDDLE;
            int mouse_middle_up = event.type == SDL_MOUSEBUTTONUP && event.button.button == SDL_BUTTON_MIDDLE;
            int escape_key_down = event.type == SDL_KEYDOWN && event.key.keysym.sym == SDLK_ESCAPE;
            if (event.type == SDL_MOUSEMOTION) {
                if (mouse_drag_scroll_active) {
                    mouse_scroll_x = event.motion.x;
                    mouse_scroll_y = event.motion.y;
                } else {
                    mouse_x = event.motion.x;
                    mouse_y = event.motion.y;
                }
            }
            int key_mod = KMOD_NONE;
            // clear unused mods such as numpad, capslock, etc.; combine ctrls, shifts, alts
            if (event.key.keysym.mod & KMOD_SHIFT) {
                key_mod |= KMOD_SHIFT;
            }
            if (event.key.keysym.mod & KMOD_CTRL) {
                key_mod |= KMOD_CTRL;
            }
            if (event.key.keysym.mod & KMOD_ALT) {
                key_mod |= KMOD_ALT;
            }
            if (event.key.keysym.mod & KMOD_GUI) {
                key_mod |= KMOD_GUI;
            }
            int enter_pressed = !key_mod && event.type == SDL_KEYDOWN && (event.key.keysym.sym == SDLK_RETURN || event.key.keysym.sym == SDLK_KP_ENTER);
            if (event.type == SDL_KEYDOWN && text_field_active && !key_mod) {
                switch (event.key.keysym.sym) {
                    case SDLK_RETURN:
                    case SDLK_KP_ENTER:
                        if (input_text_current_length + 1 < input_text_max_length && text_num_completed_lines < input_text_max_lines - 1) {
                            for (int i = input_text_current_length; i > input_text_cursor_position; i--) {
                                input_text_string[i] = input_text_string[i - 1];
                            }
                            input_text_string[input_text_cursor_position] = '\n';
                            input_text_cursor_position++;
                            input_text_current_length++;
                            parse_text(input_text_string, input_text_x, input_text_y, input_text_current_length, input_text_field_line_max_width, input_text_font);
                            move_input_text_cursor_next_line();
                        }
                        break;
                    case SDLK_BACKSPACE:
                        if (input_text_cursor_position) {
                            for (int i = input_text_cursor_position - 1; i < input_text_current_length; i++) {
                                input_text_string[i] = input_text_string[i + 1];
                            }
                            input_text_current_length--;
                            parse_text(input_text_string, input_text_x, input_text_y, input_text_current_length, input_text_field_line_max_width, input_text_font);
                            input_text_cursor_position--;
                            if (input_text_current_line_cursor_position) {
                                input_text_current_line_cursor_position--;
                                if (input_text_current_line_cursor_position) {
                                    input_text_cursor_current_x_offset = text_lines[input_text_cursor_current_line].chars[input_text_current_line_cursor_position - 1].x_end - input_text_x;
                                } else {
                                    input_text_cursor_current_x_offset = 0;
                                }
                            } else { // empty line
                                input_text_cursor_current_line--;
                                input_text_current_line_cursor_position = text_lines[input_text_cursor_current_line].num_chars;
                                input_text_cursor_current_x_offset = text_lines[input_text_cursor_current_line].chars[text_lines[input_text_cursor_current_line].num_chars - 1].x_end - input_text_x;
                            }
                        }
                        break;
                    case SDLK_DELETE:
                        if (input_text_cursor_position < input_text_current_length) {
                            for (int i = input_text_cursor_position; i < input_text_current_length; i++) {
                                input_text_string[i] = input_text_string[i + 1];
                            }
                            input_text_current_length--;
                            parse_text(input_text_string, input_text_x, input_text_y, input_text_current_length, input_text_field_line_max_width, input_text_font);
                        }
                        break;
                    case SDLK_LEFT:
                        if (input_text_cursor_position) {
                            if (input_text_current_line_cursor_position) { // move cursor left within same line
                                input_text_cursor_position--;
                                input_text_current_line_cursor_position--;
                                input_text_cursor_current_x_offset = text_lines[input_text_cursor_current_line].chars[input_text_current_line_cursor_position].x_start - input_text_x;
                            } else { // move cursor to end of previous line
                                input_text_cursor_current_line--;
                                input_text_current_line_cursor_position = text_lines[input_text_cursor_current_line].num_chars;
                                input_text_cursor_current_x_offset = text_lines[input_text_cursor_current_line].chars[input_text_current_line_cursor_position - 1].x_end - input_text_x;
                            }
                        }
                        break;
                    case SDLK_RIGHT:
                        if (input_text_cursor_position < input_text_current_length) {
                            if (input_text_string[input_text_cursor_position] == '\n'
                            || (input_text_cursor_current_line < text_num_completed_lines
                                && text_lines[input_text_cursor_current_line].num_chars == input_text_current_line_cursor_position)) { // if char is last in line
                                move_input_text_cursor_next_line();
                            } else { // move cursor right within same line
                                input_text_cursor_current_x_offset = text_lines[input_text_cursor_current_line].chars[input_text_current_line_cursor_position].x_end - input_text_x;
                                input_text_cursor_position++;
                                input_text_current_line_cursor_position++;
                            }
                        }
                        break;
                    case SDLK_UP:
                        if (input_text_cursor_current_line) {
                            input_text_cursor_current_line--;
                            if (input_text_cursor_current_x_offset > text_lines[input_text_cursor_current_line].line_width) { // moved cursor after last char on line (also when '\n' is the only char on line)
                                input_text_cursor_position = text_lines[input_text_cursor_current_line].chars[text_lines[input_text_cursor_current_line].num_chars - 1].position_in_text + 1;
                                input_text_current_line_cursor_position = text_lines[input_text_cursor_current_line].num_chars;
                                input_text_cursor_current_x_offset = text_lines[input_text_cursor_current_line].chars[text_lines[input_text_cursor_current_line].num_chars - 1].x_end - input_text_x;
                            } else {
                                for (int i = 0; i < text_lines[input_text_cursor_current_line].num_chars; i++) {
                                    if (text_lines[input_text_cursor_current_line].chars[i].x_end >= input_text_x + input_text_cursor_current_x_offset) {
                                        if (abs(text_lines[input_text_cursor_current_line].chars[i].x_start - (input_text_x + input_text_cursor_current_x_offset))
                                        < text_lines[input_text_cursor_current_line].chars[i].x_end - (input_text_x + input_text_cursor_current_x_offset)) {
                                            input_text_cursor_position = text_lines[input_text_cursor_current_line].chars[i].position_in_text;
                                            input_text_current_line_cursor_position = i;
                                            input_text_cursor_current_x_offset = text_lines[input_text_cursor_current_line].chars[i].x_start - input_text_x;
                                        } else {
                                            input_text_cursor_position = text_lines[input_text_cursor_current_line].chars[i].position_in_text + 1;
                                            input_text_current_line_cursor_position = i + 1;
                                            input_text_cursor_current_x_offset = text_lines[input_text_cursor_current_line].chars[i].x_end - input_text_x;
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                        break;
                    case SDLK_DOWN:
                        if (input_text_cursor_current_line < text_num_completed_lines) {
                            input_text_cursor_current_line++;
                            if (text_lines[input_text_cursor_current_line].num_chars) {
                                if (input_text_cursor_current_x_offset > text_lines[input_text_cursor_current_line].line_width) { // moved cursor after last char on line (also when '\n' is the only char on line)
                                    input_text_cursor_position = text_lines[input_text_cursor_current_line].chars[text_lines[input_text_cursor_current_line].num_chars - 1].position_in_text + 1;
                                    input_text_current_line_cursor_position = text_lines[input_text_cursor_current_line].num_chars;
                                    input_text_cursor_current_x_offset = text_lines[input_text_cursor_current_line].chars[text_lines[input_text_cursor_current_line].num_chars - 1].x_end - input_text_x;
                                } else {
                                    for (int i = 0; i < text_lines[input_text_cursor_current_line].num_chars; i++) {
                                        if (text_lines[input_text_cursor_current_line].chars[i].x_end >= (input_text_x + input_text_cursor_current_x_offset)) {
                                            if (abs(text_lines[input_text_cursor_current_line].chars[i].x_start - (input_text_x + input_text_cursor_current_x_offset))
                                            < text_lines[input_text_cursor_current_line].chars[i].x_end - (input_text_x + input_text_cursor_current_x_offset)) {
                                                input_text_cursor_position = text_lines[input_text_cursor_current_line].chars[i].position_in_text;
                                                input_text_current_line_cursor_position = i;
                                                input_text_cursor_current_x_offset = text_lines[input_text_cursor_current_line].chars[i].x_start - input_text_x;
                                            } else {
                                                input_text_cursor_position = text_lines[input_text_cursor_current_line].chars[i].position_in_text + 1;
                                                input_text_current_line_cursor_position = i + 1;
                                                input_text_cursor_current_x_offset = text_lines[input_text_cursor_current_line].chars[i].x_end - input_text_x;
                                            }
                                            break;
                                        }
                                    }
                                }
                            } else { // empty last line
                                input_text_cursor_position = text_lines[input_text_cursor_current_line - 1].chars[text_lines[input_text_cursor_current_line - 1].num_chars - 1].position_in_text + 1;
                                input_text_current_line_cursor_position = 0;
                                input_text_cursor_current_x_offset = 0;
                            }
                        }
                        break;
                    case SDLK_HOME:
                        move_input_text_cursor_to_beginning();
                        break;
                    case SDLK_END:
                        input_text_cursor_position = input_text_current_length;
                        input_text_cursor_current_line = text_num_completed_lines;
                        input_text_current_line_cursor_position = text_lines[text_num_completed_lines].num_chars;
                        input_text_cursor_current_x_offset = text_lines[text_num_completed_lines].line_width;
                        break;
                }
            }
            if (event.type == SDL_TEXTINPUT) {
                if (input_text_current_length + 1 < input_text_max_length // + 1 for null terminator
                && (
                    (input_text_numeric_only
                        && ((input_text_numeric_allow_negative && ((event.text.text[0] >= '0' && event.text.text[0] <= '9') || event.text.text[0] == '-'))
                            || (!input_text_numeric_allow_negative && (event.text.text[0] >= '0' && event.text.text[0] <= '9'))))
                    || (!input_text_numeric_only
                        && (event.text.text[0] == ' '
                            || event.text.text[0] == '-'
                            || (event.text.text[0] >= '0' && event.text.text[0] <= '9')
                            || (event.text.text[0] >= 'a' && event.text.text[0] <= 'z')
                            || (event.text.text[0] >= 'A' && event.text.text[0] <= 'Z')
                            || event.text.text[0] == ','
                            || event.text.text[0] == '.'
                            || event.text.text[0] == '?'
                            || event.text.text[0] == '!'
                            || event.text.text[0] == '@'
                            || event.text.text[0] == '%'
                            || event.text.text[0] == '\''
                            || event.text.text[0] == '/'
                            || event.text.text[0] == '_')))) {
                    memset(input_text_string_backup, 0, sizeof(input_text_string_backup));
                    string_copy(input_text_string, input_text_string_backup, MAX_BRIEFING_LENGTH);
                    for (int i = input_text_current_length; i > input_text_cursor_position; i--) {
                        input_text_string[i] = input_text_string[i - 1];
                    }
                    input_text_string[input_text_cursor_position] = event.text.text[0];
                    input_text_current_length++;
                    parse_text(input_text_string, input_text_x, input_text_y, input_text_current_length, input_text_field_line_max_width, input_text_font);
                    if (!input_text_current_line_cursor_position || text_lines[input_text_cursor_current_line].chars[input_text_current_line_cursor_position].position_in_text) { // char allocated to current line, move cursor right
                        input_text_cursor_current_x_offset = text_lines[input_text_cursor_current_line].chars[input_text_current_line_cursor_position].x_end - input_text_x;
                        input_text_cursor_position++;
                        input_text_current_line_cursor_position++;
                    } else { // char allocated to next line
                        if (text_num_completed_lines < input_text_max_lines) {
                            input_text_cursor_position++;
                            input_text_cursor_current_line++;
                            input_text_current_line_cursor_position = 1;
                            input_text_cursor_current_x_offset = text_lines[input_text_cursor_current_line].chars[0].x_end - input_text_x;
                        } else { // illegal operation (ran out of lines), revert text
                            memset(input_text_string, 0, sizeof(input_text_string));
                            string_copy(input_text_string_backup, input_text_string, MAX_BRIEFING_LENGTH);
                            input_text_current_length--;
                            parse_text(input_text_string, input_text_x, input_text_y, input_text_current_length, input_text_field_line_max_width, input_text_font);
                        }
                    }
                }
            }
            switch (current_window) {
                case WINDOW_INTRO_VIDEOS:
                    if (enter_pressed || mouse_left_down) {
                        video_stop();
                        change_window(WINDOW_LOGO);
                    } else if (escape_key_down || mouse_right_up) {
                        quit_game();
                    }
                    break;
                case WINDOW_LOGO:
                    if (enter_pressed || mouse_left_down) {
                        show_main_menu_window(0);
                    } else if (escape_key_down || mouse_right_up) {
                        quit_game();
                    }
                    break;
                case WINDOW_MAIN_MENU:
                    if (escape_key_down || mouse_right_up) {
                        quit_game();
                    } else if (mouse_left_down) {
                        for (int i = 0; i < 5; i++) {
                            if (mouse_x >= image_buttons_main_menu[i].x_scaled
                            && mouse_x < image_buttons_main_menu[i].x_scaled + image_buttons_main_menu[i].width_scaled
                            && mouse_y >= image_buttons_main_menu[i].y_scaled
                            && mouse_y < image_buttons_main_menu[i].y_scaled + 25) {
                                switch (i) {
                                    case 0:
                                        change_window(WINDOW_CCK_SELECTION);
                                        cck_selection_data.scenarios = dir_list_files("map");
                                        if (cck_selection_data.scenarios->num_files) {
                                            select_scenario(0);
                                        }
                                        init_scrollbar(screen_center_y - 35);
                                        break;
                                    case 1:
                                        show_file_dialog_window(FILE_TYPE_SAVED_GAME, FILE_DIALOG_LOAD);
                                        break;
                                    case 2:
                                    {
                                        int editor_present = 1;
                                        for (int i = 0; i < MAX_EDITOR_FILES; i++) {
                                            if (!file_exists(0, EDITOR_FILES[i])) {
                                                editor_present = 0;
                                                change_window(WINDOW_EDITOR_NOT_FOUND);
                                                break;
                                            }
                                        }
                                        if (editor_present) {
                                            load_files(FILE_EDITOR_TEXT_ENG, FILE_EDITOR_MM_ENG);
                                            game_animation_init();
                                            building_clear_all();
                                            memset(storages, 0, MAX_STORAGES * sizeof(struct data_storage));
                                            figure_init_scenario();
                                            reset_all_formations();
                                            figure_route_clear_all();
                                            memset(&figure_trader_data, 0, sizeof(figure_trader_data));
                                            game_time_init(2098);
                                            editor_active = 1;
                                            game_file_editor_create_scenario(2);
                                            change_window(WINDOW_EDITOR_MAP);
                                            update_music(1);
                                        }
                                        break;
                                    }
                                    case 3:
                                        change_window(WINDOW_CONFIGS);
                                        break;
                                    case 4:
                                        quit_game();
                                        break;
                                }
                                break;
                            }
                        }
                    }
                    break;
                case WINDOW_CCK_SELECTION:
                    if (enter_pressed) {
                        start_scenario();
                    } else if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_MAIN_MENU);
                    } else if (mouse_left_down) {
                        if (mouse_x >= screen_center_x - 57 && mouse_x < screen_center_x - 57 + SCROLLBAR_BUTTON_WIDTH
                        && mouse_y >= screen_center_y - 35 // SCROLLBAR_DOT_HEIGHT / 2 omitted here to allow dot dragging by clicking anywhere on it
                        && mouse_y < screen_center_y + 198) { // ^
                            is_dragging_scroll = 1;
                        } else {
                            if (mouse_x >= screen_center_x - 358 && mouse_x < screen_center_x - 75
                            && mouse_y >= screen_center_y - 52 && mouse_y < screen_center_y - 34 + 18 * (MAX_SCENARIOS_SHOWN - 1)) {
                                for (int i = 0; i < MAX_SCENARIOS_SHOWN; i++) {
                                    if (i >= cck_selection_data.scenarios->num_files) {
                                        break;
                                    }
                                    if (mouse_x >= screen_center_x - 358 && mouse_x < screen_center_x - 75
                                    && mouse_y >= screen_center_y - 52 + 18 * i && mouse_y < screen_center_y - 34 + 18 * i) {
                                        select_scenario(i);
                                    }
                                }
                            } else if (mouse_x >= screen_center_x - 57 && mouse_x < screen_center_x - 57 + SCROLLBAR_BUTTON_WIDTH
                            && mouse_y >= screen_center_y - 35 - SCROLLBAR_BUTTON_HEIGHT && mouse_y < screen_center_y - 35) {
                                scrollbar_up_arrow_pressed = 1;
                            } else if (mouse_x >= screen_center_x - 57 && mouse_x < screen_center_x - 57 + SCROLLBAR_BUTTON_WIDTH
                            && mouse_y >= screen_center_y + 198 && mouse_y < screen_center_y + 198 + SCROLLBAR_BUTTON_HEIGHT) {
                                scrollbar_down_arrow_pressed = 1;
                            } else if (mouse_x >= screen_center_x + 300 && mouse_x < screen_center_x + 333
                            && mouse_y >= screen_center_y - 140 && mouse_y < screen_center_y - 118) {
                                // toggle scenario minimap
                                cck_selection_data.show_minimap = !cck_selection_data.show_minimap;
                                refresh_current_window = 1;
                            } else if (mouse_x >= screen_center_x + 340 && mouse_x < screen_center_x + 367
                            && mouse_y >= screen_center_y + 197 && mouse_y < screen_center_y + 224) {
                                current_window_image_button_pressed = 1;
                            }
                        }
                    } else if (mouse_left_up) {
                        current_window_image_button_pressed = 0;
                        if (is_dragging_scroll || scrollbar_up_arrow_pressed || scrollbar_down_arrow_pressed) {
                            release_scrollbar();
                        } else {
                            if (mouse_x >= screen_center_x + 340 && mouse_x < screen_center_x + 367
                            && mouse_y >= screen_center_y + 197 && mouse_y < screen_center_y + 224) {
                                start_scenario();
                            }
                        }
                    } else if (event.type == SDL_MOUSEWHEEL) {
                        scroll_scrollbar_step(-event.wheel.y, screen_center_y - 35, 233, cck_selection_data.scenarios->num_files - MAX_SCENARIOS_SHOWN);
                    }
                    if (is_dragging_scroll) {
                        drag_scrollbar_mouse(mouse_y, screen_center_y - 35, 233, cck_selection_data.scenarios->num_files - MAX_SCENARIOS_SHOWN);
                    }
                    break;
                case WINDOW_MISSION_BRIEFING:
                    if (enter_pressed || escape_key_down || mouse_right_up) {
                        stop_sound_channel(SOUND_CHANNEL_SPEECH);
                        update_music(1);
                        show_city_window();
                        close_build_menu();
                    } else if (event.type == SDL_MOUSEWHEEL) {
                        // scroll_scrollbar_step(-event.wheel.y, screen_center_y - 35, 233, cck_selection_data.scenarios->num_files - MAX_SCENARIOS_SHOWN);
                    }
                    if (is_dragging_scroll) {
                        // drag_scrollbar_mouse(mouse_y, screen_center_y - 35, 233, cck_selection_data.scenarios->num_files - MAX_SCENARIOS_SHOWN);
                    }
                    break;
                case WINDOW_CITY:
                    if (enter_pressed) {

                    } else if (escape_key_down || mouse_right_up) {
                        if (construction_data.type) {
                            building_construction_cancel();
                        } else if (build_menu_data.selected_menu > -1) {
                            close_build_menu();
                            refresh_current_window = 1;
                        } else if (mouse_x < sidebar_x_offset && mouse_y >= 24 && mouse_y < map_y_max) { // clicked in map area
                            selected_unit_index = -1;
                            selected_units_count = 0;
                            for (int i = 0; i < 7; i++) {
                                selected_units_list[i] = 0;
                            }
                            int FIGURE_OFFSETS[] = {
                                OFFSET(0,0), OFFSET(0,-1), OFFSET(0,1), OFFSET(1,0), OFFSET(-1,0),
                                OFFSET(-1,-1), OFFSET(1,-1), OFFSET(-1,1), OFFSET(1,1)
                            };
                            for (int i = 0; i < 9 && selected_units_count < 7; i++) {
                                int figure_id = map_grid_is_valid_offset(widget_city_data.current_tile.grid_offset + FIGURE_OFFSETS[i]) ? map_figures.items[widget_city_data.current_tile.grid_offset + FIGURE_OFFSETS[i]] : 0;
                                while (figure_id > 0 && selected_units_count < 7) {
                                    struct figure_t *f = &figures[figure_id];
                                    if (figure_is_alive(f)) {
                                        switch (f->type) {
                                            case FIGURE_NONE:
                                            case FIGURE_EXPLOSION:
                                            case FIGURE_MAP_FLAG:
                                            case FIGURE_FLOTSAM:
                                            case FIGURE_ARROW:
                                            case FIGURE_JAVELIN:
                                            case FIGURE_BOLT:
                                            case FIGURE_BALLISTA:
                                            case FIGURE_FISH_GULLS:
                                            case FIGURE_HIPPODROME_HORSES:
                                                break;
                                            default:
                                                selected_units_list[selected_units_count++] = &figures[figure_id];
                                                selected_unit_index = 0;
                                                break;
                                        }
                                    }
                                    figure_id = f->next_figure_id_on_same_tile;
                                }
                            }
                            if (selected_units_list[0]) {
                                change_window(WINDOW_CONTEXT_INFO);
                            } else {
                                selected_building = &all_buildings[map_building_at(widget_city_data.current_tile.grid_offset)];
                                while (selected_building->prev_part_building_id) {
                                    selected_building = &all_buildings[selected_building->prev_part_building_id];
                                }
                                if (selected_building) {
                                    change_window(WINDOW_CONTEXT_INFO);
                                }
                            }
                        }
                    } else if (mouse_left_down) {
                        if (mouse_x >= 10 && mouse_x < 38 && mouse_y < 30) {
                            top_menu_data.open_sub_menu = TOP_MENU_FILE;
                            change_window(WINDOW_TOP_MENU);
                        } else if (mouse_x >= 78 && mouse_x < 139 && mouse_y < 30) {
                            top_menu_data.open_sub_menu = TOP_MENU_OPTIONS;
                            change_window(WINDOW_TOP_MENU);
                        } else if (mouse_x >= sidebar_x_offset + 4 && mouse_x < sidebar_x_offset + 121 && mouse_y >= 27 && mouse_y < 52) {
                            change_window(WINDOW_OVERLAY_MENU);
                        } else if (mouse_x >= sidebar_x_offset + 127 && mouse_x < sidebar_x_offset + 158 && mouse_y >= 29 && mouse_y < 49) {
                            current_window_image_button_pressed = 1; // sidebar slide button
                        } else if (mouse_x >= minimap_data.x_offset && mouse_x < minimap_data.x_offset + minimap_data.width
                        && mouse_y >= minimap_data.y_offset && mouse_y < minimap_data.y_offset + minimap_data.height) { // in minimap
                            minimap_data.mouse.x = mouse_x;
                            minimap_data.mouse.y = mouse_y;
                            minimap_data.mouse.grid_offset = 0;
                            city_view_foreach_minimap_tile(minimap_data.x_offset, minimap_data.y_offset,
                                                           minimap_data.absolute_x, minimap_data.absolute_y,
                                                           minimap_data.width_tiles, minimap_data.height_tiles,
                                                           update_mouse_grid_offset);
                            if (minimap_data.mouse.grid_offset) {
                                city_view_go_to_grid_offset(minimap_data.mouse.grid_offset);
                            }
                        } else if (mouse_x >= sidebar_x_offset + 7 && mouse_x < sidebar_x_offset + 78 && mouse_y >= 180 && mouse_y < 203) {
                            current_window_image_button_pressed = 2; // advisors button
                        } else if (mouse_x >= sidebar_x_offset + 84 && mouse_x < sidebar_x_offset + 155 && mouse_y >= 180 && mouse_y < 203) {
                            current_window_image_button_pressed = 3; // empire button
                        } else if (mouse_x >= sidebar_x_offset + 7 && mouse_x < sidebar_x_offset + 40 && mouse_y >= 209 && mouse_y < 231) {
                            current_window_image_button_pressed = 4; // mission briefing button
                        } else if (mouse_x >= sidebar_x_offset + 46 && mouse_x < sidebar_x_offset + 79 && mouse_y >= 209 && mouse_y < 231) {
                            current_window_image_button_pressed = 5; // rotation reset button
                        } else if (mouse_x >= sidebar_x_offset + 84 && mouse_x < sidebar_x_offset + 117 && mouse_y >= 209 && mouse_y < 231) {
                            current_window_image_button_pressed = 6; // rotate left button
                        } else if (mouse_x >= sidebar_x_offset + 123 && mouse_x < sidebar_x_offset + 156 && mouse_y >= 209 && mouse_y < 231) {
                            current_window_image_button_pressed = 7; // rotate right button
                        } else if (mouse_x >= sidebar_x_offset + 13 && mouse_x < sidebar_x_offset + 152 && mouse_y >= 301 && mouse_y < 467) { // build menu buttons
                            for (int i = 0; i < 5; i++) {
                                for (int j = 0; j < 3; j++) {
                                    if (mouse_x >= sidebar_x_offset + 13 + 50 * j && mouse_x < sidebar_x_offset + 52 + 50 * j && mouse_y >= 301 + 36 * i && mouse_y < 323 + 36 * i) {
                                        current_window_image_button_pressed = 3 * i + j + 8;
                                        break;
                                    }
                                }
                            }
                        } else if (configs[CONFIG_UI_SIDEBAR_INFO].config_value && mouse_x >= sidebar_x_offset + 8 && mouse_x < sidebar_x_offset + 32 && mouse_y >= 502 && mouse_y < 526) { // extra sidebar info game speed button up
                            current_window_image_button_pressed = 23;
                            refresh_current_window = 1;
                        } else if (configs[CONFIG_UI_SIDEBAR_INFO].config_value && mouse_x >= sidebar_x_offset + 32 && mouse_x < sidebar_x_offset + 56 && mouse_y >= 502 && mouse_y < 526) { // extra sidebar info game speed button down
                            current_window_image_button_pressed = 24;
                            refresh_current_window = 1;
                        } else if (mouse_x < sidebar_x_offset && mouse_y >= 24 && mouse_y < map_y_max) { // clicked in map area
                            // select menu item
                            if (build_menu_data.selected_menu >= MENU_WATER) {
                                if (mouse_x >= sidebar_x_offset - 261 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 301 && mouse_y < 321 + 24 * (build_menu_data.num_items_to_draw - 1)) {
                                    for (int i = 0; i < build_menu_data.num_items_to_draw; i++) {
                                        if (mouse_x >= sidebar_x_offset - 261 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 301 + 24 * i && mouse_y < 321 + 24 * i) {
                                            button_submenu_or_building(i);
                                            break;
                                        }
                                    }
                                } else {
                                    build_menu_data.selected_menu = -1;
                                }
                            } else {
                                if (selected_legion_formation) { // legion selected
                                    // return legion home upon clicking on own fort/fort ground
                                    struct building_t *b = &all_buildings[map_building_at(widget_city_data.current_tile.grid_offset)];
                                    if (b && b->state == BUILDING_STATE_IN_USE && (building_is_fort(b->type) || b->type == BUILDING_FORT_GROUND) && b->formation_id == selected_legion_formation->id) {
                                        return_legion_formation_home(selected_legion_formation);
                                    } else { // move legion if route available
                                        map_routing_calculate_distances(selected_legion_formation->standard_x, selected_legion_formation->standard_y);
                                        if (routing_distance.items[widget_city_data.current_tile.grid_offset]
                                        && selected_legion_formation->morale > ROUT_MORALE_THRESHOLD
                                        && selected_legion_formation->num_figures) {
                                            play_speech_file("wavs/cohort5.wav");
                                            selected_legion_formation->standard_x = widget_city_data.current_tile.x;
                                            selected_legion_formation->standard_y = widget_city_data.current_tile.y;
                                            update_legion_standard_map_location(selected_legion_formation);
                                            for (int i = 0; i < selected_legion_formation->num_figures && selected_legion_formation->figures[i]; i++) {
                                                struct figure_t *f = &figures[selected_legion_formation->figures[i]];
                                                deploy_legion_unit_to_formation_location(f, selected_legion_formation);
                                            }
                                        } else if (selected_legion_formation->morale <= ROUT_MORALE_THRESHOLD) {
                                            city_warning_show(WARNING_LEGION_MORALE_TOO_LOW);
                                        }
                                        selected_legion_formation = 0;
                                        cursor_data.current_shape = CURSOR_ARROW;
                                        SDL_SetCursor(cursor_data.cursors[CURSOR_ARROW]);
                                    }
                                } else {
                                    // handle legion click
                                    int formation_id = select_legion_index_at(widget_city_data.current_tile.grid_offset);
                                    if (formation_id > -1 && !legion_formations[formation_id].in_distant_battle && !legion_formations[formation_id].cursed_by_mars) {
                                        select_legion_formation(&legion_formations[formation_id]);
                                    }
                                    if (!construction_data.in_progress && construction_data.type != BUILDING_NONE) {
                                        construction_data.start.grid_offset = widget_city_data.current_tile.grid_offset;
                                        construction_data.start.x = construction_data.end.x = widget_city_data.current_tile.x;
                                        construction_data.start.y = construction_data.end.y = widget_city_data.current_tile.y;
                                        if (game_undo_start_build(construction_data.type)) {
                                            construction_data.in_progress = 1;
                                            int can_start = 1;
                                            switch (construction_data.type) {
                                                case BUILDING_ROAD:
                                                    can_start = map_routing_calculate_distances_for_building(ROUTED_BUILDING_ROAD, construction_data.start.x, construction_data.start.y);
                                                    break;
                                                case BUILDING_AQUEDUCT:
                                                    can_start = map_routing_calculate_distances_for_building(ROUTED_BUILDING_AQUEDUCT, construction_data.start.x, construction_data.start.y);
                                                    break;
                                                case BUILDING_WALL:
                                                    can_start = map_routing_calculate_distances_for_building(ROUTED_BUILDING_WALL, construction_data.start.x, construction_data.start.y);
                                                    break;
                                                default:
                                                    break;
                                            }
                                            if (!can_start) {
                                                building_construction_cancel();
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else if (mouse_left_up) {
                        switch (current_window_image_button_pressed) {
                            case 1:
                                if (mouse_x >= sidebar_x_offset + 127 && mouse_x < sidebar_x_offset + 158 && mouse_y >= 29 && mouse_y < 49) {
                                    set_viewport(0, 24, view_data.screen_width - 40, view_data.screen_height - 24);
                                    check_camera_boundaries();
                                    widget_slide_data.direction = !view_data.sidebar_collapsed;
                                    widget_slide_data.position = 0;
                                    speed_clear(&widget_slide_data.slide_speed);
                                    speed_set_target(&widget_slide_data.slide_speed, SLIDE_SPEED, !(view_data.sidebar_collapsed == SLIDE_DIRECTION_OUT) ? SLIDE_ACCELERATION_MILLIS : SPEED_CHANGE_IMMEDIATE, 1);
                                    // widget_slide_data.back_sidebar_draw = draw_collapsed_background;
                                    // widget_slide_data.front_sidebar_draw = draw_expanded_background;
                                    widget_slide_data.finished_callback = slide_finished;
                                    play_sound_effect(SOUND_EFFECT_SIDEBAR);
                                    change_window(WINDOW_SLIDING_SIDEBAR);
                                }
                                break;
                            case 2:
                                if (mouse_x >= sidebar_x_offset + 7 && mouse_x < sidebar_x_offset + 78 && mouse_y >= 180 && mouse_y < 203) {
                                    window_advisors_show(settings[SETTINGS_LAST_ADVISOR].config_value);
                                }
                                break;
                            case 3:
                                if (mouse_x >= sidebar_x_offset + 84 && mouse_x < sidebar_x_offset + 155 && mouse_y >= 180 && mouse_y < 203) {
                                    window_empire_show();
                                }
                                break;
                            case 4:
                                if (mouse_x >= sidebar_x_offset + 7 && mouse_x < sidebar_x_offset + 40 && mouse_y >= 209 && mouse_y < 231) {
                                    change_window(WINDOW_MISSION_BRIEFING);
                                }
                                break;
                            case 5:
                                if (mouse_x >= sidebar_x_offset + 46 && mouse_x < sidebar_x_offset + 79 && mouse_y >= 209 && mouse_y < 231) {
                                    switch (view_data.orientation) {
                                        case DIR_2_RIGHT:
                                            city_view_rotate_right();
                                            map_orientation_change(1);
                                            break;
                                        case DIR_4_BOTTOM:
                                            city_view_rotate_left();
                                            map_orientation_change(0);
                                            /* fall through */
                                        case DIR_6_LEFT:
                                            city_view_rotate_left();
                                            map_orientation_change(0);
                                            break;
                                        default: // already north
                                            break;
                                    }
                                    minimap_data.refresh_requested = 1;
                                    city_warning_show(WARNING_ORIENTATION);
                                    refresh_current_window = 1;
                                }
                                break;
                            case 6:
                                if (mouse_x >= sidebar_x_offset + 84 && mouse_x < sidebar_x_offset + 117 && mouse_y >= 209 && mouse_y < 231) {
                                    game_orientation_rotate_left();
                                    refresh_current_window = 1;
                                }
                                break;
                            case 7:
                                if (mouse_x >= sidebar_x_offset + 123 && mouse_x < sidebar_x_offset + 156 && mouse_y >= 209 && mouse_y < 231) {
                                    game_orientation_rotate_right();
                                    refresh_current_window = 1;
                                }
                                break;
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 15:
                            case 16:
                            case 17:
                            case 18:
                            case 19:
                                if (mouse_x >= sidebar_x_offset + 13 + 50 * ((current_window_image_button_pressed - 8) % 3)
                                && mouse_x < sidebar_x_offset + 52 + 50 * ((current_window_image_button_pressed - 8) % 3)
                                && mouse_y >= 301 + 36 * ((current_window_image_button_pressed - 8) / 3)
                                && mouse_y < 323 + 36 * ((current_window_image_button_pressed - 8) / 3)) {
                                    int menu = MENU_VACANT_HOUSE + current_window_image_button_pressed - 8;
                                    if (menu == MENU_VACANT_HOUSE || menu == MENU_CLEAR_LAND || menu == MENU_ROAD) {
                                        build_menu_data.selected_submenu = -1;
                                        build_menu_data.selected_menu = menu;
                                        build_menu_data.num_items_to_draw = 0;
                                        building_construction_set_type(BUILDING_MENU_SUBMENU_ITEM_MAPPING[menu][0][0]);
                                    } else {
                                        if (menu == build_menu_data.selected_menu) { // same menu selected
                                            close_build_menu();
                                            break;
                                        } else {
                                            build_menu_data.selected_submenu = -1;
                                            build_menu_data.selected_menu = menu;
                                            build_menu_data.num_items_to_draw = 0;
                                            for (int j = 0; j < MAX_ITEMS_PER_BUILD_MENU; j++) {
                                                if (build_menus[menu].menu_items[j].building_id) {
                                                    build_menu_data.num_items_to_draw++;
                                                }
                                            }
                                        }
                                    }
                                    refresh_current_window = 1;
                                }
                                break;
                            case 20:
                                close_build_menu();
                                game_undo_perform();
                                refresh_current_window = 1;
                                break;
                            case 21:
                                close_build_menu();
                                show_messages_window();
                                break;
                            case 22:
                                button_go_to_problem();
                                break;
                            case 23:
                                increase_game_speed();
                                refresh_current_window = 1;
                                break;
                            case 24:
                                decrease_game_speed();
                                refresh_current_window = 1;
                                break;
                        }
                        if (construction_data.in_progress) {
                            if (construction_data.type != BUILDING_NONE) {
                                play_sound_effect(SOUND_EFFECT_BUILD);
                            }
                            if (construction_data.type) {
                                building_construction_place();
                            }
                            minimap_data.refresh_requested = 1;
                        }
                        if (build_menu_data.selected_menu == -1) {
                            current_window_image_button_pressed = 0;
                        }
                    } else if (mouse_middle_down) {
                        start_mouse_scroll_drag();
                    } else if (mouse_middle_up) {
                        end_mouse_scroll_drag();
                    }
                    break;
                case WINDOW_TOP_MENU:
                    if (escape_key_down || mouse_right_up) {
                        top_menu_data.open_sub_menu = TOP_MENU_NONE;
                        change_window(WINDOW_CITY);
                    } else if (mouse_left_down) {
                        if (((top_menu_data.open_sub_menu == TOP_MENU_FILE && (mouse_x < 0 || mouse_x >= 112 || mouse_y < 0 || mouse_y >= 104))
                            || (top_menu_data.open_sub_menu == TOP_MENU_OPTIONS && (mouse_x < 68 || mouse_x >= 148 || mouse_y < 0 || mouse_y >= 88)))) {
                            top_menu_data.open_sub_menu = TOP_MENU_NONE;
                            change_window(WINDOW_CITY);
                        } else {
                            switch (top_menu_data.open_sub_menu) {
                                case 1:
                                    for (int i = 0; i < 4; i++) {
                                        if (mouse_x >= 10 && mouse_x < 105 && mouse_y >= 28 + 18 * i && mouse_y < 46 + 18 * i) {
                                            switch (i) {
                                                case 0:
                                                    top_menu_data.open_sub_menu = TOP_MENU_NONE;
                                                    change_window(WINDOW_REPLAY_MAP);
                                                    break;
                                                case 1:
                                                    top_menu_data.open_sub_menu = TOP_MENU_NONE;
                                                    show_file_dialog_window(FILE_TYPE_SAVED_GAME, FILE_DIALOG_SAVE);
                                                    break;
                                                case 2:
                                                    top_menu_data.open_sub_menu = TOP_MENU_NONE;
                                                    show_file_dialog_window(FILE_TYPE_SAVED_GAME, FILE_DIALOG_LOAD);
                                                    break;
                                                case 3:
                                                    top_menu_data.open_sub_menu = TOP_MENU_NONE;
                                                    change_window(WINDOW_EXIT_TO_MAIN_MENU);
                                                    break;
                                            }
                                        }
                                    }
                                    break;
                                case 2:
                                    for (int i = 0; i < 3; i++) {
                                        if (mouse_x >= 78 && mouse_x < 142 && mouse_y >= 28 + 18 * i && mouse_y < 46 + 18 * i) {
                                            switch (i) {
                                                case 0:
                                                    top_menu_data.open_sub_menu = TOP_MENU_NONE;
                                                    change_window(WINDOW_DISPLAY_OPTIONS);
                                                    break;
                                                case 1:
                                                    top_menu_data.open_sub_menu = TOP_MENU_NONE;
                                                    change_window(WINDOW_SOUND_OPTIONS);
                                                    break;
                                                case 2:
                                                    top_menu_data.open_sub_menu = TOP_MENU_NONE;
                                                    change_window(WINDOW_SPEED_OPTIONS);
                                                    break;
                                            }
                                        }
                                    }
                                    break;
                            }
                        }
                    }
                    break;
                case WINDOW_REPLAY_MAP:
                    if (enter_pressed) {
                        if (game_file_start_scenario(scenario.scenario_name)) {
                            change_window(WINDOW_CITY);
                        }
                    } else if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_CITY);
                    } else if (mouse_left_down) {
                        if (mouse_x >= map_center_x + 73 && mouse_x < map_center_x + 112 && map_center_y - 12 && mouse_y < map_center_y + 14) {
                            current_window_image_button_pressed = 1;
                        }
                    } else if (mouse_left_up) {
                        current_window_image_button_pressed = 0;
                        if (mouse_x >= map_center_x + 73 && mouse_x < map_center_x + 112 && map_center_y - 12 && mouse_y < map_center_y + 14) {
                            if (game_file_start_scenario(scenario.scenario_name)) {
                                change_window(WINDOW_CITY);
                            }
                        }
                    }
                    break;
                case WINDOW_FILE_DIALOG:
                    if (enter_pressed) {
                        button_ok_cancel();
                    } else if (escape_key_down || mouse_right_up) {
                        if (text_field_active) {
                            stop_text_input();
                        } else {
                            if (editor_active) {
                                change_window(WINDOW_EDITOR_MAP);
                            } else {
                                if (previous_window == WINDOW_MAIN_MENU) {
                                    change_window(WINDOW_MAIN_MENU);
                                } else {
                                    change_window(WINDOW_CITY);
                                }
                            }
                        }
                    } else if (mouse_left_down) {
                        if (mouse_x >= screen_center_x - 368 && mouse_x < screen_center_x + 368 && mouse_y >= screen_center_y - 180 && mouse_y < screen_center_y - 148) {
                            handle_input_text_mouse_click(1, screen_center_x - 368, screen_center_y - 180, FILE_NAME_LENGTH_MAX, FONT_NORMAL_WHITE, file_dialog_data.selected_file, 1, 500);
                        } else {
                            stop_text_input();
                            if (mouse_x >= screen_center_x + 327 && mouse_x < screen_center_x + 327 + SCROLLBAR_BUTTON_WIDTH
                            && mouse_y >= screen_center_y - 113 // SCROLLBAR_DOT_HEIGHT / 2 omitted here to allow dot dragging by clicking anywhere on it
                            && mouse_y < screen_center_y + 184) { // ^
                                is_dragging_scroll = 1;
                            } else {
                                if (mouse_x >= screen_center_x - 352 && mouse_x < screen_center_x + 300
                                && mouse_y >= screen_center_y - 132 && mouse_y < screen_center_y - 114 + 18 * (MAX_FILE_DIALOG_FILES_SHOWN - 1)) {
                                    for (int i = 0; i < MAX_FILE_DIALOG_FILES_SHOWN; i++) {
                                        if (i >= file_dialog_data.file_list->num_files) {
                                            break;
                                        }
                                        if (mouse_x >= screen_center_x - 352 && mouse_x < screen_center_x + 300
                                        && mouse_y >= screen_center_y - 132 + 18 * i && mouse_y < screen_center_y - 114 + 18 * i) {
                                            string_copy(file_dialog_data.file_list->files[i + scrollbar_position], file_dialog_data.selected_file, FILE_NAME_LENGTH_MAX - 1);
                                            file_dialog_data.message_not_exist_start_time = 0;
                                            refresh_current_window = 1;
                                        }
                                    }
                                } else if (mouse_x >= screen_center_x + 327 && mouse_x < screen_center_x + 327 + SCROLLBAR_BUTTON_WIDTH
                                && mouse_y >= screen_center_y - 113 - SCROLLBAR_BUTTON_HEIGHT && mouse_y < screen_center_y - 113) {
                                    scrollbar_up_arrow_pressed = 1;
                                } else if (mouse_x >= screen_center_x + 327 && mouse_x < screen_center_x + 327 + SCROLLBAR_BUTTON_WIDTH
                                && mouse_y >= screen_center_y + 184 && mouse_y < screen_center_y + 184 + SCROLLBAR_BUTTON_HEIGHT) {
                                    scrollbar_down_arrow_pressed = 1;
                                } else if (mouse_x >= screen_center_x + 328 && mouse_x < screen_center_x + 367
                                && mouse_y >= screen_center_y - 220 && mouse_y < screen_center_y - 194) {
                                    current_window_image_button_pressed = 1;
                                }
                            }
                        }
                    } else if (mouse_left_up) {
                        current_window_image_button_pressed = 0;
                        if (is_dragging_scroll || scrollbar_up_arrow_pressed || scrollbar_down_arrow_pressed) {
                            release_scrollbar();
                        } else {
                            if (mouse_x >= screen_center_x + 328 && mouse_x < screen_center_x + 367
                            && mouse_y >= screen_center_y - 220 && mouse_y < screen_center_y - 194) {
                                button_ok_cancel();
                                stop_text_input();
                            }
                        }
                    } else if (event.type == SDL_MOUSEWHEEL) {
                        scroll_scrollbar_step(-event.wheel.y, screen_center_y - 113, 297, file_dialog_data.file_list->num_files - MAX_FILE_DIALOG_FILES_SHOWN);
                    }
                    if (is_dragging_scroll) {
                        drag_scrollbar_mouse(mouse_y, screen_center_y - 113, 297, file_dialog_data.file_list->num_files - MAX_FILE_DIALOG_FILES_SHOWN);
                    }
                    break;
                case WINDOW_EXIT_TO_MAIN_MENU:
                    if (escape_key_down || mouse_right_up) {
                        if (editor_active) {
                            change_window(WINDOW_EDITOR_MAP);
                        } else {
                            change_window(WINDOW_CITY);
                        }
                    } else if (mouse_left_down) {
                        if (mouse_x >= map_center_x + 239 && mouse_x < map_center_x + 278
                        && mouse_y >= map_center_y - 16 && mouse_y < map_center_y + 10) {
                            current_window_image_button_pressed = 1;
                        }
                    } else if (mouse_left_up) {
                        if (mouse_x >= map_center_x + 239 && mouse_x < map_center_x + 278
                        && mouse_y >= map_center_y - 16 && mouse_y < map_center_y + 10) {
                            if (editor_active) {
                                load_files(FILE_TEXT_ENG, FILE_MM_ENG);
                                load_main_graphics(scenario.climate, 0);
                                editor_active = 0;
                            }
                            show_main_menu_window(1);
                        }
                        current_window_image_button_pressed = 0;
                    }
                    break;
                case WINDOW_DISPLAY_OPTIONS:
                    if (escape_key_down || mouse_right_up) {
                        if (editor_active) {
                            change_window(WINDOW_EDITOR_MAP);
                        } else {
                            change_window(WINDOW_CITY);
                        }
                    } else if (mouse_left_down) {
                        for (int i = 0; i < 2; i++) {
                            if (mouse_x >= map_center_x - 112 && mouse_x < map_center_x + 112
                            && mouse_y >= map_center_y - 12 + 32 * i && mouse_y < map_center_y + 13 + 32 * i) {
                                if (i) {
                                    reset_screen();
                                } else {
                                    toggle_fullscreen();
                                }
                            }
                        }
                    }
                    break;
                case WINDOW_SOUND_OPTIONS:
                    if (escape_key_down || mouse_right_up) {
                        if (editor_active) {
                            change_window(WINDOW_EDITOR_MAP);
                        } else {
                            change_window(WINDOW_CITY);
                        }
                    } else if (mouse_left_down) {
                        for (int i = 0; i < 4; i++) {
                            if (mouse_x >= map_center_x - 160 && mouse_x < map_center_x + 64 && mouse_y >= map_center_y - 44 + 32 * i && mouse_y < map_center_y - 19 + 32 * i) {
                                settings[SETTINGS_MUSIC_ENABLED + 2 * i].config_value = settings[SETTINGS_MUSIC_ENABLED + 2 * i].config_value ? 0 : 1;
                                if (SETTINGS_MUSIC_ENABLED + 2 * i == SETTINGS_MUSIC_ENABLED) {
                                    if (settings[SETTINGS_MUSIC_ENABLED].config_value) {
                                        update_music(1);
                                    } else {
                                        stop_music();
                                    }
                                } else if (SETTINGS_MUSIC_ENABLED + 2 * i == SETTINGS_SPEECH_ENABLED && !settings[SETTINGS_SPEECH_ENABLED].config_value) {
                                    stop_sound_channel(SOUND_CHANNEL_SPEECH);
                                }
                                break;
                            }
                            if (mouse_x >= map_center_x + 86 && mouse_x < map_center_x + 110 && mouse_y >= map_center_y - 44 + 32 * i && mouse_y < map_center_y - 20 + 32 * i) {
                                current_window_image_button_pressed = 2 * i + 1;
                            } else if (mouse_x >= map_center_x + 110 && mouse_x < map_center_x + 134 && mouse_y >= map_center_y - 44 + 32 * i && mouse_y < map_center_y - 20 + 32 * i) {
                                current_window_image_button_pressed = 2 * i + 2;
                            }
                        }
                    } else if (mouse_left_up) {
                        switch (current_window_image_button_pressed) {
                            case 1:
                            case 2:
                                Mix_VolumeMusic(settings[SETTINGS_MUSIC_VOLUME].config_value * SDL_MIX_MAXVOLUME / 100);
                                break;
                            case 3:
                            case 4:
                                set_channel_volume(SOUND_CHANNEL_SPEECH, settings[SETTINGS_SPEECH_VOLUME].config_value);
                                break;
                            case 5:
                            case 6:
                                for (int i = SOUND_CHANNEL_EFFECTS_MIN; i <= SOUND_CHANNEL_EFFECTS_MAX; i++) {
                                    set_channel_volume(i, settings[SETTINGS_SOUND_EFFECTS_VOLUME].config_value);
                                }
                                break;
                            case 7:
                            case 8:
                                for (int i = SOUND_CHANNEL_CITY_MIN; i <= SOUND_CHANNEL_CITY_MAX; i++) {
                                    set_channel_volume(i, settings[SETTINGS_CITY_SOUNDS_VOLUME].config_value);
                                }
                                break;
                        }
                        current_window_image_button_pressed = 0;
                    }
                    break;
                case WINDOW_SPEED_OPTIONS:
                    if (escape_key_down || mouse_right_up) {
                        if (editor_active) {
                            change_window(WINDOW_EDITOR_MAP);
                        } else {
                            change_window(WINDOW_CITY);
                        }
                    } else if (mouse_left_down) {
                        for (int i = 0; i < 2; i++) {
                            if (mouse_x >= map_center_x + 16 && mouse_x < map_center_x + 40
                            && mouse_y >= map_center_y - 10 + 32 * i && mouse_y < map_center_y + 14 + 32 * i) {
                                current_window_image_button_pressed = 2 * i + 1;
                            } else if (mouse_x >= map_center_x + 40 && mouse_x < map_center_x + 64
                            && mouse_y >= map_center_y - 10 + 32 * i && mouse_y < map_center_y + 14 + 32 * i) {
                                current_window_image_button_pressed = 2 * i + 2;
                            }
                        }
                    } else if (mouse_left_up) {
                        switch (current_window_image_button_pressed) {
                            case 1:
                                increase_game_speed();
                                break;
                            case 2:
                                decrease_game_speed();
                                break;
                            case 3:
                                settings[SETTINGS_SCROLL_SPEED].config_value = calc_bound(settings[SETTINGS_SCROLL_SPEED].config_value + 10, 0, 100);
                                break;
                            case 4:
                                settings[SETTINGS_SCROLL_SPEED].config_value = calc_bound(settings[SETTINGS_SCROLL_SPEED].config_value - 10, 0, 100);
                                break;
                        }
                        current_window_image_button_pressed = 0;
                    }
                    break;
                case WINDOW_OVERLAY_MENU:

                    break;
                case WINDOW_SLIDING_SIDEBAR:

                    break;
                case WINDOW_ADVISOR_LABOR:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_CITY);
                    } else if (mouse_left_down) {
                        for (int i = 0; i < 9; i++) {
                            if (mouse_x >= screen_center_x - 280 && mouse_x < screen_center_x + 280 && mouse_y >= screen_center_y - 112 + 25 * i && mouse_y < screen_center_y - 90 + 25 * i) {
                                labor_priority_data.category = i;
                                labor_priority_data.max_items = 0;
                                for (int i = 0; i < 9; i++) {
                                    if (city_data.labor.categories[i].priority > 0) {
                                        labor_priority_data.max_items++;
                                    }
                                }
                                if (labor_priority_data.max_items < 9 && !city_data.labor.categories[i].priority) {
                                    // allow space for new priority
                                    labor_priority_data.max_items++;
                                }
                                change_window(WINDOW_LABOR_PRIORITY);
                                break;
                            }
                        }
                        for (int i = 0; i < 2; i++) {
                            if (mouse_x >= screen_center_x - 182 + 24 * i && mouse_x < screen_center_x - 158 + 24 * i && mouse_y >= screen_center_y + 152 && mouse_y < screen_center_y + 176) {
                                current_window_image_button_pressed = i + 1;
                            }
                        }
                    } else if (mouse_left_up) {
                        current_window_image_button_pressed = 0;
                        handle_advisor_change();
                    }
                    break;
                case WINDOW_ADVISOR_MILITARY:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_CITY);
                    } else if (mouse_left_down) {
                        if (distant_battle_army_requested && mouse_x >= screen_center_x + 128 && mouse_x < screen_center_x + 288 && mouse_y >= screen_center_y - 184 && mouse_y < screen_center_y - 162) {
                            int legions_sent = 0;
                            int roman_strength = 0;
                            for (int i = 0; i < MAX_LEGIONS; i++) {
                                if (legion_formations[i].in_use && legion_formations[i].empire_service && legion_formations[i].num_figures) {
                                    struct formation_t *m = &legion_formations[i];
                                    m->in_distant_battle = 1;
                                    for (int fig = 0; fig < m->num_figures; fig++) {
                                        if (m->figures[fig] > 0) {
                                            struct figure_t *f = &figures[m->figures[fig]];
                                            if (figure_is_alive(f)) {
                                                f->action_state = FIGURE_ACTION_SOLDIER_GOING_TO_DISTANT_BATTLE;
                                            }
                                        }
                                    }
                                    int strength_factor;
                                    if (m->has_military_training) {
                                        strength_factor = m->figure_type == FIGURE_FORT_LEGIONARY ? 3 : 2;
                                    } else {
                                        strength_factor = m->figure_type == FIGURE_FORT_LEGIONARY ? 2 : 1;
                                    }
                                    roman_strength += strength_factor * m->num_figures;
                                    legions_sent++;
                                }
                            }
                            if (legions_sent) {
                                city_data.distant_battle.roman_months_to_travel_forth = scenario.empire.distant_battle_roman_travel_months;
                                city_data.distant_battle.roman_strength = roman_strength;
                                distant_battle_army_requested = 0;
                                refresh_current_window = 1;
                            }
                        }
                        for (int i = 0; i < city_data.military.total_legions; i++) {
                            if (mouse_x >= screen_center_x + 120 && mouse_x < screen_center_x + 150
                            && mouse_y >= screen_center_y - 115 + 44 * i && mouse_y < screen_center_y - 85 + 44 * i) {
                                struct formation_t *m = &legion_formations[get_legion_formation_by_index_rank(i)];
                                city_view_go_to_grid_offset(map_grid_offset(m->standard_x, m->standard_y));
                                change_window(WINDOW_CITY);
                            }
                        }
                        for (int i = 0; i < city_data.military.total_legions; i++) {
                            if (mouse_x >= screen_center_x + 178 && mouse_x < screen_center_x + 208
                            && mouse_y >= screen_center_y - 115 + 44 * i && mouse_y < screen_center_y - 85 + 44 * i) {
                                struct formation_t *m = &legion_formations[get_legion_formation_by_index_rank(i)];
                                if (!m->in_distant_battle && !m->is_at_rest) {
                                    return_legion_formation_home(m);
                                    refresh_current_window = 1;
                                }
                            }
                        }
                        for (int i = 0; i < city_data.military.total_legions; i++) {
                            if (mouse_x >= screen_center_x + 236 && mouse_x < screen_center_x + 266
                            && mouse_y >= screen_center_y - 115 + 44 * i && mouse_y < screen_center_y - 85 + 44 * i) {
                                struct formation_t *m = &legion_formations[get_legion_formation_by_index_rank(i)];
                                if (!m->in_distant_battle) {
                                    m->empire_service = m->empire_service ? 0 : 1;
                                    refresh_current_window = 1;
                                }
                            }
                        }
                    } else if (mouse_left_up) {
                        handle_advisor_change();
                    }
                    break;
                case WINDOW_ADVISOR_IMPERIAL:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_CITY);
                    } else if (mouse_left_down) {
                        if (mouse_x >= screen_center_x - 272 && mouse_x < screen_center_x + 272
                        && mouse_y >= screen_center_y - 120 + 42 * (advisor_emperor_request_index - 1) && mouse_y < screen_center_y - 80 + 42 * (advisor_emperor_request_index - 1)) {
                            for (int i = 0; i < advisor_emperor_request_index; i++) {
                                if (mouse_x >= screen_center_x - 272 && mouse_x < screen_center_x + 272 && mouse_y >= screen_center_y - 120 + 42 * i && mouse_y < screen_center_y - 80 + 42 * i) {
                                    int unfulfilled_requests_index = 0;
                                    for (int j = 0; j < MAX_REQUESTS; j++) {
                                        if (scenario.requests[j].resource && scenario.requests[j].visible && scenario.requests[j].state <= 1) {
                                            if (i == unfulfilled_requests_index
                                            && ((scenario.requests[j].resource == RESOURCE_DENARII && city_data.finance.treasury >= scenario.requests[j].amount)
                                                || (scenario.requests[j].resource < RESOURCE_DENARII && city_data.resource.stored_in_warehouses[scenario.requests[j].resource] >= scenario.requests[j].amount))) {
                                                if (scenario.requests[j].state == REQUEST_STATE_NORMAL) {
                                                    scenario.requests[j].state = REQUEST_STATE_DISPATCHED;
                                                } else {
                                                    scenario.requests[j].state = REQUEST_STATE_DISPATCHED_LATE;
                                                }
                                                random_generate_next();
                                                scenario.requests[j].months_to_comply = (random_data.random1_7bit & 3) + 1;
                                                scenario.requests[j].visible = 0;
                                                if (scenario.requests[j].resource == RESOURCE_DENARII) {
                                                    city_finance_process_misc(scenario.requests[j].amount);
                                                } else if (scenario.requests[j].resource == RESOURCE_TROOPS) {
                                                    // ???
                                                    // remove_from_census(house_population_remove_from_city(scenario.requests[j].amount));
                                                    // city_data.population.lost_troop_request += scenario.requests[j].amount;
                                                    // recalculate_population();
                                                    // building_warehouses_remove_resource(RESOURCE_WEAPONS, scenario.requests[j].amount);
                                                } else {
                                                    building_warehouses_remove_resource(scenario.requests[j].resource, scenario.requests[j].amount);
                                                }
                                                refresh_current_window = 1;
                                                break;
                                            }
                                            unfulfilled_requests_index++;
                                        }
                                    }
                                }
                            }
                        } else if (mouse_x >= screen_center_x - 248 && mouse_x < screen_center_x + 248 && mouse_y >= screen_center_y + 168 && mouse_y < screen_center_y + 188) {
                            change_window(WINDOW_SET_SALARY);
                        } else if (mouse_x >= screen_center_x - 8 && mouse_x < screen_center_x + 232 && mouse_y >= screen_center_y + 112 && mouse_y < screen_center_y + 132) {
                            // calculate gift costs
                            city_data.emperor.gifts[GIFT_MODEST].cost = city_data.emperor.personal_savings / 8 + 20;
                            city_data.emperor.gifts[GIFT_GENEROUS].cost = city_data.emperor.personal_savings / 4 + 50;
                            city_data.emperor.gifts[GIFT_LAVISH].cost = city_data.emperor.personal_savings / 2 + 100;
                            change_window(WINDOW_GIFT_TO_EMPEROR);
                        } else if (mouse_x >= screen_center_x - 8 && mouse_x < screen_center_x + 232 && mouse_y >= screen_center_y + 140 && mouse_y < screen_center_y + 160) {
                            city_data.emperor.donate_amount = 0;
                            change_window(WINDOW_DONATE_TO_CITY);
                        }
                    } else if (mouse_left_up) {
                        handle_advisor_change();
                    }
                    break;
                case WINDOW_ADVISOR_RATINGS:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_CITY);
                    } else if (mouse_left_down) {
                        for (int i = 0; i < 4; i++) {
                            if (mouse_x >= screen_center_x - 244 + 126 * i && mouse_x < screen_center_x - 134 + 126 * i && mouse_y >= screen_center_y + 75 && mouse_y < screen_center_y + 141) {
                                city_data.ratings.selected = i + 1;
                                refresh_current_window = 1;
                                break;
                            }
                        }
                    } else if (mouse_left_up) {
                        handle_advisor_change();
                    }
                    break;
                case WINDOW_ADVISOR_TRADE:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_CITY);
                    } else if (mouse_left_down) {
                        for (int i = 0; i < available.resource_list.size; i++) {
                            if (mouse_x >= screen_center_x - 255 && mouse_x < screen_center_x + 241 && mouse_y >= screen_center_y - 154 + 22 * i && mouse_y < screen_center_y - 132 + 22 * i) {
                                resource_settings_data.resource = i + 1;
                                change_window(WINDOW_RESOURCE_SETTINGS);
                            }
                        }
                        if (mouse_x >= screen_center_x - 288 && mouse_x < screen_center_x - 96 && mouse_y >= screen_center_y + 182 && mouse_y < screen_center_y + 206) {
                            change_window(WINDOW_TRADE_PRICES);
                        } else if (mouse_x >= screen_center_x + 95 && mouse_x < screen_center_x + 287 && mouse_y >= screen_center_y + 182 && mouse_y < screen_center_y + 206) {
                            window_empire_show();
                        }
                    } else if (mouse_left_up) {
                        handle_advisor_change();
                    }
                    break;
                case WINDOW_ADVISOR_POPULATION:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_CITY);
                    } else if (mouse_left_down) {
                        if (mouse_x >= screen_center_x + 188 && mouse_x < screen_center_x + 294 && mouse_y >= screen_center_y - 145 && mouse_y < screen_center_y - 88) {
                            switch_population_graph(0);
                        } else if (mouse_x >= screen_center_x + 188 && mouse_x < screen_center_x + 294 && mouse_y >= screen_center_y - 45 && mouse_y < screen_center_y + 126) {
                            switch_population_graph(1);
                        }
                    } else if (mouse_left_up) {
                        handle_advisor_change();
                    }
                    break;
                case WINDOW_ADVISOR_HEALTH:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_CITY);
                    } else if (mouse_left_up) {
                        handle_advisor_change();
                    }
                    break;
                case WINDOW_ADVISOR_EDUCATION:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_CITY);
                    } else if (mouse_left_up) {
                        handle_advisor_change();
                    }
                    break;
                case WINDOW_ADVISOR_ENTERTAINMENT:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_CITY);
                    } else if (mouse_left_down) {
                        if (!city_data.festival.queued && mouse_x >= screen_center_x - 207 && mouse_x < screen_center_x + 81 && mouse_y >= screen_center_y + 102 && mouse_y < screen_center_y + 122) {
                            festival_costs[FESTIVAL_SMALL] = city_data.population.population / 20 + 10;
                            festival_costs[FESTIVAL_LARGE] = city_data.population.population / 10 + 20;
                            festival_costs[FESTIVAL_GRAND] = city_data.population.population / 5 + 40;
                            change_window(WINDOW_HOLD_FESTIVAL);
                        }
                    } else if (mouse_left_up) {
                        handle_advisor_change();
                    }
                    break;
                case WINDOW_ADVISOR_RELIGION:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_CITY);
                    } else if (mouse_left_up) {
                        handle_advisor_change();
                    }
                    break;
                case WINDOW_ADVISOR_FINANCIAL:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_CITY);
                    } else if (mouse_left_down) {
                        if (mouse_x >= screen_center_x - 160 && mouse_x < screen_center_x - 136 && mouse_y >= screen_center_y - 144 && mouse_y < screen_center_y - 120) {
                            current_window_image_button_pressed = 1;
                            refresh_current_window = 1;
                        } else if (mouse_x >= screen_center_x - 136 && mouse_x < screen_center_x - 112 && mouse_y >= screen_center_y - 144 && mouse_y < screen_center_y - 120) {
                            current_window_image_button_pressed = 2;
                            refresh_current_window = 1;
                        }
                    } else if (mouse_left_up) {
                        current_window_image_button_pressed = 0;
                        refresh_current_window = 1;
                        handle_advisor_change();
                    }
                    break;
                case WINDOW_ADVISOR_CHIEF:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_CITY);
                    } else if (mouse_left_up) {
                        handle_advisor_change();
                    }
                    break;
                case WINDOW_LABOR_PRIORITY:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_ADVISOR_LABOR);
                    } else if (mouse_left_down) {
                        if (mouse_x < screen_center_x - 160 || mouse_x >= screen_center_x + 160 || mouse_y < screen_center_y - 64 || mouse_y >= screen_center_y + 64) { // clicked outside of window
                            change_window(WINDOW_ADVISOR_LABOR);
                        } else {
                            for (int i = 0; i < 9; i++) {
                                if (mouse_x >= screen_center_x - 144 + 32 * i && mouse_x < screen_center_x - 117 + 32 * i && mouse_y >= screen_center_y - 8 && mouse_y < screen_center_y + 19) {
                                    city_labor_set_priority(labor_priority_data.category, i + 1);
                                    change_window(WINDOW_ADVISOR_LABOR);
                                    break;
                                }
                            }
                            if (mouse_x >= screen_center_x - 80 && mouse_x < screen_center_x + 80 && mouse_y >= screen_center_y + 27 && mouse_y < screen_center_y + 49) {
                                city_labor_set_priority(labor_priority_data.category, 0);
                                change_window(WINDOW_ADVISOR_LABOR);
                                break;
                            }
                        }
                    }
                    break;
                case WINDOW_GIFT_TO_EMPEROR:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_ADVISOR_IMPERIAL);
                    } else if (mouse_left_down) {
                        if (mouse_x < screen_center_x - 240 || mouse_x >= screen_center_x + 240 || mouse_y < screen_center_y - 96 || mouse_y >= screen_center_y + 96) {
                            change_window(WINDOW_ADVISOR_IMPERIAL);
                        } else {
                            if (city_data.emperor.gifts[GIFT_MODEST].cost <= city_data.emperor.personal_savings
                            && mouse_x >= screen_center_x - 108 && mouse_x < screen_center_x + 200 && mouse_y >= screen_center_y - 32 && mouse_y < screen_center_y - 16) {
                                send_gift_to_emperor(GIFT_MODEST);
                            } else if (city_data.emperor.gifts[GIFT_GENEROUS].cost <= city_data.emperor.personal_savings
                            && mouse_x >= screen_center_x - 108 && mouse_x < screen_center_x + 200 && mouse_y >= screen_center_y - 8 && mouse_y < screen_center_y + 8) {
                                send_gift_to_emperor(GIFT_GENEROUS);
                            } else if (city_data.emperor.gifts[GIFT_LAVISH].cost <= city_data.emperor.personal_savings
                            && mouse_x >= screen_center_x - 108 && mouse_x < screen_center_x + 200 && mouse_y >= screen_center_y + 16 && mouse_y < screen_center_y + 32) {
                                send_gift_to_emperor(GIFT_LAVISH);
                            }
                        }
                    }
                    break;
                case WINDOW_DONATE_TO_CITY:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_ADVISOR_IMPERIAL);
                    } else if (mouse_left_down) {
                        outer_panel_draw(screen_center_x - 216, screen_center_y - 64, 27, 8);
                        if (mouse_x < screen_center_x - 216 || mouse_x >= screen_center_x + 216 || mouse_y < screen_center_y - 64 || mouse_y >= screen_center_y + 64) {
                            change_window(WINDOW_ADVISOR_IMPERIAL);
                        } else {
                            if (mouse_x >= screen_center_x - 184 && mouse_x < screen_center_x - 120 && mouse_y >= screen_center_y - 8 && mouse_y < screen_center_y + 12) {
                                set_donation_amount(200);
                            } else if (mouse_x >= screen_center_x - 104 && mouse_x < screen_center_x - 40 && mouse_y >= screen_center_y - 8 && mouse_y < screen_center_y + 12) {
                                set_donation_amount(500);
                            } else if (mouse_x >= screen_center_x + 128 && mouse_x < screen_center_x + 152 && mouse_y >= screen_center_y - 10 && mouse_y < screen_center_y + 14) {
                                current_window_image_button_pressed = 1;
                            } else if (mouse_x >= screen_center_x + 152 && mouse_x < screen_center_x + 176 && mouse_y >= screen_center_y - 10 && mouse_y < screen_center_y + 14) {
                                current_window_image_button_pressed = 2;
                            } else if (mouse_x >= screen_center_x - 184 && mouse_x < screen_center_x - 120 && mouse_y >= screen_center_y + 20 && mouse_y < screen_center_y + 40) {
                                set_donation_amount(2000);
                            } else if (mouse_x >= screen_center_x - 104 && mouse_x < screen_center_x - 40 && mouse_y >= screen_center_y + 20 && mouse_y < screen_center_y + 40) {
                                set_donation_amount(5000);
                            } else if (mouse_x >= screen_center_x - 24 && mouse_x < screen_center_x + 40 && mouse_y >= screen_center_y + 20 && mouse_y < screen_center_y + 40) {
                                set_donation_amount(city_data.emperor.personal_savings);
                            } else if (mouse_x >= screen_center_x + 56 && mouse_x < screen_center_x + 176 && mouse_y >= screen_center_y + 20 && mouse_y < screen_center_y + 40) {
                                city_finance_process_donation(city_data.emperor.donate_amount);
                                city_data.emperor.personal_savings -= city_data.emperor.donate_amount;
                                city_finance_calculate_totals();
                                change_window(WINDOW_ADVISOR_IMPERIAL);
                            }
                        }
                    } else if (mouse_left_up) {
                        current_window_image_button_pressed = 0;
                        refresh_current_window = 1;
                    }
                    break;
                case WINDOW_SET_SALARY:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_ADVISOR_IMPERIAL);
                    } else if (mouse_left_down) {
                        if (mouse_x < screen_center_x - 160 || mouse_x >= screen_center_x + 160 || mouse_y < screen_center_y - 160 || mouse_y >= screen_center_y + 160) {
                            change_window(WINDOW_ADVISOR_IMPERIAL);
                        } else {
                            for (int rank = 0; rank < 11; rank++) {
                                if (mouse_x >= screen_center_x - 104 && mouse_x < screen_center_x + 125 && mouse_y >= screen_center_y - 84 + 20 * rank && mouse_y < screen_center_y - 68 + 20 * rank) {
                                    city_emperor_set_salary_rank(rank);
                                    city_data.finance.this_year.expenses.salary = city_data.finance.salary_so_far;
                                    city_ratings_update_favor_explanation();
                                    change_window(WINDOW_ADVISOR_IMPERIAL);
                                }
                            }
                        }
                    }
                    break;
                case WINDOW_RESOURCE_SETTINGS:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_ADVISOR_TRADE);
                    } else if (mouse_left_down) {
                        if (mouse_x < screen_center_x - 272 || mouse_x >= screen_center_x + 272 || mouse_y < screen_center_y - 120 || mouse_y >= screen_center_y + 120) {
                            change_window(WINDOW_ADVISOR_TRADE);
                        } else {
                            if (mouse_x >= screen_center_x - 216 && mouse_x < screen_center_x + 216 && mouse_y >= screen_center_y - 24 && mouse_y < screen_center_y + 6) {
                                city_data.resource.trade_status[resource_settings_data.resource]++;
                                if (city_data.resource.trade_status[resource_settings_data.resource] > TRADE_STATUS_EXPORT) {
                                    city_data.resource.trade_status[resource_settings_data.resource] = TRADE_STATUS_NONE;
                                }
                                if (city_data.resource.trade_status[resource_settings_data.resource] == TRADE_STATUS_IMPORT && !resource_import_trade_route_open(resource_settings_data.resource)) {
                                    city_data.resource.trade_status[resource_settings_data.resource] = TRADE_STATUS_EXPORT;
                                }
                                if (city_data.resource.trade_status[resource_settings_data.resource] == TRADE_STATUS_EXPORT && !resource_export_trade_route_open(resource_settings_data.resource)) {
                                    city_data.resource.trade_status[resource_settings_data.resource] = TRADE_STATUS_NONE;
                                }
                                if (city_data.resource.trade_status[resource_settings_data.resource] == TRADE_STATUS_EXPORT) {
                                    city_data.resource.stockpiled[resource_settings_data.resource] = 0;
                                }
                                refresh_current_window = 1;
                            } else if (mouse_x >= screen_center_x + 28 && mouse_x < screen_center_x + 52 && mouse_y >= screen_center_y - 21 && mouse_y < screen_center_y + 3) {
                                city_data.resource.export_over[resource_settings_data.resource] = calc_bound(city_data.resource.export_over[resource_settings_data.resource] + 1, 0, 100);
                                refresh_current_window = 1;
                            } else if (mouse_x >= screen_center_x + 52 && mouse_x < screen_center_x + 76 && mouse_y >= screen_center_y - 21 && mouse_y < screen_center_y + 3) {
                                city_data.resource.export_over[resource_settings_data.resource] = calc_bound(city_data.resource.export_over[resource_settings_data.resource] - 1, 0, 100);
                                refresh_current_window = 1;
                            } else if (count_data.industry[resource_settings_data.resource].total
                            && mouse_x >= screen_center_x - 216 && mouse_x < screen_center_x + 216 && mouse_y >= screen_center_y + 16 && mouse_y < screen_center_y + 46) {
                                city_data.resource.mothballed[resource_settings_data.resource] = city_data.resource.mothballed[resource_settings_data.resource] ? 0 : 1;
                            } else if (mouse_x >= screen_center_x - 216 && mouse_x < screen_center_x + 216 && mouse_y >= screen_center_y + 56 && mouse_y < screen_center_y + 106) {
                                if (city_data.resource.stockpiled[resource_settings_data.resource]) {
                                    city_data.resource.stockpiled[resource_settings_data.resource] = 0;
                                } else {
                                    city_data.resource.stockpiled[resource_settings_data.resource] = 1;
                                    if (city_data.resource.trade_status[resource_settings_data.resource] == TRADE_STATUS_EXPORT) {
                                        city_data.resource.trade_status[resource_settings_data.resource] = TRADE_STATUS_NONE;
                                    }
                                }
                            }
                        }
                    }
                    break;
                case WINDOW_TRADE_PRICES:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_ADVISOR_TRADE);
                    } else if (mouse_left_down) {
                        if (mouse_x < screen_center_x - 304 || mouse_x >= screen_center_x + 304 || mouse_y < screen_center_y - 80 || mouse_y >= screen_center_y + 80) {
                            change_window(WINDOW_ADVISOR_TRADE);
                        }
                    }
                    break;
                case WINDOW_EMPIRE:
                    if (escape_key_down || mouse_right_up) {
                        if (selected_empire_object) {
                            selected_empire_object = 0;
                            refresh_current_window = 1;
                        } else {
                            change_window(WINDOW_CITY);
                        }
                    } else if (mouse_left_down) {
                        if (mouse_x >= empire_x_min + 16 && mouse_x < empire_x_max - 16 && mouse_y >= empire_y_min + 16 && mouse_y < empire_y_max - 152) { // mouse inside map
                            select_empire_object(mouse_x - empire_x_min - 16 + empire_data.scroll_x, mouse_y - empire_y_min - 16 + empire_data.scroll_y);
                            refresh_current_window = 1;
                        } else if (mouse_x >= empire_x_min + 16 && mouse_x < empire_x_min + 44 && mouse_y >= empire_y_max - 135 && mouse_y < empire_y_max - 107) {
                            current_window_image_button_pressed = 1;
                        } else if (mouse_x >= (empire_x_min + empire_x_max - 440) / 2 && mouse_x < (empire_x_min + empire_x_max - 440) / 2 + 440
                        && mouse_y >= empire_y_max - 70 && mouse_y < empire_y_max - 44) {
                            city_finance_process_construction(selected_empire_object->trade_route_cost);
                            selected_empire_object->trade_route_open = 1;
                            refresh_current_window = 1;
                        }
                    } else if (mouse_left_up) {
                        if (mouse_x >= empire_x_min + 16 && mouse_x <= empire_x_min + 44 && mouse_y >= empire_y_max - 135 && mouse_y <= empire_y_max - 107) {
                            change_window(WINDOW_ADVISOR_TRADE);
                        }
                        current_window_image_button_pressed = 0;
                    }
                    break;
                case WINDOW_HOLD_FESTIVAL:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_ADVISOR_ENTERTAINMENT);
                    } else if (mouse_left_down) {
                        if (mouse_x < screen_center_x - 272 || mouse_x >= screen_center_x + 272 || mouse_y < screen_center_y - 144 || mouse_y >= screen_center_y + 144) { // click outside of window
                            change_window(WINDOW_ADVISOR_ENTERTAINMENT);
                        } else if (mouse_x >= screen_center_x - 222 && mouse_x < screen_center_x + 223 && mouse_y >= screen_center_y - 84 && mouse_y < screen_center_y + 7) { // select god
                            for (int i = 0; i < MAX_GODS; i++) {
                                if (mouse_x >= screen_center_x - 222 + 91 * i && mouse_x < screen_center_x - 141 + 91 * i && mouse_y >= screen_center_y - 84 && mouse_y < screen_center_y + 7) {
                                    city_data.festival.god = i;
                                    break;
                                }
                            }
                        } else if (mouse_x >= screen_center_x - 224 && mouse_x < screen_center_x + 224 && mouse_y >= screen_center_y + 27 && mouse_y < screen_center_y + 95) { // throw festival
                            for (int i = 0; i < 3; i++) {
                                if (mouse_x >= screen_center_x - 224 && mouse_x < screen_center_x + 224 && mouse_y >= screen_center_y + 27 + 34 * i && mouse_y < screen_center_y + 53 + 34 * i) {
                                    if (!city_finance_can_afford(festival_costs[i]) || (i == FESTIVAL_GRAND && city_data.resource.stored_in_warehouses[RESOURCE_WINE] < city_data.population.population / 500 + 1)) {
                                        break;
                                    } else {
                                        city_data.festival.queued = 1;
                                        city_data.festival.size = i;
                                        city_data.festival.months_to_go = city_data.festival.size + 1;
                                        city_finance_process_misc(festival_costs[i]);
                                        if (city_data.festival.size == FESTIVAL_GRAND) {
                                            building_warehouses_remove_resource(RESOURCE_WINE, city_data.population.population / 500 + 1);
                                        }
                                        change_window(WINDOW_ADVISOR_ENTERTAINMENT);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    break;
                case WINDOW_MESSAGE_LIST:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_CITY);
                    } else if (mouse_left_down) {
                        for (int i = 0; i < (message_data.total_messages < MAX_MESSAGES_IN_WINDOW ? message_data.total_messages : MAX_MESSAGES_IN_WINDOW); i++, i++) {
                            if (mouse_x >= map_center_x - 168 && mouse_x < map_center_x + 192 && mouse_y >= map_center_y - 58 + 20 * i && mouse_y < map_center_y - 42 + 20 * i) {
                                int id = message_data.current_message_id + i; // add scroll index here
                                if (id < message_data.total_messages) {
                                    message_data.messages[id].is_read = 1;
                                    window_message_dialog_show_city_message(
                                        city_message_get_text_id(message_data.messages[id].message_type),
                                        message_data.messages[id].year, message_data.messages[id].month, message_data.messages[id].param1, message_data.messages[id].param2,
                                        city_message_get_advisor(message_data.messages[id].message_type),
                                        0);
                                }
                            }
                        }
                    }
                    break;
                case WINDOW_MESSAGE_DIALOG:
                    if (escape_key_down || mouse_right_up) {
                        cleanup_message_dialog();
                        if (game_lost) {
                            change_window(WINDOW_DEFEAT_SUMMARY);
                        } else {
                            change_window(previous_window);
                        }
                    } else if (mouse_left_down) {
                        if (mouse_x >= map_center_x - 304 && mouse_x < map_center_x - 276 && mouse_y >= map_center_y - 184 && mouse_y < map_center_y - 156) {
                            current_window_image_button_pressed = 1;
                        }
                    } else if (mouse_left_up) {
                        if (mouse_x >= map_center_x - 304 && mouse_x < map_center_x - 276 && mouse_y >= map_center_y - 184 && mouse_y < map_center_y - 156) {
                            cleanup_message_dialog();
                            window_advisors_show(player_message.message_advisor);
                        }
                        current_window_image_button_pressed = 0;
                    }
                    break;
                case WINDOW_CONTEXT_INFO:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_CITY);
                    } else if (mouse_left_down) {
                        if (selected_units_list[0]) {
                            switch (selected_units_list[0]->type) {
                                case FIGURE_FORT_STANDARD:
                                case FIGURE_FORT_JAVELIN:
                                case FIGURE_FORT_MOUNTED:
                                case FIGURE_FORT_LEGIONARY:
                                {
                                    struct formation_t *m = &legion_formations[selected_units_list[0]->formation_id];
                                    for (int i = 0; i < 5; i++) {
                                        if (mouse_x >= map_center_x - 212 + 85 * i && mouse_x < map_center_x - 128 + 85 * i && mouse_y >= map_center_y - 2 && mouse_y < map_center_y + 82) {
                                            if (m->in_distant_battle || m->cursed_by_mars) {
                                                break;
                                            }
                                            switch (i) {
                                                case 0:
                                                    if (m->figure_type == FIGURE_FORT_LEGIONARY && m->has_military_training) {
                                                        m->layout = FORMATION_TORTOISE;
                                                        play_speech_file("wavs/cohort1.wav");
                                                        select_legion_formation(&legion_formations[m->id]);
                                                        change_window(WINDOW_CITY);
                                                    } else {
                                                        m->layout = FORMATION_SINGLE_LINE_1;
                                                        play_speech_file("wavs/cohort1.wav");
                                                        select_legion_formation(&legion_formations[m->id]);
                                                        change_window(WINDOW_CITY);
                                                    }
                                                    break;
                                                case 1:
                                                    if (m->figure_type != FIGURE_FORT_LEGIONARY) {
                                                        m->layout = FORMATION_SINGLE_LINE_2;
                                                        play_speech_file("wavs/cohort2.wav");
                                                        select_legion_formation(&legion_formations[m->id]);
                                                        change_window(WINDOW_CITY);
                                                    }
                                                    break;
                                                case 2:
                                                    m->layout = FORMATION_DOUBLE_LINE_1;
                                                    play_speech_file("wavs/cohort3.wav");
                                                    select_legion_formation(&legion_formations[m->id]);
                                                    change_window(WINDOW_CITY);
                                                    break;
                                                case 3:
                                                    m->layout = FORMATION_DOUBLE_LINE_2;
                                                    play_speech_file("wavs/cohort4.wav");
                                                    select_legion_formation(&legion_formations[m->id]);
                                                    change_window(WINDOW_CITY);
                                                    break;
                                                case 4: // mop up
                                                    for (int j = 0; j < m->num_figures; j++) {
                                                        figures[m->figures[j]].action_state = FIGURE_ACTION_SOLDIER_MOPPING_UP;
                                                    }
                                                    play_speech_file("wavs/cohort5.wav");
                                                    select_legion_formation(&legion_formations[m->id]);
                                                    change_window(WINDOW_CITY);
                                                    break;
                                            }
                                        }
                                    }
                                    if (!m->in_distant_battle && !m->is_at_rest) { // return to fort button
                                        if (mouse_x >= map_center_x - 120 && mouse_x < map_center_x + 120 && mouse_y >= map_center_y + 90 && mouse_y < map_center_y + 120) {
                                            return_legion_formation_home(m);
                                            change_window(WINDOW_CITY);
                                        }
                                    }
                                    break;
                                }
                                default:
                                    for (int i = 0; i < selected_units_count; i++) {
                                        if (mouse_x >= map_center_x - 208 + 60 * i && mouse_x < map_center_x - 156 + 60 * i && mouse_y >= map_center_y - 104 && mouse_y < map_center_y - 52) {
                                            selected_unit_index = i;
                                            refresh_current_window = 1;
                                            break;
                                        }
                                    }
                                    break;
                            }
                        } else if (selected_building) {
                            switch (selected_building->type) {
                                case BUILDING_GRANARY:
                                    if (mouse_x >= map_center_x - 8 && mouse_x < map_center_x + 152 && mouse_y >= map_center_y - 57 && mouse_y < map_center_y - 32) {
                                        change_window(WINDOW_GRANARY_ORDERS);
                                    }
                                    break;
                                case BUILDING_WAREHOUSE:
                                    if (mouse_x >= map_center_x + 80 && mouse_x < map_center_x + 240 && mouse_y >= map_center_y - 129 && mouse_y < map_center_y - 104) {
                                        change_window(WINDOW_WAREHOUSE_ORDERS);
                                    }
                                    break;
                            }
                        }
                    }
                    break;
                case WINDOW_GRANARY_ORDERS:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_CONTEXT_INFO);
                    } else if (mouse_left_down) {
                        if (mouse_x >= map_center_x - 52 && mouse_x < map_center_x + 140 && mouse_y >= map_center_y - 91 && mouse_y < map_center_y + 17) {
                            for (int i = 1; i < 5; i++) {
                                if (mouse_x >= map_center_x - 52 && mouse_x < map_center_x + 140 && mouse_y >= map_center_y - 91 + 27 * (i - 1) && mouse_y < map_center_y - 66 + 27 * (i - 1)) {
                                    storages[selected_building->storage_id].storage.resource_state[i]++;
                                    if (storages[selected_building->storage_id].storage.resource_state[i] > BUILDING_STORAGE_STATE_NOT_ACCEPTING) {
                                        storages[selected_building->storage_id].storage.resource_state[i] = BUILDING_STORAGE_STATE_ACCEPTING;
                                    }
                                    refresh_current_window = 1;
                                }
                            }
                        } else if (mouse_x >= map_center_x - 120 && mouse_x < map_center_x + 120 && mouse_y >= map_center_y + 30 && mouse_y < map_center_y + 52) {
                            storages[selected_building->storage_id].storage.empty_all = !storages[selected_building->storage_id].storage.empty_all;
                            refresh_current_window = 1;
                        } else if (mouse_x >= map_center_x + 159 && mouse_x < map_center_x + 179 && mouse_y >= map_center_y + 30 && mouse_y < map_center_y + 50) {
                            for (int i = 1; i < 5; i++) {
                                storages[selected_building->storage_id].storage.resource_state[i] = BUILDING_STORAGE_STATE_NOT_ACCEPTING;
                            }
                            refresh_current_window = 1;
                        }
                    }
                    break;
                case WINDOW_WAREHOUSE_ORDERS:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_CONTEXT_INFO);
                    } else if (mouse_left_down) {
                        if (mouse_x >= map_center_x - 52 && mouse_x < map_center_x + 140 && mouse_y >= map_center_y - 207 && mouse_y < map_center_y + 198) {
                            for (int i = 1; i < RESOURCE_TYPES_MAX; i++) {
                                if (mouse_x >= map_center_x - 52 && mouse_x < map_center_x + 140 && mouse_y >= map_center_y - 207 + 27 * (i - 1) && mouse_y < map_center_y - 182 + 27 * (i - 1)) {
                                    storages[selected_building->storage_id].storage.resource_state[i]++;
                                    if (storages[selected_building->storage_id].storage.resource_state[i] > BUILDING_STORAGE_STATE_NOT_ACCEPTING) {
                                        storages[selected_building->storage_id].storage.resource_state[i] = BUILDING_STORAGE_STATE_ACCEPTING;
                                    }
                                    refresh_current_window = 1;
                                }
                            }
                        } else if (mouse_x >= map_center_x - 120 && mouse_x < map_center_x + 120 && mouse_y >= map_center_y + 208 && mouse_y < map_center_y + 230) {
                            city_data.building.trade_center_building_id = selected_building->id;
                            refresh_current_window = 1;
                        } else if (mouse_x >= map_center_x - 120 && mouse_x < map_center_x + 120 && mouse_y >= map_center_y + 234 && mouse_y < map_center_y + 256) {
                            storages[selected_building->storage_id].storage.empty_all = !storages[selected_building->storage_id].storage.empty_all;
                            refresh_current_window = 1;
                        } else if (mouse_x >= map_center_x + 158 && mouse_x < map_center_x + 178 && mouse_y >= map_center_y + 208 && mouse_y < map_center_y + 228) {
                            for (int i = 1; i < RESOURCE_TYPES_MAX; i++) {
                                storages[selected_building->storage_id].storage.resource_state[i] = BUILDING_STORAGE_STATE_NOT_ACCEPTING;
                            }
                            refresh_current_window = 1;
                        }
                    }
                    break;
                case WINDOW_VICTORY_DIALOG:
                    if (mouse_left_down) {
                        if (mouse_x >= map_center_x - 64 && mouse_x < map_center_x + 64 && mouse_y >= map_center_y - 4 && mouse_y < map_center_y + 21) {
                            update_music(1);
                            change_window(WINDOW_CITY);
                        } else if (mouse_x >= map_center_x - 64 && mouse_x < map_center_x + 64 && mouse_y >= map_center_y + 26 && mouse_y < map_center_y + 51) {
                            settings[SETTINGS_VICTORY_VIDEO].config_value = settings[SETTINGS_VICTORY_VIDEO].config_value ? 0 : 1;
                            if (settings[SETTINGS_VICTORY_VIDEO].config_value) {
                                window_victory_video_show("smk/victory_balcony.smk", 400, 292);
                            } else {
                                window_victory_video_show("smk/victory_senate.smk", 400, 292);
                            }
                        }
                    }
                    break;
                case WINDOW_VICTORY_VIDEO:
                    if (enter_pressed || escape_key_down || mouse_right_up || mouse_left_down) {
                        video_stop();
                        change_window(WINDOW_VICTORY_SUMMARY);
                    }
                    break;
                case WINDOW_VICTORY_SUMMARY:
                    if (enter_pressed || escape_key_down || mouse_right_up) {
                        show_main_menu_window(1);
                    }
                    break;
                case WINDOW_DEFEAT_SUMMARY:
                    if (enter_pressed || escape_key_down || mouse_right_up) {
                        stop_sound_channel(SOUND_CHANNEL_SPEECH);
                        show_main_menu_window(1);
                    }
                    break;
                case WINDOW_EDITOR_NOT_FOUND:
                    if (escape_key_down || mouse_right_up) {
                        show_main_menu_window(0);
                    }
                    break;
                case WINDOW_EDITOR_MAP:
                    if (escape_key_down || mouse_right_up) {
                        if (tool_data.type) {
                            editor_tool_deactivate();
                        } else if (editor_build_menu_selected)
                            editor_build_menu_selected = 0;
                        else {
                            change_window(WINDOW_EXIT_TO_MAIN_MENU);
                        }
                    } else if (mouse_left_down) {
                        switch (editor_build_menu_selected) {
                            case MENU_SHRUB:
                                if (mouse_x >= sidebar_x_offset - 165 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 291 && mouse_y < 383) {
                                    for (int i = 0; i < 4; i++) {
                                        if (mouse_x >= sidebar_x_offset - 165 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 291 + 24 * i && mouse_y < 311 + 24 * i) {
                                            tool_data.type = TOOL_SMALL_SHRUB + i;
                                            editor_build_menu_selected = 0;
                                            refresh_current_window = 1;
                                            break;
                                        }
                                    }
                                } else {
                                    editor_build_menu_selected = 0;
                                }
                                break;
                            case MENU_ELEVATION:
                                if (mouse_x >= sidebar_x_offset - 165 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 291 && mouse_y < 359) {
                                    for (int i = 0; i < 3; i++) {
                                        if (mouse_x >= sidebar_x_offset - 165 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 291 + 24 * i && mouse_y < 311 + 24 * i) {
                                            tool_data.type = TOOL_RAISE_LAND + i;
                                            editor_build_menu_selected = 0;
                                            refresh_current_window = 1;
                                            break;
                                        }
                                    }
                                } else {
                                    editor_build_menu_selected = 0;
                                }
                                break;
                            case MENU_ROCK:
                                if (mouse_x >= sidebar_x_offset - 165 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 291 && mouse_y < 359) {
                                    for (int i = 0; i < 3; i++) {
                                        if (mouse_x >= sidebar_x_offset - 165 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 291 + 24 * i && mouse_y < 311 + 24 * i) {
                                            tool_data.type = TOOL_SMALL_ROCK + i;
                                            editor_build_menu_selected = 0;
                                            refresh_current_window = 1;
                                            break;
                                        }
                                    }
                                } else {
                                    editor_build_menu_selected = 0;
                                }
                                break;
                            case MENU_BRUSH_SIZE:
                                if (mouse_x >= sidebar_x_offset - 165 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 291 && mouse_y < 407) {
                                    for (int i = 0; i < 5; i++) {
                                        if (mouse_x >= sidebar_x_offset - 165 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 291 + 24 * i && mouse_y < 311 + 24 * i) {
                                            tool_data.brush_size = i;
                                            editor_build_menu_selected = 0;
                                            refresh_current_window = 1;
                                            break;
                                        }
                                    }
                                } else {
                                    editor_build_menu_selected = 0;
                                }
                                break;
                            case MENU_EARTHQUAKE_POINTS:
                                if (mouse_x >= sidebar_x_offset - 165 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 291 && mouse_y < 479) {
                                    for (int i = 0; i < 8; i++) {
                                        if (mouse_x >= sidebar_x_offset - 165 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 291 + 24 * i && mouse_y < 311 + 24 * i) {
                                            tool_data.type = TOOL_EARTHQUAKE_POINT;
                                            tool_data.id = i;
                                            editor_build_menu_selected = 0;
                                            refresh_current_window = 1;
                                            break;
                                        }
                                    }
                                } else {
                                    editor_build_menu_selected = 0;
                                }
                                break;
                            case MENU_INVASION_POINTS:
                                if (mouse_x >= sidebar_x_offset - 165 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 291 && mouse_y < 479) {
                                    for (int i = 0; i < 8; i++) {
                                        if (mouse_x >= sidebar_x_offset - 165 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 291 + 24 * i && mouse_y < 311 + 24 * i) {
                                            tool_data.type = TOOL_INVASION_POINT;
                                            tool_data.id = i;
                                            editor_build_menu_selected = 0;
                                            refresh_current_window = 1;
                                            break;
                                        }
                                    }
                                } else {
                                    editor_build_menu_selected = 0;
                                }
                                break;
                            case MENU_PEOPLE_POINTS:
                                if (mouse_x >= sidebar_x_offset - 165 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 291 && mouse_y < 335) {
                                    for (int i = 0; i < 2; i++) {
                                        if (mouse_x >= sidebar_x_offset - 165 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 291 + 24 * i && mouse_y < 311 + 24 * i) {
                                            if (i) {
                                                tool_data.type = TOOL_EXIT_POINT;
                                            } else {
                                                tool_data.type = TOOL_ENTRY_POINT;
                                            }
                                            editor_build_menu_selected = 0;
                                            refresh_current_window = 1;
                                            break;
                                        }
                                    }
                                } else {
                                    editor_build_menu_selected = 0;
                                }
                                break;
                            case MENU_RIVER_POINTS:
                                if (mouse_x >= sidebar_x_offset - 165 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 291 && mouse_y < 335) {
                                    for (int i = 0; i < 2; i++) {
                                        if (mouse_x >= sidebar_x_offset - 165 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 291 + 24 * i && mouse_y < 311 + 24 * i) {
                                            if (i) {
                                                tool_data.type = TOOL_RIVER_EXIT_POINT;
                                            } else {
                                                tool_data.type = TOOL_RIVER_ENTRY_POINT;
                                            }
                                            editor_build_menu_selected = 0;
                                            refresh_current_window = 1;
                                            break;
                                        }
                                    }
                                } else {
                                    editor_build_menu_selected = 0;
                                }
                                break;
                            case MENU_NATIVE_BUILDINGS:
                                if (mouse_x >= sidebar_x_offset - 165 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 291 && mouse_y < 383) {
                                    for (int i = 0; i < 4; i++) {
                                        if (mouse_x >= sidebar_x_offset - 165 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 291 + 24 * i && mouse_y < 311 + 24 * i) {
                                            switch (i) {
                                                case 0:
                                                    tool_data.type = TOOL_NATIVE_HUT;
                                                    break;
                                                case 1:
                                                    tool_data.type = TOOL_NATIVE_FIELD;
                                                    break;
                                                case 2:
                                                    tool_data.type = TOOL_NATIVE_CENTER;
                                                    break;

                                                case 3:
                                                    tool_data.type = TOOL_HOUSE_VACANT_LOT;
                                                    break;
                                            }
                                            editor_build_menu_selected = 0;
                                            refresh_current_window = 1;
                                            break;
                                        }
                                    }
                                } else {
                                    editor_build_menu_selected = 0;
                                }
                                break;
                            case MENU_ANIMAL_POINTS:
                                if (mouse_x >= sidebar_x_offset - 165 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 291 && mouse_y < 671) {
                                    for (int i = 0; i < 16; i++) {
                                        if (mouse_x >= sidebar_x_offset - 165 && mouse_x < sidebar_x_offset - 5 && mouse_y >= 291 + 24 * i && mouse_y < 311 + 24 * i) {
                                            if (i < 8) {
                                                tool_data.type = TOOL_FISHING_POINT;
                                                tool_data.id = i;
                                            } else {
                                                tool_data.type = TOOL_HERD_POINT;
                                                tool_data.id = i - 8;
                                            }
                                            editor_build_menu_selected = 0;
                                            refresh_current_window = 1;
                                            break;
                                        }
                                    }
                                } else {
                                    editor_build_menu_selected = 0;
                                }
                                break;
                            default:
                                if (mouse_x && mouse_x < sidebar_x_offset && mouse_y >= 24 && mouse_y < map_y_max) { // clicked on map
                                    if (tool_data.type && current_tile.grid_offset) {
                                        tool_data.build_in_progress = 1;
                                        tool_data.start_elevation = terrain_elevation.items[current_tile.grid_offset];
                                        tool_data.start_tile = current_tile;
                                        if (tool_data.type == TOOL_ROAD) {
                                            game_undo_start_build(BUILDING_ROAD);
                                            map_routing_update_land();
                                        }
                                    }
                                } else if (mouse_x >= 10 && mouse_x < 38 && mouse_y < 30) {
                                    top_menu_data.open_sub_menu = TOP_MENU_FILE;
                                    change_window(WINDOW_EDITOR_TOP_MENU);
                                } else if (mouse_x >= 78 && mouse_x < 139 && mouse_y < 30) {
                                    top_menu_data.open_sub_menu = TOP_MENU_OPTIONS;
                                    change_window(WINDOW_EDITOR_TOP_MENU);
                                } else if (mouse_x >= 179 && mouse_x < 230 && mouse_y < 30) {
                                    top_menu_data.open_sub_menu = TOP_MENU_RESETS;
                                    change_window(WINDOW_EDITOR_TOP_MENU);
                                } else if (mouse_x >= sidebar_x_offset + 7 && mouse_x < sidebar_x_offset + 78 && mouse_y >= 147 && mouse_y < 170) { // attributes button
                                    current_window_image_button_pressed = 1;
                                } else if (mouse_x >= sidebar_x_offset + 84 && mouse_x < sidebar_x_offset + 155 && mouse_y >= 147 && mouse_y < 170) { // empire button
                                    current_window_image_button_pressed = 2;
                                } else if (mouse_x >= sidebar_x_offset + 13 && mouse_x < sidebar_x_offset + 152 && mouse_y >= 291 && mouse_y < 461) { // build menu buttons
                                    for (int i = 0; i < 5; i++) {
                                        for (int j = 0; j < 3; j++) {
                                            if (mouse_x >= sidebar_x_offset + 13 + 50 * j && mouse_x < sidebar_x_offset + 52 + 50 * j && mouse_y >= 291 + 36 * i && mouse_y < 317 + 36 * i) {
                                                current_window_image_button_pressed = 3 * i + j + 3;
                                                break;
                                            }
                                        }
                                        if (current_window_image_button_pressed) {
                                            break;
                                        }
                                    }
                                }
                                break;
                        }
                    } else if (mouse_left_up) {
                        switch (current_window_image_button_pressed) {
                            case 1:
                                if (mouse_x >= sidebar_x_offset + 7 && mouse_x < sidebar_x_offset + 78 && mouse_y >= 147 && mouse_y < 170) {
                                    change_window(WINDOW_EDITOR_ATTRIBUTES);
                                }
                                break;
                            case 2:
                                if (mouse_x >= sidebar_x_offset + 84 && mouse_x < sidebar_x_offset + 155 && mouse_y >= 147 && mouse_y < 170) {
                                    change_window(WINDOW_EDITOR_EMPIRE);
                                }
                                break;
                            case 3:
                                if (mouse_x >= sidebar_x_offset + 13 && mouse_x < sidebar_x_offset + 52 && mouse_y >= 291 && mouse_y < 317) {
                                    tool_data.type = TOOL_GRASS;
                                    refresh_current_window = 1;
                                }
                                break;
                            case 4:
                                if (mouse_x >= sidebar_x_offset + 63 && mouse_x < sidebar_x_offset + 102 && mouse_y >= 291 && mouse_y < 317) {
                                    editor_build_menu_selected = MENU_SHRUB;
                                }
                                break;
                            case 5:
                                if (mouse_x >= sidebar_x_offset + 113 && mouse_x < sidebar_x_offset + 152 && mouse_y >= 291 && mouse_y < 317) {
                                    tool_data.type = TOOL_WATER;
                                    refresh_current_window = 1;
                                }
                                break;
                            case 6:
                                if (mouse_x >= sidebar_x_offset + 13 && mouse_x < sidebar_x_offset + 52 && mouse_y >= 327 && mouse_y < 353) {
                                    editor_build_menu_selected = MENU_ELEVATION;
                                }
                                break;
                            case 7:
                                if (mouse_x >= sidebar_x_offset + 63 && mouse_x < sidebar_x_offset + 102 && mouse_y >= 327 && mouse_y < 353) {
                                    tool_data.type = TOOL_TREES;
                                    refresh_current_window = 1;
                                }
                                break;
                            case 8:
                                if (mouse_x >= sidebar_x_offset + 113 && mouse_x < sidebar_x_offset + 152 && mouse_y >= 327 && mouse_y < 353) {
                                    editor_build_menu_selected = MENU_ROCK;
                                }
                                break;
                            case 9:
                                if (mouse_x >= sidebar_x_offset + 13 && mouse_x < sidebar_x_offset + 52 && mouse_y >= 363 && mouse_y < 389) {
                                    tool_data.type = TOOL_MEADOW;
                                    refresh_current_window = 1;
                                }
                                break;
                            case 10:
                                if (mouse_x >= sidebar_x_offset + 63 && mouse_x < sidebar_x_offset + 102 && mouse_y >= 363 && mouse_y < 389) {
                                    tool_data.type = TOOL_ROAD;
                                    refresh_current_window = 1;
                                }
                                break;
                            case 11:
                                if (mouse_x >= sidebar_x_offset + 113 && mouse_x < sidebar_x_offset + 152 && mouse_y >= 363 && mouse_y < 389) {
                                    editor_build_menu_selected = MENU_BRUSH_SIZE;
                                }
                                break;
                            case 12:
                                if (mouse_x >= sidebar_x_offset + 13 && mouse_x < sidebar_x_offset + 52 && mouse_y >= 399 && mouse_y < 425) {
                                    editor_build_menu_selected = MENU_EARTHQUAKE_POINTS;
                                }
                                break;
                            case 13:
                                if (mouse_x >= sidebar_x_offset + 63 && mouse_x < sidebar_x_offset + 102 && mouse_y >= 399 && mouse_y < 425) {
                                    editor_build_menu_selected = MENU_INVASION_POINTS;
                                }
                                break;
                            case 14:
                                if (mouse_x >= sidebar_x_offset + 113 && mouse_x < sidebar_x_offset + 152 && mouse_y >= 399 && mouse_y < 425) {
                                    editor_build_menu_selected = MENU_PEOPLE_POINTS;
                                }
                                break;
                            case 15:
                                if (mouse_x >= sidebar_x_offset + 13 && mouse_x < sidebar_x_offset + 52 && mouse_y >= 435 && mouse_y < 461) {
                                    editor_build_menu_selected = MENU_RIVER_POINTS;
                                }
                                break;
                            case 16:
                                if (mouse_x >= sidebar_x_offset + 63 && mouse_x < sidebar_x_offset + 102 && mouse_y >= 435 && mouse_y < 461) {
                                    editor_build_menu_selected = MENU_NATIVE_BUILDINGS;
                                }
                                break;
                            case 17:
                                if (mouse_x >= sidebar_x_offset + 113 && mouse_x < sidebar_x_offset + 152 && mouse_y >= 435 && mouse_y < 461) {
                                    editor_build_menu_selected = MENU_ANIMAL_POINTS;
                                }
                                break;
                        }
                        current_window_image_button_pressed = 0;
                        if (tool_data.build_in_progress) {
                            end_editor_tool_use();
                        }
                    } else if (mouse_middle_down) {
                        start_mouse_scroll_drag();
                    } else if (mouse_middle_up) {
                        end_mouse_scroll_drag();
                    }
                    break;
                case WINDOW_EDITOR_TOP_MENU:
                    if (escape_key_down || mouse_right_up) {
                        hide_editor_top_menu();
                        change_window(WINDOW_EDITOR_MAP);
                    } else if (mouse_left_down) {
                        if (dropdown_list_selected) {
                            for (int i = 0; i < 6; i++) {
                                if (mouse_x >= 128 && mouse_x < 255 && mouse_y >= 40 + 18 * i && mouse_y < 58 + 18 * i) {
                                    hide_editor_top_menu();
                                    game_file_editor_create_scenario(i);
                                    change_window(WINDOW_EDITOR_MAP);
                                }
                            }
                        }
                        if (((top_menu_data.open_sub_menu == TOP_MENU_FILE && (mouse_x < 0 || mouse_x >= 112 || mouse_y < 0 || mouse_y >= 104))
                            || (top_menu_data.open_sub_menu == TOP_MENU_OPTIONS && (mouse_x < 68 || mouse_x >= 148 || mouse_y < 0 || mouse_y >= 88))
                            || (top_menu_data.open_sub_menu == TOP_MENU_RESETS && (mouse_x < 169 || mouse_x >= 297 || mouse_y < 0 || mouse_y >= 104)))) {
                            hide_editor_top_menu();
                            change_window(WINDOW_EDITOR_MAP);
                        } else {
                            switch (top_menu_data.open_sub_menu) {
                                case 1:
                                    for (int i = 0; i < 4; i++) {
                                        if (mouse_x >= 10 && mouse_x < 105 && mouse_y >= 28 + 18 * i && mouse_y < 46 + 18 * i) {
                                            switch (i) {
                                                case 0:
                                                    dropdown_list_selected = 1;
                                                    refresh_current_window = 1;
                                                    break;
                                                case 1:
                                                    hide_editor_top_menu();
                                                    show_file_dialog_window(FILE_TYPE_SCENARIO, FILE_DIALOG_LOAD);
                                                    break;
                                                case 2:
                                                    hide_editor_top_menu();
                                                    show_file_dialog_window(FILE_TYPE_SCENARIO, FILE_DIALOG_SAVE);
                                                    break;
                                                case 3:
                                                    hide_editor_top_menu();
                                                    change_window(WINDOW_EXIT_TO_MAIN_MENU);
                                                    break;
                                            }
                                        }
                                    }
                                    break;
                                case 2:
                                    for (int i = 0; i < 3; i++) {
                                        if (mouse_x >= 78 && mouse_x < 142 && mouse_y >= 28 + 18 * i && mouse_y < 46 + 18 * i) {
                                            switch (i) {
                                                case 0:
                                                    top_menu_data.open_sub_menu = TOP_MENU_NONE;
                                                    change_window(WINDOW_DISPLAY_OPTIONS);
                                                    break;
                                                case 1:
                                                    top_menu_data.open_sub_menu = TOP_MENU_NONE;
                                                    change_window(WINDOW_SOUND_OPTIONS);
                                                    break;
                                                case 2:
                                                    top_menu_data.open_sub_menu = TOP_MENU_NONE;
                                                    change_window(WINDOW_SPEED_OPTIONS);
                                                    break;
                                            }
                                        }
                                    }
                                    break;
                                case 3:
                                    for (int i = 0; i < 4; i++) {
                                        if (mouse_x >= 179 && mouse_x < 290 && mouse_y >= 28 + 18 * i && mouse_y < 46 + 18 * i) {
                                            switch (i) {
                                                case 0:
                                                    for (int j = 0; j < MAX_HERD_POINTS; j++) {
                                                        scenario.herd_points[j].x = -1;
                                                        scenario.herd_points[j].y = -1;
                                                    }
                                                    top_menu_data.open_sub_menu = TOP_MENU_NONE;
                                                    change_window(WINDOW_EDITOR_MAP);
                                                    break;
                                                case 1:
                                                    for (int j = 0; j < MAX_FISH_POINTS; j++) {
                                                        scenario.fishing_points[j].x = -1;
                                                        scenario.fishing_points[j].y = -1;
                                                    }
                                                    top_menu_data.open_sub_menu = TOP_MENU_NONE;
                                                    change_window(WINDOW_EDITOR_MAP);
                                                    break;
                                                case 2:
                                                    for (int j = 0; j < MAX_INVASION_POINTS; j++) {
                                                        scenario.invasion_points[j].x = -1;
                                                        scenario.invasion_points[j].y = -1;
                                                    }
                                                    top_menu_data.open_sub_menu = TOP_MENU_NONE;
                                                    change_window(WINDOW_EDITOR_MAP);
                                                    break;
                                                case 3:
                                                    for (int j = 0; j < MAX_EARTHQUAKE_POINTS; j++) {
                                                        scenario.earthquake_points[j].x = -1;
                                                        scenario.earthquake_points[j].y = -1;
                                                    }
                                                    top_menu_data.open_sub_menu = TOP_MENU_NONE;
                                                    change_window(WINDOW_EDITOR_MAP);
                                                    break;
                                            }
                                        }
                                    }
                                    break;
                            }
                        }
                    }
                    break;
                case WINDOW_EDITOR_ATTRIBUTES:
                    if (text_field_active && (enter_pressed || escape_key_down || mouse_right_up)) {
                        stop_text_input();
                        string_copy(input_text_string, scenario.brief_description, MAX_BRIEF_DESCRIPTION_LENGTH);
                    } else if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_EDITOR_MAP);
                    } else if (mouse_left_down) {
                        if (mouse_x >= map_center_x - 132 && mouse_x < map_center_x + 188 && mouse_y >= map_center_y - 180 && mouse_y < map_center_y - 148) {
                            handle_input_text_mouse_click(1, map_center_x - 132, map_center_y - 180, MAX_BRIEF_DESCRIPTION_LENGTH, FONT_NORMAL_WHITE, scenario.brief_description, 1, 500);
                        } else {
                            if (input_text_string[0]) {
                                string_copy(input_text_string, scenario.brief_description, MAX_BRIEF_DESCRIPTION_LENGTH);
                            }
                            stop_text_input();
                            for (int i = 0; i < 2; i++) {
                                if (mouse_x >= map_center_x - 200 + 24 * i && mouse_x < map_center_x - 176 + 24 * i
                                && mouse_y >= map_center_y - 176 && mouse_y < map_center_y - 152) {
                                    current_window_image_button_pressed = i + 1;
                                    if (i) {
                                        scenario.brief_description_image_id++;
                                        if (scenario.brief_description_image_id > 7968) {
                                            scenario.brief_description_image_id = 7953;
                                        }
                                    } else {
                                        scenario.brief_description_image_id--;
                                        if (scenario.brief_description_image_id < 7953) {
                                            scenario.brief_description_image_id = 7968;
                                        }
                                    }
                                    refresh_current_window = 1;
                                    break;
                                }
                            }
                            for (int i = 0; i < 4; i++) {
                                if (mouse_x >= map_center_x - 200 && mouse_x < map_center_x - 15
                                && mouse_y >= map_center_y + 20 + 40 * i && mouse_y < map_center_y + 50 + 40 * i) {
                                    switch (i) {
                                        case 0:
                                            scenario.climate++;
                                            if (scenario.climate > 2) {
                                                scenario.climate = 0;
                                            }
                                            load_main_graphics(scenario.climate, 1);
                                            minimap_data.refresh_requested = 1;
                                            refresh_current_window = 1;
                                            break;
                                        case 1:
                                            change_window(WINDOW_EDITOR_BRIEFING);
                                            break;
                                        case 2:
                                            change_window(WINDOW_EDITOR_STARTING_CONDITIONS);
                                            break;
                                        case 3:
                                            change_window(WINDOW_EDITOR_WIN_CRITERIA);
                                            break;
                                    }
                                }
                            }
                            for (int i = 0; i < 8; i++) {
                                if (mouse_x >= map_center_x - 8 && mouse_x < map_center_x + 187
                                && mouse_y >= map_center_y - 140 + 40 * i && mouse_y < map_center_y - 110 + 40 * i) {
                                    switch (i) {
                                        case 0:
                                            change_window(WINDOW_EDITOR_ALLOWED_BUILDINGS);
                                            break;
                                        case 1:
                                            change_window(WINDOW_EDITOR_SPECIAL_EVENTS);
                                            break;
                                        case 2:
                                            change_window(WINDOW_EDITOR_REQUESTS);
                                            break;
                                        case 3:
                                            change_window(WINDOW_EDITOR_CUSTOM_MESSAGES);
                                            break;
                                        case 4:
                                            change_window(WINDOW_EDITOR_EARTHQUAKES);
                                            break;
                                        case 5:
                                            change_window(WINDOW_EDITOR_INVASIONS);
                                            break;
                                        case 6:
                                            change_window(WINDOW_EDITOR_PRICE_CHANGES);
                                            break;
                                        case 7:
                                            change_window(WINDOW_EDITOR_DEMAND_CHANGES);
                                            break;
                                    }
                                }
                            }
                        }
                    } else if (mouse_left_up) {
                        current_window_image_button_pressed = 0;
                    }
                    break;
                case WINDOW_EDITOR_BRIEFING:
                    if (text_field_active && (escape_key_down || mouse_right_up)) {
                        stop_text_input();
                        string_copy(input_text_string, scenario.briefing, input_text_max_length);
                    } else if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_EDITOR_ATTRIBUTES);
                    } else if (mouse_left_down) {
                        if (mouse_x >= map_center_x - 480 && mouse_x < map_center_x + 480 && mouse_y >= map_center_y - 296 && mouse_y < map_center_y + 296) {
                            handle_input_text_mouse_click(1, map_center_x - 480, map_center_y - 296, MAX_BRIEFING_LENGTH, FONT_NORMAL_WHITE, scenario.briefing, MAX_BRIEFING_LINES, BRIEFING_MAX_LINE_WIDTH);
                        } else if (mouse_x >= map_center_x - 88 && mouse_x < map_center_x + 88 && mouse_y >= map_center_y + 295 && mouse_y < map_center_y + 320) {
                            memset(text_lines, 0, sizeof(text_lines));
                            move_input_text_cursor_to_beginning();
                            text_num_completed_lines = 0;
                            text_lines[0].line_y = input_text_y;
                        }
                    }
                    break;
                case WINDOW_EDITOR_STARTING_CONDITIONS:
                    if (enter_pressed) {
                        if (text_field_active) {
                            save_starting_conditions_numeric_field();
                        }
                    } else if (escape_key_down || mouse_right_up) {
                        if (text_field_active) {
                            save_starting_conditions_numeric_field();
                        } else if (dropdown_list_selected) {
                            hide_dropdown_list();
                        } else {
                            change_window(WINDOW_EDITOR_ATTRIBUTES);
                        }
                    } else if (mouse_left_down) {
                        if (text_field_active
                        && (mouse_x < map_center_x - 8 || mouse_x >= map_center_x + 200 || mouse_y < map_center_y - 136 + 40 * text_field_active || mouse_y >= map_center_y - 106 + 40 * text_field_active)) {
                            save_starting_conditions_numeric_field();
                        } else if (dropdown_list_selected) {
                            int item_selected = 0;
                            for (int i = 0; i < 11; i++) {
                                if (mouse_x >= map_center_x + 200 && mouse_x < map_center_x + 314
                                && mouse_y >= map_center_y - 208 + 18 * i && mouse_y < map_center_y - 190 + 18 * i) {
                                    scenario.player_rank = i;
                                    hide_dropdown_list();
                                    item_selected = 1;
                                    break;
                                }
                            }
                            if (!item_selected) {
                                hide_dropdown_list();
                            }
                        } else {
                            for (int i = 0; i < 8; i++) {
                                if (mouse_x >= map_center_x - 8 && mouse_x < map_center_x + 200
                                && mouse_y >= map_center_y - 136 + 40 * i && mouse_y < map_center_y - 106 + 40 * i) {
                                    switch (i) {
                                        case 0:
                                            dropdown_list_selected = 1;
                                            refresh_current_window = 1;
                                            break;
                                        case 1:
                                        {
                                            activate_numeric_input_text_field(scenario.start_year, 1);
                                            handle_input_text_mouse_click(1, map_center_x - 8, map_center_y - 96, 5, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                        }
                                        case 2:
                                            activate_numeric_input_text_field(scenario.initial_favor, 0);
                                            handle_input_text_mouse_click(2, map_center_x - 8, map_center_y - 56, 4, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                        case 3:
                                            activate_numeric_input_text_field(scenario.initial_funds, 0);
                                            handle_input_text_mouse_click(3, map_center_x - 8, map_center_y - 16, 7, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                        case 4:
                                            activate_numeric_input_text_field(scenario.rescue_loan, 1);
                                            handle_input_text_mouse_click(4, map_center_x - 8, map_center_y + 24, 6, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                        case 5:
                                            activate_numeric_input_text_field(scenario.initial_personal_savings, 1);
                                            handle_input_text_mouse_click(5, map_center_x - 8, map_center_y + 64, 6, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                        case 6:
                                            scenario.rome_supplies_wheat = !scenario.rome_supplies_wheat;
                                            refresh_current_window = 1;
                                            break;
                                        case 7:
                                            scenario.flotsam_enabled = !scenario.flotsam_enabled;
                                            refresh_current_window = 1;
                                            break;
                                    }
                                }
                            }
                        }
                    }
                    break;
                case WINDOW_EDITOR_WIN_CRITERIA:
                    if (enter_pressed) {
                        if (text_field_active) {
                            save_win_criteria_numeric_field();
                        }
                    } else if (escape_key_down || mouse_right_up) {
                        if (text_field_active) {
                            save_win_criteria_numeric_field();
                        } else {
                            change_window(WINDOW_EDITOR_ATTRIBUTES);
                        }
                    } else if (mouse_left_down) {
                        if (text_field_active
                        && (mouse_x < map_center_x + 10 || mouse_x >= map_center_x + 170
                            || mouse_y < map_center_y - 122 + 40 * (text_field_active - 1) || mouse_y >= map_center_y - 92 + 40 * (text_field_active - 1))) {
                            save_win_criteria_numeric_field();
                        } else {
                            for (int i = 0; i < 7; i++) {
                                if (mouse_x >= map_center_x + 10 && mouse_x < map_center_x + 170 && mouse_y >= map_center_y - 122 + 40 * i && mouse_y < map_center_y - 92 + 40 * i) {
                                    switch (i) {
                                        case 0:
                                            activate_numeric_input_text_field(scenario.population_win_criteria, 0);
                                            handle_input_text_mouse_click(1, map_center_x + 10, map_center_y - 122, 7, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                        case 1:
                                            activate_numeric_input_text_field(scenario.culture_win_criteria, 0);
                                            handle_input_text_mouse_click(2, map_center_x + 10, map_center_y - 82, 4, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                        case 2:
                                            activate_numeric_input_text_field(scenario.prosperity_win_criteria, 0);
                                            handle_input_text_mouse_click(3, map_center_x + 10, map_center_y - 42, 4, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                        case 3:
                                            activate_numeric_input_text_field(scenario.peace_win_criteria, 0);
                                            handle_input_text_mouse_click(4, map_center_x + 10, map_center_y - 2, 4, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                        case 4:
                                            activate_numeric_input_text_field(scenario.favor_win_criteria, 0);
                                            handle_input_text_mouse_click(5, map_center_x + 10, map_center_y + 38, 4, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                        case 5:
                                            activate_numeric_input_text_field(scenario.time_limit_win_criteria, 0);
                                            handle_input_text_mouse_click(6, map_center_x + 10, map_center_y + 78, 5, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                        case 6:
                                            activate_numeric_input_text_field(scenario.survival_time_win_criteria, 0);
                                            handle_input_text_mouse_click(7, map_center_x + 10, map_center_y + 118, 5, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                    }
                                }
                            }
                        }
                    }
                    break;
                case WINDOW_EDITOR_ALLOWED_BUILDINGS:
                    if (escape_key_down || mouse_right_up) {
                        set_resources_sell_our_city();
                        change_window(WINDOW_EDITOR_ATTRIBUTES);
                    } else if (mouse_left_down) {
                        for (int i = 0; i < MAX_ALLOWED_BUILDINGS; i++) {
                            int building_index = i + 1 > 2 ? i + 1 + MAX_HOUSE_TYPES : i + 1;
                            if ((i < 20 && mouse_x >= map_center_x - 392 && mouse_x < map_center_x - 202 && mouse_y >= map_center_y - 188 + 20 * i && mouse_y < map_center_y - 168 + 20 * i)
                            || (i < 40 && mouse_x >= map_center_x - 194 && mouse_x < map_center_x - 4 && mouse_y >= map_center_y - 188 + 20 * (i - 20) && mouse_y < map_center_y - 168 + 20 * (i - 20))
                            || (i < 60 && mouse_x >= map_center_x + 4 && mouse_x < map_center_x + 194 && mouse_y >= map_center_y - 188 + 20 * (i - 40) && mouse_y < map_center_y - 168 + 20 * (i - 40))
                            || (mouse_x >= map_center_x + 202 && mouse_x < map_center_x + 392 && mouse_y >= map_center_y - 188 + 20 * (i - 60) && mouse_y < map_center_y - 168 + 20 * (i - 60))) {
                                scenario.allowed_buildings[building_index] = !scenario.allowed_buildings[building_index];
                                refresh_current_window = 1;
                                break;
                            }
                        }
                    }
                    break;
                case WINDOW_EDITOR_SPECIAL_EVENTS:
                    if (enter_pressed) {
                        if (text_field_active) {
                            save_special_events_numeric_field();
                        }
                    } else if (escape_key_down || mouse_right_up) {
                        if (text_field_active) {
                            save_special_events_numeric_field();
                        } else if (dropdown_list_selected) {
                            hide_dropdown_list();
                        } else {
                            change_window(WINDOW_EDITOR_ATTRIBUTES);
                        }
                    } else if (mouse_left_down) {
                        if (text_field_active
                        && (mouse_x < map_center_x + 76 || mouse_x >= map_center_x + 236 || mouse_y < map_center_y - 87 || mouse_y >= map_center_y - 57)) {
                            save_special_events_numeric_field();
                        } else if (dropdown_list_selected) {
                            int item_selected = 0;
                            for (int i = 0; i < 12; i++) {
                                if (mouse_x >= map_center_x + 83 && mouse_x < map_center_x + 183
                                && mouse_y >= map_center_y - 169 + 18 * i && mouse_y < map_center_y - 151 + 18 * i) {
                                    scenario.gladiator_revolt.month = i;
                                    if (!scenario.gladiator_revolt.year_offset && !scenario.gladiator_revolt.month) {
                                        scenario.gladiator_revolt.month++; // don't allow Jan year 0 event
                                    }
                                    hide_dropdown_list();
                                    item_selected = 1;
                                    break;
                                }
                            }
                            if (!item_selected) {
                                hide_dropdown_list();
                            }
                        } else {
                            if (mouse_x >= map_center_x + 23 && mouse_x < map_center_x + 68 && mouse_y >= map_center_y - 87 && mouse_y < map_center_y - 57) {
                                dropdown_list_selected = 1;
                            } else if (mouse_x >= map_center_x + 76 && mouse_x < map_center_x + 236 && mouse_y >= map_center_y - 87 && mouse_y < map_center_y - 57) {
                                activate_numeric_input_text_field(scenario.gladiator_revolt.year_offset, 0);
                                handle_input_text_mouse_click(1, map_center_x + 76, map_center_y - 87, 5, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                            } else {
                                for (int i = 0; i < 6; i++) {
                                    if (mouse_x >= map_center_x - 60 && mouse_x < map_center_x + 15 && mouse_y >= map_center_y - 87 + 40 * i && mouse_y < map_center_y - 57 + 40 * i) {
                                        switch (i) {
                                            case 0:
                                                scenario.gladiator_revolt.state = !scenario.gladiator_revolt.state;
                                                break;
                                            case 1:
                                                scenario.random_events.sea_trade_problem = !scenario.random_events.sea_trade_problem;
                                                break;
                                            case 2:
                                                scenario.random_events.land_trade_problem = !scenario.random_events.land_trade_problem;
                                                break;
                                            case 3:
                                                scenario.random_events.raise_wages = !scenario.random_events.raise_wages;
                                                break;
                                            case 4:
                                                scenario.random_events.lower_wages = !scenario.random_events.lower_wages;
                                                break;
                                            case 5:
                                                scenario.random_events.contaminated_water = !scenario.random_events.contaminated_water;
                                        }
                                        refresh_current_window = 1;
                                    }
                                }
                            }
                        }
                    }
                    break;
                case WINDOW_EDITOR_REQUESTS:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_EDITOR_ATTRIBUTES);
                    } else if (mouse_left_down) {
                        for (int i = 0; i < MAX_REQUESTS; i++) {
                            if ((i < 15 && mouse_x >= map_center_x - 447 && mouse_x < map_center_x - 157 && mouse_y >= map_center_y - 212 + 30 * i && mouse_y < map_center_y - 187 + 30 * i)
                            || (i < 30 && mouse_x >= map_center_x - 149 && mouse_x < map_center_x + 141 && mouse_y >= map_center_y - 212 + 30 * (i - 20) && mouse_y < map_center_y - 187 + 30 * (i - 15))
                            || (i < 45 && mouse_x >= map_center_x + 149 && mouse_x < map_center_x + 439 && mouse_y >= map_center_y - 212 + 30 * (i - 40) && mouse_y < map_center_y - 187 + 30 * (i - 30))) {
                                change_window(WINDOW_EDITOR_EDIT_REQUEST);
                                id_edit_request = i;
                                break;
                            }
                        }
                    }
                    break;
                case WINDOW_EDITOR_EDIT_REQUEST:
                    if (enter_pressed) {
                        if (text_field_active) {
                            save_edit_request_numeric_field();
                        }
                    } else if (escape_key_down || mouse_right_up) {
                        if (text_field_active) {
                            save_edit_request_numeric_field();
                        } else if (dropdown_list_selected) {
                            hide_dropdown_list();
                        } else {
                            sort_editor_requests();
                            change_window(WINDOW_EDITOR_REQUESTS);
                        }
                    } else if (mouse_left_down) {
                        if (text_field_active
                        && (mouse_x < map_center_x + 8 || mouse_x >= map_center_x + 120
                            || mouse_y < map_center_y - 84 + 30 * (text_field_active - 1) || mouse_y >= map_center_y - 54 + 30 * (text_field_active - 1))) {
                            save_edit_request_numeric_field();
                        } else if (dropdown_list_selected) {
                            int item_selected = 0;
                            switch (dropdown_list_selected) {
                                case 1:
                                    for (int i = 0; i < 12; i++) {
                                        if (mouse_x >= map_center_x + 143 && mouse_x < map_center_x + 243
                                        && mouse_y >= map_center_y - 152 + 18 * i && mouse_y < map_center_y - 134 + 18 * i) {
                                            scenario.requests[id_edit_request].month = i;
                                            if (!scenario.requests[id_edit_request].year_offset && !scenario.requests[id_edit_request].month) {
                                                scenario.requests[id_edit_request].month++; // don't allow Jan year 0 event
                                            }
                                            item_selected = 1;
                                            hide_dropdown_list();
                                            break;
                                        }
                                    }
                                    break;
                                case 2:
                                    for (int i = 0; i < 17; i++) {
                                        if (mouse_x >= map_center_x + 143 && mouse_x < map_center_x + 243
                                        && mouse_y >= map_center_y - 122 + 18 * i && mouse_y < map_center_y - 104 + 18 * i) {
                                            scenario.requests[id_edit_request].resource = i;
                                            item_selected = 1;
                                            hide_dropdown_list();
                                            break;
                                        }
                                    }
                                    break;
                            }
                            if (!item_selected) {
                                hide_dropdown_list();
                            }
                        } else {
                            for (int i = 0; i < 6; i++) {
                                if (mouse_x >= map_center_x + 8 && mouse_x < map_center_x + 120
                                && mouse_y >= map_center_y - 84 + 30 * i && mouse_y < map_center_y - 54 + 30 * i) {
                                    switch (i) {
                                        case 0:
                                            activate_numeric_input_text_field(scenario.requests[id_edit_request].year_offset, 0);
                                            handle_input_text_mouse_click(1, map_center_x + 8, map_center_y - 84, 5, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                        case 1:
                                            dropdown_list_selected = 1;
                                            refresh_current_window = 1;
                                            break;
                                        case 2:
                                            dropdown_list_selected = 2;
                                            refresh_current_window = 1;
                                            break;
                                        case 3:
                                            activate_numeric_input_text_field(scenario.requests[id_edit_request].amount, 0);
                                            handle_input_text_mouse_click(4, map_center_x + 8, map_center_y + 6, scenario.requests[id_edit_request].resource == RESOURCE_DENARII ? 6 : 4, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                        case 4:
                                            activate_numeric_input_text_field(scenario.requests[id_edit_request].years_deadline, 0);
                                            handle_input_text_mouse_click(5, map_center_x + 8, map_center_y + 36, 4, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                        case 5:
                                            activate_numeric_input_text_field(scenario.requests[id_edit_request].favor, 0);
                                            handle_input_text_mouse_click(6, map_center_x + 8, map_center_y + 66, 3, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                    }
                                }
                            }
                            if (mouse_x >= map_center_x - 100 && mouse_x < map_center_x + 100 && mouse_y >= map_center_y + 101 && mouse_y < map_center_y + 126) {
                                scenario.requests[id_edit_request].year_offset = 1;
                                scenario.requests[id_edit_request].month = 0;
                                scenario.requests[id_edit_request].resource = 0;
                                scenario.requests[id_edit_request].amount = 1;
                                scenario.requests[id_edit_request].years_deadline = 5;
                                scenario.requests[id_edit_request].months_to_comply = 60;
                                scenario.requests[id_edit_request].favor = 8;
                                sort_editor_requests();
                                change_window(WINDOW_EDITOR_REQUESTS);
                            }
                        }
                    }
                    break;
                case WINDOW_EDITOR_CUSTOM_MESSAGES:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_EDITOR_ATTRIBUTES);
                    } else if (mouse_left_down) {
                        for (int i = 0; i < MAX_EDITOR_CUSTOM_MESSAGES; i++) {
                            if ((i < 20 && mouse_x >= map_center_x - 392 && mouse_x < map_center_x - 267 && mouse_y >= map_center_y - 276 + 30 * i && mouse_y < map_center_y - 251 + 30 * i)
                            || (mouse_x >= map_center_x + 7 && mouse_x < map_center_x + 132 && mouse_y >= map_center_y - 276 + 30 * (i - 20) && mouse_y < map_center_y - 251 + 30 * (i - 20))) {
                                change_window(WINDOW_EDITOR_EDIT_CUSTOM_MESSAGE_ATTRIBUTES);
                                custom_message_id = i;
                                break;
                            } else if ((i < 20 && mouse_x >= map_center_x - 262 && mouse_x < map_center_x - 137 && mouse_y >= map_center_y - 276 + 30 * i && mouse_y < map_center_y - 251 + 30 * i)
                            || (mouse_x >= map_center_x + 137 && mouse_x < map_center_x + 262 && mouse_y >= map_center_y - 276 + 30 * (i - 20) && mouse_y < map_center_y - 251 + 30 * (i - 20))) {
                                change_window(WINDOW_EDITOR_EDIT_CUSTOM_MESSAGE_TITLE);
                                custom_message_id = i;
                                break;
                            } else if ((i < 20 && mouse_x >= map_center_x - 132 && mouse_x < map_center_x - 7 && mouse_y >= map_center_y - 276 + 30 * i && mouse_y < map_center_y - 251 + 30 * i)
                            || (mouse_x >= map_center_x + 267 && mouse_x < map_center_x + 392 && mouse_y >= map_center_y - 276 + 30 * (i - 20) && mouse_y < map_center_y - 251 + 30 * (i - 20))) {
                                change_window(WINDOW_EDITOR_EDIT_CUSTOM_MESSAGE_TEXT);
                                custom_message_id = i;
                                break;
                            }
                        }
                    }
                    break;
                case WINDOW_EDITOR_EDIT_CUSTOM_MESSAGE_ATTRIBUTES:
                    if (enter_pressed) {
                        if (text_field_active) {
                            save_custom_message_attributes_text_field();
                        }
                    } else if (escape_key_down || mouse_right_up) {
                        if (text_field_active) {
                            save_custom_message_attributes_text_field();
                        } else if (dropdown_list_selected) {
                            hide_dropdown_list();
                        } else {
                            sort_custom_messages();
                            change_window(WINDOW_EDITOR_CUSTOM_MESSAGES);
                        }
                    } else if (mouse_left_down) {
                        if (text_field_active
                        && (mouse_x < map_center_x - 55 || mouse_x >= map_center_x + 105
                            || mouse_y < map_center_y - 68 + 30 * (text_field_active - 1) || mouse_y >= map_center_y - 38 + 30 * (text_field_active - 1))) {
                            save_custom_message_attributes_text_field();
                        } else if (dropdown_list_selected) {
                            int item_selected = 0;
                            for (int i = 0; i < 12; i++) {
                                if (mouse_x >= map_center_x + 121 && mouse_x < map_center_x + 221
                                && mouse_y >= map_center_y - 129 + 18 * i && mouse_y < map_center_y - 111 + 18 * i) {
                                    scenario.editor_custom_messages[custom_message_id].month = i;
                                    if (!scenario.editor_custom_messages[custom_message_id].year_offset && !scenario.editor_custom_messages[custom_message_id].month) {
                                        scenario.editor_custom_messages[custom_message_id].month++; // don't allow Jan year 0 event
                                    }
                                    hide_dropdown_list();
                                    item_selected = 1;
                                    break;
                                }
                            }
                            if (!item_selected) {
                                hide_dropdown_list();
                            }
                        } else {
                            for (int i = 0; i < 5; i++) {
                                if (mouse_x >= map_center_x - 55 && mouse_x < map_center_x + 105
                                && mouse_y >= map_center_y - 68 + 30 * i && mouse_y < map_center_y - 38 + 30 * i) {
                                    switch (i) {
                                        case 0:
                                            activate_numeric_input_text_field(scenario.editor_custom_messages[custom_message_id].year_offset, 0);
                                            handle_input_text_mouse_click(1, map_center_x - 55, map_center_y - 68, 4, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                        case 1:
                                            dropdown_list_selected = 1;
                                            refresh_current_window = 1;
                                            break;
                                        case 2:
                                            scenario.editor_custom_messages[custom_message_id].urgent = !scenario.editor_custom_messages[custom_message_id].urgent;
                                            refresh_current_window = 1;
                                            break;
                                        case 3:
                                            handle_input_text_mouse_click(4, map_center_x - 55, map_center_y + 22, MAX_CUSTOM_MESSAGE_VIDEO_TEXT, FONT_NORMAL_WHITE, scenario.editor_custom_messages[custom_message_id].video_file, 1, 500);
                                            break;
                                        case 4:
                                            scenario.editor_custom_messages[custom_message_id].enabled = !scenario.editor_custom_messages[custom_message_id].enabled;
                                            refresh_current_window = 1;
                                            break;
                                    }

                                }
                            }
                            if (mouse_x >= map_center_x - 65 && mouse_x < map_center_x + 65 && mouse_y >= map_center_y + 93 && mouse_y < map_center_y + 118) {
                                scenario.editor_custom_messages[custom_message_id].year_offset = 1;
                                scenario.editor_custom_messages[custom_message_id].month = 0;
                                scenario.editor_custom_messages[custom_message_id].urgent = 0;
                                scenario.editor_custom_messages[custom_message_id].enabled = 0;
                                scenario.editor_custom_messages[custom_message_id].title[0] = '\0';
                                scenario.editor_custom_messages[custom_message_id].text[0] = '\0';
                                scenario.editor_custom_messages[custom_message_id].video_file[0] = '\0';
                                stop_text_input();
                                sort_custom_messages();
                                change_window(WINDOW_EDITOR_CUSTOM_MESSAGES);
                            }
                        }
                    }
                    break;
                case WINDOW_EDITOR_EDIT_CUSTOM_MESSAGE_TITLE:
                    if (text_field_active && (enter_pressed || escape_key_down || mouse_right_up)) {
                        string_copy(input_text_string, scenario.editor_custom_messages[custom_message_id].title, input_text_max_length);
                        stop_text_input();
                    } else if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_EDITOR_CUSTOM_MESSAGES);
                    } else if (mouse_left_down) {
                        if (mouse_x >= map_center_x - 136 && mouse_x < map_center_x + 136 && mouse_y >= map_center_y - 12 && mouse_y < map_center_y + 20) {
                            handle_input_text_mouse_click(1, map_center_x - 136, map_center_y - 12, MAX_CUSTOM_MESSAGE_TITLE, FONT_NORMAL_WHITE, scenario.editor_custom_messages[custom_message_id].title, 1, 500);
                        } else if (mouse_x >= map_center_x - 63 && mouse_x < map_center_x + 63 && mouse_y >= map_center_y + 32 && mouse_y < map_center_y + 57) {
                            stop_text_input();
                            scenario.editor_custom_messages[custom_message_id].title[0] = '\0';
                            change_window(WINDOW_EDITOR_CUSTOM_MESSAGES);
                        }
                    }
                    break;
                case WINDOW_EDITOR_EDIT_CUSTOM_MESSAGE_TEXT:
                    if (text_field_active && (escape_key_down || mouse_right_up)) {
                        string_copy(input_text_string, scenario.editor_custom_messages[custom_message_id].text, input_text_max_length);
                        stop_text_input();
                    } else if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_EDITOR_CUSTOM_MESSAGES);
                    } else if (mouse_left_down) {
                        if (mouse_x >= map_center_x - 384 && mouse_x < map_center_x + 384 && mouse_y >= map_center_y - 192 && mouse_y < map_center_y + 224) {
                            handle_input_text_mouse_click(1, map_center_x - 384, map_center_y - 192, MAX_CUSTOM_MESSAGE_TEXT, FONT_NORMAL_WHITE, scenario.editor_custom_messages[custom_message_id].text, 18, MAX_CUSTOM_MESSAGE_TEXT_WIDTH);
                        } else if (mouse_x >= map_center_x - 63 && mouse_x < map_center_x + 63 && mouse_y >= map_center_y + 222 && mouse_y < map_center_y + 247) {
                            stop_text_input();
                            scenario.editor_custom_messages[custom_message_id].text[0] = '\0';
                            change_window(WINDOW_EDITOR_CUSTOM_MESSAGES);
                        }
                    }
                    break;
                case WINDOW_EDITOR_EARTHQUAKES:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_EDITOR_ATTRIBUTES);
                    } else if (mouse_left_down) {
                        for (int i = 0; i < MAX_EARTHQUAKES; i++) {
                            if (mouse_x >= map_center_x - 175 && mouse_x < map_center_x + 175 && mouse_y >= map_center_y - 140 + 32 * i && mouse_y < map_center_y - 115 + 32 * i) {
                                change_window(WINDOW_EDITOR_EDIT_EARTHQUAKE);
                                id_edit_earthquake = i;
                                break;
                            }
                        }
                    }
                    break;
                case WINDOW_EDITOR_EDIT_EARTHQUAKE:
                    if (enter_pressed) {
                        if (text_field_active) {
                            save_earthquake_year_offset();
                        }
                    } else if (escape_key_down || mouse_right_up) {
                        if (text_field_active) {
                            save_earthquake_year_offset();
                        } else if (dropdown_list_selected) {
                            hide_dropdown_list();
                        } else {
                            sort_earthquakes();
                            change_window(WINDOW_EDITOR_EARTHQUAKES);
                        }
                    } else if (mouse_left_down) {
                        if (text_field_active
                        && (mouse_x < map_center_x - 55 || mouse_x >= map_center_x + 153 || mouse_y < map_center_y - 51 || mouse_y >= map_center_y - 21)) {
                            save_earthquake_year_offset();
                        } else if (dropdown_list_selected) {
                            int item_selected = 0;
                            switch (dropdown_list_selected) {
                                case 1:
                                    for (int i = 0; i < 12; i++) {
                                        if (mouse_x >= map_center_x + 121 && mouse_x < map_center_x + 221
                                        && mouse_y >= map_center_y - 129 + 18 * i && mouse_y < map_center_y - 111 + 18 * i) {
                                            scenario.earthquakes[id_edit_earthquake].month = i;
                                            if (!scenario.earthquakes[id_edit_earthquake].year_offset && !scenario.earthquakes[id_edit_earthquake].month) {
                                                scenario.earthquakes[id_edit_earthquake].month++; // don't allow Jan year 0 event
                                            }
                                            hide_dropdown_list();
                                            item_selected = 1;
                                            break;
                                        }
                                    }
                                    break;
                                case 2:
                                    for (int i = 0; i < 8; i++) {
                                        if (mouse_x >= map_center_x + 169 && mouse_x < map_center_x + 269
                                        && mouse_y >= map_center_y - 24 + 18 * i && mouse_y < map_center_y - 6 + 18 * i) {
                                            scenario.earthquakes[id_edit_earthquake].point = i;
                                            item_selected = 1;
                                            hide_dropdown_list();
                                            break;
                                        }
                                    }
                                    break;
                            }
                            if (!item_selected) {
                                hide_dropdown_list();
                            }
                        } else {
                            for (int i = 0; i < 4; i++) {
                                if (mouse_x >= map_center_x - 55 && mouse_x < map_center_x + 153 && mouse_y >= map_center_y - 51 + 30 * i && mouse_y < map_center_y - 21 + 30 * i) {
                                    switch (i) {
                                        case 0:
                                            activate_numeric_input_text_field(scenario.earthquakes[id_edit_earthquake].year_offset, 0);
                                            handle_input_text_mouse_click(1, map_center_x - 55, map_center_y - 51, 4, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                        case 1:
                                            dropdown_list_selected = 1;
                                            refresh_current_window = 1;
                                            break;
                                        case 2:
                                            scenario.earthquakes[id_edit_earthquake].severity++;
                                            switch (scenario.earthquakes[id_edit_earthquake].severity) {
                                                case 1:
                                                    scenario.earthquakes[id_edit_earthquake].state = 1;
                                                    scenario.earthquakes[id_edit_earthquake].max_duration = 25 + rand() % 32;
                                                    scenario.earthquakes[id_edit_earthquake].max_delay = 10;
                                                    break;
                                                case 2:
                                                    scenario.earthquakes[id_edit_earthquake].state = 1;
                                                    scenario.earthquakes[id_edit_earthquake].max_duration = 100 + rand() % 64;
                                                    scenario.earthquakes[id_edit_earthquake].max_delay = 8;
                                                    break;
                                                case 3:
                                                    scenario.earthquakes[id_edit_earthquake].state = 1;
                                                    scenario.earthquakes[id_edit_earthquake].max_duration = 250 + rand() % 128;
                                                    scenario.earthquakes[id_edit_earthquake].max_delay = 6;
                                                    break;
                                                default:
                                                    scenario.earthquakes[id_edit_earthquake].state = 0;
                                                    scenario.earthquakes[id_edit_earthquake].severity = 0;
                                                    scenario.earthquakes[id_edit_earthquake].max_duration = 0;
                                                    scenario.earthquakes[id_edit_earthquake].max_delay = 0;
                                                    break;
                                            }
                                            refresh_current_window = 1;
                                            break;
                                        case 3:
                                            dropdown_list_selected = 2;
                                            refresh_current_window = 1;
                                            break;
                                    }
                                }
                            }
                            if (mouse_x >= map_center_x - 100 && mouse_x < map_center_x + 100 && mouse_y >= map_center_y + 74 && mouse_y < map_center_y + 99) {
                                scenario.earthquakes[id_edit_earthquake].state = 0;
                                scenario.earthquakes[id_edit_earthquake].severity = 0;
                                scenario.earthquakes[id_edit_earthquake].month = 0;
                                scenario.earthquakes[id_edit_earthquake].year_offset = 1;
                                scenario.earthquakes[id_edit_earthquake].duration = 0;
                                scenario.earthquakes[id_edit_earthquake].max_duration = 0;
                                scenario.earthquakes[id_edit_earthquake].delay = 0;
                                scenario.earthquakes[id_edit_earthquake].max_delay = 0;
                                scenario.earthquakes[id_edit_earthquake].point = 0;
                                for (int i = 0; i < MAX_EARTHQUAKE_BRANCHES; i++) {
                                    scenario.earthquakes[id_edit_earthquake].branch_coordinates[i].x = -1;
                                    scenario.earthquakes[id_edit_earthquake].branch_coordinates[i].y = -1;
                                }
                                sort_earthquakes();
                                change_window(WINDOW_EDITOR_EARTHQUAKES);
                            }
                        }
                    }
                    break;
                case WINDOW_EDITOR_INVASIONS:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_EDITOR_ATTRIBUTES);
                    } else if (mouse_left_down) {
                        for (int i = 0; i < MAX_INVASIONS; i++) {
                            if ((i < 15 && mouse_x >= map_center_x - 447 && mouse_x < map_center_x - 157 && mouse_y >= map_center_y - 212 + 30 * i && mouse_y < map_center_y - 187 + 30 * i)
                            || (i < 30 && mouse_x >= map_center_x - 149 && mouse_x < map_center_x + 141 && mouse_y >= map_center_y - 212 + 30 * (i - 20) && mouse_y < map_center_y - 187 + 30 * (i - 15))
                            || (i < 45 && mouse_x >= map_center_x + 149 && mouse_x < map_center_x + 439 && mouse_y >= map_center_y - 212 + 30 * (i - 40) && mouse_y < map_center_y - 187 + 30 * (i - 30))) {
                                change_window(WINDOW_EDITOR_EDIT_INVASION);
                                id_edit_invasion = i;
                                break;
                            }
                        }
                    }
                    break;
                case WINDOW_EDITOR_EDIT_INVASION:
                    if (enter_pressed) {
                        if (text_field_active) {
                            save_invasions_text_field();
                        }
                    } else if (escape_key_down || mouse_right_up) {
                        if (text_field_active) {
                            save_invasions_text_field();
                        } else if (dropdown_list_selected) {
                            hide_dropdown_list();
                        } else {
                            sort_invasions();
                            change_window(WINDOW_EDITOR_INVASIONS);
                        }
                    } else if (mouse_left_down) {
                        if (text_field_active
                        && (mouse_x < map_center_x - 50 || mouse_x >= map_center_x + 126
                            || mouse_y < map_center_y - 101 + 30 * (text_field_active - 1) || mouse_y >= map_center_y - 71 + 30 * (text_field_active - 1))) {
                            save_custom_message_attributes_text_field();
                        } else if (dropdown_list_selected) {
                            int item_selected = 0;
                            switch (dropdown_list_selected) {
                                case 1:
                                    for (int i = 0; i < 12; i++) {
                                        if (mouse_x >= map_center_x + 141 && mouse_x < map_center_x + 241
                                        && mouse_y >= map_center_y - 159 + 18 * i && mouse_y < map_center_y - 141 + 18 * i) {
                                            scenario.invasions[id_edit_invasion].month = i;
                                            if (!scenario.invasions[id_edit_invasion].year_offset && !scenario.invasions[id_edit_invasion].month) {
                                                scenario.invasions[id_edit_invasion].month++; // don't allow Jan year 0 event
                                            }
                                            hide_dropdown_list();
                                            item_selected = 1;
                                            break;
                                        }
                                    }
                                    break;
                                case 2:
                                    for (int i = 0; i < 5; i++) {
                                        if (mouse_x >= map_center_x + 141 && mouse_x < map_center_x + 271
                                        && mouse_y >= map_center_y - 36 + 18 * i && mouse_y < map_center_y - 18 + 18 * i) {
                                            scenario.invasions[id_edit_invasion].type = i;
                                            if (scenario.invasions[id_edit_invasion].type == INVASION_TYPE_LOCAL_UPRISING) {
                                                scenario.invasions[id_edit_invasion].enemy_type = ENEMY_TYPE_BARBARIAN;
                                            }
                                            hide_dropdown_list();
                                            item_selected = 1;
                                            break;
                                        }
                                    }
                                    break;
                                case 3:
                                    for (int i = 0; i < 20; i++) {
                                        if (mouse_x >= map_center_x + 141 && mouse_x < map_center_x + 271
                                        && mouse_y >= map_center_y - 129 + 18 * i && mouse_y < map_center_y - 111 + 18 * i) {
                                            scenario.invasions[id_edit_invasion].enemy_type = i;
                                            hide_dropdown_list();
                                            item_selected = 1;
                                            break;
                                        }
                                    }
                                    break;
                                case 4:
                                    for (int i = 0; i < 9; i++) {
                                        if (mouse_x >= map_center_x + 141 && mouse_x < map_center_x + 271
                                        && mouse_y >= map_center_y - 14 + 18 * i && mouse_y < map_center_y + 4 + 18 * i) {
                                            scenario.invasions[id_edit_invasion].from = i;
                                            hide_dropdown_list();
                                            item_selected = 1;
                                            break;
                                        }
                                    }
                                    break;
                                case 5:
                                    for (int i = 0; i < 5; i++) {
                                        if (mouse_x >= map_center_x + 141 && mouse_x < map_center_x + 271
                                        && mouse_y >= map_center_y + 51 + 18 * i && mouse_y < map_center_y + 69 + 18 * i) {
                                            text_draw(invasions_entry_points[i], map_center_x + 141, map_center_y + 51 + 18 * i, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                            scenario.invasions[id_edit_invasion].target_type = i;
                                            hide_dropdown_list();
                                            item_selected = 1;
                                            break;
                                        }
                                    }
                                    break;
                            }
                            if (!item_selected) {
                                hide_dropdown_list();
                            }
                        } else {
                            for (int i = 0; i < 7; i++) {
                                if (mouse_x >= map_center_x - 50 && mouse_x < map_center_x + 126
                                && mouse_y >= map_center_y - 101 + 30 * i && mouse_y < map_center_y - 71 + 30 * i) {
                                    switch (i) {
                                        case 0:
                                            activate_numeric_input_text_field(scenario.invasions[id_edit_invasion].year_offset, 0);
                                            handle_input_text_mouse_click(1, map_center_x - 50, map_center_y - 101, 4, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                        case 1:
                                            dropdown_list_selected = 1;
                                            refresh_current_window = 1;
                                            break;
                                        case 2:
                                            activate_numeric_input_text_field(scenario.invasions[id_edit_invasion].amount, 0);
                                            handle_input_text_mouse_click(3, map_center_x - 50, map_center_y - 41, 4, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            refresh_current_window = 1;
                                            break;
                                        case 3:
                                            dropdown_list_selected = 2;
                                            refresh_current_window = 1;
                                            break;
                                        case 4:
                                            if (scenario.invasions[id_edit_invasion].type > INVASION_TYPE_LOCAL_UPRISING) {
                                                dropdown_list_selected = 3;
                                                refresh_current_window = 1;
                                            }
                                            break;
                                        case 5:
                                            if (scenario.invasions[id_edit_invasion].type) {
                                                dropdown_list_selected = 4;
                                                refresh_current_window = 1;
                                            }
                                            break;
                                        case 6:
                                            if (scenario.invasions[id_edit_invasion].type) {
                                                dropdown_list_selected = 5;
                                                refresh_current_window = 1;
                                            }
                                            break;
                                    }
                                }
                            }
                            if (mouse_x >= map_center_x - 88 && mouse_x < map_center_x + 88 && mouse_y >= map_center_y + 118 && mouse_y < map_center_y + 148) {
                                scenario.invasions[id_edit_invasion].year_offset = 1;
                                scenario.invasions[id_edit_invasion].month = 0;
                                scenario.invasions[id_edit_invasion].amount = 0;
                                scenario.invasions[id_edit_invasion].type = 0;
                                scenario.invasions[id_edit_invasion].from = 8;
                                scenario.invasions[id_edit_invasion].target_type = 0;
                                sort_invasions();
                                change_window(WINDOW_EDITOR_INVASIONS);
                            }
                        }
                    }
                    break;
                case WINDOW_EDITOR_PRICE_CHANGES:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_EDITOR_ATTRIBUTES);
                    } else if (mouse_left_down) {
                        for (int i = 0; i < MAX_PRICE_CHANGES; i++) {
                            if ((i < 15 && mouse_x >= map_center_x - 447 && mouse_x < map_center_x - 157 && mouse_y >= map_center_y - 212 + 30 * i && mouse_y < map_center_y - 187 + 30 * i)
                            || (i < 30 && mouse_x >= map_center_x - 149 && mouse_x < map_center_x + 141 && mouse_y >= map_center_y - 212 + 30 * (i - 20) && mouse_y < map_center_y - 187 + 30 * (i - 15))
                            || (i < 45 && mouse_x >= map_center_x + 149 && mouse_x < map_center_x + 439 && mouse_y >= map_center_y - 212 + 30 * (i - 40) && mouse_y < map_center_y - 187 + 30 * (i - 30))) {
                                change_window(WINDOW_EDITOR_EDIT_PRICE_CHANGE);
                                id_edit_price_change = i;
                                break;
                            }
                        }
                    }
                    break;
                case WINDOW_EDITOR_EDIT_PRICE_CHANGE:
                    if (enter_pressed) {
                        if (text_field_active) {
                            save_price_change_text_field();
                        }
                    } else if (escape_key_down || mouse_right_up) {
                        if (text_field_active) {
                            save_price_change_text_field();
                        } else if (dropdown_list_selected) {
                            hide_dropdown_list();
                        } else {
                            sort_price_changes();
                            change_window(WINDOW_EDITOR_PRICE_CHANGES);
                        }
                    } else if (mouse_left_down) {
                        if ((text_field_active == 1 && (mouse_x < map_center_x - 90 || mouse_x >= map_center_x + 22 || mouse_y < map_center_y - 44 || mouse_y >= map_center_y - 14))
                            || (text_field_active == 2 && (mouse_x < map_center_x + 150 || mouse_x >= map_center_x + 198 || mouse_y < map_center_y + 16 || mouse_y >= map_center_y + 46))) {
                            save_price_change_text_field();
                        } else if (dropdown_list_selected) {
                            int item_selected = 0;
                            switch (dropdown_list_selected) {
                                case 1:
                                    for (int i = 0; i < 12; i++) {
                                        if (mouse_x >= map_center_x + 37 && mouse_x < map_center_x + 137
                                        && mouse_y >= map_center_y - 104 + 18 * i && mouse_y < map_center_y - 86 + 18 * i) {
                                            scenario.price_changes[id_edit_price_change].month = i;
                                            if (!scenario.price_changes[id_edit_price_change].year_offset && !scenario.price_changes[id_edit_price_change].month) {
                                                scenario.price_changes[id_edit_price_change].month++; // don't allow Jan year 0 event
                                            }
                                            item_selected = 1;
                                            hide_dropdown_list();
                                            break;
                                        }
                                    }
                                    break;
                                case 2:
                                    for (int i = 0; i < 16; i++) {
                                        if (mouse_x >= map_center_x + 37 && mouse_x < map_center_x + 137
                                        && mouse_y >= map_center_y - 112 + 18 * i && mouse_y < map_center_y - 94 + 18 * i) {
                                            scenario.price_changes[id_edit_price_change].resource = i;
                                            item_selected = 1;
                                            hide_dropdown_list();
                                            break;
                                        }
                                    }
                                    break;
                            }
                            if (!item_selected) {
                                hide_dropdown_list();
                            }
                        } else {
                            for (int i = 0; i < 3; i++) {
                                if (mouse_x >= map_center_x - 90 && mouse_x < map_center_x + 22 && mouse_y >= map_center_y - 44 + 30 * i && mouse_y < map_center_y - 14 + 30 * i) {
                                    switch (i) {
                                        case 0:
                                            activate_numeric_input_text_field(scenario.price_changes[id_edit_price_change].year_offset, 0);
                                            handle_input_text_mouse_click(1, map_center_x - 90, map_center_y - 44, 4, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                        case 1:
                                            dropdown_list_selected = 1;
                                            break;
                                        case 2:
                                            dropdown_list_selected = 2;
                                            break;
                                    }
                                }
                            }
                            if (mouse_x >= map_center_x + 38 && mouse_x < map_center_x + 134 && mouse_y >= map_center_y + 16 && mouse_y < map_center_y + 46) {
                                scenario.price_changes[id_edit_price_change].is_rise = !scenario.price_changes[id_edit_price_change].is_rise;
                                refresh_current_window = 1;
                            } else if (mouse_x >= map_center_x + 150 && mouse_x < map_center_x + 198 && mouse_y >= map_center_y + 16 && mouse_y < map_center_y + 46) {
                                activate_numeric_input_text_field(scenario.price_changes[id_edit_price_change].amount, 0);
                                handle_input_text_mouse_click(2, map_center_x + 150, map_center_y + 16, 3, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                            } else if (mouse_x >= map_center_x - 88 && mouse_x < map_center_x + 88 && mouse_y >= map_center_y + 56 && mouse_y < map_center_y + 86) {
                                scenario.price_changes[id_edit_price_change].year_offset = 1;
                                scenario.price_changes[id_edit_price_change].month = 0;
                                scenario.price_changes[id_edit_price_change].resource = 0;
                                scenario.price_changes[id_edit_price_change].is_rise = 0;
                                scenario.price_changes[id_edit_price_change].amount = 1;
                                sort_price_changes();
                                change_window(WINDOW_EDITOR_PRICE_CHANGES);
                            }
                        }
                    }
                    break;
                case WINDOW_EDITOR_DEMAND_CHANGES:
                    if (escape_key_down || mouse_right_up) {
                        change_window(WINDOW_EDITOR_ATTRIBUTES);
                    } else if (mouse_left_down) {
                        for (int i = 0; i < MAX_DEMAND_CHANGES; i++) {
                            if ((i < 15 && mouse_x >= map_center_x - 447 && mouse_x < map_center_x - 157 && mouse_y >= map_center_y - 212 + 30 * i && mouse_y < map_center_y - 187 + 30 * i)
                            || (i < 30 && mouse_x >= map_center_x - 149 && mouse_x < map_center_x + 141 && mouse_y >= map_center_y - 212 + 30 * (i - 20) && mouse_y < map_center_y - 187 + 30 * (i - 15))
                            || (i < 45 && mouse_x >= map_center_x + 149 && mouse_x < map_center_x + 439 && mouse_y >= map_center_y - 212 + 30 * (i - 40) && mouse_y < map_center_y - 187 + 30 * (i - 30))) {
                                change_window(WINDOW_EDITOR_EDIT_DEMAND_CHANGE);
                                id_demand_route = i;
                                break;
                            }
                        }
                    }
                    break;
                case WINDOW_EDITOR_EDIT_DEMAND_CHANGE:
                    if (enter_pressed) {
                        if (text_field_active) {
                            save_demand_change_text_field();
                        }
                    } else if (escape_key_down || mouse_right_up) {
                        if (text_field_active) {
                            save_demand_change_text_field();
                        } else if (dropdown_list_selected) {
                            hide_dropdown_list();
                        } else {
                            if (!scenario.demand_changes[id_demand_route].trade_city_id) {
                                scenario.demand_changes[id_demand_route].resource = 0;
                            }
                            sort_demand_changes();
                            change_window(WINDOW_EDITOR_DEMAND_CHANGES);
                        }
                    } else if (mouse_left_down) {
                        if (text_field_active
                        && (mouse_x < map_center_x - 68 || mouse_x >= map_center_x + 60 || mouse_y < map_center_y - 77 || mouse_y >= map_center_y - 47)) {
                            save_demand_change_text_field();
                        } else if (dropdown_list_selected) {
                            int item_selected = 0;
                            switch (dropdown_list_selected) {
                                case 1:
                                    for (int i = 0; i < 12; i++) {
                                        if (mouse_x >= map_center_x + 75 && mouse_x < map_center_x + 175
                                        && mouse_y >= map_center_y - 138 + 18 * i && mouse_y < map_center_y - 120 + 18 * i) {
                                            scenario.demand_changes[id_demand_route].month = i;
                                            if (!scenario.demand_changes[id_demand_route].year_offset && !scenario.demand_changes[id_demand_route].month) {
                                                scenario.demand_changes[id_demand_route].month++; // don't allow Jan year 0 event
                                            }
                                            item_selected = 1;
                                            hide_dropdown_list();
                                            break;
                                        }
                                    }
                                    break;
                                case 2:
                                    for (int i = 0; i < 16; i++) {
                                        if (mouse_x >= map_center_x + 75 && mouse_x < map_center_x + 175
                                        && mouse_y >= map_center_y - 146 + 18 * i && mouse_y < map_center_y - 128 + 18 * i) {
                                            scenario.demand_changes[id_demand_route].trade_city_id = 0;
                                            scenario.demand_changes[id_demand_route].resource = i;
                                            item_selected = 1;
                                            hide_dropdown_list();
                                            // reset routes -> create route names for the chosen resource
                                            demand_routes_num_routes = 0;
                                            memset(route_display_names, 0, sizeof(route_display_names));
                                            for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
                                                if ((empire_objects[i].city_type == EMPIRE_CITY_TRADE || empire_objects[i].city_type == EMPIRE_CITY_FUTURE_TRADE)
                                                && (empire_objects[i].resource_sell_limit[scenario.demand_changes[id_demand_route].resource] || empire_objects[i].resource_buy_limit[scenario.demand_changes[id_demand_route].resource])) {
                                                    for (int j = 0; j < MAX_DEMAND_ROUTES; j++) {
                                                        if (!route_display_names[j][0]) {
                                                            int offset = string_from_int(route_display_names[j], i, 0);
                                                            route_display_names[j][offset++] = ' ';
                                                            route_display_names[j][offset++] = '-';
                                                            route_display_names[j][offset++] = ' ';
                                                            string_copy(city_names[empire_objects[i].city_name_id], &route_display_names[j][offset], DEMAND_ROUTE_MAX_NAME_LENGTH - offset);
                                                            demand_routes_route_ids[demand_routes_num_routes] = i;
                                                            demand_routes_num_routes++;
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                            if (!demand_routes_num_routes) {
                                                demand_routes_num_routes = 1;
                                                string_copy("None available", route_display_names[0], DEMAND_ROUTE_MAX_NAME_LENGTH);
                                            }
                                            break;
                                        }
                                    }
                                    break;
                                case 3:
                                    for (int i = 0; i < demand_routes_num_routes; i++) {
                                        if (mouse_x >= map_center_x + 151 && mouse_x < map_center_x + 311
                                        && mouse_y >= map_center_y + 29 + 18 * i && mouse_y < map_center_y + 47 + 18 * i) {
                                            scenario.demand_changes[id_demand_route].trade_city_id = demand_routes_route_ids[i]; // choose trade route from the dropdown list
                                            reusable_int = i;
                                            item_selected = 1;
                                            hide_dropdown_list();
                                            break;
                                        }
                                    }
                                    break;
                            }
                            if (!item_selected) {
                                hide_dropdown_list();
                            }
                        } else {
                            for (int i = 0; i < 3; i++) {
                                if (mouse_x >= map_center_x - 68 && mouse_x < map_center_x + 60
                                && mouse_y >= map_center_y - 77 + 30 * i && mouse_y < map_center_y - 47 + 30 * i) {
                                    switch (i) {
                                        case 0:
                                            activate_numeric_input_text_field(scenario.demand_changes[id_demand_route].year_offset, 0);
                                            handle_input_text_mouse_click(1, map_center_x - 68, map_center_y - 77, 4, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                                            break;
                                        case 1:
                                            dropdown_list_selected = 1;
                                            break;
                                        case 2:
                                            dropdown_list_selected = 2;
                                            break;
                                    }
                                }
                            }
                            if (mouse_x >= map_center_x - 68 && mouse_x < map_center_x + 140 && mouse_y >= map_center_y + 13 && mouse_y < map_center_y + 43) {
                                dropdown_list_selected = 3;
                                refresh_current_window = 1;
                            } else if (mouse_x >= map_center_x + 12 && mouse_x < map_center_x + 140 && mouse_y >= map_center_y + 43 && mouse_y < map_center_y + 73) {
                                scenario.demand_changes[id_demand_route].is_rise = !scenario.demand_changes[id_demand_route].is_rise;
                                refresh_current_window = 1;
                            } else if (mouse_x >= map_center_x - 128 && mouse_x < map_center_x + 128 && mouse_y >= map_center_y + 83 && mouse_y < map_center_y + 113) {
                                scenario.demand_changes[id_demand_route].year_offset = 1;
                                scenario.demand_changes[id_demand_route].month = 0;
                                scenario.demand_changes[id_demand_route].resource = 0;
                                scenario.demand_changes[id_demand_route].trade_city_id = 0;
                                scenario.demand_changes[id_demand_route].is_rise = 0;
                                sort_demand_changes();
                                change_window(WINDOW_EDITOR_DEMAND_CHANGES);
                            }
                        }
                    }
                    break;
                case WINDOW_EDITOR_EMPIRE:
                    if (enter_pressed) {
                        if (text_field_active) {
                            save_editor_empire_text_field();
                        }
                    } else if (escape_key_down || mouse_right_up) {
                        if (text_field_active) {
                            save_editor_empire_text_field();
                        } else {
                            if (selected_empire_object) {
                                selected_empire_object = 0;
                                refresh_current_window = 1;
                            } else {
                                change_window(WINDOW_EDITOR_MAP);
                            }
                        }
                    } else if (mouse_left_down) {
                        if ((text_field_active == 1 && (mouse_x < empire_editor_resource_toggle_x + 683 || mouse_x >= empire_editor_resource_toggle_x + 747 || mouse_y < empire_y_max - 108 || mouse_y >= empire_y_max - 78))
                        || (text_field_active == 2 && (mouse_x < empire_editor_resource_toggle_x + 683 || mouse_x >= empire_editor_resource_toggle_x + 747 || mouse_y < empire_y_max - 68 || mouse_y >= empire_y_max - 38))) {
                            save_editor_empire_text_field();
                        } else {
                            if (mouse_x >= empire_x_min + 16 && mouse_x < empire_x_max - 16 && mouse_y >= empire_y_min + 16 && mouse_y < empire_y_max - 152) { // mouse inside map
                                int city_was_selected = 0;
                                if (selected_empire_object) {
                                    city_was_selected = 1;
                                }
                                select_empire_object(mouse_x - empire_x_min - 16 + empire_data.scroll_x, mouse_y - empire_y_min - 16 + empire_data.scroll_y);
                                if (selected_empire_object) {
                                    if (selected_empire_object->type == EMPIRE_OBJECT_ORNAMENT && selected_empire_object->image_id == 3323) { // if border flag selected, remove it
                                        selected_empire_object->in_use = 0;
                                        selected_empire_object = 0;
                                    }
                                } else {
                                    if (!city_was_selected) { // place border flag on map if no object selected, but not on the same click as deselecting a city
                                        for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
                                            if (!empire_objects[i].in_use) {
                                                empire_objects[i].in_use = 1;
                                                empire_objects[i].image_id = 3323;
                                                empire_objects[i].x = mouse_x - empire_x_min - 16 + empire_data.scroll_x;
                                                empire_objects[i].y = mouse_y - empire_y_min - 16 + empire_data.scroll_y;
                                                break;
                                            }
                                        }
                                    }
                                }
                                refresh_current_window = 1;
                            } else if (mouse_x >= screen_center_x - 24 && mouse_x < screen_center_x
                            && mouse_y >= empire_y_max - 69 && mouse_y < empire_y_max - 45) {
                                current_window_image_button_pressed = 1; // empire state arrow up
                            } else if (mouse_x >= screen_center_x && mouse_x < screen_center_x + 24
                            && mouse_y >= empire_y_max - 69 && mouse_y < empire_y_max - 45) {
                                current_window_image_button_pressed = 2; // empire state arrow down
                            } else if (mouse_x >= empire_editor_city_type_arrow_x && mouse_x < empire_editor_city_type_arrow_x + 24
                            && mouse_y >= empire_y_max - 108 && mouse_y < empire_y_max - 84) {
                                current_window_image_button_pressed = 3; // city type arrow
                            } else if (mouse_x >= empire_editor_resource_toggle_x + 683 && mouse_x < empire_editor_resource_toggle_x + 747
                            && mouse_y >= empire_y_max - 108 && mouse_y < empire_y_max - 84) {
                                activate_numeric_input_text_field(selected_empire_object->trade_route_cost, 0);
                                handle_input_text_mouse_click(1, empire_editor_resource_toggle_x + 683, empire_y_max - 108, 5, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                            } else if (mouse_x >= empire_editor_resource_toggle_x + 683 && mouse_x < empire_editor_resource_toggle_x + 731
                            && mouse_y >= empire_y_max - 68 && mouse_y < empire_y_max - 44) {
                                activate_numeric_input_text_field(scenario.empire.expansion_year, 0);
                                handle_input_text_mouse_click(2, empire_editor_resource_toggle_x + 683, empire_y_max - 68, 4, FONT_NORMAL_WHITE, input_text_string, 1, 100);
                            } else if (mouse_x >= empire_editor_resource_toggle_x && mouse_x < empire_editor_resource_toggle_x + 472
                            && mouse_y >= empire_y_max - 108 && mouse_y < empire_y_max - 44) {
                                for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                    if (mouse_x >= empire_editor_resource_toggle_x + 32 * (r - 1) && mouse_x < empire_editor_resource_toggle_x + 24 + 32 * (r - 1)
                                    && mouse_y >= empire_y_max - 108 && mouse_y < empire_y_max - 84) {
                                        switch (selected_empire_object->resource_buy_limit[r]) {
                                            case 0:
                                                selected_empire_object->resource_buy_limit[r] = 15;
                                                break;
                                            case 15:
                                                selected_empire_object->resource_buy_limit[r] = 25;
                                                break;
                                            case 25:
                                                selected_empire_object->resource_buy_limit[r] = 40;
                                                break;
                                            default:
                                                selected_empire_object->resource_buy_limit[r] = 0;
                                        }
                                        // if resource to sell already enabled, disable
                                        selected_empire_object->resource_sell_limit[r] = 0;
                                    }
                                }
                                for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                    if (mouse_x >= empire_editor_resource_toggle_x + 32 * (r - 1) && mouse_x < empire_editor_resource_toggle_x + 24 + 32 * (r - 1)
                                    && mouse_y >= empire_y_max - 68 && mouse_y < empire_y_max - 44) {
                                        switch (selected_empire_object->resource_sell_limit[r]) {
                                            case 0:
                                                selected_empire_object->resource_sell_limit[r] = 15;
                                                break;
                                            case 15:
                                                selected_empire_object->resource_sell_limit[r] = 25;
                                                break;
                                            case 25:
                                                selected_empire_object->resource_sell_limit[r] = 40;
                                                break;
                                            default:
                                                selected_empire_object->resource_sell_limit[r] = 0;
                                        }
                                        // if resource to buy already enabled, disable
                                        selected_empire_object->resource_buy_limit[r] = 0;
                                    }
                                }
                            }
                        }
                    } else if (mouse_left_up) {
                        switch (current_window_image_button_pressed) {
                            case 1:
                                switch_empire_state(1);
                                break;
                            case 2:
                                switch_empire_state(-1);
                                break;
                            case 3:
                                set_city_type();
                                break;
                        }
                        current_window_image_button_pressed = 0;
                    }
                    break;
                case WINDOW_CONFIGS:
                    if (text_field_active && (enter_pressed || escape_key_down || mouse_right_up)) {
                        stop_text_input();
                        string_copy(input_text_string, configs_player_name, input_text_max_length);
                    } else if (escape_key_down || mouse_right_up) {
                        fp = fopen(CONFIGS_FILE_PATH, "wt");
                        string_copy(input_text_string, configs_player_name, MAX_PLAYER_NAME_LENGTH);
                        fprintf(fp, "%s=%s\n", "Player name", configs_player_name);
                        for (int i = 0; i < CONFIGS_MAX_ENTRIES; i++) {
                            fprintf(fp, "%s=%d\n", configs[i].config_string, configs[i].config_value);
                        }
                        fclose(fp);
                        show_main_menu_window(0);
                    } else if (mouse_left_down) {
                        if (mouse_x >= screen_center_x - 216 && mouse_x < screen_center_x + 152
                        && mouse_y >= screen_center_y - 92 && mouse_y < screen_center_y - 60) {
                            handle_input_text_mouse_click(1, screen_center_x - 216, screen_center_y - 92, MAX_PLAYER_NAME_LENGTH, FONT_NORMAL_WHITE, configs_player_name, 1, 100);
                        } else {
                            stop_text_input();
                            string_copy(input_text_string, configs_player_name, input_text_max_length);
                            if (mouse_y >= screen_center_y + 126 && mouse_y < screen_center_y + 156) {
                                if (mouse_x >= screen_center_x - 205 && mouse_x < screen_center_x - 25) {
                                    change_window(WINDOW_HOTKEY_CONFIGS);
                                    init_scrollbar(screen_center_y - 240);
                                } else if (mouse_x >= screen_center_x + 25 && mouse_x < screen_center_x + 205) {
                                    set_default_configs();
                                    refresh_current_window = 1;
                                }
                            } else {
                                for (int i = 0; i < CONFIGS_MAX_ENTRIES; i++) {
                                    if (mouse_x >= screen_center_x - 216 && mouse_x < screen_center_x - 194
                                    && mouse_y >= screen_center_y - 52 + 22 * i && mouse_y < screen_center_y - 30 + 22 * i) {
                                        configs[i].config_value = configs[i].config_value ? 0 : 1;
                                        refresh_current_window = 1;
                                    }
                                }
                            }
                        }
                    }
                    break;
                case WINDOW_HOTKEY_CONFIGS:
                    if (escape_key_down || mouse_right_up) {
                        fp = fopen(HOTKEY_CONFIGS_FILE_PATH, "wt");
                        if (fp) {
                            for (int i = 0; i < HOTKEY_CONFIGS_NUMBER_ROWS; i++) {
                                if (hotkey_mappings[i].is_header) {
                                    fprintf(fp, "%s\n", hotkey_mappings[i].action_name);
                                } else {
                                    char hotkey[FILE_LINE_LENGTH_MAX] = { 0 };
                                    if (hotkey_mappings[i].sdl_mods) {
                                        for (int k = 0; k < 4; k++) {
                                            if (hotkey_mappings[i].sdl_mods & modifier_names[k].modifier) {
                                                strcat(hotkey, modifier_names[k].name);
                                                strcat(hotkey, "_");
                                            }
                                        }
                                    }
                                    strcat(hotkey, SDL_GetKeyName(hotkey_mappings[i].sdl_key));
                                    fprintf(fp, "%s=%s\n", hotkey_mappings[i].action_name, hotkey);
                                }
                            }
                            fclose(fp);
                        }
                        change_window(WINDOW_CONFIGS);
                    } else if (mouse_left_down) {
                        if (mouse_x >= screen_center_x + 247 && mouse_x < screen_center_x + 247 + SCROLLBAR_BUTTON_WIDTH
                        && mouse_y >= screen_center_y - 241 // SCROLLBAR_DOT_HEIGHT / 2 omitted here to allow dot dragging by clicking anywhere on it
                        && mouse_y < screen_center_y + 232) { // ^
                            is_dragging_scroll = 1;
                        } else {
                            if (mouse_x >= screen_center_x && mouse_x <= screen_center_x + 230
                            && mouse_y >= screen_center_y - 249 && mouse_y <= screen_center_y - 227 + 24 * (HOTKEY_CONFIGS_NUM_VISIBLE_ROWS - 1)) {
                                for (int i = 0; i < HOTKEY_CONFIGS_NUM_VISIBLE_ROWS; i++) {
                                    if (mouse_x >= screen_center_x && mouse_x <= screen_center_x + 230
                                    && mouse_y >= screen_center_y - 249 + 24 * i && mouse_y <= screen_center_y - 227 + 24 * i) {
                                        int absolute_position = i + scrollbar_position;
                                        if (absolute_position && !hotkey_mappings[absolute_position].is_header) {
                                            hotkey_config_window_data.action_index = absolute_position;
                                            change_window(WINDOW_HOTKEY_EDITOR);
                                        }
                                        break;
                                    }
                                }
                            } else if (mouse_x >= screen_center_x - 90 && mouse_x < screen_center_x + 90
                            && mouse_y >= screen_center_y + 276 && mouse_y < screen_center_y + 306) {
                                for (int action = 0; action < HOTKEY_CONFIGS_NUMBER_ROWS; action++) {
                                    hotkey_mappings[action].sdl_mods = 0;
                                    hotkey_mappings[action].sdl_key = 0;
                                }
                                set_default_hotkeys();
                                refresh_current_window = 1;
                            } else if (mouse_x >= screen_center_x + 247 && mouse_x < screen_center_x + 247 + SCROLLBAR_BUTTON_WIDTH
                                && mouse_y >= screen_center_y - 241 - SCROLLBAR_BUTTON_HEIGHT && mouse_y < screen_center_y - 241) {
                                scrollbar_up_arrow_pressed = 1;
                            } else if (mouse_x >= screen_center_x + 247 && mouse_x < screen_center_x + 247 + SCROLLBAR_BUTTON_WIDTH
                            && mouse_y >= screen_center_y + 232 && mouse_y < screen_center_y + 232 + SCROLLBAR_BUTTON_HEIGHT) {
                                scrollbar_down_arrow_pressed = 1;
                            }
                        }
                    } else if (mouse_left_up) {
                        current_window_image_button_pressed = 0;
                        if (is_dragging_scroll || scrollbar_up_arrow_pressed || scrollbar_down_arrow_pressed) {
                            release_scrollbar();
                        }
                    } else if (event.type == SDL_MOUSEWHEEL) {
                        scroll_scrollbar_step(-event.wheel.y, screen_center_y - 240, 472, HOTKEY_CONFIGS_NUMBER_ROWS - HOTKEY_CONFIGS_NUM_VISIBLE_ROWS);
                    }
                    if (is_dragging_scroll) {
                        drag_scrollbar_mouse(mouse_y, screen_center_y - 240, 472, HOTKEY_CONFIGS_NUMBER_ROWS - HOTKEY_CONFIGS_NUM_VISIBLE_ROWS);
                    }
                    break;
                case WINDOW_HOTKEY_EDITOR:
                    if (event.type == SDL_KEYDOWN) {
                        if (key_mod) {
                            hotkey_config_window_data.modifiers |= key_mod;
                        }
                        if (event.key.keysym.sym != SDLK_RETURN && event.key.keysym.sym != SDLK_KP_ENTER && event.key.keysym.sym != SDLK_ESCAPE) {
                            hotkey_config_window_data.key = event.key.keysym.sym;
                        }
                        // prevent showing mod as key
                        if (hotkey_config_window_data.key == SDLK_LCTRL) {
                            hotkey_config_window_data.key -= SDLK_LCTRL;
                        }
                        if (hotkey_config_window_data.key == SDLK_LSHIFT) {
                            hotkey_config_window_data.key -= SDLK_LSHIFT;
                        }
                        if (hotkey_config_window_data.key == SDLK_LALT) {
                            hotkey_config_window_data.key -= SDLK_LALT;
                        }
                        if (hotkey_config_window_data.key == SDLK_LGUI) {
                            hotkey_config_window_data.key -= SDLK_LGUI;
                        }
                        if (hotkey_config_window_data.key == SDLK_RCTRL) {
                            hotkey_config_window_data.key -= SDLK_RCTRL;
                        }
                        if (hotkey_config_window_data.key == SDLK_RSHIFT) {
                            hotkey_config_window_data.key -= SDLK_RSHIFT;
                        }
                        if (hotkey_config_window_data.key == SDLK_RALT) {
                            hotkey_config_window_data.key -= SDLK_RALT;
                        }
                        if (hotkey_config_window_data.key == SDLK_RGUI) {
                            hotkey_config_window_data.key -= SDLK_RGUI;
                        }
                    }
                    if (enter_pressed) {
                        close_hotkey_editor_window(1);
                    } else if (escape_key_down || mouse_right_up) {
                        close_hotkey_editor_window(0);
                    }
                    break;
            }


            switch (event.type) {
                case SDL_KEYDOWN:
                    // handle text cursor position keys and enter/exit
                    switch (event.key.keysym.sym) {
                        case SDLK_ESCAPE:
                            switch (current_window) {
                                case WINDOW_OVERLAY_MENU:
                                    close_submenu();
                                    show_city_window();
                                    break;
                            }
                            break;
                    }
                    // save mods and key for hotkey assignment drawing purposes
                    if (current_window != WINDOW_HOTKEY_EDITOR) { // prevent hotkey from activating during assignment
                        // handle hotkey actions
                        for (int i = 0; i < HOTKEY_CONFIGS_NUMBER_ROWS; i++) {
                            if (event.key.keysym.sym == hotkey_mappings[i].sdl_key
                            && key_mod == hotkey_mappings[i].sdl_mods) {
                                // action found, fulfill
                                switch (i) {
                                    case HOTKEY_ARROW_UP:
                                        is_key_scrolling_up = 1;
                                        break;
                                    case HOTKEY_ARROW_DOWN:
                                        is_key_scrolling_down = 1;
                                        break;
                                    case HOTKEY_ARROW_LEFT:
                                        is_key_scrolling_left = 1;
                                        break;
                                    case HOTKEY_ARROW_RIGHT:
                                        is_key_scrolling_right = 1;
                                        break;
                                    case HOTKEY_TOGGLE_FULLSCREEN:
                                        toggle_fullscreen();
                                        break;
                                    case HOTKEY_RESET_WINDOW:
                                        reset_screen();
                                        break;
                                    case HOTKEY_SAVE_SCREENSHOT:
                                        graphics_save_screenshot(0);
                                        break;
                                    case HOTKEY_SAVE_CITY_SCREENSHOT:
                                        if (current_window == WINDOW_CITY) {
                                            graphics_save_screenshot(1);
                                        }
                                        break;
                                    case HOTKEY_LOAD_FILE:
                                        switch (current_window) {
                                            case WINDOW_MAIN_MENU:
                                            case WINDOW_CITY:
                                                show_file_dialog_window(FILE_TYPE_SAVED_GAME, FILE_DIALOG_LOAD);
                                                break;
                                            case WINDOW_EDITOR_MAP:
                                                show_file_dialog_window(FILE_TYPE_SCENARIO, FILE_DIALOG_LOAD);
                                                break;
                                        }
                                        break;
                                    case HOTKEY_SAVE_FILE:
                                        switch (current_window) {
                                            case WINDOW_MAIN_MENU:
                                            case WINDOW_CITY:
                                                show_file_dialog_window(FILE_TYPE_SAVED_GAME, FILE_DIALOG_SAVE);
                                                break;
                                            case WINDOW_EDITOR_MAP:
                                                show_file_dialog_window(FILE_TYPE_SCENARIO, FILE_DIALOG_SAVE);
                                                break;
                                        }
                                        break;
                                    case HOTKEY_DECREASE_GAME_SPEED:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                decrease_game_speed();
                                                refresh_current_window = 1;
                                                break;
                                        }
                                        break;
                                    case HOTKEY_INCREASE_GAME_SPEED:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                increase_game_speed();
                                                refresh_current_window = 1;
                                                break;
                                        }
                                        break;
                                    case HOTKEY_TOGGLE_PAUSE:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                state_data.paused = state_data.paused ? 0 : 1;
                                                clear_all_warnings();
                                                break;
                                        }
                                        break;
                                    case HOTKEY_ROTATE_MAP_LEFT:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                game_orientation_rotate_left();
                                                refresh_current_window = 1;
                                                break;
                                        }
                                        break;
                                    case HOTKEY_ROTATE_MAP_RIGHT:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                game_orientation_rotate_right();
                                                refresh_current_window = 1;
                                                break;
                                        }
                                        break;
                                    case HOTKEY_REPLAY_MAP:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                change_window(WINDOW_REPLAY_MAP);
                                                break;
                                            case WINDOW_REPLAY_MAP:
                                                change_window(WINDOW_CITY);
                                                break;
                                        }
                                        break;
                                    case HOTKEY_CYCLE_LEGION:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                if (city_data.military.total_legions) {
                                                    int selectable_legions_count = 0;
                                                    for (int i = 0; i < MAX_LEGIONS; i++) {
                                                        if (legion_formations[i].in_use && !legion_formations[i].in_distant_battle && legion_formations[i].num_figures && legion_formations[i].morale > ROUT_MORALE_THRESHOLD) {
                                                            selectable_legions_count++;
                                                        }
                                                    }
                                                    // handle wrap around and index mismatches caused by fort delete/recreate, formation rout/destruction, allocation to distant battle
                                                    if (last_selected_legion_index >= selectable_legions_count - 1) {
                                                        last_selected_legion_index = -1;
                                                    }
                                                    if (selectable_legions_count) {
                                                        int next_available_legion_index = 0;
                                                        for (int i = 0; i < MAX_LEGIONS; i++) {
                                                            if (legion_formations[i].in_use && !legion_formations[i].in_distant_battle && legion_formations[i].num_figures && legion_formations[i].morale > ROUT_MORALE_THRESHOLD) {
                                                                if (last_selected_legion_index == -1 || next_available_legion_index == last_selected_legion_index) {
                                                                    last_selected_legion_index++;
                                                                    selected_legion_formation = &legion_formations[last_selected_legion_index];
                                                                    set_cursor_shape(CURSOR_SWORD);
                                                                    break;
                                                                }
                                                                next_available_legion_index++;
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                        }
                                        break;
                                    case HOTKEY_RETURN_LEGIONS_TO_FORT:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                for (int i = 0; i < MAX_LEGIONS; i++) {
                                                    if (legion_formations[i].in_use && !legion_formations[i].in_distant_battle) {
                                                        return_legion_formation_home(&legion_formations[i]);
                                                    }
                                                }
                                                break;
                                        }
                                        break;
                                    case HOTKEY_SHOW_LAST_ADVISOR:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                            case WINDOW_EMPIRE:
                                                window_advisors_show(settings[SETTINGS_LAST_ADVISOR].config_value);
                                                break;
                                            case WINDOW_ADVISOR_LABOR:
                                            case WINDOW_ADVISOR_MILITARY:
                                            case WINDOW_ADVISOR_IMPERIAL:
                                            case WINDOW_ADVISOR_RATINGS:
                                            case WINDOW_ADVISOR_TRADE:
                                            case WINDOW_ADVISOR_POPULATION:
                                            case WINDOW_ADVISOR_HEALTH:
                                            case WINDOW_ADVISOR_EDUCATION:
                                            case WINDOW_ADVISOR_ENTERTAINMENT:
                                            case WINDOW_ADVISOR_RELIGION:
                                            case WINDOW_ADVISOR_FINANCIAL:
                                            case WINDOW_ADVISOR_CHIEF:
                                                change_window(WINDOW_CITY);
                                                break;

                                        }
                                        break;
                                    case HOTKEY_SHOW_EMPIRE_MAP:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                window_empire_show();
                                                break;
                                            case WINDOW_EMPIRE:
                                                show_city_window();
                                                break;
                                            case WINDOW_EDITOR_MAP:
                                                change_window(WINDOW_EDITOR_EMPIRE);
                                                break;
                                            case WINDOW_EDITOR_EMPIRE:
                                                selected_empire_object = 0;
                                                change_window(WINDOW_EDITOR_MAP);
                                                break;
                                        }
                                        break;
                                    case HOTKEY_SHOW_MESSAGES:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                show_messages_window();
                                                break;
                                            case WINDOW_MESSAGE_LIST:
                                                show_city_window();
                                        }
                                        break;
                                    case HOTKEY_GO_TO_PROBLEM:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                button_go_to_problem();
                                                break;
                                        }
                                        break;
                                    case HOTKEY_SHOW_OVERLAY_WATER:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                handle_overlay_hotkey(OVERLAY_WATER);
                                        }
                                        break;
                                    case HOTKEY_SHOW_OVERLAY_FIRE:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                handle_overlay_hotkey(OVERLAY_FIRE);
                                                break;
                                        }
                                        break;
                                    case HOTKEY_SHOW_OVERLAY_DAMAGE:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                handle_overlay_hotkey(OVERLAY_DAMAGE);
                                                break;
                                        }
                                        break;
                                    case HOTKEY_SHOW_OVERLAY_CRIME:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                handle_overlay_hotkey(OVERLAY_CRIME);
                                                break;
                                        }
                                        break;
                                    case HOTKEY_SHOW_OVERLAY_PROBLEMS:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                handle_overlay_hotkey(OVERLAY_PROBLEMS);
                                                break;
                                        }
                                        break;
                                    case HOTKEY_GO_TO_BOOKMARK_1:
                                    case HOTKEY_GO_TO_BOOKMARK_2:
                                    case HOTKEY_GO_TO_BOOKMARK_3:
                                    case HOTKEY_GO_TO_BOOKMARK_4:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                handle_go_to_bookmark_hotkey(i - HOTKEY_GO_TO_BOOKMARK_1 + 1);
                                                break;
                                        }
                                        break;
                                    case HOTKEY_SET_BOOKMARK_1:
                                    case HOTKEY_SET_BOOKMARK_2:
                                    case HOTKEY_SET_BOOKMARK_3:
                                    case HOTKEY_SET_BOOKMARK_4:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                handle_set_bookmark_hotkey(i - HOTKEY_SET_BOOKMARK_1 + 1);
                                                break;
                                        }
                                        break;
                                    case HOTKEY_EDITOR_TOGGLE_BATTLE_INFO:
                                        switch (current_window) {
                                            case WINDOW_EDITOR_EMPIRE:
                                                empire_editor_show_battle_objects = !empire_editor_show_battle_objects;
                                                break;
                                        }
                                        break;
                                    case HOTKEY_CHEAT_MONEY:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                if (city_data.finance.treasury < 50000) {
                                                    city_data.finance.treasury += 1000;
                                                    city_data.finance.cheated_money += 1000;
                                                }
                                                refresh_current_window = 1;
                                                break;
                                        }
                                        break;
                                    case HOTKEY_CHEAT_INVASION:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                city_message_post(1, MESSAGE_ENEMY_ARMY_ATTACK, 0, start_invasion(rand() % (ENEMY_TYPE_MAX_COUNT + 1), 160, MAX_INVASION_POINTS, FORMATION_ATTACK_RANDOM));
                                                break;
                                        }
                                        break;
                                    case HOTKEY_CHEAT_VICTORY:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                change_window(WINDOW_VICTORY_DIALOG);
                                                break;
                                        }
                                        break;
                                    case HOTKEY_BUILD_CLONE:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                if (terrain_grid.items[widget_city_data.current_tile.grid_offset] & TERRAIN_BUILDING) {
                                                    int building_id = map_building_at(widget_city_data.current_tile.grid_offset);
                                                    if (building_id) {
                                                        struct building_t *b = building_main(&all_buildings[building_id]);
                                                        if (building_is_house(b->type)) {
                                                            set_construction_building_type(BUILDING_HOUSE_VACANT_LOT);
                                                        } else {
                                                            set_construction_building_type(b->type);
                                                        }
                                                    }
                                                } else if (terrain_grid.items[widget_city_data.current_tile.grid_offset] & TERRAIN_AQUEDUCT) {
                                                    set_construction_building_type(BUILDING_AQUEDUCT);
                                                } else if (terrain_grid.items[widget_city_data.current_tile.grid_offset] & TERRAIN_WALL) {
                                                    set_construction_building_type(BUILDING_WALL);
                                                } else if (terrain_grid.items[widget_city_data.current_tile.grid_offset] & TERRAIN_GARDEN) {
                                                    set_construction_building_type(BUILDING_GARDENS);
                                                } else if (terrain_grid.items[widget_city_data.current_tile.grid_offset] & TERRAIN_ROAD) {
                                                    if (terrain_grid.items[widget_city_data.current_tile.grid_offset] & TERRAIN_WATER) {
                                                        if (sprite.items[widget_city_data.current_tile.grid_offset] > 6) {
                                                            set_construction_building_type(BUILDING_SHIP_BRIDGE);
                                                        } else {
                                                            set_construction_building_type(BUILDING_LOW_BRIDGE);
                                                        }
                                                    } else if (bitfields_grid.items[widget_city_data.current_tile.grid_offset] & BIT_PLAZA_OR_EARTHQUAKE) {
                                                        set_construction_building_type(BUILDING_PLAZA);
                                                    } else {
                                                        set_construction_building_type(BUILDING_ROAD);
                                                    }
                                                }
                                                break;
                                        }
                                        break;
                                    case HOTKEY_CYCLE_BUILDINGS:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                            {
                                                int last_building_type_selected = construction_data.type;
                                                if (last_building_type_selected < BUILDING_RESERVOIR) {
                                                    last_building_type_selected = BUILDING_RESERVOIR;
                                                } else {
                                                    last_building_type_selected++;
                                                }
                                                while (last_building_type_selected <= BUILDING_WAREHOUSE) {
                                                    if (last_building_type_selected == BUILDING_TRIUMPHAL_ARCH) {
                                                        if (!city_data.building.triumphal_arches_available) {
                                                            last_building_type_selected++;
                                                        }
                                                    }
                                                    if (scenario.allowed_buildings[last_building_type_selected]) {
                                                        set_construction_building_type(last_building_type_selected);
                                                        break;
                                                    }
                                                    last_building_type_selected++;
                                                }
                                                break;
                                            }
                                        }
                                        break;
                                    case HOTKEY_CYCLE_BUILDINGS_REVERSE:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                            {
                                                int last_building_type_selected = construction_data.type;
                                                if (last_building_type_selected < BUILDING_RESERVOIR) {
                                                    last_building_type_selected = BUILDING_WAREHOUSE;
                                                } else {
                                                    last_building_type_selected--;
                                                }
                                                while (last_building_type_selected >= BUILDING_RESERVOIR) {
                                                    if (last_building_type_selected == BUILDING_TRIUMPHAL_ARCH) {
                                                        if (!city_data.building.triumphal_arches_available) {
                                                            last_building_type_selected--;
                                                        }
                                                    }
                                                    if (scenario.allowed_buildings[last_building_type_selected]) {
                                                        set_construction_building_type(last_building_type_selected);
                                                        break;
                                                    }
                                                    last_building_type_selected--;
                                                }
                                                break;
                                            }
                                        }
                                        break;
                                    case HOTKEY_UNDO:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                game_undo_perform();
                                                break;
                                        }
                                        break;
                                    case HOTKEY_BUILD_VACANT_HOUSE:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                handle_set_building_hotkey(BUILDING_HOUSE_VACANT_LOT);
                                                break;
                                        }
                                        break;
                                    case HOTKEY_BUILD_CLEAR_LAND:
                                    case HOTKEY_BUILD_ROAD:
                                    case HOTKEY_BUILD_RESERVOIR:
                                    case HOTKEY_BUILD_AQUEDUCT:
                                    case HOTKEY_BUILD_FOUNTAIN:
                                    case HOTKEY_BUILD_WELL:
                                    case HOTKEY_BUILD_DOCTOR:
                                    case HOTKEY_BUILD_BATHHOUSE:
                                    case HOTKEY_BUILD_BARBER:
                                    case HOTKEY_BUILD_HOSPITAL:
                                    case HOTKEY_BUILD_SMALL_TEMPLE_CERES:
                                    case HOTKEY_BUILD_SMALL_TEMPLE_NEPTUNE:
                                    case HOTKEY_BUILD_SMALL_TEMPLE_MERCURY:
                                    case HOTKEY_BUILD_SMALL_TEMPLE_MARS:
                                    case HOTKEY_BUILD_SMALL_TEMPLE_VENUS:
                                    case HOTKEY_BUILD_LARGE_TEMPLE_CERES:
                                    case HOTKEY_BUILD_LARGE_TEMPLE_NEPTUNE:
                                    case HOTKEY_BUILD_LARGE_TEMPLE_MERCURY:
                                    case HOTKEY_BUILD_LARGE_TEMPLE_MARS:
                                    case HOTKEY_BUILD_LARGE_TEMPLE_VENUS:
                                    case HOTKEY_BUILD_ORACLE:
                                    case HOTKEY_BUILD_SCHOOL:
                                    case HOTKEY_BUILD_LIBRARY:
                                    case HOTKEY_BUILD_ACADEMY:
                                    case HOTKEY_BUILD_MISSION_POST:
                                    case HOTKEY_BUILD_THEATER:
                                    case HOTKEY_BUILD_ACTOR_COLONY:
                                    case HOTKEY_BUILD_AMPHITHEATER:
                                    case HOTKEY_BUILD_GLADIATOR_SCHOOL:
                                    case HOTKEY_BUILD_LION_HOUSE:
                                    case HOTKEY_BUILD_COLOSSEUM:
                                    case HOTKEY_BUILD_CHARIOT_MAKER:
                                    case HOTKEY_BUILD_HIPPODROME:
                                    case HOTKEY_BUILD_GARDENS:
                                    case HOTKEY_BUILD_PLAZA:
                                    case HOTKEY_BUILD_SMALL_STATUE:
                                    case HOTKEY_BUILD_MEDIUM_STATUE:
                                    case HOTKEY_BUILD_LARGE_STATUE:
                                    case HOTKEY_BUILD_GOVERNORS_HOUSE:
                                    case HOTKEY_BUILD_GOVERNORS_VILLA:
                                    case HOTKEY_BUILD_GOVERNORS_PALACE:
                                    case HOTKEY_BUILD_FORUM:
                                    case HOTKEY_BUILD_SENATE:
                                    case HOTKEY_BUILD_TRIUMPHAL_ARCH:
                                    case HOTKEY_BUILD_ENGINEERS_POST:
                                    case HOTKEY_BUILD_LOW_BRIDGE:
                                    case HOTKEY_BUILD_SHIP_BRIDGE:
                                    case HOTKEY_BUILD_SHIPYARD:
                                    case HOTKEY_BUILD_WHARF:
                                    case HOTKEY_BUILD_DOCK:
                                    case HOTKEY_BUILD_PREFECTURE:
                                    case HOTKEY_BUILD_WALL:
                                    case HOTKEY_BUILD_TOWER:
                                    case HOTKEY_BUILD_GATEHOUSE:
                                    case HOTKEY_BUILD_FORT_LEGIONARIES:
                                    case HOTKEY_BUILD_FORT_JAVELIN:
                                    case HOTKEY_BUILD_FORT_MOUNTED:
                                    case HOTKEY_BUILD_BARRACKS:
                                    case HOTKEY_BUILD_MILITARY_ACADEMY:
                                    case HOTKEY_BUILD_WHEAT_FARM:
                                    case HOTKEY_BUILD_VEGETABLE_FARM:
                                    case HOTKEY_BUILD_FRUIT_FARM:
                                    case HOTKEY_BUILD_PIG_FARM:
                                    case HOTKEY_BUILD_OLIVE_FARM:
                                    case HOTKEY_BUILD_VINES_FARM:
                                    case HOTKEY_BUILD_CLAY_PIT:
                                    case HOTKEY_BUILD_TIMBER_YARD:
                                    case HOTKEY_BUILD_MARBLE_QUARRY:
                                    case HOTKEY_BUILD_IRON_MINE:
                                    case HOTKEY_BUILD_OIL_WORKSHOP:
                                    case HOTKEY_BUILD_WINE_WORKSHOP:
                                    case HOTKEY_BUILD_POTTERY_WORKSHOP:
                                    case HOTKEY_BUILD_FURNITURE_WORKSHOP:
                                    case HOTKEY_BUILD_WEAPONS_WORKSHOP:
                                    case HOTKEY_BUILD_MARKET:
                                    case HOTKEY_BUILD_GRANARY:
                                    case HOTKEY_BUILD_WAREHOUSE:
                                        switch (current_window) {
                                            case WINDOW_CITY:
                                                handle_set_building_hotkey(i - BUILDING_CLEAR_LAND - 8);
                                                break;
                                        }
                                        break;
                                }
                                break;
                            }
                        }
                    }
                    break;
                case SDL_KEYUP:
                    if (event.key.keysym.sym == SDLK_UP) {
                        is_key_scrolling_up = 0;
                    }
                    if (event.key.keysym.sym == SDLK_DOWN) {
                        is_key_scrolling_down = 0;
                    }
                    if (event.key.keysym.sym == SDLK_LEFT) {
                        is_key_scrolling_left = 0;
                    }
                    if (event.key.keysym.sym == SDLK_RIGHT) {
                        is_key_scrolling_right = 0;
                    }
                    break;
                case SDL_TEXTINPUT:
                    if (keyboard_data.capture_numeric) {
                        char c = event.text.text[0];
                        if (c >= '0' && c <= '9') {
                            keyboard_data.capture_numeric_callback(c - '0');
                        }
                    } else {
                        if (keyboard_data.capture) {
                            int index = 0;
                            while (event.text.text[index]) {
                                char c = event.text.text[0];
                                int add = 0;
                                if (c == ' ' || c == '-') {
                                    add = 1;
                                } else if (c >= '0' && c <= '9') {
                                    add = 1;
                                } else if (c >= 'a' && c <= 'z') {
                                    add = 1;
                                } else if (c >= 'A' && c <= 'Z') {
                                    add = 1;
                                } else if (c == ',' || c == '.' || c == '?' || c == '!' || c == '@' || c == '%' || c == '\'' || c == '/' || c == '_') {
                                    add = keyboard_data.allow_punctuation;
                                }
                                if (add) {
                                    if (keyboard_data.length + 1 < keyboard_data.max_length) {
                                        keyboard_data.text[keyboard_data.length] = 0;
                                        while (keyboard_data.text[keyboard_data.length] > keyboard_data.text[keyboard_data.cursor_position]) {
                                            keyboard_data.text[keyboard_data.length]--;
                                            keyboard_data.text[keyboard_data.length] = keyboard_data.text[keyboard_data.length];
                                        }
                                        keyboard_data.text[keyboard_data.cursor_position] = event.text.text[0];
                                        keyboard_data.cursor_position++;
                                        keyboard_data.length += 1;
                                        update_viewport(1);
                                    }
                                }
                                index++;
                            }
                        }
                    }
                    break;
                    // case SDL_MOUSEMOTION:
                    //     switch (current_window) {
                    //         case WINDOW_OVERLAY_MENU:
                    //             for (int i = 0; i < OVERLAY_NUM_SUBMENUS; i++) {
                    //                 if (mouse_x >= sidebar_x_offset + 4 - OVERLAY_SUBMENUS_X_OFFSET - 160
                    //                 && mouse_x < sidebar_x_offset + 4 - OVERLAY_SUBMENUS_X_OFFSET - 160 + OVERLAY_SUBMENUS_BUTTONS_WIDTH
                    //                 && mouse_y >= 24 + 3 + (LABEL_IMG_HEIGHT + OVERLAY_SUBMENUS_SPACING) * i
                    //                 && mouse_y < 24 + 3 + LABEL_IMG_HEIGHT + (LABEL_IMG_HEIGHT + OVERLAY_SUBMENUS_SPACING) * i) {
                    //                     current_window_buttons_focus_id = i + 1;
                    //                     break;
                    //                 }
                    //             }
                    //             if (overlay_menu_data.selected_submenu) {
                    //                 for (int i = 0; i < overlay_submenus[overlay_menu_data.selected_submenu - 1].num_items; i++) {
                    //                     if (mouse_x >= sidebar_x_offset + 4 - OVERLAY_SUBMENUS_X_OFFSET - 330
                    //                     && mouse_x < sidebar_x_offset + 4 - OVERLAY_SUBMENUS_X_OFFSET - 330 + OVERLAY_SUBMENUS_BUTTONS_WIDTH
                    //                     && mouse_y >= 24 + 3 + (LABEL_IMG_HEIGHT + OVERLAY_SUBMENUS_SPACING) * (i + overlay_menu_data.selected_submenu - 1)
                    //                     && mouse_y < 24 + 3 + LABEL_IMG_HEIGHT + (LABEL_IMG_HEIGHT + OVERLAY_SUBMENUS_SPACING) * (i + overlay_menu_data.selected_submenu - 1)) {
                    //                         current_window_buttons_focus_id = i + OVERLAY_NUM_SUBMENUS + 1;
                    //                         break;
                    //                     }
                    //                 }
                    //             }
                    //             break;
                    //         case WINDOW_SLIDING_SIDEBAR:
                    //             break;
                    //     }
                    //     break;
                    // case SDL_MOUSEBUTTONDOWN:
                    //     switch (event.button.button) {
                    //         case SDL_BUTTON_LEFT:
                    //             switch (current_window) {
                    //                 case WINDOW_OVERLAY_MENU:
                    //                     for (int i = 0; i < OVERLAY_NUM_SUBMENUS; i++) {
                    //                         if (mouse_x >= sidebar_x_offset + 4 - OVERLAY_SUBMENUS_X_OFFSET - 160
                    //                         && mouse_x < sidebar_x_offset + 4 - OVERLAY_SUBMENUS_X_OFFSET - 160 + OVERLAY_SUBMENUS_BUTTONS_WIDTH
                    //                         && mouse_y >= 24 + 3 + (LABEL_IMG_HEIGHT + OVERLAY_SUBMENUS_SPACING) * i
                    //                         && mouse_y < 24 + 3 + LABEL_IMG_HEIGHT + (LABEL_IMG_HEIGHT + OVERLAY_SUBMENUS_SPACING) * i) {
                    //                             overlay_menu_data.selected_submenu = i + 1;
                    //                             game_state_set_overlay(overlay_menu_data.selected_submenu);
                    //                             break;
                    //                         }
                    //                     }
                    //                     break;
                    //             }
                    //             break;
                    //         case SDL_BUTTON_RIGHT:
                    //             switch (current_window) {
                    //                 case WINDOW_OVERLAY_MENU:
                    //                     close_submenu();
                    //                     show_city_window();
                    //                     break;
                    //             }
                    //     }
                    //     break;
            }
        }
        // draw screen
        char *maps_saves_file_names_list[SCENARIO_FILES_MAX];
        switch (current_window) {
            case WINDOW_INTRO_VIDEOS:
                video_draw_fullscreen();
                if (!data_video.is_playing && current_intro_video < 3) {
                    video_start(intro_videos_files_names[current_intro_video]);
                    video_init(0);
                    current_intro_video++;
                }
                if (current_intro_video == 3 && data_video.is_ended) {
                    change_window(WINDOW_LOGO);
                }
                break;
            case WINDOW_LOGO:
                if (refresh_current_window) {
                    memset(canvas.pixels, 0, sizeof(uint32_t) * canvas.width * canvas.height);
                    image_draw(7971, (current_resolution_width - 640) / 2, (current_resolution_height - 480) / 2);
                    play_intro_music();
                    refresh_current_window = 0;
                }
                break;
            case WINDOW_MAIN_MENU:
                if (refresh_current_window) {
                    image_draw_scaled(MAIN_MENU_BACKGROUND_IMG_ID, 0, 0, current_resolution_width, current_resolution_height);
                    text_draw(VERSION, 24, current_resolution_height - 24, FONT_SMALL_PLAIN, COLOR_FONT_LIGHT_GRAY);
                    refresh_current_window = 0;
                }
                for (int i = 0; i < 5; i++) {
                    draw_label(
                        image_buttons_main_menu[i].x_scaled,
                        image_buttons_main_menu[i].y_scaled,
                        image_buttons_main_menu[i].width_scaled,
                        1,
                        1);
                    text_draw_centered(
                        image_buttons_main_menu[i].text,
                        image_buttons_main_menu[i].x_scaled,
                        image_buttons_main_menu[i].y_scaled + 6,
                        image_buttons_main_menu[i].width_scaled,
                        FONT_NORMAL_GREEN,
                        COLOR_BLACK);
                }
                break;
            case WINDOW_CCK_SELECTION:
                if (refresh_current_window) {
                    image_draw_scaled(8984, 0, 0, current_resolution_width, current_resolution_height);
                    outer_panel_draw(screen_center_x - 384, screen_center_y - 240, 48, 30);
                    image_draw(7977, screen_center_x - 352, screen_center_y - 216);
                    button_border_draw(screen_center_x - 287, screen_center_y - 224, 184, 144, 0);
                    image_draw(scenario.brief_description_image_id, screen_center_x - 285, screen_center_y - 222);
                    image_draw(7978, screen_center_x - 93, screen_center_y - 215);
                    for (int i = 0; i < 44; i++) {
                        image_draw(924, screen_center_x - 366 + 8 * i, screen_center_y - 72);
                    }
                    for (int i = 0; i < 57; i++) {
                        image_draw(924, screen_center_x - 13, screen_center_y - 226 + 8 * i);
                    }
                    memset(maps_saves_file_names_list, 0, sizeof(maps_saves_file_names_list));
                    for (int i = 0; i < MAX_SCENARIOS_SHOWN; i++) {
                        if (i >= cck_selection_data.scenarios->num_files) {
                            break;
                        }
                        maps_saves_file_names_list[i] = cck_selection_data.scenarios->files[i + scrollbar_position];
                        file_remove_extension(maps_saves_file_names_list[i]);
                    }
                    text_draw_centered(cck_selection_data.selected_scenario_display, screen_center_x - 8, screen_center_y - 220, 392, FONT_LARGE_BLACK, COLOR_BLACK);
                    text_draw_centered(scenario.brief_description, screen_center_x - 8, screen_center_y - 172, 392, FONT_NORMAL_WHITE, COLOR_BLACK);
                    text_draw_year(scenario.start_year, screen_center_x + 130, screen_center_y - 140, FONT_LARGE_BLACK);
                    if (cck_selection_data.show_minimap) {
                        // draw large minimap
                        widget_scenario_minimap_draw(screen_center_x + 35, screen_center_y - 135, 286, 300);
                        // minimap button: draw mission instructions image
                        image_draw(955, screen_center_x + 300, screen_center_y - 140);
                    } else {
                        // minimap button: draw minimap
                        widget_scenario_minimap_draw(screen_center_x + 300, screen_center_y - 140, 33, 22);
                        // climate
                        text_draw_centered(climate_types_strings[scenario.climate], screen_center_x - 8, 320, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                        // map size
                        switch (scenario.map.width) {
                            case 40:
                                text_draw_centered("Tiny province", screen_center_x - 8, 340, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 60:
                                text_draw_centered("Small province", screen_center_x - 8, 340, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 80:
                                text_draw_centered("Average province", screen_center_x - 8, 340, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 100:
                                text_draw_centered("Large province", screen_center_x - 8, 340, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 120:
                                text_draw_centered("Very large province", screen_center_x - 8, 340, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            default:
                                break;
                        }
                        // military
                        int num_invasions = 0;
                        for (int i = 0; i < MAX_INVASIONS; i++) {
                            if (scenario.invasions[i].type) {
                                num_invasions++;
                            }
                        }
                        if (num_invasions <= 0) {
                            text_draw_centered("No military activity", screen_center_x - 8, 360, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                        } else if (num_invasions <= 2) {
                            text_draw_centered("Minor skirmishes reported", screen_center_x - 8, 360, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                        } else if (num_invasions <= 4) {
                            text_draw_centered("Some military activity", screen_center_x - 8, 360, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                        } else if (num_invasions <= 10) {
                            text_draw_centered("Many invasions likely", screen_center_x - 8, 360, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                        } else {
                            text_draw_centered("City is besieged", screen_center_x - 8, 360, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                        switch (scenario.player_rank) {
                            case 0:
                                text_draw_centered("Trivial assignment", screen_center_x - 8, 380, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 1:
                                text_draw_centered("Very simple assignment", screen_center_x - 8, 380, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 2:
                                text_draw_centered("Easy assignment", screen_center_x - 8, 380, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 3:
                                text_draw_centered("Somewhat easy assignment", screen_center_x - 8, 380, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 4:
                                text_draw_centered("Standard assignment", screen_center_x - 8, 380, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 5:
                                text_draw_centered("Quite hard assignment", screen_center_x - 8, 380, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 6:
                                text_draw_centered("Hard assignment", screen_center_x - 8, 380, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 7:
                                text_draw_centered("Very hard assignment", screen_center_x - 8, 380, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 8:
                                text_draw_centered("Extremely hard assignment", screen_center_x - 8, 380, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 9:
                                text_draw_centered("Hardest assignment", screen_center_x - 8, 380, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 10:
                                text_draw_centered("Virtually impossible task", screen_center_x - 8, 380, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;

                        }
                        // win conditions
                        text_draw_centered("Win conditions", screen_center_x - 8, 426, 392, FONT_NORMAL_BLACK, COLOR_BLACK);
                        int width;
                        if (scenario.culture_win_criteria) {
                            width = text_draw_number(scenario.culture_win_criteria, 0, 0, screen_center_x + 142, 454, FONT_NORMAL_BLACK);
                            text_draw("Culture", screen_center_x + 142 + width, 454, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                        if (scenario.prosperity_win_criteria) {
                            width = text_draw_number(scenario.prosperity_win_criteria, 0, 0, screen_center_x + 142, 472, FONT_NORMAL_BLACK);
                            text_draw("Prosperity", screen_center_x + 142 + width, 472, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                        if (scenario.peace_win_criteria) {
                            width = text_draw_number(scenario.peace_win_criteria, 0, 0, screen_center_x + 142, 490, FONT_NORMAL_BLACK);
                            text_draw("Peace", screen_center_x + 142 + width, 490, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                        if (scenario.favor_win_criteria) {
                            width = text_draw_number(scenario.favor_win_criteria, 0, 0, screen_center_x + 142, 508, FONT_NORMAL_BLACK);
                            text_draw("Favor", screen_center_x + 142 + width, 508, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                        if (scenario.population_win_criteria) {
                            width = text_draw_number(scenario.population_win_criteria, 0, 0, screen_center_x + 142, 526, FONT_NORMAL_BLACK);
                            text_draw("People", screen_center_x + 142 + width, 526, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                        if (scenario.time_limit_win_criteria) {
                            width = text_draw_number(scenario.time_limit_win_criteria, 0, 0, screen_center_x + 142, 544, FONT_NORMAL_BLACK);
                            text_draw("Years maximum", screen_center_x + 142 + width, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                        if (scenario.survival_time_win_criteria) {
                            width = text_draw_number(scenario.survival_time_win_criteria, 0, 0, screen_center_x + 142, 562, FONT_NORMAL_BLACK);
                            text_draw("Survival years", screen_center_x + 142 + width, 562, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                    }
                    refresh_current_window = 0;
                }
                // map names
                inner_panel_draw(screen_center_x - 368, screen_center_y - 62, 22, 18);
                for (int i = 0; i < MAX_SCENARIOS_SHOWN; i++) {
                    if (i >= cck_selection_data.scenarios->num_files) {
                        break;
                    }
                    if (mouse_x >= screen_center_x - 358 && mouse_x < screen_center_x - 75
                    && mouse_y >= screen_center_y - 52 + 18 * i && mouse_y < screen_center_y - 34 + 18 * i) {
                        text_draw(maps_saves_file_names_list[i], screen_center_x - 358, screen_center_y - 52 + 18 * i, FONT_NORMAL_WHITE, 0);
                    } else {
                        text_draw(maps_saves_file_names_list[i], screen_center_x - 358, screen_center_y - 52 + 18 * i, FONT_NORMAL_GREEN, 0);
                    }
                }
                if (cck_selection_data.scenarios->file_overflow) {
                    text_draw("Too many files. Showing 128.", screen_center_x, screen_center_y + 203, FONT_NORMAL_PLAIN, COLOR_RED);
                }
                draw_scrollbar(screen_center_x - 57, screen_center_y - 35, 233, cck_selection_data.scenarios->num_files - MAX_SCENARIOS_SHOWN);
                // minimap button border
                if (mouse_x >= screen_center_x + 300 && mouse_x < screen_center_x + 333
                && mouse_y >= screen_center_y - 140 && mouse_y < screen_center_y - 118) {
                    button_border_draw(screen_center_x + 300, screen_center_y - 140, 33, 22, 1);
                } else {
                    button_border_draw(screen_center_x + 300, screen_center_y - 140, 33, 22, 0);
                }
                // start scenario button
                draw_image_button(1049, screen_center_x + 340, screen_center_y + 197, 27, 27, 2);
                break;
            case WINDOW_MISSION_BRIEFING:
                if (refresh_current_window) {
                    image_draw_scaled(MAIN_MENU_BACKGROUND_IMG_ID, 0, 0, current_resolution_width, current_resolution_height);
                    outer_panel_draw(screen_center_x - 496, screen_center_y - 392, 62, 49);
                    text_draw_centered(scenario.scenario_name, screen_center_x - 496, screen_center_y - 372, 992, FONT_LARGE_BLACK, COLOR_BLACK);
                    text_draw_centered(scenario.brief_description, screen_center_x - 496, screen_center_y - 332, 992, FONT_NORMAL_BLACK, COLOR_BLACK);
                    inner_panel_draw(screen_center_x - 416, screen_center_y - 312, 52, 5);
                    for (int i = 0; i < 3; i++) {
                        draw_label(screen_center_x - 360 + 256 * i, screen_center_y - 296, 240, 0, 0);
                    }
                    for (int i = 0; i < 3; i++) {
                        draw_label(screen_center_x - 360 + 256 * i, screen_center_y - 264, 240, 0, 0);
                    }
                    if (scenario.culture_win_criteria) {
                        int width = text_draw("Culture rating of", screen_center_x - 328, screen_center_y - 292, FONT_NORMAL_RED, COLOR_BLACK);
                        text_draw_number(scenario.culture_win_criteria, 0, 0, screen_center_x - 328 + width, screen_center_y - 292, FONT_NORMAL_RED);
                    } else {
                        text_draw("No culture requirement", screen_center_x - 328, screen_center_y - 292, FONT_NORMAL_RED, COLOR_BLACK);
                    }
                    if (scenario.prosperity_win_criteria) {
                        int width = text_draw("Prosperity rating of", screen_center_x - 72, screen_center_y - 292, FONT_NORMAL_RED, COLOR_BLACK);
                        text_draw_number(scenario.prosperity_win_criteria, 0, 0, screen_center_x - 72 + width, screen_center_y - 292, FONT_NORMAL_RED);
                    } else {
                        text_draw("No prosperity requirement", screen_center_x - 88, screen_center_y - 292, FONT_NORMAL_RED, COLOR_BLACK);
                    }
                    if (scenario.peace_win_criteria) {
                        int width = text_draw("Peace rating of", screen_center_x + 184, screen_center_y - 292, FONT_NORMAL_RED, COLOR_BLACK);
                        text_draw_number(scenario.peace_win_criteria, 0, 0, screen_center_x + 184 + width, screen_center_y - 292, FONT_NORMAL_RED);
                    } else {
                        text_draw("No peace requirement", screen_center_x + 184, screen_center_y - 292, FONT_NORMAL_RED, COLOR_BLACK);
                    }
                    if (scenario.favor_win_criteria) {
                        int width = text_draw("Favor rating of", screen_center_x - 328, screen_center_y - 260, FONT_NORMAL_RED, COLOR_BLACK);
                        text_draw_number(scenario.favor_win_criteria, 0, 0, screen_center_x - 328 + width, screen_center_y - 260, FONT_NORMAL_RED);
                    } else {
                        text_draw("No favor requirement", screen_center_x - 328, screen_center_y - 260, FONT_NORMAL_RED, COLOR_BLACK);
                    }
                    if (scenario.population_win_criteria) {
                        int width = text_draw("Population of", screen_center_x - 72, screen_center_y - 260, FONT_NORMAL_RED, COLOR_BLACK);
                        text_draw_number(scenario.population_win_criteria, 0, 0, screen_center_x - 72 + width, screen_center_y - 260, FONT_NORMAL_RED);
                    } else {
                        text_draw("No population requirement", screen_center_x - 88, screen_center_y - 260, FONT_NORMAL_RED, COLOR_BLACK);
                    }
                    if (scenario.time_limit_win_criteria) {
                        int width = text_draw("Lose after", screen_center_x + 184, screen_center_y - 260, FONT_NORMAL_RED, COLOR_BLACK);
                        text_draw_number(scenario.time_limit_win_criteria, 0, " Years", screen_center_x + 184 + width, screen_center_y - 260, FONT_NORMAL_RED);
                    } else {
                        if (scenario.survival_time_win_criteria) {
                            int width = text_draw("Survive for", screen_center_x + 184, screen_center_y - 260, FONT_NORMAL_RED, COLOR_BLACK);
                            text_draw_number(scenario.survival_time_win_criteria, 0, " Years", screen_center_x + 184 + width, screen_center_y - 260, FONT_NORMAL_RED);
                        } else {
                            text_draw("No time limit", screen_center_x + 184, screen_center_y - 260, FONT_NORMAL_RED, COLOR_BLACK);
                        }
                    }
                    refresh_current_window = 0;
                }
                inner_panel_draw(screen_center_x - 480, screen_center_y - 216, 60, 37);
                parse_text(scenario.briefing, screen_center_x - 470, screen_center_y - 206, string_length(scenario.briefing), BRIEFING_MAX_LINE_WIDTH, FONT_NORMAL_WHITE);
                draw_text(scenario.briefing, FONT_NORMAL_WHITE, COLOR_BLACK);
                break;
            case WINDOW_CITY:
                if (refresh_current_window) {
                    window_city_draw_background();
                    refresh_current_window = 0;
                }
                if (construction_data.in_progress) {
                    build_move();
                }
                draw_foreground_city();
                if (build_menu_data.selected_menu > -1) {
                    int n_skipped_items = 0;
                    for (int j = 0; j < build_menu_data.num_items_to_draw; j++) {
                        draw_label(sidebar_x_offset - 261, 301 + 24 * j, 256, 0, 1);
                        if (build_menu_data.selected_submenu > -1) { // drawing items from a submenu
                            for (int k = j + n_skipped_items; k < MAX_ITEMS_PER_SUBMENU; k++) { // draw next enabled item
                                if (build_menus[build_menu_data.selected_menu].menu_items[build_menu_data.selected_submenu].submenu_items[k]) {
                                    text_draw_centered(all_buildings_strings[build_menus[build_menu_data.selected_menu].menu_items[build_menu_data.selected_submenu].submenu_items[k]], sidebar_x_offset - 261, 305 + 24 * j, 186, FONT_NORMAL_GREEN, COLOR_BLACK);
                                    text_draw_money(building_properties[build_menus[build_menu_data.selected_menu].menu_items[build_menu_data.selected_submenu].submenu_items[k]].cost, sidebar_x_offset - 70, 305 + 24 * j, FONT_NORMAL_GREEN);
                                    break;
                                } else {
                                    n_skipped_items++;
                                }
                            }
                        } else { // drawing items from a menu
                            for (int k = j + n_skipped_items; k < MAX_ITEMS_PER_BUILD_MENU; k++) {
                                if (build_menus[build_menu_data.selected_menu].menu_items[k].building_id) { // building or submenu is enabled
                                    if (build_menus[build_menu_data.selected_menu].menu_items[k].building_id == -1) { // submenu item
                                        text_draw_centered(build_menus[build_menu_data.selected_menu].menu_items[k].submenu_string, sidebar_x_offset - 261, 305 + 24 * j, 186, FONT_NORMAL_GREEN, COLOR_BLACK);
                                    } else { // building item
                                        text_draw_centered(all_buildings_strings[build_menus[build_menu_data.selected_menu].menu_items[k].building_id], sidebar_x_offset - 261, 305 + 24 * j, 186, FONT_NORMAL_GREEN, COLOR_BLACK);
                                        text_draw_money(building_properties[build_menus[build_menu_data.selected_menu].menu_items[k].building_id].cost, sidebar_x_offset - 70, 305 + 24 * j, FONT_NORMAL_GREEN);
                                    }
                                    break;
                                } else {
                                    n_skipped_items++;
                                }
                            }
                        }
                    }
                }
                break;
            case WINDOW_TOP_MENU:
                if (refresh_current_window) {
                    draw_foreground_city();
                    refresh_current_window = 0;
                }
                switch (top_menu_data.open_sub_menu) {
                    case 1:
                        draw_top_menu_submenu(0, 7, 4);
                        for (int i = 0; i < 4; i++) {
                            if (mouse_x >= 10 && mouse_x < 105 && mouse_y >= 28 + 18 * i && mouse_y < 46 + 18 * i) {
                                switch (i) {
                                    case 0:
                                        text_draw("Replay map", 10, 30, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                        break;
                                    case 1:
                                        text_draw("Save map", 10, 48, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                        break;
                                    case 2:
                                        text_draw("Load map", 10, 66, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                        break;
                                    case 3:
                                        text_draw("Exit", 10, 84, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                        break;
                                }
                            } else {
                                switch (i) {
                                    case 0:
                                        text_draw("Replay map", 10, 30, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                        break;
                                    case 1:
                                        text_draw("Save map", 10, 48, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                        break;
                                    case 2:
                                        text_draw("Load map", 10, 66, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                        break;
                                    case 3:
                                        text_draw("Exit", 10, 84, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                        break;
                                }
                            }
                        }
                        break;
                    case 2:
                        draw_top_menu_submenu(68, 5, 3);
                        for (int i = 0; i < 3; i++) {
                            if (mouse_x >= 78 && mouse_x < 142 && mouse_y >= 28 + 18 * i && mouse_y < 46 + 18 * i) {
                                switch (i) {
                                    case 0:
                                        text_draw("Display", 78, 30, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                        break;
                                    case 1:
                                        text_draw("Sound", 78, 48, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                        break;
                                    case 2:
                                        text_draw("Speed", 78, 66, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                        break;
                                }
                            } else {
                                switch (i) {
                                    case 0:
                                        text_draw("Display", 78, 30, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                        break;
                                    case 1:
                                        text_draw("Sound", 78, 48, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                        break;
                                    case 2:
                                        text_draw("Speed", 78, 66, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                        break;
                                }
                            }
                        }
                        break;
                }
                // allow opening other top menus by hovering the mouse over them
                if (top_menu_data.open_sub_menu) {
                    if (mouse_x >= 10 && mouse_x < 38 && mouse_y < 30) {
                        top_menu_data.open_sub_menu = TOP_MENU_FILE;
                        refresh_current_window = 1;
                    } else if (mouse_x >= 78 && mouse_x < 139 && mouse_y < 30) {
                        top_menu_data.open_sub_menu = TOP_MENU_OPTIONS;
                        refresh_current_window = 1;
                    }
                }
                break;
            case WINDOW_REPLAY_MAP:
                if (refresh_current_window) {
                    outer_panel_draw(map_center_x - 128, map_center_y - 32, 16, 4);
                    text_draw("Replay map?", map_center_x - 100, map_center_y - 12, FONT_LARGE_BLACK, COLOR_BLACK);
                    refresh_current_window = 0;
                }
                draw_image_button(1109, map_center_x + 73, map_center_y - 12, 39, 26, 1);
                break;
            case WINDOW_FILE_DIALOG:
                if (refresh_current_window) {
                    if (previous_window == WINDOW_MAIN_MENU) {
                        image_draw_scaled(MAIN_MENU_BACKGROUND_IMG_ID, 0, 0, current_resolution_width, current_resolution_height);
                    } else if (editor_active) {
                        draw_editor_map();
                    } else {
                        draw_foreground_city();
                    }
                    outer_panel_draw(screen_center_x - 384, screen_center_y - 240, 48, 30);
                    if (file_dialog_data.message_not_exist_start_time
                    && current_time - file_dialog_data.message_not_exist_start_time < NOT_EXIST_MESSAGE_TIMEOUT) {
                        text_draw_centered("File does not exist", screen_center_x - 384, screen_center_y - 220, 768, FONT_LARGE_BLACK, COLOR_BLACK);
                    } else {
                        switch (file_dialog_data.dialog_type + (file_dialog_data.type == FILE_TYPE_SCENARIO ? 3 : 0)) {
                            case 0:
                                text_draw_centered("Saving your city", screen_center_x - 384, screen_center_y - 220, 768, FONT_LARGE_BLACK, COLOR_BLACK);
                                break;
                            case 1:
                                text_draw_centered("Loading a city", screen_center_x - 384, screen_center_y - 220, 768, FONT_LARGE_BLACK, COLOR_BLACK);
                                break;
                            case 3:
                                text_draw_centered("Saving a province", screen_center_x - 384, screen_center_y - 220, 768, FONT_LARGE_BLACK, COLOR_BLACK);
                                break;
                            case 4:
                                text_draw_centered("Loading a province", screen_center_x - 384, screen_center_y - 220, 768, FONT_LARGE_BLACK, COLOR_BLACK);
                                break;
                        }
                    }
                    inner_panel_draw(screen_center_x - 368, screen_center_y - 180, 46, 2);
                    text_draw(file_dialog_data.selected_file, screen_center_x - 358, screen_center_y - 170, FONT_NORMAL_WHITE, COLOR_BLACK);
                    refresh_current_window = 0;
                }
                if (text_field_active) {
                    draw_input_field(46, 2);
                }
                inner_panel_draw(screen_center_x - 368, screen_center_y - 140, 46, 22);
                for (int i = 0; i < MAX_FILE_DIALOG_FILES_SHOWN; i++) {
                    if (i >= file_dialog_data.file_list->num_files) {
                        break;
                    }
                    if (!is_dragging_scroll
                    && mouse_x >= screen_center_x - 352 && mouse_x < screen_center_x + 300
                    && mouse_y >= screen_center_y - 132 + 18 * i && mouse_y < screen_center_y - 114 + 18 * i) {
                        text_draw(file_dialog_data.file_list->files[i + scrollbar_position], screen_center_x - 352, screen_center_y - 132 + 18 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                    } else {
                        text_draw(file_dialog_data.file_list->files[i + scrollbar_position], screen_center_x - 352, screen_center_y - 132 + 18 * i, FONT_NORMAL_GREEN, COLOR_BLACK);
                    }
                }
                if (file_dialog_data.file_list->file_overflow) {
                    text_draw("Too many files. Showing 128.", screen_center_x - 368, screen_center_y - 212, FONT_NORMAL_PLAIN, COLOR_RED);
                }
                draw_scrollbar(screen_center_x + 327, screen_center_y - 113, 297, file_dialog_data.file_list->num_files - MAX_FILE_DIALOG_FILES_SHOWN);
                draw_image_button(editor_active ? 1112 : 1109, screen_center_x + 328, screen_center_y - 220, 39, 26, 1);
                break;
            case WINDOW_EXIT_TO_MAIN_MENU:
                if (refresh_current_window) {
                    outer_panel_draw(map_center_x - 288, map_center_y - 32, 36, 4);
                    text_draw("Exit to main menu? Remember to save!", map_center_x - 272, map_center_y - 16, FONT_LARGE_BLACK, COLOR_BLACK);
                    refresh_current_window = 0;
                }
                draw_image_button(editor_active ? 1112 : 1109, map_center_x + 239, map_center_y - 16, 39, 26, 1);
                break;
            case WINDOW_DISPLAY_OPTIONS:
                if (refresh_current_window) {
                    outer_panel_draw(map_center_x - 144, map_center_y - 72, 18, 9);
                    text_draw_centered("Display options", map_center_x - 144, map_center_y - 52, 288, FONT_LARGE_BLACK, COLOR_BLACK);
                    refresh_current_window = 0;
                }
                for (int i = 0; i < 2; i++) {
                    draw_label(map_center_x - 112, map_center_y - 12 + 32 * i, 224, 1, 1);
                }
                if (settings[SETTINGS_FULLSCREEN].config_value) {
                    text_draw_centered("Fullscreen", map_center_x - 112, map_center_y - 5, 224, FONT_NORMAL_GREEN, COLOR_BLACK);
                } else {
                    text_draw_centered("Windowed", map_center_x - 112, map_center_y - 5, 224, FONT_NORMAL_GREEN, COLOR_BLACK);
                }
                text_draw_centered("Reset window", map_center_x - 112, map_center_y + 27, 224, FONT_NORMAL_GREEN, COLOR_BLACK);
                break;
            case WINDOW_SOUND_OPTIONS:
                outer_panel_draw(map_center_x - 192, map_center_y - 104, 24, 13);
                text_draw_centered("Sound options", map_center_x - 192, map_center_y - 84, 384, FONT_LARGE_BLACK, COLOR_BLACK);
                for (int i = 0; i < 4; i++) {
                    draw_label(map_center_x - 160, map_center_y - 44 + 32 * i, 224, 1, 1);
                    if (settings[2 * i + SETTINGS_MUSIC_ENABLED].config_value) {
                        switch (i) {
                            case 0:
                                text_draw_centered("Music ON", map_center_x - 160, map_center_y - 36, 224, FONT_NORMAL_GREEN, COLOR_BLACK);
                                break;
                            case 1:
                                text_draw_centered("Speech ON", map_center_x - 160, map_center_y - 4, 224, FONT_NORMAL_GREEN, COLOR_BLACK);
                                break;
                            case 2:
                                text_draw_centered("Sound effects ON", map_center_x - 160, map_center_y + 28, 224, FONT_NORMAL_GREEN, COLOR_BLACK);
                                break;
                            case 3:
                                text_draw_centered("City sounds ON", map_center_x - 160, map_center_y + 60, 224, FONT_NORMAL_GREEN, COLOR_BLACK);
                                break;
                        }
                    } else {
                        switch (i) {
                            case 0:
                                text_draw_centered("Music OFF", map_center_x - 160, map_center_y - 36, 224, FONT_NORMAL_GREEN, COLOR_BLACK);
                                break;
                            case 1:
                                text_draw_centered("Speech OFF", map_center_x - 160, map_center_y - 4, 224, FONT_NORMAL_GREEN, COLOR_BLACK);
                                break;
                            case 2:
                                text_draw_centered("Sound effects OFF", map_center_x - 160, map_center_y + 28, 224, FONT_NORMAL_GREEN, COLOR_BLACK);
                                break;
                            case 3:
                                text_draw_centered("City sounds OFF", map_center_x - 160, map_center_y + 60, 224, FONT_NORMAL_GREEN, COLOR_BLACK);
                                break;
                        }
                    }
                    draw_arrow_button(15, map_center_x + 86, map_center_y - 44 + 32 * i, 2 * i + 1);
                    draw_arrow_button(17, map_center_x + 110, map_center_y - 44 + 32 * i, 2 * i + 2);
                    text_draw_percentage(settings[2 * i + SETTINGS_MUSIC_VOLUME].config_value, map_center_x + 142, map_center_y - 36 + 32 * i, FONT_NORMAL_PLAIN);
                }
                if (current_window_image_button_pressed && current_time > button_last_update_time + BUTTON_REPEAT_DELAY_TIME) {
                    button_last_update_time = current_time;
                    switch (current_window_image_button_pressed) {
                        case 1:
                            settings[SETTINGS_MUSIC_VOLUME].config_value = calc_bound(settings[SETTINGS_MUSIC_VOLUME].config_value + 1, 0, 100);
                            break;
                        case 2:
                            settings[SETTINGS_MUSIC_VOLUME].config_value = calc_bound(settings[SETTINGS_MUSIC_VOLUME].config_value - 1, 0, 100);
                            break;
                        case 3:
                            settings[SETTINGS_SPEECH_VOLUME].config_value = calc_bound(settings[SETTINGS_SPEECH_VOLUME].config_value + 1, 0, 100);
                            break;
                        case 4:
                            settings[SETTINGS_SPEECH_VOLUME].config_value = calc_bound(settings[SETTINGS_SPEECH_VOLUME].config_value - 1, 0, 100);
                            break;
                        case 5:
                            settings[SETTINGS_SOUND_EFFECTS_VOLUME].config_value = calc_bound(settings[SETTINGS_SOUND_EFFECTS_VOLUME].config_value + 1, 0, 100);
                            break;
                        case 6:
                            settings[SETTINGS_SOUND_EFFECTS_VOLUME].config_value = calc_bound(settings[SETTINGS_SOUND_EFFECTS_VOLUME].config_value - 1, 0, 100);
                            break;
                        case 7:
                            settings[SETTINGS_CITY_SOUNDS_VOLUME].config_value = calc_bound(settings[SETTINGS_CITY_SOUNDS_VOLUME].config_value + 1, 0, 100);
                            break;
                        case 8:
                            settings[SETTINGS_CITY_SOUNDS_VOLUME].config_value = calc_bound(settings[SETTINGS_CITY_SOUNDS_VOLUME].config_value - 1, 0, 100);
                            break;
                    }
                }
                break;
            case WINDOW_SPEED_OPTIONS:
                outer_panel_draw(map_center_x - 120, map_center_y - 64, 15, 8);
                text_draw_centered("Speed options", map_center_x - 120, map_center_y - 44, 240, FONT_LARGE_BLACK, COLOR_BLACK);
                text_draw("Game speed", map_center_x - 88, map_center_y - 4, FONT_NORMAL_PLAIN, COLOR_BLACK);
                text_draw("Scroll speed", map_center_x - 88, map_center_y + 28, FONT_NORMAL_PLAIN, COLOR_BLACK);
                for (int i = 0; i < 2; i++) {
                    draw_arrow_button(15, map_center_x + 16, map_center_y - 10 + 32 * i, 2 * i + 1);
                    draw_arrow_button(17, map_center_x + 40, map_center_y - 10 + 32 * i, 2 * i + 2);
                }
                for (int i = 0; i < 2; i++) {
                    text_draw_percentage(settings[SETTINGS_GAME_SPEED + i].config_value, map_center_x + 72, map_center_y - 4 + 32 * i, FONT_NORMAL_PLAIN);
                }
                break;
            case WINDOW_OVERLAY_MENU:
                if (refresh_current_window) {
                    window_city_draw_background();
                    refresh_current_window = 0;
                } else {
                    widget_city_draw();
                    int x_offset = sidebar_x_offset + 4 - OVERLAY_SUBMENUS_X_OFFSET - 160;
                    for (int i = 0; i < OVERLAY_NUM_SUBMENUS; i++) {
                        // label_draw(x_offset, 24 + 3 + (LABEL_IMG_HEIGHT + OVERLAY_SUBMENUS_SPACING) * i, OVERLAY_SUBMENUS_BUTTONS_WIDTH / BLOCK_SIZE, 0);
                        text_draw_centered(
                            overlay_submenus[i].submenu_name,
                            x_offset,
                            24 + 3 + TEXT_Y_OFFSET_FROM_LABEL + (LABEL_IMG_HEIGHT + OVERLAY_SUBMENUS_SPACING) * i,
                            OVERLAY_SUBMENUS_BUTTONS_WIDTH,
                            FONT_NORMAL_GREEN,
                            COLOR_BLACK);
                    }
                    if (overlay_menu_data.selected_submenu && overlay_submenus[overlay_menu_data.selected_submenu - 1].num_items) {
                        for (int i = 0; i < overlay_submenus[overlay_menu_data.selected_submenu - 1].num_items; i++) {
                            // label_draw(x_offset - 170, 24 + 3 + (LABEL_IMG_HEIGHT + OVERLAY_SUBMENUS_SPACING) * (i + overlay_menu_data.selected_submenu - 1), OVERLAY_SUBMENUS_BUTTONS_WIDTH / BLOCK_SIZE, 0);
                            text_draw_centered(
                                overlay_submenus[overlay_menu_data.selected_submenu - 1].item_names[i],
                                x_offset - 170,
                                24 + 3 + TEXT_Y_OFFSET_FROM_LABEL + (LABEL_IMG_HEIGHT + OVERLAY_SUBMENUS_SPACING) * (i + overlay_menu_data.selected_submenu - 1),
                                OVERLAY_SUBMENUS_BUTTONS_WIDTH,
                                FONT_NORMAL_GREEN,
                                COLOR_BLACK);
                        }
                    }
                }
                break;
            case WINDOW_SLIDING_SIDEBAR:
                widget_city_draw();
                widget_slide_data.position += speed_get_delta(&widget_slide_data.slide_speed);
                int is_finished = 0;
                if (widget_slide_data.position >= 162) {
                    widget_slide_data.position = 162;
                    is_finished = 1;
                }
                int x_offset = screen_data.width - 162;
                graphics_set_clip_rectangle(x_offset, 24, 162, screen_data.height - 24);

                if (widget_slide_data.direction == SLIDE_DIRECTION_IN) {
                    if (widget_slide_data.position > SIDEBAR_DECELERATION_OFFSET) {
                        speed_set_target(&widget_slide_data.slide_speed, 1, SLIDE_ACCELERATION_MILLIS, 1);
                    }
                    x_offset += 162 - widget_slide_data.position;
                } else {
                    x_offset += widget_slide_data.position;
                }
                widget_slide_data.back_sidebar_draw();
                widget_slide_data.front_sidebar_draw(x_offset);
                graphics_reset_clip_rectangle();
                if (is_finished) {
                    widget_slide_data.finished_callback();
                }
                break;
            case WINDOW_ADVISOR_LABOR:
                draw_common_advisor_ui();
                if (refresh_current_window) {
                    outer_panel_draw(screen_center_x - 320, screen_center_y - 208, 40, 26);
                    image_draw(1125, screen_center_x - 304, screen_center_y - 192); // labor advisor icon
                    text_draw_centered("Labor Allocation", screen_center_x - 320, screen_center_y - 188, 640, FONT_LARGE_BLACK, COLOR_BLACK);
                    text_draw("Priority", screen_center_x - 272, screen_center_y - 136, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("Sector", screen_center_x - 176, screen_center_y - 136, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("Need", screen_center_x + 148, screen_center_y - 136, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("Have", screen_center_x + 212, screen_center_y - 136, FONT_SMALL_PLAIN, COLOR_BLACK);
                    inner_panel_draw(screen_center_x - 288, screen_center_y - 120, 36, 15);
                    int width = text_draw_number(city_data.labor.workers_employed, 0, 0, screen_center_x - 280, screen_center_y + 128, FONT_NORMAL_BLACK);
                    text_draw("Employed workforce", screen_center_x - 280 + width, screen_center_y + 128, FONT_NORMAL_BLACK, COLOR_BLACK);
                    width += text_draw_number(city_data.labor.workers_unemployed, 0, 0, screen_center_x - 56 + width, screen_center_y + 128, FONT_NORMAL_BLACK);
                    width += text_draw("Unemployed workforce", screen_center_x - 56 + width, screen_center_y + 128, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number(city_data.labor.unemployment_percentage, '(', "%)", screen_center_x - 56 + width, screen_center_y + 128, FONT_NORMAL_BLACK);
                    inner_panel_draw(screen_center_x - 256, screen_center_y + 148, 32, 2);
                    text_draw("Wages", screen_center_x - 246, screen_center_y + 158, FONT_NORMAL_WHITE, COLOR_BLACK);
                    text_draw_number(city_data.labor.wages, 0, 0, screen_center_x - 122, screen_center_y + 158, FONT_NORMAL_WHITE);
                    text_draw("Denarii", screen_center_x - 90, screen_center_y + 158, FONT_NORMAL_WHITE, COLOR_BLACK);
                    text_draw("(Rome pays", screen_center_x - 26, screen_center_y + 158, FONT_NORMAL_WHITE, COLOR_BLACK);
                    text_draw_number(city_data.labor.wages_rome, 0, ")", screen_center_x + 70, screen_center_y + 158, FONT_NORMAL_WHITE);
                    text_draw("Estimated annual bill of", screen_center_x - 256, screen_center_y + 184, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_money(city_data.finance.estimated_wages, screen_center_x - 60, screen_center_y + 184, FONT_NORMAL_BLACK);
                    refresh_current_window = 0;
                }
                // Industry stats
                char *prio_strings[] = {
                    "Industry and Commerce",
                    "Food Production",
                    "Engineering",
                    "Water Services",
                    "Prefectures",
                    "Military",
                    "Entertainment",
                    "Health and Education",
                    "Governance/Religion",
                };
                for (int i = 0; i < 9; i++) {
                    if (mouse_x >= screen_center_x - 280 && mouse_x < screen_center_x + 280 && mouse_y >= screen_center_y - 112 + 25 * i && mouse_y < screen_center_y - 90 + 25 * i) {
                        button_border_draw(screen_center_x - 280, screen_center_y - 112 + 25 * i, 560, 22, 1);
                    } else {
                        button_border_draw(screen_center_x - 280, screen_center_y - 112 + 25 * i, 560, 22, 0);
                    }
                    if (city_data.labor.categories[i].priority) {
                        image_draw(1108, screen_center_x - 272, screen_center_y - 109 + 25 * i); // lock icon
                        text_draw_number(city_data.labor.categories[i].priority, 0, 0, screen_center_x - 256, screen_center_y - 106 + 25 * i, FONT_NORMAL_WHITE);
                    }
                    text_draw(prio_strings[i], screen_center_x - 176, screen_center_y - 106 + 25 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                    text_draw_number(city_data.labor.categories[i].workers_needed, 0, 0, screen_center_x + 152, screen_center_y - 106 + 25 * i, FONT_NORMAL_WHITE);
                    if (city_data.labor.categories[i].workers_needed > city_data.labor.categories[i].workers_allocated) {
                        text_draw_number(city_data.labor.categories[i].workers_allocated, 0, 0, screen_center_x + 216, screen_center_y - 106 + 25 * i, FONT_NORMAL_RED);
                    } else {
                        text_draw_number(city_data.labor.categories[i].workers_allocated, 0, 0, screen_center_x + 216, screen_center_y - 106 + 25 * i, FONT_NORMAL_WHITE);
                    }
                }
                draw_arrow_button(15, screen_center_x - 182, screen_center_y + 152, 1);
                draw_arrow_button(17, screen_center_x - 158, screen_center_y + 152, 2);
                if (current_window_image_button_pressed && current_time > button_last_update_time + BUTTON_REPEAT_DELAY_TIME) {
                    button_last_update_time = current_time;
                    switch (current_window_image_button_pressed) {
                        case 1:
                            modify_wages(1);
                            break;
                        case 2:
                            modify_wages(-1);
                            break;
                    }
                }
                break;
            case WINDOW_LABOR_PRIORITY:
                outer_panel_draw(screen_center_x - 160, screen_center_y - 64, 20, 8);
                // Priority level
                text_draw_centered("Priority level", screen_center_x - 160, screen_center_y - 44, 320, FONT_LARGE_BLACK, COLOR_BLACK);
                char *labor_prio_numbers[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
                for (int i = 0; i < 9; i++) {
                    if (mouse_x >= screen_center_x - 144 + 32 * i && mouse_x < screen_center_x - 117 + 32 * i && mouse_y >= screen_center_y - 8 && mouse_y < screen_center_y + 19) {
                        button_border_draw(screen_center_x - 144 + 32 * i, screen_center_y - 8, 27, 27, 1);
                    } else {
                        button_border_draw(screen_center_x - 144 + 32 * i, screen_center_y - 8, 27, 27, 0);
                    }
                    text_draw_centered(labor_prio_numbers[i], screen_center_x - 144 + 32 * i, screen_center_y - 6, 27, FONT_LARGE_BLACK, COLOR_BLACK);
                    if (i > labor_priority_data.max_items) {
                        graphics_shade_rect(screen_center_x - 144 + 32 * i, screen_center_y - 8, 25, 25, 1);
                    }
                }
                // No priority
                if (mouse_x >= screen_center_x - 80 && mouse_x < screen_center_x + 80 && mouse_y >= screen_center_y + 27 && mouse_y < screen_center_y + 49) {
                    button_border_draw(screen_center_x - 80, screen_center_y + 27, 160, 22, 1);
                } else {
                    button_border_draw(screen_center_x - 80, screen_center_y + 27, 160, 22, 0);
                }
                text_draw_centered("No priority", screen_center_x - 160, screen_center_y + 32, 320, FONT_NORMAL_BLACK, COLOR_BLACK);
                break;
            case WINDOW_ADVISOR_MILITARY:
                draw_common_advisor_ui();
                if (refresh_current_window) {
                    outer_panel_draw(screen_center_x - 320, screen_center_y - 208, 40, 26);
                    image_draw(1126, screen_center_x - 304, screen_center_y - 192); // military advisor icon
                    text_draw_centered("Legion status", screen_center_x - 320, screen_center_y - 188, 640, FONT_LARGE_BLACK, COLOR_BLACK);
                    // if (distant_battle_army_requested) {
                    text_draw_centered("Send relief force", screen_center_x + 128, screen_center_y - 178, 160, FONT_NORMAL_BLACK, COLOR_BLACK);
                    // }
                    text_draw("Morale", screen_center_x - 30, screen_center_y - 140, FONT_SMALL_PLAIN, COLOR_BLACK);
                    // Button headers
                    text_draw("Go to", screen_center_x + 117, screen_center_y - 152, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("legion", screen_center_x + 117, screen_center_y - 140, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("Return", screen_center_x + 170, screen_center_y - 152, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("to fort", screen_center_x + 170, screen_center_y - 140, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("Empire", screen_center_x + 230, screen_center_y - 152, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("service", screen_center_x + 230, screen_center_y - 140, FONT_SMALL_PLAIN, COLOR_BLACK);
                    inner_panel_draw(screen_center_x - 288, screen_center_y - 128, 36, 17);
                    if (city_data.military.total_legions) {
                        int draw_index = 0;
                        for (int i = 0; i < MAX_LEGIONS; i++) {
                            struct formation_t *m = &legion_formations[i];
                            if (m->in_use) {
                                image_draw(5422 + m->id, screen_center_x - 272, screen_center_y - 110 + 44 * draw_index); // legion animal patron icon
                                text_draw(legion_names[m->id], screen_center_x - 228, screen_center_y - 112 + 44 * draw_index, FONT_NORMAL_WHITE, COLOR_BLACK);
                                int width = text_draw_number(m->num_figures, 0, 0, screen_center_x - 228, screen_center_y - 98 + 44 * draw_index, FONT_NORMAL_GREEN);
                                switch (m->figure_type) {
                                    case FIGURE_FORT_LEGIONARY:
                                        text_draw("Legionaries", screen_center_x - 228 + width, screen_center_y - 98 + 44 * draw_index, FONT_NORMAL_GREEN, COLOR_BLACK);
                                        break;
                                    case FIGURE_FORT_MOUNTED:
                                        text_draw("Mounted", screen_center_x - 228 + width, screen_center_y - 98 + 44 * draw_index, FONT_NORMAL_GREEN, COLOR_BLACK);
                                        break;
                                    case FIGURE_FORT_JAVELIN:
                                        text_draw("Javelineer", screen_center_x - 228 + width, screen_center_y - 98 + 44 * draw_index, FONT_NORMAL_GREEN, COLOR_BLACK);
                                        break;
                                }
                                text_draw_centered(legion_morale_strings[m->morale / 5], screen_center_x - 100 + width, screen_center_y - 106 + 44 * draw_index, 150, FONT_NORMAL_GREEN, COLOR_BLACK);
                                image_draw(1433, screen_center_x + 122, screen_center_y - 113 + 44 * draw_index);
                                if (m->is_at_rest || m->in_distant_battle) {
                                    image_draw(1435, screen_center_x + 180, screen_center_y - 113 + 44 * draw_index);
                                } else {
                                    image_draw(1434, screen_center_x + 180, screen_center_y - 113 + 44 * draw_index);
                                }
                                if (m->empire_service) {
                                    image_draw(1436, screen_center_x + 238, screen_center_y - 113 + 44 * draw_index);
                                } else {
                                    image_draw(1437, screen_center_x + 238, screen_center_y - 113 + 44 * draw_index);
                                }
                                draw_index++;
                            }
                        }
                    } else {
                        // You have no legions to command
                        text_draw_multiline("You have no legions to command. You must first build a fort to house a new legion.", screen_center_x - 256, screen_center_y, 544, FONT_NORMAL_GREEN, COLOR_BLACK);
                    }
                    // Enemy threat status
                    image_draw(926, screen_center_x - 288, screen_center_y + 156);
                    if (city_data.figure.enemies) {
                        text_draw("Our enemies are within sight of the city.", screen_center_x - 272, screen_center_y + 156, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.figure.imperial_soldiers) {
                        text_draw("A legion of the Emperor's troops is at our gates.", screen_center_x - 272, screen_center_y + 156, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (scenario.invasion_upcoming) {
                        text_draw("We are getting reports of enemies moving toward the city.", screen_center_x - 272, screen_center_y + 156, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else {
                        text_draw("We have no reports of any threats to the city.", screen_center_x - 272, screen_center_y + 156, FONT_NORMAL_BLACK, COLOR_BLACK);
                    }
                    // Distant battle status
                    image_draw(926, screen_center_x - 288, screen_center_y + 176);
                    if (city_data.distant_battle.roman_months_to_travel_back) {
                        text_draw("Our legion is marching back to our city.", screen_center_x - 272, screen_center_y + 176, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.distant_battle.roman_months_to_travel_forth) {
                        text_draw("Our legion is marching to save an Imperial city.", screen_center_x - 272, screen_center_y + 176, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.distant_battle.months_until_battle) {
                        text_draw("Some of our troops are needed elsewhere in the Empire.", screen_center_x - 272, screen_center_y + 176, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else {
                        text_draw("We have no requests for help across the Empire.", screen_center_x - 272, screen_center_y + 176, FONT_NORMAL_BLACK, COLOR_BLACK);
                    }
                    refresh_current_window = 0;
                }
                if (distant_battle_army_requested) {
                    if (mouse_x >= screen_center_x + 128 && mouse_x < screen_center_x + 288 && mouse_y >= screen_center_y - 184 && mouse_y < screen_center_y - 162) {
                        button_border_draw(screen_center_x + 128, screen_center_y - 184, 160, 22, 0);
                    } else {
                        button_border_draw(screen_center_x + 128, screen_center_y - 184, 160, 22, 0);
                    }
                }
                for (int i = 0; i < city_data.military.total_legions; i++) {
                    if (mouse_x >= screen_center_x - 280 && mouse_x < screen_center_x + 280
                    && mouse_y >= screen_center_y - 120 + 44 * i && mouse_y < screen_center_y - 80 + 44 * i) {
                        button_border_draw(screen_center_x - 280, screen_center_y - 120 + 44 * i, 560, 40, 1);
                    } else {
                        button_border_draw(screen_center_x - 280, screen_center_y - 120 + 44 * i, 560, 40, 0);
                    }
                }
                for (int i = 0; i < city_data.military.total_legions; i++) {
                    for (int j = 0; j < 3; j++) {
                        if (mouse_x >= screen_center_x + 120 + 58 * j && mouse_x < screen_center_x + 150 + 58 * j
                        && mouse_y >= screen_center_y - 115 + 44 * i && mouse_y < screen_center_y - 85 + 44 * i) {
                            button_border_draw(screen_center_x + 120 + 58 * j, screen_center_y - 115 + 44 * i, 30, 30, 1);
                        } else {
                            button_border_draw(screen_center_x + 120 + 58 * j, screen_center_y - 115 + 44 * i, 30, 30, 0);
                        }
                    }
                }
                break;
            case WINDOW_ADVISOR_IMPERIAL:
                if (refresh_current_window) {
                    draw_common_advisor_ui();
                    outer_panel_draw(screen_center_x - 320, screen_center_y - 216, 40, 27);
                    image_draw(1127, screen_center_x - 304, screen_center_y - 192); // imperial advisor icon
                    text_draw(scenario_settings.player_name, screen_center_x - 248, screen_center_y - 196, FONT_LARGE_BLACK, COLOR_BLACK);
                    int width = text_draw("Imperial favor", screen_center_x - 248, screen_center_y - 168, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number(city_data.ratings.favor, 0, 0, screen_center_x - 248 + width, screen_center_y - 168, FONT_NORMAL_BLACK);
                    if (city_data.ratings.favor < 5) {
                        text_draw_multiline("The Emperor is so incredibly angry, he is talking about exiling you!", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.ratings.favor < 10) {
                        text_draw_multiline("The Emperor is furious with you!", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.ratings.favor < 15) {
                        text_draw_multiline("The Emperor is extremely angry with you.", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.ratings.favor < 20) {
                        text_draw_multiline("The Emperor is very angry with you.", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.ratings.favor < 25) {
                        text_draw_multiline("The Emperor is angry with you.", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.ratings.favor < 30) {
                        text_draw_multiline("The Emperor is extremely displeased with you.", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.ratings.favor < 35) {
                        text_draw_multiline("The Emperor is most displeased with you.", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.ratings.favor < 40) {
                        text_draw_multiline("The Emperor is displeased with you.", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.ratings.favor < 45) {
                        text_draw_multiline("The Emperor is slightly displeased with you.", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.ratings.favor < 50) {
                        text_draw_multiline("The Emperor is a little concerned with you.", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.ratings.favor < 55) {
                        text_draw_multiline("The Emperor is ambivalent toward you.", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.ratings.favor < 60) {
                        text_draw_multiline("The Emperor thinks you may prove satisfactory.", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.ratings.favor < 65) {
                        text_draw_multiline("The Emperor is satisfied with you.", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.ratings.favor < 70) {
                        text_draw_multiline("The Emperor is more than satisfied with your performance.", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.ratings.favor < 75) {
                        text_draw_multiline("The Emperor is pleased with your performance.", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.ratings.favor < 80) {
                        text_draw_multiline("The Emperor is very pleased with your performance.", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.ratings.favor < 85) {
                        text_draw_multiline("The Emperor is excited with your performance.", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.ratings.favor < 90) {
                        text_draw_multiline("The Emperor is very excited with your performance.", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.ratings.favor < 95) {
                        text_draw_multiline("The Emperor is extremely excited with your performance.", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.ratings.favor < 100) {
                        text_draw_multiline("The Emperor is overjoyed with your performance.", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.ratings.favor == 100) {
                        text_draw_multiline("The Emperor is so incredibly pleased, he is talking about naming you as his heir!", screen_center_x - 248, screen_center_y - 152, 544, FONT_NORMAL_BLACK, COLOR_BLACK);
                    }
                    inner_panel_draw(screen_center_x - 280, screen_center_y - 128, 35, 14);
                    advisor_emperor_request_index = 0;
                    // draw distant battle army request
                    // if (city_data.distant_battle.months_until_battle && !city_data.distant_battle.roman_months_to_travel_forth) {
                    //     image_draw(resource_images[RESOURCE_WEAPONS].icon_img_id, screen_center_x - 256, screen_center_y - 112);
                    //     width = text_draw("Dispatch troops to protect", screen_center_x - 232, screen_center_y - 112, FONT_NORMAL_WHITE, COLOR_BLACK);
                    //     text_draw(city_names[empire_objects[city_data.distant_battle.city].city_name_id], screen_center_x - 232 + width, screen_center_y - 112, FONT_NORMAL_WHITE, COLOR_BLACK);
                    //     if (city_data.distant_battle.enemy_strength < 46) {
                    //         width = text_draw("A small force will attack in", screen_center_x - 232, screen_center_y - 96, FONT_NORMAL_WHITE, COLOR_BLACK);
                    //     } else if (city_data.distant_battle.enemy_strength < 89) {
                    //         width = text_draw("An average force will attack in", screen_center_x - 232, screen_center_y - 96, FONT_NORMAL_WHITE, COLOR_BLACK);
                    //     } else {
                    //         width = text_draw("A large force will attack in", screen_center_x - 232, screen_center_y - 96, FONT_NORMAL_WHITE, COLOR_BLACK);
                    //     }
                    //     text_draw_number(city_data.distant_battle.months_until_battle, 0, " months", screen_center_x - 232 + width, screen_center_y - 96, FONT_NORMAL_WHITE);
                    //     advisor_emperor_request_index++;
                    // }
                    for (int i = 0; i < MAX_REQUESTS; i++) {
                        if (advisor_emperor_request_index <= MAX_REQUESTS_SHOWN && scenario.requests[i].resource && scenario.requests[i].visible) {
                            width = text_draw_number(scenario.requests[i].amount, 0, 0, screen_center_x - 256, screen_center_y - 112 + 42 * advisor_emperor_request_index, FONT_NORMAL_WHITE);
                            image_draw(resource_images[scenario.requests[i].resource].icon_img_id + resource_image_offset(scenario.requests[i].resource, RESOURCE_IMAGE_ICON), screen_center_x - 256 + width, screen_center_y - 115 + 42 * advisor_emperor_request_index);
                            text_draw(resource_strings[scenario.requests[i].resource], screen_center_x - 230 + width, screen_center_y - 112 + 42 * advisor_emperor_request_index, FONT_NORMAL_WHITE, COLOR_BLACK);
                            text_draw_number(scenario.requests[i].months_to_comply, 0, " months to comply", screen_center_x - 8, screen_center_y - 106 + 42 * advisor_emperor_request_index, FONT_NORMAL_WHITE);
                            if (scenario.requests[i].resource == RESOURCE_DENARII) {
                                // request for money
                                text_draw_number(city_data.finance.treasury, 0, " in city treasuries", screen_center_x - 256, screen_center_y - 96 + 42 * advisor_emperor_request_index, FONT_NORMAL_WHITE);
                            } else {
                                // normal goods request
                                text_draw_number(city_data.resource.stored_in_warehouses[scenario.requests[i].resource], 0, " in warehouses", screen_center_x - 256, screen_center_y - 96 + 42 * advisor_emperor_request_index, FONT_NORMAL_WHITE);
                            }
                            advisor_emperor_request_index++;
                        }
                    }
                    if (!advisor_emperor_request_index) {
                        text_draw_multiline("The Emperor is not requesting anything from you at the moment.", screen_center_x - 264, screen_center_y - 26, 512, FONT_NORMAL_WHITE, COLOR_BLACK);
                    }
                    inner_panel_draw(screen_center_x - 256, screen_center_y + 104, 32, 6);
                    text_draw(initial_rank_strings[city_data.emperor.player_rank], screen_center_x - 248, screen_center_y + 112, FONT_LARGE_BROWN, COLOR_BLACK);
                    width = text_draw("Savings of", screen_center_x - 248, screen_center_y + 146, FONT_NORMAL_WHITE, COLOR_BLACK);
                    text_draw_money(city_data.emperor.personal_savings, screen_center_x - 248 + width, screen_center_y + 146, FONT_NORMAL_WHITE);
                    text_draw_centered("Send a gift", screen_center_x - 8, screen_center_y + 117, 240, FONT_NORMAL_WHITE, COLOR_BLACK);
                    text_draw_centered("Give to city", screen_center_x - 8, screen_center_y + 145, 240, FONT_NORMAL_WHITE, COLOR_BLACK);
                    width = text_draw(initial_rank_strings[city_data.emperor.salary_rank], screen_center_x - 176, screen_center_y + 173, FONT_NORMAL_WHITE, COLOR_BLACK);
                    width += text_draw("'s salary of", screen_center_x - 176 + width, screen_center_y + 173, FONT_NORMAL_WHITE, COLOR_BLACK);
                    width += text_draw_number(city_data.emperor.salary_amount, 0, 0, screen_center_x - 176 + width, screen_center_y + 173, FONT_NORMAL_WHITE);
                    text_draw("Denarii per month", screen_center_x - 176 + width, screen_center_y + 173, FONT_NORMAL_WHITE, COLOR_BLACK);
                    refresh_current_window = 0;
                }
                for (int i = 0; i < advisor_emperor_request_index; i++) {
                    if (mouse_x >= screen_center_x - 272 && mouse_x < screen_center_x + 272 && mouse_y >= screen_center_y - 120 + 42 * i && mouse_y < screen_center_y - 80 + 42 * i) {
                        button_border_draw(screen_center_x - 272, screen_center_y - 120 + 42 * i, 544, 40, 1);
                    } else {
                        button_border_draw(screen_center_x - 272, screen_center_y - 120 + 42 * i, 544, 40, 0);
                    }
                }
                if (mouse_x >= screen_center_x - 8 && mouse_x < screen_center_x + 232 && mouse_y >= screen_center_y + 112 && mouse_y < screen_center_y + 132) {
                    button_border_draw(screen_center_x - 8, screen_center_y + 112, 240, 20, 1);
                } else {
                    button_border_draw(screen_center_x - 8, screen_center_y + 112, 240, 20, 0);
                }
                if (mouse_x >= screen_center_x - 8 && mouse_x < screen_center_x + 232 && mouse_y >= screen_center_y + 140 && mouse_y < screen_center_y + 160) {
                    button_border_draw(screen_center_x - 8, screen_center_y + 140, 240, 20, 1);
                } else {
                    button_border_draw(screen_center_x - 8, screen_center_y + 140, 240, 20, 0);
                }
                if (mouse_x >= screen_center_x - 248 && mouse_x < screen_center_x + 248 && mouse_y >= screen_center_y + 168 && mouse_y < screen_center_y + 188) {
                    button_border_draw(screen_center_x - 248, screen_center_y + 168, 496, 20, 1);
                } else {
                    button_border_draw(screen_center_x - 248, screen_center_y + 168, 496, 20, 0);
                }
                break;
            case WINDOW_ADVISOR_RATINGS:
                if (refresh_current_window) {
                    draw_common_advisor_ui();
                    outer_panel_draw(screen_center_x - 320, screen_center_y - 216, 40, 27);
                    image_draw(1128, screen_center_x - 304, screen_center_y - 200); // ratings advisor icon
                    text_draw_centered("Ratings", screen_center_x - 304, screen_center_y - 196, 640, FONT_LARGE_BLACK, COLOR_BLACK);
                    image_draw(7763, screen_center_x - 260, screen_center_y - 162); // background image
                    // culture
                    draw_rating_column(screen_center_x - 217, screen_center_y + 62, city_data.ratings.culture, city_data.ratings.culture >= scenario.culture_win_criteria);
                    text_draw_centered("Culture", screen_center_x - 244, screen_center_y + 83, 110, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number_centered(city_data.ratings.culture, screen_center_x - 244, screen_center_y + 98, 110, FONT_LARGE_BLACK);
                    text_draw_number(scenario.culture_win_criteria, 0, " Needed", screen_center_x - 232, screen_center_y + 124, FONT_NORMAL_BLACK);
                    // prosperity
                    draw_rating_column(screen_center_x - 91, screen_center_y + 62, city_data.ratings.prosperity, city_data.ratings.prosperity >= scenario.prosperity_win_criteria);
                    text_draw_centered("Prosperity", screen_center_x - 118, screen_center_y + 83, 110, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number_centered(city_data.ratings.prosperity, screen_center_x - 118, screen_center_y + 98, 110, FONT_LARGE_BLACK);
                    text_draw_number(scenario.prosperity_win_criteria, 0, " Needed", screen_center_x - 106, screen_center_y + 124, FONT_NORMAL_BLACK);
                    // peace
                    draw_rating_column(screen_center_x + 35, screen_center_y + 62, city_data.ratings.peace, city_data.ratings.peace >= scenario.peace_win_criteria);
                    text_draw_centered("Peace", screen_center_x + 8, screen_center_y + 83, 110, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number_centered(city_data.ratings.peace, screen_center_x + 8, screen_center_y + 98, 110, FONT_LARGE_BLACK);
                    text_draw_number(scenario.peace_win_criteria, 0, " Needed", screen_center_x + 20, screen_center_y + 124, FONT_NORMAL_BLACK);
                    // favor
                    draw_rating_column(screen_center_x + 161, screen_center_y + 62, city_data.ratings.favor, city_data.ratings.favor >= scenario.favor_win_criteria);
                    text_draw_centered("Peace", screen_center_x + 134, screen_center_y + 83, 110, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number_centered(city_data.ratings.favor, screen_center_x + 134, screen_center_y + 98, 110, FONT_LARGE_BLACK);
                    text_draw_number(scenario.favor_win_criteria, 0, " Needed", screen_center_x + 146, screen_center_y + 124, FONT_NORMAL_BLACK);
                    // bottom info box
                    inner_panel_draw(screen_center_x - 252, screen_center_y + 143, 32, 4);
                    switch (city_data.ratings.selected) {
                        case SELECTED_RATING_CULTURE:
                            text_draw("Culture", screen_center_x - 244, screen_center_y + 151, FONT_NORMAL_WHITE, COLOR_BLACK);
                            if (city_data.ratings.culture <= 90) {
                                switch (city_data.ratings.culture_explanation) {
                                    case 0:
                                        text_draw_multiline("You have no culture in your city, ergo (that's Latin for therefore!) you have no Culture rating.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 1:
                                        text_draw_multiline("You have too few schools working in your city. Building more would improve this rating.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 2:
                                        text_draw_multiline("You have too few libraries working in your city. Building more would improve this rating.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 3:
                                        text_draw_multiline("You have too few academies working in your city. Building more would improve this rating.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 4:
                                        text_draw_multiline("You have too few places of worship in your city. Building more would improve this rating.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 5:
                                        text_draw_multiline("You have too few theaters working in your city. Building more would improve this rating.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;

                                }
                            } else {
                                text_draw_multiline("This city is more cultured than any in the Empire!", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                            }
                            break;
                        case SELECTED_RATING_PROSPERITY:
                            text_draw("Prosperity", screen_center_x - 244, screen_center_y + 151, FONT_NORMAL_WHITE, COLOR_BLACK);
                            if (city_data.ratings.prosperity <= 90) {
                                switch (city_data.ratings.prosperity_explanation) {
                                    case 0:
                                        text_draw_multiline("It is the dawn of your city. We have had no chance to assess your Prosperity yet!", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 1:
                                        text_draw_multiline("The overall quality of your city's housing holds this rating back. Improve the housing in your city to raise this rating.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 2:
                                        text_draw_multiline("Your Prosperity rating is rising.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 3:
                                        text_draw_multiline("Last year your city lost money - this reduced the city's prosperity.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 4:
                                        text_draw_multiline("High unemployment in your city retards your Prosperity rating.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 5:
                                        text_draw_multiline("Paying wages lower than Rome's tarnishes your city's image as a prosperous one.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 6:
                                        text_draw_multiline("The high concentration of slum dwellers in your city lends it the appearance of a poor one.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 7:
                                        text_draw_multiline("Your inability to pay the annual tribute to Rome marks your city out as a failure.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 8:
                                        text_draw_multiline("The fact that the Emperor recently had to bail you out of trouble hits hard at your city's reputation as a prosperous one.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 9:
                                        text_draw_multiline("There is no change in this rating this year. Showing a profit in your city's annual accounts is the best way to increase your Prosperity rating.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                }
                            } else {
                                text_draw_multiline("The amazing prosperity of this city is the talk of Rome!", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                            }
                            break;
                        case SELECTED_RATING_PEACE:
                            text_draw("Peace", screen_center_x - 244, screen_center_y + 151, FONT_NORMAL_WHITE, COLOR_BLACK);
                            if (city_data.ratings.peace <= 90) {
                                switch (city_data.ratings.peace_explanation) {
                                    case 0:
                                        text_draw_multiline("The Peace rating will rise every year that there are no riots or invasions that damage city property.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 1:
                                        text_draw_multiline("This province has been peaceful for a short time, but your citizens do not yet feel very save. More peaceful years will improve this.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 2:
                                        text_draw_multiline("This province feels reasonably peaceful, a sentiment which will improve with time.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 3:
                                        text_draw_multiline("This is a law-abiding province and, given time, could become very peaceful.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 4:
                                        text_draw_multiline("Overall, this has become a sleepy province with few real threats - just how the inhabitants like it!", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 5:
                                        text_draw_multiline("Your province's quiet and secure existence is legendary. Other governors are probably already planning their retirement here!", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 6:
                                        text_draw_multiline("The recent riots in the city had a bad effect on your city's overall peace rating.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 7:
                                        text_draw_multiline("The enemy soldiers in the city's environs do not help your peace rating!", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 8:
                                        text_draw_multiline("The approaching Imperial legions are frightening your citizens, and will do no good to your peace rating.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                }
                            } else {
                                text_draw_multiline("The Empire has never seen a city this peaceful before!", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                            }
                            break;
                        case SELECTED_RATING_FAVOR:
                            text_draw("Favor", screen_center_x - 244, screen_center_y + 151, FONT_NORMAL_WHITE, COLOR_BLACK);
                            if (city_data.ratings.favor <= 90) {
                                switch (city_data.ratings.favor_explanation) {
                                    case 0:
                                        text_draw_multiline("Your Favor rating with Rome is dropping. You must catch Caesar's attention - somehow!", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 1:
                                        text_draw_multiline("The ridiculously high salary you pay yourself angers the senate. All Rome is talking about your bare-faced greed.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 2:
                                        text_draw_multiline("Your continued inability to provide a tribute to Rome damages your reputation there.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 3:
                                        text_draw_multiline("The Imperial request you recently cancelled has badly affected your standing in Rome.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 4:
                                        text_draw_multiline("The salary that you pay yourself, far exceeding your rank, is a source of great displeasure in Rome.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 5:
                                        text_draw_multiline("For the second year in a row, you have not paid a tribute to Rome. This is becoming a big problem for your future career.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 6:
                                        text_draw_multiline("Missing the recent Imperial request, through inability or willful neglect, harmed your standing in Rome a little. Your Favor rating would have risen had you complied.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 7:
                                        text_draw_multiline("Rome thinks your salary is too high for your current standing. Your Favor will rise if you reduce it a little.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 8:
                                        text_draw_multiline("You could not pay your tribute this year, which reduced your Favor. Keep some money in your treasury at year's end, so that you can make your annual payment to Rome.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 9:
                                        text_draw_multiline("Rome thinks your salary too high for your current standing. You would do well to reduce it a little.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 10:
                                        text_draw_multiline("Your slow progress toward meeting the goals that Rome has set you annoys the Senate and has reduced your Favor.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 11:
                                        text_draw_multiline("Your cheek in paying yourself a salary higher than your rank entitles you to is frowned upon in Rome.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 12:
                                        text_draw_multiline("Your standing in Rome has increased from last year.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                    case 13:
                                        text_draw_multiline("Your standing is unchanged from last year.", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                                        break;
                                }
                            } else {
                                text_draw_multiline("Caesar has higher respect for you than for any other governor ever!", screen_center_x - 244, screen_center_y + 169, 496, FONT_NORMAL_WHITE, COLOR_BLACK);
                            }
                            break;
                    }
                    refresh_current_window = 0;
                }
                for (int i = 0; i < 4; i++) {
                    if (mouse_x >= screen_center_x - 244 + 126 * i && mouse_x < screen_center_x - 134 + 126 * i && mouse_y >= screen_center_y + 75 && mouse_y < screen_center_y + 141) {
                        button_border_draw(screen_center_x - 244 + 126 * i, screen_center_y + 75, 110, 66, 1);
                    } else {
                        button_border_draw(screen_center_x - 244 + 126 * i, screen_center_y + 75, 110, 66, 0);
                    }
                }
                break;
            case WINDOW_ADVISOR_TRADE:
                if (refresh_current_window) {
                    draw_common_advisor_ui();
                    city_resource_determine_available();
                    outer_panel_draw(screen_center_x - 320, screen_center_y - 216, 40, 27);
                    image_draw(1129, screen_center_x - 304, screen_center_y - 200);
                    text_draw_centered("Trade Advisor", screen_center_x - 320, screen_center_y - 196, 640, FONT_LARGE_BLACK, COLOR_BLACK);
                    text_draw_centered("Show prices", screen_center_x - 288, screen_center_y + 188, 192, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered("Go to the empire", screen_center_x + 95, screen_center_y + 188, 192, FONT_NORMAL_BLACK, COLOR_BLACK);
                    refresh_current_window = 0;
                }
                inner_panel_draw(screen_center_x - 288, screen_center_y - 156, 36, 21);
                for (int i = 0; i < available.resource_list.size; i++) {
                    image_draw(resource_images[available.resource_list.items[i]].icon_img_id + resource_image_offset(available.resource_list.items[i], RESOURCE_IMAGE_ICON), screen_center_x - 280, screen_center_y - 153 + 22 * i);
                    image_draw(resource_images[available.resource_list.items[i]].icon_img_id + resource_image_offset(available.resource_list.items[i], RESOURCE_IMAGE_ICON), screen_center_x + 255, screen_center_y - 153 + 22 * i);
                    text_draw(resource_strings[available.resource_list.items[i]], screen_center_x - 250, screen_center_y - 148 + 22 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                    text_draw_number_centered(city_data.resource.stored_in_warehouses[available.resource_list.items[i]], screen_center_x - 138, screen_center_y - 148 + 22 * i, 60, FONT_NORMAL_WHITE);
                    if (city_data.resource.mothballed[available.resource_list.items[i]]) {
                        text_draw_centered("OFF", screen_center_x - 82, screen_center_y - 148 + 22 * i, 100, FONT_NORMAL_WHITE, COLOR_BLACK);
                    }
                    if (city_data.resource.stockpiled[available.resource_list.items[i]]) {
                        text_draw("Stockpiling", screen_center_x + 24, screen_center_y - 148 + 22 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                    } else {
                        if (city_data.resource.trade_status[available.resource_list.items[i]] == TRADE_STATUS_IMPORT) {
                            text_draw("Importing", screen_center_x - 82, screen_center_y - 148 + 22 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                        } else if (city_data.resource.trade_status[available.resource_list.items[i]] == TRADE_STATUS_EXPORT) {
                            int width = text_draw("Exports over", screen_center_x - 82, screen_center_y - 148 + 22 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                            text_draw_number(city_data.resource.export_over[available.resource_list.items[i]], 0, 0, screen_center_x - 82 + width, screen_center_y - 148 + 22 * i, FONT_NORMAL_WHITE);
                        }
                    }
                }
                for (int i = 0; i < available.resource_list.size; i++) {
                    if (mouse_x >= screen_center_x - 255 && mouse_x < screen_center_x + 241 && mouse_y >= screen_center_y - 154 + 22 * i && mouse_y < screen_center_y - 132 + 22 * i) {
                        button_border_draw(screen_center_x - 255, screen_center_y - 154 + 22 * i, 496, 22, 1);
                    }
                }
                if (mouse_x >= screen_center_x - 288 && mouse_x < screen_center_x - 96 && mouse_y >= screen_center_y + 182 && mouse_y < screen_center_y + 206) {
                    button_border_draw(screen_center_x - 288, screen_center_y + 182, 192, 24, 1);
                } else {
                    button_border_draw(screen_center_x - 288, screen_center_y + 182, 192, 24, 0);
                }
                if (mouse_x >= screen_center_x + 95 && mouse_x < screen_center_x + 287 && mouse_y >= screen_center_y + 182 && mouse_y < screen_center_y + 206) {
                    button_border_draw(screen_center_x + 95, screen_center_y + 182, 192, 24, 1);
                } else {
                    button_border_draw(screen_center_x + 95, screen_center_y + 182, 192, 24, 0);
                }
                break;
            case WINDOW_ADVISOR_POPULATION:
                if (refresh_current_window) {
                    draw_common_advisor_ui();
                    outer_panel_draw(screen_center_x - 320, screen_center_y - 216, 40, 27);
                    image_draw(1130, screen_center_x - 304, screen_center_y - 200); // population advisor icon
                    if (city_data.population.graph_order < 2) {
                        text_draw_centered("Population - History", screen_center_x - 320, screen_center_y - 196, 640, FONT_LARGE_BLACK, COLOR_BLACK);
                    } else if (city_data.population.graph_order < 4) {
                        text_draw_centered("Population - Census", screen_center_x - 320, screen_center_y - 196, 640, FONT_LARGE_BLACK, COLOR_BLACK);
                    } else {
                        text_draw_centered("Population - Society", screen_center_x - 320, screen_center_y - 196, 640, FONT_LARGE_BLACK, COLOR_BLACK);
                    }
                    image_draw(7751, screen_center_x - 256, screen_center_y - 144); // background panel image
                    switch (city_data.population.graph_order) {
                        default:
                        case 0:
                            text_draw_centered("City population over time", screen_center_x - 248, screen_center_y + 72, 400, FONT_NORMAL_BLACK, COLOR_BLACK);
                            text_draw_centered("Census", screen_center_x + 192, screen_center_y - 84, 100, FONT_NORMAL_BLACK, COLOR_BLACK);
                            text_draw_centered("Society", screen_center_x + 192, screen_center_y + 16, 100, FONT_NORMAL_BLACK, COLOR_BLACK);
                            draw_history_graph(1, screen_center_x - 248, screen_center_y - 140);
                            draw_census_graph(0, screen_center_x + 188, screen_center_y - 145);
                            draw_society_graph(0, screen_center_x + 188, screen_center_y - 45);
                            break;
                        case 1:
                            text_draw_centered("City population over time", screen_center_x - 248, screen_center_y + 72, 400, FONT_NORMAL_BLACK, COLOR_BLACK);
                            text_draw_centered("Society", screen_center_x + 192, screen_center_y - 84, 100, FONT_NORMAL_BLACK, COLOR_BLACK);
                            text_draw_centered("Census", screen_center_x + 192, screen_center_y + 16, 100, FONT_NORMAL_BLACK, COLOR_BLACK);
                            draw_history_graph(1, screen_center_x - 248, screen_center_y - 140);
                            draw_society_graph(0, 511, 63);
                            draw_census_graph(0, 511, 163);
                            break;
                        case 2:
                            text_draw_centered("Population composition by age (in years)", screen_center_x - 248, screen_center_y + 92, 400, FONT_NORMAL_BLACK, COLOR_BLACK);
                            text_draw_centered("History", screen_center_x + 192, screen_center_y - 84, 100, FONT_NORMAL_BLACK, COLOR_BLACK);
                            text_draw_centered("Society", screen_center_x + 192, screen_center_y + 16, 100, FONT_NORMAL_BLACK, COLOR_BLACK);
                            draw_census_graph(1, screen_center_x - 248, screen_center_y - 140);
                            draw_history_graph(0, 511, 63);
                            draw_society_graph(0, 511, 163);
                            break;
                        case 3:
                            text_draw_centered("Population composition by age (in years)", screen_center_x - 248, screen_center_y + 92, 400, FONT_NORMAL_BLACK, COLOR_BLACK);
                            text_draw_centered("Society", screen_center_x + 192, screen_center_y - 84, 100, FONT_NORMAL_BLACK, COLOR_BLACK);
                            text_draw_centered("History", screen_center_x + 192, screen_center_y + 16, 100, FONT_NORMAL_BLACK, COLOR_BLACK);
                            draw_census_graph(1, screen_center_x - 248, screen_center_y - 140);
                            draw_society_graph(0, 511, 63);
                            draw_history_graph(0, 511, 163);
                            break;
                        case 4:
                            text_draw_centered("Population composition by income", screen_center_x - 248, screen_center_y + 92, 400, FONT_NORMAL_BLACK, COLOR_BLACK);
                            text_draw_centered("History", screen_center_x + 192, screen_center_y - 84, 100, FONT_NORMAL_BLACK, COLOR_BLACK);
                            text_draw_centered("Census", screen_center_x + 192, screen_center_y + 16, 100, FONT_NORMAL_BLACK, COLOR_BLACK);
                            draw_society_graph(1, screen_center_x - 248, screen_center_y - 140);
                            draw_history_graph(0, 511, 63);
                            draw_census_graph(0, 511, 163);
                            break;
                        case 5:
                            text_draw_centered("Population composition by income", screen_center_x - 248, screen_center_y + 92, 400, FONT_NORMAL_BLACK, COLOR_BLACK);
                            text_draw_centered("Census", screen_center_x + 192, screen_center_y - 84, 100, FONT_NORMAL_BLACK, COLOR_BLACK);
                            text_draw_centered("History", screen_center_x + 192, screen_center_y + 16, 100, FONT_NORMAL_BLACK, COLOR_BLACK);
                            draw_society_graph(1, screen_center_x - 248, screen_center_y - 140);
                            draw_census_graph(0, 511, 63);
                            draw_history_graph(0, 511, 163);
                            break;
                    }
                    // food/migration info panel
                    inner_panel_draw(screen_center_x - 272, screen_center_y + 124, 34, 5);
                    int width;
                    for (int i = 0; i < 4; i++) {
                        image_draw(926, screen_center_x - 264, screen_center_y + 132 + 18 * i);
                    }
                    // food stores
                    if (scenario.rome_supplies_wheat) {
                        text_draw("Rome provides all the food for this city", screen_center_x - 245, screen_center_y + 132, FONT_NORMAL_WHITE, COLOR_BLACK);
                    } else {
                        width = text_draw_number(city_data.resource.granaries.operating, 0, " Granaries hold", screen_center_x - 245, screen_center_y + 132, FONT_NORMAL_WHITE);
                        if (city_data.resource.food_supply_months) {
                            width += text_draw("food for", screen_center_x - 245 + width, screen_center_y + 132, FONT_NORMAL_WHITE, COLOR_BLACK);
                            text_draw_number(city_data.resource.food_supply_months, 0, "Months", screen_center_x - 245 + width, screen_center_y + 132, FONT_NORMAL_WHITE);
                        } else if (city_data.resource.granary_total_stored > city_data.resource.food_needed_per_month / 2) {
                            text_draw("some food for the coming month", screen_center_x - 245 + width, screen_center_y + 132, FONT_NORMAL_WHITE, COLOR_BLACK);
                        } else if (city_data.resource.granary_total_stored) {
                            text_draw("very little food for the coming month", screen_center_x - 245 + width, screen_center_y + 132, FONT_NORMAL_WHITE, COLOR_BLACK);
                        } else {
                            text_draw("no food for the coming month", screen_center_x - 245 + width, screen_center_y + 132, FONT_NORMAL_WHITE, COLOR_BLACK);
                        }
                    }
                    // food types eaten
                    width = text_draw("Varieties of food eaten:", screen_center_x - 245, screen_center_y + 150, FONT_NORMAL_WHITE, COLOR_BLACK);
                    text_draw_number(city_data.resource.food_types_available, 0, 0, screen_center_x - 245 + width, screen_center_y + 150, FONT_NORMAL_WHITE);
                    // immigration
                    if (city_data.migration.newcomers >= 5) {
                        text_draw("Overall, people are coming, or wish to come to, your city.", screen_center_x - 245, screen_center_y + 168, FONT_NORMAL_WHITE, COLOR_BLACK);
                        width = text_draw_number(city_data.migration.newcomers, 0, 0, screen_center_x - 245, screen_center_y + 186, FONT_NORMAL_WHITE);
                        text_draw("newcomers arrived this month", screen_center_x - 245 + width, 396, FONT_NORMAL_WHITE, COLOR_BLACK);
                    } else if (city_migration_no_room_for_immigrants()) {
                        text_draw("Overall, people are coming, or wish to come to, your city.", screen_center_x - 245, screen_center_y + 168, FONT_NORMAL_WHITE, COLOR_BLACK);
                        text_draw("Lack of empty housing limits immigration.", screen_center_x - 245, screen_center_y + 186, FONT_NORMAL_WHITE, COLOR_BLACK);
                    } else if (city_data.migration.percentage < 80) {
                        text_draw("Overall, people are leaving your city.", screen_center_x - 245, screen_center_y + 168, FONT_NORMAL_WHITE, COLOR_BLACK);
                        switch (city_data.migration.no_immigration_cause) {
                            case NO_IMMIGRATION_LOW_WAGES:
                                text_draw("Low wages reduce immigration to your city.", screen_center_x - 245, screen_center_y + 186, FONT_NORMAL_WHITE, COLOR_BLACK);
                                break;
                            case NO_IMMIGRATION_NO_JOBS:
                                text_draw("Unemployment reduces your number of immigrants.", screen_center_x - 245, screen_center_y + 186, FONT_NORMAL_WHITE, COLOR_BLACK);
                                break;
                            case NO_IMMIGRATION_NO_FOOD:
                                text_draw("Lack of food in your granaries is reducing immigration.", screen_center_x - 245, screen_center_y + 186, FONT_NORMAL_WHITE, COLOR_BLACK);
                                break;
                            case NO_IMMIGRATION_HIGH_TAXES:
                                text_draw("High taxes are keeping some people away from your city.", screen_center_x - 245, screen_center_y + 186, FONT_NORMAL_WHITE, COLOR_BLACK);
                                break;
                            case NO_IMMIGRATION_MANY_TENTS:
                                text_draw("Poor housing, despite your city's wealth, discourages immigrants.", screen_center_x - 245, screen_center_y + 186, FONT_NORMAL_WHITE, COLOR_BLACK);
                                break;
                            case NO_IMMIGRATION_LOW_MOOD:
                                text_draw("Nobody wants to live in your city.", screen_center_x - 245, screen_center_y + 186, FONT_NORMAL_WHITE, COLOR_BLACK);
                                break;
                            default:
                                break;
                        }
                    } else {
                        text_draw("Overall, people are coming, or wish to come to, your city.", screen_center_x - 245, screen_center_y + 168, FONT_NORMAL_WHITE, COLOR_BLACK);
                        width = text_draw_number(city_data.migration.newcomers, 0, 0, screen_center_x - 245, screen_center_y + 186, FONT_NORMAL_WHITE);
                        text_draw("newcomers arrived this month", screen_center_x - 245 + width, 396, FONT_NORMAL_WHITE, COLOR_BLACK);
                    }
                    refresh_current_window = 0;
                }
                if (mouse_x >= screen_center_x + 188 && mouse_x < screen_center_x + 294 && mouse_y >= screen_center_y - 145 && mouse_y < screen_center_y - 88) {
                    button_border_draw(screen_center_x + 188, screen_center_y - 145, 106, 57, 1);
                } else {
                    button_border_draw(screen_center_x + 188, screen_center_y - 145, 106, 57, 0);
                }
                if (mouse_x >= screen_center_x + 188 && mouse_x < screen_center_x + 294 && mouse_y >= screen_center_y - 45 && mouse_y < screen_center_y + 12) {
                    button_border_draw(screen_center_x + 188, screen_center_y - 45, 106, 57, 1);
                } else {
                    button_border_draw(screen_center_x + 188, screen_center_y - 45, 106, 57, 0);
                }
                break;
            case WINDOW_ADVISOR_HEALTH:
                if (refresh_current_window) {
                    draw_common_advisor_ui();
                    outer_panel_draw(screen_center_x - 320, screen_center_y - 144, 40, 18);
                    image_draw(1131, screen_center_x - 304, screen_center_y - 128); // health advisor icon
                    text_draw_centered("City health", screen_center_x - 320, screen_center_y - 124, 640, FONT_LARGE_BLACK, COLOR_BLACK);
                    if (city_data.population.population >= 200) {
                        if (city_data.health.value == 100) {
                            text_draw_multiline("City health is perfect. Your empty clinics are a shining model throughout the Empire.", screen_center_x - 256, screen_center_y - 84, 552, FONT_NORMAL_GREEN, COLOR_BLACK);
                        } else if (city_data.health.value >= 90) {
                            text_draw_multiline("City health is almost perfect, with doctors' clinics virtually empty.", screen_center_x - 256, screen_center_y - 84, 552, FONT_NORMAL_GREEN, COLOR_BLACK);
                        } else if (city_data.health.value >= 80) {
                            text_draw_multiline("City health is excellent, with no waiting times at all to visit local clinics.", screen_center_x - 256, screen_center_y - 84, 552, FONT_NORMAL_GREEN, COLOR_BLACK);
                        } else if (city_data.health.value >= 70) {
                            text_draw_multiline("City health is very good. Local clinics are coping well.", screen_center_x - 256, screen_center_y - 84, 552, FONT_NORMAL_GREEN, COLOR_BLACK);
                        } else if (city_data.health.value >= 60) {
                            text_draw_multiline("City health is good. Citizens are prone to only minor ailments.", screen_center_x - 256, screen_center_y - 84, 552, FONT_NORMAL_GREEN, COLOR_BLACK);
                        } else if (city_data.health.value >= 50) {
                            text_draw_multiline("City health is average. Clinics are keeping foul influences under control.", screen_center_x - 256, screen_center_y - 84, 552, FONT_NORMAL_GREEN, COLOR_BLACK);
                        } else if (city_data.health.value >= 40) {
                            text_draw_multiline("City health is below average. Make sure citizens have food, and access to clinics.", screen_center_x - 256, screen_center_y - 84, 552, FONT_NORMAL_RED, COLOR_BLACK);
                        } else if (city_data.health.value >= 30) {
                            text_draw_multiline("City health is poor. Plenty of food and clinics would improve health.", screen_center_x - 256, screen_center_y - 84, 552, FONT_NORMAL_RED, COLOR_BLACK);
                        } else if (city_data.health.value >= 20) {
                            text_draw_multiline("City health is bad. Your overworked clinics fear a deadly outbreak.", screen_center_x - 256, screen_center_y - 84, 552, FONT_NORMAL_RED, COLOR_BLACK);
                        } else if (city_data.health.value >= 10) {
                            text_draw_multiline("City health is terrible! Clinics cannot cope, and disease is almost inevitable.", screen_center_x - 256, screen_center_y - 84, 552, FONT_NORMAL_RED, COLOR_BLACK);
                        } else if (city_data.health.value >= 0) {
                            text_draw_multiline("City health is appalling! Pestilence is certain in such shocking conditions.", screen_center_x - 256, screen_center_y - 84, 552, FONT_NORMAL_RED, COLOR_BLACK);
                        }
                    } else {
                        text_draw_multiline("Your small settlement has yet to report any problems with health.", screen_center_x - 256, screen_center_y - 84, 552, FONT_NORMAL_BLACK, COLOR_BLACK);
                    }
                    text_draw("Working", screen_center_x - 131, screen_center_y - 46, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("Care for", screen_center_x + 12, screen_center_y - 46, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("City coverage", screen_center_x + 154, screen_center_y - 46, FONT_SMALL_PLAIN, COLOR_BLACK);
                    inner_panel_draw(screen_center_x - 288, screen_center_y - 32, 36, 5);
                    text_draw_number(count_data.buildings[BUILDING_BATHHOUSE].total, 0, " Bath houses", screen_center_x - 280, screen_center_y - 24, FONT_NORMAL_GREEN);
                    text_draw_number_centered(count_data.buildings[BUILDING_BATHHOUSE].active, screen_center_x - 148, screen_center_y - 24, 100, FONT_NORMAL_GREEN);
                    for (int i = 0; i < 3; i++) {
                        text_draw("N/A", screen_center_x + 20, screen_center_y - 24 + 18 * i, FONT_NORMAL_GREEN, COLOR_BLACK);
                        text_draw("N/A", screen_center_x + 180, screen_center_y - 24 + 18 * i, FONT_NORMAL_GREEN, COLOR_BLACK);
                    }
                    text_draw_number(count_data.buildings[BUILDING_BARBER].total, 0, " Barber shops", screen_center_x - 280, screen_center_y - 6, FONT_NORMAL_GREEN);
                    text_draw_number_centered(count_data.buildings[BUILDING_BARBER].active, screen_center_x - 148, screen_center_y - 6, 100, FONT_NORMAL_GREEN);
                    text_draw_number(count_data.buildings[BUILDING_DOCTOR].total, 0, " Clinics", screen_center_x - 280, screen_center_y + 12, FONT_NORMAL_GREEN);
                    text_draw_number_centered(count_data.buildings[BUILDING_DOCTOR].active, screen_center_x - 148, screen_center_y + 12, 100, FONT_NORMAL_GREEN);
                    text_draw_number(count_data.buildings[BUILDING_HOSPITAL].total, 0, " Hospitals", screen_center_x - 280, screen_center_y + 30, FONT_NORMAL_GREEN);
                    text_draw_number_centered(count_data.buildings[BUILDING_HOSPITAL].active, screen_center_x - 148, screen_center_y + 30, 100, FONT_NORMAL_GREEN);
                    text_draw_number(1000 * count_data.buildings[BUILDING_HOSPITAL].active, 0, " patients", screen_center_x, screen_center_y + 30, FONT_NORMAL_GREEN);
                    if (culture_coverage.hospital) {
                        text_draw_centered(amenities_coverage_strings[culture_coverage.school / 10], screen_center_x + 160, screen_center_y + 30, 160, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else {
                        text_draw("None", screen_center_x + 178, screen_center_y + 30, FONT_NORMAL_GREEN, COLOR_BLACK);
                    }
                    switch (city_data.houses.health) {
                        case 1:
                            if (city_data.houses.requiring.bathhouse) {
                                text_draw_multiline("Some regions of the city want more bath-houses. Some houses have access to bathing facilities, but others do not, and this hinders their development.", screen_center_x - 288, screen_center_y + 58, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                            } else {
                                text_draw_multiline("Certain areas of the city now need access to bath-houses. Lack of these basic sanitary facilities restricts housing growth in these areas.", screen_center_x - 288, screen_center_y + 58, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                            }
                            break;
                        case 2:
                            if (city_data.houses.requiring.barber) {
                                text_draw_multiline("More areas of the city now require barbers. As your city grows wealthier, more and more residents have time for a shave and a haircut!", screen_center_x - 288, screen_center_y + 58, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                            } else {
                                text_draw_multiline("Certain well-to-do areas of the city want barber shops. A local barber will enhance the stature of the neighborhood.", screen_center_x - 288, screen_center_y + 58, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                            }
                            break;
                        case 3:
                            if (city_data.houses.requiring.clinic) {
                                text_draw_multiline("More and more people want convenient medical facilities. Provide local access to clinics to allow the city to grow.", screen_center_x - 288, screen_center_y + 58, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                            } else {
                                text_draw_multiline("Some parts of the city demand access to a clinic. Without medical care, those houses are unlikely to increase much further in stature.", screen_center_x - 288, screen_center_y + 58, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                            }
                            break;
                        case 4:
                            text_draw_multiline("Development in some quarters is being held back by poor city-wide hospital coverage. New hospitals will attract more patricians to the city.", screen_center_x - 288, screen_center_y + 58, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                            break;
                        default:
                            text_draw_multiline("There are presently no requests for health or sanitary facilities. As the city develops, though, people will expect bath-houses and medical facilities, followed later by demands for barbers, then even more medical facilities!", screen_center_x - 288, screen_center_y + 58, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                            break;
                    }
                    refresh_current_window = 0;
                }
                break;
            case WINDOW_ADVISOR_EDUCATION:
                if (refresh_current_window) {
                    draw_common_advisor_ui();
                    outer_panel_draw(screen_center_x - 320, screen_center_y - 128, 40, 16);
                    image_draw(1132, screen_center_x - 304, screen_center_y - 112); // education advisor icon
                    text_draw_centered("Education", screen_center_x - 320, screen_center_y - 108, 640, FONT_LARGE_BLACK, COLOR_BLACK);
                    int width = text_draw_number(city_data.population.population, 0, " people,", screen_center_x - 252, screen_center_y - 72, FONT_NORMAL_BLACK);
                    width += text_draw_number(city_data.population.school_age, 0, " school age,", screen_center_x - 252 + width, screen_center_y - 72, FONT_NORMAL_BLACK);
                    text_draw_number(city_data.population.academy_age, 0, " academy age.", screen_center_x - 252 + width, screen_center_y - 72, FONT_NORMAL_BLACK);
                    text_draw("Working", screen_center_x - 131, screen_center_y - 48, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("Can educate", screen_center_x + 12, screen_center_y - 48, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("City coverage", screen_center_x + 154, screen_center_y - 48, FONT_SMALL_PLAIN, COLOR_BLACK);
                    inner_panel_draw(screen_center_x - 288, screen_center_y - 32, 36, 4);
                    text_draw_number(count_data.buildings[BUILDING_SCHOOL].total, 0, " Schools", screen_center_x - 280, screen_center_y - 24, FONT_NORMAL_WHITE);
                    text_draw_number_centered(count_data.buildings[BUILDING_SCHOOL].active, screen_center_x - 148, screen_center_y - 24, 100, FONT_NORMAL_WHITE);
                    text_draw_number(75 * count_data.buildings[BUILDING_SCHOOL].active, 0, " children", screen_center_x + 10, screen_center_y - 24, FONT_NORMAL_WHITE);
                    if (culture_coverage.school) {
                        text_draw_centered(amenities_coverage_strings[culture_coverage.school / 10], screen_center_x + 98, screen_center_y - 24, 200, FONT_NORMAL_WHITE, COLOR_BLACK);
                    } else {
                        text_draw("None", screen_center_x + 178, screen_center_y - 24, FONT_NORMAL_WHITE, COLOR_BLACK);
                    }
                    text_draw_number(count_data.buildings[BUILDING_ACADEMY].total, 0, " Academies", screen_center_x - 280, screen_center_y - 6, FONT_NORMAL_WHITE);
                    text_draw_number_centered(count_data.buildings[BUILDING_ACADEMY].active, screen_center_x - 148, screen_center_y - 6, 100, FONT_NORMAL_WHITE);
                    text_draw_number(100 * count_data.buildings[BUILDING_ACADEMY].active, 0, " young people", screen_center_x + 10, screen_center_y - 6, FONT_NORMAL_WHITE);
                    if (culture_coverage.academy) {
                        text_draw_centered(amenities_coverage_strings[culture_coverage.academy / 10], screen_center_x + 98, screen_center_y - 6, 200, FONT_NORMAL_WHITE, COLOR_BLACK);
                    } else {
                        text_draw("None", screen_center_x + 178, screen_center_y - 6, FONT_NORMAL_WHITE, COLOR_BLACK);
                    }
                    text_draw_number(count_data.buildings[BUILDING_LIBRARY].total, 0, " Academies", screen_center_x - 280, screen_center_y + 12, FONT_NORMAL_WHITE);
                    text_draw_number_centered(count_data.buildings[BUILDING_LIBRARY].active, screen_center_x - 148, screen_center_y + 12, 100, FONT_NORMAL_WHITE);
                    text_draw_number(800 * count_data.buildings[BUILDING_LIBRARY].active, 0, " people", screen_center_x + 10, screen_center_y + 12, FONT_NORMAL_WHITE);
                    if (culture_coverage.library) {
                        text_draw_centered(amenities_coverage_strings[culture_coverage.library / 10], screen_center_x + 98, screen_center_y + 12, 200, FONT_NORMAL_WHITE, COLOR_BLACK);
                    } else {
                        text_draw("None", screen_center_x + 178, screen_center_y + 12, FONT_NORMAL_WHITE, COLOR_BLACK);
                    }
                    if (city_data.houses.education == 1) {
                        if (city_data.houses.requiring.school) {
                            text_draw_multiline("Some neighborhoods demand better school or academy access. Some houses have access to city schools or academies, but others do not, and this hinders their development.", screen_center_x - 288, screen_center_y + 48, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                        } else {
                            text_draw_multiline("Certain areas of the city now need school or academy access. Lack of educational access prevents parts of the city from developing better housing.", screen_center_x - 288, screen_center_y + 48, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                    } else if (city_data.houses.education == 2) {
                        if (city_data.houses.requiring.library) {
                            text_draw_multiline("Some areas of the city want better library access. Wealthier citizens enjoy reading, and do not appreciate having to walk so far to the library.", screen_center_x - 288, screen_center_y + 48, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                        } else {
                            text_draw_multiline("Library access is now needed in certain areas of the city. Your citizens have time to read. Now they need access to literature.", screen_center_x - 288, screen_center_y + 48, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                    } else if (city_data.houses.education == 3) {
                        text_draw_multiline("Better school or academy and library access would enhance some areas of the city. People should not have to walk so far for learning!", screen_center_x - 288, screen_center_y + 48, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else {
                        if (!city_data.houses.requiring.school) {
                            text_draw_multiline("No citizens are asking for educational facilities yet. As the city grows in stature, though, people will expect schools and academies, followed later by demands for libraries.", screen_center_x - 288, screen_center_y + 48, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                        } else if (!city_data.houses.requiring.library) {
                            if (culture_coverage.school >= 100 && culture_coverage.academy >= 100) {
                                text_draw_multiline("Everybody requesting educational facilities in the city has them, and the educational facilities for the whole city are perfect.", screen_center_x - 288, screen_center_y + 48, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                            } else if (culture_coverage.school <= culture_coverage.academy) {
                                text_draw_multiline("All neighborhoods that demand them have educational facilities, but building more schools would reduce classroom sizes.", screen_center_x - 288, screen_center_y + 48, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                            } else {
                                text_draw_multiline("All neighborhoods that demand them have educational facilities, but building more academies would reduce classroom sizes.", screen_center_x - 288, screen_center_y + 48, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                            }
                        } else {
                            // all education needed
                            if (culture_coverage.school == 100 && culture_coverage.academy == 100 && culture_coverage.library == 100) {
                                text_draw_multiline("Everybody requesting educational facilities in the city has them, and the educational facilities for the whole city are perfect.", screen_center_x - 288, screen_center_y + 48, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                            } else if (culture_coverage.school <= culture_coverage.academy && culture_coverage.school <= culture_coverage.library) {
                                text_draw_multiline("All neighborhoods that demand them have educational facilities, but building more schools would reduce classroom sizes.", screen_center_x - 288, screen_center_y + 48, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                            } else if (culture_coverage.academy <= culture_coverage.school && culture_coverage.academy <= culture_coverage.library) {
                                text_draw_multiline("All neighborhoods that demand them have educational facilities, but building more academies would reduce classroom sizes.", screen_center_x - 288, screen_center_y + 48, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                            } else if (culture_coverage.library <= culture_coverage.school && culture_coverage.library <= culture_coverage.academy) {
                                text_draw_multiline("All neighborhoods that demand them have educational facilities, but building more libraries would reduce overcrowding.", screen_center_x - 288, screen_center_y + 48, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                            }
                        }
                    }
                    refresh_current_window = 0;
                }
                break;
            case WINDOW_ADVISOR_ENTERTAINMENT:
                if (refresh_current_window) {
                    city_culture_calculate();
                    draw_common_advisor_ui();
                    outer_panel_draw(screen_center_x - 320, screen_center_y - 184, 40, 23);
                    image_draw(1133, screen_center_x - 304, screen_center_y - 168); // entertainment advisor icon
                    text_draw_centered("Entertainment", screen_center_x - 320, screen_center_y - 164, 640, FONT_LARGE_BLACK, COLOR_BLACK);
                    text_draw("Working", screen_center_x - 116, screen_center_y - 128, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("Shows", screen_center_x - 26, screen_center_y - 128, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("Can entertain", screen_center_x + 50, screen_center_y - 128, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("City coverage", screen_center_x + 168, screen_center_y - 128, FONT_SMALL_PLAIN, COLOR_BLACK);
                    inner_panel_draw(screen_center_x - 288, screen_center_y - 112, 36, 5);
                    text_draw_number(count_data.buildings[BUILDING_THEATER].total, 0, " Theaters", screen_center_x - 280, screen_center_y - 104, FONT_NORMAL_WHITE);
                    text_draw_number_centered(count_data.buildings[BUILDING_THEATER].active, screen_center_x - 135, screen_center_y - 104, 100, FONT_NORMAL_WHITE);
                    text_draw_number_centered(city_data.entertainment.theater_shows, screen_center_x - 54, screen_center_y - 104, 100, FONT_NORMAL_WHITE);
                    text_draw_number(500 * count_data.buildings[BUILDING_THEATER].active, 0, " people", screen_center_x + 56, screen_center_y - 104, FONT_NORMAL_WHITE);
                    if (culture_coverage.theater) {
                        text_draw_centered(amenities_coverage_strings[culture_coverage.theater / 10], screen_center_x + 112, screen_center_y - 104, 200, FONT_NORMAL_WHITE, COLOR_BLACK);
                    } else {
                        text_draw("None", screen_center_x + 190, screen_center_y - 104, FONT_NORMAL_WHITE, COLOR_BLACK);
                    }
                    text_draw_number(count_data.buildings[BUILDING_AMPHITHEATER].total, 0, " Amphitheaters", screen_center_x - 280, screen_center_y - 86, FONT_NORMAL_WHITE);
                    text_draw_number_centered(count_data.buildings[BUILDING_AMPHITHEATER].active, screen_center_x - 135, screen_center_y - 86, 100, FONT_NORMAL_WHITE);
                    text_draw_number_centered(city_data.entertainment.amphitheater_shows, screen_center_x - 54, screen_center_y - 86, 100, FONT_NORMAL_WHITE);
                    text_draw_number(800 * count_data.buildings[BUILDING_AMPHITHEATER].active, 0, " people", screen_center_x + 56, screen_center_y - 86, FONT_NORMAL_WHITE);
                    if (culture_coverage.amphitheater) {
                        text_draw_centered(amenities_coverage_strings[culture_coverage.amphitheater / 10], screen_center_x + 112, screen_center_y - 104, 200, FONT_NORMAL_WHITE, COLOR_BLACK);
                    } else {
                        text_draw("None", screen_center_x + 190, screen_center_y - 104, FONT_NORMAL_WHITE, COLOR_BLACK);
                    }
                    text_draw_number(count_data.buildings[BUILDING_AMPHITHEATER].total, 0, " Colosseums", screen_center_x - 280, screen_center_y - 68, FONT_NORMAL_WHITE);
                    text_draw_number_centered(count_data.buildings[BUILDING_COLOSSEUM].active, screen_center_x - 135, screen_center_y - 68, 100, FONT_NORMAL_WHITE);
                    text_draw_number_centered(city_data.entertainment.colosseum_shows, screen_center_x - 54, screen_center_y - 68, 100, FONT_NORMAL_WHITE);
                    text_draw_number(1500 * count_data.buildings[BUILDING_COLOSSEUM].active, 0, " people", screen_center_x + 56, screen_center_y - 68, FONT_NORMAL_WHITE);
                    if (culture_coverage.colosseum) {
                        text_draw_centered(amenities_coverage_strings[culture_coverage.colosseum / 10], screen_center_x + 112, screen_center_y - 104, 200, FONT_NORMAL_WHITE, COLOR_BLACK);
                    } else {
                        text_draw("None", screen_center_x + 190, screen_center_y - 104, FONT_NORMAL_WHITE, COLOR_BLACK);
                    }
                    text_draw_number(count_data.buildings[BUILDING_AMPHITHEATER].total, 0, " Hippodromes", screen_center_x - 280, screen_center_y - 50, FONT_NORMAL_WHITE);
                    text_draw_number_centered(count_data.buildings[BUILDING_HIPPODROME].active, screen_center_x - 135, screen_center_y - 50, 100, FONT_NORMAL_WHITE);
                    text_draw_number_centered(city_data.entertainment.hippodrome_shows, screen_center_x - 54, screen_center_y - 50, 100, FONT_NORMAL_WHITE);
                    text_draw("N/A", screen_center_x + 68, screen_center_y - 50, FONT_NORMAL_WHITE, COLOR_BLACK);
                    if (culture_coverage.hippodrome == 0) {
                        text_draw("None", screen_center_x + 190, screen_center_y - 104, FONT_NORMAL_WHITE, COLOR_BLACK);
                    } else {
                        text_draw("Perfect", screen_center_x + 190, screen_center_y - 104, FONT_NORMAL_WHITE, COLOR_BLACK);
                    }
                    if (city_data.houses.missing.entertainment > city_data.houses.missing.more_entertainment) {
                        text_draw_multiline("Parts of the city complain that they have no access to recreational facilities. Building more entertainment venues would help these poorer areas develop.", screen_center_x - 288, screen_center_y - 16, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (!city_data.houses.missing.more_entertainment) {
                        if (city_data.culture.average_entertainment) {
                            text_draw_multiline("Citizens seeking diversion currently have all their desires met. As the city grows, though, you need to provide even grander forms of entertainment, and more of it!", screen_center_x - 288, screen_center_y - 16, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                        } else {
                            text_draw_multiline("At the moment your citizens have other, simpler needs than entertainment on their minds. As your city grows, though, they will clamor for something to relieve the monotony of their everyday lives.", screen_center_x - 288, screen_center_y - 16, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                    } else if (city_data.entertainment.venue_needing_shows) {
                        switch (city_data.entertainment.venue_needing_shows) {
                            case 1:
                                text_draw_multiline("Some citizens complain of inadequate entertainment in their areas. You may need to offer more variety, or perhaps build more actor colonies to provide actors for those theaters that need them.", screen_center_x - 288, screen_center_y - 16, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 2:
                                text_draw_multiline("Some amphitheaters lack actors or gladiators, and so are not at full capacity. More showmen will help boost certain areas of the city that are complaining of poor entertainment.", screen_center_x - 288, screen_center_y - 16, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 3:
                                text_draw_multiline("Your colosseums need more spectacles! Providing gladiators or lions for them would boost local entertainment levels in parts of the city.", screen_center_x - 288, screen_center_y - 16, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 4:
                                text_draw_multiline("Your hippodrome has no chariots to race. Providing some would give a massive boost to the city's population, which is eager for more entertainment.", screen_center_x - 288, screen_center_y - 16, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                        }
                    }
                    inner_panel_draw(screen_center_x - 272, screen_center_y + 70, 34, 6);
                    text_draw_centered("Festivals", screen_center_x - 272, screen_center_y + 40, 544, FONT_LARGE_BLACK, COLOR_BLACK);
                    image_draw(7752, screen_center_x + 142, screen_center_y + 74); // fruit bowl image
                    text_draw_number(city_data.festival.months_since_festival, 0, " months since last festival", screen_center_x - 184, screen_center_y + 82, FONT_NORMAL_WHITE);
                    if (city_data.festival.queued) {
                        text_draw_centered("Preparing for the coming festival", screen_center_x - 207, screen_center_y + 107, 288, FONT_NORMAL_WHITE, COLOR_BLACK);
                    } else {
                        text_draw_centered("Hold new festival", screen_center_x - 207, screen_center_y + 107, 288, FONT_NORMAL_WHITE, COLOR_BLACK);
                    }
                    if (city_data.festival.months_since_festival <= 1) {
                        text_draw_multiline("Your citizens, some still drunk from the recent revelry, salute your generosity.", screen_center_x - 256, screen_center_y + 130, 432, FONT_NORMAL_WHITE, COLOR_BLACK);
                    } else if (city_data.festival.months_since_festival <= 6) {
                        text_draw_multiline("People still talk fondly of your last festival.", screen_center_x - 256, screen_center_y + 130, 432, FONT_NORMAL_WHITE, COLOR_BLACK);
                    } else if (city_data.festival.months_since_festival <= 12) {
                        text_draw_multiline("The memory of the earlier festival is fading from people's minds.", screen_center_x - 256, screen_center_y + 130, 432, FONT_NORMAL_WHITE, COLOR_BLACK);
                    } else if (city_data.festival.months_since_festival <= 18) {
                        text_draw_multiline("People cannot remember the last festival to be held in the city.", screen_center_x - 256, screen_center_y + 130, 432, FONT_NORMAL_WHITE, COLOR_BLACK);
                    } else if (city_data.festival.months_since_festival <= 24) {
                        text_draw_multiline("Citizens grumble at the lack of festivals held in your city.", screen_center_x - 256, screen_center_y + 130, 432, FONT_NORMAL_WHITE, COLOR_BLACK);
                    } else if (city_data.festival.months_since_festival <= 30) {
                        text_draw_multiline("Your people are very unhappy at the prospect of another year without a festival.", screen_center_x - 256, screen_center_y + 130, 432, FONT_NORMAL_WHITE, COLOR_BLACK);
                    } else {
                        text_draw_multiline("\"Governor-No-festivals!\" your disillusioned people chant in the streets.", screen_center_x - 256, screen_center_y + 130, 432, FONT_NORMAL_WHITE, COLOR_BLACK);
                    }
                    refresh_current_window = 0;
                }
                if (!city_data.festival.queued) {
                    if (mouse_x >= screen_center_x - 207 && mouse_x < screen_center_x + 81 && mouse_y >= screen_center_y + 102 && mouse_y < screen_center_y + 122) {
                        button_border_draw(screen_center_x - 207, screen_center_y + 102, 288, 20, 1);
                    } else {
                        button_border_draw(screen_center_x - 207, screen_center_y + 102, 288, 20, 0);
                    }
                }
                break;
            case WINDOW_ADVISOR_RELIGION:
                if (refresh_current_window) {
                    draw_common_advisor_ui();
                    city_gods_calculate_least_happy();
                    outer_panel_draw(screen_center_x - 320, screen_center_y - 136, 40, 17);
                    image_draw(1134, screen_center_x - 304, screen_center_y - 120); // religion advisor icon
                    text_draw("Religion", screen_center_x - 248, screen_center_y - 120, FONT_LARGE_BLACK, COLOR_BLACK);
                    // table header
                    text_draw("small temples", screen_center_x - 176, screen_center_y - 84, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("large temples", screen_center_x - 52, screen_center_y - 84, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("months since", screen_center_x + 74, screen_center_y - 102, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("festival", screen_center_x + 89, screen_center_y - 84, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("the god is", screen_center_x + 182, screen_center_y - 84, FONT_SMALL_PLAIN, COLOR_BLACK);
                    inner_panel_draw(screen_center_x - 288, screen_center_y - 68, 36, 8);
                    // gods
                    for (int i = 0; i < MAX_GODS; i++) {
                        switch (i) {
                            case 0:
                                text_draw("Ceres", screen_center_x - 280, screen_center_y - 60 + 18 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                                break;
                            case 1:
                                text_draw("Neptune", screen_center_x - 280, screen_center_y - 60 + 18 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                                break;
                            case 2:
                                text_draw("Mercury", screen_center_x - 280, screen_center_y - 60 + 18 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                                break;
                            case 3:
                                text_draw("Mars", screen_center_x - 280, screen_center_y - 60 + 18 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                                break;
                            case 4:
                                text_draw("Venus", screen_center_x - 280, screen_center_y - 60 + 18 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                                break;
                        }
                        text_draw_number_centered(count_data.buildings[BUILDING_SMALL_TEMPLE_CERES + i].total, screen_center_x - 160, screen_center_y - 60 + 18 * i, 50, FONT_NORMAL_WHITE);
                        text_draw_number_centered(count_data.buildings[BUILDING_LARGE_TEMPLE_CERES + i].total, screen_center_x - 36, screen_center_y - 60 + 18 * i, 50, FONT_NORMAL_WHITE);
                        text_draw_number_centered(city_data.religion.gods[i].months_since_festival, screen_center_x + 92, screen_center_y - 60 + 18 * i, 50, FONT_NORMAL_WHITE);
                        int width;
                        if (city_data.religion.gods[i].happiness <= 10) {
                            width = text_draw("Wrathful", screen_center_x + 180, screen_center_y - 60 + 18 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                        } else if (city_data.religion.gods[i].happiness <= 20) {
                            width = text_draw("Very angry", screen_center_x + 176, screen_center_y - 60 + 18 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                        } else if (city_data.religion.gods[i].happiness <= 30) {
                            width = text_draw("Angry", screen_center_x + 184, screen_center_y - 60 + 18 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                        } else if (city_data.religion.gods[i].happiness <= 40) {
                            width = text_draw("Irritated", screen_center_x + 178, screen_center_y - 60 + 18 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                        } else if (city_data.religion.gods[i].happiness <= 50) {
                            width = text_draw("Displeased", screen_center_x + 176, screen_center_y - 60 + 18 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                        } else if (city_data.religion.gods[i].happiness <= 60) {
                            width = text_draw("Indifferent", screen_center_x + 184, screen_center_y - 60 + 18 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                        } else if (city_data.religion.gods[i].happiness <= 70) {
                            width = text_draw("Pleased", screen_center_x + 188, screen_center_y - 60 + 18 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                        } else if (city_data.religion.gods[i].happiness <= 80) {
                            width = text_draw("Happy", screen_center_x + 190, screen_center_y - 60 + 18 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                        } else if (city_data.religion.gods[i].happiness <= 90) {
                            width = text_draw("Charmed", screen_center_x + 188, screen_center_y - 60 + 18 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                        } else if (city_data.religion.gods[i].happiness < 100) {
                            width = text_draw("Delighted", screen_center_x + 184, screen_center_y - 60 + 18 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                        } else if (city_data.religion.gods[i].happiness == 100) {
                            width = text_draw("Exalted", screen_center_x + 186, screen_center_y - 60 + 18 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                        }
                        for (int i = 0; i < city_data.religion.gods[i].wrath_bolts / 10; i++) {
                            image_draw(1204, screen_center_x + 184 + width + 10 * i, screen_center_y - 64 + 18 * i);
                        }
                    }
                    // oracles
                    text_draw("Oracles", screen_center_x - 280, screen_center_y + 35, FONT_NORMAL_WHITE, COLOR_BLACK);
                    text_draw_number_centered(count_data.buildings[BUILDING_ORACLE].total, screen_center_x - 160, screen_center_y + 35, 50, FONT_NORMAL_WHITE);
                    if (city_data.religion.least_happy_god - 1 >= 0 && city_data.religion.gods[city_data.religion.least_happy_god - 1].wrath_bolts > 4) {
                        switch (city_data.religion.least_happy_god) {
                            case 1:
                                text_draw_multiline("Ceres' displeasure is dangerous, as she protects the people from poor harvests and famines.", screen_center_x - 288, screen_center_y + 68, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 2:
                                text_draw_multiline("Neptune protects sailors and their ships from the perils of the seas. Displease him, and you risk the lives of sea merchants and fishermen.", screen_center_x - 288, screen_center_y + 68, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 3:
                                text_draw_multiline("Mercury, messenger of the gods and patron of merchants, is unhappy. Your traders worry that his protection is waning.", screen_center_x - 288, screen_center_y + 68, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 4:
                                text_draw_multiline("Mars, protector of soldiers and grantor of victories, is displeased. Your troops fear that they will lose a great battle if he is not appeased!", screen_center_x - 288, screen_center_y + 68, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                            case 5:
                                text_draw_multiline("Venus, bringer of love and harmony, is upset. This does not bode well for your city's prefects!", screen_center_x - 288, screen_center_y + 68, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                                break;
                        }
                    } else if (city_data.houses.religion == 1) {
                        if (city_data.houses.requiring.religion) {
                            text_draw_multiline("More and more citizens demand at least one place of worship in their neighborhoods to raise the gods' opinions of them.", screen_center_x - 288, screen_center_y + 68, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                        } else {
                            text_draw_multiline("Your citizens are taking an interest in religion. The lack of access to a nearby place of worship is holding back city development.", screen_center_x - 288, screen_center_y + 68, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                    } else if (city_data.houses.religion == 2) {
                        text_draw_multiline("Some citizens want access to another religion close to home. Lack of religious diversity limits city development in certain areas.", screen_center_x - 288, screen_center_y + 68, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (city_data.houses.religion == 3) {
                        text_draw_multiline("Some citizens want a third religion established near their locale. They feel that this would help to attract a better class of patrician.", screen_center_x - 288, screen_center_y + 68, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else if (!city_data.houses.requiring.religion) {
                        text_draw_multiline("So far, your citizens are preoccupied with other aspects of city life. As your city grows, though, they will want easy access to a variety of temples.", screen_center_x - 288, screen_center_y + 68, 582, FONT_NORMAL_BLACK, COLOR_BLACK);
                    }
                    refresh_current_window = 0;
                }
                break;
            case WINDOW_ADVISOR_FINANCIAL:
                if (refresh_current_window) {
                    draw_common_advisor_ui();
                    outer_panel_draw(screen_center_x - 320, screen_center_y - 232, 40, 29);
                    image_draw(1135, screen_center_x - 304, screen_center_y - 216); // finances advisor icon
                    text_draw_centered("Finances", screen_center_x - 320, screen_center_y - 212, 640, FONT_LARGE_BLACK, COLOR_BLACK);
                    inner_panel_draw(screen_center_x - 272, screen_center_y - 172, 34, 5);
                    int width;
                    if (city_data.finance.treasury < 0) {
                        width = text_draw("City has a debt to Rome of", screen_center_x - 256, screen_center_y - 160, FONT_NORMAL_RED, COLOR_BLACK);
                        text_draw_number(-city_data.finance.treasury, 0, " Dn", screen_center_x - 256 + width, screen_center_y - 160, FONT_NORMAL_RED);
                    } else {
                        width = text_draw("City treasury has assets of", screen_center_x - 256, screen_center_y - 160, FONT_NORMAL_WHITE, COLOR_BLACK);
                        text_draw_number(city_data.finance.treasury, 0, " Dn", screen_center_x - 256 + width, screen_center_y - 160, FONT_NORMAL_WHITE);
                    }
                    // tax percentage and estimated income
                    text_draw("Tax rate of", screen_center_x - 256, screen_center_y - 138, FONT_NORMAL_WHITE, COLOR_BLACK);
                    width = text_draw_percentage(city_data.finance.tax_percentage, screen_center_x - 104, screen_center_y - 138, FONT_NORMAL_WHITE);
                    width += text_draw("yields an estimated", screen_center_x - 104 + width, screen_center_y - 138, FONT_NORMAL_WHITE, COLOR_BLACK);
                    draw_arrow_button(15, screen_center_x - 160, screen_center_y - 144, 1);
                    draw_arrow_button(17, screen_center_x - 136, screen_center_y - 144, 2);
                    text_draw_number(city_data.finance.estimated_tax_income, 0, " Dn", screen_center_x - 104 + width, screen_center_y - 138, FONT_NORMAL_WHITE);
                    // percentage taxpayers
                    width = text_draw_percentage(city_data.taxes.percentage_taxed_people, screen_center_x - 256, screen_center_y - 116, FONT_NORMAL_WHITE);
                    text_draw("of the population are taxed", screen_center_x - 256 + width, screen_center_y - 116, FONT_NORMAL_WHITE, COLOR_BLACK);
                    // table headers
                    text_draw("Last year", screen_center_x - 50, screen_center_y - 84, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("So far this year", screen_center_x + 98, screen_center_y - 84, FONT_NORMAL_BLACK, COLOR_BLACK);
                    // income
                    text_draw("Taxes in", screen_center_x - 264, screen_center_y - 60, FONT_NORMAL_BLACK, COLOR_BLACK);
                    draw_finances_row(city_data.finance.last_year.income.taxes, city_data.finance.this_year.income.taxes, screen_center_y - 60);
                    text_draw("Trade receipts", screen_center_x - 264, screen_center_y - 42, FONT_NORMAL_BLACK, COLOR_BLACK);
                    draw_finances_row(city_data.finance.last_year.income.exports, city_data.finance.this_year.income.exports, screen_center_y - 42);
                    text_draw("Donated", screen_center_x - 264, screen_center_y - 24, FONT_NORMAL_BLACK, COLOR_BLACK);
                    draw_finances_row(city_data.finance.last_year.income.donated, city_data.finance.this_year.income.donated, screen_center_y - 24);
                    graphics_draw_horizontal_line(screen_center_x - 46, screen_center_x + 18, screen_center_y - 8, COLOR_BLACK);
                    graphics_draw_horizontal_line(screen_center_x + 126, screen_center_x + 190, screen_center_y - 8, COLOR_BLACK);
                    text_draw("Income", screen_center_x - 264, screen_center_y + 4, FONT_NORMAL_BLACK, COLOR_BLACK);
                    draw_finances_row(city_data.finance.last_year.income.total, city_data.finance.this_year.income.total, screen_center_y + 4);
                    // expenses
                    text_draw("Imports", screen_center_x - 264, screen_center_y + 22, FONT_NORMAL_BLACK, COLOR_BLACK);
                    draw_finances_row(city_data.finance.last_year.expenses.imports, city_data.finance.this_year.expenses.imports, screen_center_y + 22);
                    text_draw("Wages", screen_center_x - 264, screen_center_y + 40, FONT_NORMAL_BLACK, COLOR_BLACK);
                    draw_finances_row(city_data.finance.last_year.expenses.wages, city_data.finance.this_year.expenses.wages, screen_center_y + 40);
                    text_draw("Construction", screen_center_x - 264, screen_center_y + 58, FONT_NORMAL_BLACK, COLOR_BLACK);
                    draw_finances_row(city_data.finance.last_year.expenses.construction, city_data.finance.this_year.expenses.construction, screen_center_y + 58);
                    // interest (with percentage)
                    width = text_draw("Interest at", screen_center_x - 264, screen_center_y + 76, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_percentage(10, screen_center_x - 264 + width, screen_center_y + 76, FONT_NORMAL_BLACK);
                    draw_finances_row(city_data.finance.last_year.expenses.interest, city_data.finance.this_year.expenses.interest, screen_center_y + 76);
                    text_draw("Personal salary", screen_center_x - 264, screen_center_y + 94, FONT_NORMAL_BLACK, COLOR_BLACK);
                    draw_finances_row(city_data.finance.last_year.expenses.salary, city_data.finance.this_year.expenses.salary, screen_center_y + 94);
                    text_draw("Sundries", screen_center_x - 264, screen_center_y + 112, FONT_NORMAL_BLACK, COLOR_BLACK);
                    draw_finances_row(city_data.finance.last_year.expenses.sundries, city_data.finance.this_year.expenses.sundries, screen_center_y + 112);
                    text_draw("Tribute", screen_center_x - 264, screen_center_y + 130, FONT_NORMAL_BLACK, COLOR_BLACK);
                    draw_finances_row(city_data.finance.last_year.expenses.tribute, city_data.finance.this_year.expenses.tribute, screen_center_y + 130);
                    graphics_draw_horizontal_line(screen_center_x - 46, screen_center_x + 18, screen_center_y + 146, COLOR_BLACK);
                    graphics_draw_horizontal_line(screen_center_x + 126, screen_center_x + 190, screen_center_y + 146, COLOR_BLACK);
                    text_draw("Expenses", screen_center_x - 264, screen_center_y + 158, FONT_NORMAL_BLACK, COLOR_BLACK);
                    draw_finances_row(city_data.finance.last_year.expenses.total, city_data.finance.this_year.expenses.total, screen_center_y + 158);
                    text_draw("Net in/out flow", screen_center_x - 264, screen_center_y + 178, FONT_NORMAL_BLACK, COLOR_BLACK);
                    draw_finances_row(city_data.finance.last_year.net_in_out, city_data.finance.this_year.net_in_out, screen_center_y + 178);
                    text_draw("Balance", screen_center_x - 264, screen_center_y + 198, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number_centered(city_data.finance.last_year.balance, screen_center_x - 59, screen_center_y + 198, 100, FONT_NORMAL_BLACK);
                    text_draw_number_centered(city_data.finance.this_year.balance, screen_center_x + 113, screen_center_y + 198, 100, FONT_NORMAL_BLACK);
                    refresh_current_window = 0;
                }
                if (current_window_image_button_pressed && current_time > button_last_update_time + BUTTON_REPEAT_DELAY_TIME) {
                    button_last_update_time = current_time;
                    if (current_window_image_button_pressed == 1) {
                        adjust_taxes(1);
                    } else if (current_window_image_button_pressed == 2) {
                        adjust_taxes(-1);
                    }
                    refresh_current_window = 1;
                }
                break;
            case WINDOW_ADVISOR_CHIEF:
                if (refresh_current_window) {
                    draw_common_advisor_ui();
                    outer_panel_draw(screen_center_x - 320, screen_center_y - 184, 40, 21);
                    image_draw(1136, screen_center_x - 304, screen_center_y - 168); // finances advisor icon
                    text_draw_centered("Chief advisor", screen_center_x - 320, screen_center_y - 164, 640, FONT_LARGE_BLACK, COLOR_BLACK);
                    inner_panel_draw(screen_center_x - 296, screen_center_y - 124, 37, 16);
                    // workers
                    draw_title_advisors(screen_center_y - 114, "Employment");
                    int width;
                    if (city_data.labor.unemployment_percentage) {
                        width = text_draw("The city has unemployment of", screen_center_x - 84, screen_center_y - 114, FONT_NORMAL_RED, COLOR_BLACK);
                        width += text_draw_percentage(city_data.labor.unemployment_percentage, screen_center_x - 84 + width, screen_center_y - 114, FONT_NORMAL_RED);
                        text_draw_number(city_data.labor.workers_unemployed - city_data.labor.workers_needed, '(', ")", screen_center_x - 84 + width, screen_center_y - 114, FONT_NORMAL_RED);
                    } else if (city_data.labor.workers_needed > 0) {
                        width = text_draw("The city is short by", screen_center_x - 84, screen_center_y - 114, FONT_NORMAL_RED, COLOR_BLACK);
                        text_draw_number(city_data.labor.workers_needed, ' ', "employees", screen_center_x - 84 + width, screen_center_y - 114, FONT_NORMAL_RED);
                    } else {
                        text_draw("The city has no employment problems", screen_center_x - 84, screen_center_y - 114, FONT_NORMAL_GREEN, COLOR_BLACK);
                    }
                    // finance
                    draw_title_advisors(screen_center_y - 94, "Finances");
                    if (city_data.finance.treasury > city_data.finance.last_year.balance) {
                        width = text_draw("This year assets have risen by", screen_center_x - 84, screen_center_y - 94, FONT_NORMAL_GREEN, COLOR_BLACK);
                        text_draw_money(city_data.finance.treasury - city_data.finance.last_year.balance, screen_center_x - 84 + width, screen_center_y - 94, FONT_NORMAL_GREEN);
                    } else if (city_data.finance.treasury < city_data.finance.last_year.balance) {
                        width = text_draw("This year assets have fallen by", screen_center_x - 84, screen_center_y - 94, FONT_NORMAL_RED, COLOR_BLACK);
                        text_draw_money(city_data.finance.last_year.balance - city_data.finance.treasury, screen_center_x - 84 + width, screen_center_y - 94, FONT_NORMAL_RED);
                    } else {
                        text_draw("No change expected", screen_center_x - 84, screen_center_y - 94, FONT_NORMAL_GREEN, COLOR_BLACK);
                    }
                    // migration
                    draw_title_advisors(screen_center_y - 74, "Migration");
                    if (city_figures_total_invading_enemies() > 3) {
                        text_draw("War is deterring immigrants!!", screen_center_x - 84, screen_center_y - 74, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else if (city_data.migration.newcomers >= 5) {
                        text_draw("People are immigrating to the city", screen_center_x - 84, screen_center_y - 74, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else if (city_migration_no_room_for_immigrants()) {
                        text_draw("Lack of housing prevents immigration", screen_center_x - 84, screen_center_y - 74, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (city_data.migration.percentage >= 80) {
                        text_draw("People are immigrating to the city", screen_center_x - 84, screen_center_y - 74, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else {
                        switch (city_data.migration.no_immigration_cause) {
                            case NO_IMMIGRATION_LOW_WAGES:
                                text_draw("Low wages prevent immigration", screen_center_x - 84, screen_center_y - 74, FONT_NORMAL_GREEN, COLOR_BLACK);
                                break;
                            case NO_IMMIGRATION_NO_JOBS:
                                text_draw("Lack of jobs prevents immigration", screen_center_x - 84, screen_center_y - 74, FONT_NORMAL_GREEN, COLOR_BLACK);
                                break;
                            case NO_IMMIGRATION_NO_FOOD:
                                text_draw("Lack of food prevents immigration", screen_center_x - 84, screen_center_y - 74, FONT_NORMAL_GREEN, COLOR_BLACK);
                                break;
                            case NO_IMMIGRATION_HIGH_TAXES:
                                text_draw("High taxes prevent immigration", screen_center_x - 84, screen_center_y - 74, FONT_NORMAL_GREEN, COLOR_BLACK);
                                break;
                            case NO_IMMIGRATION_MANY_TENTS:
                                text_draw("Having some slums prevents immigration", screen_center_x - 84, screen_center_y - 74, FONT_NORMAL_GREEN, COLOR_BLACK);
                                break;
                            case NO_IMMIGRATION_LOW_MOOD:
                                text_draw("Poor city mood prevents immigration", screen_center_x - 84, screen_center_y - 74, FONT_NORMAL_GREEN, COLOR_BLACK);
                                break;
                        }
                    }
                    // food stocks
                    draw_title_advisors(screen_center_y - 54, "Food stocks");
                    if (scenario.rome_supplies_wheat) {
                        text_draw("Rome supplies all our needs", screen_center_x - 84, screen_center_y - 54, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else if (city_data.resource.food_supply_months) {
                        width = text_draw("Supplies for", screen_center_x - 84, screen_center_y - 54, FONT_NORMAL_GREEN, COLOR_BLACK);
                        text_draw_number(city_data.resource.food_supply_months, 0, "Month", screen_center_x - 84 + width, screen_center_y - 54, FONT_NORMAL_GREEN);
                    } else {
                        text_draw("Our food levels are low", screen_center_x - 84, screen_center_y - 54, FONT_NORMAL_RED, COLOR_BLACK);
                    }
                    // food consumption
                    draw_title_advisors(screen_center_y - 34, "Food consumption");
                    if (scenario.rome_supplies_wheat) {
                        text_draw("Rome supplies all our needs", screen_center_x - 84, screen_center_y - 34, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else {
                        int pct = calc_percentage(city_data.resource.food_produced_last_month, city_data.resource.food_consumed_last_month);
                        if (pct > 150) {
                            text_draw("We produce much more than we eat", screen_center_x - 84, screen_center_y - 34, FONT_NORMAL_GREEN, COLOR_BLACK);
                        } else if (pct > 105) {
                            text_draw("We produce a little more than we eat", screen_center_x - 84, screen_center_y - 34, FONT_NORMAL_GREEN, COLOR_BLACK);
                        } else if (pct > 95) {
                            text_draw("We produce just enough to feed everyone", screen_center_x - 84, screen_center_y - 34, FONT_NORMAL_GREEN, COLOR_BLACK);
                        } else if (pct > 75) {
                            text_draw("We eat a little more than we produce", screen_center_x - 84, screen_center_y - 34, FONT_NORMAL_RED, COLOR_BLACK);
                        } else if (pct > 30) {
                            text_draw("We eat more than we produce", screen_center_x - 84, screen_center_y - 34, FONT_NORMAL_RED, COLOR_BLACK);
                        } else if (pct > 0) {
                            text_draw("We eat much more than we produce", screen_center_x - 84, screen_center_y - 34, FONT_NORMAL_RED, COLOR_BLACK);
                        } else {
                            text_draw("NO FOOD stored last month!", screen_center_x - 84, screen_center_y - 34, FONT_NORMAL_RED, COLOR_BLACK);
                        }
                    }
                    // military
                    draw_title_advisors(screen_center_y - 14, "Military");
                    if (city_data.figure.imperial_soldiers) {
                        text_draw("Imperial troops at our gates", screen_center_x - 84, screen_center_y - 14, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (city_data.figure.enemies) {
                        text_draw("Enemies are attacking the city", screen_center_x - 84, screen_center_y - 14, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (scenario.invasion_upcoming) {
                        text_draw("Enemies are closing on the city", screen_center_x - 84, screen_center_y - 14, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (city_military_distant_battle_roman_army_is_traveling()) {
                        text_draw("We have troops elsewhere", screen_center_x - 84, screen_center_y - 14, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else if (city_data.distant_battle.months_until_battle) {
                        text_draw("Our troops are needed elsewhere", screen_center_x - 84, screen_center_y - 14, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (city_data.figure.soldiers) {
                        text_draw("We have no reported threats", screen_center_x - 84, screen_center_y - 14, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else {
                        text_draw("You have no legions to command", screen_center_x - 84, screen_center_y - 14, FONT_NORMAL_GREEN, COLOR_BLACK);
                    }
                    // crime
                    draw_title_advisors(screen_center_y + 6, "Crime");
                    if (city_data.figure.rioters) {
                        text_draw("Citizens are rioting!", screen_center_x - 84, screen_center_y + 6, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (city_data.sentiment.criminals > 10) {
                        text_draw("Crime is endemic in the city", screen_center_x - 84, screen_center_y + 6, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (city_data.sentiment.criminals) {
                        text_draw("Some areas have high crime levels", screen_center_x - 84, screen_center_y + 6, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (city_data.sentiment.protesters) {
                        text_draw("Some areas have minor troubles", screen_center_x - 84, screen_center_y + 6, FONT_NORMAL_RED, COLOR_BLACK);
                    } else {
                        text_draw("No problems reported", screen_center_x - 84, screen_center_y + 6, FONT_NORMAL_GREEN, COLOR_BLACK);
                    }
                    // health
                    draw_title_advisors(screen_center_y + 26, "Health");
                    if (city_data.health.value == 100) {
                        text_draw("City health is perfect", screen_center_x - 84, screen_center_y + 26, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else if (city_data.health.value >= 90) {
                        text_draw("City health is almost perfect", screen_center_x - 84, screen_center_y + 26, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else if (city_data.health.value >= 80) {
                        text_draw("City health is excellent", screen_center_x - 84, screen_center_y + 26, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else if (city_data.health.value >= 70) {
                        text_draw("City health is very good", screen_center_x - 84, screen_center_y + 26, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else if (city_data.health.value >= 60) {
                        text_draw("City health is good", screen_center_x - 84, screen_center_y + 26, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else if (city_data.health.value >= 50) {
                        text_draw("City health is average", screen_center_x - 84, screen_center_y + 26, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else if (city_data.health.value >= 40) {
                        text_draw("City health is below average", screen_center_x - 84, screen_center_y + 26, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (city_data.health.value >= 30) {
                        text_draw("City health is poor", screen_center_x - 84, screen_center_y + 26, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (city_data.health.value >= 20) {
                        text_draw("City health is bad", screen_center_x - 84, screen_center_y + 26, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (city_data.health.value >= 10) {
                        text_draw("City health is terrible", screen_center_x - 84, screen_center_y + 26, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (city_data.health.value >= 0) {
                        text_draw("City health is appalling", screen_center_x - 84, screen_center_y + 26, FONT_NORMAL_RED, COLOR_BLACK);
                    }
                    // education
                    draw_title_advisors(screen_center_y + 46, "Education");
                    if (city_data.houses.education == 1) {
                        text_draw("Some citizens want more schools", screen_center_x - 84, screen_center_y + 46, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (city_data.houses.education == 2) {
                        text_draw("Some citizens want more libraries", screen_center_x - 84, screen_center_y + 46, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (city_data.houses.education == 3) {
                        text_draw("Some citizens demand more education", screen_center_x - 84, screen_center_y + 46, FONT_NORMAL_RED, COLOR_BLACK);
                    } else {
                        text_draw("No problems reported", screen_center_x - 84, screen_center_y + 46, FONT_NORMAL_GREEN, COLOR_BLACK);
                    }
                    // religion
                    draw_title_advisors(screen_center_y + 66, "Religion");
                    if (city_data.houses.religion == 1) {
                        text_draw("Most demands are for basic access", screen_center_x - 84, screen_center_y + 66, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (city_data.houses.religion == 2) {
                        text_draw("Most demands are for more access", screen_center_x - 84, screen_center_y + 66, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (city_data.houses.religion == 3) {
                        text_draw("Demands for access to a third religion", screen_center_x - 84, screen_center_y + 66, FONT_NORMAL_RED, COLOR_BLACK);
                    } else {
                        text_draw("All needs are met", screen_center_x - 84, screen_center_y + 66, FONT_NORMAL_GREEN, COLOR_BLACK);
                    }
                    // entertainment
                    draw_title_advisors(screen_center_y + 86, "Entertainment");
                    if (city_data.houses.entertainment == 1) {
                        text_draw("Most demands are for basic access", screen_center_x - 84, screen_center_y + 86, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (city_data.houses.entertainment == 2) {
                        text_draw("Most demands are for better access", screen_center_x - 84, screen_center_y + 86, FONT_NORMAL_RED, COLOR_BLACK);
                    } else {
                        text_draw("All needs are met", screen_center_x - 84, screen_center_y + 86, FONT_NORMAL_GREEN, COLOR_BLACK);
                    }
                    // sentiment
                    draw_title_advisors(screen_center_y + 106, "City sentiment");
                    if (city_data.sentiment.value == 100) {
                        text_draw("People idolize you as a god", screen_center_x - 84, screen_center_y + 106, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else if (city_data.sentiment.value >= 90) {
                        text_draw("People love you", screen_center_x - 84, screen_center_y + 106, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else if (city_data.sentiment.value >= 80) {
                        text_draw("People are extremely pleased with you", screen_center_x - 84, screen_center_y + 106, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else if (city_data.sentiment.value >= 70) {
                        text_draw("People are very pleased with you", screen_center_x - 84, screen_center_y + 106, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else if (city_data.sentiment.value >= 60) {
                        text_draw("People are pleased with you", screen_center_x - 84, screen_center_y + 106, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else if (city_data.sentiment.value >= 50) {
                        text_draw("People are indifferent to you", screen_center_x - 84, screen_center_y + 106, FONT_NORMAL_GREEN, COLOR_BLACK);
                    } else if (city_data.sentiment.value >= 40) {
                        text_draw("People are annoyed with you", screen_center_x - 84, screen_center_y + 106, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (city_data.sentiment.value >= 30) {
                        text_draw("People are upset with you", screen_center_x - 84, screen_center_y + 106, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (city_data.sentiment.value >= 20) {
                        text_draw("People are very upset with you", screen_center_x - 84, screen_center_y + 106, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (city_data.sentiment.value >= 10) {
                        text_draw("People are angry with you", screen_center_x - 84, screen_center_y + 106, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (city_data.sentiment.value >= 0) {
                        text_draw("People are very angry with you", screen_center_x - 84, screen_center_y + 106, FONT_NORMAL_RED, COLOR_BLACK);
                    } else { // ?
                        text_draw("You are loathed throughout the city", screen_center_x - 84, screen_center_y + 106, FONT_NORMAL_RED, COLOR_BLACK);
                    }
                    refresh_current_window = 0;
                }
                break;
            case WINDOW_SET_SALARY:
                if (refresh_current_window) {
                    outer_panel_draw(screen_center_x - 160, screen_center_y - 160, 20, 20);
                    image_draw(1202, screen_center_x - 144, screen_center_y - 138); // Coin image
                    text_draw_centered("Set salary level", screen_center_x - 160, screen_center_y - 140, 320, FONT_LARGE_BLACK, COLOR_BLACK);
                    refresh_current_window = 0;
                }
                inner_panel_draw(screen_center_x - 144, screen_center_y - 96, 18, 15);
                for (int rank = 0; rank < 11; rank++) {
                    int font = FONT_NORMAL_WHITE;
                    if (mouse_x >= screen_center_x - 104 && mouse_x < screen_center_x + 125 && mouse_y >= screen_center_y - 84 + 20 * rank && mouse_y < screen_center_y - 68 + 20 * rank) {
                        font = FONT_NORMAL_RED;
                    }
                    int width = text_draw(initial_rank_strings[rank], screen_center_x - 104, screen_center_y - 84 + 20 * rank, font, COLOR_BLACK);
                    width += text_draw("'s salary of", screen_center_x - 104 + width, screen_center_y - 84 + 20 * rank, font, COLOR_BLACK);
                    text_draw_number(SALARY_FOR_RANK[rank], 0, " Dn", screen_center_x - 104 + width, screen_center_y - 84 + 20 * rank, font);
                }
                break;
            case WINDOW_GIFT_TO_EMPEROR:
                if (refresh_current_window) {
                    outer_panel_draw(screen_center_x - 240, screen_center_y - 96, 30, 12);
                    image_draw(1202, screen_center_x - 224, screen_center_y - 74); // Coin image
                    text_draw_centered("Send the Emperor a gift", screen_center_x - 240, screen_center_y - 76, 480, FONT_LARGE_BLACK, COLOR_BLACK);
                    refresh_current_window = 0;
                }
                inner_panel_draw(screen_center_x - 224, screen_center_y - 40, 28, 5);
                if (city_data.emperor.gifts[GIFT_MODEST].cost <= city_data.emperor.personal_savings) {
                    text_draw("Modest:", screen_center_x - 208, screen_center_y - 32, FONT_NORMAL_WHITE, COLOR_BLACK);
                    int font = FONT_NORMAL_WHITE;
                    if (mouse_x >= screen_center_x - 108 && mouse_x < screen_center_x + 200 && mouse_y >= screen_center_y - 32 && mouse_y < screen_center_y - 16) {
                        font = FONT_NORMAL_RED;
                    }
                    int width = text_draw(MODEST_GIFT_STRINGS[city_data.emperor.gifts[GIFT_MODEST].id], screen_center_x - 108, screen_center_y - 32, font, COLOR_BLACK);
                    text_draw_number(city_data.emperor.gifts[GIFT_MODEST].cost, 0, " Dn", screen_center_x - 108 + width, screen_center_y - 32, font);
                } else {
                    text_draw_multiline("You do not have enough personal savings to pay for a gift to the Emperor. Try paying yourself a bigger salary!", screen_center_x - 208, screen_center_y - 24, 416, FONT_NORMAL_WHITE, COLOR_BLACK);
                }
                if (city_data.emperor.gifts[GIFT_GENEROUS].cost <= city_data.emperor.personal_savings) {
                    text_draw("Generous:", screen_center_x - 208, screen_center_y - 8, FONT_NORMAL_WHITE, COLOR_BLACK);
                    int font = FONT_NORMAL_WHITE;
                    if (mouse_x >= screen_center_x - 108 && mouse_x < screen_center_x + 200 && mouse_y >= screen_center_y - 8 && mouse_y < screen_center_y + 8) {
                        font = FONT_NORMAL_RED;
                    }
                    int width = text_draw(GENEROUS_GIFT_STRINGS[city_data.emperor.gifts[GIFT_GENEROUS].id], screen_center_x - 108, screen_center_y - 8, font, COLOR_BLACK);
                    text_draw_number(city_data.emperor.gifts[GIFT_GENEROUS].cost, 0, " Dn", screen_center_x - 108 + width, screen_center_y - 8, font);
                }
                if (city_data.emperor.gifts[GIFT_LAVISH].cost <= city_data.emperor.personal_savings) {
                    text_draw("Lavish:", screen_center_x - 208, screen_center_y + 16, FONT_NORMAL_WHITE, COLOR_BLACK);
                    int font = FONT_NORMAL_WHITE;
                    if (mouse_x >= screen_center_x - 108 && mouse_x < screen_center_x + 200 && mouse_y >= screen_center_y + 16 && mouse_y < screen_center_y + 32) {
                        font = FONT_NORMAL_RED;
                    }
                    int width = text_draw(LAVISH_GIFT_STRINGS[city_data.emperor.gifts[GIFT_LAVISH].id], screen_center_x - 108, screen_center_y + 16, font, COLOR_BLACK);
                    text_draw_number(city_data.emperor.gifts[GIFT_LAVISH].cost, 0, " Dn", screen_center_x - 108 + width, screen_center_y + 16, font);
                }
                int width = text_draw("Time since last gift:", screen_center_x - 128, screen_center_y + 56, FONT_NORMAL_BLACK, COLOR_BLACK);
                text_draw_number(city_data.emperor.months_since_gift, 0, " Months", screen_center_x - 128 + width, screen_center_y + 56, FONT_NORMAL_BLACK);
                break;
            case WINDOW_DONATE_TO_CITY:
                outer_panel_draw(screen_center_x - 216, screen_center_y - 64, 27, 8);
                image_draw(1202, screen_center_x - 200, screen_center_y - 48);
                text_draw_centered("Give money to the city", screen_center_x - 216, screen_center_y - 44, 432, FONT_LARGE_BLACK, COLOR_BLACK);
                inner_panel_draw(screen_center_x - 200, screen_center_y - 16, 25, 4);
                if (mouse_x >= screen_center_x - 184 && mouse_x < screen_center_x - 120 && mouse_y >= screen_center_y - 8 && mouse_y < screen_center_y + 12) {
                    button_border_draw(screen_center_x - 184, screen_center_y - 8, 64, 20, 1);
                } else {
                    button_border_draw(screen_center_x - 184, screen_center_y - 8, 64, 20, 0);
                }
                text_draw_number_centered(200, screen_center_x - 184, screen_center_y - 3, 64, FONT_NORMAL_WHITE);
                if (mouse_x >= screen_center_x - 104 && mouse_x < screen_center_x - 40 && mouse_y >= screen_center_y - 8 && mouse_y < screen_center_y + 12) {
                    button_border_draw(screen_center_x - 104, screen_center_y - 8, 64, 20, 1);
                } else {
                    button_border_draw(screen_center_x - 104, screen_center_y - 8, 64, 20, 0);
                }
                text_draw_number_centered(500, screen_center_x - 104, screen_center_y - 3, 64, FONT_NORMAL_WHITE);
                text_draw("Donation is", screen_center_x - 22, screen_center_y - 3, FONT_NORMAL_WHITE, COLOR_BLACK);
                text_draw_number(city_data.emperor.donate_amount, 0, 0, screen_center_x + 76, screen_center_y - 3, FONT_NORMAL_GREEN);
                draw_arrow_button(15, screen_center_x + 128, screen_center_y - 10, 1);
                draw_arrow_button(17, screen_center_x + 152, screen_center_y - 10, 2);
                if (current_window_image_button_pressed && current_time > button_last_update_time + BUTTON_REPEAT_DELAY_TIME) {
                    button_last_update_time = current_time;
                    if (current_window_image_button_pressed == 1) {
                        adjust_donation_amount(1);
                    } else if (current_window_image_button_pressed == 2) {
                        adjust_donation_amount(-1);
                    }
                }
                if (mouse_x >= screen_center_x - 184 && mouse_x < screen_center_x - 120 && mouse_y >= screen_center_y + 20 && mouse_y < screen_center_y + 40) {
                    button_border_draw(screen_center_x - 184, screen_center_y + 20, 64, 20, 1);
                } else {
                    button_border_draw(screen_center_x - 184, screen_center_y + 20, 64, 20, 0);
                }
                text_draw_number_centered(2000, screen_center_x - 184, screen_center_y + 25, 64, FONT_NORMAL_WHITE);
                if (mouse_x >= screen_center_x - 104 && mouse_x < screen_center_x - 40 && mouse_y >= screen_center_y + 20 && mouse_y < screen_center_y + 40) {
                    button_border_draw(screen_center_x - 104, screen_center_y + 20, 64, 20, 1);
                } else {
                    button_border_draw(screen_center_x - 104, screen_center_y + 20, 64, 20, 0);
                }
                text_draw_number_centered(5000, screen_center_x - 104, screen_center_y + 25, 64, FONT_NORMAL_WHITE);
                if (mouse_x >= screen_center_x - 24 && mouse_x < screen_center_x + 40 && mouse_y >= screen_center_y + 20 && mouse_y < screen_center_y + 40) {
                    button_border_draw(screen_center_x - 24, screen_center_y + 20, 64, 20, 1);
                } else {
                    button_border_draw(screen_center_x - 24, screen_center_y + 20, 64, 20, 0);
                }
                text_draw_centered("All", screen_center_x - 24, screen_center_y + 25, 64, FONT_NORMAL_WHITE, COLOR_BLACK);
                if (mouse_x >= screen_center_x + 56 && mouse_x < screen_center_x + 176 && mouse_y >= screen_center_y + 20 && mouse_y < screen_center_y + 40) {
                    button_border_draw(screen_center_x + 56, screen_center_y + 20, 120, 20, 1);
                } else {
                    button_border_draw(screen_center_x + 56, screen_center_y + 20, 120, 20, 0);
                }
                text_draw_centered("Give money", screen_center_x + 56, screen_center_y + 25, 120, FONT_NORMAL_GREEN, COLOR_BLACK);
                break;
            case WINDOW_RESOURCE_SETTINGS:
                if (refresh_current_window) {
                    outer_panel_draw(screen_center_x - 272, screen_center_y - 120, 34, 15);
                    image_draw(resource_images[resource_settings_data.resource].icon_img_id + resource_image_offset(resource_settings_data.resource, RESOURCE_IMAGE_ICON), screen_center_x - 256, screen_center_y - 104);
                    text_draw_centered(resource_strings[resource_settings_data.resource], screen_center_x - 272, screen_center_y - 100, 544, FONT_LARGE_BLACK, COLOR_BLACK);
                    refresh_current_window = 0;
                }
                if (city_data.resource.mothballed[resource_settings_data.resource]) {
                    text_draw_number(count_data.industry[resource_settings_data.resource].total, 0, " mothballed industries in the city", screen_center_x - 240, screen_center_y - 64, FONT_NORMAL_BLACK);
                } else {
                    if (count_data.industry[resource_settings_data.resource].total) {
                        if (count_data.industry[resource_settings_data.resource].total == count_data.industry[resource_settings_data.resource].active) {
                            text_draw_number(count_data.industry[resource_settings_data.resource].total, 0, " working industries in the city", screen_center_x - 240, screen_center_y - 64, FONT_NORMAL_BLACK);
                        } else if (count_data.industry[resource_settings_data.resource].total > count_data.industry[resource_settings_data.resource].active) {
                            int width = text_draw_number(count_data.industry[resource_settings_data.resource].active, 0, " working", screen_center_x - 240, screen_center_y - 64, FONT_NORMAL_BLACK);
                            text_draw_number(count_data.industry[resource_settings_data.resource].total - count_data.industry[resource_settings_data.resource].active, 0, " idle industries in the city", 109 + width, 164, FONT_NORMAL_BLACK);
                        }
                    } else {
                        text_draw("No industry in the city", screen_center_x - 240, screen_center_y - 64, FONT_NORMAL_BLACK, COLOR_BLACK);
                    }
                }
                text_draw_number(city_data.resource.stored_in_warehouses[resource_settings_data.resource], 0, " stored in the city's warehouses", screen_center_x - 240, screen_center_y - 44, FONT_NORMAL_BLACK);
                // Import/Export
                int trade_flags = TRADE_STATUS_NONE;
                if (resource_import_trade_route_open(resource_settings_data.resource)) {
                    trade_flags |= TRADE_STATUS_IMPORT;
                }
                if (resource_export_trade_route_open(resource_settings_data.resource)) {
                    trade_flags |= TRADE_STATUS_EXPORT;
                }
                if (trade_flags) {
                    if (mouse_x >= screen_center_x - 216 && mouse_x < screen_center_x + 216 && mouse_y >= screen_center_y - 24 && mouse_y < screen_center_y + 6) {
                        button_border_draw(screen_center_x - 216, screen_center_y - 24, 432, 30, 1);
                    } else {
                        button_border_draw(screen_center_x - 216, screen_center_y - 24, 432, 30, 0);
                    }
                    switch (city_data.resource.trade_status[resource_settings_data.resource]) {
                        case TRADE_STATUS_NONE:
                            text_draw_centered("Not trading", screen_center_x - 216, screen_center_y - 15, 432, FONT_NORMAL_BLACK, COLOR_BLACK);
                            break;
                        case TRADE_STATUS_IMPORT:
                            text_draw_centered("Importing goods", screen_center_x - 216, screen_center_y - 15, 432, FONT_NORMAL_BLACK, COLOR_BLACK);
                            break;
                        case TRADE_STATUS_EXPORT:
                            text_draw("Export goods over", screen_center_x - 140, screen_center_y - 15, FONT_NORMAL_BLACK, COLOR_BLACK);
                            draw_arrow_button(15, screen_center_x + 28, screen_center_y - 21, 1);
                            draw_arrow_button(17, screen_center_x + 52, screen_center_y - 21, 2);
                            text_draw_number(city_data.resource.export_over[resource_settings_data.resource], 0, " Units", screen_center_x + 90, screen_center_y - 15, FONT_NORMAL_BLACK);
                            break;
                    }
                } else {
                    text_draw("There are no trade routes open for these goods", screen_center_x - 240, screen_center_y - 24, FONT_NORMAL_BLACK, COLOR_BLACK);
                }
                if (count_data.industry[resource_settings_data.resource].total) {
                    if (mouse_x >= screen_center_x - 216 && mouse_x < screen_center_x + 216 && mouse_y >= screen_center_y + 16 && mouse_y < screen_center_y + 46) {
                        button_border_draw(screen_center_x - 216, screen_center_y + 16, 432, 30, 1);
                    } else {
                        button_border_draw(screen_center_x - 216, screen_center_y + 16, 432, 30, 0);
                    }
                    if (city_data.resource.mothballed[resource_settings_data.resource]) {
                        text_draw_centered("Industry is OFF", screen_center_x - 216, screen_center_y + 25, 432, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else {
                        text_draw_centered("Industry is ON", screen_center_x - 216, screen_center_y + 25, 432, FONT_NORMAL_BLACK, COLOR_BLACK);
                    }
                }
                if (mouse_x >= screen_center_x - 216 && mouse_x < screen_center_x + 216 && mouse_y >= screen_center_y + 56 && mouse_y < screen_center_y + 106) {
                    button_border_draw(screen_center_x - 216, screen_center_y + 56, 432, 50, 1);
                } else {
                    button_border_draw(screen_center_x - 216, screen_center_y + 56, 432, 50, 0);
                }
                if (city_data.resource.stockpiled[resource_settings_data.resource]) {
                    text_draw_centered("Stockpiling resource", screen_center_x - 216, 284, 432, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered("Click here to turn off stockpiling", screen_center_x - 216, 304, 432, FONT_NORMAL_BLACK, COLOR_BLACK);
                } else {
                    text_draw_centered("Using and trading this resource", screen_center_x - 216, screen_center_y + 64, 432, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered("Click here to stockpile it", screen_center_x - 216, screen_center_y + 84, 432, FONT_NORMAL_BLACK, COLOR_BLACK);
                }
                break;
            case WINDOW_TRADE_PRICES:
                if (refresh_current_window) {
                    graphics_shade_rect(screen_center_x - 288, screen_center_y - 156, 574, 334, 0);
                    outer_panel_draw(screen_center_x - 304, screen_center_y - 80, 38, 10);
                    image_draw(1202, screen_center_x - 288, screen_center_y - 64); // Coin image
                    text_draw_centered("Prices set by Rome", screen_center_x - 304, screen_center_y - 60, 608, FONT_LARGE_BLACK, COLOR_BLACK);
                    refresh_current_window = 0;
                }
                text_draw("Buyers pay", screen_center_x - 288, screen_center_y + 14, FONT_NORMAL_BLACK, COLOR_BLACK);
                text_draw("Sellers receive", screen_center_x - 288, screen_center_y + 40, FONT_NORMAL_BLACK, COLOR_BLACK);
                for (int i = RESOURCE_WHEAT; i < RESOURCE_TYPES_MAX; i++) {
                    image_draw(resource_images[i].icon_img_id + resource_image_offset(i, RESOURCE_IMAGE_ICON), screen_center_x - 188 + 30 * i, screen_center_y - 20);
                    text_draw_number_centered(trade_prices[i].buy, screen_center_x - 191 + 30 * i, screen_center_y + 14, 30, FONT_SMALL_PLAIN);
                    text_draw_number_centered(trade_prices[i].sell, screen_center_x - 191 + 30 * i, screen_center_y + 40, 30, FONT_SMALL_PLAIN);
                }
                break;
            case WINDOW_EMPIRE:
                if (refresh_current_window) {
                    empire_x_min = current_resolution_width <= 2032 ? 0 : (current_resolution_width - 2032) / 2; // the_empire.bmp width = 2000, vertical borders = 16*2=32 
                    empire_x_max = current_resolution_width <= 2032 ? current_resolution_width : empire_x_min + 2032;
                    empire_y_min = current_resolution_height <= 1168 ? 0 : (current_resolution_height - 1168) / 2; // the_empire.bmp height = 1000, horizontal bars = 3*16, bottom panel = 3*40, altogether 168
                    empire_y_max = current_resolution_height <= 1168 ? current_resolution_height : empire_y_min + 1168;
                    graphics_set_clip_rectangle(empire_x_min, empire_y_min, empire_x_max - empire_x_min, empire_y_max - empire_y_min);
                    // bottom panel background
                    for (int x = empire_x_min + 16; x < empire_x_max - 16; x += 70) {
                        image_draw(7976, x, empire_y_max - 136);
                        image_draw(7976, x, empire_y_max - 96);
                        image_draw(7976, x, empire_y_max - 56);
                    }
                    // vertical bar borders
                    for (int y = empire_y_min + 16; y < empire_y_max - 16; y += 86) {
                        image_draw(7973, empire_x_min, y);
                        image_draw(7973, empire_x_max - 16, y);
                    }
                    // horizontal bar borders
                    for (int x = empire_x_min + 16; x < empire_x_max - 16; x += 86) {
                        image_draw(7974, x, empire_y_min);
                        image_draw(7974, x, empire_y_max - 152);
                        image_draw(7974, x, empire_y_max - 16);
                    }
                    // crossbars
                    image_draw(7975, empire_x_min, empire_y_min); // top left
                    image_draw(7975, empire_x_min, empire_y_max - 152); // bottom left above bottom panel
                    image_draw(7975, empire_x_min, empire_y_max - 16); // bottom left below bottom panel
                    image_draw(7975, empire_x_max - 16, empire_y_min); // top right
                    image_draw(7975, empire_x_max - 16, empire_y_max - 152); // bottom right above bottom panel
                    image_draw(7975, empire_x_max - 16, empire_y_max - 16); // bottom right below bottom panel
                    graphics_reset_clip_rectangle();
                    refresh_current_window = 0;
                }
                scroll_empire_arrow_keys();
                graphics_set_clip_rectangle(empire_x_min + 16, empire_y_min + 16, empire_x_max - empire_x_min - 32, empire_y_max - empire_y_min - 168);
                image_draw(7972, empire_x_min + 16 - empire_data.scroll_x, empire_y_min + 16 - empire_data.scroll_y); // draw the_empire.bmp
                for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
                    if (empire_objects[i].in_use) {
                        // don't draw trade routes that aren't open
                        if ((empire_objects[i].type == EMPIRE_OBJECT_LAND_TRADE_ROUTE || empire_objects[i].type == EMPIRE_OBJECT_SEA_TRADE_ROUTE)
                        && !get_trade_city_by_trade_route(empire_objects[i].trade_route_id)->trade_route_open) {
                            continue;
                        }
                        if (empire_objects[i].type == EMPIRE_OBJECT_BATTLE_ICON) {
                            for (int j = 0; j < MAX_INVASIONS; j++) {
                                int battle_icon_year_abs = time_data.year + empire_objects[i].invasion_years;
                                int invasion_year_abs = scenario.start_year + scenario.invasions[j].year_offset;
                                // check that invasion is yet to come
                                if (scenario.invasions[j].type == INVASION_TYPE_ENEMY_ARMY
                                && (time_data.year < invasion_year_abs || (time_data.year == invasion_year_abs && time_data.month < scenario.invasions[j].month))) {
                                    // draw up to 3 battle icons per invasion, 1 per year
                                    if (empire_objects[i].invasion_path_id == (j % 3) + 1
                                    && (battle_icon_year_abs > invasion_year_abs || (battle_icon_year_abs == invasion_year_abs && time_data.month >= scenario.invasions[j].month))
                                    ) {
                                        image_draw(empire_objects[i].image_id, empire_x_min + 16 + empire_objects[i].x, empire_y_min + 16 + empire_objects[i].y);
                                    }
                                }

                            }
                            continue;
                        }
                        if (empire_objects[i].type == EMPIRE_OBJECT_ENEMY_ARMY
                        && (!city_data.distant_battle.months_until_battle || city_data.distant_battle.enemy_months_traveled != empire_objects[i].distant_battle_travel_months)) {
                            continue;
                        }
                        if (empire_objects[i].type == EMPIRE_OBJECT_ROMAN_ARMY
                        && (!city_military_distant_battle_roman_army_is_traveling() || city_data.distant_battle.roman_months_traveled != empire_objects[i].distant_battle_travel_months)) {
                            continue;
                        }
                        int x, y, image_id;
                        if (scenario.empire.is_expanded) {
                            x = empire_objects[i].expanded.x;
                            y = empire_objects[i].expanded.y;
                            image_id = empire_objects[i].expanded.image_id;
                        } else {
                            x = empire_objects[i].x;
                            y = empire_objects[i].y;
                            image_id = empire_objects[i].image_id;
                        }
                        if (empire_objects[i].city_type == EMPIRE_CITY_FUTURE_TRADE) {
                            // Fix case where future trade city (as specified in the editor) is drawn as a trade city before expansion
                            image_id = 8017;
                        }
                        image_draw(image_id, empire_x_min + 16 + x - empire_data.scroll_x, empire_y_min + 16 + y - empire_data.scroll_y);
                        struct image_t *img = image_get(image_id);
                        if (img->animation_speed_id) {
                            image_draw(image_id + empire_object_update_animation(&empire_objects[i], image_id),
                                empire_x_min + 16 + x + img->sprite_offset_x - empire_data.scroll_x,
                                empire_y_min + 16 + y + img->sprite_offset_y - empire_data.scroll_y);
                        }
                    }
                }
                graphics_reset_clip_rectangle();
                draw_image_button(1162, empire_x_min + 16, empire_y_max - 135, 28, 28, 1); // trade advisor button
                if (selected_empire_object) {
                    switch (selected_empire_object->type) {
                        case EMPIRE_OBJECT_CITY:
                            image_draw(7979, empire_x_min + 16, empire_y_max - 230); // left bird ornament
                            image_draw(7980, empire_x_max - 93, empire_y_max - 230); // right bird ornament
                            image_draw(7981, (empire_x_min + empire_x_max - 332) / 2, empire_y_max - 219); // city name ornament, draw in the middle of bottom panel (322 img width)
                            text_draw_centered(city_names[selected_empire_object->city_name_id], empire_x_min + 16, empire_y_max - 156, empire_x_max - empire_x_min, FONT_LARGE_BLACK, COLOR_BLACK);
                            switch (selected_empire_object->city_type) {
                                case EMPIRE_CITY_OURS:
                                    text_draw_centered("Our city!", empire_x_min + 16, empire_y_max - 103, empire_x_max - empire_x_min, FONT_NORMAL_GREEN, COLOR_BLACK);
                                    break;
                                case EMPIRE_CITY_FUTURE_TRADE:
                                case EMPIRE_CITY_DISTANT_ROMAN:
                                    text_draw_centered("A Roman city", empire_x_min + 16, empire_y_max - 103, empire_x_max - empire_x_min, FONT_NORMAL_GREEN, COLOR_BLACK);
                                    break;
                                case EMPIRE_CITY_VULNERABLE_ROMAN:
                                    if (city_data.distant_battle.city_foreign_months_left <= 0) {
                                        text_draw_centered("A Roman city", empire_x_min + 16, empire_y_max - 103, empire_x_max - empire_x_min, FONT_NORMAL_GREEN, COLOR_BLACK);
                                    } else {
                                        text_draw_centered("A captured city", empire_x_min + 16, empire_y_max - 103, empire_x_max - empire_x_min, FONT_NORMAL_GREEN, COLOR_BLACK);
                                    }
                                    break;
                                case EMPIRE_CITY_DISTANT_FOREIGN:
                                case EMPIRE_CITY_FUTURE_ROMAN:
                                    text_draw_centered("A distant city", empire_x_min + 16, empire_y_max - 103, empire_x_max - empire_x_min, FONT_NORMAL_GREEN, COLOR_BLACK);
                                    break;
                                case EMPIRE_CITY_TRADE:
                                    if (selected_empire_object->trade_route_open) {
                                        // city buys
                                        int x_draw = (empire_x_min + empire_x_max - 440) / 2 + text_draw("Bought", (empire_x_min + empire_x_max - 440) / 2, empire_y_max - 102, FONT_NORMAL_GREEN, COLOR_BLACK);
                                        for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                            if (selected_empire_object->resource_buy_limit[r]) {
                                                int trade_max = selected_empire_object->resource_buy_limit[r];
                                                draw_trade_resource(r, selected_empire_object->resource_buy_limit[r], x_draw, empire_y_max - 109);
                                                if (selected_empire_object->resource_bought[r] > trade_max) {
                                                    trade_max = selected_empire_object->resource_bought[r];
                                                }
                                                int width = text_draw_number(selected_empire_object->resource_bought[r], 0, " of", x_draw + 34, empire_y_max - 102, FONT_NORMAL_GREEN);
                                                text_draw_number(trade_max, 0, 0, x_draw + 34 + width, empire_y_max - 102, FONT_NORMAL_GREEN);
                                                x_draw += 102;
                                            }
                                        }
                                        // city sells
                                        x_draw = (empire_x_min + empire_x_max - 440) / 2 + text_draw("Sold", (empire_x_min + empire_x_max - 440) / 2, empire_y_max - 62, FONT_NORMAL_GREEN, COLOR_BLACK);
                                        for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                            if (selected_empire_object->resource_sell_limit[r]) {
                                                int trade_max = selected_empire_object->resource_sell_limit[r];
                                                draw_trade_resource(r, selected_empire_object->resource_sell_limit[r], x_draw, empire_y_max - 69);
                                                if (selected_empire_object->resource_sold[r] > trade_max) {
                                                    trade_max = selected_empire_object->resource_sold[r];
                                                }
                                                int width = text_draw_number(selected_empire_object->resource_sold[r], 0, " of", x_draw + 34, empire_y_max - 62, FONT_NORMAL_GREEN);
                                                text_draw_number(trade_max, 0, 0, x_draw + 34 + width, empire_y_max - 62, FONT_NORMAL_GREEN);
                                                x_draw += 102;
                                            }
                                        }
                                    } else { // trade is closed
                                        int x_draw = (empire_x_min + empire_x_max - 440) / 2 + text_draw("Buys", (empire_x_min + empire_x_max - 440) / 2, empire_y_max - 102, FONT_NORMAL_GREEN, COLOR_BLACK);
                                        for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                            if (selected_empire_object->resource_buy_limit[r]) {
                                                draw_trade_resource(r, selected_empire_object->resource_buy_limit[r], x_draw, empire_y_max - 109);
                                                x_draw += 32;
                                            }
                                        }
                                        x_draw += 16;
                                        x_draw += text_draw("Sells", x_draw, empire_y_max - 102, FONT_NORMAL_GREEN, COLOR_BLACK);
                                        for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                            if (selected_empire_object->resource_sell_limit[r]) {
                                                draw_trade_resource(r, selected_empire_object->resource_sell_limit[r], x_draw, empire_y_max - 109);
                                                x_draw += 32;
                                            }
                                        }
                                        if (mouse_x >= (empire_x_min + empire_x_max - 440) / 2 && mouse_x < (empire_x_min + empire_x_max - 440) / 2 + 440
                                        && mouse_y >= empire_y_max - 70 && mouse_y < empire_y_max - 44) { // draw trade route open button
                                            button_border_draw((empire_x_min + empire_x_max - 440) / 2, empire_y_max - 70, 440, 26, 1);
                                        } else {
                                            button_border_draw((empire_x_min + empire_x_max - 440) / 2, empire_y_max - 70, 440, 26, 0);
                                        }
                                        int width = text_draw_number(selected_empire_object->trade_route_cost, 0, " Dn", (empire_x_min + empire_x_max - 440) / 2 + 8, empire_y_max - 63, FONT_NORMAL_GREEN);
                                        text_draw("to open trade route", (empire_x_min + empire_x_max - 440) / 2 + 8 + width, empire_y_max - 63, FONT_NORMAL_GREEN, COLOR_BLACK);
                                        image_draw(8072 - selected_empire_object->is_sea_trade, (empire_x_min + empire_x_max - 440) / 2 + 406, empire_y_max - 69 + 2 * selected_empire_object->is_sea_trade);
                                    }
                                    break;
                            }
                            break;
                        case EMPIRE_OBJECT_ROMAN_ARMY:
                            if (city_military_distant_battle_roman_army_is_traveling()) {
                                if (city_data.distant_battle.roman_months_traveled == selected_empire_object->distant_battle_travel_months) {
                                    if (city_data.distant_battle.roman_months_to_travel_forth) {
                                        text_draw_multiline("Your legion, marching to relieve a city of the Empire", (empire_x_min + empire_x_max - 240) / 2, empire_y_max - 68, 240, FONT_NORMAL_GREEN, COLOR_BLACK);
                                    } else {
                                        text_draw_multiline("Your legion, returning to your city", (empire_x_min + empire_x_max - 240) / 2, empire_y_max - 68, 240, FONT_NORMAL_GREEN, COLOR_BLACK);
                                    }
                                    break;
                                }
                            }
                            break;
                        case EMPIRE_OBJECT_ENEMY_ARMY:
                            if (city_data.distant_battle.months_until_battle) {
                                if (city_data.distant_battle.enemy_months_traveled == selected_empire_object->distant_battle_travel_months) {
                                    text_draw_multiline("An enemy army, threatening a city of the Empire", (empire_x_min + empire_x_max - 240) / 2, empire_y_max - 68, 240, FONT_NORMAL_GREEN, COLOR_BLACK);
                                    break;
                                }
                            }
                            break;
                        default:
                            text_draw_centered("Click on a city to get information on it", empire_x_min, empire_y_max - 65, empire_x_max - empire_x_min, FONT_NORMAL_GREEN, COLOR_BLACK);
                    }
                }
                break;
            case WINDOW_HOLD_FESTIVAL:
                if (refresh_current_window) {
                    draw_common_advisor_ui();
                    outer_panel_draw(screen_center_x - 272, screen_center_y - 144, 34, 18);
                    switch (city_data.festival.god) {
                        case 0:
                            text_draw_centered("Hold festival to Ceres", screen_center_x - 272, screen_center_y - 124, 544, FONT_LARGE_BLACK, COLOR_BLACK);
                            break;
                        case 1:
                            text_draw_centered("Hold festival to Neptune", screen_center_x - 272, screen_center_y - 124, 544, FONT_LARGE_BLACK, COLOR_BLACK);
                            break;
                        case 2:
                            text_draw_centered("Hold festival to Mercury", screen_center_x - 272, screen_center_y - 124, 544, FONT_LARGE_BLACK, COLOR_BLACK);
                            break;
                        case 3:
                            text_draw_centered("Hold festival to Mars", screen_center_x - 272, screen_center_y - 124, 544, FONT_LARGE_BLACK, COLOR_BLACK);
                            break;
                        case 4:
                            text_draw_centered("Hold festival to Venus", screen_center_x - 272, screen_center_y - 124, 544, FONT_LARGE_BLACK, COLOR_BLACK);
                            break;
                    }
                    // Small festival
                    text_draw("Small festival:", screen_center_x - 88, screen_center_y + 34, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number(festival_costs[FESTIVAL_SMALL], 0, " Dn", screen_center_x + 38, screen_center_y + 34, FONT_NORMAL_BLACK);
                    // Large festival
                    text_draw("Large festival:", screen_center_x - 90, screen_center_y + 68, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number(festival_costs[FESTIVAL_LARGE], 0, " Dn", screen_center_x + 38, screen_center_y + 68, FONT_NORMAL_BLACK);
                    // Grand festival
                    text_draw("Grand festival:", screen_center_x - 93, screen_center_y + 102, FONT_NORMAL_BLACK, COLOR_BLACK);
                    width = text_draw_number(festival_costs[FESTIVAL_GRAND], 0, " Dn", screen_center_x + 38, screen_center_y + 102, FONT_NORMAL_BLACK);
                    width += text_draw_number(city_data.population.population / 500 + 1, 0, " Units", screen_center_x + 46 + width, screen_center_y + 102, FONT_NORMAL_BLACK);
                    image_draw(1193, screen_center_x + 46 + width, screen_center_y + 98); // wine icon
                    // greying out of buttons
                    for (int i = 0; i < 3; i++) {
                        if (!city_finance_can_afford(festival_costs[i + 1])) {
                            graphics_shade_rect(screen_center_x - 222, screen_center_y + 29 + 34 * i, 444, 22, 0);
                        }
                    }
                    if (city_data.resource.stored_in_warehouses[RESOURCE_WINE] < city_data.population.population / 500 + 1) {
                        graphics_shade_rect(screen_center_x - 222, screen_center_y + 97, 444, 22, 0);
                    }
                    refresh_current_window = 0;
                }
                for (int god = 0; god < MAX_GODS; god++) {
                    if (god == city_data.festival.god) {
                        image_draw(7758 + god, screen_center_x - 222 + 91 * god, screen_center_y - 84);
                    } else {
                        image_draw(7753 + god, screen_center_x - 222 + 91 * god, screen_center_y - 84);
                    }
                }
                for (int i = 0; i < 3; i++) {
                    if (mouse_x >= screen_center_x - 224 && mouse_x < screen_center_x + 224 && mouse_y >= screen_center_y + 27 + 34 * i && mouse_y < screen_center_y + 53 + 34 * i) {
                        button_border_draw(screen_center_x - 224, screen_center_y + 27 + 34 * i, 448, 26, 01);
                    } else {
                        button_border_draw(screen_center_x - 224, screen_center_y + 27 + 34 * i, 448, 26, 0);
                    }
                }
                break;
            case WINDOW_MESSAGE_LIST:
                if (refresh_current_window) {
                    outer_panel_draw(map_center_x - 232, map_center_y - 144, 29, 18);
                    text_draw_centered("Messages from your scribes", map_center_x - 232, map_center_y - 124, 464, FONT_LARGE_BLACK, COLOR_BLACK);
                    inner_panel_draw(map_center_x - 208, map_center_y - 68, 26, 12);
                    if (message_data.total_messages) {
                        text_draw("Date", map_center_x - 192, map_center_y - 82, FONT_SMALL_PLAIN, COLOR_BLACK);
                        text_draw("Subject", map_center_x - 44, map_center_y - 82, FONT_SMALL_PLAIN, COLOR_BLACK);
                    } else {
                        text_draw_multiline("You currently have no messages to read. As your city grows or the Emperor asks you for goods, messages will be posted here", map_center_x - 192, map_center_y - 6, 384, FONT_NORMAL_GREEN, COLOR_BLACK);
                    }
                    refresh_current_window = 0;
                }
                if (message_data.total_messages) {
                    int max = message_data.total_messages < MAX_MESSAGES_IN_WINDOW ? message_data.total_messages : MAX_MESSAGES_IN_WINDOW;
                    // int index = scrollbar_message_list.scroll_position;
                    int index = 0;
                    for (int i = 0; i < max; i++, index++) {
                        struct lang_message_t *lang_msg = &lang_data.message_entries[city_message_get_text_id(message_data.messages[index].message_type)];
                        int image_offset = 0;
                        if (lang_msg->message_type == MESSAGE_TYPE_DISASTER) {
                            image_offset = 2;
                        }
                        if (message_data.messages[index].is_read) {
                            image_draw(982 + image_offset, map_center_x - 200, map_center_y - 62 + 20 * i);
                        } else {
                            image_draw(981 + image_offset, map_center_x - 202, map_center_y - 62 + 20 * i);
                        }
                        int font = FONT_NORMAL_WHITE;
                        if (mouse_x >= map_center_x - 168 && mouse_x < map_center_x + 192 && mouse_y >= map_center_y - 58 + 20 * i && mouse_y < map_center_y - 42 + 20 * i) {
                            font = FONT_NORMAL_RED;
                        }
                        int width = text_draw(short_month_names[message_data.messages[index].month], map_center_x - 168, map_center_y - 58 + 20 * i, font, COLOR_BLACK);
                        text_draw_year(message_data.messages[index].year, map_center_x - 168 + width, map_center_y - 58 + 20 * i, font);
                        text_draw(lang_msg->title.text, map_center_x - 44, map_center_y - 58 + 20 * i, font, COLOR_BLACK);
                    }
                    // scrollbar_draw(&scrollbar_message_list);
                }
                break;
            case WINDOW_MESSAGE_DIALOG:
                if (refresh_current_window) {
                    if (message_dialog_data.show_video) {
                        struct lang_message_t *msg = &lang_data.message_entries[message_dialog_data.text_id];
                        message_dialog_data.x = 32;
                        message_dialog_data.y = 28;
                        int small_font = 0;
                        // int lines_available = 4;
                        if (msg->type == TYPE_MESSAGE && msg->message_type == MESSAGE_TYPE_IMPERIAL) {
                            // lines_available = 3;
                        }
                        // rich_text_set_fonts(FONT_NORMAL_WHITE, FONT_NORMAL_RED, 5);
                        // rich_text_clear_links();
                        // int lines_required = draw_text_old(msg->content.text, 0, 0, 384, lines_available, 0, 1);
                        // if (lines_required > lines_available) {
                        //     small_font = 1;
                        //     // rich_text_set_fonts(FONT_SMALL_PLAIN, FONT_SMALL_PLAIN, 7);
                        //     lines_required = draw_text_old(msg->content.text, 0, 0, 384, lines_available, 0, 1);
                        // }
                        outer_panel_draw(message_dialog_data.x, message_dialog_data.y, 26, 28);
                        graphics_draw_rect(message_dialog_data.x + 7, message_dialog_data.y + 7, 402, 294, COLOR_BLACK);
                        int y_base = message_dialog_data.y + 308;
                        int inner_height_blocks = 6;
                        // if (lines_required > lines_available) {
                        //     // create space to cram an extra line into the dialog
                        //     y_base = y_base - 8;
                        //     inner_height_blocks += 1;
                        // }
                        inner_panel_draw(message_dialog_data.x + 8, y_base, 25, inner_height_blocks);
                        text_draw_centered(msg->title.text, message_dialog_data.x + 8, message_dialog_data.y + 414, 400, FONT_NORMAL_BLACK, 0);
                        int width = text_draw(short_month_names[player_message.month], message_dialog_data.x + 16, y_base + 4, FONT_NORMAL_WHITE, COLOR_BLACK);
                        width += text_draw_year(player_message.year, message_dialog_data.x + 18 + width, y_base + 4, FONT_NORMAL_WHITE);
                        if (msg->type == TYPE_MESSAGE && msg->message_type == MESSAGE_TYPE_DISASTER &&
                            message_dialog_data.text_id == MESSAGE_DIALOG_THEFT) {
                            lang_text_draw_amount(8, 0, player_message.param1, message_dialog_data.x + 90 + width, y_base + 4, FONT_NORMAL_WHITE);
                        } else {
                            width += lang_text_draw(63, 5, message_dialog_data.x + 70 + width, y_base + 4, FONT_NORMAL_WHITE);
                            text_draw(scenario_settings.player_name, message_dialog_data.x + 70 + width, y_base + 4, FONT_NORMAL_WHITE, 0);
                        }
                        message_dialog_data.text_height_blocks = msg->height_blocks - 1 - (32 + message_dialog_data.y_text - message_dialog_data.y) / BLOCK_SIZE;
                        message_dialog_data.text_width_blocks = msg->width_blocks - 4;
                        if (small_font) {
                            // Draw in black and then white to create shadow effect
                            // draw_text_old(msg->content.text, message_dialog_data.x + 16 + 1, y_base + 24 + 1, 384, message_dialog_data.text_height_blocks - 1, COLOR_BLACK, 0);
                            // draw_text_old(msg->content.text, message_dialog_data.x + 16, y_base + 24, 384, message_dialog_data.text_height_blocks - 1, COLOR_WHITE, 0);
                        } else {
                            // draw_text_old(msg->content.text, message_dialog_data.x + 16, y_base + 24, 384, message_dialog_data.text_height_blocks - 1, 0, 0);
                        }
                        if (msg->type == TYPE_MESSAGE && msg->message_type == MESSAGE_TYPE_IMPERIAL) {
                            int y_text = message_dialog_data.y + 384;
                            // if (lines_required > lines_available) {
                            //     y_text += 8;
                            // }
                            text_draw_number(scenario.requests[player_message.param1].amount, 0, 0, message_dialog_data.x + 8, y_text, FONT_NORMAL_WHITE);
                            image_draw(resource_images[scenario.requests[player_message.param1].resource].icon_img_id
                                + resource_image_offset(scenario.requests[player_message.param1].resource, RESOURCE_IMAGE_ICON),
                                message_dialog_data.x + 70, y_text - 5);
                            lang_text_draw(23, scenario.requests[player_message.param1].resource, message_dialog_data.x + 100, y_text, FONT_NORMAL_WHITE);
                            if (scenario.requests[player_message.param1].state == REQUEST_STATE_NORMAL || scenario.requests[player_message.param1].state == REQUEST_STATE_OVERDUE) {
                                width = lang_text_draw_amount(8, 4, scenario.requests[player_message.param1].months_to_comply, message_dialog_data.x + 200, y_text, FONT_NORMAL_WHITE);
                                lang_text_draw(12, 2, message_dialog_data.x + 200 + width, y_text, FONT_NORMAL_WHITE);
                            }
                        }
                        draw_foreground_video();
                    } else {
                        struct lang_message_t *msg = &lang_data.message_entries[message_dialog_data.text_id];
                        message_dialog_data.x = msg->x;
                        message_dialog_data.y = msg->y;
                        message_dialog_data.x_text = message_dialog_data.x + 16;
                        outer_panel_draw(map_center_x - 320, map_center_y - 200, 40, 25);
                        if (msg->title.text) {
                            int image_id;
                            if (!msg->image.id) {
                                image_id = 0;
                            } else if (!message_dialog_data.text_id) {
                                // message id = 0 ==> "about": fixed image position
                                image_id = 8129;
                            } else {
                                image_id = 7838 + msg->image.id;
                            }
                            struct image_t *img = image_id ? image_get(image_id) : 0;
                            text_draw_centered(msg->title.text, map_center_x - 320, map_center_y - 180, 640, FONT_LARGE_BLACK, COLOR_BLACK);
                            message_dialog_data.y_text = message_dialog_data.y + 48;
                            // picture
                            if (img) {
                                int image_x = msg->image.x;
                                int image_y = msg->image.y;
                                image_draw(image_id, message_dialog_data.x + image_x, message_dialog_data.y + image_y);
                                if (message_dialog_data.y + image_y + img->height + 8 > message_dialog_data.y_text) {
                                    message_dialog_data.y_text = message_dialog_data.y + image_y + img->height + 8;
                                }
                            }
                        }
                        if (msg->subtitle.x && msg->subtitle.text) {
                            int width = BLOCK_SIZE * (msg->width_blocks - 1) - msg->subtitle.x;
                            int height = text_draw_multiline(msg->subtitle.text,
                                message_dialog_data.x + msg->subtitle.x, message_dialog_data.y + msg->subtitle.y, width, FONT_NORMAL_BLACK, 0);
                            if (message_dialog_data.y + msg->subtitle.y + height > message_dialog_data.y_text) {
                                message_dialog_data.y_text = message_dialog_data.y + msg->subtitle.y + height;
                            }
                        }
                        if (msg->content.text) {
                            inner_panel_draw(map_center_x - 304, map_center_y - 140, 38, 20);
                            // graphics_set_clip_rectangle(message_dialog_data.x_text + 3, message_dialog_data.y_text + 3, BLOCK_SIZE * message_dialog_data.text_width_blocks - 6, BLOCK_SIZE * message_dialog_data.text_height_blocks - 6);
                            if (msg->type == TYPE_MESSAGE) {
                                int width = text_draw(short_month_names[player_message.month], map_center_x - 294, map_center_y - 130, FONT_NORMAL_WHITE, COLOR_BLACK);
                                width += text_draw_year(player_message.year, map_center_x - 294 + width, map_center_y - 130, FONT_NORMAL_WHITE);
                                if (msg->message_type == MESSAGE_TYPE_DISASTER && player_message.param1) {
                                    if (message_dialog_data.text_id == MESSAGE_DIALOG_THEFT) {
                                        // param1 = denarii
                                        lang_text_draw_amount(8, 0, player_message.param1, message_dialog_data.x + 240, message_dialog_data.y_text + 6, FONT_NORMAL_WHITE);
                                    } else {
                                        // param1 = building type
                                        lang_text_draw(41, player_message.param1, message_dialog_data.x + 240, message_dialog_data.y_text + 6, FONT_NORMAL_WHITE);
                                    }
                                } else {
                                    width += text_draw("To", map_center_x, map_center_y - 130, FONT_NORMAL_WHITE, COLOR_BLACK);
                                    text_draw(scenario_settings.player_name, map_center_x + width, map_center_y - 130, FONT_NORMAL_WHITE, COLOR_BLACK);
                                }
                                switch (msg->message_type) {
                                    case MESSAGE_TYPE_DISASTER:
                                    case MESSAGE_TYPE_INVASION:
                                        lang_text_draw(12, 1, message_dialog_data.x + 100, message_dialog_data.y_text + 44, FONT_NORMAL_WHITE); // remove this, move button to top right
                                        // draw_text_old(msg->content.text, message_dialog_data.x_text + 8, message_dialog_data.y_text + 86, BLOCK_SIZE * message_dialog_data.text_width_blocks, message_dialog_data.text_height_blocks - 1, 0, 0);
                                        break;
                                    case MESSAGE_TYPE_EMIGRATION:
                                    {
                                        if (city_data.sentiment.low_mood_cause >= 1 && city_data.sentiment.low_mood_cause <= 5) {
                                            int max_width = BLOCK_SIZE * (message_dialog_data.text_width_blocks - 1) - 64;
                                            lang_text_draw_multiline(12, city_data.sentiment.low_mood_cause + 2, message_dialog_data.x + 64, message_dialog_data.y_text + 44, max_width, FONT_NORMAL_WHITE);
                                        }
                                        // draw_text_old(msg->content.text, message_dialog_data.x_text + 8, message_dialog_data.y_text + 86, BLOCK_SIZE * (message_dialog_data.text_width_blocks - 1), message_dialog_data.text_height_blocks - 1, 0, 0);
                                        break;
                                    }
                                    case MESSAGE_TYPE_TRADE_CHANGE:
                                        image_draw(resource_image(player_message.param2), message_dialog_data.x + 64, message_dialog_data.y_text + 40);
                                        lang_text_draw(21, empire_objects[player_message.param1].city_name_id, message_dialog_data.x + 100, message_dialog_data.y_text + 44, FONT_NORMAL_WHITE);
                                        // draw_text_old(msg->content.text, message_dialog_data.x_text + 8, message_dialog_data.y_text + 86, BLOCK_SIZE * (message_dialog_data.text_width_blocks - 1),message_dialog_data.text_height_blocks - 1, 0, 0);
                                        break;
                                    case MESSAGE_TYPE_PRICE_CHANGE:
                                        image_draw(resource_image(player_message.param2), message_dialog_data.x + 64, message_dialog_data.y_text + 40);
                                        text_draw_money(player_message.param1, message_dialog_data.x + 100, message_dialog_data.y_text + 44, FONT_NORMAL_WHITE);
                                        // draw_text_old(msg->content.text,message_dialog_data.x_text + 8, message_dialog_data.y_text + 86, BLOCK_SIZE * (message_dialog_data.text_width_blocks - 1),message_dialog_data.text_height_blocks - 1, 0, 0);
                                        break;
                                    default:
                                    {
                                        // int lines = draw_text_old(msg->content.text, message_dialog_data.x_text + 8, message_dialog_data.y_text + 56, BLOCK_SIZE * (message_dialog_data.text_width_blocks - 1),message_dialog_data.text_height_blocks - 1, 0, 0);
                                        if (msg->message_type == MESSAGE_TYPE_IMPERIAL) {
                                            int y_offset = message_dialog_data.y_text + 86;
                                            text_draw_number(scenario.requests[player_message.param1].amount, '@', " ", message_dialog_data.x_text + 8, y_offset, FONT_NORMAL_WHITE);
                                            image_draw(resource_image(scenario.requests[player_message.param1].resource), message_dialog_data.x_text + 70, y_offset - 5);
                                            lang_text_draw(23, scenario.requests[player_message.param1].resource,
                                                message_dialog_data.x_text + 100, y_offset, FONT_NORMAL_WHITE);
                                            if (scenario.requests[player_message.param1].state == REQUEST_STATE_NORMAL || scenario.requests[player_message.param1].state == REQUEST_STATE_OVERDUE) {
                                                int comply_time_width = lang_text_draw_amount(8, 4, scenario.requests[player_message.param1].months_to_comply,
                                                    message_dialog_data.x_text + 200, y_offset, FONT_NORMAL_WHITE);
                                                lang_text_draw(12, 2, message_dialog_data.x_text + 200 + comply_time_width, y_offset, FONT_NORMAL_WHITE);
                                            }
                                        }
                                        break;
                                    }
                                }
                            } else {
                                // draw_text_old(msg->content.text,message_dialog_data.x_text + 8, message_dialog_data.y_text + 6, BLOCK_SIZE * (message_dialog_data.text_width_blocks - 1),message_dialog_data.text_height_blocks - 1, 0, 0);
                            }
                            graphics_reset_clip_rectangle();
                        }
                    }
                    refresh_current_window = 0;
                }
                if (message_dialog_data.show_video) {
                    draw_foreground_video();
                } else {
                    struct lang_message_t *msg = &lang_data.message_entries[message_dialog_data.text_id];
                    if (msg->type == TYPE_MESSAGE) {
                        switch (player_message.message_advisor) {
                            case MESSAGE_ADVISOR_LABOR:
                                draw_image_button(1150, map_center_x - 304, map_center_y - 184, 28, 28, 1);
                                break;
                            case MESSAGE_ADVISOR_TRADE:
                                draw_image_button(1162, map_center_x - 304, map_center_y - 184, 28, 28, 1);
                                break;
                            case MESSAGE_ADVISOR_POPULATION:
                                draw_image_button(1165, map_center_x - 304, map_center_y - 184, 28, 28, 1);
                                break;
                            case MESSAGE_ADVISOR_IMPERIAL:
                                draw_image_button(1156, map_center_x - 304, map_center_y - 184, 28, 28, 1);
                                break;
                            case MESSAGE_ADVISOR_MILITARY:
                                draw_image_button(1153, map_center_x - 304, map_center_y - 184, 28, 28, 1);
                                break;
                            case MESSAGE_ADVISOR_HEALTH:
                                draw_image_button(1168, map_center_x - 304, map_center_y - 184, 28, 28, 1);
                                break;
                            case MESSAGE_ADVISOR_RELIGION:
                                draw_image_button(1177, map_center_x - 304, map_center_y - 184, 28, 28, 1);
                                break;
                        }
                        if (msg->message_type == MESSAGE_TYPE_DISASTER || msg->message_type == MESSAGE_TYPE_INVASION) {
                            // image_buttons_draw(map_center_x - 320, map_center_y - 200, &image_button_go_to_problem, 1);
                        }
                    }
                    // scrollbar_draw(&scrollbar);
                }
                break;
            case WINDOW_CONTEXT_INFO:
                if (refresh_current_window) {
                    draw_foreground_city();
                    int width = 0;
                    if (selected_units_list[0]) {
                        int random = 0;
                        int least_god_happiness = 100;
                        for (int god = 0; god < MAX_GODS; god++) {
                            if (city_data.religion.gods[god].happiness < least_god_happiness) {
                                least_god_happiness = city_data.religion.gods[god].happiness;
                            }
                        }
                        switch (selected_units_list[selected_unit_index]->type) {
                            case FIGURE_IMMIGRANT:
                                draw_figure_list();
                                image_draw(8141, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Immigrant", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                random = rand() % 3;
                                if (!random) {
                                    text_draw_multiline("I'm new to this place. Do you know of somewhere to live?", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/immigrant_exact1.wav");
                                } else if (random == 1) {
                                    text_draw_multiline("I've heard there are jobs here. I want to be a lion tamer!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/immigrant_exact2.wav");
                                } else if (random == 2) {
                                    text_draw_multiline("They say there's food here. Is it a good place to live?", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/immigrant_exact3.wav");
                                }
                                break;
                            case FIGURE_EMIGRANT:
                                draw_figure_list();
                                image_draw(8141, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Emigrant", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (city_data.sentiment.low_mood_cause == LOW_MOOD_CAUSE_NO_JOBS) {
                                    text_draw_multiline("I've had enough of this place! There's no work here!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/emigrate_exact1.wav");
                                } else if (city_data.sentiment.low_mood_cause == LOW_MOOD_CAUSE_NO_FOOD) {
                                    text_draw_multiline("If I stay any longer I think I'll die. There's no food anywhere.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/emigrate_exact2.wav");
                                } else if (city_data.sentiment.low_mood_cause == LOW_MOOD_CAUSE_HIGH_TAXES) {
                                    text_draw_multiline("Have you seen the taxes here? Citizen, it's just not right!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/emigrate_exact3.wav");
                                } else if (city_data.sentiment.low_mood_cause == LOW_MOOD_CAUSE_LOW_WAGES) {
                                    text_draw_multiline("My dog wouldn't work for the wages they pay here! I'm leaving!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/emigrate_exact4.wav");
                                } else {
                                    text_draw_multiline("A day longer in that tent and I would have exploded.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/explo1.wav");
                                }
                                break;
                            case FIGURE_HOMELESS:
                                draw_figure_list();
                                image_draw(8137, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Homeless", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (current_time % 2) {
                                    text_draw_multiline("I've been thrown out of my home!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/homeless_exact1.wav");
                                } else {
                                    text_draw_multiline("I've got nowhere to live!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/homeless_exact2.wav");
                                }
                                break;
                            case FIGURE_PATRICIAN:
                                draw_figure_list();
                                image_draw(8186, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Patrician", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (!city_data.resource.food_supply_months) {
                                    text_draw_multiline("Hail! What use is it to be rich if there's no food to buy?", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/patric_starv1.wav");
                                } else if (city_data.labor.unemployment_percentage >= 17) {
                                    text_draw_multiline("This is disgraceful! I've never seen so many plebes out of work!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/patric_nojob1.wav");
                                } else if (city_data.labor.workers_needed >= 10) {
                                    text_draw_multiline("Services are suffering here! The city needs more workers!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/patric_needjob1.wav");
                                } else if (!city_data.culture.average_entertainment) {
                                    text_draw_multiline("Citizen! Is this not the dullest city in the empire!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/patric_nofun1.wav");
                                } else if (least_god_happiness < 20) {
                                    text_draw_multiline("Citizen! All is not well. The gods are angry.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/patric_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 10) {
                                    text_draw_multiline("Citizen! Is this not the dullest city in the empire!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/patric_nofun1.wav");
                                } else if (least_god_happiness < 40) {
                                    text_draw_multiline("Citizen! All is not well. The gods are angry.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/patric_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 20) {
                                    text_draw_multiline("Citizen! Is this not the dullest city in the empire!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/patric_nofun1.wav");
                                } else if (city_data.resource.food_supply_months >= 4
                                        && city_data.labor.unemployment_percentage <= 5
                                        && city_data.culture.average_health
                                        && city_data.culture.average_education) {
                                    if (city_data.population.population < 500) {
                                        text_draw_multiline("This city is quite well run.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/patric_great1.wav");
                                    } else {
                                        text_draw_multiline("From the comfort of my villa, I perceive life here to be very good.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/patric_great2.wav");
                                    }
                                } else if (city_data.labor.unemployment_percentage >= 10) {
                                    text_draw_multiline("This is disgraceful! I've never seen so many plebes out of work!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/patric_nojob1.wav");
                                } else {
                                    text_draw_multiline("This city is quite well run.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/patric_great1.wav");
                                }
                                break;
                            case FIGURE_CART_PUSHER:
                                draw_figure_list();
                                image_draw(8179, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Cart pusher", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                image_draw(resource_images[selected_units_list[selected_unit_index]->resource_id].icon_img_id + resource_image_offset(selected_units_list[selected_unit_index]->resource_id, RESOURCE_IMAGE_ICON), map_center_x - 70, map_center_y - 40);
                                if (selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_CARTPUSHER_INITIAL) {
                                    if (selected_units_list[selected_unit_index]->min_max_seen == 2) {
                                        text_draw_multiline("The destination for these goods won't accept them! They need more workers.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_exact1.wav");
                                    } else if (selected_units_list[selected_unit_index]->min_max_seen == 1) {
                                        text_draw_multiline("There's no room for this lot anywhere in the city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_exact2.wav");
                                    }
                                } else if ((selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_WAREHOUSE || selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_GRANARY || selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_CARTPUSHER_DELIVERING_TO_WORKSHOP)
                                && (calc_maximum_distance(selected_units_list[selected_unit_index]->destination_x, selected_units_list[selected_unit_index]->destination_y, selected_units_list[selected_unit_index]->source_x, selected_units_list[selected_unit_index]->source_y) >= 25)) {
                                    text_draw_multiline("It would be quicker to push these goods to Rome than to where I'm going!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/crtpsh_exact3.wav");
                                } else {
                                    if (!city_data.resource.food_supply_months) {
                                        text_draw_multiline("Pushing carts all day long takes energy; how's a cartpusher supposed to carry on without food?!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_starv1.wav");
                                    } else if (city_data.labor.unemployment_percentage >= 17) {
                                        text_draw_multiline("Unemployment is so high my wife's even stopped nagging me to get a better job!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_nojob1.wav");
                                    } else if (city_data.labor.workers_needed >= 10) {
                                        text_draw_multiline("Everywhere you look in this city there are job vacancies!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_needjob1.wav");
                                    } else if (!city_data.culture.average_entertainment) {
                                        text_draw_multiline("I don't mind pushing a cart; it's more entertaining than the rest of this city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_nofun1.wav");
                                    } else if (least_god_happiness < 20) {
                                        text_draw_multiline("I'm not a very religious citizen, but even I wouldn't treat the gods this badly!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_relig1.wav");
                                    } else if (city_data.culture.average_entertainment <= 10) {
                                        text_draw_multiline("I don't mind pushing a cart; it's more entertaining than the rest of this city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_nofun1.wav");
                                    } else if (least_god_happiness < 40) {
                                        text_draw_multiline("I'm not a very religious citizen, but even I wouldn't treat the gods this badly!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_relig1.wav");
                                    } else if (city_data.culture.average_entertainment <= 20) {
                                        text_draw_multiline("I don't mind pushing a cart; it's more entertaining than the rest of this city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_nofun1.wav");
                                    } else if (city_data.resource.food_supply_months >= 4
                                            && city_data.labor.unemployment_percentage <= 5
                                            && city_data.culture.average_health
                                            && city_data.culture.average_education) {
                                        if (city_data.population.population < 500) {
                                            text_draw_multiline("As cities go, this one seems OK.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/crtpsh_great1.wav");
                                        } else {
                                            text_draw_multiline("Pushing carts all day long is hardly fun, but living here makes it worthwhile.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/crtpsh_great2.wav");
                                        }
                                    } else if (city_data.labor.unemployment_percentage >= 10) {
                                        text_draw_multiline("Unemployment is so high my wife's even stopped nagging me to get a better job!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_nojob1.wav");
                                    } else {
                                        text_draw_multiline("As cities go, this one seems OK.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_great1.wav");
                                    }
                                }
                                // int is_returning = 0;
                                // switch (f->action_state) {
                                //     case FIGURE_ACTION_CARTPUSHER_RETURNING:
                                //     case FIGURE_ACTION_WAREHOUSEMAN_RETURNING_EMPTY:
                                //     case FIGURE_ACTION_WAREHOUSEMAN_RETURNING_WITH_FOOD:
                                //     case FIGURE_ACTION_WAREHOUSEMAN_RETURNING_WITH_RESOURCE:
                                //     case FIGURE_ACTION_DOCKER_EXPORT_QUEUE:
                                //     case FIGURE_ACTION_DOCKER_EXPORT_RETURNING:
                                //     case FIGURE_ACTION_DOCKER_IMPORT_RETURNING:
                                //         is_returning = 1;
                                //         break;
                                // }
                                // if (f->action_state != FIGURE_ACTION_DOCKER_IDLING) {
                                //     int x_base = c->x_offset + 40;
                                //     int y_base = c->y_offset + 216;
                                //     if (phrase_height > 60) {
                                //         y_base += 8;
                                //     }
                                //     struct building_t *source_building = &all_buildings[f->building_id];
                                //     struct building_t *target_building = &all_buildings[f->destination_building_id];
                                //     if (is_returning) {
                                //         width = lang_text_draw(129, 16, x_base, y_base, FONT_NORMAL_BROWN);
                                //         width += text_draw(all_buildings_strings[source_building->type], x_base + width, y_base, FONT_NORMAL_BROWN, COLOR_BLACK);
                                //         width += lang_text_draw(129, 14, x_base + width, y_base, FONT_NORMAL_BROWN);
                                //         text_draw(all_buildings_strings[target_building->type], x_base + width, y_base, FONT_NORMAL_BROWN, COLOR_BLACK);
                                //     } else {
                                //         width = lang_text_draw(129, 15, x_base, y_base, FONT_NORMAL_BROWN);
                                //         width += text_draw(all_buildings_strings[target_building->type], x_base + width, y_base, FONT_NORMAL_BROWN, COLOR_BLACK);
                                //         width += lang_text_draw(129, 14, x_base + width, y_base, FONT_NORMAL_BROWN);
                                //         text_draw(all_buildings_strings[source_building->type], x_base + width, y_base, FONT_NORMAL_BROWN, COLOR_BLACK);
                                //     }
                                // }
                                break;
                            case FIGURE_LABOR_SEEKER:
                                draw_figure_list();
                                image_draw(8141, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Citizen", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (!city_data.resource.food_supply_months) {
                                    text_draw_multiline("Could you spare a little bread? I haven't eaten for so long.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/pleb_starv1.wav");
                                } else if (city_data.labor.unemployment_percentage >= 17) {
                                    text_draw_multiline("Have you seen how high unemployment is here?", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/pleb_nojob1.wav");
                                } else if (city_data.labor.workers_needed >= 10) {
                                    text_draw_multiline("Citizen! This place needs more workers!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/pleb_needjob1.wav");
                                } else if (!city_data.culture.average_entertainment) {
                                    text_draw_multiline("I work hard, I like to play hard. But I can't here, there's not enough to do", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/pleb_nofun1.wav");
                                } else if (least_god_happiness < 20) {
                                    text_draw_multiline("We're in trouble! The gods are annoyed with us!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/pleb_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 10) {
                                    text_draw_multiline("I work hard, I like to play hard. But I can't here, there's not enough to do", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/pleb_nofun1.wav");
                                } else if (least_god_happiness < 40) {
                                    text_draw_multiline("We're in trouble! The gods are annoyed with us!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/pleb_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 20) {
                                    text_draw_multiline("I work hard, I like to play hard. But I can't here, there's not enough to do", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/pleb_nofun1.wav");
                                } else if (city_data.resource.food_supply_months >= 4
                                        && city_data.labor.unemployment_percentage <= 5
                                        && city_data.culture.average_health
                                        && city_data.culture.average_education) {
                                    if (city_data.population.population < 500) {
                                        text_draw_multiline("Greetings! This is an OK city, really.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/pleb_great1.wav");
                                    } else {
                                        text_draw_multiline("Hail! Life here's is great.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/pleb_great2.wav");
                                    }
                                } else if (city_data.labor.unemployment_percentage >= 10) {
                                    text_draw_multiline("Have you seen how high unemployment is here?", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/pleb_nojob1.wav");
                                } else {
                                    text_draw_multiline("Greetings! This is an OK city, really.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/pleb_great1.wav");
                                }
                                break;
                            case FIGURE_BARBER:
                                draw_figure_list();
                                image_draw(8130, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Barber", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (!city_data.resource.food_supply_months) {
                                    text_draw_multiline("A hair cut takes your mind off hunger. And there's lots of hunger here.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/barber_starv1.wav");
                                } else if (city_data.labor.unemployment_percentage >= 17) {
                                    text_draw_multiline("There's enough unemployment here to make your hair stand on end!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/barber_nojob1.wav");
                                } else if (city_data.labor.workers_needed >= 10) {
                                    text_draw_multiline("There's a real shortage of workers here", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/barber_needjob1.wav");
                                } else if (!city_data.culture.average_entertainment) {
                                    text_draw_multiline("After a day cutting hair, all I want is a lion fight. No chance of that here!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/barber_nofun1.wav");
                                } else if (least_god_happiness < 20) {
                                    text_draw_multiline("The gods are angry. I wish the governor would build more temples!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/barber_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 10) {
                                    text_draw_multiline("After a day cutting hair, all I want is a lion fight. No chance of that here!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/barber_nofun1.wav");
                                } else if (least_god_happiness < 40) {
                                    text_draw_multiline("The gods are angry. I wish the governor would build more temples!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/barber_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 20) {
                                    text_draw_multiline("After a day cutting hair, all I want is a lion fight. No chance of that here!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/barber_nofun1.wav");
                                } else if (city_data.resource.food_supply_months >= 4
                                        && city_data.labor.unemployment_percentage <= 5
                                        && city_data.culture.average_health
                                        && city_data.culture.average_education) {
                                    if (city_data.population.population < 500) {
                                        text_draw_multiline("Will that be a shave or a trim. Citizen?  Life here's all right, isn't it?", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/barber_great1.wav");
                                    } else {
                                        text_draw_multiline("Isn't this city hair-trimmingly lovely?", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/barber_great2.wav");
                                    }
                                } else if (city_data.labor.unemployment_percentage >= 10) {
                                    text_draw_multiline("There's enough unemployment here to make your hair stand on end!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/barber_nojob1.wav");
                                } else {
                                    text_draw_multiline("Will that be a shave or a trim. Citizen?  Life here's all right, isn't it?", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/barber_great1.wav");
                                }
                                break;
                            case FIGURE_BATHHOUSE_WORKER:
                                draw_figure_list();
                                image_draw(8131, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Baths worker", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (!city_data.resource.food_supply_months) {
                                    text_draw_multiline("People haven't eaten for so long their ribs are showing at the bath house!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/bather_starv1.wav");
                                } else if (city_data.labor.unemployment_percentage >= 17) {
                                    text_draw_multiline("Unemployment is so high it's making the whole city unhappy", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/bather_nojob1.wav");
                                } else if (city_data.labor.workers_needed >= 10) {
                                    text_draw_multiline("This city is terribly short of workers", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/bather_needjob1.wav");
                                } else if (!city_data.culture.average_entertainment) {
                                    text_draw_multiline("You can't get a good night out in this place!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/bather_nofun1.wav");
                                } else if (least_god_happiness < 20) {
                                    text_draw_multiline("This governor has no respect for the gods", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/bather_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 10) {
                                    text_draw_multiline("You can't get a good night out in this place!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/bather_nofun1.wav");
                                } else if (least_god_happiness < 40) {
                                    text_draw_multiline("This governor has no respect for the gods", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/bather_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 20) {
                                    text_draw_multiline("You can't get a good night out in this place!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/bather_nofun1.wav");
                                } else if (city_data.resource.food_supply_months >= 4
                                        && city_data.labor.unemployment_percentage <= 5
                                        && city_data.culture.average_health
                                        && city_data.culture.average_education) {
                                    if (city_data.population.population < 500) {
                                        text_draw_multiline("Things seem to be working well here", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/bather_great1.wav");
                                    } else {
                                        text_draw_multiline("This is a good city; people like living here", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/bather_great2.wav");
                                    }
                                } else if (city_data.labor.unemployment_percentage >= 10) {
                                    text_draw_multiline("Unemployment is so high it's making the whole city unhappy", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/bather_nojob1.wav");
                                } else {
                                    text_draw_multiline("Things seem to be working well here", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/bather_great1.wav");
                                }
                                break;
                            case FIGURE_DOCTOR:
                            case FIGURE_SURGEON:
                                draw_figure_list();
                                image_draw(8134, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Doctor", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (!city_data.resource.food_supply_months) {
                                    text_draw_multiline("There's malnutrition everywhere, yet no food to treat it!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/doctor_starv1.wav");
                                } else if (city_data.labor.unemployment_percentage >= 17) {
                                    text_draw_multiline("Unemployment is very high here; I'm thinking of leaving", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/doctor_nojob1.wav");
                                } else if (city_data.labor.workers_needed >= 10) {
                                    text_draw_multiline("There's a real shortage of workers here", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/doctor_needjob1.wav");
                                } else if (!city_data.culture.average_entertainment) {
                                    text_draw_multiline("This city is so dull I've had patients ask me to cure chronic boredom!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/doctor_nofun1.wav");
                                } else if (least_god_happiness < 20) {
                                    text_draw_multiline("If we don't pay the gods more respect, we'll feel their wrath!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/doctor_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 10) {
                                    text_draw_multiline("This city is so dull I've had patients ask me to cure chronic boredom!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/doctor_nofun1.wav");
                                } else if (least_god_happiness < 40) {
                                    text_draw_multiline("If we don't pay the gods more respect, we'll feel their wrath!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/doctor_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 20) {
                                    text_draw_multiline("This city is so dull I've had patients ask me to cure chronic boredom!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/doctor_nofun1.wav");
                                } else if (city_data.resource.food_supply_months >= 4
                                        && city_data.labor.unemployment_percentage <= 5
                                        && city_data.culture.average_health
                                        && city_data.culture.average_education) {
                                    if (city_data.population.population < 500) {
                                        text_draw_multiline("The city seems to be in good health", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/doctor_great1.wav");
                                    } else {
                                        text_draw_multiline("This is a wonderful city", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/doctor_great2.wav");
                                    }
                                } else if (city_data.labor.unemployment_percentage >= 10) {
                                    text_draw_multiline("Unemployment is very high here; I'm thinking of leaving", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/doctor_nojob1.wav");
                                } else {
                                    text_draw_multiline("The city seems to be in good health", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/doctor_great1.wav");
                                }
                                break;
                            case FIGURE_PRIEST:
                                draw_figure_list();
                                image_draw(8142, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Priest", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (!city_data.resource.food_supply_months) {
                                    text_draw_multiline("Greetings! This city urgently needs more food.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/priest_starv1.wav");
                                } else if (city_data.labor.unemployment_percentage >= 17) {
                                    text_draw_multiline("Unemployment is worryingly high here", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/priest_nojob1.wav");
                                } else if (city_data.labor.workers_needed >= 10) {
                                    text_draw_multiline("This place really needs many more workers", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/priest_needjob1.wav");
                                } else if (!city_data.culture.average_entertainment) {
                                    text_draw_multiline("This city is so dull. Even priests like a gladiator fight from time to time!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/priest_nofun1.wav");
                                } else if (least_god_happiness < 20) {
                                    text_draw_multiline("We're in danger ! This city has no respect for the gods!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/priest_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 10) {
                                    text_draw_multiline("This city is so dull. Even priests like a gladiator fight from time to time!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/priest_nofun1.wav");
                                } else if (least_god_happiness < 40) {
                                    text_draw_multiline("We're in danger ! This city has no respect for the gods!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/priest_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 20) {
                                    text_draw_multiline("This city is so dull. Even priests like a gladiator fight from time to time!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/priest_nofun1.wav");
                                } else if (city_data.resource.food_supply_months >= 4
                                        && city_data.labor.unemployment_percentage <= 5
                                        && city_data.culture.average_health
                                        && city_data.culture.average_education) {
                                    if (city_data.population.population < 500) {
                                        text_draw_multiline("This city is a reasonable place", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/priest_great1.wav");
                                    } else {
                                        text_draw_multiline("Life's very good in this city.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/priest_great2.wav");
                                    }
                                } else if (city_data.labor.unemployment_percentage >= 10) {
                                    text_draw_multiline("Unemployment is worryingly high here", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/priest_nojob1.wav");
                                } else {
                                    text_draw_multiline("This city is a reasonable place", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/priest_great1.wav");
                                }
                                break;
                            case FIGURE_SCHOOL_CHILD:
                                draw_figure_list();
                                image_draw(8133, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Schoolchild", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (!city_data.resource.food_supply_months) {
                                    text_draw_multiline("I'm starving!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/pupils_starv1.wav");
                                } else if (city_data.labor.unemployment_percentage >= 17) {
                                    text_draw_multiline("There are ever so many people looking for work here", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/pupils_nojob1.wav");
                                } else if (city_data.labor.workers_needed >= 10) {
                                    text_draw_multiline("There are so few workers here that someone even offered me a job!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/pupils_needjob1.wav");
                                } else if (!city_data.culture.average_entertainment) {
                                    text_draw_multiline("This city is so boring! I want to see more shows!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/pupils_nofun1.wav");
                                } else if (least_god_happiness < 20) {
                                    text_draw_multiline("Help! The gods are so angry we'll all be struck down!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/pupils_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 10) {
                                    text_draw_multiline("This city is so boring! I want to see more shows!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/pupils_nofun1.wav");
                                } else if (least_god_happiness < 40) {
                                    text_draw_multiline("Help! The gods are so angry we'll all be struck down!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/pupils_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 20) {
                                    text_draw_multiline("This city is so boring! I want to see more shows!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/pupils_nofun1.wav");
                                } else if (city_data.resource.food_supply_months >= 4
                                        && city_data.labor.unemployment_percentage <= 5
                                        && city_data.culture.average_health
                                        && city_data.culture.average_education) {
                                    if (city_data.population.population < 500) {
                                        text_draw_multiline("This city seems all right", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/pupils_great1.wav");
                                    } else {
                                        text_draw_multiline("This city is fantastic!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/pupils_great2.wav");
                                    }
                                } else if (city_data.labor.unemployment_percentage >= 10) {
                                    text_draw_multiline("There are ever so many people looking for work here", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/pupils_nojob1.wav");
                                } else {
                                    text_draw_multiline("This city seems all right", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/pupils_great1.wav");
                                }
                                break;
                            case FIGURE_TEACHER:
                                draw_figure_list();
                                image_draw(8180, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Teacher", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (!city_data.resource.food_supply_months) {
                                    text_draw_multiline("There's not enough food here. It's making citizens unhappy", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/teach_starv1.wav");
                                } else if (city_data.labor.unemployment_percentage >= 17) {
                                    text_draw_multiline("I hope I don't lose my job; unemployment is so high I won't get another!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/teach_nojob1.wav");
                                } else if (city_data.labor.workers_needed >= 10) {
                                    text_draw_multiline("I'm amazed by how many jobs not filled there are here", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/teach_needjob1.wav");
                                } else if (!city_data.culture.average_entertainment) {
                                    text_draw_multiline("My lessons are more entertaining than this city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/teach_nofun1.wav");
                                } else if (least_god_happiness < 20) {
                                    text_draw_multiline("We will feel the wrath of the gods unless we build more temples soon!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/teach_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 10) {
                                    text_draw_multiline("My lessons are more entertaining than this city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/teach_nofun1.wav");
                                } else if (least_god_happiness < 40) {
                                    text_draw_multiline("We will feel the wrath of the gods unless we build more temples soon!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/teach_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 20) {
                                    text_draw_multiline("My lessons are more entertaining than this city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/teach_nofun1.wav");
                                } else if (city_data.resource.food_supply_months >= 4
                                        && city_data.labor.unemployment_percentage <= 5
                                        && city_data.culture.average_health
                                        && city_data.culture.average_education) {
                                    if (city_data.population.population < 500) {
                                        text_draw_multiline("I'd give this city 8 out of 10", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/teach_great1.wav");
                                    } else {
                                        text_draw_multiline("This city gets full marks; it's a wonderful place!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/teach_great2.wav");
                                    }
                                } else if (city_data.labor.unemployment_percentage >= 10) {
                                    text_draw_multiline("I hope I don't lose my job; unemployment is so high I won't get another!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/teach_nojob1.wav");
                                } else {
                                    text_draw_multiline("I'd give this city 8 out of 10", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/teach_great1.wav");
                                }
                                break;
                            case FIGURE_LIBRARIAN:
                                draw_figure_list();
                                image_draw(8180, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Librarian", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (!city_data.resource.food_supply_months) {
                                    text_draw_multiline("There's not enough food here. It's making citizens unhappy", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/teach_starv1.wav");
                                } else if (city_data.labor.unemployment_percentage >= 17) {
                                    text_draw_multiline("I hope I don't lose my job; unemployment is so high I won't get another!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/teach_nojob1.wav");
                                } else if (city_data.labor.workers_needed >= 10) {
                                    text_draw_multiline("I'm amazed by how many jobs not filled there are here", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/teach_needjob1.wav");
                                } else if (!city_data.culture.average_entertainment) {
                                    text_draw_multiline("My lessons are more entertaining than this city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/teach_nofun1.wav");
                                } else if (least_god_happiness < 20) {
                                    text_draw_multiline("We will feel the wrath of the gods unless we build more temples soon!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/teach_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 10) {
                                    text_draw_multiline("My lessons are more entertaining than this city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/teach_nofun1.wav");
                                } else if (least_god_happiness < 40) {
                                    text_draw_multiline("We will feel the wrath of the gods unless we build more temples soon!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/teach_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 20) {
                                    text_draw_multiline("My lessons are more entertaining than this city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/teach_nofun1.wav");
                                } else if (city_data.resource.food_supply_months >= 4
                                        && city_data.labor.unemployment_percentage <= 5
                                        && city_data.culture.average_health
                                        && city_data.culture.average_education) {
                                    if (city_data.population.population < 500) {
                                        text_draw_multiline("I'd give this city 8 out of 10", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/teach_great1.wav");
                                    } else {
                                        text_draw_multiline("This city gets full marks; it's a wonderful place!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/teach_great2.wav");
                                    }
                                } else if (city_data.labor.unemployment_percentage >= 10) {
                                    text_draw_multiline("I hope I don't lose my job; unemployment is so high I won't get another!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/teach_nojob1.wav");
                                } else {
                                    text_draw_multiline("I'd give this city 8 out of 10", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/teach_great1.wav");
                                }
                                break;
                            case FIGURE_MISSIONARY:
                                draw_figure_list();
                                image_draw(8181, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Missionary", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (city_data.military.native_attack_duration) {
                                    text_draw_multiline("I'll do what I can to calm these barbarians down. I'm sure they'll stop attacking the city when I've had a word with them!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/mission_exact4.wav");
                                } else {
                                    random_generate_next();
                                    random = rand() % 3;
                                    if (!random) {
                                        text_draw_multiline("Hail! I can see there's lots to be done teaching barbarians Rome's benevolence!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/missionary_exact1.wav");
                                    } else if (random == 1) {
                                        text_draw_multiline("My teaching Rome's benefits seems to be sinking in to these barbarians!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/missionary_exact2.wav");
                                    } else if (random == 2) {
                                        text_draw_multiline("I'm so glad to be Roman.  You should see what these barbarians get up to in their huts", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/missionary_exact3.wav");
                                    }
                                }
                                break;
                            case FIGURE_ACTOR:
                                draw_figure_list();
                                image_draw(8180, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Actor", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (!city_data.resource.food_supply_months) {
                                    text_draw_multiline("I simply can't perform well without more food", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/actor_starv1.wav");
                                } else if (city_data.labor.unemployment_percentage >= 17) {
                                    text_draw_multiline("There's so much unemployment it's distracted me from learning my lines", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/actor_nojob1.wav");
                                } else if (city_data.labor.workers_needed >= 10) {
                                    text_draw_multiline("There are simply not enough workers in this city", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/actor_needjob1.wav");
                                } else if (!city_data.culture.average_entertainment) {
                                    text_draw_multiline("I work as hard as I can, but there's still not enough entertainment here", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/actor_nofun1.wav");
                                } else if (least_god_happiness < 20) {
                                    text_draw_multiline("Aaagh!! The gods are angry! We're all doomed!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/actor_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 10) {
                                    text_draw_multiline("I work as hard as I can, but there's still not enough entertainment here", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/actor_nofun1.wav");
                                } else if (least_god_happiness < 40) {
                                    text_draw_multiline("Aaagh!! The gods are angry! We're all doomed!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/actor_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 20) {
                                    text_draw_multiline("I work as hard as I can, but there's still not enough entertainment here", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/actor_nofun1.wav");
                                } else if (city_data.resource.food_supply_months >= 4
                                        && city_data.labor.unemployment_percentage <= 5
                                        && city_data.culture.average_health
                                        && city_data.culture.average_education) {
                                    if (city_data.population.population < 500) {
                                        text_draw_multiline("This city isn't too bad", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/actor_great1.wav");
                                    } else {
                                        text_draw_multiline("Life here is simply adorable", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/actor_great2.wav");
                                    }
                                } else if (city_data.labor.unemployment_percentage >= 10) {
                                    text_draw_multiline("There's so much unemployment it's distracted me from learning my lines", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/actor_nojob1.wav");
                                } else {
                                    text_draw_multiline("This city isn't too bad", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/actor_great1.wav");
                                }
                                break;
                            case FIGURE_GLADIATOR:
                                draw_figure_list();
                                image_draw(8180, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Gladiator", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (selected_units_list[selected_unit_index]->engaged_in_combat) {
                                    text_draw_multiline("I'll teach you to come near my city! I eat people like you for breakfast!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/gladtr_starv1.wav");
                                } else {
                                    if (!city_data.resource.food_supply_months) {
                                        text_draw_multiline("I'm so hungry I could eat a lion!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/gladtr_starv1.wav");
                                    } else if (city_data.labor.unemployment_percentage >= 17) {
                                        text_draw_multiline("There's so much unemployment here. I wish we could practice on some of them!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/gladtr_nojob1.wav");
                                    } else if (city_data.labor.workers_needed >= 10) {
                                        text_draw_multiline("It's terrible. I've never seen so many job vacancies not filled.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/gladtr_needjob1.wav");
                                    } else if (!city_data.culture.average_entertainment) {
                                        text_draw_multiline("Boring! That's what they say about this place!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/gladtr_nofun1.wav");
                                    } else if (least_god_happiness < 20) {
                                        text_draw_multiline("Hail, citizen. Have you heard? The gods are angry.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/gladtr_relig1.wav");
                                    } else if (city_data.culture.average_entertainment <= 10) {
                                        text_draw_multiline("Boring! That's what they say about this place!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/gladtr_nofun1.wav");
                                    } else if (least_god_happiness < 40) {
                                        text_draw_multiline("Hail, citizen. Have you heard? The gods are angry.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/gladtr_relig1.wav");
                                    } else if (city_data.culture.average_entertainment <= 20) {
                                        text_draw_multiline("Boring! That's what they say about this place!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/gladtr_nofun1.wav");
                                    } else if (city_data.resource.food_supply_months >= 4
                                            && city_data.labor.unemployment_percentage <= 5
                                            && city_data.culture.average_health
                                            && city_data.culture.average_education) {
                                        if (city_data.population.population < 500) {
                                            text_draw_multiline("Salutations! Life here is all right, isn't it?", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/gladtr_great1.wav");
                                        } else {
                                            text_draw_multiline("Citizen! I've fought in many cities in my day, and this one is one of the best.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/gladtr_great2.wav");
                                        }
                                    } else if (city_data.labor.unemployment_percentage >= 10) {
                                        text_draw_multiline("There's so much unemployment here. I wish we could practice on some of them!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/gladtr_nojob1.wav");
                                    } else {
                                        text_draw_multiline("Salutations! Life here is all right, isn't it?", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/gladtr_great1.wav");
                                    }
                                }
                                break;
                            case FIGURE_LION_TAMER:
                                draw_figure_list();
                                image_draw(8138, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Lion tamer", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (selected_units_list[selected_unit_index]->engaged_in_combat) {
                                    random = rand() % 3;
                                    if (!random) {
                                        text_draw_multiline("Now's your chance, Leo. That's a good lion!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/liontr_exact1.wav");
                                    } else if (random == 1) {
                                        text_draw_multiline("Here's some foreign meat for you Leo!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/liontr_exact2.wav");
                                    } else if (random == 2) {
                                        text_draw_multiline("If you touch my lion, you'll feel the tip of my whip!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/liontr_exact3.wav");
                                    }
                                } else {
                                    if (!city_data.resource.food_supply_months) {
                                        text_draw_multiline("If food doesn't arrive soon, this lion'll eat his own tamer! Me!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/liontr_starv1.wav");
                                    } else if (city_data.labor.unemployment_percentage >= 17) {
                                        text_draw_multiline("There's a lot of unemployment here", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/liontr_nojob1.wav");
                                    } else if (city_data.labor.workers_needed >= 10) {
                                        text_draw_multiline("This city needs workers. I wonder if I could train Leo to do more work?", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/liontr_needjob1.wav");
                                    } else if (!city_data.culture.average_entertainment) {
                                        text_draw_multiline("I fight all day, and still people are bored! There aren't enough entertainers!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/liontr_nofun1.wav");
                                    } else if (least_god_happiness < 20) {
                                        text_draw_multiline("The gods are so angry it's affected my lion! He's roaring mad!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/liontr_relig1.wav");
                                    } else if (city_data.culture.average_entertainment <= 10) {
                                        text_draw_multiline("I fight all day, and still people are bored! There aren't enough entertainers!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/liontr_nofun1.wav");
                                    } else if (least_god_happiness < 40) {
                                        text_draw_multiline("The gods are so angry it's affected my lion! He's roaring mad!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/liontr_relig1.wav");
                                    } else if (city_data.culture.average_entertainment <= 20) {
                                        text_draw_multiline("I fight all day, and still people are bored! There aren't enough entertainers!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/liontr_nofun1.wav");
                                    } else if (city_data.resource.food_supply_months >= 4
                                            && city_data.labor.unemployment_percentage <= 5
                                            && city_data.culture.average_health
                                            && city_data.culture.average_education) {
                                        if (city_data.population.population < 500) {
                                            text_draw_multiline("Hail, citizen! This city? I quite like it, really.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/liontr_great1.wav");
                                        } else {
                                            text_draw_multiline("Salutations! Isn't this a marvelous city?", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/liontr_great2.wav");
                                        }
                                    } else if (city_data.labor.unemployment_percentage >= 10) {
                                        text_draw_multiline("There's a lot of unemployment here", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/liontr_nojob1.wav");
                                    } else {
                                        text_draw_multiline("Hail, citizen! This city? I quite like it, really.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/liontr_great1.wav");
                                    }
                                }
                                break;
                            case FIGURE_CHARIOTEER:
                                draw_figure_list();
                                image_draw(8139, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Charioteer", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (!city_data.resource.food_supply_months) {
                                    text_draw_multiline("Hungry? I could eat a horse, there's so little food here!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/charot_starv1.wav");
                                } else if (city_data.labor.unemployment_percentage >= 17) {
                                    text_draw_multiline("I've never been past so many unemployed citizens before!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/charot_nojob1.wav");
                                } else if (city_data.labor.workers_needed >= 10) {
                                    text_draw_multiline("This city needs a lot more workers!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/charot_needjob1.wav");
                                } else if (!city_data.culture.average_entertainment) {
                                    text_draw_multiline("Citizens here are bored! Even with chariot racing, there's not enough fun here!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/charot_nofun1.wav");
                                } else if (least_god_happiness < 20) {
                                    text_draw_multiline("This is a heathen city! It needs more temples!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/charot_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 10) {
                                    text_draw_multiline("Citizens here are bored! Even with chariot racing, there's not enough fun here!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/charot_nofun1.wav");
                                } else if (least_god_happiness < 40) {
                                    text_draw_multiline("This is a heathen city! It needs more temples!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/charot_relig1.wav");
                                } else if (city_data.culture.average_entertainment <= 20) {
                                    text_draw_multiline("Citizens here are bored! Even with chariot racing, there's not enough fun here!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/charot_nofun1.wav");
                                } else if (city_data.resource.food_supply_months >= 4
                                        && city_data.labor.unemployment_percentage <= 5
                                        && city_data.culture.average_health
                                        && city_data.culture.average_education) {
                                    if (city_data.population.population < 500) {
                                        text_draw_multiline("I've raced in many worse cities than this", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/charot_great1.wav");
                                    } else {
                                        text_draw_multiline("This is a magnificent city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/charot_great2.wav");
                                    }
                                } else if (city_data.labor.unemployment_percentage >= 10) {
                                    text_draw_multiline("I've never been past so many unemployed citizens before!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/charot_nojob1.wav");
                                } else {
                                    text_draw_multiline("I've raced in many worse cities than this", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/charot_great1.wav");
                                }
                                break;
                            case FIGURE_TAX_COLLECTOR:
                                draw_figure_list();
                                image_draw(8144, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Tax collector", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (selected_units_list[selected_unit_index]->min_max_seen >= HOUSE_LARGE_CASA) {
                                    text_draw_multiline("I love collecting tax from rich houses like these!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/taxman_exact1.wav");
                                } else if (selected_units_list[selected_unit_index]->min_max_seen >= HOUSE_SMALL_HOVEL) {
                                    text_draw_multiline("Collecting taxes from these people almost brings a tear to my eye; but not quite!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/taxman_exact2.wav");
                                } else if (selected_units_list[selected_unit_index]->min_max_seen >= HOUSE_LARGE_TENT) {
                                    text_draw_multiline("These houses pay so little tax it hardly seems worth my time!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/taxman_exact3.wav");
                                } else {
                                    if (!city_data.resource.food_supply_months) {
                                        text_draw_multiline("If more food doesn't arrive soon there won't be anyone left to pay any tax!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/taxman_starv1.wav");
                                    } else if (city_data.labor.unemployment_percentage >= 17) {
                                        text_draw_multiline("I don't like it here. Unemployment is too high", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/taxman_nojob1.wav");
                                    } else if (city_data.labor.workers_needed >= 10) {
                                        text_draw_multiline("This place badly needs more workers", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/taxman_needjob1.wav");
                                    } else if (!city_data.culture.average_entertainment) {
                                        text_draw_multiline("I wouldn't mind squeezing people for denarii all day if there was more night life!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/taxman_nofun1.wav");
                                    } else if (least_god_happiness < 20) {
                                        text_draw_multiline("If we don't build more temples soon, the gods will curse this place!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/taxman_relig1.wav");
                                    } else if (city_data.culture.average_entertainment <= 10) {
                                        text_draw_multiline("I wouldn't mind squeezing people for denarii all day if there was more night life!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/taxman_nofun1.wav");
                                    } else if (least_god_happiness < 40) {
                                        text_draw_multiline("If we don't build more temples soon, the gods will curse this place!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/taxman_relig1.wav");
                                    } else if (city_data.culture.average_entertainment <= 20) {
                                        text_draw_multiline("I wouldn't mind squeezing people for denarii all day if there was more night life!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/taxman_nofun1.wav");
                                    } else if (city_data.resource.food_supply_months >= 4
                                            && city_data.labor.unemployment_percentage <= 5
                                            && city_data.culture.average_health
                                            && city_data.culture.average_education) {
                                        if (city_data.population.population < 500) {
                                            text_draw_multiline("This city seems to be running smoothly", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/taxman_great1.wav");
                                        } else {
                                            text_draw_multiline("Salutations! This is a most enjoyable city to live in.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/taxman_great2.wav");
                                        }
                                    } else if (city_data.labor.unemployment_percentage >= 10) {
                                        text_draw_multiline("I don't like it here. Unemployment is too high", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/taxman_nojob1.wav");
                                    } else {
                                        text_draw_multiline("This city seems to be running smoothly", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/taxman_great1.wav");
                                    }
                                }
                                break;
                            case FIGURE_ENGINEER:
                                draw_figure_list();
                                image_draw(8135, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Engineer", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (selected_units_list[selected_unit_index]->min_max_seen >= 60) {
                                    text_draw_multiline("These structures were in poor condition; I came along just in time", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/engine_exact1.wav");
                                } else if (selected_units_list[selected_unit_index]->min_max_seen >= 10) {
                                    text_draw_multiline("I'm hardly needed; these buildings are in great condition.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/engine_exact2.wav");
                                } else {
                                    if (!city_data.resource.food_supply_months) {
                                        text_draw_multiline("If I don't get some food soon, I'm leaving this city", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/engine_starv1.wav");
                                    } else if (city_data.labor.unemployment_percentage >= 17) {
                                        text_draw_multiline("I'm lucky to have a job, with unemployment this high", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/engine_nojob1.wav");
                                    } else if (city_data.labor.workers_needed >= 10) {
                                        text_draw_multiline("This city would be a lot better if there were enough workers!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/engine_needjob1.wav");
                                    } else if (!city_data.culture.average_entertainment) {
                                        text_draw_multiline("After a hard day's work I want to see a good show! No chance of that here!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/engine_nofun1.wav");
                                    } else if (least_god_happiness < 20) {
                                        text_draw_multiline("May the gods take pity on me! It's not my fault the governor mocks them!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/engine_relig1.wav");
                                    } else if (city_data.culture.average_entertainment <= 10) {
                                        text_draw_multiline("After a hard day's work I want to see a good show! No chance of that here!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/engine_nofun1.wav");
                                    } else if (least_god_happiness < 40) {
                                        text_draw_multiline("May the gods take pity on me! It's not my fault the governor mocks them!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/engine_relig1.wav");
                                    } else if (city_data.culture.average_entertainment <= 20) {
                                        text_draw_multiline("After a hard day's work I want to see a good show! No chance of that here!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/engine_nofun1.wav");
                                    } else if (city_data.resource.food_supply_months >= 4
                                            && city_data.labor.unemployment_percentage <= 5
                                            && city_data.culture.average_health
                                            && city_data.culture.average_education) {
                                        if (city_data.population.population < 500) {
                                            text_draw_multiline("Everything seems to be working well here", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/engine_great1.wav");
                                        } else {
                                            text_draw_multiline("Hail! Isn't this a great city?", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/engine_great2.wav");
                                        }
                                    } else if (city_data.labor.unemployment_percentage >= 10) {
                                        text_draw_multiline("I'm lucky to have a job, with unemployment this high", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/engine_nojob1.wav");
                                    } else {
                                        text_draw_multiline("Everything seems to be working well here", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/engine_great1.wav");
                                    }
                                }
                                break;
                            case FIGURE_FISHING_BOAT:
                                draw_figure_list();
                                image_draw(8188, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Fishing boat", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_SHIPWRECK:
                                draw_figure_list();
                                image_draw(8190, map_center_x - 200, map_center_y - 34);
                                text_draw("Shipwreck", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_DOCKER:
                                draw_figure_list();
                                image_draw(8179, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Docker", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                image_draw(resource_images[selected_units_list[selected_unit_index]->resource_id].icon_img_id + resource_image_offset(selected_units_list[selected_unit_index]->resource_id, RESOURCE_IMAGE_ICON), map_center_x - 70, map_center_y - 40);
                                if (selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_CARTPUSHER_INITIAL) {
                                    if (selected_units_list[selected_unit_index]->min_max_seen == 2) {
                                        text_draw_multiline("The destination for these goods won't accept them! They need more workers.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_exact1.wav");
                                    } else if (selected_units_list[selected_unit_index]->min_max_seen == 1) {
                                        text_draw_multiline("There's no room for this lot anywhere in the city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_exact2.wav");
                                    }
                                } else if ((selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_DOCKER_IMPORT_GOING_TO_WAREHOUSE || selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_DOCKER_EXPORT_GOING_TO_WAREHOUSE)
                                && (calc_maximum_distance(selected_units_list[selected_unit_index]->destination_x, selected_units_list[selected_unit_index]->destination_y, selected_units_list[selected_unit_index]->source_x, selected_units_list[selected_unit_index]->source_y) >= 25)) {
                                    text_draw_multiline("It would be quicker to push these goods to Rome than to where I'm going!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/crtpsh_exact3.wav");
                                } else {
                                    if (!city_data.resource.food_supply_months) {
                                        text_draw_multiline("Pushing carts all day long takes energy; how's a cartpusher supposed to carry on without food?!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_starv1.wav");
                                    } else if (city_data.labor.unemployment_percentage >= 17) {
                                        text_draw_multiline("Unemployment is so high my wife's even stopped nagging me to get a better job!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_nojob1.wav");
                                    } else if (city_data.labor.workers_needed >= 10) {
                                        text_draw_multiline("Everywhere you look in this city there are job vacancies!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_needjob1.wav");
                                    } else if (!city_data.culture.average_entertainment) {
                                        text_draw_multiline("I don't mind pushing a cart; it's more entertaining than the rest of this city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_nofun1.wav");
                                    } else if (least_god_happiness < 20) {
                                        text_draw_multiline("I'm not a very religious citizen, but even I wouldn't treat the gods this badly!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_relig1.wav");
                                    } else if (city_data.culture.average_entertainment <= 10) {
                                        text_draw_multiline("I don't mind pushing a cart; it's more entertaining than the rest of this city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_nofun1.wav");
                                    } else if (least_god_happiness < 40) {
                                        text_draw_multiline("I'm not a very religious citizen, but even I wouldn't treat the gods this badly!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_relig1.wav");
                                    } else if (city_data.culture.average_entertainment <= 20) {
                                        text_draw_multiline("I don't mind pushing a cart; it's more entertaining than the rest of this city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_nofun1.wav");
                                    } else if (city_data.resource.food_supply_months >= 4
                                            && city_data.labor.unemployment_percentage <= 5
                                            && city_data.culture.average_health
                                            && city_data.culture.average_education) {
                                        if (city_data.population.population < 500) {
                                            text_draw_multiline("As cities go, this one seems OK.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/crtpsh_great1.wav");
                                        } else {
                                            text_draw_multiline("Pushing carts all day long is hardly fun, but living here makes it worthwhile.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/crtpsh_great2.wav");
                                        }
                                    } else if (city_data.labor.unemployment_percentage >= 10) {
                                        text_draw_multiline("Unemployment is so high my wife's even stopped nagging me to get a better job!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_nojob1.wav");
                                    } else {
                                        text_draw_multiline("As cities go, this one seems OK.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_great1.wav");
                                    }
                                }
                                break;
                            case FIGURE_TOWER_SENTRY:
                                draw_figure_list();
                                image_draw(8178, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Sentry", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (city_figures_total_invading_enemies() > 80) {
                                    text_draw_multiline("We'll do our best, but even Roman soldiers will find it tough to defeat this enemy!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/wallguard_exact5.wav");
                                } else if (city_figures_total_invading_enemies() > 48) {
                                    text_draw_multiline("This bunch look like they won't be beaten easily", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/wallguard_exact4.wav");
                                } else if (city_figures_total_invading_enemies()) {
                                    text_draw_multiline("We should see those wimps off easily!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/wallguard_exact3.wav");
                                } else if (current_time % 5 < 2) {
                                    text_draw_multiline("No sign of barbarians", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/wallguard_exact1.wav");
                                } else if (current_time % 10 < 6) {
                                    text_draw_multiline("No sign of the enemy", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/wallguard_exact2.wav");
                                } else {
                                    if (!city_data.resource.food_supply_months) {
                                        text_draw_multiline("How's a soldier supposed to fight without food?", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/wallguard_starv1.wav");
                                    } else if (city_data.labor.unemployment_percentage >= 17) {
                                        text_draw_multiline("With unemployment this high I thank the gods that I have a job!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/wallguard_nojob1.wav");
                                    } else if (city_data.labor.workers_needed >= 10) {
                                        text_draw_multiline("This city needs more workers!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/wallguard_needjob1.wav");
                                    } else if (!city_data.culture.average_entertainment) {
                                        text_draw_multiline("If there was more entertainment in this city, guard duty wouldn't seem so dull!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/wallguard_nofun1.wav");
                                    } else if (least_god_happiness < 20) {
                                        text_draw_multiline("The gods are angry with this place!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/wallguard_relig1.wav");
                                    } else if (city_data.culture.average_entertainment <= 10) {
                                        text_draw_multiline("If there was more entertainment in this city, guard duty wouldn't seem so dull!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/wallguard_nofun1.wav");
                                    } else if (least_god_happiness < 40) {
                                        text_draw_multiline("The gods are angry with this place!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/wallguard_relig1.wav");
                                    } else if (city_data.culture.average_entertainment <= 20) {
                                        text_draw_multiline("If there was more entertainment in this city, guard duty wouldn't seem so dull!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/wallguard_nofun1.wav");
                                    } else if (city_data.resource.food_supply_months >= 4
                                            && city_data.labor.unemployment_percentage <= 5
                                            && city_data.culture.average_health
                                            && city_data.culture.average_education) {
                                        if (city_data.population.population < 500) {
                                            text_draw_multiline("Everything seems calm here..", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/wallguard_great1.wav");
                                        } else {
                                            text_draw_multiline("I may only be a lowly soldier, but even I can see what a great city this is!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/wallguard_great2.wav");
                                        }
                                    } else if (city_data.labor.unemployment_percentage >= 10) {
                                        text_draw_multiline("With unemployment this high I thank the gods that I have a job!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/wallguard_nojob1.wav");
                                    } else {
                                        text_draw_multiline("Everything seems calm here..", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/wallguard_great1.wav");
                                    }
                                }
                                break;
                            case FIGURE_PREFECT:
                                draw_figure_list();
                                if (selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_PREFECT_GOING_TO_FIRE || selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_PREFECT_GOING_TO_FIRE) {
                                    image_draw(8147, map_center_x - 200, map_center_y - 34);
                                } else {
                                    image_draw(8146, map_center_x - 200, map_center_y - 34);
                                }
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Prefect", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (selected_units_list[selected_unit_index]->engaged_in_combat) {
                                    random = rand() % 4;
                                    if (!random) {
                                        text_draw_multiline("This soldier is too strong for me!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/vigils_exact7.wav");
                                    } else if (random == 1) {
                                        text_draw_multiline("I'm not paid enough to fight!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/vigils_exact8.wav");
                                    } else if (random == 2) {
                                        text_draw_multiline("The city's defenses should never have let the enemy through!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/vigils_exact9.wav");
                                    } else if (random == 3) {
                                        text_draw_multiline("I'll fight to the death! This city's safe while I'm still alive!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/vigils_exact10.wav");
                                    }
                                } else if (selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_PREFECT_GOING_TO_FIRE) {
                                    text_draw_multiline("I'm a little busy right now", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/vigils_exact4.wav");
                                } else if (selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_PREFECT_AT_FIRE) {
                                    if (current_time % 2) {
                                        text_draw_multiline("The heat from this fire is amazing", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/vigils_exact5.wav");
                                    } else {
                                        text_draw_multiline("These fires spread if you don't catch them fast enough", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/vigils_exact6.wav");
                                    }
                                } else if (selected_units_list[selected_unit_index]->min_max_seen >= 50) {
                                    if (current_time % 2) {
                                        text_draw_multiline("No sign of crime around here", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/vigils_exact1.wav");
                                    } else {
                                        if (!city_data.resource.food_supply_months) {
                                            text_draw_multiline("There's not enough food in this city. It's encouraging crime.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/vigils_starv1.wav");
                                        } else if (city_data.labor.unemployment_percentage >= 17) {
                                            text_draw_multiline("I've never seen so many people out of work!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/vigils_nojob1.wav");
                                        } else if (city_data.labor.workers_needed >= 10) {
                                            text_draw_multiline("This city desperately needs more workers!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/vigils_needjob1.wav");
                                        } else if (!city_data.culture.average_entertainment) {
                                            text_draw_multiline("The criminals I lock up have better entertainment than this city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/vigils_nofun1.wav");
                                        } else if (least_god_happiness < 20) {
                                            text_draw_multiline("I'm terrified that the gods will curse this city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/vigils_relig1.wav");
                                        } else if (city_data.culture.average_entertainment <= 10) {
                                            text_draw_multiline("The criminals I lock up have better entertainment than this city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/vigils_nofun1.wav");
                                        } else if (least_god_happiness < 40) {
                                            text_draw_multiline("I'm terrified that the gods will curse this city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/vigils_relig1.wav");
                                        } else if (city_data.culture.average_entertainment <= 20) {
                                            text_draw_multiline("The criminals I lock up have better entertainment than this city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/vigils_nofun1.wav");
                                        } else if (city_data.resource.food_supply_months >= 4
                                                && city_data.labor.unemployment_percentage <= 5
                                                && city_data.culture.average_health
                                                && city_data.culture.average_education) {
                                            if (city_data.population.population < 500) {
                                                text_draw_multiline("Things seem to be working well here.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                                play_speech_file("wavs/vigils_great1.wav");
                                            } else {
                                                text_draw_multiline("This is a wonderful place to live.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                                play_speech_file("wavs/vigils_great2.wav");
                                            }
                                        } else if (city_data.labor.unemployment_percentage >= 10) {
                                            text_draw_multiline("I've never seen so many people out of work!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/vigils_nojob1.wav");
                                        } else {
                                            text_draw_multiline("Things seem to be working well here.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/vigils_great1.wav");
                                        }
                                    }
                                } else if (selected_units_list[selected_unit_index]->min_max_seen >= 10) {
                                    text_draw_multiline("This area has some risk of crime", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/vigils_exact2.wav");
                                } else {
                                    text_draw_multiline("This area is dangerous", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/vigils_exact3.wav");
                                }
                                break;
                            case FIGURE_FORT_STANDARD:
                            case FIGURE_FORT_JAVELIN:
                            case FIGURE_FORT_MOUNTED:
                            case FIGURE_FORT_LEGIONARY:
                                outer_panel_draw(map_center_x - 240, map_center_y - 136, 30, 17);
                                text_draw_centered(legion_names[selected_units_list[selected_unit_index]->formation_id], map_center_x - 240, map_center_y - 118, 480, FONT_LARGE_BLACK, COLOR_BLACK);
                                // animal symbol at the top of banner pole
                                int icon_image_id = 5422 + selected_units_list[selected_unit_index]->formation_id;
                                image_draw(icon_image_id, map_center_x - 224, map_center_y - 116);
                                // legion banner
                                int flag_image_id = 5374;
                                if (selected_units_list[selected_unit_index]->type == FIGURE_FORT_JAVELIN) {
                                    flag_image_id += 9;
                                } else if (selected_units_list[selected_unit_index]->type == FIGURE_FORT_MOUNTED) {
                                    flag_image_id += 18;
                                }
                                image_draw(flag_image_id, map_center_x - 224, map_center_y - 98);
                                // banner pole and morale ball
                                struct formation_t *m = &legion_formations[selected_units_list[selected_unit_index]->formation_id];
                                int pole_image_id = 5421 - m->morale / 5;
                                image_draw(pole_image_id, map_center_x - 223, map_center_y - 69);
                                // number of soldiers
                                text_draw("Soldiers in legion", map_center_x - 168, map_center_y - 81, FONT_NORMAL_BLACK, COLOR_BLACK);
                                text_draw_number(m->num_figures, 0, 0, map_center_x + 64, map_center_y - 81, FONT_NORMAL_BLACK);
                                // health
                                text_draw("Soldiers' health", map_center_x - 168, map_center_y - 63, FONT_NORMAL_BLACK, COLOR_BLACK);
                                int formation_damage = 0;
                                int formation_max_damage = 0;
                                for (int i = 0; i < m->num_figures; i++) {
                                    struct figure_t *f = &figures[m->figures[i]];
                                    if (figure_is_alive(f)) {
                                        formation_damage += selected_units_list[selected_unit_index]->damage;
                                        formation_max_damage += figure_properties[selected_units_list[selected_unit_index]->type].max_damage;
                                    }
                                }
                                int formation_damage_perc = calc_percentage(formation_damage, formation_max_damage);
                                if (!formation_damage_perc) {
                                    text_draw("Perfect", map_center_x + 64, map_center_y - 63, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else if (formation_damage_perc <= 20) {
                                    text_draw("Very good", map_center_x + 64, map_center_y - 63, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else if (formation_damage_perc <= 40) {
                                    text_draw("Good", map_center_x + 64, map_center_y - 63, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else if (formation_damage_perc <= 55) {
                                    text_draw("Average", map_center_x + 64, map_center_y - 63, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else if (formation_damage_perc <= 70) {
                                    text_draw("Poor", map_center_x + 64, map_center_y - 63, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else if (formation_damage_perc <= 90) {
                                    text_draw("Very poor", map_center_x + 64, map_center_y - 63, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else {
                                    text_draw("Appalling", map_center_x + 64, map_center_y - 63, FONT_NORMAL_BLACK, COLOR_BLACK);
                                }
                                // military training
                                text_draw("Academy trained", map_center_x - 168, map_center_y - 45, FONT_NORMAL_BLACK, COLOR_BLACK);
                                text_draw(m->has_military_training ? "Yes" : "No", map_center_x + 64, map_center_y - 45, FONT_NORMAL_BLACK, COLOR_BLACK);
                                // morale
                                if (m->cursed_by_mars) {
                                    text_draw("Cursed by Mars!", map_center_x - 168, map_center_y - 27, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else {
                                    text_draw("Morale", map_center_x - 168, map_center_y - 27, FONT_NORMAL_BLACK, COLOR_BLACK);
                                    text_draw(legion_morale_strings[m->morale / 5], map_center_x + 64, map_center_y - 27, FONT_NORMAL_BLACK, COLOR_BLACK);
                                }
                                if (m->num_figures) {
                                    // layout
                                    int OFFSETS_LEGIONARY[2][5] = {
                                        {0, 0, 2, 3, 4},
                                        {0, 0, 3, 2, 4},
                                    };
                                    int OFFSETS_OTHER[2][5] = {
                                        {5, 6, 2, 3, 4},
                                        {6, 5, 3, 2, 4},
                                    };
                                    int *offsets;
                                    int rotation_index = 0;
                                    if (view_data.orientation == DIR_6_LEFT || view_data.orientation == DIR_2_RIGHT) {
                                        rotation_index = 1;
                                    }
                                    if (selected_units_list[selected_unit_index]->type == FIGURE_FORT_LEGIONARY) {
                                        offsets = OFFSETS_LEGIONARY[rotation_index];
                                    } else {
                                        offsets = OFFSETS_OTHER[rotation_index];
                                    }
                                    for (int i = 0; i < 5; i++) {
                                        // for legionaries, draw tortoise formation in first position if academy trained, skip second position
                                        if (selected_units_list[selected_unit_index]->type == FIGURE_FORT_LEGIONARY) {
                                            if ((i == 0 && !m->has_military_training) || i == 1) {
                                                continue;
                                            }
                                        }
                                        image_draw(7764 + offsets[i], map_center_x - 210 + 85 * i, map_center_y);
                                    }
                                } else {
                                    // no soldiers
                                    if (m->cursed_by_mars) {
                                        text_draw_multiline("This fort has been cursed by Mars, It will be some time yet before any soldiers dare to venture back here.", map_center_x - 210, map_center_y + 16, 464, FONT_NORMAL_BLACK, COLOR_BLACK);
                                    } else if (count_data.buildings[BUILDING_BARRACKS].active) {
                                        text_draw_multiline("This legion currently has no soldiers. It exists in name only. Only when newly-trained troops arrive from the barracks will it become a fighting unit.", map_center_x - 210, map_center_y + 16, 464, FONT_NORMAL_BLACK, COLOR_BLACK);
                                    } else {
                                        text_draw_multiline("This legion currently has no soldiers. It exists in name only, and with no operating barracks in the city it cannot receive new troops.", map_center_x - 210, map_center_y + 16, 464, FONT_NORMAL_BLACK, COLOR_BLACK);
                                    }
                                }
                                if (!m->in_distant_battle && !m->is_at_rest) {
                                    text_draw_centered("Return to fort", map_center_x - 120, map_center_y + 99, 240, FONT_NORMAL_BLACK, COLOR_BLACK);
                                }
                                break;
                            case FIGURE_MARKET_BUYER:
                                draw_figure_list();
                                image_draw(8140, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Market buyer", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_MARKET_BUYER_GOING_TO_STORAGE) {
                                    text_draw_multiline("I'm off to collect more supplies", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/market_exact2.wav");
                                } else if (selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_MARKET_BUYER_RETURNING) {
                                    text_draw_multiline("These baskets are so heavy! They're full of new goods to sell!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/market_exact1.wav");
                                } else {
                                    if (!city_data.resource.food_supply_months) {
                                        text_draw_multiline("There's not enough food here! How am I supposed to make a living?", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/market_starv1.wav");
                                    } else if (city_data.labor.unemployment_percentage >= 17) {
                                        text_draw_multiline("With unemployment as high as it is, I'm working hard to keep my job!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/market_nojob1.wav");
                                    } else if (city_data.labor.workers_needed >= 10) {
                                        text_draw_multiline("I've never seen so many buildings needing more workers!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/market_needjob1.wav");
                                    } else if (!city_data.culture.average_entertainment) {
                                        text_draw_multiline("This must be the most boring city in the Empire!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/market_nofun1.wav");
                                    } else if (least_god_happiness < 20) {
                                        text_draw_multiline("This is a heathen place! The governor has no respect for the gods!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/market_relig1.wav");
                                    } else if (city_data.culture.average_entertainment <= 10) {
                                        text_draw_multiline("This must be the most boring city in the Empire!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/market_nofun1.wav");
                                    } else if (least_god_happiness < 40) {
                                        text_draw_multiline("This is a heathen place! The governor has no respect for the gods!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/market_relig1.wav");
                                    } else if (city_data.culture.average_entertainment <= 20) {
                                        text_draw_multiline("This must be the most boring city in the Empire!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/market_nofun1.wav");
                                    } else if (city_data.resource.food_supply_months >= 4
                                            && city_data.labor.unemployment_percentage <= 5
                                            && city_data.culture.average_health
                                            && city_data.culture.average_education) {
                                        if (city_data.population.population < 500) {
                                            text_draw_multiline("This city isn't too bad, really.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/market_great1.wav");
                                        } else {
                                            text_draw_multiline("Good day, citizen! Isn't this a great city?", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/market_great2.wav");
                                        }
                                    } else if (city_data.labor.unemployment_percentage >= 10) {
                                        text_draw_multiline("With unemployment as high as it is, I'm working hard to keep my job!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/market_nojob1.wav");
                                    } else {
                                        text_draw_multiline("This city isn't too bad, really.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/market_great1.wav");
                                    }
                                }
                                // returning with resource
                                // if (f->action_state == FIGURE_ACTION_MARKET_BUYER_GOING_TO_STORAGE) {
                                //     width += lang_text_draw(129, 17, c->x_offset + 90 + width, c->y_offset + 139, FONT_NORMAL_BROWN);
                                //     image_draw(resource_images[f->collecting_item_id + 1].icon_img_id + resource_image_offset(f->collecting_item_id + 1, RESOURCE_IMAGE_ICON),
                                //         c->x_offset + 90 + width, c->y_offset + 135);
                                // } else if (f->action_state == FIGURE_ACTION_MARKET_BUYER_RETURNING) {
                                //     width += lang_text_draw(129, 18, c->x_offset + 90 + width, c->y_offset + 139, FONT_NORMAL_BROWN);
                                //     image_draw(resource_images[f->collecting_item_id + 1].icon_img_id + resource_image_offset(f->collecting_item_id + 1, RESOURCE_IMAGE_ICON),
                                //         c->x_offset + 90 + width, c->y_offset + 135);
                                // }
                                break;
                            case FIGURE_MARKET_TRADER:
                                draw_figure_list();
                                image_draw(8140, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Market trader", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_ROAMER_RETURNING && building_market_get_max_food_stock(&all_buildings[selected_units_list[selected_unit_index]->building_id]) == 0) {
                                    text_draw_multiline("The market has run out of food, so I'm on my way home.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/market_exact3.wav");
                                } else {
                                    if (!city_data.resource.food_supply_months) {
                                        text_draw_multiline("There's not enough food here! How am I supposed to make a living?", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/market_starv1.wav");
                                    } else if (city_data.labor.unemployment_percentage >= 17) {
                                        text_draw_multiline("With unemployment as high as it is, I'm working hard to keep my job!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/market_nojob1.wav");
                                    } else if (city_data.labor.workers_needed >= 10) {
                                        text_draw_multiline("I've never seen so many buildings needing more workers!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/market_needjob1.wav");
                                    } else if (!city_data.culture.average_entertainment) {
                                        text_draw_multiline("This must be the most boring city in the Empire!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/market_nofun1.wav");
                                    } else if (least_god_happiness < 20) {
                                        text_draw_multiline("This is a heathen place! The governor has no respect for the gods!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/market_relig1.wav");
                                    } else if (city_data.culture.average_entertainment <= 10) {
                                        text_draw_multiline("This must be the most boring city in the Empire!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/market_nofun1.wav");
                                    } else if (least_god_happiness < 40) {
                                        text_draw_multiline("This is a heathen place! The governor has no respect for the gods!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/market_relig1.wav");
                                    } else if (city_data.culture.average_entertainment <= 20) {
                                        text_draw_multiline("This must be the most boring city in the Empire!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/market_nofun1.wav");
                                    } else if (city_data.resource.food_supply_months >= 4
                                            && city_data.labor.unemployment_percentage <= 5
                                            && city_data.culture.average_health
                                            && city_data.culture.average_education) {
                                        if (city_data.population.population < 500) {
                                            text_draw_multiline("This city isn't too bad, really.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/market_great1.wav");
                                        } else {
                                            text_draw_multiline("Good day, citizen! Isn't this a great city?", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/market_great2.wav");
                                        }
                                    } else if (city_data.labor.unemployment_percentage >= 10) {
                                        text_draw_multiline("With unemployment as high as it is, I'm working hard to keep my job!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/market_nojob1.wav");
                                    } else {
                                        text_draw_multiline("This city isn't too bad, really.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/market_great1.wav");
                                    }
                                }
                                break;
                            case FIGURE_DELIVERY_BOY:
                                draw_figure_list();
                                image_draw(8166, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Delivery boy", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                random = rand() % 3;
                                if (!random) {
                                    text_draw_multiline("That fat lady up front told me to carry this and follow her!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/granboy_exact1.wav");
                                } else if (random == 1) {
                                    text_draw_multiline("I don't care who needs this, there should be a law against child labor!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/granboy_exact2.wav");
                                } else if (random == 2) {
                                    text_draw_multiline("Hail! I'm taking this basket to that lady's market. I'm hoping for a big tip!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/granboy_exact3.wav");
                                }
                                break;
                            case FIGURE_WAREHOUSEMAN:
                                draw_figure_list();
                                image_draw(8179, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Warehouseman", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                image_draw(resource_images[selected_units_list[selected_unit_index]->resource_id].icon_img_id + resource_image_offset(selected_units_list[selected_unit_index]->resource_id, RESOURCE_IMAGE_ICON), map_center_x - 70, map_center_y - 40);
                                if (selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_CARTPUSHER_INITIAL) {
                                    if (selected_units_list[selected_unit_index]->min_max_seen == 2) {
                                        text_draw_multiline("The destination for these goods won't accept them! They need more workers.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_exact1.wav");
                                    } else if (selected_units_list[selected_unit_index]->min_max_seen == 1) {
                                        text_draw_multiline("There's no room for this lot anywhere in the city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_exact2.wav");
                                    }
                                } else if ((selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_DOCKER_IMPORT_GOING_TO_WAREHOUSE || selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_DOCKER_EXPORT_GOING_TO_WAREHOUSE)
                                && (calc_maximum_distance(selected_units_list[selected_unit_index]->destination_x, selected_units_list[selected_unit_index]->destination_y, selected_units_list[selected_unit_index]->source_x, selected_units_list[selected_unit_index]->source_y) >= 25)) {
                                    text_draw_multiline("It would be quicker to push these goods to Rome than to where I'm going!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/crtpsh_exact3.wav");
                                } else {
                                    if (!city_data.resource.food_supply_months) {
                                        text_draw_multiline("Pushing carts all day long takes energy; how's a cartpusher supposed to carry on without food?!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_starv1.wav");
                                    } else if (city_data.labor.unemployment_percentage >= 17) {
                                        text_draw_multiline("Unemployment is so high my wife's even stopped nagging me to get a better job!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_nojob1.wav");
                                    } else if (city_data.labor.workers_needed >= 10) {
                                        text_draw_multiline("Everywhere you look in this city there are job vacancies!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_needjob1.wav");
                                    } else if (!city_data.culture.average_entertainment) {
                                        text_draw_multiline("I don't mind pushing a cart; it's more entertaining than the rest of this city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_nofun1.wav");
                                    } else if (least_god_happiness < 20) {
                                        text_draw_multiline("I'm not a very religious citizen, but even I wouldn't treat the gods this badly!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_relig1.wav");
                                    } else if (city_data.culture.average_entertainment <= 10) {
                                        text_draw_multiline("I don't mind pushing a cart; it's more entertaining than the rest of this city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_nofun1.wav");
                                    } else if (least_god_happiness < 40) {
                                        text_draw_multiline("I'm not a very religious citizen, but even I wouldn't treat the gods this badly!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_relig1.wav");
                                    } else if (city_data.culture.average_entertainment <= 20) {
                                        text_draw_multiline("I don't mind pushing a cart; it's more entertaining than the rest of this city!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_nofun1.wav");
                                    } else if (city_data.resource.food_supply_months >= 4
                                            && city_data.labor.unemployment_percentage <= 5
                                            && city_data.culture.average_health
                                            && city_data.culture.average_education) {
                                        if (city_data.population.population < 500) {
                                            text_draw_multiline("As cities go, this one seems OK.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/crtpsh_great1.wav");
                                        } else {
                                            text_draw_multiline("Pushing carts all day long is hardly fun, but living here makes it worthwhile.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                            play_speech_file("wavs/crtpsh_great2.wav");
                                        }
                                    } else if (city_data.labor.unemployment_percentage >= 10) {
                                        text_draw_multiline("Unemployment is so high my wife's even stopped nagging me to get a better job!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_nojob1.wav");
                                    } else {
                                        text_draw_multiline("As cities go, this one seems OK.", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                        play_speech_file("wavs/crtpsh_great1.wav");
                                    }
                                }
                                break;
                            case FIGURE_PROTESTER:
                                draw_figure_list();
                                image_draw(8143, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Protester", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                random = rand() % 3;
                                if (!random) {
                                    text_draw_multiline("Down with the governor!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/rioter_exact1.wav");
                                } else if (random == 1) {
                                    text_draw_multiline("The governor clearly doesn't care about me!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/rioter_exact2.wav");
                                } else if (random == 2) {
                                    text_draw_multiline("If you want to know what cities look like when they burn, watch carefully!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/rioter_exact3.wav");
                                }
                                break;
                            case FIGURE_CRIMINAL:
                                draw_figure_list();
                                image_draw(8143, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Criminal", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                random = rand() % 3;
                                if (!random) {
                                    text_draw_multiline("Down with the governor!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/rioter_exact1.wav");
                                } else if (random == 1) {
                                    text_draw_multiline("The governor clearly doesn't care about me!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/rioter_exact2.wav");
                                } else if (random == 2) {
                                    text_draw_multiline("If you want to know what cities look like when they burn, watch carefully!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/rioter_exact3.wav");
                                }
                                break;
                            case FIGURE_RIOTER:
                                draw_figure_list();
                                image_draw(8143, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Rioter", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                random = rand() % 3;
                                if (!random) {
                                    text_draw_multiline("Down with the governor!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/rioter_exact1.wav");
                                } else if (random == 1) {
                                    text_draw_multiline("The governor clearly doesn't care about me!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/rioter_exact2.wav");
                                } else if (random == 2) {
                                    text_draw_multiline("If you want to know what cities look like when they burn, watch carefully!", map_center_x - 137, map_center_y + 16, 345, FONT_NORMAL_BROWN, COLOR_BLACK);
                                    play_speech_file("wavs/rioter_exact3.wav");
                                }
                                break;
                            case FIGURE_TRADE_CARAVAN:
                            case FIGURE_TRADE_CARAVAN_DONKEY:
                                draw_figure_list();
                                image_draw(8143, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Merchant", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_TRADE_CARAVAN_ARRIVING) {
                                    play_speech_file("wavs/donkey_exact2.wav");
                                } else if (selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_TRADE_CARAVAN_TRADING) {
                                    if (figure_trade_caravan_can_buy(selected_units_list[selected_unit_index], selected_units_list[selected_unit_index]->destination_building_id, selected_units_list[selected_unit_index]->empire_city_id)) {
                                        play_speech_file("wavs/donkey_exact5.wav");
                                    } else if (figure_trade_caravan_can_sell(selected_units_list[selected_unit_index], selected_units_list[selected_unit_index]->destination_building_id, selected_units_list[selected_unit_index]->empire_city_id)) {
                                        play_speech_file("wavs/donkey_exact4.wav");
                                    }
                                } else if (selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_TRADE_CARAVAN_LEAVING) {
                                    if (trader_has_traded(selected_units_list[selected_unit_index]->trader_id)) {
                                        play_speech_file("wavs/donkey_exact3.wav");
                                    } else {
                                        play_speech_file("wavs/donkey_exact1.wav");
                                    }
                                }
                                // caravan or merchants from {city}, capacity, returning home, bought/sold - also for trade ship
                                // while (f->type == FIGURE_TRADE_CARAVAN_DONKEY) {
                                //     f = &figures[f->leading_figure_id];
                                // }
                                // // lang_text_draw(65, f->name_id, c->x_offset + 40, c->y_offset + 110, FONT_NORMAL_BROWN);
                                // int width = text_draw(figure_desc_strings[f->type], c->x_offset + 40, c->y_offset + 130, FONT_NORMAL_BROWN, COLOR_BLACK);
                                // lang_text_draw(21, empire_objects[f->empire_city_id].city_name_id, c->x_offset + 40 + width, c->y_offset + 130, FONT_NORMAL_BROWN);
                                // width = lang_text_draw(129, 1, c->x_offset + 40, c->y_offset + 150, FONT_NORMAL_BROWN);
                                // lang_text_draw_amount(8, 10, f->type == FIGURE_TRADE_SHIP ? 12 : 8, c->x_offset + 40 + width, c->y_offset + 150, FONT_NORMAL_BROWN);
                                // int trader_id = f->trader_id;
                                // int text_id;
                                // if (f->type == FIGURE_TRADE_SHIP) {
                                //     switch (f->action_state) {
                                //         case FIGURE_ACTION_TRADE_SHIP_ANCHORED: text_id = 6; break;
                                //         case FIGURE_ACTION_TRADE_SHIP_MOORED: text_id = 7; break;
                                //         case FIGURE_ACTION_TRADE_SHIP_LEAVING: text_id = 8; break;
                                //         default: text_id = 9; break;
                                //     }
                                // } else {
                                //     switch (f->action_state) {
                                //         case FIGURE_ACTION_TRADE_CARAVAN_ARRIVING:
                                //             text_id = 12;
                                //             break;
                                //         case FIGURE_ACTION_TRADE_CARAVAN_TRADING:
                                //             text_id = 10;
                                //             break;
                                //         case FIGURE_ACTION_TRADE_CARAVAN_LEAVING:
                                //             if (trader_has_traded(trader_id)) {
                                //                 text_id = 11;
                                //             } else {
                                //                 text_id = 13;
                                //             }
                                //             break;
                                //         default:
                                //             text_id = 11;
                                //             break;
                                //     }
                                // }
                                // lang_text_draw(129, text_id, c->x_offset + 40, c->y_offset + 170, FONT_NORMAL_BROWN);
                                // if (trader_has_traded(trader_id)) {
                                //     // bought
                                //     int y_base = c->y_offset + 192;
                                //     width = lang_text_draw(129, 4, c->x_offset + 40, y_base, FONT_NORMAL_BROWN);
                                //     for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                //         if (figure_trader_data.traders[trader_id].bought_resources[r]) {
                                //             width += text_draw_number(figure_trader_data.traders[trader_id].bought_resources[r], ' ', "", c->x_offset + 40 + width, y_base, FONT_NORMAL_BROWN);
                                //             image_draw(resource_images[r].icon_img_id + resource_image_offset(r, RESOURCE_IMAGE_ICON), c->x_offset + 40 + width, y_base - 3);
                                //             width += 25;
                                //         }
                                //     }
                                //     // sold
                                //     y_base = c->y_offset + 213;
                                //     width = lang_text_draw(129, 5, c->x_offset + 40, y_base, FONT_NORMAL_BROWN);
                                //     for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                //         if (figure_trader_data.traders[trader_id].sold_resources[r]) { 
                                //             width += text_draw_number(figure_trader_data.traders[trader_id].sold_resources[r], ' ', "", c->x_offset + 40 + width, y_base, FONT_NORMAL_BROWN);
                                //             image_draw(resource_images[r].icon_img_id + resource_image_offset(r, RESOURCE_IMAGE_ICON), c->x_offset + 40 + width, y_base - 3);
                                //             width += 25;
                                //         }
                                //     }
                                // } else { // nothing sold/bought (yet)
                                //     // buying
                                //     int y_base = c->y_offset + 192;
                                //     width = lang_text_draw(129, 2, c->x_offset + 40, y_base, FONT_NORMAL_BROWN);
                                //     for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                //         if (empire_objects[f->empire_city_id].resource_buy_limit[r]) {
                                //             image_draw(resource_images[r].icon_img_id + resource_image_offset(r, RESOURCE_IMAGE_ICON), c->x_offset + 40 + width, y_base - 3);
                                //             width += 25;
                                //         }
                                //     }
                                //     // selling
                                //     y_base = c->y_offset + 213;
                                //     width = lang_text_draw(129, 3, c->x_offset + 40, y_base, FONT_NORMAL_BROWN);
                                //     for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                //         if (empire_objects[f->empire_city_id].resource_sell_limit[r]) {
                                //             image_draw(resource_images[r].icon_img_id + resource_image_offset(r, RESOURCE_IMAGE_ICON), c->x_offset + 40 + width, y_base - 3);
                                //             width += 25;
                                //         }
                                //     }
                                // }
                                break;
                            case FIGURE_TRADE_SHIP:
                                draw_figure_list();
                                image_draw(8189, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Trade ship", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                if (selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_TRADE_SHIP_GOING_TO_DOCK) {
                                    play_speech_file("wavs/boats_exact4.wav");
                                } else if (selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_TRADE_SHIP_MOORED) {
                                    struct building_t *b = &all_buildings[selected_units_list[selected_unit_index]->destination_building_id];
                                    for (int j = 0; j < 3; j++) {
                                        struct figure_t *docker = &figures[b->data.dock.docker_ids[j]];
                                        if (!b->data.dock.docker_ids[j] || !figure_is_alive(docker)) {
                                            continue;
                                        }
                                        switch (docker->action_state) {
                                            case FIGURE_ACTION_DOCKER_IMPORT_QUEUE:
                                            case FIGURE_ACTION_DOCKER_IMPORT_GOING_TO_WAREHOUSE:
                                            case FIGURE_ACTION_DOCKER_IMPORT_RETURNING:
                                            case FIGURE_ACTION_DOCKER_IMPORT_AT_WAREHOUSE:
                                                play_speech_file("wavs/boats_exact1.wav");
                                                break;
                                            case FIGURE_ACTION_DOCKER_EXPORT_QUEUE:
                                            case FIGURE_ACTION_DOCKER_EXPORT_GOING_TO_WAREHOUSE:
                                            case FIGURE_ACTION_DOCKER_EXPORT_RETURNING:
                                            case FIGURE_ACTION_DOCKER_EXPORT_AT_WAREHOUSE:
                                                play_speech_file("wavs/boats_exact2.wav");
                                                break;
                                        }
                                    }
                                } else if (selected_units_list[selected_unit_index]->action_state == FIGURE_ACTION_TRADE_SHIP_LEAVING) {
                                    if (trader_has_traded(selected_units_list[selected_unit_index]->trader_id)) {
                                        play_speech_file("wavs/boats_exact5.wav");
                                    } else {
                                        play_speech_file("wavs/boats_exact3.wav");
                                    }
                                }
                                break;
                            case FIGURE_INDIGENOUS_NATIVE:
                                draw_figure_list();
                                image_draw(8149, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Indigenous native", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_NATIVE_TRADER:
                                draw_figure_list();
                                image_draw(8191, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Native trader", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_WOLF:
                                draw_figure_list();
                                image_draw(8183, map_center_x - 200, map_center_y - 34);
                                text_draw("Wolf", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_SHEEP:
                                draw_figure_list();
                                image_draw(8182, map_center_x - 200, map_center_y - 34);
                                text_draw("Sheep", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ZEBRA:
                                draw_figure_list();
                                image_draw(8184, map_center_x - 200, map_center_y - 34);
                                text_draw("Zebra", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_GLADIATOR:
                                draw_figure_list();
                                image_draw(8161, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Enemy gladiator", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_BARBARIAN_SWORDSMAN:
                                draw_figure_list();
                                image_draw(8149, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A barbarian warrior", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_CARTHAGINIAN_SWORDSMAN:
                                draw_figure_list();
                                image_draw(8150, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Carthaginian soldier", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_CARTHAGINIAN_ELEPHANT:
                                draw_figure_list();
                                image_draw(8158, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Carthaginian soldier", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_BRITON_SWORDSMAN:
                                draw_figure_list();
                                image_draw(8152, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Briton", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_BRITON_CHARIOT:
                                draw_figure_list();
                                image_draw(8151, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Briton", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_CELT_SWORDSMAN:
                                draw_figure_list();
                                image_draw(8152, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Celtic warrior", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_CELT_CHARIOT:
                                draw_figure_list();
                                image_draw(8151, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Celtic warrior", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_PICT_SWORDSMAN:
                                draw_figure_list();
                                image_draw(8152, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Pictish warrior", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_PICT_CHARIOT:
                                draw_figure_list();
                                image_draw(8151, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Pictish warrior", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_EGYPTIAN_SWORDSMAN:
                                draw_figure_list();
                                image_draw(8157, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("An Egyptian soldier", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_EGYPTIAN_CAMEL:
                                draw_figure_list();
                                image_draw(8156, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("An Egyptian soldier", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_ETRUSCAN_SWORDSMAN:
                                draw_figure_list();
                                image_draw(8159, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("An Etruscan soldier", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_ETRUSCAN_SPEAR_THROWER:
                                draw_figure_list();
                                image_draw(8160, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("An Etruscan soldier", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_SAMNITE_SWORDSMAN:
                                draw_figure_list();
                                image_draw(8159, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Samnite soldier", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_SAMNITE_SPEAR_THROWER:
                                draw_figure_list();
                                image_draw(8160, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Samnite soldier", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_GAUL_SWORDSMAN:
                                draw_figure_list();
                                image_draw(8168, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Gaulish warrior", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_GAUL_AXEMAN:
                                draw_figure_list();
                                image_draw(8167, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Gaulish warrior", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_HELVETIUS_SWORDSMAN:
                                draw_figure_list();
                                image_draw(8168, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A warrior of the Helvetii", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_HELVETIUS_AXEMAN:
                                draw_figure_list();
                                image_draw(8167, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A warrior of the Helvetii", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_HUN_SWORDSMAN:
                                draw_figure_list();
                                image_draw(8163, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Hun warrior", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_HUN_MOUNTED_ARCHER:
                                draw_figure_list();
                                image_draw(8162, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Hun warrior", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_GOTH_SWORDSMAN:
                                draw_figure_list();
                                image_draw(8163, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Goth warrior", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_GOTH_MOUNTED_ARCHER:
                                draw_figure_list();
                                image_draw(8162, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Goth warrior", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_VISIGOTH_SWORDSMAN:
                                draw_figure_list();
                                image_draw(8163, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Visigoth warrior", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_VISIGOTH_MOUNTED_ARCHER:
                                draw_figure_list();
                                image_draw(8162, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Visigoth warrior", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_GREEK_SWORDSMAN:
                                draw_figure_list();
                                image_draw(8165, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Greek soldier", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_GREEK_SPEAR_THROWER:
                                draw_figure_list();
                                image_draw(8164, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Greek soldier", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_MACEDONIAN_SWORDSMAN:
                                draw_figure_list();
                                image_draw(8165, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Macedonian soldier", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_MACEDONIAN_SPEAR_THROWER:
                                draw_figure_list();
                                image_draw(8164, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Macedonian soldier", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_NUMIDIAN_SWORDSMAN:
                                draw_figure_list();
                                image_draw(8148, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Numidian warrior", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_NUMIDIAN_SPEAR_THROWER:
                                draw_figure_list();
                                image_draw(8148, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Numidian warrior", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_PERGAMUM_SWORDSMAN:
                                draw_figure_list();
                                image_draw(8173, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A soldier from Pergamum", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_PERGAMUM_ARCHER:
                                draw_figure_list();
                                image_draw(8172, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A soldier from Pergamum", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_IBERIAN_SWORDSMAN:
                                draw_figure_list();
                                image_draw(8175, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("An Iberian warrior", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_IBERIAN_SPEAR_THROWER:
                                draw_figure_list();
                                image_draw(8174, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("An Iberian warrior", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_JUDEAN_SWORDSMAN:
                                draw_figure_list();
                                image_draw(8175, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Judaean warrior", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_JUDEAN_SPEAR_THROWER:
                                draw_figure_list();
                                image_draw(8174, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Judaean warrior", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_SELEUCID_SWORDSMAN:
                                draw_figure_list();
                                image_draw(8175, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Seleucid soldier", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_SELEUCID_SPEAR_THROWER:
                                draw_figure_list();
                                image_draw(8174, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("A Seleucid soldier", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                            case FIGURE_ENEMY_CAESAR_LEGIONARY:
                                draw_figure_list();
                                image_draw(8176, map_center_x - 200, map_center_y - 34);
                                text_draw(selected_units_list[selected_unit_index]->name, map_center_x - 137, map_center_y - 34, FONT_LARGE_BROWN, COLOR_BLACK);
                                text_draw("Imperial soldier", map_center_x - 137, map_center_y - 4, FONT_NORMAL_BROWN, COLOR_BLACK);
                                break;
                        }
                    } else if (selected_building->id) {
                        switch (selected_building->type) {
                            case BUILDING_HOUSE_VACANT_LOT:
                                outer_panel_draw(map_center_x - 88, map_center_y - 32, 11, 4);
                                text_draw_centered("Vacant lot", map_center_x - 88, map_center_y - 12, 176, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/empty_land.wav");
                                break;
                            case BUILDING_HOUSE_SMALL_TENT:
                                draw_common_house_context();
                                text_draw_centered("Small tent", map_center_x - 176, map_center_y - 140, 352, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/house_slum1.wav");
                                break;
                            case BUILDING_HOUSE_LARGE_TENT:
                                draw_common_house_context();
                                text_draw_centered("Large tent", map_center_x - 176, map_center_y - 140, 352, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/house_slum2.wav");
                                break;
                            case BUILDING_HOUSE_SMALL_SHACK:
                                draw_common_house_context();
                                text_draw_centered("Small schack", map_center_x - 176, map_center_y - 140, 352, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/house_slum3.wav");
                                break;
                            case BUILDING_HOUSE_LARGE_SHACK:
                                draw_common_house_context();
                                text_draw_centered("Large shack", map_center_x - 176, map_center_y - 140, 352, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/wavs/house_slum4.wav");
                                break;
                            case BUILDING_HOUSE_SMALL_HOVEL:
                                draw_common_house_context();
                                text_draw_centered("Small hovel", map_center_x - 176, map_center_y - 140, 352, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/house_poor1");
                                break;
                            case BUILDING_HOUSE_LARGE_HOVEL:
                                draw_common_house_context();
                                text_draw_centered("Large hovel", map_center_x - 176, map_center_y - 140, 352, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/house_poor2");
                                break;
                            case BUILDING_HOUSE_SMALL_CASA:
                                draw_common_house_context();
                                text_draw_centered("Small casa", map_center_x - 176, map_center_y - 140, 352, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/house_poor3");
                                break;
                            case BUILDING_HOUSE_LARGE_CASA:
                                draw_common_house_context();
                                text_draw_centered("Large casa", map_center_x - 176, map_center_y - 140, 352, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/house_poor4");
                                break;
                            case BUILDING_HOUSE_SMALL_INSULA:
                                draw_common_house_context();
                                text_draw_centered("Small insula", map_center_x - 176, map_center_y - 140, 352, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/house_mid1.wav");
                                break;
                            case BUILDING_HOUSE_MEDIUM_INSULA:
                                draw_common_house_context();
                                text_draw_centered("Medium insula", map_center_x - 176, map_center_y - 140, 352, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/house_mid2.wav");
                                break;
                            case BUILDING_HOUSE_LARGE_INSULA:
                                draw_common_house_context();
                                text_draw_centered("Large insula", map_center_x - 176, map_center_y - 140, 352, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/house_mid3.wav");
                                break;
                            case BUILDING_HOUSE_GRAND_INSULA:
                                draw_common_house_context();
                                text_draw_centered("Grand insula", map_center_x - 176, map_center_y - 140, 352, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/house_mid4.wav");
                                break;
                            case BUILDING_HOUSE_SMALL_VILLA:
                                draw_common_house_context();
                                text_draw_centered("Small villa", map_center_x - 176, map_center_y - 140, 352, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/house_good1.wav");
                                break;
                            case BUILDING_HOUSE_MEDIUM_VILLA:
                                draw_common_house_context();
                                text_draw_centered("Medium villa", map_center_x - 176, map_center_y - 140, 352, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/house_good2.wav");
                                break;
                            case BUILDING_HOUSE_LARGE_VILLA:
                                draw_common_house_context();
                                text_draw_centered("Large villa", map_center_x - 176, map_center_y - 140, 352, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/house_good3.wav");
                                break;
                            case BUILDING_HOUSE_GRAND_VILLA:
                                draw_common_house_context();
                                text_draw_centered("Grand villa", map_center_x - 176, map_center_y - 140, 352, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/house_good4.wav");
                                break;
                            case BUILDING_HOUSE_SMALL_PALACE:
                                draw_common_house_context();
                                text_draw_centered("Small palace", map_center_x - 176, map_center_y - 140, 352, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/house_posh1.wav");
                                break;
                            case BUILDING_HOUSE_MEDIUM_PALACE:
                                draw_common_house_context();
                                text_draw_centered("Medium palace", map_center_x - 176, map_center_y - 140, 352, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/house_posh2.wav");
                                break;
                            case BUILDING_HOUSE_LARGE_PALACE:
                                draw_common_house_context();
                                text_draw_centered("Large palace", map_center_x - 176, map_center_y - 140, 352, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/house_posh3.wav");
                                break;
                            case BUILDING_HOUSE_LUXURY_PALACE:
                                draw_common_house_context();
                                text_draw_centered("Luxury palace", map_center_x - 176, map_center_y - 140, 352, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/house_posh4.wav");
                                break;
                                break;
                            case BUILDING_RESERVOIR:
                                outer_panel_draw(map_center_x - 80, map_center_y - 32, 10, 4);
                                text_draw_centered("Reservoir", map_center_x - 80, map_center_y - 12, 160, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/resevoir.wav");
                                break;
                            case BUILDING_FOUNTAIN:
                                outer_panel_draw(map_center_x - 80, map_center_y - 32, 10, 4);
                                text_draw_centered("Fountain", map_center_x - 80, map_center_y - 12, 160, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/fountain.wav");
                                break;
                            case BUILDING_WELL:
                                outer_panel_draw(map_center_x - 56, map_center_y - 32, 7, 4);
                                text_draw_centered("Well", map_center_x - 56, map_center_y - 12, 112, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/well.wav");
                                break;
                            case BUILDING_DOCTOR:
                                outer_panel_draw(map_center_x - 120, map_center_y - 56, 15, 7);
                                text_draw("Doctor's clinic", map_center_x - 80, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/clinic.wav");
                                break;
                            case BUILDING_BATHHOUSE:
                                outer_panel_draw(map_center_x - 104, map_center_y - 56, 13, 7);
                                text_draw("Bath house", map_center_x - 64, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/baths.wav");
                                break;
                            case BUILDING_BARBER:
                                outer_panel_draw(map_center_x - 80, map_center_y - 56, 10, 7);
                                text_draw("Barber", map_center_x - 40, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/barber.wav");
                                break;
                            case BUILDING_HOSPITAL:
                                outer_panel_draw(map_center_x - 88, map_center_y - 56, 11, 7);
                                text_draw("Hospital", map_center_x - 48, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/hospital.wav");
                                break;
                            case BUILDING_SMALL_TEMPLE_CERES:
                            case BUILDING_LARGE_TEMPLE_CERES:
                                outer_panel_draw(map_center_x - 136, map_center_y - 56, 17, 7);
                                text_draw("Temple to Ceres", map_center_x - 96, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/temp_farm.wav");
                                break;
                            case BUILDING_SMALL_TEMPLE_NEPTUNE:
                            case BUILDING_LARGE_TEMPLE_NEPTUNE:
                                outer_panel_draw(map_center_x - 160, map_center_y - 56, 20, 7);
                                text_draw("Temple to Neptune", map_center_x - 120, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/temp_ship.wav");
                                break;
                            case BUILDING_SMALL_TEMPLE_MERCURY:
                            case BUILDING_LARGE_TEMPLE_MERCURY:
                                outer_panel_draw(map_center_x - 160, map_center_y - 56, 20, 7);
                                text_draw("Temple to Mercury", map_center_x - 120, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/temp_comm.wav");
                                break;
                            case BUILDING_SMALL_TEMPLE_MARS:
                            case BUILDING_LARGE_TEMPLE_MARS:
                                outer_panel_draw(map_center_x - 136, map_center_y - 56, 17, 7);
                                text_draw("Temple to Mars", map_center_x - 96, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/temp_war.wav");
                                break;
                            case BUILDING_SMALL_TEMPLE_VENUS:
                            case BUILDING_LARGE_TEMPLE_VENUS:
                                outer_panel_draw(map_center_x - 144, map_center_y - 56, 18, 7);
                                text_draw("Temple to Venus", map_center_x - 104, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/temp_love.wav");
                                break;
                            case BUILDING_ORACLE:
                                outer_panel_draw(map_center_x - 72, map_center_y - 56, 9, 7);
                                text_draw("Oracle", map_center_x - 32, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/oracle.wav");
                                break;
                            case BUILDING_SCHOOL:
                                outer_panel_draw(map_center_x - 80, map_center_y - 56, 10, 7);
                                text_draw("School", map_center_x - 40, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/school.wav");
                                break;
                            case BUILDING_LIBRARY:
                                outer_panel_draw(map_center_x - 88, map_center_y - 56, 11, 7);
                                text_draw("Library", map_center_x - 48, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/library.wav");
                                break;
                            case BUILDING_ACADEMY:
                                outer_panel_draw(map_center_x - 88, map_center_y - 56, 11, 7);
                                text_draw("Academy", map_center_x - 48, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/academy.wav");
                                break;
                            case BUILDING_MISSION_POST:
                                outer_panel_draw(map_center_x - 112, map_center_y - 56, 14, 7);
                                text_draw("Mission post", map_center_x - 73, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                break;
                            case BUILDING_THEATER:
                                outer_panel_draw(map_center_x - 80, map_center_y - 56, 10, 7);
                                text_draw("Theater", map_center_x - 40, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/theatre.wav");
                                break;
                            case BUILDING_ACTOR_COLONY:
                                outer_panel_draw(map_center_x - 112, map_center_y - 56, 14, 7);
                                text_draw("Actor colony", map_center_x - 72, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/art_pit.wav");
                                break;
                            case BUILDING_AMPHITHEATER:
                                outer_panel_draw(map_center_x - 120, map_center_y - 56, 15, 7);
                                text_draw("Amphitheater", map_center_x - 80, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/ampitheatre.wav");
                                break;
                            case BUILDING_GLADIATOR_SCHOOL:
                                outer_panel_draw(map_center_x - 136, map_center_y - 56, 17, 7);
                                text_draw("Gladiator school", map_center_x - 96, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/glad_pit.wav");
                                break;
                            case BUILDING_LION_HOUSE:
                                outer_panel_draw(map_center_x - 104, map_center_y - 56, 13, 7);
                                text_draw("Lion house", map_center_x - 64, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/lion_pit.wav");
                                break;
                            case BUILDING_COLOSSEUM:
                                outer_panel_draw(map_center_x - 104, map_center_y - 56, 13, 7);
                                text_draw("Colosseum", map_center_x - 64, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/colloseum.wav");
                                break;
                            case BUILDING_CHARIOT_MAKER:
                                outer_panel_draw(map_center_x - 120, map_center_y - 56, 15, 7);
                                text_draw("Chariot maker", map_center_x - 80, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/char_pit.wav");
                                break;
                            case BUILDING_HIPPODROME:
                                outer_panel_draw(map_center_x - 112, map_center_y - 56, 14, 7);
                                text_draw("Hippodrome", map_center_x - 72, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/hippodrome.wav");
                                break;
                            case BUILDING_SMALL_STATUE:
                                outer_panel_draw(map_center_x - 104, map_center_y - 32, 13, 4);
                                text_draw_centered("Small statue", map_center_x - 104, map_center_y - 12, 208, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/gardens2.wav");
                                break;
                            case BUILDING_MEDIUM_STATUE:
                                outer_panel_draw(map_center_x - 112, map_center_y - 32, 14, 4);
                                text_draw_centered("Medium statue", map_center_x - 112, map_center_y - 12, 224, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/gardens3.wav");
                                break;
                            case BUILDING_LARGE_STATUE:
                                outer_panel_draw(map_center_x - 104, map_center_y - 32, 13, 4);
                                text_draw_centered("Large statue", map_center_x - 104, map_center_y - 12, 208, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/gardens4.wav");
                                break;
                            case BUILDING_GOVERNORS_HOUSE:
                                outer_panel_draw(map_center_x - 136, map_center_y - 32, 17, 4);
                                text_draw_centered("Governor's house", map_center_x - 136, map_center_y - 12, 272, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/palace.wav");
                                break;
                            case BUILDING_GOVERNORS_VILLA:
                                outer_panel_draw(map_center_x - 128, map_center_y - 32, 16, 4);
                                text_draw_centered("Governor's villa", map_center_x - 128, map_center_y - 12, 256, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/palace.wav");
                                break;
                            case BUILDING_GOVERNORS_PALACE:
                                outer_panel_draw(map_center_x - 136, map_center_y - 32, 17, 4);
                                text_draw_centered("Governor's palace", map_center_x - 136, map_center_y - 12, 272, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/palace.wav");
                                break;
                            case BUILDING_FORUM:
                                outer_panel_draw(map_center_x - 88, map_center_y - 64, 11, 8);
                                text_draw("Forum", map_center_x - 48, map_center_y - 52, FONT_LARGE_BLACK, COLOR_BLACK);
                                width = text_draw_number(selected_building->tax_income_or_storage, 0, 0, map_center_x - 72, map_center_y + 38, FONT_NORMAL_BLACK);
                                image_draw(1202, map_center_x - 72 + width, map_center_y + 32);
                                text_draw("in vaults", map_center_x - 44 + width, map_center_y + 38, FONT_NORMAL_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/forum.wav");
                                break;
                            case BUILDING_SENATE:
                                outer_panel_draw(map_center_x - 88, map_center_y - 64, 11, 8);
                                text_draw("Senate", map_center_x - 48, map_center_y - 52, FONT_LARGE_BLACK, COLOR_BLACK);
                                width = text_draw_number(selected_building->tax_income_or_storage, 0, 0, map_center_x - 72, map_center_y + 38, FONT_NORMAL_BLACK);
                                image_draw(1202, map_center_x - 72 + width, map_center_y + 32);
                                text_draw("in vaults", map_center_x - 44 + width, map_center_y + 38, FONT_NORMAL_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/senate.wav");
                                break;
                            case BUILDING_TRIUMPHAL_ARCH:
                                outer_panel_draw(map_center_x - 120, map_center_y - 56, 15, 7);
                                text_draw_centered("Triumphal arch", map_center_x - 120, map_center_y - 44, 240, FONT_LARGE_BLACK, COLOR_BLACK);
                                break;
                            case BUILDING_ENGINEERS_POST:
                                outer_panel_draw(map_center_x - 120, map_center_y - 56, 15, 7);
                                text_draw_centered("Engineer's post", map_center_x - 120, map_center_y - 41, 240, FONT_LARGE_BLACK, COLOR_BLACK);
                                break;
                            case BUILDING_LOW_BRIDGE:
                                outer_panel_draw(map_center_x - 96, map_center_y - 32, 12, 4);
                                text_draw_centered("Low bridge", map_center_x - 96, map_center_y - 12, 192, FONT_LARGE_BLACK, COLOR_BLACK);
                                break;
                            case BUILDING_SHIP_BRIDGE:
                                outer_panel_draw(map_center_x - 96, map_center_y - 32, 12, 4);
                                text_draw_centered("Ship bridge", map_center_x - 96, map_center_y - 12, 192, FONT_LARGE_BLACK, COLOR_BLACK);
                                break;
                            case BUILDING_SHIPYARD:
                                outer_panel_draw(map_center_x - 96, map_center_y - 56, 12, 7);
                                text_draw_centered("Shipyard", map_center_x - 96, map_center_y - 41, 192, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/shipyard.wav");
                                break;
                            case BUILDING_WHARF:
                                outer_panel_draw(map_center_x - 80, map_center_y - 56, 10, 7);
                                text_draw_centered("Wharf", map_center_x - 80, map_center_y - 41, 160, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/wharf.wav");
                                break;
                            case BUILDING_DOCK:
                                outer_panel_draw(map_center_x - 80, map_center_y - 56, 10, 7);
                                text_draw("Dock", map_center_x - 40, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/dock.wav");
                                break;
                            case BUILDING_PREFECTURE:
                                outer_panel_draw(map_center_x - 96, map_center_y - 56, 12, 7);
                                text_draw_centered("Prefecture", map_center_x - 96, map_center_y - 41, 192, FONT_LARGE_BLACK, COLOR_BLACK);
                                break;
                            case BUILDING_WALL:
                                outer_panel_draw(map_center_x - 40, map_center_y - 32, 5, 4);
                                text_draw_centered("Wall", map_center_x - 40, map_center_y - 12, 80, FONT_LARGE_BLACK, COLOR_BLACK);
                                break;
                            case BUILDING_TOWER:
                                outer_panel_draw(map_center_x - 80, map_center_y - 56, 10, 7);
                                text_draw_centered("Tower", map_center_x - 80, map_center_y - 41, 160, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/tower1.wav");
                                break;
                            case BUILDING_GATEHOUSE:
                                outer_panel_draw(map_center_x - 88, map_center_y - 32, 11, 4);
                                text_draw_centered("Gatehouse", map_center_x - 88, map_center_y - 12, 176, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/tower4.wav");
                                break;
                            case BUILDING_FORT_LEGIONARIES:
                                outer_panel_draw(map_center_x - 136, map_center_y - 32, 17, 4);
                                text_draw("Fort: legionaries", map_center_x - 96, map_center_y - 20, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/fort1.wav");
                                break;
                            case BUILDING_FORT_JAVELIN:
                                outer_panel_draw(map_center_x - 128, map_center_y - 32, 16, 4);
                                text_draw("Fort: javelin", map_center_x - 88, map_center_y - 20, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/fort1.wav");
                                break;
                            case BUILDING_FORT_MOUNTED:
                                outer_panel_draw(map_center_x - 128, map_center_y - 32, 16, 4);
                                text_draw("Fort: mounted", map_center_x - 88, map_center_y - 20, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/fort1.wav");
                                break;
                            case BUILDING_BARRACKS:
                                outer_panel_draw(map_center_x - 88, map_center_y - 64, 11, 8);
                                text_draw("Barracks", map_center_x - 48, map_center_y - 52, FONT_LARGE_BLACK, COLOR_BLACK);
                                width = text_draw_number(selected_building->loads_stored, 0, 0, map_center_x - 72, map_center_y + 38, FONT_NORMAL_BLACK);
                                image_draw(resource_images[RESOURCE_WEAPONS].icon_img_id, map_center_x - 72 + width, map_center_y + 32);
                                text_draw("stored", map_center_x - 50 + width, map_center_y + 38, FONT_NORMAL_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/barracks.wav");
                                break;
                            case BUILDING_MILITARY_ACADEMY:
                                outer_panel_draw(map_center_x - 144, map_center_y - 56, 18, 7);
                                text_draw("Military academy", map_center_x - 104, map_center_y - 44, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/mil_acad.wav");
                                break;
                            case BUILDING_WHEAT_FARM:
                                outer_panel_draw(map_center_x - 112, map_center_y - 64, 14, 8);
                                text_draw("Wheat farm", map_center_x - 72, map_center_y - 52, FONT_LARGE_BLACK, COLOR_BLACK);
                                if (city_data.resource.mothballed[RESOURCE_IRON]) {
                                    text_draw("Production mothballed", map_center_x - 96, map_center_y + 38, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else {
                                    text_draw_number(calc_percentage(selected_building->data.industry.progress, 400), 0, "% done", map_center_x - 96, map_center_y + 38, FONT_NORMAL_BLACK);
                                }
                                play_speech_file("wavs/wheat_farm.wav");
                                break;
                            case BUILDING_VEGETABLE_FARM:
                                outer_panel_draw(map_center_x - 136, map_center_y - 64, 17, 8);
                                text_draw("Vegetable farm", map_center_x - 96, map_center_y - 52, FONT_LARGE_BLACK, COLOR_BLACK);
                                if (city_data.resource.mothballed[RESOURCE_IRON]) {
                                    text_draw("Production mothballed", map_center_x - 96, map_center_y + 38, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else {
                                    text_draw_number(calc_percentage(selected_building->data.industry.progress, 400), 0, "% done", map_center_x - 96, map_center_y + 38, FONT_NORMAL_BLACK);
                                }
                                play_speech_file("wavs/veg_farm.wav");
                                break;
                            case BUILDING_FRUIT_FARM:
                                outer_panel_draw(map_center_x - 104, map_center_y - 64, 13, 8);
                                text_draw("Fruit farm", map_center_x - 64, map_center_y - 52, FONT_LARGE_BLACK, COLOR_BLACK);
                                if (city_data.resource.mothballed[RESOURCE_IRON]) {
                                    text_draw("Production mothballed", map_center_x - 88, map_center_y + 38, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else {
                                    text_draw_number(calc_percentage(selected_building->data.industry.progress, 400), 0, "% done", map_center_x - 88, map_center_y + 38, FONT_NORMAL_BLACK);
                                }
                                play_speech_file("wavs/figs_farm.wav");
                                break;
                            case BUILDING_PIG_FARM:
                                outer_panel_draw(map_center_x - 96, map_center_y - 64, 12, 8);
                                text_draw("Pig farm", map_center_x - 56, map_center_y - 52, FONT_LARGE_BLACK, COLOR_BLACK);
                                if (city_data.resource.mothballed[RESOURCE_IRON]) {
                                    text_draw("Production mothballed", map_center_x - 80, map_center_y + 38, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else {
                                    text_draw_number(calc_percentage(selected_building->data.industry.progress, 400), 0, "% done", map_center_x - 80, map_center_y + 38, FONT_NORMAL_BLACK);
                                }
                                play_speech_file("wavs/meat_farm.wav");
                                break;
                            case BUILDING_OLIVE_FARM:
                                outer_panel_draw(map_center_x - 104, map_center_y - 64, 13, 8);
                                text_draw("Olive farm", map_center_x - 64, map_center_y - 52, FONT_LARGE_BLACK, COLOR_BLACK);
                                if (city_data.resource.mothballed[RESOURCE_IRON]) {
                                    text_draw("Production mothballed", map_center_x - 88, map_center_y + 38, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else {
                                    text_draw_number(calc_percentage(selected_building->data.industry.progress, 400), 0, "% done", map_center_x - 88, map_center_y + 38, FONT_NORMAL_BLACK);
                                }
                                play_speech_file("wavs/olives_farm.wav");
                                break;
                            case BUILDING_VINES_FARM:
                                outer_panel_draw(map_center_x - 112, map_center_y - 64, 14, 8);
                                text_draw("Vines farm", map_center_x - 72, map_center_y - 52, FONT_LARGE_BLACK, COLOR_BLACK);
                                if (city_data.resource.mothballed[RESOURCE_IRON]) {
                                    text_draw("Production mothballed", map_center_x - 96, map_center_y + 38, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else {
                                    text_draw_number(calc_percentage(selected_building->data.industry.progress, 400), 0, "% done", map_center_x - 96, map_center_y + 38, FONT_NORMAL_BLACK);
                                }
                                play_speech_file("wavs/vines_farm.wav");
                                break;
                            case BUILDING_CLAY_PIT:
                                outer_panel_draw(map_center_x - 88, map_center_y - 64, 11, 8);
                                text_draw("Clay pit", map_center_x - 48, map_center_y - 52, FONT_LARGE_BLACK, COLOR_BLACK);
                                if (city_data.resource.mothballed[RESOURCE_IRON]) {
                                    text_draw("Production mothballed", map_center_x - 72, map_center_y + 38, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else {
                                    text_draw_number(calc_percentage(selected_building->data.industry.progress, 400), 0, "% done", map_center_x - 72, map_center_y + 38, FONT_NORMAL_BLACK);
                                }
                                play_speech_file("wavs/clay_pit.wav");
                                break;
                            case BUILDING_TIMBER_YARD:
                                outer_panel_draw(map_center_x - 120, map_center_y - 64, 15, 8);
                                text_draw("Timber yard", map_center_x - 80, map_center_y - 52, FONT_LARGE_BLACK, COLOR_BLACK);
                                if (city_data.resource.mothballed[RESOURCE_IRON]) {
                                    text_draw("Production mothballed", map_center_x - 104, map_center_y + 38, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else {
                                    text_draw_number(calc_percentage(selected_building->data.industry.progress, 400), 0, "% done", map_center_x - 104, map_center_y + 38, FONT_NORMAL_BLACK);
                                }
                                play_speech_file("wavs/lumber_mill.wav");
                                break;
                            case BUILDING_MARBLE_QUARRY:
                                outer_panel_draw(map_center_x - 136, map_center_y - 64, 17, 8);
                                text_draw("Marble quarry", map_center_x - 96, map_center_y - 52, FONT_LARGE_BLACK, COLOR_BLACK);
                                if (city_data.resource.mothballed[RESOURCE_IRON]) {
                                    text_draw("Production mothballed", map_center_x - 120, map_center_y + 38, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else {
                                    text_draw_number(calc_percentage(selected_building->data.industry.progress, 400), 0, "% done", map_center_x - 120, map_center_y + 38, FONT_NORMAL_BLACK);
                                }
                                play_speech_file("wavs/quarry.wav");
                                break;
                            case BUILDING_IRON_MINE:
                                outer_panel_draw(map_center_x - 104, map_center_y - 64, 13, 8);
                                text_draw("Iron mine", map_center_x - 64, map_center_y - 52, FONT_LARGE_BLACK, COLOR_BLACK);
                                if (city_data.resource.mothballed[RESOURCE_IRON]) {
                                    text_draw("Production mothballed", map_center_x - 88, map_center_y + 38, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else {
                                    text_draw_number(calc_percentage(selected_building->data.industry.progress, 400), 0, "% done", map_center_x - 88, map_center_y + 38, FONT_NORMAL_BLACK);
                                }
                                play_speech_file("wavs/mine.wav");
                                break;
                            case BUILDING_OIL_WORKSHOP:
                                outer_panel_draw(map_center_x - 128, map_center_y - 80, 16, 10);
                                text_draw("Oil workshop", map_center_x - 88, map_center_y - 68, FONT_LARGE_BLACK, COLOR_BLACK);
                                width = text_draw_number(selected_building->loads_stored, 0, 0, map_center_x - 112, map_center_y + 28, FONT_NORMAL_BLACK);
                                image_draw(resource_images[RESOURCE_OLIVES].icon_img_id, map_center_x - 112 + width, map_center_y + 24);
                                text_draw("stored", map_center_x - 85 + width, map_center_y + 28, FONT_NORMAL_BLACK, COLOR_BLACK);
                                if (city_data.resource.mothballed[RESOURCE_OIL]) {
                                    text_draw("Production mothballed", map_center_x - 112, map_center_y + 52, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else {
                                    text_draw_number(calc_percentage(selected_building->data.industry.progress, 400), 0, "% done", map_center_x - 112, map_center_y + 52, FONT_NORMAL_BLACK);
                                }
                                play_speech_file("wavs/oil_workshop.wav");
                                break;
                            case BUILDING_WINE_WORKSHOP:
                                outer_panel_draw(map_center_x - 144, map_center_y - 80, 18, 10);
                                text_draw("Wine workshop", map_center_x - 104, map_center_y - 68, FONT_LARGE_BLACK, COLOR_BLACK);
                                width = text_draw_number(selected_building->loads_stored, 0, 0, map_center_x - 128, map_center_y + 28, FONT_NORMAL_BLACK);
                                image_draw(resource_images[RESOURCE_VINES].icon_img_id, map_center_x - 128 + width, map_center_y + 24);
                                text_draw("stored", map_center_x - 97 + width, map_center_y + 28, FONT_NORMAL_BLACK, COLOR_BLACK);
                                if (city_data.resource.mothballed[RESOURCE_WINE]) {
                                    text_draw("Production mothballed", map_center_x - 128, map_center_y + 52, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else {
                                    text_draw_number(calc_percentage(selected_building->data.industry.progress, 400), 0, "% done", map_center_x - 128, map_center_y + 52, FONT_NORMAL_BLACK);
                                }
                                play_speech_file("wavs/wine_workshop.wav");
                                break;
                            case BUILDING_POTTERY_WORKSHOP:
                                outer_panel_draw(map_center_x - 152, map_center_y - 80, 19, 10);
                                text_draw("Pottery workshop", map_center_x - 112, map_center_y - 68, FONT_LARGE_BLACK, COLOR_BLACK);
                                width = text_draw_number(selected_building->loads_stored, 0, 0, map_center_x - 136, map_center_y + 28, FONT_NORMAL_BLACK);
                                image_draw(resource_images[RESOURCE_CLAY].icon_img_id, map_center_x - 136 + width, map_center_y + 24);
                                text_draw("stored", map_center_x - 105 + width, map_center_y + 28, FONT_NORMAL_BLACK, COLOR_BLACK);
                                if (city_data.resource.mothballed[RESOURCE_POTTERY]) {
                                    text_draw("Production mothballed", map_center_x - 136, map_center_y + 52, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else {
                                    text_draw_number(calc_percentage(selected_building->data.industry.progress, 400), 0, "% done", map_center_x - 136, map_center_y + 52, FONT_NORMAL_BLACK);
                                }
                                play_speech_file("wavs/pottery_workshop.wav");
                                break;
                            case BUILDING_FURNITURE_WORKSHOP:
                                outer_panel_draw(map_center_x - 168, map_center_y - 80, 21, 10);
                                text_draw("Furniture workshop", map_center_x - 128, map_center_y - 68, FONT_LARGE_BLACK, COLOR_BLACK);
                                int width = text_draw_number(selected_building->loads_stored, 0, 0, map_center_x - 152, map_center_y + 28, FONT_NORMAL_BLACK);
                                image_draw(resource_images[RESOURCE_TIMBER].icon_img_id, map_center_x - 152 + width, map_center_y + 24);
                                text_draw("stored", map_center_x - 122 + width, map_center_y + 28, FONT_NORMAL_BLACK, COLOR_BLACK);
                                if (city_data.resource.mothballed[RESOURCE_FURNITURE]) {
                                    text_draw("Production mothballed", map_center_x - 152, map_center_y + 52, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else {
                                    text_draw_number(calc_percentage(selected_building->data.industry.progress, 400), 0, "% done", map_center_x - 152, map_center_y + 52, FONT_NORMAL_BLACK);
                                }
                                play_speech_file("wavs/furniture_workshop.wav");
                                break;
                            case BUILDING_WEAPONS_WORKSHOP:
                                outer_panel_draw(map_center_x - 160, map_center_y - 80, 20, 10);
                                text_draw("Weapons workshop", map_center_x - 120, map_center_y - 68, FONT_LARGE_BLACK, COLOR_BLACK);
                                width = text_draw_number(selected_building->loads_stored, 0, 0, map_center_x - 144, map_center_y + 28, FONT_NORMAL_BLACK);
                                image_draw(resource_images[RESOURCE_IRON].icon_img_id, map_center_x - 144 + width, map_center_y + 24);
                                text_draw("stored", map_center_x - 113 + width, map_center_y + 28, FONT_NORMAL_BLACK, COLOR_BLACK);
                                if (city_data.resource.mothballed[RESOURCE_WEAPONS]) {
                                    text_draw("Production mothballed", map_center_x - 144, map_center_y + 52, FONT_NORMAL_BLACK, COLOR_BLACK);
                                } else {
                                    text_draw_number(calc_percentage(selected_building->data.industry.progress, 400), 0, "% done", map_center_x - 144, map_center_y + 52, FONT_NORMAL_BLACK);
                                }
                                play_speech_file("wavs/weapons_workshop.wav");
                                break;
                            case BUILDING_MARKET:
                                outer_panel_draw(map_center_x - 168, map_center_y - 88, 21, 11);
                                text_draw("Market", map_center_x - 128, map_center_y - 76, FONT_LARGE_BLACK, COLOR_BLACK);
                                for (int i = 1; i < 5; i++) {
                                    image_draw(resource_images[i].icon_img_id, map_center_x - 152 + 80 * (i - 1), map_center_y + 16);
                                    text_draw_number(building_warehouse_get_amount(&all_buildings[selected_building->id], i), 0, 0, map_center_x - 122 + 80 * (i - 1), map_center_y + 20, FONT_NORMAL_BLACK);
                                }
                                for (int i = 1; i < 5; i++) {
                                    image_draw(resource_images[i + 10].icon_img_id, map_center_x - 152 + 80 * (i - 1), map_center_y + 48);
                                    text_draw_number(building_warehouse_get_amount(&all_buildings[selected_building->id], i + 10), 0, 0, map_center_x - 122 + 80 * (i - 1), map_center_y + 52, FONT_NORMAL_BLACK);
                                }
                                play_speech_file("wavs/market1.wav");
                                break;
                            case BUILDING_GRANARY:
                                outer_panel_draw(map_center_x - 168, map_center_y - 72, 21, 9);
                                text_draw("Granary", map_center_x - 128, map_center_y - 60, FONT_LARGE_BLACK, COLOR_BLACK);
                                text_draw_centered("Special orders", map_center_x - 8, map_center_y - 50, 160, FONT_NORMAL_BLACK, COLOR_BLACK);
                                for (int i = 1; i < 5; i++) {
                                    image_draw(resource_images[i].icon_img_id, map_center_x - 152 + 80 * (i - 1), map_center_y + 34);
                                    text_draw_number(building_warehouse_get_amount(&all_buildings[selected_building->id], i), 0, 0, map_center_x - 122 + 80 * (i - 1), map_center_y + 38, FONT_NORMAL_BLACK);
                                }
                                play_speech_file("wavs/granary.wav");
                                break;
                            case BUILDING_WAREHOUSE:
                                outer_panel_draw(map_center_x - 256, map_center_y - 144, 32, 18);
                                text_draw("Warehouse", map_center_x - 216, map_center_y - 132, FONT_LARGE_BLACK, COLOR_BLACK);
                                text_draw_centered("Special orders", map_center_x + 80, map_center_y - 122, 160, FONT_NORMAL_BLACK, COLOR_BLACK);
                                for (int i = 1; i < 6; i++) {
                                    image_draw(resource_images[i].icon_img_id, map_center_x - 240, map_center_y - 32 + 32 * (i - 1));
                                    int width = text_draw_number(building_warehouse_get_amount(&all_buildings[selected_building->id], i), 0, 0, map_center_x - 210, map_center_y - 28 + 32 * (i - 1), FONT_NORMAL_BLACK);
                                    text_draw(resource_strings[i], map_center_x - 210 + width, map_center_y - 28 + 32 * (i - 1), FONT_NORMAL_BLACK, COLOR_BLACK);
                                }
                                for (int i = 1; i < 6; i++) {
                                    image_draw(resource_images[i + 5].icon_img_id, map_center_x - 70, map_center_y - 32 + 32 * (i - 1));
                                    int width = text_draw_number(building_warehouse_get_amount(&all_buildings[selected_building->id], i + 5), 0, 0, map_center_x - 40, map_center_y - 28 + 32 * (i - 1), FONT_NORMAL_BLACK);
                                    text_draw(resource_strings[i + 5], map_center_x - 40 + width, map_center_y - 28 + 32 * (i - 1), FONT_NORMAL_BLACK, COLOR_BLACK);
                                }
                                for (int i = 1; i < 6; i++) {
                                    image_draw(resource_images[i + 10].icon_img_id, map_center_x + 100, map_center_y - 32 + 32 * (i - 1));
                                    int width = text_draw_number(building_warehouse_get_amount(&all_buildings[selected_building->id], i + 10), 0, 0, map_center_x + 130, map_center_y - 28 + 32 * (i - 1), FONT_NORMAL_BLACK);
                                    text_draw(resource_strings[i + 10], map_center_x + 130 + width, map_center_y - 28 + 32 * (i - 1), FONT_NORMAL_BLACK, COLOR_BLACK);
                                }
                                play_speech_file("wavs/warehouse.wav");
                                break;
                            case BUILDING_NATIVE_HUT:
                                outer_panel_draw(map_center_x - 88, map_center_y - 32, 11, 4);
                                text_draw_centered("Native hut", map_center_x - 88, map_center_y - 12, 176, FONT_LARGE_BLACK, COLOR_BLACK);
                                break;
                            case BUILDING_NATIVE_CROPS:
                                outer_panel_draw(map_center_x - 96, map_center_y - 32, 12, 4);
                                text_draw_centered("Native crops", map_center_x - 96, map_center_y - 12, 192, FONT_LARGE_BLACK, COLOR_BLACK);
                                break;
                            case BUILDING_NATIVE_MEETING:
                                outer_panel_draw(map_center_x - 160, map_center_y - 32, 20, 4);
                                text_draw_centered("Native meeting center", map_center_x - 160, map_center_y - 12, 320, FONT_LARGE_BLACK, COLOR_BLACK);
                                break;
                            case BUILDING_BURNING_RUIN:
                                outer_panel_draw(map_center_x - 104, map_center_y - 32, 13, 4);
                                text_draw_centered("Burning ruins", map_center_x - 104, map_center_y - 12, 208, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/burning_ruin.wav");
                                break;
                        }
                    } else {
                        switch (terrain_grid.items[widget_city_data.current_tile.grid_offset]) {
                            case TERRAIN_SHRUB:
                                outer_panel_draw(map_center_x - 56, map_center_y - 32, 7, 4);
                                text_draw_centered("Shrub", map_center_x - 56, map_center_y - 12, 112, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/empty_land.wav");
                                break;
                            case TERRAIN_ROCK:
                                outer_panel_draw(map_center_x - 56, map_center_y - 32, 7, 4);
                                text_draw_centered("Rock", map_center_x - 56, map_center_y - 12, 112, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/empty_land.wav");
                                break;
                            case TERRAIN_WATER:
                                outer_panel_draw(map_center_x - 56, map_center_y - 32, 7, 4);
                                text_draw_centered("Water", map_center_x - 56, map_center_y - 12, 112, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/empty_land.wav");
                                break;
                            case TERRAIN_TREE:
                                outer_panel_draw(map_center_x - 56, map_center_y - 32, 7, 4);
                                text_draw_centered("Tree", map_center_x - 56, map_center_y - 12, 112, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/empty_land.wav");
                                break;
                            case TERRAIN_GARDEN:
                                outer_panel_draw(map_center_x - 64, map_center_y - 32, 8, 4);
                                text_draw_centered("Garden", map_center_x - 64, map_center_y - 12, 128, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/gardens1.wav");
                                break;
                            case TERRAIN_ROAD:
                                outer_panel_draw(map_center_x - 56, map_center_y - 32, 7, 4);
                                text_draw_centered("Road", map_center_x - 56, map_center_y - 12, 112, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/empty_land.wav");
                                break;
                            case TERRAIN_AQUEDUCT:
                                outer_panel_draw(map_center_x - 72, map_center_y - 32, 9, 4);
                                text_draw_centered("Aqueduct", map_center_x - 72, map_center_y - 12, 144, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/aquaduct.wav");
                                break;
                            case TERRAIN_ELEVATION:
                                outer_panel_draw(map_center_x - 72, map_center_y - 32, 9, 4);
                                text_draw_centered("Elevation", map_center_x - 72, map_center_y - 12, 144, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/empty_land.wav");
                                break;
                            case TERRAIN_ACCESS_RAMP:
                                outer_panel_draw(map_center_x - 56, map_center_y - 32, 7, 4);
                                text_draw_centered("Ramp", map_center_x - 56, map_center_y - 12, 112, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/empty_land.wav");
                                break;
                            case TERRAIN_MEADOW:
                                outer_panel_draw(map_center_x - 64, map_center_y - 32, 8, 4);
                                text_draw_centered("Meadow", map_center_x - 64, map_center_y - 12, 128, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/empty_land.wav");
                                break;
                            case TERRAIN_RUBBLE:
                                outer_panel_draw(map_center_x - 64, map_center_y - 32, 8, 4);
                                text_draw_centered("Rubble", map_center_x - 64, map_center_y - 12, 128, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/burning_ruin.wav");
                                break;
                            case TERRAIN_WALL:
                                outer_panel_draw(map_center_x - 56, map_center_y - 32, 7, 4);
                                text_draw_centered("Wall", map_center_x - 56, map_center_y - 12, 112, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/empty_land.wav");
                                break;
                            default:
                                outer_panel_draw(map_center_x - 56, map_center_y - 32, 7, 4);
                                text_draw_centered("Land", map_center_x - 56, map_center_y - 12, 112, FONT_LARGE_BLACK, COLOR_BLACK);
                                play_speech_file("wavs/empty_land.wav");
                        }
                    }
                    refresh_current_window = 0;
                }
                if (selected_units_list[0]) {
                    switch (selected_units_list[selected_unit_index]->type) {
                        case FIGURE_FORT_STANDARD:
                        case FIGURE_FORT_JAVELIN:
                        case FIGURE_FORT_MOUNTED:
                        case FIGURE_FORT_LEGIONARY:
                            if (legion_formations[selected_units_list[selected_unit_index]->formation_id].num_figures) {
                                struct formation_t *m = &legion_formations[selected_units_list[selected_unit_index]->formation_id];
                                for (int i = 0; i < 5; i++) {
                                    if (selected_units_list[selected_unit_index]->type == FIGURE_FORT_LEGIONARY) {
                                        if ((i == 0 && !m->has_military_training) || i == 1) {
                                            continue;
                                        }
                                    }
                                    if (mouse_x >= map_center_x - 212 + 85 * i && mouse_x < map_center_x - 128 + 85 * i && mouse_y >= map_center_y - 2 && mouse_y < map_center_y + 82) {
                                        button_border_draw(map_center_x - 212 + 85 * i, map_center_y - 2, 84, 84, 1);
                                    } else {
                                        button_border_draw(map_center_x - 212 + 85 * i, map_center_y - 2, 84, 84, 0);
                                    }
                                }
                                if (!m->in_distant_battle && !m->is_at_rest) { // return to fort button
                                    if (mouse_x >= map_center_x - 120 && mouse_x < map_center_x + 120 && mouse_y >= map_center_y + 90 && mouse_y < map_center_y + 120) {
                                        button_border_draw(map_center_x - 120, map_center_y + 90, 240, 30, 1);
                                    } else {
                                        button_border_draw(map_center_x - 120, map_center_y + 90, 240, 30, 0);
                                    }
                                }
                            }
                            break;
                    }
                } else if (selected_building) {
                    switch (selected_building->type) {
                        case BUILDING_DOCTOR:
                            draw_image_button(1168, map_center_x - 112, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(13, map_center_y - 8);
                            break;
                        case BUILDING_BATHHOUSE:
                            draw_image_button(1168, map_center_x - 96, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(11, map_center_y - 8);
                            break;
                        case BUILDING_BARBER:
                            draw_image_button(1168, map_center_x - 72, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(8, map_center_y - 8);
                            break;
                        case BUILDING_HOSPITAL:
                            draw_image_button(1168, map_center_x - 80, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(9, map_center_y - 8);
                            break;
                        case BUILDING_SMALL_TEMPLE_CERES:
                        case BUILDING_LARGE_TEMPLE_CERES:
                            draw_image_button(1177, map_center_x - 128, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(15, map_center_y - 8);
                            break;
                        case BUILDING_SMALL_TEMPLE_NEPTUNE:
                        case BUILDING_LARGE_TEMPLE_NEPTUNE:
                            draw_image_button(1177, map_center_x - 152, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(18, map_center_y - 8);
                            break;
                        case BUILDING_SMALL_TEMPLE_MERCURY:
                        case BUILDING_LARGE_TEMPLE_MERCURY:
                            draw_image_button(1177, map_center_x - 152, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(18, map_center_y - 8);
                            break;
                        case BUILDING_SMALL_TEMPLE_MARS:
                        case BUILDING_LARGE_TEMPLE_MARS:
                            draw_image_button(1177, map_center_x - 128, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(15, map_center_y - 8);
                            break;
                        case BUILDING_SMALL_TEMPLE_VENUS:
                        case BUILDING_LARGE_TEMPLE_VENUS:
                            draw_image_button(1177, map_center_x - 136, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(16, map_center_y - 8);
                            break;
                        case BUILDING_SCHOOL:
                            draw_image_button(1171, map_center_x - 72, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(8, map_center_y - 8);
                            break;
                        case BUILDING_LIBRARY:
                            draw_image_button(1171, map_center_x - 80, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(9, map_center_y - 8);
                            break;
                        case BUILDING_ACADEMY:
                            draw_image_button(1171, map_center_x - 80, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(9, map_center_y - 8);
                            break;
                        case BUILDING_MISSION_POST:
                            draw_image_button(1171, map_center_x - 104, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(12, map_center_y - 8);
                            break;
                        case BUILDING_THEATER:
                            draw_image_button(1174, map_center_x - 72, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(8, map_center_y - 8);
                            break;
                        case BUILDING_ACTOR_COLONY:
                            draw_image_button(1174, map_center_x - 104, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(12, map_center_y - 8);
                            break;
                        case BUILDING_AMPHITHEATER:
                            draw_image_button(1174, map_center_x - 112, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(13, map_center_y - 8);
                            break;
                        case BUILDING_GLADIATOR_SCHOOL:
                            draw_image_button(1174, map_center_x - 128, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(15, map_center_y - 8);
                            break;
                        case BUILDING_LION_HOUSE:
                            draw_image_button(1174, map_center_x - 96, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(11, map_center_y - 8);
                            break;
                        case BUILDING_COLOSSEUM:
                            draw_image_button(1174, map_center_x - 96, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(11, map_center_y - 8);
                            break;
                        case BUILDING_CHARIOT_MAKER:
                            draw_image_button(1174, map_center_x - 112, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(13, map_center_y - 8);
                            break;
                        case BUILDING_HIPPODROME:
                            draw_image_button(1174, map_center_x - 104, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(12, map_center_y - 8);
                            break;
                        case BUILDING_FORUM:
                            draw_image_button(1180, map_center_x - 80, map_center_y - 56, 28, 28, 1);
                            draw_context_employment_info(9, map_center_y - 16);
                            break;
                        case BUILDING_SENATE:
                            draw_image_button(1159, map_center_x - 80, map_center_y - 56, 28, 28, 1);
                            draw_context_employment_info(9, map_center_y - 16);
                            break;
                        case BUILDING_ENGINEERS_POST:
                            draw_context_employment_info(13, map_center_y - 8);
                            break;
                        case BUILDING_SHIPYARD:
                            image_draw(1203, map_center_x + 61, map_center_y - 48);
                            draw_context_employment_info(10, map_center_y - 8);
                            break;
                        case BUILDING_WHARF:
                            image_draw(1203, map_center_x + 45, map_center_y - 48);
                            draw_context_employment_info(8, map_center_y - 8);
                            break;
                        case BUILDING_DOCK:
                            draw_image_button(1162, map_center_x - 80, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(8, map_center_y - 8);
                            break;
                        case BUILDING_PREFECTURE:
                            draw_context_employment_info(10, map_center_y - 8);
                            break;
                        case BUILDING_TOWER:
                            draw_context_employment_info(8, map_center_y - 8);
                            break;
                        case BUILDING_FORT_LEGIONARIES:
                            draw_image_button(1153, map_center_x - 128, map_center_y - 24, 28, 28, 1);
                            break;
                        case BUILDING_FORT_JAVELIN:
                            draw_image_button(1153, map_center_x - 120, map_center_y - 24, 28, 28, 1);
                            break;
                        case BUILDING_FORT_MOUNTED:
                            draw_image_button(1153, map_center_x - 120, map_center_y - 24, 28, 28, 1);
                            break;
                        case BUILDING_BARRACKS:
                            draw_image_button(1153, map_center_x - 80, map_center_y - 56, 28, 28, 1);
                            draw_context_employment_info(9, map_center_y - 16);
                            break;
                        case BUILDING_MILITARY_ACADEMY:
                            draw_image_button(1153, map_center_x - 136, map_center_y - 48, 28, 28, 1);
                            draw_context_employment_info(16, map_center_y - 8);
                            break;
                        case BUILDING_WHEAT_FARM:
                            draw_image_button(1162, map_center_x - 104, map_center_y - 56, 28, 28, 1);
                            image_draw(1187, map_center_x + 78, map_center_y - 56);
                            draw_context_employment_info(12, map_center_y - 16);
                            break;
                        case BUILDING_VEGETABLE_FARM:
                            draw_image_button(1162, map_center_x - 128, map_center_y - 56, 28, 28, 1);
                            image_draw(1188, map_center_x + 102, map_center_y - 56);
                            draw_context_employment_info(15, map_center_y - 16);
                            break;
                        case BUILDING_FRUIT_FARM:
                            draw_image_button(1162, map_center_x - 96, map_center_y - 56, 28, 28, 1);
                            image_draw(1189, map_center_x + 73, map_center_y - 56);
                            draw_context_employment_info(11, map_center_y - 16);
                            break;
                        case BUILDING_PIG_FARM:
                            draw_image_button(1162, map_center_x - 88, map_center_y - 56, 28, 28, 1);
                            image_draw(1192, map_center_x + 65, map_center_y - 56);
                            draw_context_employment_info(10, map_center_y - 16);
                            break;
                        case BUILDING_OLIVE_FARM:
                            draw_image_button(1162, map_center_x - 96, map_center_y - 56, 28, 28, 1);
                            image_draw(1190, map_center_x + 73, map_center_y - 56);
                            draw_context_employment_info(11, map_center_y - 16);
                            break;
                        case BUILDING_VINES_FARM:
                            draw_image_button(1162, map_center_x - 104, map_center_y - 56, 28, 28, 1);
                            image_draw(1191, map_center_x + 77, map_center_y - 56);
                            draw_context_employment_info(12, map_center_y - 16);
                            break;
                        case BUILDING_CLAY_PIT:
                            draw_image_button(1162, map_center_x - 80, map_center_y - 56, 28, 28, 1);
                            image_draw(1197, map_center_x + 53, map_center_y - 56);
                            draw_context_employment_info(9, map_center_y - 16);
                            break;
                        case BUILDING_TIMBER_YARD:
                            draw_image_button(1162, map_center_x - 112, map_center_y - 56, 28, 28, 1);
                            image_draw(1196, map_center_x + 86, map_center_y - 56);
                            draw_context_employment_info(13, map_center_y - 16);
                            break;
                        case BUILDING_MARBLE_QUARRY:
                            draw_image_button(1162, map_center_x - 128, map_center_y - 56, 28, 28, 1);
                            image_draw(1198, map_center_x + 104, map_center_y - 56);
                            draw_context_employment_info(15, map_center_y - 16);
                            break;
                        case BUILDING_IRON_MINE:
                            draw_image_button(1162, map_center_x - 96, map_center_y - 56, 28, 28, 1);
                            image_draw(1195, map_center_x + 69, map_center_y - 56);
                            draw_context_employment_info(11, map_center_y - 16);
                            break;
                        case BUILDING_OIL_WORKSHOP:
                            draw_image_button(1162, map_center_x - 120, map_center_y - 72, 28, 28, 1);
                            image_draw(1194, map_center_x + 97, map_center_y - 72);
                            draw_context_employment_info(14, map_center_y - 32);
                            break;
                        case BUILDING_WINE_WORKSHOP:
                            draw_image_button(1162, map_center_x - 136, map_center_y - 72, 28, 28, 1);
                            image_draw(1193, map_center_x + 108, map_center_y - 72);
                            draw_context_employment_info(16, map_center_y - 32);
                            break;
                        case BUILDING_POTTERY_WORKSHOP:
                            draw_image_button(1162, map_center_x - 144, map_center_y - 72, 28, 28, 1);
                            image_draw(1201, map_center_x + 123, map_center_y - 72);
                            draw_context_employment_info(17, map_center_y - 32);
                            break;
                        case BUILDING_FURNITURE_WORKSHOP:
                            draw_image_button(1162, map_center_x - 160, map_center_y - 72, 28, 28, 1);
                            image_draw(1200, map_center_x + 143, map_center_y - 72);
                            draw_context_employment_info(19, map_center_y - 32);
                            break;
                        case BUILDING_WEAPONS_WORKSHOP:
                            draw_image_button(1162, map_center_x - 152, map_center_y - 72, 28, 28, 1);
                            image_draw(1199, map_center_x + 134, map_center_y - 72);
                            draw_context_employment_info(18, map_center_y - 32);
                            break;
                        case BUILDING_MARKET:
                            draw_image_button(1162, map_center_x - 160, map_center_y - 80, 28, 28, 1);
                            draw_context_employment_info(19, map_center_y - 40);
                            break;
                        case BUILDING_GRANARY:
                            draw_image_button(1162, map_center_x - 160, map_center_y - 64, 28, 28, 1);
                            if (mouse_x >= map_center_x - 8 && mouse_x < map_center_x + 152 && mouse_y >= map_center_y - 57 && mouse_y < map_center_y - 32) {
                                button_border_draw(map_center_x - 8, map_center_y - 57, 160, 25, 1);
                            } else {
                                button_border_draw(map_center_x - 8, map_center_y - 57, 160, 25, 0);
                            }
                            draw_context_employment_info(19, map_center_y - 24);
                            break;
                        case BUILDING_WAREHOUSE:
                            draw_image_button(1162, map_center_x - 248, map_center_y - 136, 28, 28, 1);
                            if (mouse_x >= map_center_x + 80 && mouse_x < map_center_x + 240 && mouse_y >= map_center_y - 129 && mouse_y < map_center_y - 104) {
                                button_border_draw(map_center_x + 80, map_center_y - 129, 160, 25, 1);
                            } else {
                                button_border_draw(map_center_x + 80, map_center_y - 129, 160, 25, 0);
                            }
                            draw_context_employment_info(30, map_center_y - 96);
                            break;
                    }
                }
                break;
            case WINDOW_GRANARY_ORDERS:
                if (refresh_current_window) {
                    draw_foreground_city();
                    outer_panel_draw(map_center_x - 208, map_center_y - 160, 26, 14);
                    text_draw_centered("Granary instructions", map_center_x - 208, map_center_y - 140, 416, FONT_LARGE_BLACK, COLOR_BLACK);
                    inner_panel_draw(map_center_x - 192, map_center_y - 100, 24, 8);
                    for (int i = 1; i < 5; i++) {
                        image_draw(resource_images[i].icon_img_id, map_center_x - 182, map_center_y - 88 + 27 * (i - 1));
                        image_draw(resource_images[i].icon_img_id, map_center_x + 160, map_center_y - 88 + 27 * (i - 1));
                        text_draw(resource_strings[i], map_center_x - 150, map_center_y - 84 + 27 * (i - 1), FONT_NORMAL_PLAIN, COLOR_BLACK);
                        struct building_storage_t *storage = &storages[selected_building->storage_id].storage;
                        if (storage->resource_state[i] == BUILDING_STORAGE_STATE_ACCEPTING) {
                            text_draw_centered("Accepting", map_center_x - 52, map_center_y - 84 + 27 * (i - 1), 192, FONT_NORMAL_WHITE, COLOR_BLACK);
                        } else if (storage->resource_state[i] == BUILDING_STORAGE_STATE_GETTING) {
                            image_draw(1410, map_center_x - 44, map_center_y - 87 + 27 * (i - 1));
                            text_draw_centered("Getting goods", map_center_x - 52, map_center_y - 84 + 27 * (i - 1), 192, FONT_NORMAL_WHITE, COLOR_BLACK);
                        } else if (storage->resource_state[i] == BUILDING_STORAGE_STATE_NOT_ACCEPTING) {
                            text_draw_centered("Not accepting", map_center_x - 52, map_center_y - 84 + 27 * (i - 1), 192, FONT_NORMAL_RED, COLOR_BLACK);
                        }
                        text_draw_centered(storage->empty_all ? "STOP emptying granary" : "START emptying granary", map_center_x - 120, map_center_y + 36, 240, FONT_NORMAL_BLACK, COLOR_BLACK);
                        text_draw("x", map_center_x + 165, map_center_y + 33, FONT_NORMAL_BLACK, COLOR_BLACK);
                    }
                    refresh_current_window = 0;
                }
                for (int i = 1; i < 5; i++) {
                    if (mouse_x >= map_center_x - 52 && mouse_x < map_center_x + 140 && mouse_y >= map_center_y - 91 + 27 * (i - 1) && mouse_y < map_center_y - 66 + 27 * (i - 1)) {
                        button_border_draw(map_center_x - 52, map_center_y - 91 + 27 * (i - 1), 192, 25, 1);
                    } else {
                        button_border_draw(map_center_x - 52, map_center_y - 91 + 27 * (i - 1), 192, 25, 0);
                    }
                    if (mouse_x >= map_center_x - 120 && mouse_x < map_center_x + 120 && mouse_y >= map_center_y + 30 && mouse_y < map_center_y + 52) {
                        button_border_draw(map_center_x - 120, map_center_y + 30, 240, 22, 1);
                    } else {
                        button_border_draw(map_center_x - 120, map_center_y + 30, 240, 22, 0);
                    }
                    if (mouse_x >= map_center_x + 159 && mouse_x < map_center_x + 179 && mouse_y >= map_center_y + 30 && mouse_y < map_center_y + 50) {
                        button_border_draw(map_center_x + 159, map_center_y + 30, 20, 20, 1);
                    } else {
                        button_border_draw(map_center_x + 159, map_center_y + 30, 20, 20, 0);
                    }
                }
                break;
            case WINDOW_WAREHOUSE_ORDERS:
                if (refresh_current_window) {
                    draw_foreground_city();
                    outer_panel_draw(map_center_x - 208, map_center_y - 272, 26, 34);
                    text_draw_centered("Warehouse instructions", map_center_x - 208, map_center_y - 252, 416, FONT_LARGE_BLACK, COLOR_BLACK);
                    inner_panel_draw(map_center_x - 192, map_center_y - 212, 24, 26);
                    for (int i = 1; i < RESOURCE_TYPES_MAX; i++) {
                        image_draw(resource_images[i].icon_img_id, map_center_x - 182, map_center_y - 204 + 27 * (i - 1));
                        image_draw(resource_images[i].icon_img_id, map_center_x + 160, map_center_y - 204 + 27 * (i - 1));
                        text_draw(resource_strings[i], map_center_x - 150, map_center_y - 200 + 27 * (i - 1), FONT_NORMAL_PLAIN, COLOR_BLACK);
                        struct building_storage_t *storage = &storages[selected_building->storage_id].storage;
                        if (storage->resource_state[i] == BUILDING_STORAGE_STATE_ACCEPTING) {
                            text_draw_centered("Accepting", map_center_x - 52, map_center_y - 200 + 27 * (i - 1), 192, FONT_NORMAL_WHITE, COLOR_BLACK);
                        } else if (storage->resource_state[i] == BUILDING_STORAGE_STATE_GETTING) {
                            image_draw(1410, map_center_x - 44, map_center_y - 203 + 27 * (i - 1));
                            text_draw_centered("Getting goods", map_center_x - 52, map_center_y - 200 + 27 * (i - 1), 192, FONT_NORMAL_WHITE, COLOR_BLACK);
                        } else if (storage->resource_state[i] == BUILDING_STORAGE_STATE_NOT_ACCEPTING) {
                            text_draw_centered("Not accepting", map_center_x - 52, map_center_y - 200 + 27 * (i - 1), 192, FONT_NORMAL_RED, COLOR_BLACK);
                        }
                        text_draw_centered(selected_building->id == city_data.building.trade_center_building_id ? "Trade center" : "Become the trade center", map_center_x - 120, map_center_y + 214, 240, FONT_NORMAL_BLACK, COLOR_BLACK);
                        text_draw_centered(storage->empty_all ? "STOP emptying warehouse" : "START emptying warehouse", map_center_x - 120, map_center_y + 240, 240, FONT_NORMAL_BLACK, COLOR_BLACK);
                        text_draw("x", map_center_x + 164, map_center_y + 211, FONT_NORMAL_BLACK, COLOR_BLACK);
                    }
                    refresh_current_window = 0;
                }
                for (int i = 1; i < RESOURCE_TYPES_MAX; i++) {
                    if (mouse_x >= map_center_x - 52 && mouse_x < map_center_x + 140 && mouse_y >= map_center_y - 207 + 27 * (i - 1) && mouse_y < map_center_y - 182 + 27 * (i - 1)) {
                        button_border_draw(map_center_x - 52, map_center_y - 207 + 27 * (i - 1), 192, 25, 1);
                    } else {
                        button_border_draw(map_center_x - 52, map_center_y - 207 + 27 * (i - 1), 192, 25, 0);
                    }
                }
                if (mouse_x >= map_center_x - 120 && mouse_x < map_center_x + 120 && mouse_y >= map_center_y + 208 && mouse_y < map_center_y + 230) {
                    button_border_draw(map_center_x - 120, map_center_y + 208, 240, 22, 1);
                } else {
                    button_border_draw(map_center_x - 120, map_center_y + 208, 240, 22, 0);
                }
                if (mouse_x >= map_center_x - 120 && mouse_x < map_center_x + 120 && mouse_y >= map_center_y + 234 && mouse_y < map_center_y + 256) {
                    button_border_draw(map_center_x - 120, map_center_y + 234, 240, 22, 1);
                } else {
                    button_border_draw(map_center_x - 120, map_center_y + 234, 240, 22, 0);
                }
                if (mouse_x >= map_center_x + 158 && mouse_x < map_center_x + 178 && mouse_y >= map_center_y + 208 && mouse_y < map_center_y + 228) {
                    button_border_draw(map_center_x + 158, map_center_y + 208, 20, 20, 1);
                } else {
                    button_border_draw(map_center_x + 158, map_center_y + 208, 20, 20, 0);
                }
                break;
            case WINDOW_VICTORY_DIALOG:
                if (refresh_current_window) {
                    outer_panel_draw(map_center_x - 80, map_center_y - 64, 10, 8);
                    text_draw_centered("Victory!", map_center_x - 80, map_center_y - 44, 160, FONT_LARGE_BLACK, COLOR_BLACK);
                    refresh_current_window = 0;
                }
                for (int i = 0; i < 2; i++) {
                    draw_label(map_center_x - 64, map_center_y - 4 + 30 * i, 128, 1, 1);
                }
                text_draw_centered("Continue", map_center_x - 64, map_center_y + 2, 128, FONT_NORMAL_GREEN, COLOR_BLACK);
                text_draw_centered("Retire", map_center_x - 64, map_center_y + 32, 128, FONT_NORMAL_GREEN, COLOR_BLACK);
                break;
            case WINDOW_VICTORY_VIDEO:
                if (refresh_current_window) {
                    memset(canvas.pixels, 0, sizeof(uint32_t) * canvas.width * canvas.height);
                    refresh_current_window = 0;
                }
                video_draw_fullscreen();
                if (current_intro_video == 3 && data_video.is_ended) {
                    change_window(0);
                }
                break;
            case WINDOW_VICTORY_SUMMARY:
                if (refresh_current_window) {
                    image_draw_scaled(MAIN_MENU_BACKGROUND_IMG_ID, 0, 0, current_resolution_width, current_resolution_height);
                    outer_panel_draw(screen_center_x - 272, screen_center_y - 136, 34, 11);
                    text_draw_centered("Victory!", screen_center_x - 272, screen_center_y - 116, 544, FONT_LARGE_BLACK, COLOR_BLACK);
                    inner_panel_draw(screen_center_x - 256, screen_center_y - 76, 32, 6);
                    int width = text_draw("Final Culture rating:", screen_center_x - 240, screen_center_y - 60, FONT_NORMAL_PLAIN, COLOR_BLACK);
                    text_draw_number(city_data.ratings.culture, 0, 0, screen_center_x - 240 + width, screen_center_y - 60, FONT_NORMAL_PLAIN);
                    width = text_draw("Final Prosperity rating:", screen_center_x - 240, screen_center_y - 35, FONT_NORMAL_PLAIN, COLOR_BLACK);
                    text_draw_number(city_data.ratings.prosperity, 0, 0, screen_center_x - 240 + width, screen_center_y - 35, FONT_NORMAL_PLAIN);
                    width = text_draw("Final Peace rating:", screen_center_x - 240, screen_center_y - 10, FONT_NORMAL_PLAIN, COLOR_BLACK);
                    text_draw_number(city_data.ratings.peace, 0, 0, screen_center_x - 240 + width, screen_center_y - 10, FONT_NORMAL_PLAIN);
                    width = text_draw("Final Imperial Favor:", screen_center_x + 16, screen_center_y - 60, FONT_NORMAL_PLAIN, COLOR_BLACK);
                    text_draw_number(city_data.ratings.favor, 0, 0, screen_center_x + 16 + width, screen_center_y - 60, FONT_NORMAL_PLAIN);
                    width = text_draw("Final population:", screen_center_x + 16, screen_center_y - 35, FONT_NORMAL_PLAIN, COLOR_BLACK);
                    text_draw_number(city_data.population.population, 0, 0, screen_center_x + 16 + width, screen_center_y - 35, FONT_NORMAL_PLAIN);
                    width = text_draw("Final city funds:", screen_center_x + 16, screen_center_y - 10, FONT_NORMAL_PLAIN, COLOR_BLACK);
                    text_draw_number(city_data.finance.treasury, 0, 0, screen_center_x + 16 + width, screen_center_y - 10, FONT_NORMAL_PLAIN);
                    play_speech_file(SOUND_FILE_WIN);
                    refresh_current_window = 0;
                }
                break;
            case WINDOW_DEFEAT_SUMMARY:
                if (refresh_current_window) {
                    stop_music();
                    image_draw_scaled(9011, 0, 0, current_resolution_width, current_resolution_height);
                    play_speech_file(SOUND_FILE_LOSE);
                    outer_panel_draw(screen_center_x - 208, screen_center_y - 368, 34, 11);
                    text_draw_centered("Fired!", screen_center_x - 208, screen_center_y - 348, 544, FONT_LARGE_BLACK, COLOR_BLACK);
                    text_draw_multiline("I am most displeased. Despite all the funds I invested in your city, and the Senate's generosity with credit, you have let me down. Your city has not honored Rome. My faith in you was misplaced, and I am forced to find another governor to take your place. Perhaps you will fare better in the new role I have in mind for you...  -The Emperor", screen_center_x - 184, screen_center_y - 308, 496, FONT_NORMAL_BLACK, COLOR_BLACK);
                    game_lost = 0;
                    refresh_current_window = 0;
                }
                break;
            case WINDOW_EDITOR_NOT_FOUND:
                if (refresh_current_window) {
                    outer_panel_draw(screen_center_x - 240, screen_center_y - 64, 30, 8);
                    text_draw_centered("Editor not installed", screen_center_x - 240, screen_center_y - 44, 480, FONT_LARGE_BLACK, 0);
                    text_draw_multiline(
                        "Your Caesar 3 installation does not contain the editor files. You can download them from:\nhttps://github.com/bvschaik/julius/wiki/Editor",
                        screen_center_x - 220,
                        screen_center_y,
                        450,
                        FONT_NORMAL_BLACK,
                        COLOR_BLACK);
                    refresh_current_window = 0;
                }
                break;
            case WINDOW_EDITOR_MAP:
                if (refresh_current_window) {
                    draw_top_menu_bar();
                    image_draw(3102, sidebar_x_offset, TOP_BAR_HEIGHT); // side panel
                    // draw status
                    inner_panel_draw(sidebar_x_offset + 1, 175, 10, 7);
                    char *editor_sidebar_menu_label_strings[] = {
                        "",
                        "Grass",
                        "Small shrub",
                        "Medium shrub",
                        "Large shrub",
                        "Largest shrub",
                        "Water",
                        "Raise land",
                        "Lower land",
                        "Access ramp",
                        "Trees",
                        "Small rock",
                        "Medium rock",
                        "Large rock",
                        "Meadow",
                        "Road",
                        "Earthquake",
                        "Invasion point",
                        "Entry point",
                        "Exit point",
                        "River IN",
                        "River OUT",
                        "Native hut",
                        "Native field",
                        "Native center",
                        "Vacant lot",
                        "Fishing waters",
                        "Herd point",
                    };
                    text_draw(editor_sidebar_menu_label_strings[tool_data.type], sidebar_x_offset + 6, 178, FONT_NORMAL_WHITE, COLOR_BLACK);
                    char *editor_tool_size_strings[] = {
                        "Tiny brush",
                        "Small brush",
                        "Medium brush",
                        "Big brush",
                        "Biggest brush",
                    };
                    switch (tool_data.type) {
                        case TOOL_GRASS:
                        case TOOL_SMALL_SHRUB:
                        case TOOL_MEDIUM_SHRUB:
                        case TOOL_LARGE_SHRUB:
                        case TOOL_LARGEST_SHRUB:
                        case TOOL_WATER:
                        case TOOL_TREES:
                        case TOOL_SMALL_ROCK:
                        case TOOL_MEDIUM_ROCK:
                        case TOOL_LARGE_ROCK:
                        case TOOL_MEADOW:
                            text_draw(editor_tool_size_strings[tool_data.brush_size], sidebar_x_offset + 6, 194, FONT_NORMAL_GREEN, COLOR_BLACK);
                            break;
                    }
                    if (scenario.entry_point.x == -1) {
                        text_draw("Entry point not set", sidebar_x_offset + 6, 224, FONT_NORMAL_RED, COLOR_BLACK);
                    } else if (scenario.exit_point.x == -1) {
                        text_draw("Exit point not set", sidebar_x_offset + 6, 224, FONT_NORMAL_RED, COLOR_BLACK);
                    }
                    int invasion_points = 0;
                    for (int i = 0; i < MAX_INVASION_POINTS; i++) {
                        if (scenario.invasion_points[i].x != -1) {
                            invasion_points++;
                        }
                    }
                    if (invasion_points) {
                        text_draw_number(invasion_points, 0, " Invasion points", sidebar_x_offset + 4, 254, FONT_NORMAL_GREEN);
                    } else {
                        if (scenario.invasions[0].type) {
                            text_draw("No invasion points", sidebar_x_offset + 6, 254, FONT_NORMAL_RED, COLOR_BLACK);
                        }
                    }
                    draw_sidebar_ornaments(474);
                    refresh_current_window = 0;
                }
                scroll_map();
                draw_editor_map();
                switch (editor_build_menu_selected) {
                    case MENU_SHRUB:
                    case MENU_NATIVE_BUILDINGS:
                        for (int i = 0; i < 4; i++) {
                            draw_label(sidebar_x_offset - 165, 291 + 24 * i, 160, 0, 1);
                            text_draw_centered(editor_menu_types_strings[editor_build_menu_selected][i], sidebar_x_offset - 165, 295 + 24 * i, 160, FONT_NORMAL_GREEN, COLOR_BLACK);
                        }
                        break;
                    case MENU_ELEVATION:
                    case MENU_ROCK:
                        for (int i = 0; i < 3; i++) {
                            draw_label(sidebar_x_offset - 165, 291 + 24 * i, 160, 0, 1);
                            text_draw_centered(editor_menu_types_strings[editor_build_menu_selected][i], sidebar_x_offset - 165, 295 + 24 * i, 160, FONT_NORMAL_GREEN, COLOR_BLACK);
                        }
                        break;
                    case MENU_BRUSH_SIZE:
                        for (int i = 0; i < 5; i++) {
                            draw_label(sidebar_x_offset - 165, 291 + 24 * i, 160, 0, 1);
                            text_draw_centered(editor_menu_types_strings[editor_build_menu_selected][i], sidebar_x_offset - 165, 295 + 24 * i, 160, FONT_NORMAL_GREEN, COLOR_BLACK);
                        }
                        break;
                    case MENU_EARTHQUAKE_POINTS:
                    case MENU_INVASION_POINTS:
                        for (int i = 0; i < 8; i++) {
                            draw_label(sidebar_x_offset - 165, 291 + 24 * i, 160, 0, 1);
                            text_draw_centered(editor_menu_types_strings[editor_build_menu_selected][i], sidebar_x_offset - 165, 295 + 24 * i, 160, FONT_NORMAL_GREEN, COLOR_BLACK);
                        }
                        break;
                    case MENU_PEOPLE_POINTS:
                    case MENU_RIVER_POINTS:
                        for (int i = 0; i < 2; i++) {
                            draw_label(sidebar_x_offset - 165, 291 + 24 * i, 160, 0, 1);
                            text_draw_centered(editor_menu_types_strings[editor_build_menu_selected][i], sidebar_x_offset - 165, 295 + 24 * i, 160, FONT_NORMAL_GREEN, COLOR_BLACK);
                        }
                        break;
                    case MENU_ANIMAL_POINTS:
                        for (int i = 0; i < 16; i++) {
                            draw_label(sidebar_x_offset - 165, 291 + 24 * i, 160, 0, 1);
                            text_draw_centered(editor_menu_types_strings[editor_build_menu_selected][i], sidebar_x_offset - 165, 295 + 24 * i, 160, FONT_NORMAL_GREEN, COLOR_BLACK);
                        }
                        break;
                }
                if (tool_data.build_in_progress) {
                    if (tool_data.type == TOOL_ROAD) {
                        building_construction_place_road(1, tool_data.start_tile.x, tool_data.start_tile.y, current_tile.x, current_tile.y);
                    } else {
                        switch (tool_data.type) {
                            case TOOL_SMALL_SHRUB:
                            case TOOL_MEDIUM_SHRUB:
                            case TOOL_LARGE_SHRUB:
                            case TOOL_LARGEST_SHRUB:
                            case TOOL_TREES:
                            case TOOL_SMALL_ROCK:
                            case TOOL_MEDIUM_ROCK:
                            case TOOL_LARGE_ROCK:
                            case TOOL_MEADOW:
                                place_selected_terrain_at_brush_location();
                                break;
                            case TOOL_GRASS:
                                place_selected_terrain_at_brush_location();
                                update_surrounding_water_images();
                                map_tiles_update_region_empty_land(current_tile.x - tool_data.brush_size, current_tile.y - tool_data.brush_size, current_tile.x + tool_data.brush_size, current_tile.y + tool_data.brush_size);
                                break;
                            case TOOL_WATER:
                                place_selected_terrain_at_brush_location();
                                update_surrounding_water_images();
                                break;
                            case TOOL_RAISE_LAND:
                            case TOOL_LOWER_LAND:
                                place_selected_terrain_at_brush_location();
                                for (int y = 0; y <= map_data.height - 2; y++) {
                                    for (int x = 0; x <= map_data.width - 2; x++) {
                                        // if (map_terrain_is(map_data.start_offset + x + y * GRID_SIZE, TERRAIN_ACCESS_RAMP)) {
                                        //     images.items[map_data.start_offset + x + y * GRID_SIZE] = 0;
                                        // }
                                        set_elevation_image(x, y, map_data.start_offset + x + y * GRID_SIZE);
                                    }
                                }
                                update_surrounding_water_images();
                                map_tiles_update_region_empty_land(current_tile.x - tool_data.brush_size, current_tile.y - tool_data.brush_size, current_tile.x + tool_data.brush_size, current_tile.y + tool_data.brush_size);
                                break;
                        }
                        minimap_data.refresh_requested = 1;
                    }
                }
                draw_image_button(1101, sidebar_x_offset + 7, 147, 71, 23, 1); // draw attributes button
                draw_image_button(952, sidebar_x_offset + 84, 147, 71, 23, 2); // draw empire button
                // draw build menu
                for (int i = 0; i < 3; i++) {
                    draw_image_button(1053 + 3 * i, sidebar_x_offset + 13 + 50 * i, 291, 39, 26, i + 3); // grassland, shrubs, water
                }
                draw_image_button(1074, sidebar_x_offset + 13, 327, 39, 26, 6); // elevation
                draw_image_button(1065, sidebar_x_offset + 63, 327, 39, 26, 7); // trees
                draw_image_button(1068, sidebar_x_offset + 113, 327, 39, 26, 8); // rocks
                draw_image_button(1071, sidebar_x_offset + 13, 363, 39, 26, 9); // meadow
                draw_image_button(1083, sidebar_x_offset + 63, 363, 39, 26, 10); // road
                draw_image_button(1077, sidebar_x_offset + 113, 363, 39, 26, 11); // brush
                draw_image_button(1062, sidebar_x_offset + 13, 399, 39, 26, 12); // earthquake
                draw_image_button(1092, sidebar_x_offset + 63, 399, 39, 26, 13); // invasion points
                draw_image_button(1095, sidebar_x_offset + 113, 399, 39, 26, 14); // land entry/exit points
                draw_image_button(1086, sidebar_x_offset + 13, 435, 39, 26, 15); // river entry/exit points
                draw_image_button(1080, sidebar_x_offset + 63, 435, 39, 26, 16); // buildings
                draw_image_button(1104, sidebar_x_offset + 113, 435, 39, 26, 17); // animal points
                widget_minimap_draw(sidebar_x_offset + 8, 30, 146, 111, 1);
                break;
            case WINDOW_EDITOR_TOP_MENU:
                if (refresh_current_window) {
                    draw_editor_map();
                    if (dropdown_list_selected) {
                        outer_panel_draw(112, 24, 10, 9);
                    }
                    refresh_current_window = 0;
                }
                switch (top_menu_data.open_sub_menu) {
                    case 1:
                        draw_top_menu_submenu(0, 7, 4);
                        for (int i = 0; i < 4; i++) {
                            if (mouse_x >= 10 && mouse_x < 105 && mouse_y >= 28 + 18 * i && mouse_y < 46 + 18 * i) {
                                switch (i) {
                                    case 0:
                                        text_draw("New map", 10, 30, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                        break;
                                    case 1:
                                        text_draw("Load map", 10, 48, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                        break;
                                    case 2:
                                        text_draw("Save map", 10, 66, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                        break;
                                    case 3:
                                        text_draw("Exit editor", 10, 84, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                        break;
                                }
                            } else {
                                switch (i) {
                                    case 0:
                                        text_draw("New map", 10, 30, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                        break;
                                    case 1:
                                        text_draw("Load map", 10, 48, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                        break;
                                    case 2:
                                        text_draw("Save map", 10, 66, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                        break;
                                    case 3:
                                        text_draw("Exit editor", 10, 84, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                        break;
                                }
                            }
                        }
                        break;
                    case 2:
                        draw_top_menu_submenu(68, 5, 3);
                        for (int i = 0; i < 3; i++) {
                            if (mouse_x >= 78 && mouse_x < 142 && mouse_y >= 28 + 18 * i && mouse_y < 46 + 18 * i) {
                                switch (i) {
                                    case 0:
                                        text_draw("Display", 78, 30, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                        break;
                                    case 1:
                                        text_draw("Sound", 78, 48, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                        break;
                                    case 2:
                                        text_draw("Speed", 78, 66, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                        break;
                                }
                            } else {
                                switch (i) {
                                    case 0:
                                        text_draw("Display", 78, 30, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                        break;
                                    case 1:
                                        text_draw("Sound", 78, 48, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                        break;
                                    case 2:
                                        text_draw("Speed", 78, 66, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                        break;
                                }
                            }
                        }
                        break;
                    case 3:
                        draw_top_menu_submenu(169, 8, 4);
                        for (int i = 0; i < 4; i++) {
                            if (mouse_x >= 179 && mouse_x < 290 && mouse_y >= 28 + 18 * i && mouse_y < 46 + 18 * i) {
                                switch (i) {
                                    case 0:
                                        text_draw("Herds", 179, 30, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                        break;
                                    case 1:
                                        text_draw("Fish", 179, 48, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                        break;
                                    case 2:
                                        text_draw("Invasions", 179, 66, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                        break;
                                    case 3:
                                        text_draw("Earthquakes", 179, 84, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                        break;
                                }
                            } else {
                                switch (i) {
                                    case 0:
                                        text_draw("Herds", 179, 30, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                        break;
                                    case 1:
                                        text_draw("Fish", 179, 48, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                        break;
                                    case 2:
                                        text_draw("Invasions", 179, 66, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                        break;
                                    case 3:
                                        text_draw("Earthquakes", 179, 84, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                        break;
                                }
                            }
                        }
                        break;
                }
                if (dropdown_list_selected) {
                    for (int i = 0; i < 6; i++) {
                        if (mouse_x >= 128 && mouse_x < 255 && mouse_y >= 40 + 18 * i && mouse_y < 58 + 18 * i) {
                            switch (i) {
                                case 0:
                                    text_draw("Tiny map", 128, 40, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                    break;
                                case 1:
                                    text_draw("Small map", 128, 58, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                    break;
                                case 2:
                                    text_draw("Medium map", 128, 76, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                    break;
                                case 3:
                                    text_draw("Large map", 128, 94, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                    break;
                                case 4:
                                    text_draw("Huge map", 128, 112, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                    break;
                                case 5:
                                    text_draw("Enormous map", 128, 130, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                                    break;
                            }
                        } else {
                            switch (i) {
                                case 0:
                                    text_draw("Tiny map", 128, 40, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                    break;
                                case 1:
                                    text_draw("Small map", 128, 58, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                    break;
                                case 2:
                                    text_draw("Medium map", 128, 76, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                    break;
                                case 3:
                                    text_draw("Large map", 128, 94, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                    break;
                                case 4:
                                    text_draw("Huge map", 128, 112, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                    break;
                                case 5:
                                    text_draw("Enormous map", 128, 130, FONT_NORMAL_PLAIN, COLOR_BLACK);
                                    break;
                            }
                        }
                    }
                }
                // allow opening other top menus by hovering the mouse over them
                if (top_menu_data.open_sub_menu) {
                    if (mouse_x >= 10 && mouse_x < 38 && mouse_y < 30) {
                        top_menu_data.open_sub_menu = TOP_MENU_FILE;
                        refresh_current_window = 1;
                    } else if (mouse_x >= 78 && mouse_x < 139 && mouse_y < 30) {
                        dropdown_list_selected = 0;
                        top_menu_data.open_sub_menu = TOP_MENU_OPTIONS;
                        refresh_current_window = 1;
                    } else if (mouse_x >= 179 && mouse_x < 230 && mouse_y < 30) {
                        dropdown_list_selected = 0;
                        top_menu_data.open_sub_menu = TOP_MENU_RESETS;
                        refresh_current_window = 1;
                    }
                }
                break;
            case WINDOW_EDITOR_ATTRIBUTES:
                if (refresh_current_window) {
                    draw_editor_map();
                    outer_panel_draw(map_center_x - 216, map_center_y - 200, 27, 25);
                    inner_panel_draw(map_center_x - 132, map_center_y - 180, 20, 2);
                    text_draw(scenario.brief_description, map_center_x - 122, map_center_y - 170, FONT_NORMAL_WHITE, COLOR_BLACK);
                    button_border_draw(map_center_x - 202, map_center_y - 138, 184, 144, 0);
                    image_draw(scenario.brief_description_image_id - 4576, map_center_x - 200, map_center_y - 136); // Brief description img id different in editor files
                    text_draw_centered(climate_types_strings[scenario.climate], map_center_x - 200, map_center_y + 29, 185, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered("Scenario briefing", map_center_x - 200, map_center_y + 69, 185, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered("Starting conditions", map_center_x - 200, map_center_y + 109, 185, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered("Win criteria", map_center_x - 200, map_center_y + 149, 185, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered("Allowed buildings", map_center_x - 8, map_center_y - 131, 195, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered("Special events", map_center_x - 8, map_center_y - 91, 195, FONT_NORMAL_BLACK, COLOR_BLACK);
                    if (scenario.requests[0].resource) {
                        text_draw_centered("Requests scheduled", map_center_x - 8, map_center_y - 51, 195, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else {
                        text_draw_centered("No requests", map_center_x - 8, map_center_y - 51, 195, FONT_NORMAL_BLACK, COLOR_BLACK);
                    }
                    if (scenario.editor_custom_messages[0].enabled) {
                        text_draw_centered("Messages scheduled", map_center_x - 8, map_center_y - 11, 195, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else {
                        text_draw_centered("No messages", map_center_x - 8, map_center_y - 11, 195, FONT_NORMAL_BLACK, COLOR_BLACK);
                    }
                    if (scenario.earthquakes[0].state) {
                        text_draw_centered("Earthquakes scheduled", map_center_x - 8, map_center_y + 29, 195, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else {
                        text_draw_centered("No earthquakes", map_center_x - 8, map_center_y + 29, 195, FONT_NORMAL_BLACK, COLOR_BLACK);
                    }
                    if (scenario.invasions[0].type) {
                        text_draw_centered("Invasions scheduled", map_center_x - 8, map_center_y + 69, 195, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else {
                        text_draw_centered("No invasions", map_center_x - 8, map_center_y + 69, 195, FONT_NORMAL_BLACK, COLOR_BLACK);
                    }
                    if (scenario.price_changes[0].resource) {
                        text_draw_centered("Price changes sch.", map_center_x - 8, map_center_y + 109, 195, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else {
                        text_draw_centered("No price changes", map_center_x - 8, map_center_y + 109, 195, FONT_NORMAL_BLACK, COLOR_BLACK);
                    }
                    if (scenario.demand_changes[0].resource && scenario.demand_changes[0].trade_city_id) {
                        text_draw_centered("Demand changes sch.", map_center_x - 8, map_center_y + 149, 195, FONT_NORMAL_BLACK, COLOR_BLACK);
                    } else {
                        text_draw_centered("No demand changes", map_center_x - 8, map_center_y + 149, 195, FONT_NORMAL_BLACK, COLOR_BLACK);
                    }
                    refresh_current_window = 0;
                }
                draw_arrow_button(15, map_center_x - 200, map_center_y - 176, 1);
                draw_arrow_button(17, map_center_x - 216 + 40, map_center_y - 176, 2);
                if (text_field_active) {
                    draw_input_field(20, 2);
                }
                for (int i = 0; i < 4; i++) {
                    if (mouse_x >= map_center_x - 200 && mouse_x < map_center_x - 15
                    && mouse_y >= map_center_y + 20 + 40 * i && mouse_y < map_center_y + 50 + 40 * i) {
                        button_border_draw(map_center_x - 200, map_center_y + 20 + 40 * i, 185, 30, 1);
                    } else {
                        button_border_draw(map_center_x - 200, map_center_y + 20 + 40 * i, 185, 30, 0);
                    }
                }
                for (int i = 0; i < 8; i++) {
                    if (mouse_x >= map_center_x - 8 && mouse_x < map_center_x + 187
                    && mouse_y >= map_center_y - 140 + 40 * i && mouse_y < map_center_y - 110 + 40 * i) {
                        button_border_draw(map_center_x - 8, map_center_y - 140 + 40 * i, 195, 30, 1);
                    } else {
                        button_border_draw(map_center_x - 8, map_center_y - 140 + 40 * i, 195, 30, 0);
                    }
                }
                break;
            case WINDOW_EDITOR_BRIEFING:
                if (refresh_current_window) {
                    inner_panel_draw(map_center_x - 480, map_center_y - 296, 60, 37);
                    parse_text(scenario.briefing, map_center_x - 470, map_center_y - 286, string_length(scenario.briefing), BRIEFING_MAX_LINE_WIDTH, FONT_NORMAL_WHITE);
                    draw_text(scenario.briefing, FONT_NORMAL_WHITE, COLOR_BLACK);
                    refresh_current_window = 0;
                }
                if (text_field_active) {
                    draw_input_field(60, 37);
                }
                draw_label(map_center_x - 88, map_center_y + 295, 176, 0, 1);
                text_draw_centered("Reset briefing", map_center_x - 88, map_center_y + 301, 176, FONT_NORMAL_RED, COLOR_BLACK);
                break;
            case WINDOW_EDITOR_STARTING_CONDITIONS:
                if (refresh_current_window) {
                    draw_editor_map();
                    outer_panel_draw(map_center_x - 240, map_center_y - 192, 30, 24);
                    text_draw_centered("Starting conditions", map_center_x - 240, map_center_y - 176, 480, FONT_LARGE_BLACK, COLOR_BLACK);
                    text_draw("Initial rank", map_center_x - 208, map_center_y - 128, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(initial_rank_strings[scenario.player_rank], map_center_x - 8, map_center_y - 127, 208, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Start date", map_center_x - 208, map_center_y - 88, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_year(scenario.start_year, map_center_x + 56, map_center_y - 87, FONT_NORMAL_BLACK);
                    text_draw("Initial favor", map_center_x - 208, map_center_y - 48, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number_centered(scenario.initial_favor, map_center_x - 8, map_center_y - 47, 208, FONT_NORMAL_BLACK);
                    text_draw("Initial funds", map_center_x - 208, map_center_y - 8, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number_centered(scenario.initial_funds, map_center_x - 8, map_center_y - 7, 208, FONT_NORMAL_BLACK);
                    text_draw("Rescue loan", map_center_x - 208, map_center_y + 32, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number_centered(scenario.rescue_loan, map_center_x - 8, map_center_y + 33, 208, FONT_NORMAL_BLACK);
                    text_draw("Initial personal savings", map_center_x - 208, map_center_y + 72, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number_centered(scenario.initial_personal_savings, map_center_x - 8, map_center_y + 73, 208, FONT_NORMAL_BLACK);
                    text_draw("Rome supplies wheat?", map_center_x - 208, map_center_y + 112, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(scenario.rome_supplies_wheat ? "Yes" : "No", map_center_x - 8, map_center_y + 113, 208, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Flotsam on?", map_center_x - 208, map_center_y + 152, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(scenario.flotsam_enabled ? "Yes" : "No", map_center_x - 8, map_center_y + 153, 208, FONT_NORMAL_BLACK, COLOR_BLACK);
                    if (dropdown_list_selected) {
                        outer_panel_draw(map_center_x + 200, map_center_y - 224, 8, 14);
                    }
                    refresh_current_window = 0;
                }
                for (int i = 0; i < 8; i++) {
                    if (!text_field_active && !dropdown_list_selected
                    && mouse_x >= map_center_x - 8 && mouse_x < map_center_x + 200
                    && mouse_y >= map_center_y - 136 + 40 * i && mouse_y < map_center_y - 106 + 40 * i) {
                        button_border_draw(map_center_x - 8, map_center_y - 136 + 40 * i, 208, 30, 1);
                    } else {
                        button_border_draw(map_center_x - 8, map_center_y - 136 + 40 * i, 208, 30, 0);
                    }
                }
                if (text_field_active) {
                    draw_input_field(13, 2);
                }
                if (dropdown_list_selected) {
                    for (int i = 0; i < 11; i++) {
                        if (mouse_x >= map_center_x + 216 && mouse_x < map_center_x + 322
                        && mouse_y >= map_center_y - 208 + 18 * i && mouse_y < map_center_y - 190 + 18 * i) {
                            text_draw(initial_rank_strings[i], map_center_x + 216, map_center_y - 208 + 18 * i, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                        } else {
                            text_draw(initial_rank_strings[i], map_center_x + 216, map_center_y - 208 + 18 * i, FONT_NORMAL_PLAIN, COLOR_BLACK);
                        }
                    }
                }
                break;
            case WINDOW_EDITOR_WIN_CRITERIA:
                if (refresh_current_window) {
                    draw_editor_map();
                    outer_panel_draw(map_center_x - 192, map_center_y - 192, 25, 24);
                    text_draw_centered("Win criteria", map_center_x - 192, map_center_y - 172, 400, FONT_LARGE_BLACK, COLOR_BLACK);
                    text_draw("Winning population", map_center_x - 160, map_center_y - 112, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Culture needed", map_center_x - 160, map_center_y - 72, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Prosperity needed", map_center_x - 160, map_center_y - 32, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Peace needed", map_center_x - 160, map_center_y + 8, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Favor needed", map_center_x - 160, map_center_y + 48, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Time until loss", map_center_x - 160, map_center_y + 88, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Time until win", map_center_x - 160, map_center_y + 128, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number_centered(scenario.population_win_criteria, map_center_x + 10, map_center_y - 114, 160, FONT_NORMAL_BLACK);
                    text_draw_number_centered(scenario.culture_win_criteria, map_center_x + 10, map_center_y - 74, 160, FONT_NORMAL_BLACK);
                    text_draw_number_centered(scenario.prosperity_win_criteria, map_center_x + 10, map_center_y - 34, 160, FONT_NORMAL_BLACK);
                    text_draw_number_centered(scenario.peace_win_criteria, map_center_x + 10, map_center_y + 6, 160, FONT_NORMAL_BLACK);
                    text_draw_number_centered(scenario.favor_win_criteria, map_center_x + 10, map_center_y + 46, 160, FONT_NORMAL_BLACK);
                    int width = text_draw_number(scenario.time_limit_win_criteria, '+', 0, map_center_x + 28, map_center_y + 86, FONT_NORMAL_BLACK);
                    text_draw_year(scenario.start_year + scenario.time_limit_win_criteria, width + map_center_x + 36, map_center_y + 86, FONT_NORMAL_BLACK);
                    width = text_draw_number(scenario.survival_time_win_criteria, '+', 0, map_center_x + 28, map_center_y + 126, FONT_NORMAL_BLACK);
                    text_draw_year(scenario.start_year + scenario.survival_time_win_criteria, width + map_center_x + 36, map_center_y + 126, FONT_NORMAL_BLACK);
                    refresh_current_window = 0;
                }
                for (int i = 0; i < 7; i++) {
                    if (!text_field_active && mouse_x >= map_center_x + 10 && mouse_x < map_center_x + 170
                    && mouse_y >= map_center_y - 122 + 40 * i && mouse_y < map_center_y - 92 + 40 * i) {
                        button_border_draw(map_center_x + 10, map_center_y - 122 + 40 * i, 160, 30, 1);
                    } else {
                        button_border_draw(map_center_x + 10, map_center_y - 122 + 40 * i, 160, 30, 0);
                    }
                }
                if (text_field_active) {
                    draw_input_field(10, 2);
                }
                break;
            case WINDOW_EDITOR_ALLOWED_BUILDINGS:
                if (refresh_current_window) {
                    outer_panel_draw(map_center_x - 416, map_center_y - 240, 52, 30);
                    text_draw_centered("Allowed buildings", map_center_x - 416, map_center_y - 220, 832, FONT_LARGE_BLACK, COLOR_BLACK);
                    for (int i = 0; i < MAX_ALLOWED_BUILDINGS; i++) {
                        int building_index = i + 1 > 2 ? i + 1 + MAX_HOUSE_TYPES : i + 1;
                        int font = FONT_NORMAL_PLAIN;
                        int color = COLOR_FONT_RED;
                        if (scenario.allowed_buildings[building_index]) {
                            font = FONT_NORMAL_BLACK;
                            color = COLOR_BLACK;
                        }
                        if (i < 20) {
                            text_draw_centered(all_buildings_strings[building_index], map_center_x - 392, map_center_y - 183 + 20 * i, 190, font, color);
                        } else if (i < 40) {
                            text_draw_centered(all_buildings_strings[building_index], map_center_x - 194, map_center_y - 183 + 20 * (i - 20), 190, font, color);
                        } else if (i < 60) {
                            text_draw_centered(all_buildings_strings[building_index], map_center_x + 4, map_center_y - 183 + 20 * (i - 40), 190, font, color);
                        } else {
                            text_draw_centered(all_buildings_strings[building_index], map_center_x + 202, map_center_y - 183 + 20 * (i - 60), 190, font, color);
                        }
                    }
                    refresh_current_window = 0;
                }
                for (int i = 0; i < MAX_ALLOWED_BUILDINGS; i++) {
                    if (i < 20) {
                        if (mouse_x >= map_center_x - 392 && mouse_x < map_center_x - 202
                        && mouse_y >= map_center_y - 188 + 20 * i && mouse_y < map_center_y - 168 + 20 * i) {
                            button_border_draw(map_center_x - 392, map_center_y - 188 + 20 * i, 190, 20, 1);
                        } else {
                            button_border_draw(map_center_x - 392, map_center_y - 188 + 20 * i, 190, 20, 0);
                        }
                    } else if (i < 40) {
                        if (mouse_x >= map_center_x - 194 && mouse_x < map_center_x - 4
                        && mouse_y >= map_center_y - 188 + 20 * (i - 20) && mouse_y < map_center_y - 168 + 20 * (i - 20)) {
                            button_border_draw(map_center_x - 194, map_center_y - 188 + 20 * (i - 20), 190, 20, 1);
                        } else {
                            button_border_draw(map_center_x - 194, map_center_y - 188 + 20 * (i - 20), 190, 20, 0);
                        }
                    } else if (i < 60) {
                        if (mouse_x >= map_center_x + 4 && mouse_x < map_center_x + 194
                        && mouse_y >= map_center_y - 188 + 20 * (i - 40) && mouse_y < map_center_y - 168 + 20 * (i - 40)) {
                            button_border_draw(map_center_x + 4, map_center_y - 188 + 20 * (i - 40), 190, 20, 1);
                        } else {
                            button_border_draw(map_center_x + 4, map_center_y - 188 + 20 * (i - 40), 190, 20, 0);
                        }
                    } else {
                        if (mouse_x >= map_center_x + 202 && mouse_x < map_center_x + 392
                        && mouse_y >= map_center_y - 188 + 20 * (i - 60) && mouse_y < map_center_y - 168 + 20 * (i - 60)) {
                            button_border_draw(map_center_x + 202, map_center_y - 188 + 20 * (i - 60), 190, 20, 1);
                        } else {
                            button_border_draw(map_center_x + 202, map_center_y - 188 + 20 * (i - 60), 190, 20, 0);
                        }
                    }
                }
                break;
            case WINDOW_EDITOR_SPECIAL_EVENTS:
                if (refresh_current_window) {
                    draw_editor_map();
                    outer_panel_draw(map_center_x - 256, map_center_y - 168, 32, 21);
                    text_draw_centered("Special events", map_center_x - 256, map_center_y - 148, 512, FONT_LARGE_BLACK, COLOR_BLACK);
                    text_draw("In use", map_center_x - 41, map_center_y - 108, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("Timing", map_center_x + 50, map_center_y - 108, FONT_SMALL_PLAIN, COLOR_BLACK);
                    text_draw("Gladiator revolt", map_center_x - 224, map_center_y - 78, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(scenario.gladiator_revolt.state ? "Yes" : "No", map_center_x - 60, map_center_y - 78, 75, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(short_month_names[scenario.gladiator_revolt.month], map_center_x + 23, map_center_y - 78, 45, FONT_NORMAL_BLACK, COLOR_BLACK);
                    int width = text_draw_number(scenario.gladiator_revolt.year_offset, '+', 0, map_center_x + 88, map_center_y - 78, FONT_NORMAL_BLACK);
                    text_draw_year(scenario.start_year + scenario.gladiator_revolt.year_offset, width + map_center_x + 88, map_center_y - 78, FONT_NORMAL_BLACK);
                    text_draw("Sea trade problem", map_center_x - 224, map_center_y - 38, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(scenario.random_events.sea_trade_problem ? "Yes" : "No", map_center_x - 60, map_center_y - 38, 75, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Land trade problem", map_center_x - 224, map_center_y + 2, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(scenario.random_events.land_trade_problem ? "Yes" : "No", map_center_x - 60, map_center_y + 2, 75, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Rome raises wages", map_center_x - 224, map_center_y + 42, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(scenario.random_events.raise_wages ? "Yes" : "No", map_center_x - 60, map_center_y + 42, 75, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Rome lowers wages", map_center_x - 224, map_center_y + 82, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(scenario.random_events.lower_wages ? "Yes" : "No", map_center_x - 60, map_center_y + 82, 75, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Contaminated water", map_center_x - 224, map_center_y + 122, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(scenario.random_events.contaminated_water ? "Yes" : "No", map_center_x - 60, map_center_y + 122, 75, FONT_NORMAL_BLACK, COLOR_BLACK);
                    for (int i = 0; i < 5; i++) {
                        text_draw("Random", map_center_x + 45, map_center_y - 38 + 40 * i, FONT_NORMAL_BLACK, COLOR_BLACK);
                    }
                    refresh_current_window = 0;
                }
                for (int i = 0; i < 6; i++) {
                    if (!text_field_active && !dropdown_list_selected
                    && mouse_x >= map_center_x - 60 && mouse_x < map_center_x + 15
                    && mouse_y >= map_center_y - 87 + 40 * i && mouse_y < map_center_y - 57 + 40 * i) {
                        button_border_draw(map_center_x - 60, map_center_y - 87 + 40 * i, 75, 30, 1);
                    } else {
                        button_border_draw(map_center_x - 60, map_center_y - 87 + 40 * i, 75, 30, 0);
                    }
                }
                if (!text_field_active && !dropdown_list_selected
                && mouse_x >= map_center_x + 23 && mouse_x < map_center_x + 68
                && mouse_y >= map_center_y - 87 && mouse_y < map_center_y - 57) {
                    button_border_draw(map_center_x + 23, map_center_y - 87, 45, 30, 1);
                } else {
                    button_border_draw(map_center_x + 23, map_center_y - 87, 45, 30, 0);
                }
                if (!text_field_active && !dropdown_list_selected
                && mouse_x >= map_center_x + 76 && mouse_x < map_center_x + 236
                && mouse_y >= map_center_y - 87 && mouse_y < map_center_y - 57) {
                    button_border_draw(map_center_x + 76, map_center_y - 87, 160, 30, 1);
                } else {
                    button_border_draw(map_center_x + 76, map_center_y - 87, 160, 30, 0);
                }
                if (dropdown_list_selected) {
                    outer_panel_draw(map_center_x + 67, map_center_y - 185, 8, 15);
                    for (int i = 0; i < 12; i++) {
                        if (mouse_x >= map_center_x + 83 && mouse_x < map_center_x + 183
                        && mouse_y >= map_center_y - 169 + 18 * i && mouse_y < map_center_y - 151 + 18 * i) {
                            text_draw(long_month_names[i], map_center_x + 83, map_center_y - 169 + 18 * i, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                        } else {
                            text_draw(long_month_names[i], map_center_x + 83, map_center_y - 169 + 18 * i, FONT_NORMAL_PLAIN, COLOR_BLACK);
                        }
                    }
                }
                if (text_field_active) {
                    draw_input_field(10, 2);
                }
                break;
            case WINDOW_EDITOR_REQUESTS:
                if (refresh_current_window) {
                    draw_editor_map();
                    outer_panel_draw(map_center_x - 472, map_center_y - 280, 59, 35);
                    text_draw_centered("Emperor requests", map_center_x - 472, map_center_y - 260, 944, FONT_LARGE_BLACK, COLOR_BLACK);
                    for (int i = 0; i < MAX_REQUESTS; i++) {
                        int x, y;
                        if (i < 15) {
                            x = map_center_x - 447;
                            y = map_center_y - 212 + 30 * i;
                        } else if (i < 30) {
                            x = map_center_x - 149;
                            y = map_center_y - 212 + 30 * (i - 15);
                        } else {
                            x = map_center_x + 149;
                            y = map_center_y - 212 + 30 * (i - 30);
                        }
                        if (scenario.requests[i].resource) {
                            int width = text_draw(short_month_names[scenario.requests[i].month], x + 12, y + 6, FONT_NORMAL_BLACK, COLOR_BLACK);
                            width += text_draw_year(scenario.start_year + scenario.requests[i].year_offset, x + 6 + width, y + 6, FONT_NORMAL_BLACK);
                            width += text_draw_number(scenario.requests[i].amount, 0, "", x + 6 + width, y + 6, FONT_NORMAL_BLACK);
                            image_draw(resource_images[scenario.requests[i].resource].editor_icon_img_id + resource_image_offset(scenario.requests[i].resource, RESOURCE_IMAGE_ICON), x + 12 + width, y + 3);
                            width += text_draw_number(scenario.requests[i].years_deadline, 0, "Y", x + 40 + width, y + 6, FONT_NORMAL_BLACK);
                            text_draw_number(scenario.requests[i].favor, 0, "F", x + 40 + width, y + 6, FONT_NORMAL_BLACK);
                        } else {
                            text_draw_centered("Free slot", x, y + 6, 290, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                    }
                    refresh_current_window = 0;
                }
                for (int i = 0; i < MAX_REQUESTS; i++) {
                    int x, y;
                    if (i < 15) {
                        x = map_center_x - 447;
                        y = map_center_y - 212 + 30 * i;
                    } else if (i < 30) {
                        x = map_center_x - 149;
                        y = map_center_y - 212 + 30 * (i - 15);
                    } else {
                        x = map_center_x + 149;
                        y = map_center_y - 212 + 30 * (i - 30);
                    }
                    if (mouse_x >= x && mouse_x < x + 290 && mouse_y >= y && mouse_y < y + 25) {
                        button_border_draw(x, y, 290, 25, 1);
                    } else {
                        button_border_draw(x, y, 290, 25, 0);
                    }
                }
                break;
            case WINDOW_EDITOR_EDIT_REQUEST:
                if (refresh_current_window) {
                    draw_editor_map();
                    outer_panel_draw(map_center_x - 152, map_center_y - 144, 19, 18);
                    text_draw_centered("Specify request", map_center_x - 152, map_center_y - 124, 304, FONT_LARGE_BLACK, COLOR_BLACK);
                    text_draw("Year offset:", map_center_x - 120, map_center_y - 75, FONT_NORMAL_BLACK, COLOR_BLACK);
                    int width = text_draw_number(scenario.requests[id_edit_request].year_offset, '+', 0, map_center_x + 16, map_center_y - 75, FONT_NORMAL_BLACK);
                    text_draw_year(scenario.start_year + scenario.requests[id_edit_request].year_offset, map_center_x + 12 + width, map_center_y - 75, FONT_NORMAL_BLACK);
                    text_draw("Month:", map_center_x - 120, map_center_y - 45, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(short_month_names[scenario.requests[id_edit_request].month], map_center_x + 8, map_center_y - 45, 112, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Resource:", map_center_x - 120, map_center_y - 15, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(resource_strings[scenario.requests[id_edit_request].resource], map_center_x + 8, map_center_y - 15, 112, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Amount:", map_center_x - 120, map_center_y + 15, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number_centered(scenario.requests[id_edit_request].amount, map_center_x + 8, map_center_y + 15, 112, FONT_NORMAL_BLACK);
                    text_draw("Years deadline:", map_center_x - 120, map_center_y + 45, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number(scenario.requests[id_edit_request].years_deadline, 0, " Years", map_center_x + 30, map_center_y + 45, FONT_NORMAL_BLACK);
                    text_draw("Favor granted:", map_center_x - 120, map_center_y + 75, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number_centered_prefix(scenario.requests[id_edit_request].favor, '+', map_center_x + 8, map_center_y + 75, 112, FONT_NORMAL_BLACK);
                    text_draw_centered("Unschedule request", map_center_x - 100, map_center_y + 108, 200, FONT_NORMAL_BLACK, COLOR_BLACK);
                    if (dropdown_list_selected == 1) {
                        outer_panel_draw(map_center_x + 127, map_center_y - 168, 8, 15);
                    } else if (dropdown_list_selected == 2) {
                        outer_panel_draw(map_center_x + 127, map_center_y - 138, 8, 21);
                    }
                    refresh_current_window = 0;
                }
                for (int i = 0; i < 6; i++) {
                    if (!text_field_active && !dropdown_list_selected
                    && mouse_x >= map_center_x + 8 && mouse_x < map_center_x + 120
                    && mouse_y >= map_center_y - 84 + 30 * i && mouse_y < map_center_y - 54 + 30 * i) {
                        button_border_draw(map_center_x + 8, map_center_y - 84 + 30 * i, 112, 30, 1);
                    } else {
                        button_border_draw(map_center_x + 8, map_center_y - 84 + 30 * i, 112, 30, 0);
                    }
                }
                if (!text_field_active && !dropdown_list_selected
                && mouse_x >= map_center_x - 100 && mouse_x < map_center_x + 100
                && mouse_y >= map_center_y + 101 && mouse_y < map_center_y + 126) {
                    button_border_draw(map_center_x - 100, map_center_y + 101, 200, 25, 1);
                } else {
                    button_border_draw(map_center_x - 100, map_center_y + 101, 200, 25, 0);
                }
                if (text_field_active) {
                    draw_input_field(7, 2);
                }
                if (dropdown_list_selected == 1) {
                    for (int i = 0; i < 12; i++) {
                        if (mouse_x >= map_center_x + 143 && mouse_x < map_center_x + 243
                        && mouse_y >= map_center_y - 152 + 18 * i && mouse_y < map_center_y - 134 + 18 * i) {
                            text_draw(long_month_names[i], map_center_x + 142, map_center_y - 151 + 18 * i, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                        } else {
                            text_draw(long_month_names[i], map_center_x + 142, map_center_y - 151 + 18 * i, FONT_NORMAL_PLAIN, COLOR_BLACK);
                        }
                    }
                } else if (dropdown_list_selected == 2) {
                    for (int i = 0; i < 17; i++) {
                        if (mouse_x >= map_center_x + 143 && mouse_x < map_center_x + 243
                        && mouse_y >= map_center_y - 122 + 18 * i && mouse_y < map_center_y - 104 + 18 * i) {
                            text_draw(resource_strings[i], map_center_x + 142, map_center_y - 121 + 18 * i, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                        } else {
                            text_draw(resource_strings[i], map_center_x + 142, map_center_y - 121 + 18 * i, FONT_NORMAL_PLAIN, COLOR_BLACK);
                        }
                    }
                }
                break;
            case WINDOW_EDITOR_CUSTOM_MESSAGES:
                if (refresh_current_window) {
                    outer_panel_draw(map_center_x - 416, map_center_y - 336, 52, 42);
                    text_draw_centered("Messages to player", map_center_x - 416, map_center_y - 316, 832, FONT_LARGE_BLACK, COLOR_BLACK);
                    for (int i = 0; i < MAX_EDITOR_CUSTOM_MESSAGES; i++) {
                        int x, y;
                        if (i < 20) {
                            x = map_center_x - 392;
                            y = map_center_y - 270 + 30 * i;
                        } else {
                            x = map_center_x + 7;
                            y = map_center_y - 270 + 30 * (i - 20);
                        }
                        if (scenario.editor_custom_messages[i].enabled) {
                            int width = text_draw(short_month_names[scenario.editor_custom_messages[i].month], x + 12, y, FONT_NORMAL_BLACK, COLOR_BLACK);
                            text_draw_year(scenario.start_year + scenario.editor_custom_messages[i].year_offset, x + width + 6, y, FONT_NORMAL_BLACK);
                        } else {
                            text_draw_centered("Attributes", x, y, 125, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                        int max_preview_length = 12; // can make into an ellipsize function
                        if (scenario.editor_custom_messages[i].title[0] != '\0') {
                            char title_preview[max_preview_length + 3];
                            string_copy(scenario.editor_custom_messages[i].title, title_preview, max_preview_length);
                            if (string_length(scenario.editor_custom_messages[i].title) > max_preview_length) {
                                title_preview[max_preview_length - 1] = '.';
                                title_preview[max_preview_length] = '.';
                                title_preview[max_preview_length + 1] = '.';
                                title_preview[max_preview_length + 2] = '\0';
                            }
                            text_draw(title_preview, x + 138, y, FONT_NORMAL_BLACK, COLOR_BLACK);
                        } else {
                            text_draw_centered("Title", x + 130, y, 125, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                        if (scenario.editor_custom_messages[i].text[0] != '\0') {
                            char text_preview[max_preview_length + 3];
                            string_copy(scenario.editor_custom_messages[i].text, text_preview, max_preview_length);
                            if (string_length(scenario.editor_custom_messages[i].text) > max_preview_length) {
                                text_preview[max_preview_length - 1] = '.';
                                text_preview[max_preview_length] = '.';
                                text_preview[max_preview_length + 1] = '.';
                                text_preview[max_preview_length + 2] = '\0';
                            }
                            text_draw(text_preview, x + 268, y, FONT_NORMAL_BLACK, COLOR_BLACK);
                        } else {
                            text_draw_centered("Text", x + 260, y, 125, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                    }
                    refresh_current_window = 0;
                }
                for (int i = 0; i < MAX_EDITOR_CUSTOM_MESSAGES; i++) {
                    if (i < 20) {
                        if (mouse_x >= map_center_x - 392 && mouse_x < map_center_x - 267
                        && mouse_y >= map_center_y - 276 + 30 * i && mouse_y < map_center_y - 251 + 30 * i) {
                            button_border_draw(map_center_x - 392, map_center_y - 276 + 30 * i, 125, 25, 1);
                        } else {
                            button_border_draw(map_center_x - 392, map_center_y - 276 + 30 * i, 125, 25, 0);
                        }
                        if (mouse_x >= map_center_x - 262 && mouse_x < map_center_x - 137
                        && mouse_y >= map_center_y - 276 + 30 * i && mouse_y < map_center_y - 251 + 30 * i) {
                            button_border_draw(map_center_x - 262, map_center_y - 276 + 30 * i, 125, 25, 1);
                        } else {
                            button_border_draw(map_center_x - 262, map_center_y - 276 + 30 * i, 125, 25, 0);
                        }
                        if (mouse_x >= map_center_x - 132 && mouse_x < map_center_x - 7
                        && mouse_y >= map_center_y - 276 + 30 * i && mouse_y < map_center_y - 251 + 30 * i) {
                            button_border_draw(map_center_x - 132, map_center_y - 276 + 30 * i, 125, 25, 1);
                        } else {
                            button_border_draw(map_center_x - 132, map_center_y - 276 + 30 * i, 125, 25, 0);
                        }
                    } else {
                        if (mouse_x >= map_center_x + 7 && mouse_x < map_center_x + 132
                        && mouse_y >= map_center_y - 276 + 30 * (i - 20) && mouse_y < map_center_y - 251 + 30 * (i - 20)) {
                            button_border_draw(map_center_x + 7, map_center_y - 276 + 30 * (i - 20), 125, 25, 1);
                        } else {
                            button_border_draw(map_center_x + 7, map_center_y - 276 + 30 * (i - 20), 125, 25, 0);
                        }
                        if (mouse_x >= map_center_x + 137 && mouse_x < map_center_x + 262
                        && mouse_y >= map_center_y - 276 + 30 * (i - 20) && mouse_y < map_center_y - 251 + 30 * (i - 20)) {
                            button_border_draw(map_center_x + 137, map_center_y - 276 + 30 * (i - 20), 125, 25, 1);
                        } else {
                            button_border_draw(map_center_x + 137, map_center_y - 276 + 30 * (i - 20), 125, 25, 0);
                        }
                        if (mouse_x >= map_center_x + 267 && mouse_x < map_center_x + 392
                        && mouse_y >= map_center_y - 276 + 30 * (i - 20) && mouse_y < map_center_y - 251 + 30 * (i - 20)) {
                            button_border_draw(map_center_x + 267, map_center_y - 276 + 30 * (i - 20), 125, 25, 1);
                        } else {
                            button_border_draw(map_center_x + 267, map_center_y - 276 + 30 * (i - 20), 125, 25, 0);
                        }
                    }
                }
                break;
            case WINDOW_EDITOR_EDIT_CUSTOM_MESSAGE_ATTRIBUTES:
                if (refresh_current_window) {
                    draw_editor_map();
                    outer_panel_draw(map_center_x - 192, map_center_y - 136, 24, 17);
                    text_draw_centered("Message attributes", map_center_x - 192, map_center_y - 116, 384, FONT_LARGE_BLACK, COLOR_BLACK);
                    text_draw("Year offset:", map_center_x - 160, map_center_y - 59, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number_centered_prefix(scenario.editor_custom_messages[custom_message_id].year_offset, '+', map_center_x - 55, map_center_y - 59, 75, FONT_NORMAL_BLACK);
                    text_draw_year(scenario.start_year + scenario.editor_custom_messages[custom_message_id].year_offset, map_center_x, map_center_y - 59, FONT_NORMAL_BLACK);
                    text_draw("Month:", map_center_x - 160, map_center_y - 29, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(short_month_names[scenario.editor_custom_messages[custom_message_id].month], map_center_x - 55, map_center_y - 29, 160, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Urgent?", map_center_x - 160, map_center_y + 1, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(scenario.editor_custom_messages[custom_message_id].urgent ? "Yes" : "No", map_center_x - 55, map_center_y + 1, 160, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Video file:", map_center_x - 160, map_center_y + 31, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(scenario.editor_custom_messages[custom_message_id].video_file, map_center_x - 55, map_center_y + 31, 160, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("smk/file", map_center_x + 108, map_center_y + 31, FONT_NORMAL_PLAIN, COLOR_TOOLTIP);
                    text_draw("Enabled?", map_center_x - 160, map_center_y + 61, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(scenario.editor_custom_messages[custom_message_id].enabled ? "Yes" : "No", map_center_x - 55, map_center_y + 61, 160, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered("Reset message", map_center_x - 65, map_center_y + 100, 130, FONT_NORMAL_PLAIN, COLOR_RED);
                    if (dropdown_list_selected) {
                        outer_panel_draw(map_center_x + 105, map_center_y - 145, 8, 15);
                    }
                    refresh_current_window = 0;
                }
                for (int i = 0; i < 5; i++) {
                    if (!dropdown_list_selected && mouse_x >= map_center_x - 55 && mouse_x < map_center_x + 105
                    && mouse_y >= map_center_y - 68 + 30 * i && mouse_y < map_center_y - 38 + 30 * i) {
                        button_border_draw(map_center_x - 55, map_center_y - 68 + 30 * i, 160, 30, 1);
                    } else {
                        button_border_draw(map_center_x - 55, map_center_y - 68 + 30 * i, 160, 30, 0);
                    }
                }
                if (text_field_active) {
                    draw_input_field(10, 2);
                }
                if (!dropdown_list_selected && mouse_x >= map_center_x - 65 && mouse_x < map_center_x + 65
                && mouse_y >= map_center_y + 93 && mouse_y < map_center_y + 118) {
                    button_border_draw(map_center_x - 65, map_center_y + 93, 130, 25, 1);
                } else {
                    button_border_draw(map_center_x - 65, map_center_y + 93, 130, 25, 0);
                }
                if (dropdown_list_selected) {
                    for (int i = 0; i < 12; i++) {
                        if (mouse_x >= map_center_x + 121 && mouse_x < map_center_x + 221
                        && mouse_y >= map_center_y - 129 + 18 * i && mouse_y < map_center_y - 111 + 18 * i) {
                            text_draw(long_month_names[i], map_center_x + 121, map_center_y - 129 + 18 * i, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                        } else {
                            text_draw(long_month_names[i], map_center_x + 121, map_center_y - 129 + 18 * i, FONT_NORMAL_PLAIN, COLOR_BLACK);
                        }
                    }
                }
                break;
            case WINDOW_EDITOR_EDIT_CUSTOM_MESSAGE_TITLE:
                if (refresh_current_window) {
                    draw_editor_map();
                    outer_panel_draw(map_center_x - 168, map_center_y - 80, 21, 10);
                    text_draw_centered("Message title", map_center_x - 168, map_center_y - 60, 336, FONT_LARGE_BLACK, COLOR_BLACK);
                    inner_panel_draw(map_center_x - 136, map_center_y - 12, 17, 2);
                    text_draw(scenario.editor_custom_messages[custom_message_id].title, map_center_x - 126, map_center_y - 2, FONT_NORMAL_WHITE, COLOR_BLACK);
                    text_draw_centered("Reset title", map_center_x - 63, map_center_y + 39, 126, FONT_NORMAL_PLAIN, COLOR_RED);
                    refresh_current_window = 0;
                }
                if (text_field_active) {
                    draw_input_field(17, 2);
                }
                if (mouse_x >= map_center_x - 63 && mouse_x < map_center_x + 63
                && mouse_y >= map_center_y + 32 && mouse_y < map_center_y + 57) {
                    button_border_draw(map_center_x - 63, map_center_y + 32, 126, 25, 1);
                } else {
                    button_border_draw(map_center_x - 63, map_center_y + 32, 126, 25, 0);
                }
                break;
            case WINDOW_EDITOR_EDIT_CUSTOM_MESSAGE_TEXT:
                if (refresh_current_window) {
                    draw_editor_map();
                    outer_panel_draw(map_center_x - 400, map_center_y - 256, 50, 32);
                    text_draw_centered("Message text", map_center_x - 400, map_center_y - 236, 800, FONT_LARGE_BLACK, COLOR_BLACK);
                    inner_panel_draw(map_center_x - 384, map_center_y - 192, 48, 26);
                    parse_text(scenario.editor_custom_messages[custom_message_id].text, map_center_x - 374, map_center_y - 182, string_length(scenario.editor_custom_messages[custom_message_id].text), MAX_CUSTOM_MESSAGE_TEXT_WIDTH, FONT_NORMAL_WHITE);
                    draw_text(scenario.editor_custom_messages[custom_message_id].text, FONT_NORMAL_WHITE, COLOR_BLACK);
                    text_draw_centered("Reset text", map_center_x - 63, map_center_y + 228, 126, FONT_NORMAL_PLAIN, COLOR_RED);
                    refresh_current_window = 0;
                }
                if (text_field_active) {
                    draw_input_field(48, 26);
                }
                if (mouse_x >= map_center_x - 63 && mouse_x < map_center_x + 63
                && mouse_y >= map_center_y + 222 && mouse_y < map_center_y + 247) {
                    button_border_draw(map_center_x - 63, map_center_y + 222, 126, 25, 1);
                } else {
                    button_border_draw(map_center_x - 63, map_center_y + 222, 126, 25, 0);
                }
                break;
            case WINDOW_EDITOR_EARTHQUAKES:
                if (refresh_current_window) {
                    draw_editor_map();
                    outer_panel_draw(map_center_x - 200, map_center_y - 200, 25, 25);
                    text_draw_centered("Earthquakes", map_center_x - 200, map_center_y - 180, 400, FONT_LARGE_BLACK, COLOR_BLACK);
                    for (int i = 0; i < MAX_EARTHQUAKES; i++) {
                        if (scenario.earthquakes[i].state) {
                            int width = text_draw(short_month_names[scenario.earthquakes[i].month], map_center_x - 159, map_center_y - 134 + 32 * i, FONT_NORMAL_BLACK, COLOR_BLACK);
                            width += text_draw_year(scenario.start_year + scenario.earthquakes[i].year_offset, map_center_x - 159 + width, map_center_y - 134 + 32 * i, FONT_NORMAL_BLACK);
                            switch (scenario.earthquakes[i].severity) {
                                case 0:
                                    width += text_draw("None", map_center_x - 159 + width, map_center_y - 134 + 32 * i, FONT_NORMAL_BLACK, COLOR_BLACK);
                                    break;
                                case 1:
                                    width += text_draw("Minor", map_center_x - 159 + width, map_center_y - 134 + 32 * i, FONT_NORMAL_BLACK, COLOR_BLACK);
                                    break;
                                case 2:
                                    width += text_draw("Average", map_center_x - 159 + width, map_center_y - 134 + 32 * i, FONT_NORMAL_BLACK, COLOR_BLACK);
                                    break;
                                case 3:
                                    width += text_draw("Major", map_center_x - 159 + width, map_center_y - 134 + 32 * i, FONT_NORMAL_BLACK, COLOR_BLACK);
                                    break;
                            }
                            text_draw(earthquakes_strings[scenario.earthquakes[i].point], map_center_x - 159 + width, map_center_y - 134 + 32 * i, FONT_NORMAL_BLACK, COLOR_BLACK);
                        } else {
                            text_draw_centered("Free earthquake slot", map_center_x - 175, map_center_y - 134 + 32 * i, 350, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                    }
                    refresh_current_window = 0;
                }
                for (int i = 0; i < MAX_EARTHQUAKES; i++) {
                    if (mouse_x >= map_center_x - 175 && mouse_x < map_center_x + 175
                    && mouse_y >= map_center_y - 140 + 32 * i && mouse_y < map_center_y - 115 + 32 * i) {
                        button_border_draw(map_center_x - 175, map_center_y - 140 + 32 * i, 350, 25, 1);
                    } else {
                        button_border_draw(map_center_x - 175, map_center_y - 140 + 32 * i, 350, 25, 0);
                    }
                }
                break;
            case WINDOW_EDITOR_EDIT_EARTHQUAKE:
                if (refresh_current_window) {
                    draw_editor_map();
                    outer_panel_draw(map_center_x - 200, map_center_y - 112, 25, 14);
                    text_draw_centered("Schedule an earthquake", map_center_x - 200, map_center_y - 92, 400, FONT_LARGE_BLACK, COLOR_BLACK);
                    text_draw("Year offset:", map_center_x - 168, map_center_y - 42, FONT_NORMAL_BLACK, COLOR_BLACK);
                    int width = text_draw_number(scenario.earthquakes[id_edit_earthquake].year_offset, '+', 0, map_center_x - 14, map_center_y - 42, FONT_NORMAL_BLACK);
                    text_draw_year(scenario.start_year + scenario.earthquakes[id_edit_earthquake].year_offset, map_center_x + width, map_center_y - 42, FONT_NORMAL_BLACK);
                    text_draw("Month:", map_center_x - 168, map_center_y - 12, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(short_month_names[scenario.earthquakes[id_edit_earthquake].month], map_center_x - 55, map_center_y - 12, 208, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Severity:", map_center_x - 168, map_center_y + 18, FONT_NORMAL_BLACK, COLOR_BLACK);
                    switch (scenario.earthquakes[id_edit_earthquake].severity) {
                        case 0:
                            text_draw_centered("None", map_center_x - 55, map_center_y + 18, 208, FONT_NORMAL_BLACK, COLOR_BLACK);
                            break;
                        case 1:
                            text_draw_centered("Minor", map_center_x - 55, map_center_y + 18, 208, FONT_NORMAL_BLACK, COLOR_BLACK);
                            break;
                        case 2:
                            text_draw_centered("Average", map_center_x - 55, map_center_y + 18, 208, FONT_NORMAL_BLACK, COLOR_BLACK);
                            break;
                        case 3:
                            text_draw_centered("Major", map_center_x - 55, map_center_y + 18, 208, FONT_NORMAL_BLACK, COLOR_BLACK);
                            break;
                    }
                    text_draw("Point:", map_center_x - 168, map_center_y + 48, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(earthquakes_strings[scenario.earthquakes[id_edit_earthquake].point], map_center_x - 55, map_center_y + 48, 200, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered("Cancel earthquake", map_center_x - 100, map_center_y + 81, 200, FONT_NORMAL_BLACK, COLOR_BLACK);
                    if (dropdown_list_selected == 1) {
                        outer_panel_draw(map_center_x + 153, map_center_y - 145, 8, 15);
                    } else if (dropdown_list_selected == 2) {
                        outer_panel_draw(map_center_x + 153, map_center_y - 40, 12, 11);
                    }
                    refresh_current_window = 0;
                }
                for (int i = 0; i < 4; i++) {
                    if (!text_field_active && !dropdown_list_selected
                    && mouse_x >= map_center_x - 55 && mouse_x < map_center_x + 153
                    && mouse_y >= map_center_y - 51 + 30 * i && mouse_y < map_center_y - 21 + 30 * i) {
                        button_border_draw(map_center_x - 55, map_center_y - 51 + 30 * i, 208, 30, 1);
                    } else {
                        button_border_draw(map_center_x - 55, map_center_y - 51 + 30 * i, 208, 30, 0);
                    }
                }
                if (text_field_active) {
                    draw_input_field(13, 2);
                }
                if (!text_field_active && !dropdown_list_selected
                && mouse_x >= map_center_x - 100 && mouse_x < map_center_x + 100
                && mouse_y >= map_center_y + 74 && mouse_y < map_center_y + 99) {
                    button_border_draw(map_center_x - 100, map_center_y + 74, 200, 25, 1);
                } else {
                    button_border_draw(map_center_x - 100, map_center_y + 74, 200, 25, 0);
                }
                if (dropdown_list_selected == 1) {
                    for (int i = 0; i < 12; i++) {
                        if (mouse_x >= map_center_x + 169 && mouse_x < map_center_x + 269
                        && mouse_y >= map_center_y - 129 + 18 * i && mouse_y < map_center_y - 111 + 18 * i) {
                            text_draw(long_month_names[i], map_center_x + 169, map_center_y - 129 + 18 * i, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                        } else {
                            text_draw(long_month_names[i], map_center_x + 169, map_center_y - 129 + 18 * i, FONT_NORMAL_PLAIN, COLOR_BLACK);
                        }
                    }
                } else if (dropdown_list_selected == 2) {
                    for (int i = 0; i < 8; i++) {
                        if (mouse_x >= map_center_x + 169 && mouse_x < map_center_x + 269
                        && mouse_y >= map_center_y - 24 + 18 * i && mouse_y < map_center_y - 6 + 18 * i) {
                            text_draw(editor_menu_types_strings[4][i], map_center_x + 169, map_center_y - 24 + 18 * i, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                        } else {
                            text_draw(editor_menu_types_strings[4][i], map_center_x + 169, map_center_y - 24 + 18 * i, FONT_NORMAL_PLAIN, COLOR_BLACK);
                        }
                    }
                }
                break;
            case WINDOW_EDITOR_INVASIONS:
                if (refresh_current_window) {
                    outer_panel_draw(map_center_x - 472, map_center_y - 280, 59, 35);
                    text_draw_centered("Invasions", map_center_x - 472, map_center_y - 260, 944, FONT_LARGE_BLACK, COLOR_BLACK);
                    for (int i = 0; i < MAX_INVASIONS; i++) {
                        int x, y;
                        if (i < 15) {
                            x = map_center_x - 447;
                            y = map_center_y - 212 + 30 * i;
                        } else if (i < 30) {
                            x = map_center_x - 149;
                            y = map_center_y - 212 + 30 * (i - 15);
                        } else {
                            x = map_center_x + 149;
                            y = map_center_y - 212 + 30 * (i - 30);
                        }
                        if (scenario.invasions[i].type) {
                            int width = text_draw(short_month_names[scenario.invasions[i].month], x + 12, y + 6, FONT_NORMAL_BLACK, COLOR_BLACK);
                            width += text_draw_year(scenario.start_year + scenario.invasions[i].year_offset, x + 6 + width, y + 6, FONT_NORMAL_BLACK);
                            width += text_draw_number(scenario.invasions[i].amount, 0, 0, x + 12 + width, y + 6, FONT_NORMAL_BLACK);
                            if (scenario.invasions[i].type == INVASION_TYPE_ENEMY_ARMY) {
                                text_draw(invasions_enemy_type_strings[scenario.invasions[i].enemy_type], x - 12 + width + (290 - width - text_get_width(invasions_enemy_type_strings[scenario.invasions[i].enemy_type], FONT_NORMAL_BLACK)), y + 6, FONT_NORMAL_BLACK, COLOR_BLACK);
                            } else {
                                text_draw(invasions_enemy_army_type_strings[scenario.invasions[i].type], x - 12 + width + (290 - width - text_get_width(invasions_enemy_army_type_strings[scenario.invasions[i].type], FONT_NORMAL_BLACK)), y + 6, FONT_NORMAL_BLACK, COLOR_BLACK);
                            }
                        } else {
                            text_draw_centered("Free slot", x, y + 6, 290, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                    }
                    refresh_current_window = 0;
                }
                for (int i = 0; i < MAX_INVASIONS; i++) {
                    int x, y;
                    if (i < 15) {
                        x = map_center_x - 447;
                        y = map_center_y - 212 + 30 * i;
                    } else if (i < 30) {
                        x = map_center_x - 149;
                        y = map_center_y - 212 + 30 * (i - 15);
                    } else {
                        x = map_center_x + 149;
                        y = map_center_y - 212 + 30 * (i - 30);
                    }
                    if (mouse_x >= x && mouse_x < x + 290 && mouse_y >= y && mouse_y < y + 25) {
                        button_border_draw(x, y, 290, 25, 1);
                    } else {
                        button_border_draw(x, y, 290, 25, 0);
                    }
                }
                break;
            case WINDOW_EDITOR_EDIT_INVASION:
                if (refresh_current_window) {
                    draw_editor_map();
                    outer_panel_draw(map_center_x - 192, map_center_y - 160, 24, 20);
                    text_draw_centered("Schedule an invasion", map_center_x - 192, map_center_y - 140, 384, FONT_LARGE_BLACK, COLOR_BLACK);
                    text_draw("Year offset:", map_center_x - 160, map_center_y - 92, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Month:", map_center_x - 160, map_center_y - 62, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Amount:", map_center_x - 160, map_center_y - 32, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Type:", map_center_x - 160, map_center_y - 2, FONT_NORMAL_BLACK, COLOR_BLACK);
                    if (scenario.invasions[id_edit_invasion].type) {
                        text_draw("Enemy type:", map_center_x - 160, map_center_y + 28, FONT_NORMAL_BLACK, COLOR_BLACK);
                        text_draw("From:", map_center_x - 160, map_center_y + 58, FONT_NORMAL_BLACK, COLOR_BLACK);
                        text_draw("Target type:", map_center_x - 160, map_center_y + 88, FONT_NORMAL_BLACK, COLOR_BLACK);
                    }
                    if (dropdown_list_selected == 1) {
                        outer_panel_draw(map_center_x + 125, map_center_y - 175, 8, 15);
                    } else if (dropdown_list_selected == 2) {
                        outer_panel_draw(map_center_x + 125, map_center_y - 52, 10, 7);
                    } else if (dropdown_list_selected == 3) {
                        outer_panel_draw(map_center_x + 125, map_center_y - 145, 10, 24);
                    } else if (dropdown_list_selected == 4) {
                        outer_panel_draw(map_center_x + 125, map_center_y - 30, 12, 12);
                    } else if (dropdown_list_selected == 5) {
                        outer_panel_draw(map_center_x + 125, map_center_y + 35, 12, 7);
                    }
                    refresh_current_window = 0;
                }
                for (int i = 0; i < 4; i++) {
                    if (!dropdown_list_selected && mouse_x >= map_center_x - 50 && mouse_x < map_center_x + 126
                    && mouse_y >= map_center_y - 101 + 30 * i && mouse_y < map_center_y - 71 + 30 * i) {
                        button_border_draw(map_center_x - 50, map_center_y - 101 + 30 * i, 176, 30, 1);
                    } else {
                        button_border_draw(map_center_x - 50, map_center_y - 101 + 30 * i, 176, 30, 0);
                    }
                }
                text_draw_number_centered_prefix(scenario.invasions[id_edit_invasion].year_offset, '+', map_center_x - 98, map_center_y - 92, 176, FONT_NORMAL_BLACK);
                text_draw_year(scenario.start_year + scenario.invasions[id_edit_invasion].year_offset, map_center_x + 30, map_center_y - 92, FONT_NORMAL_BLACK);
                text_draw_centered(short_month_names[scenario.invasions[id_edit_invasion].month], map_center_x - 50, map_center_y - 62, 176, FONT_NORMAL_BLACK, COLOR_BLACK);
                text_draw_number_centered(scenario.invasions[id_edit_invasion].amount, map_center_x - 50, map_center_y - 32, 176, FONT_NORMAL_BLACK);
                text_draw_centered(invasions_enemy_army_type_strings[scenario.invasions[id_edit_invasion].type], map_center_x - 50, map_center_y - 2, 176, FONT_NORMAL_BLACK, COLOR_BLACK);
                if (scenario.invasions[id_edit_invasion].type) {
                    if (scenario.invasions[id_edit_invasion].type > INVASION_TYPE_LOCAL_UPRISING) {
                        if (!dropdown_list_selected && mouse_x >= map_center_x - 50 && mouse_x < map_center_x + 126
                        && mouse_y >= map_center_y + 19 && mouse_y < map_center_y + 49) {
                            button_border_draw(map_center_x - 50, map_center_y + 19, 176, 30, 1);
                        } else {
                            button_border_draw(map_center_x - 50, map_center_y + 19, 176, 30, 0);
                        }
                    }
                    text_draw_centered(invasions_enemy_type_strings[scenario.invasions[id_edit_invasion].enemy_type], map_center_x - 50, map_center_y + 28, 176, FONT_NORMAL_BLACK, COLOR_BLACK);
                    for (int i = 0; i < 2; i++) {
                        if (!dropdown_list_selected && mouse_x >= map_center_x - 50 && mouse_x < map_center_x + 126
                        && mouse_y >= map_center_y + 49 + 30 * i && mouse_y < map_center_y + 79 + 30 * i) {
                            button_border_draw(map_center_x - 50, map_center_y + 49 + 30 * i, 176, 30, 1);
                        } else {
                            button_border_draw(map_center_x - 50, map_center_y + 49 + 30 * i, 176, 30, 0);
                        }
                    }
                    text_draw_centered(invasions_entry_points[scenario.invasions[id_edit_invasion].from], map_center_x - 50, map_center_y + 58, 176, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(invasions_target_types[scenario.invasions[id_edit_invasion].target_type], map_center_x - 50, map_center_y + 88, 176, FONT_NORMAL_BLACK, COLOR_BLACK);
                }
                if (text_field_active) {
                    draw_input_field(11, 2);
                }
                if (!dropdown_list_selected && mouse_x >= map_center_x - 88 && mouse_x < map_center_x + 88
                && mouse_y >= map_center_y + 118 && mouse_y < map_center_y + 148) {
                    button_border_draw(map_center_x - 88, map_center_y + 118, 176, 30, 1);
                } else {
                    button_border_draw(map_center_x - 88, map_center_y + 118, 176, 30, 0);
                }
                text_draw_centered("Unschedule invasion", map_center_x - 88, map_center_y + 127, 176, FONT_NORMAL_BLACK, COLOR_BLACK);
                if (dropdown_list_selected == 1) {
                    for (int i = 0; i < 12; i++) {
                        if (mouse_x >= map_center_x + 141 && mouse_x < map_center_x + 241
                        && mouse_y >= map_center_y - 159 + 18 * i && mouse_y < map_center_y - 141 + 18 * i) {
                            text_draw(long_month_names[i], map_center_x + 141, map_center_y - 159 + 18 * i, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                        } else {
                            text_draw(long_month_names[i], map_center_x + 141, map_center_y - 159 + 18 * i, FONT_NORMAL_PLAIN, COLOR_BLACK);
                        }
                    }
                } else if (dropdown_list_selected == 2) {
                    for (int i = 0; i < 5; i++) {
                        if (mouse_x >= map_center_x + 141 && mouse_x < map_center_x + 271
                        && mouse_y >= map_center_y - 36 + 18 * i && mouse_y < map_center_y - 18 + 18 * i) {
                            text_draw(invasions_enemy_army_type_strings[i], map_center_x + 141, map_center_y - 36 + 18 * i, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                        } else {
                            text_draw(invasions_enemy_army_type_strings[i], map_center_x + 141, map_center_y - 36 + 18 * i, FONT_NORMAL_PLAIN, COLOR_BLACK);
                        }
                    }
                } else if (dropdown_list_selected == 3) {
                    for (int i = 0; i < 20; i++) {
                        if (mouse_x >= map_center_x + 141 && mouse_x < map_center_x + 271
                        && mouse_y >= map_center_y - 129 + 18 * i && mouse_y < map_center_y - 111 + 18 * i) {
                            text_draw(invasions_enemy_type_strings[i], map_center_x + 141, map_center_y - 129 + 18 * i, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                        } else {
                            text_draw(invasions_enemy_type_strings[i], map_center_x + 141, map_center_y - 129 + 18 * i, FONT_NORMAL_PLAIN, COLOR_BLACK);
                        }
                    }
                } else if (dropdown_list_selected == 4) {
                    for (int i = 0; i < 9; i++) {
                        if (mouse_x >= map_center_x + 141 && mouse_x < map_center_x + 271
                        && mouse_y >= map_center_y - 14 + 18 * i && mouse_y < map_center_y + 4 + 18 * i) {
                            text_draw(invasions_entry_points[i], map_center_x + 141, map_center_y - 14 + 18 * i, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                        } else {
                            text_draw(invasions_entry_points[i], map_center_x + 141, map_center_y - 14 + 18 * i, FONT_NORMAL_PLAIN, COLOR_BLACK);
                        }
                    }
                } else if (dropdown_list_selected == 5) {
                    for (int i = 0; i < 5; i++) {
                        if (mouse_x >= map_center_x + 141 && mouse_x < map_center_x + 271
                        && mouse_y >= map_center_y + 51 + 18 * i && mouse_y < map_center_y + 69 + 18 * i) {
                            text_draw(invasions_target_types[i], map_center_x + 141, map_center_y + 51 + 18 * i, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                        } else {
                            text_draw(invasions_target_types[i], map_center_x + 141, map_center_y + 51 + 18 * i, FONT_NORMAL_PLAIN, COLOR_BLACK);
                        }
                    }
                }
                break;
            case WINDOW_EDITOR_PRICE_CHANGES:
                if (refresh_current_window) {
                    outer_panel_draw(map_center_x - 472, map_center_y - 280, 59, 35);
                    text_draw_centered("Price changes", map_center_x - 472, map_center_y - 260, 944, FONT_LARGE_BLACK, COLOR_BLACK);
                    for (int i = 0; i < MAX_PRICE_CHANGES; i++) {
                        int x, y;
                        if (i < 15) {
                            x = map_center_x - 447;
                            y = map_center_y - 212 + 30 * i;
                        } else if (i < 30) {
                            x = map_center_x - 149;
                            y = map_center_y - 212 + 30 * (i - 15);
                        } else {
                            x = map_center_x + 149;
                            y = map_center_y - 212 + 30 * (i - 30);
                        }
                        if (scenario.price_changes[i].resource) {
                            int width = text_draw(short_month_names[scenario.price_changes[i].month], x + 12, y + 6, FONT_NORMAL_BLACK, COLOR_BLACK);
                            width += text_draw_year(scenario.start_year + scenario.price_changes[i].year_offset, x + 6 + width, y + 6, FONT_NORMAL_BLACK);
                            image_draw(resource_images[scenario.price_changes[i].resource].editor_icon_img_id + resource_image_offset(scenario.price_changes[i].resource, RESOURCE_IMAGE_ICON), x + 12 + width, y + 3);
                            width += text_draw(scenario.price_changes[i].is_rise ? "rises by" : "falls by", x + 45 + width, y + 6, FONT_NORMAL_BLACK, COLOR_BLACK);
                            text_draw_number(scenario.price_changes[i].amount, 0, 0, x + 45 + width, y + 6, FONT_NORMAL_BLACK);
                        } else {
                            text_draw_centered("Free slot", x, y + 6, 290, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                    }
                    refresh_current_window = 0;
                }
                for (int i = 0; i < MAX_PRICE_CHANGES; i++) {
                    int x, y;
                    if (i < 15) {
                        x = map_center_x - 447;
                        y = map_center_y - 212 + 30 * i;
                    } else if (i < 30) {
                        x = map_center_x - 149;
                        y = map_center_y - 212 + 30 * (i - 15);
                    } else {
                        x = map_center_x + 149;
                        y = map_center_y - 212 + 30 * (i - 30);
                    }
                    if (mouse_x >= x && mouse_x < x + 290 && mouse_y >= y && mouse_y < y + 25) {
                        button_border_draw(x, y, 290, 25, 1);
                    } else {
                        button_border_draw(x, y, 290, 25, 0);
                    }
                }
                break;
            case WINDOW_EDITOR_EDIT_PRICE_CHANGE:
                if (refresh_current_window) {
                    draw_editor_map();
                    outer_panel_draw(map_center_x - 232, map_center_y - 104, 29, 13);
                    text_draw_centered("Schedule a price change", map_center_x - 232, map_center_y - 84, 464, FONT_LARGE_BLACK, COLOR_BLACK);
                    text_draw("Year offset:", map_center_x - 200, map_center_y - 35, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number_centered_prefix(scenario.price_changes[id_edit_price_change].year_offset, '+', map_center_x - 90, map_center_y - 35, 112, FONT_NORMAL_BLACK);
                    text_draw_year(scenario.start_year + scenario.price_changes[id_edit_price_change].year_offset, map_center_x + 35, map_center_y - 35, FONT_NORMAL_BLACK);
                    text_draw("Month:", map_center_x - 200, map_center_y - 5, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(short_month_names[scenario.price_changes[id_edit_price_change].month], map_center_x - 90, map_center_y - 5, 112, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Resource:", map_center_x - 200, map_center_y + 25, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(resource_strings[scenario.price_changes[id_edit_price_change].resource], map_center_x - 90, map_center_y + 25, 112, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(scenario.price_changes[id_edit_price_change].is_rise ? "rises by" : "falls by", map_center_x + 38, map_center_y + 25, 96, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number_centered(scenario.price_changes[id_edit_price_change].amount, map_center_x + 150, map_center_y + 25, 48, FONT_NORMAL_BLACK);
                    text_draw_centered("Unschedule request", map_center_x - 88, map_center_y + 65, 176, FONT_NORMAL_BLACK, COLOR_BLACK);
                    refresh_current_window = 0;
                }
                for (int i = 0; i < 3; i++) {
                    if (!text_field_active && !dropdown_list_selected
                    && mouse_x >= map_center_x - 90 && mouse_x < map_center_x + 22
                    && mouse_y >= map_center_y - 44 + 30 * i && mouse_y < map_center_y - 14 + 30 * i) {
                        button_border_draw(map_center_x - 90, map_center_y - 44 + 30 * i, 112, 30, 1);
                    } else {
                        button_border_draw(map_center_x - 90, map_center_y - 44 + 30 * i, 112, 30, 0);
                    }
                }
                if (!text_field_active && !dropdown_list_selected
                && mouse_x >= map_center_x + 38 && mouse_x < map_center_x + 134
                && mouse_y >= map_center_y + 16 && mouse_y < map_center_y + 46) {
                    button_border_draw(map_center_x + 38, map_center_y + 16, 96, 30, 1);
                } else {
                    button_border_draw(map_center_x + 38, map_center_y + 16, 96, 30, 0);
                }
                if (!text_field_active && !dropdown_list_selected
                && mouse_x >= map_center_x + 150 && mouse_x < map_center_x + 198
                && mouse_y >= map_center_y + 16 && mouse_y < map_center_y + 46) {
                    button_border_draw(map_center_x + 150, map_center_y + 16, 48, 30, 1);
                } else {
                    button_border_draw(map_center_x + 150, map_center_y + 16, 48, 30, 0);
                }
                if (!text_field_active && !dropdown_list_selected
                && mouse_x >= map_center_x - 88 && mouse_x < map_center_x + 88
                && mouse_y >= map_center_y + 56 && mouse_y < map_center_y + 86) {
                    button_border_draw(map_center_x - 88, map_center_y + 56, 176, 30, 1);
                } else {
                    button_border_draw(map_center_x - 88, map_center_y + 56, 176, 30, 0);
                }
                if (text_field_active == 1) {
                    draw_input_field(7, 2);
                } else if (text_field_active == 2) {
                    draw_input_field(3, 2);
                }
                if (dropdown_list_selected == 1) {
                    outer_panel_draw(map_center_x + 21, map_center_y - 120, 8, 15);
                    for (int i = 0; i < 12; i++) {
                        if (mouse_x >= map_center_x + 37 && mouse_x < map_center_x + 137
                        && mouse_y >= map_center_y - 104 + 18 * i && mouse_y < map_center_y - 86 + 18 * i) {
                            text_draw(long_month_names[i], map_center_x + 37, map_center_y - 104 + 18 * i, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                        } else {
                            text_draw(long_month_names[i], map_center_x + 37, map_center_y - 104 + 18 * i, FONT_NORMAL_PLAIN, COLOR_BLACK);
                        }
                    }
                } else if (dropdown_list_selected == 2) {
                    outer_panel_draw(map_center_x + 21, map_center_y - 128, 8, 20);
                    for (int i = 0; i < 16; i++) {
                        if (mouse_x >= map_center_x + 37 && mouse_x < map_center_x + 137
                        && mouse_y >= map_center_y - 112 + 18 * i && mouse_y < map_center_y - 94 + 18 * i) {
                            text_draw(resource_strings[i], map_center_x + 37, map_center_y - 112 + 18 * i, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                        } else {
                            text_draw(resource_strings[i], map_center_x + 37, map_center_y - 112 + 18 * i, FONT_NORMAL_PLAIN, COLOR_BLACK);
                        }
                    }
                }
                break;
            case WINDOW_EDITOR_DEMAND_CHANGES:
                if (refresh_current_window) {
                    outer_panel_draw(map_center_x - 472, map_center_y - 280, 59, 35);
                    text_draw_centered("Demand changes", map_center_x - 472, map_center_y - 260, 944, FONT_LARGE_BLACK, COLOR_BLACK);
                    for (int i = 0; i < MAX_DEMAND_CHANGES; i++) {
                        int x, y;
                        if (i < 15) {
                            x = map_center_x - 447;
                            y = map_center_y - 212 + 30 * i;
                        } else if (i < 30) {
                            x = map_center_x - 149;
                            y = map_center_y - 212 + 30 * (i - 15);
                        } else {
                            x = map_center_x + 149;
                            y = map_center_y - 212 + 30 * (i - 30);
                        }
                        if (scenario.demand_changes[i].resource && scenario.demand_changes[i].trade_city_id) {
                            int width = text_draw(short_month_names[scenario.demand_changes[i].month], x + 12, y + 6, FONT_NORMAL_BLACK, COLOR_BLACK);
                            width += text_draw_year(scenario.start_year + scenario.demand_changes[i].year_offset, x + 6 + width, y + 6, FONT_NORMAL_BLACK);
                            image_draw(resource_images[scenario.demand_changes[i].resource].editor_icon_img_id + resource_image_offset(scenario.demand_changes[i].resource, RESOURCE_IMAGE_ICON), x + 12 + width, y + 3);
                            width += text_draw("in route", x + 45 + width, y + 6, FONT_NORMAL_BLACK, COLOR_BLACK);
                            width += text_draw_number(scenario.demand_changes[i].trade_city_id, 0, 0, x + 45 + width, y + 6, FONT_NORMAL_BLACK);
                            text_draw(scenario.demand_changes[i].is_rise ? "rises" : "falls", x + 45 + width, y + 6, FONT_NORMAL_BLACK, COLOR_BLACK);
                        } else {
                            text_draw_centered("Free slot", x, y + 6, 290, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                    }
                    refresh_current_window = 0;
                }
                for (int i = 0; i < MAX_DEMAND_CHANGES; i++) {
                    int x, y;
                    if (i < 15) {
                        x = map_center_x - 447;
                        y = map_center_y - 212 + 30 * i;
                    } else if (i < 30) {
                        x = map_center_x - 149;
                        y = map_center_y - 212 + 30 * (i - 15);
                    } else {
                        x = map_center_x + 149;
                        y = map_center_y - 212 + 30 * (i - 30);
                    }
                    if (mouse_x >= x && mouse_x < x + 290 && mouse_y >= y && mouse_y < y + 25) {
                        button_border_draw(x, y, 290, 25, 1);
                    } else {
                        button_border_draw(x, y, 290, 25, 0);
                    }
                }
                break;
            case WINDOW_EDITOR_EDIT_DEMAND_CHANGE:
                if (refresh_current_window) {
                    draw_editor_map();
                    outer_panel_draw(map_center_x - 208, map_center_y - 136, 26, 17);
                    text_draw_centered("Schedule a demand change", map_center_x - 208, map_center_y - 116, 416, FONT_LARGE_BLACK, COLOR_BLACK);
                    text_draw("Year offset:", map_center_x - 176, map_center_y - 68, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_number_centered_prefix(scenario.demand_changes[id_demand_route].year_offset, '+', map_center_x - 68, map_center_y - 68, 128, FONT_NORMAL_BLACK);
                    text_draw_year(scenario.start_year + scenario.demand_changes[id_demand_route].year_offset, map_center_x + 76, map_center_y - 68, FONT_NORMAL_BLACK);
                    text_draw("Month:", map_center_x - 176, map_center_y - 38, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(short_month_names[scenario.demand_changes[id_demand_route].month], map_center_x - 68, map_center_y - 38, 128, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("Resource:", map_center_x - 176, map_center_y - 8, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(resource_strings[scenario.demand_changes[id_demand_route].resource], map_center_x - 68, map_center_y - 8, 128, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw("In route:", map_center_x - 176, map_center_y + 24, FONT_NORMAL_BLACK, COLOR_BLACK);
                    if (scenario.demand_changes[id_demand_route].trade_city_id) {
                        text_draw_centered(route_display_names[reusable_int], map_center_x - 68, map_center_y + 22, 208, FONT_NORMAL_BLACK, COLOR_BLACK);
                        reusable_int = 0;
                    }
                    if (dropdown_list_selected == 3) {
                        outer_panel_draw(map_center_x + 135, map_center_y + 13, 12, demand_routes_num_routes + 2);
                    }
                    text_draw("Demand for this good:", map_center_x - 176, map_center_y + 54, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered(scenario.demand_changes[id_demand_route].is_rise ? "rises" : "falls", map_center_x + 12, map_center_y + 52, 128, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered("Cancel demand change", map_center_x - 128, map_center_y + 92, 256, FONT_NORMAL_BLACK, COLOR_BLACK);
                    refresh_current_window = 0;
                }
                for (int i = 0; i < 3; i++) {
                    if (!text_field_active && !dropdown_list_selected
                    && mouse_x >= map_center_x - 68 && mouse_x < map_center_x + 60
                    && mouse_y >= map_center_y - 77 + 30 * i && mouse_y < map_center_y - 47 + 30 * i) {
                        button_border_draw(map_center_x - 68, map_center_y - 77 + 30 * i, 128, 30, 1);
                    } else {
                        button_border_draw(map_center_x - 68, map_center_y - 77 + 30 * i, 128, 30, 0);
                    }
                }
                if (!text_field_active && !dropdown_list_selected
                && mouse_x >= map_center_x - 68 && mouse_x < map_center_x + 140
                && mouse_y >= map_center_y + 13 && mouse_y < map_center_y + 43) {
                    button_border_draw(map_center_x - 68, map_center_y + 13, 208, 30, 1);
                } else {
                    button_border_draw(map_center_x - 68, map_center_y + 13, 208, 30, 0);
                }
                if (!text_field_active && !dropdown_list_selected
                && mouse_x >= map_center_x + 12 && mouse_x < map_center_x + 140
                && mouse_y >= map_center_y + 43 && mouse_y < map_center_y + 73) {
                    button_border_draw(map_center_x + 12, map_center_y + 43, 128, 30, 1);
                } else {
                    button_border_draw(map_center_x + 12, map_center_y + 43, 128, 30, 0);
                }
                if (!text_field_active && !dropdown_list_selected
                && mouse_x >= map_center_x - 128 && mouse_x < map_center_x + 128
                && mouse_y >= map_center_y + 83 && mouse_y < map_center_y + 113) {
                    button_border_draw(map_center_x - 128, map_center_y + 83, 256, 30, 1);
                } else {
                    button_border_draw(map_center_x - 128, map_center_y + 83, 256, 30, 0);
                }
                if (text_field_active) {
                    draw_input_field(8, 2);
                }
                if (dropdown_list_selected == 1) {
                    outer_panel_draw(map_center_x + 59, map_center_y - 154, 8, 15);
                    for (int i = 0; i < 12; i++) {
                        if (mouse_x >= map_center_x + 75 && mouse_x < map_center_x + 175
                        && mouse_y >= map_center_y - 138 + 18 * i && mouse_y < map_center_y - 120 + 18 * i) {
                            text_draw(long_month_names[i], map_center_x + 75, map_center_y - 138 + 18 * i, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                        } else {
                            text_draw(long_month_names[i], map_center_x + 75, map_center_y - 138 + 18 * i, FONT_NORMAL_PLAIN, COLOR_BLACK);
                        }
                    }
                } else if (dropdown_list_selected == 2) {
                    outer_panel_draw(map_center_x + 59, map_center_y - 162, 8, 20);
                    for (int i = 0; i < 16; i++) {
                        if (mouse_x >= map_center_x + 75 && mouse_x < map_center_x + 175
                        && mouse_y >= map_center_y - 146 + 18 * i && mouse_y < map_center_y - 128 + 18 * i) {
                            text_draw(resource_strings[i], map_center_x + 75, map_center_y - 146 + 18 * i, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                        } else {
                            text_draw(resource_strings[i], map_center_x + 75, map_center_y - 146 + 18 * i, FONT_NORMAL_PLAIN, COLOR_BLACK);
                        }
                    }
                } else if (dropdown_list_selected == 3) {
                    for (int i = 0; i < demand_routes_num_routes; i++) {
                        if (mouse_x >= map_center_x + 151 && mouse_x < map_center_x + 311
                        && mouse_y >= map_center_y + 29 + 18 * i && mouse_y < map_center_y + 47 + 18 * i) {
                            text_draw(route_display_names[i], map_center_x + 151, map_center_y + 29 + 18 * i, FONT_NORMAL_PLAIN, COLOR_FONT_ORANGE);
                        } else {
                            text_draw(route_display_names[i], map_center_x + 151, map_center_y + 29 + 18 * i, FONT_NORMAL_PLAIN, COLOR_BLACK);
                        }
                    }
                }
                break;
            case WINDOW_EDITOR_EMPIRE:
                if (refresh_current_window) {
                    empire_x_min = current_resolution_width <= 2032 ? 0 : (current_resolution_width - 2032) / 2; // the_empire.bmp width = 2000, vertical borders = 16*2=32 
                    empire_x_max = current_resolution_width <= 2032 ? current_resolution_width : empire_x_min + 2032;
                    empire_y_min = current_resolution_height <= 1168 ? 0 : (current_resolution_height - 1168) / 2; // the_empire.bmp height = 1000, horizontal bars = 3*16, bottom panel = 3*40, altogether 168
                    empire_y_max = current_resolution_height <= 1168 ? current_resolution_height : empire_y_min + 1168;
                    graphics_set_clip_rectangle(empire_x_min, empire_y_min, empire_x_max - empire_x_min, empire_y_max - empire_y_min);
                    // bottom panel background
                    for (int x = empire_x_min + 16; x < empire_x_max - 16; x += 70) {
                        image_draw(3226, x, empire_y_max - 136);
                        image_draw(3226, x, empire_y_max - 96);
                        image_draw(3226, x, empire_y_max - 56);
                    }
                    // vertical bar borders
                    for (int y = empire_y_min + 16; y < empire_y_max - 16; y += 86) {
                        image_draw(3223, empire_x_min, y);
                        image_draw(3223, empire_x_max - 16, y);
                    }
                    // horizontal bar borders
                    for (int x = empire_x_min + 16; x < empire_x_max - 16; x += 86) {
                        image_draw(3224, x, empire_y_min);
                        image_draw(3224, x, empire_y_max - 152);
                        image_draw(3224, x, empire_y_max - 16);
                    }
                    // crossbars
                    image_draw(3225, empire_x_min, empire_y_min); // top left
                    image_draw(3225, empire_x_min, empire_y_max - 152); // bottom left above bottom panel
                    image_draw(3225, empire_x_min, empire_y_max - 16); // bottom left below bottom panel
                    image_draw(3225, empire_x_max - 16, empire_y_min); // top right
                    image_draw(3225, empire_x_max - 16, empire_y_max - 152); // bottom right above bottom panel
                    image_draw(3225, empire_x_max - 16, empire_y_max - 16); // bottom right below bottom panel
                    graphics_reset_clip_rectangle();
                    refresh_current_window = 0;
                }
                scroll_empire_arrow_keys();
                graphics_set_clip_rectangle(empire_x_min + 16, empire_y_min + 16, empire_x_max - empire_x_min - 32, empire_y_max - empire_y_min - 168);
                image_draw(3222, empire_x_min + 16 - empire_data.scroll_x, empire_y_min + 16 - empire_data.scroll_y); // draw the_empire.bmp
                for (int i = 0; i < MAX_EMPIRE_OBJECTS; i++) {
                    if (empire_objects[i].in_use) {
                        // don't draw trade route if trade city switched to non-trade city
                        if (empire_objects[i].type == EMPIRE_OBJECT_LAND_TRADE_ROUTE || empire_objects[i].type == EMPIRE_OBJECT_SEA_TRADE_ROUTE) {
                            struct empire_object_t *trade_city = get_trade_city_by_trade_route(empire_objects[i].trade_route_id);
                            if (!trade_city) {
                                continue;
                            }
                        }
                        if (!empire_editor_show_battle_objects && (
                            empire_objects[i].type == EMPIRE_OBJECT_BATTLE_ICON ||
                            empire_objects[i].type == EMPIRE_OBJECT_ROMAN_ARMY ||
                            empire_objects[i].type == EMPIRE_OBJECT_ENEMY_ARMY)) {
                            continue;
                        }
                        if (empire_objects[i].type == EMPIRE_OBJECT_BATTLE_ICON) {
                            draw_shadowed_number(empire_objects[i].invasion_path_id, empire_x_min + 16 + empire_objects[i].x - 9 - empire_data.scroll_x, empire_y_min + 16 + empire_objects[i].y - 9 - empire_data.scroll_y, COLOR_WHITE);
                            draw_shadowed_number(empire_objects[i].invasion_years, empire_x_min + 16 + empire_objects[i].x + 15 - empire_data.scroll_x, empire_y_min + 16 + empire_objects[i].y - 9 - empire_data.scroll_y, COLOR_FONT_RED);
                        } else if (empire_objects[i].type == EMPIRE_OBJECT_ROMAN_ARMY || empire_objects[i].type == EMPIRE_OBJECT_ENEMY_ARMY) {
                            draw_shadowed_number(empire_objects[i].distant_battle_travel_months, empire_x_min + 16 + empire_objects[i].x + 7 - empire_data.scroll_x, empire_y_min + 16 + empire_objects[i].y - 9 - empire_data.scroll_y,
                                empire_objects[i].type == EMPIRE_OBJECT_ROMAN_ARMY ? COLOR_WHITE : COLOR_FONT_RED);
                        }
                        image_draw(empire_objects[i].image_id, empire_x_min + 16 + empire_objects[i].x - empire_data.scroll_x, empire_y_min + 16 + empire_objects[i].y - empire_data.scroll_y);
                        struct image_t *img = image_get(empire_objects[i].image_id);
                        if (img->animation_speed_id) {
                            image_draw(empire_objects[i].image_id + empire_object_update_animation(&empire_objects[i], empire_objects[i].image_id),
                                empire_x_min + 16 + empire_objects[i].x + img->sprite_offset_x - empire_data.scroll_x,
                                empire_y_min + 16 + empire_objects[i].y + img->sprite_offset_y - empire_data.scroll_y);
                        }
                    }
                }
                graphics_reset_clip_rectangle();
                if (selected_empire_object && selected_empire_object->type == EMPIRE_OBJECT_CITY) {
                    // draw city info
                    int width = text_draw(city_names[selected_empire_object->city_name_id], empire_x_min + 28, empire_y_max - 103, FONT_NORMAL_WHITE, COLOR_BLACK);
                    switch (selected_empire_object->city_type) {
                        case EMPIRE_CITY_OURS:
                            width += text_draw("Our city!", empire_x_min + 44 + width, empire_y_max - 103, FONT_NORMAL_GREEN, COLOR_BLACK);
                            // draw icons for available resources based on the "Allowed buildings" menu
                            for (int r = RESOURCE_WHEAT; r < RESOURCE_TYPES_MAX; r++) {
                                if (selected_empire_object->resource_sell_limit[r]) {
                                    image_draw(resource_images[r].editor_empire_icon_img_id + resource_image_offset(r, RESOURCE_IMAGE_ICON), empire_x_min + 58 + width + 32 * (r - 1), empire_y_max - 108);
                                }
                            }
                            break;
                        case EMPIRE_CITY_TRADE:
                            width += text_draw("A trade city", empire_x_min + 44 + width, empire_y_max - 103, FONT_NORMAL_GREEN, 0);
                            empire_editor_city_type_arrow_x = empire_x_min + 50 + width;
                            draw_trade_city_info_editor_empire();
                            break;
                        case EMPIRE_CITY_FUTURE_TRADE:
                            width += text_draw("A future trade city", empire_x_min + 44 + width, empire_y_max - 103, FONT_NORMAL_GREEN, 0);
                            empire_editor_city_type_arrow_x = empire_x_min + 50 + width;
                            draw_trade_city_info_editor_empire();
                            // draw empire expansion year (offset from scenario start year)
                            text_draw("Expansion year offset:", empire_editor_resource_toggle_x + 500, empire_y_max - 63, FONT_NORMAL_GREEN, 0);
                            if (mouse_x >= empire_editor_resource_toggle_x + 683 && mouse_x < empire_editor_resource_toggle_x + 731
                            && mouse_y >= empire_y_max - 68 && mouse_y < empire_y_max - 44) {
                                button_border_draw(empire_editor_resource_toggle_x + 683, empire_y_max - 68, 48, 24, 1);
                            } else {
                                button_border_draw(empire_editor_resource_toggle_x + 683, empire_y_max - 68, 48, 24, 0);
                            }
                            text_draw_number_centered(scenario.empire.expansion_year, empire_editor_resource_toggle_x + 683, empire_y_max - 62, 48, FONT_NORMAL_GREEN);
                            if (text_field_active == 2) {
                                draw_input_field(3, 2);
                            }
                            break;
                        case EMPIRE_CITY_DISTANT_ROMAN:
                        case EMPIRE_CITY_VULNERABLE_ROMAN:
                            width += text_draw("A Roman city", empire_x_min + 44 + width, empire_y_max - 103, FONT_NORMAL_GREEN, COLOR_BLACK);
                            if (selected_empire_object->trade_route_id) {
                                empire_editor_city_type_arrow_x = empire_x_min + 50 + width;
                                draw_arrow_button(21, empire_editor_city_type_arrow_x, empire_y_max - 108, 3);
                            }
                            break;
                        case EMPIRE_CITY_DISTANT_FOREIGN:
                        case EMPIRE_CITY_FUTURE_ROMAN:
                            text_draw("A distant city", empire_x_min + 44 + width, empire_y_max - 103, FONT_NORMAL_GREEN, COLOR_BLACK);
                            break;
                    }
                } else {
                    char *empire_states_strings[] = {
                        "Empire state 1: Lugdunum",
                        "Empire state 2: Corinthus",
                        "Empire state 3: Londinium",
                        "Empire state 4: Mediolanum",
                        "Empire state 5: Lindum",
                        "Empire state 6: Toletum",
                        "Empire state 7: Valentia",
                        "Empire state 8: Caesarea",
                        "Empire state 9: Carthago",
                        "Empire state 10: Cyrene",
                        "Empire state 11: Tarraco",
                        "Empire state 12: Hierosolyma",
                        "Empire state 13: Mediolanum II",
                        "Empire state 14: Syracusae",
                        "Empire state 15: Tarraco II",
                        "Empire state 16: Tarsus",
                        "Empire state 17: Tingis",
                        "Empire state 18: Augusta Trevorum",
                        "Empire state 19: Carthago Nova",
                        "Empire state 20: Leptis Magna",
                        "Empire state 21: Athenae",
                        "Empire state 22: Brundisium",
                        "Empire state 23: Capua",
                        "Empire state 24: Tarentum",
                        "Empire state 25: Tarraco II",
                        "Empire state 26: Syracusae II",
                        "Empire state 27: Miletus",
                        "Empire state 28: Mediolanum III",
                        "Empire state 29: Lugdunum II",
                        "Empire state 30: Carthago II",
                        "Empire state 31: Tarsus II",
                        "Empire state 32: Tingis II",
                        "Empire state 33: Valentia II",
                        "Empire state 34: Lutetia",
                        "Empire state 35: Caesarea II",
                        "Empire state 36: Sarmizegetusa",
                        "Empire state 37: Londinium II",
                        "Empire state 38: Damascus",
                        "Empire state 39: Massilia",
                        "Empire state 40: Lindum II",
                    };
                    text_draw_centered(empire_states_strings[scenario.empire.id], empire_x_min, empire_y_max - 103, empire_x_max - empire_x_min, FONT_NORMAL_GREEN, COLOR_BLACK);
                    draw_arrow_button(15, screen_center_x - 24, empire_y_max - 69, 1);
                    draw_arrow_button(17, screen_center_x, empire_y_max - 69, 2);
                }
                break;
            case WINDOW_CONFIGS:
                if (refresh_current_window) {
                    image_draw_scaled(MAIN_MENU_BACKGROUND_IMG_ID, 0, 0, current_resolution_width, current_resolution_height);
                    text_draw(VERSION, 24, current_resolution_height - 24, FONT_SMALL_PLAIN, COLOR_FONT_LIGHT_GRAY);
                    outer_panel_draw(screen_center_x - 248, screen_center_y - 184, 31, 23);
                    text_draw_centered("Brutus configuration options", screen_center_x - 248, screen_center_y - 164, 496, FONT_LARGE_BLACK, 0);
                    text_draw("Player name:", screen_center_x - 216, screen_center_y - 116, FONT_NORMAL_BLACK, COLOR_BLACK);
                    inner_panel_draw(screen_center_x - 216, screen_center_y - 92, 23, 2);
                    text_draw(configs_player_name, screen_center_x - 206, screen_center_y - 82, FONT_NORMAL_WHITE, COLOR_BLACK);
                    for (int i = 0; i < CONFIGS_MAX_ENTRIES; i++) {
                        if (configs[i].config_value) {
                            text_draw("x", screen_center_x - 209, screen_center_y - 48 + 22 * i, FONT_NORMAL_BLACK, COLOR_BLACK);
                        }
                        text_draw(configs[i].config_string, screen_center_x - 184, screen_center_y - 48 + 22 * i, FONT_NORMAL_BLACK, COLOR_BLACK);
                    }
                    text_draw_centered("Configure hotkeys", screen_center_x - 205, screen_center_y + 135, 180, FONT_NORMAL_BLACK, COLOR_BLACK);
                    text_draw_centered("Reset defaults", screen_center_x + 25, screen_center_y + 135, 180, FONT_NORMAL_BLACK, COLOR_BLACK);
                    refresh_current_window = 0;
                }
                if (text_field_active) {
                    draw_input_field(23, 2);
                }
                for (int i = 0; i < CONFIGS_MAX_ENTRIES; i++) {
                    if (mouse_x >= screen_center_x - 216 && mouse_x < screen_center_x - 194
                    && mouse_y >= screen_center_y - 52 + 22 * i && mouse_y < screen_center_y - 30 + 22 * i) {
                        button_border_draw(screen_center_x - 216, screen_center_y - 52 + 22 * i, 22, 22, 1);
                    } else {
                        button_border_draw(screen_center_x - 216, screen_center_y - 52 + 22 * i, 22, 22, 0);
                    }
                }
                if (mouse_x >= screen_center_x - 205 && mouse_x < screen_center_x - 25
                && mouse_y >= screen_center_y + 126 && mouse_y < screen_center_y + 156) {
                    button_border_draw(screen_center_x - 205, screen_center_y + 126, 180, 30, 1);
                } else {
                    button_border_draw(screen_center_x - 205, screen_center_y + 126, 180, 30, 0);
                }
                if (mouse_x >= screen_center_x + 25 && mouse_x < screen_center_x + 205
                && mouse_y >= screen_center_y + 126 && mouse_y < screen_center_y + 156) {
                    button_border_draw(screen_center_x + 25, screen_center_y + 126, 180, 30, 1);
                } else {
                    button_border_draw(screen_center_x + 25, screen_center_y + 126, 180, 30, 0);
                }
                break;
            case WINDOW_HOTKEY_CONFIGS:
                if (refresh_current_window) {
                    image_draw_scaled(MAIN_MENU_BACKGROUND_IMG_ID, 0, 0, current_resolution_width, current_resolution_height);
                    text_draw(VERSION, 24, current_resolution_height - 24, FONT_SMALL_PLAIN, COLOR_FONT_LIGHT_GRAY);
                    outer_panel_draw(screen_center_x - 320, screen_center_y - 336, 40, 42);
                    text_draw_centered("Brutus hotkey configuration", screen_center_x - 320, screen_center_y - 316, 640, FONT_LARGE_BLACK, COLOR_BLACK);
                    inner_panel_draw(screen_center_x - 288, screen_center_y - 268, 36, 33);
                    for (int i = 0; i < HOTKEY_CONFIGS_NUM_VISIBLE_ROWS; i++) {
                        int current_pos = i + scrollbar_position;
                        if (hotkey_mappings[current_pos].is_header) {
                            text_draw(hotkey_mappings[current_pos].action_name, screen_center_x - 272, screen_center_y - 243 + 24 * i, FONT_NORMAL_WHITE, COLOR_BLACK);
                        } else {
                            text_draw(hotkey_mappings[current_pos].action_name, screen_center_x - 264, screen_center_y - 243 + 24 * i, FONT_NORMAL_GREEN, COLOR_BLACK);
                        }
                        if (hotkey_mappings[current_pos].sdl_key) {
                            char hotkey_name[100] = { 0 };
                            for (int j = 0; j < 4; j++) {
                                if (hotkey_mappings[current_pos].sdl_mods & modifier_names[j].modifier) {
                                    strcat(hotkey_name, modifier_names[j].name);
                                    strcat(hotkey_name, " ");
                                }
                            }
                            char *key_name = SDL_GetKeyName(hotkey_mappings[current_pos].sdl_key);
                            adjust_key_display_name(&key_name);
                            strcat(hotkey_name, key_name);
                            text_draw_centered(hotkey_name, screen_center_x, screen_center_y - 243 + 24 * i, 230, FONT_NORMAL_WHITE, COLOR_BLACK);
                        }
                    }
                    text_draw_centered("Reset defaults", screen_center_x - 90, screen_center_y + 285, 180, FONT_NORMAL_BLACK, COLOR_BLACK);
                    refresh_current_window = 0;
                }
                draw_scrollbar(screen_center_x + 247, screen_center_y - 241, 473, HOTKEY_CONFIGS_NUMBER_ROWS - HOTKEY_CONFIGS_NUM_VISIBLE_ROWS);
                for (int i = 0; i < HOTKEY_CONFIGS_NUM_VISIBLE_ROWS; i++) {
                    if (!hotkey_mappings[i + scrollbar_position].is_header) {
                        if (mouse_x >= screen_center_x && mouse_x <= screen_center_x + 230
                        && mouse_y >= screen_center_y - 249 + 24 * i && mouse_y <= screen_center_y - 227 + 24 * i) {
                            button_border_draw(screen_center_x, screen_center_y - 249 + 24 * i, 230, 22, 1);
                        } else {
                            button_border_draw(screen_center_x, screen_center_y - 249 + 24 * i, 230, 22, 0);
                        }
                    }
                }
                if (mouse_x >= screen_center_x - 90 && mouse_x < screen_center_x + 90
                && mouse_y >= screen_center_y + 276 && mouse_y < screen_center_y + 306) {
                    button_border_draw(screen_center_x - 90, screen_center_y + 276, 180, 30, 1);
                } else {
                    button_border_draw(screen_center_x - 90, screen_center_y + 276, 180, 30, 0);
                }
                break;
            case WINDOW_HOTKEY_EDITOR:
                if (refresh_current_window) {
                    outer_panel_draw(screen_center_x - 192, screen_center_y - 72, 24, 9);
                    text_draw_centered("Press new hotkey", screen_center_x - 192, screen_center_y - 52, 384, FONT_LARGE_BLACK, COLOR_BLACK);
                    text_draw_centered("Enter to confirm", screen_center_x - 192, screen_center_y + 32, 384, FONT_NORMAL_BLACK, COLOR_BLACK);
                    refresh_current_window = 0;
                }
                inner_panel_draw(screen_center_x - 128, screen_center_y - 12, 16, 2);
                char hotkey_name[100] = { 0 };
                for (int j = 0; j < 4; j++) {
                    if (hotkey_config_window_data.modifiers & modifier_names[j].modifier) {
                        strcat(hotkey_name, modifier_names[j].name);
                        strcat(hotkey_name, " ");
                    }
                }
                char *key_name = SDL_GetKeyName(hotkey_config_window_data.key);
                adjust_key_display_name(&key_name);
                strcat(hotkey_name, key_name);
                text_draw_centered(hotkey_name, screen_center_x - 128, screen_center_y - 4, 256, FONT_NORMAL_WHITE, COLOR_BLACK);
                break;
        }
        game_run();
        if (current_window != WINDOW_CITY && current_window != WINDOW_EDITOR_MAP) {
            clear_all_warnings();
        } else {
            for (int i = 0; i < MAX_WARNINGS; i++) {
                char *text = 0;
                if (warnings[i].in_use) {
                    text = warnings[i].text;
                }
                if (!text) {
                    continue;
                }
                int top_offset = 30 + i * 25;
                if (state_data.paused) {
                    top_offset += 70;
                }
                int box_width = 0;
                int width = text_get_width(text, FONT_NORMAL_BLACK);
                if (width <= 100) {
                    box_width = 200;
                } else if (width <= 200) {
                    box_width = 300;
                } else if (width <= 300) {
                    box_width = 400;
                } else {
                    box_width = 460;
                }
                draw_label(map_center_x - box_width / 2 + 1, top_offset, box_width, 0, 0);
                if (box_width < 460) {
                    // ornaments at the side
                    image_draw(1413, map_center_x - box_width / 2 + 2, top_offset + 2);
                    image_draw(1413, map_center_x + box_width / 2 - 30, top_offset + 2);
                }
                text_draw_centered(text, map_center_x - box_width / 2 + 1, top_offset + 4, box_width, FONT_NORMAL_WHITE, 0);
            }
            for (int i = 0; i < MAX_WARNINGS; i++) {
                if (warnings[i].in_use && current_time - warnings[i].time > TIMEOUT_MS) {
                    warnings[i].in_use = 0;
                }
            }
        }
        mouse_data.scrolled = SCROLL_NONE;
        for (int i = 1; i < MAX_CITY_SOUNDS_CHANNELS; i++) {
            channels[i].should_play = 0;
            if (channels[i].available) {
                channels[i].available = 0;
                if (channels[i].total_views >= channels[i].views_threshold) {
                    if (current_time - channels[i].last_played_time >= channels[i].delay_millis) {
                        channels[i].should_play = 1;
                    }
                }
            } else {
                channels[i].total_views = 0;
                for (int d = 0; d < 5; d++) {
                    channels[i].direction_views[d] = 0;
                }
            }
        }
        if (current_time - last_update_time > 10000) {
            // Only play 1 sound every 10 seconds
            uint32_t max_delay = 0;
            int max_sound_id = 0;
            for (int i = 1; i < MAX_CITY_SOUNDS_CHANNELS; i++) {
                if (channels[i].should_play) {
                    if (current_time - channels[i].last_played_time > max_delay) {
                        max_delay = current_time - channels[i].last_played_time;
                        max_sound_id = i;
                    }
                }
            }
            if (max_sound_id) {
                // always only one channel available... use it
                int channel = channels[max_sound_id].channel;
                int direction;
                if (channels[max_sound_id].direction_views[SOUND_DIRECTION_CENTER] > 10) {
                    direction = SOUND_DIRECTION_CENTER;
                } else if (channels[max_sound_id].direction_views[SOUND_DIRECTION_LEFT] > 10) {
                    direction = SOUND_DIRECTION_LEFT;
                } else if (channels[max_sound_id].direction_views[SOUND_DIRECTION_RIGHT] > 10) {
                    direction = SOUND_DIRECTION_RIGHT;
                } else {
                    direction = SOUND_DIRECTION_CENTER;
                }
                // allows using alternative building sounds that already exist in the game; index 3 means 4 sounds in the same group
                int sound_variety_index = 0;
                switch (channel) {
                    case SOUND_CHANNEL_CITY_HOUSE_POOR:
                    case SOUND_CHANNEL_CITY_HOUSE_MEDIUM:
                    case SOUND_CHANNEL_CITY_HOUSE_GOOD:
                    case SOUND_CHANNEL_CITY_HOUSE_POSH:
                    case SOUND_CHANNEL_CITY_GARDEN:
                    case SOUND_CHANNEL_CITY_FORT:
                    case SOUND_CHANNEL_CITY_TOWER:
                    case SOUND_CHANNEL_CITY_MARKET:
                        sound_variety_index = 3;
                        break;
                    case SOUND_CHANNEL_CITY_GRANARY:
                    case SOUND_CHANNEL_CITY_WAREHOUSE:
                    case SOUND_CHANNEL_CITY_SHIPYARD:
                    case SOUND_CHANNEL_CITY_DOCK:
                    case SOUND_CHANNEL_CITY_WHARF:
                        sound_variety_index = 2;
                        break;
                    case SOUND_CHANNEL_CITY_VACANT_LOT:
                    case SOUND_CHANNEL_CITY_HOUSE_SLUM:
                        sound_variety_index = 1;
                    default:
                        break;
                }
                if (settings[SETTINGS_CITY_SOUNDS_ENABLED].config_value && !(sound_channels[channel].chunk && Mix_Playing(channel))) {
                    int left_pan;
                    int right_pan;
                    switch (direction) {
                        case SOUND_DIRECTION_CENTER:
                            left_pan = right_pan = 100;
                            break;
                        case SOUND_DIRECTION_LEFT:
                            left_pan = 100;
                            right_pan = 0;
                            break;
                        case SOUND_DIRECTION_RIGHT:
                            left_pan = 0;
                            right_pan = 100;
                            break;
                        default:
                            left_pan = right_pan = 0;
                            break;
                    }
                    int random_factor = 0;
                    if (sound_variety_index) {
                        random_factor = rand() % sound_variety_index;
                        channel = channel + random_factor;
                    }
                    struct sound_channel_t *ch = &sound_channels[channel];
                    if (load_channel(ch)) {
                        Mix_SetPanning(channel, left_pan * 255 / 100, right_pan * 255 / 100);
                        set_channel_volume(channel, settings[SETTINGS_CITY_SOUNDS_VOLUME].config_value);
                        Mix_PlayChannel(channel, ch->chunk, 0);
                    }
                }
                last_update_time = current_time;
                channels[max_sound_id].last_played_time = current_time;
                channels[max_sound_id].total_views = 0;
                for (int d = 0; d < 5; d++) {
                    channels[max_sound_id].direction_views[d] = 0;
                }
                channels[max_sound_id].times_played++;
            }
        }
        update_screen();
    }
    return 0;
}
